'use strict';

var reactCompilerRuntime = require('react-compiler-runtime');
var behaviors = require('@primer/behaviors');
var utils = require('@primer/behaviors/utils');
var props = require('@styled-system/props');
var React = require('react');
var reactIs = require('react-is');
var useRefObjectAsForwardedRef = require('../hooks/useRefObjectAsForwardedRef.js');
var useFocusZone = require('../hooks/useFocusZone.js');
var Token = require('../Token/Token.js');
var TextInputWrapper = require('../internal/components/TextInputWrapper.js');
var UnstyledTextInput = require('../internal/components/UnstyledTextInput.js');
var TextInputInnerVisualSlot = require('../internal/components/TextInputInnerVisualSlot.js');
var TextInputWithTokens_module = require('./TextInputWithTokens.module.css.js');
var clsx = require('clsx');
var jsxRuntime = require('react/jsx-runtime');
var Text = require('../Text/Text.js');

function _interopDefault (e) { return e && e.__esModule ? e : { default: e }; }

var React__default = /*#__PURE__*/_interopDefault(React);

const overflowCountFontSizeMap = {
  small: 0,
  medium: 1,
  large: 1,
  xlarge: 2
};

// using forwardRef is important so that other components (ex. Autocomplete) can use the ref
function TextInputWithTokensInnerComponent(t0, forwardedRef) {
  const $ = reactCompilerRuntime.c(139);
  let IconComponent;
  let LeadingVisual;
  let TrailingVisual;
  let block;
  let className;
  let contrast;
  let disabled;
  let loading;
  let maxHeight;
  let maxWidthProp;
  let minWidthProp;
  let onTokenRemove;
  let rest;
  let style;
  let sxProp;
  let t1;
  let t2;
  let t3;
  let t4;
  let t5;
  let tokens;
  let validationStatus;
  let variantProp;
  let visibleTokenCount;
  let widthProp;
  if ($[0] !== t0) {
    ({
      icon: IconComponent,
      leadingVisual: LeadingVisual,
      trailingVisual: TrailingVisual,
      loading,
      loaderPosition: t1,
      contrast,
      className,
      block,
      disabled,
      sx: sxProp,
      tokens,
      onTokenRemove,
      tokenComponent: t2,
      preventTokenWrapping: t3,
      size: t4,
      hideTokenRemoveButtons: t5,
      maxHeight,
      width: widthProp,
      minWidth: minWidthProp,
      maxWidth: maxWidthProp,
      validationStatus,
      variant: variantProp,
      visibleTokenCount,
      style,
      ...rest
    } = t0);
    $[0] = t0;
    $[1] = IconComponent;
    $[2] = LeadingVisual;
    $[3] = TrailingVisual;
    $[4] = block;
    $[5] = className;
    $[6] = contrast;
    $[7] = disabled;
    $[8] = loading;
    $[9] = maxHeight;
    $[10] = maxWidthProp;
    $[11] = minWidthProp;
    $[12] = onTokenRemove;
    $[13] = rest;
    $[14] = style;
    $[15] = sxProp;
    $[16] = t1;
    $[17] = t2;
    $[18] = t3;
    $[19] = t4;
    $[20] = t5;
    $[21] = tokens;
    $[22] = validationStatus;
    $[23] = variantProp;
    $[24] = visibleTokenCount;
    $[25] = widthProp;
  } else {
    IconComponent = $[1];
    LeadingVisual = $[2];
    TrailingVisual = $[3];
    block = $[4];
    className = $[5];
    contrast = $[6];
    disabled = $[7];
    loading = $[8];
    maxHeight = $[9];
    maxWidthProp = $[10];
    minWidthProp = $[11];
    onTokenRemove = $[12];
    rest = $[13];
    style = $[14];
    sxProp = $[15];
    t1 = $[16];
    t2 = $[17];
    t3 = $[18];
    t4 = $[19];
    t5 = $[20];
    tokens = $[21];
    validationStatus = $[22];
    variantProp = $[23];
    visibleTokenCount = $[24];
    widthProp = $[25];
  }
  const loaderPosition = t1 === undefined ? "auto" : t1;
  const TokenComponent = t2 === undefined ? Token : t2;
  const preventTokenWrapping = t3 === undefined ? false : t3;
  const size = t4 === undefined ? "xlarge" : t4;
  const hideTokenRemoveButtons = t5 === undefined ? false : t5;
  let t6;
  if ($[26] !== rest) {
    t6 = props.omit(rest);
    $[26] = rest;
    $[27] = t6;
  } else {
    t6 = $[27];
  }
  let inputPropsRest;
  let onBlur;
  let onFocus;
  let onKeyDown;
  if ($[28] !== t6) {
    ({
      onBlur,
      onFocus,
      onKeyDown,
      ...inputPropsRest
    } = t6);
    $[28] = t6;
    $[29] = inputPropsRest;
    $[30] = onBlur;
    $[31] = onFocus;
    $[32] = onKeyDown;
  } else {
    inputPropsRest = $[29];
    onBlur = $[30];
    onFocus = $[31];
    onKeyDown = $[32];
  }
  const ref = React.useRef(null);
  useRefObjectAsForwardedRef.useRefObjectAsForwardedRef(forwardedRef, ref);
  const [selectedTokenIndex, setSelectedTokenIndex] = React.useState();
  const [tokensAreTruncated, setTokensAreTruncated] = React.useState(Boolean(visibleTokenCount));
  let t7;
  if ($[33] !== selectedTokenIndex) {
    t7 = [selectedTokenIndex];
    $[33] = selectedTokenIndex;
    $[34] = t7;
  } else {
    t7 = $[34];
  }
  const {
    containerRef: t8
  } = useFocusZone.useFocusZone({
    focusOutBehavior: "wrap",
    bindKeys: behaviors.FocusKeys.ArrowHorizontal | behaviors.FocusKeys.HomeAndEnd,
    focusableElementFilter: _temp,
    getNextFocusable: direction => {
      var _containerRef$current;
      if (!selectedTokenIndex && selectedTokenIndex !== 0) {
        return;
      }
      let nextIndex = selectedTokenIndex + 1;
      if (direction === "next") {
        nextIndex = nextIndex + 1;
      }
      if (direction === "previous") {
        nextIndex = nextIndex - 1;
      }
      if (nextIndex > tokens.length || nextIndex < 1) {
        return ref.current || undefined;
      }
      return (_containerRef$current = containerRef.current) === null || _containerRef$current === void 0 ? void 0 : _containerRef$current.children[nextIndex];
    }
  }, t7);
  const containerRef = t8;
  let t9;
  if ($[35] !== containerRef || $[36] !== onTokenRemove || $[37] !== selectedTokenIndex) {
    t9 = tokenId => {
      onTokenRemove(tokenId);
      setTimeout(() => {
        var _containerRef$current2, _containerRef$current3;
        const nextElementToFocus = (_containerRef$current2 = containerRef.current) === null || _containerRef$current2 === void 0 ? void 0 : _containerRef$current2.children[selectedTokenIndex || 0];
        const firstFocusable = nextElementToFocus && utils.isFocusable(nextElementToFocus) ? nextElementToFocus : Array.from(((_containerRef$current3 = containerRef.current) === null || _containerRef$current3 === void 0 ? void 0 : _containerRef$current3.children) || []).find(_temp2);
        if (firstFocusable) {
          firstFocusable.focus();
        } else {
          var _ref$current;
          (_ref$current = ref.current) === null || _ref$current === void 0 ? void 0 : _ref$current.focus();
        }
      }, 0);
    };
    $[35] = containerRef;
    $[36] = onTokenRemove;
    $[37] = selectedTokenIndex;
    $[38] = t9;
  } else {
    t9 = $[38];
  }
  const handleTokenRemove = t9;
  let t10;
  if ($[39] !== disabled) {
    t10 = tokenIndex => () => {
      if (!disabled) {
        setSelectedTokenIndex(tokenIndex);
      }
    };
    $[39] = disabled;
    $[40] = t10;
  } else {
    t10 = $[40];
  }
  const handleTokenFocus = t10;
  let t11;
  if ($[41] !== containerRef || $[42] !== visibleTokenCount) {
    t11 = () => {
      setSelectedTokenIndex(undefined);
      setTimeout(() => {
        var _containerRef$current4;
        if (!((_containerRef$current4 = containerRef.current) !== null && _containerRef$current4 !== void 0 && _containerRef$current4.contains(document.activeElement)) && visibleTokenCount) {
          setTokensAreTruncated(true);
        }
      }, 0);
    };
    $[41] = containerRef;
    $[42] = visibleTokenCount;
    $[43] = t11;
  } else {
    t11 = $[43];
  }
  const handleTokenBlur = t11;
  let t12;
  if ($[44] === Symbol.for("react.memo_cache_sentinel")) {
    t12 = event => {
      if (event.key === "Escape") {
        var _ref$current2;
        (_ref$current2 = ref.current) === null || _ref$current2 === void 0 ? void 0 : _ref$current2.focus();
      }
    };
    $[44] = t12;
  } else {
    t12 = $[44];
  }
  const handleTokenKeyUp = t12;
  let t13;
  if ($[45] !== onFocus || $[46] !== visibleTokenCount) {
    t13 = event_0 => {
      onFocus && onFocus(event_0);
      setSelectedTokenIndex(undefined);
      visibleTokenCount && setTokensAreTruncated(false);
    };
    $[45] = onFocus;
    $[46] = visibleTokenCount;
    $[47] = t13;
  } else {
    t13 = $[47];
  }
  const handleInputFocus = t13;
  let t14;
  if ($[48] !== containerRef || $[49] !== onBlur || $[50] !== visibleTokenCount) {
    t14 = event_1 => {
      onBlur && onBlur(event_1);
      setTimeout(() => {
        var _containerRef$current5;
        if (!((_containerRef$current5 = containerRef.current) !== null && _containerRef$current5 !== void 0 && _containerRef$current5.contains(document.activeElement)) && visibleTokenCount) {
          setTokensAreTruncated(true);
        }
      }, 0);
    };
    $[48] = containerRef;
    $[49] = onBlur;
    $[50] = visibleTokenCount;
    $[51] = t14;
  } else {
    t14 = $[51];
  }
  const handleInputBlur = t14;
  let t15;
  if ($[52] !== handleTokenRemove || $[53] !== onKeyDown || $[54] !== tokens) {
    t15 = e => {
      var _ref$current3;
      if (onKeyDown) {
        onKeyDown(e);
      }
      if ((_ref$current3 = ref.current) !== null && _ref$current3 !== void 0 && _ref$current3.value) {
        return;
      }
      const lastToken = tokens[tokens.length - 1];
      if (e.key === "Backspace" && lastToken) {
        handleTokenRemove(lastToken.id);
        if (ref.current) {
          ref.current.value = `${lastToken.text} `;
        }
        setTimeout(() => {
          var _ref$current4;
          (_ref$current4 = ref.current) === null || _ref$current4 === void 0 ? void 0 : _ref$current4.select();
        }, 0);
      }
    };
    $[52] = handleTokenRemove;
    $[53] = onKeyDown;
    $[54] = tokens;
    $[55] = t15;
  } else {
    t15 = $[55];
  }
  const handleInputKeyDown = t15;
  let t16;
  if ($[56] === Symbol.for("react.memo_cache_sentinel")) {
    t16 = () => {
      var _ref$current5;
      (_ref$current5 = ref.current) === null || _ref$current5 === void 0 ? void 0 : _ref$current5.focus();
    };
    $[56] = t16;
  } else {
    t16 = $[56];
  }
  const focusInput = t16;
  const preventTokenClickPropagation = _temp3;
  let t17;
  if ($[57] !== tokens || $[58] !== tokensAreTruncated || $[59] !== visibleTokenCount) {
    t17 = tokensAreTruncated ? tokens.slice(0, visibleTokenCount) : tokens;
    $[57] = tokens;
    $[58] = tokensAreTruncated;
    $[59] = visibleTokenCount;
    $[60] = t17;
  } else {
    t17 = $[60];
  }
  const visibleTokens = t17;
  let t18;
  if ($[61] === Symbol.for("react.memo_cache_sentinel")) {
    t18 = {
      small: "small",
      medium: "small",
      large: "medium",
      xlarge: "medium"
    };
    $[61] = t18;
  } else {
    t18 = $[61];
  }
  const inputSizeMap = t18;
  const showLeadingLoadingIndicator = loading && (loaderPosition === "leading" || Boolean(LeadingVisual && loaderPosition !== "trailing"));
  const showTrailingLoadingIndicator = loading && (loaderPosition === "trailing" || loaderPosition === "auto" && !LeadingVisual);
  const t19 = Boolean(LeadingVisual || showLeadingLoadingIndicator);
  const t20 = Boolean(TrailingVisual || showTrailingLoadingIndicator);
  const t21 = inputSizeMap[size];
  const t22 = Boolean(preventTokenWrapping || maxHeight) || undefined;
  let t23;
  if ($[62] !== className) {
    t23 = clsx.clsx(className, TextInputWithTokens_module.TextInputWrapper);
    $[62] = className;
    $[63] = t23;
  } else {
    t23 = $[63];
  }
  let t24;
  if ($[64] !== maxHeight || $[65] !== style) {
    t24 = maxHeight ? {
      maxHeight,
      ...style
    } : style;
    $[64] = maxHeight;
    $[65] = style;
    $[66] = t24;
  } else {
    t24 = $[66];
  }
  let t25;
  if ($[67] !== IconComponent || $[68] !== LeadingVisual) {
    t25 = IconComponent && !LeadingVisual && /*#__PURE__*/jsxRuntime.jsx(IconComponent, {
      className: "TextInput-icon"
    });
    $[67] = IconComponent;
    $[68] = LeadingVisual;
    $[69] = t25;
  } else {
    t25 = $[69];
  }
  const t26 = typeof loading === "boolean";
  let t27;
  if ($[70] !== LeadingVisual) {
    t27 = typeof LeadingVisual !== "string" && reactIs.isValidElementType(LeadingVisual) ? /*#__PURE__*/jsxRuntime.jsx(LeadingVisual, {}) : LeadingVisual;
    $[70] = LeadingVisual;
    $[71] = t27;
  } else {
    t27 = $[71];
  }
  let t28;
  if ($[72] !== showLeadingLoadingIndicator || $[73] !== t26 || $[74] !== t27) {
    t28 = /*#__PURE__*/jsxRuntime.jsx(TextInputInnerVisualSlot, {
      hasLoadingIndicator: t26,
      visualPosition: "leading",
      showLoadingIndicator: showLeadingLoadingIndicator,
      children: t27
    });
    $[72] = showLeadingLoadingIndicator;
    $[73] = t26;
    $[74] = t27;
    $[75] = t28;
  } else {
    t28 = $[75];
  }
  const t29 = containerRef;
  const t30 = validationStatus === "error" ? "true" : "false";
  let t31;
  if ($[76] !== disabled || $[77] !== handleInputBlur || $[78] !== handleInputFocus || $[79] !== handleInputKeyDown || $[80] !== inputPropsRest || $[81] !== t30) {
    t31 = /*#__PURE__*/jsxRuntime.jsx("div", {
      className: TextInputWithTokens_module.InputWrapper,
      children: /*#__PURE__*/jsxRuntime.jsx(UnstyledTextInput, {
        ref: ref,
        disabled: disabled,
        onFocus: handleInputFocus,
        onBlur: handleInputBlur,
        onKeyDown: handleInputKeyDown,
        type: "text",
        className: TextInputWithTokens_module.UnstyledTextInput,
        "aria-invalid": t30,
        ...inputPropsRest
      })
    });
    $[76] = disabled;
    $[77] = handleInputBlur;
    $[78] = handleInputFocus;
    $[79] = handleInputKeyDown;
    $[80] = inputPropsRest;
    $[81] = t30;
    $[82] = t31;
  } else {
    t31 = $[82];
  }
  let t32;
  if ($[83] !== TokenComponent || $[84] !== disabled || $[85] !== handleTokenBlur || $[86] !== handleTokenFocus || $[87] !== handleTokenRemove || $[88] !== hideTokenRemoveButtons || $[89] !== selectedTokenIndex || $[90] !== size || $[91] !== visibleTokens) {
    let t33;
    if ($[93] !== TokenComponent || $[94] !== disabled || $[95] !== handleTokenBlur || $[96] !== handleTokenFocus || $[97] !== handleTokenRemove || $[98] !== hideTokenRemoveButtons || $[99] !== selectedTokenIndex || $[100] !== size) {
      t33 = (t34, i) => {
        const {
          id,
          ...tokenRest
        } = t34;
        return /*#__PURE__*/jsxRuntime.jsx(TokenComponent, {
          disabled: disabled,
          onFocus: handleTokenFocus(i),
          onBlur: handleTokenBlur,
          onKeyUp: handleTokenKeyUp,
          onClick: preventTokenClickPropagation,
          isSelected: selectedTokenIndex === i,
          onRemove: () => {
            handleTokenRemove(id);
          },
          hideRemoveButton: disabled || hideTokenRemoveButtons,
          size: size,
          tabIndex: 0,
          ...tokenRest
        }, id);
      };
      $[93] = TokenComponent;
      $[94] = disabled;
      $[95] = handleTokenBlur;
      $[96] = handleTokenFocus;
      $[97] = handleTokenRemove;
      $[98] = hideTokenRemoveButtons;
      $[99] = selectedTokenIndex;
      $[100] = size;
      $[101] = t33;
    } else {
      t33 = $[101];
    }
    t32 = visibleTokens.map(t33);
    $[83] = TokenComponent;
    $[84] = disabled;
    $[85] = handleTokenBlur;
    $[86] = handleTokenFocus;
    $[87] = handleTokenRemove;
    $[88] = hideTokenRemoveButtons;
    $[89] = selectedTokenIndex;
    $[90] = size;
    $[91] = visibleTokens;
    $[92] = t32;
  } else {
    t32 = $[92];
  }
  let t33;
  if ($[102] !== size || $[103] !== tokens || $[104] !== tokensAreTruncated || $[105] !== visibleTokens.length) {
    t33 = tokensAreTruncated && tokens.length - visibleTokens.length ? /*#__PURE__*/jsxRuntime.jsxs(Text, {
      color: "fg.muted",
      fontSize: overflowCountFontSizeMap[size],
      children: ["+", tokens.length - visibleTokens.length]
    }) : null;
    $[102] = size;
    $[103] = tokens;
    $[104] = tokensAreTruncated;
    $[105] = visibleTokens.length;
    $[106] = t33;
  } else {
    t33 = $[106];
  }
  let t34;
  if ($[107] !== preventTokenWrapping || $[108] !== t29 || $[109] !== t31 || $[110] !== t32 || $[111] !== t33) {
    t34 = /*#__PURE__*/jsxRuntime.jsxs("div", {
      ref: t29,
      className: TextInputWithTokens_module.Container,
      "data-prevent-token-wrapping": preventTokenWrapping,
      children: [t31, t32, t33]
    });
    $[107] = preventTokenWrapping;
    $[108] = t29;
    $[109] = t31;
    $[110] = t32;
    $[111] = t33;
    $[112] = t34;
  } else {
    t34 = $[112];
  }
  const t35 = typeof loading === "boolean";
  let t36;
  if ($[113] !== TrailingVisual) {
    t36 = typeof TrailingVisual !== "string" && reactIs.isValidElementType(TrailingVisual) ? /*#__PURE__*/jsxRuntime.jsx(TrailingVisual, {}) : TrailingVisual;
    $[113] = TrailingVisual;
    $[114] = t36;
  } else {
    t36 = $[114];
  }
  let t37;
  if ($[115] !== showTrailingLoadingIndicator || $[116] !== t35 || $[117] !== t36) {
    t37 = /*#__PURE__*/jsxRuntime.jsx(TextInputInnerVisualSlot, {
      hasLoadingIndicator: t35,
      visualPosition: "trailing",
      showLoadingIndicator: showTrailingLoadingIndicator,
      children: t36
    });
    $[115] = showTrailingLoadingIndicator;
    $[116] = t35;
    $[117] = t36;
    $[118] = t37;
  } else {
    t37 = $[118];
  }
  let t38;
  if ($[119] !== block || $[120] !== contrast || $[121] !== disabled || $[122] !== maxWidthProp || $[123] !== minWidthProp || $[124] !== sxProp || $[125] !== t19 || $[126] !== t20 || $[127] !== t21 || $[128] !== t22 || $[129] !== t23 || $[130] !== t24 || $[131] !== t25 || $[132] !== t28 || $[133] !== t34 || $[134] !== t37 || $[135] !== validationStatus || $[136] !== variantProp || $[137] !== widthProp) {
    t38 = /*#__PURE__*/jsxRuntime.jsxs(TextInputWrapper.TextInputWrapper, {
      block: block,
      contrast: contrast,
      disabled: disabled,
      hasLeadingVisual: t19,
      hasTrailingVisual: t20,
      width: widthProp,
      minWidth: minWidthProp,
      maxWidth: maxWidthProp,
      size: t21,
      validationStatus: validationStatus,
      variant: variantProp,
      onClick: focusInput,
      "data-token-wrapping": t22,
      className: t23,
      style: t24,
      sx: sxProp,
      children: [t25, t28, t34, t37]
    });
    $[119] = block;
    $[120] = contrast;
    $[121] = disabled;
    $[122] = maxWidthProp;
    $[123] = minWidthProp;
    $[124] = sxProp;
    $[125] = t19;
    $[126] = t20;
    $[127] = t21;
    $[128] = t22;
    $[129] = t23;
    $[130] = t24;
    $[131] = t25;
    $[132] = t28;
    $[133] = t34;
    $[134] = t37;
    $[135] = validationStatus;
    $[136] = variantProp;
    $[137] = widthProp;
    $[138] = t38;
  } else {
    t38 = $[138];
  }
  return t38;
}
function _temp3(event_2) {
  event_2.stopPropagation();
}
function _temp2(el) {
  return utils.isFocusable(el);
}
function _temp(element) {
  return !element.getAttributeNames().includes("aria-hidden");
}
const TextInputWithTokens = /*#__PURE__*/React__default.default.forwardRef(TextInputWithTokensInnerComponent);
TextInputWithTokens.displayName = 'TextInputWithTokens';

module.exports = TextInputWithTokens;
