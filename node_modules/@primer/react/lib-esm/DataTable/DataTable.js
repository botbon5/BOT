import { c } from 'react-compiler-runtime';
import { useTable } from './useTable.js';
import { TableRow, TableCell, TableSortHeader, TableHeader, TableHead, TableBody, Table } from './Table.js';
import { jsx, jsxs } from 'react/jsx-runtime';

function defaultGetRowId(row) {
  return row.id;
}
function DataTable(t0) {
  const $ = c(26);
  const {
    "aria-labelledby": labelledby,
    "aria-describedby": describedby,
    cellPadding,
    columns,
    data,
    initialSortColumn,
    initialSortDirection,
    getRowId: t1,
    onToggleSort
  } = t0;
  const getRowId = t1 === undefined ? defaultGetRowId : t1;
  let t2;
  if ($[0] !== columns || $[1] !== data || $[2] !== getRowId || $[3] !== initialSortColumn || $[4] !== initialSortDirection) {
    t2 = {
      data,
      columns,
      initialSortColumn,
      initialSortDirection,
      getRowId
    };
    $[0] = columns;
    $[1] = data;
    $[2] = getRowId;
    $[3] = initialSortColumn;
    $[4] = initialSortDirection;
    $[5] = t2;
  } else {
    t2 = $[5];
  }
  const {
    headers,
    rows,
    actions,
    gridTemplateColumns
  } = useTable(t2);
  let t3;
  if ($[6] !== actions || $[7] !== headers || $[8] !== onToggleSort) {
    let t4;
    if ($[10] !== actions || $[11] !== onToggleSort) {
      t4 = header => {
        if (header.isSortable()) {
          return /*#__PURE__*/jsx(TableSortHeader, {
            align: header.column.align,
            direction: header.getSortDirection(),
            onToggleSort: () => {
              const nextDirection = header.getSortDirection() === "ASC" ? "DESC" : "ASC";
              actions.sortBy(header);
              onToggleSort === null || onToggleSort === void 0 ? void 0 : onToggleSort(header.id, nextDirection);
            },
            children: typeof header.column.header === "string" ? header.column.header : header.column.header()
          }, header.id);
        }
        return /*#__PURE__*/jsx(TableHeader, {
          align: header.column.align,
          children: typeof header.column.header === "string" ? header.column.header : header.column.header()
        }, header.id);
      };
      $[10] = actions;
      $[11] = onToggleSort;
      $[12] = t4;
    } else {
      t4 = $[12];
    }
    t3 = headers.map(t4);
    $[6] = actions;
    $[7] = headers;
    $[8] = onToggleSort;
    $[9] = t3;
  } else {
    t3 = $[9];
  }
  let t4;
  if ($[13] !== t3) {
    t4 = /*#__PURE__*/jsx(TableHead, {
      children: /*#__PURE__*/jsx(TableRow, {
        children: t3
      })
    });
    $[13] = t3;
    $[14] = t4;
  } else {
    t4 = $[14];
  }
  let t5;
  if ($[15] !== rows) {
    t5 = rows.map(_temp);
    $[15] = rows;
    $[16] = t5;
  } else {
    t5 = $[16];
  }
  let t6;
  if ($[17] !== t5) {
    t6 = /*#__PURE__*/jsx(TableBody, {
      children: t5
    });
    $[17] = t5;
    $[18] = t6;
  } else {
    t6 = $[18];
  }
  let t7;
  if ($[19] !== cellPadding || $[20] !== describedby || $[21] !== gridTemplateColumns || $[22] !== labelledby || $[23] !== t4 || $[24] !== t6) {
    t7 = /*#__PURE__*/jsxs(Table, {
      "aria-labelledby": labelledby,
      "aria-describedby": describedby,
      cellPadding: cellPadding,
      gridTemplateColumns: gridTemplateColumns,
      children: [t4, t6]
    });
    $[19] = cellPadding;
    $[20] = describedby;
    $[21] = gridTemplateColumns;
    $[22] = labelledby;
    $[23] = t4;
    $[24] = t6;
    $[25] = t7;
  } else {
    t7 = $[25];
  }
  return t7;
}
function _temp(row) {
  return /*#__PURE__*/jsx(TableRow, {
    children: row.getCells().map(cell => /*#__PURE__*/jsx(TableCell, {
      scope: cell.rowHeader ? "row" : undefined,
      align: cell.column.align,
      children: cell.column.renderCell ? cell.column.renderCell(row.getValue()) : cell.getValue()
    }, cell.id))
  }, row.id);
}
_temp.displayName = "_temp";

export { DataTable };
