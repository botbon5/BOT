import { c } from 'react-compiler-runtime';
import { useRef, useEffect } from 'react';

/**
 * Create a callback that can be used within an effect without re-running the
 * effect when the values used change. The callback passed to this hook will
 * always see the latest snapshot of values that it uses and does not need to
 * use a dependency array.
 */
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function useEffectCallback(callback) {
  const $ = c(4);
  const savedCallback = useRef(callback);
  let t0;
  let t1;
  if ($[0] !== callback) {
    t0 = () => {
      savedCallback.current = callback;
    };
    t1 = [callback];
    $[0] = callback;
    $[1] = t0;
    $[2] = t1;
  } else {
    t0 = $[1];
    t1 = $[2];
  }
  useEffect(t0, t1);
  let t2;
  if ($[3] === Symbol.for("react.memo_cache_sentinel")) {
    t2 = (...t3) => {
      const args = t3;
      return savedCallback.current(...args);
    };
    $[3] = t2;
  } else {
    t2 = $[3];
  }
  return t2;
}

export { useEffectCallback };
