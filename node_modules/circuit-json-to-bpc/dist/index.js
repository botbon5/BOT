var __defProp = Object.defineProperty;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {enumerable: true, configurable: true, writable: true, value}) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};

// lib/convertCircuitJsonToBpc.ts
import {cju as cju3} from "@tscircuit/circuit-json-util";

// lib/getUnitVecFromAnchorSide.ts
var getUnitVecFromAnchorSide = (anchorSide) => {
  switch (anchorSide) {
    case "left":
      return {x: -1, y: 0};
    case "right":
      return {x: 1, y: 0};
    case "top":
      return {x: 0, y: 1};
    case "bottom":
      return {x: 0, y: -1};
  }
};

// lib/getReadableIdMap.ts
import {cju} from "@tscircuit/circuit-json-util";
var getReadableIdMap = (circuitJson) => {
  var _a, _b;
  const schComps = cju(circuitJson).schematic_component.list();
  const schLabels = cju(circuitJson).schematic_net_label.list();
  const schPorts = cju(circuitJson).schematic_port.list();
  const readableIdMap = {};
  for (const schComp of schComps) {
    const srcComp = cju(circuitJson).source_component.get(schComp.source_component_id);
    readableIdMap[schComp.schematic_component_id] = srcComp == null ? void 0 : srcComp.name;
  }
  for (const schLabel of schLabels) {
    const srcNet = cju(circuitJson).source_net.get(schLabel.source_net_id);
    if (!(srcNet == null ? void 0 : srcNet.name))
      continue;
    let index = 0;
    while (Object.values(readableIdMap).includes(`NL_${srcNet.name}${index}`)) {
      index++;
    }
    readableIdMap[schLabel.schematic_net_label_id] = `NL_${srcNet.name}${index}`;
  }
  for (const schPort of schPorts) {
    const srcPort = cju(circuitJson).source_port.get(schPort.source_port_id);
    if (!srcPort)
      continue;
    const srcComp = cju(circuitJson).source_component.get(srcPort.source_component_id);
    if (!(srcComp == null ? void 0 : srcComp.name))
      continue;
    const readableName = `${srcComp.name}_${(_b = (_a = srcPort == null ? void 0 : srcPort.name) != null ? _a : srcPort == null ? void 0 : srcPort.pin_number) != null ? _b : ""}`;
    readableIdMap[schPort.schematic_port_id] = readableName;
  }
  return readableIdMap;
};

// lib/generateImplicitNetLabels.ts
import {cju as cju2, oppositeSide} from "@tscircuit/circuit-json-util";
var generateImplicitNetLabels = (circuitJson) => {
  var _a;
  const db = cju2(circuitJson);
  const existingLabels = new Set(db.schematic_net_label.list().map((nl) => {
    var _a2, _b, _c, _d;
    return `${(_b = (_a2 = nl.anchor_position) == null ? void 0 : _a2.x) != null ? _b : nl.center.x},${(_d = (_c = nl.anchor_position) == null ? void 0 : _c.y) != null ? _d : nl.center.y}`;
  }));
  const newLabels = [];
  for (const sp of db.schematic_port.list()) {
    const key = `${sp.center.x},${sp.center.y}`;
    if (existingLabels.has(key))
      continue;
    const srcPort = db.source_port.get(sp.source_port_id);
    if (!srcPort)
      continue;
    const srcNet = db.source_net.getWhere({
      subcircuit_connectivity_map_key: srcPort.subcircuit_connectivity_map_key
    });
    if (!srcNet)
      continue;
    const srcTrace = db.source_trace.list().find((st) => {
      var _a2;
      return (_a2 = st.connected_source_port_ids) == null ? void 0 : _a2.includes(sp.source_port_id);
    });
    const schTrace = db.schematic_trace.getWhere({
      source_trace_id: srcTrace == null ? void 0 : srcTrace.source_trace_id
    });
    const schematic_net_label_id = `netlabel_for_${sp.schematic_port_id}`;
    const schematic_net_label = {
      type: "schematic_net_label",
      schematic_net_label_id,
      schematic_port_id: sp.schematic_port_id,
      text: srcNet.name,
      source_net_id: srcNet.source_net_id,
      source_trace_id: srcTrace == null ? void 0 : srcTrace.source_trace_id,
      schematic_trace_id: schTrace == null ? void 0 : schTrace.schematic_trace_id,
      anchor_position: __spreadValues({}, sp.center),
      center: __spreadValues({}, sp.center),
      anchor_side: oppositeSide((_a = sp.facing_direction) != null ? _a : "right")
    };
    newLabels.push(schematic_net_label);
  }
  return newLabels;
};

// lib/convertCircuitJsonToBpc.ts
var convertCircuitJsonToBpc = (circuitJson, opts = {}) => {
  const g = {
    boxes: [],
    pins: []
  };
  const schComps = cju3(circuitJson).schematic_component.list();
  let schLabels = cju3(circuitJson).schematic_net_label.list();
  if (opts.inferNetLabels) {
    schLabels = schLabels.concat(generateImplicitNetLabels(circuitJson));
  }
  const readableIdMap = opts.useReadableIds ? getReadableIdMap(circuitJson) : {};
  const maybeMakeIdReadable = (id) => {
    if (!opts.useReadableIds)
      return id;
    if (readableIdMap[id])
      return readableIdMap[id];
    return id;
  };
  let disconnectedCounter = 0;
  for (const schComp of schComps) {
    const box = {
      boxId: maybeMakeIdReadable(schComp.schematic_component_id),
      kind: "floating",
      center: schComp.center
    };
    g.boxes.push(box);
    const centerPin = {
      pinId: `${maybeMakeIdReadable(schComp.schematic_component_id)}_center`,
      color: "component_center",
      networkId: `center_${schComp.schematic_component_id}`,
      offset: {x: 0, y: 0},
      boxId: maybeMakeIdReadable(schComp.schematic_component_id)
    };
    g.pins.push(centerPin);
    const schPorts = cju3(circuitJson).schematic_port.list({
      schematic_component_id: schComp.schematic_component_id
    });
    for (const schPort of schPorts) {
      const srcPort = cju3(circuitJson).source_port.get(schPort.source_port_id);
      let networkId = srcPort == null ? void 0 : srcPort.subcircuit_connectivity_map_key;
      let color = "normal";
      if (networkId) {
        const srcNet = cju3(circuitJson).source_net.getWhere({
          subcircuit_connectivity_map_key: srcPort == null ? void 0 : srcPort.subcircuit_connectivity_map_key
        });
        if (srcNet && (srcNet.is_power || srcNet.name.startsWith("V"))) {
          color = "vcc";
        }
        if (srcNet && (srcNet.is_ground || srcNet.name.startsWith("GND"))) {
          color = "gnd";
        }
      } else {
        networkId = `disconnected-${disconnectedCounter++}`;
        color = "not_connected";
      }
      const pin = {
        pinId: maybeMakeIdReadable(schPort.schematic_port_id),
        color,
        networkId,
        offset: {
          x: schPort.center.x - box.center.x,
          y: schPort.center.y - box.center.y
        },
        boxId: maybeMakeIdReadable(schComp.schematic_component_id)
      };
      g.pins.push(pin);
    }
  }
  for (const schLabel of schLabels) {
    const srcNet = cju3(circuitJson).source_net.get(schLabel.source_net_id);
    let networkId = srcNet == null ? void 0 : srcNet.subcircuit_connectivity_map_key;
    let color = "normal";
    if (networkId) {
      if (srcNet && (srcNet.is_power || srcNet.name.startsWith("V"))) {
        color = "vcc";
      }
      if (srcNet && (srcNet.is_ground || srcNet.name.startsWith("GND"))) {
        color = "gnd";
      }
    } else {
      networkId = `disconnected-${disconnectedCounter++}`;
      color = "not_connected";
    }
    const netLabelDir = getUnitVecFromAnchorSide(schLabel.anchor_side);
    const netLabelCenter = {
      x: schLabel.anchor_position.x - netLabelDir.x * schLabel.text.length * 0.18 * 0.5,
      y: schLabel.anchor_position.y - netLabelDir.y * 0.18
    };
    let offset = {x: 0, y: 0};
    if (schLabel.anchor_position) {
      offset = {
        x: schLabel.anchor_position.x - netLabelCenter.x,
        y: schLabel.anchor_position.y - netLabelCenter.y
      };
    }
    const box = {
      boxId: maybeMakeIdReadable(schLabel.schematic_net_label_id),
      kind: "fixed",
      center: netLabelCenter,
      boxAttributes: {
        is_net_label: true,
        source_net_id: schLabel.source_net_id,
        source_trace_id: schLabel.source_trace_id
      }
    };
    g.boxes.push(box);
    const pin = {
      pinId: `${maybeMakeIdReadable(schLabel.schematic_net_label_id)}_pin`,
      boxId: maybeMakeIdReadable(schLabel.schematic_net_label_id),
      networkId,
      color,
      offset
    };
    g.pins.push(pin);
    g.pins.push({
      pinId: `${maybeMakeIdReadable(schLabel.schematic_net_label_id)}_center`,
      boxId: maybeMakeIdReadable(schLabel.schematic_net_label_id),
      networkId: `${maybeMakeIdReadable(schLabel.schematic_net_label_id)}_center`,
      color: "netlabel_center",
      offset: {x: 0, y: 0}
    });
  }
  return g;
};
export {
  convertCircuitJsonToBpc,
  generateImplicitNetLabels
};
