"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// lib/index.ts
var lib_exports = {};
__export(lib_exports, {
  executeJscadOperations: () => executeJscadOperations,
  jscadPlanner: () => jscadPlanner
});
module.exports = __toCommonJS(lib_exports);

// lib/jscad-planner.ts
var jscadPlanner = {
  booleans: {
    intersect: (...shapes) => ({
      type: "intersect",
      shapes
    }),
    subtract: (...shapes) => ({
      type: "subtract",
      shapes
    }),
    union: (...shapes) => ({
      type: "union",
      shapes
    })
  },
  hulls: {
    hull: (...shapes) => ({
      type: "hull",
      shapes: shapes.flat()
    }),
    hullChain: (...shapes) => ({
      type: "hullChain",
      shapes: shapes.flat()
    })
  },
  colors: {
    colorize: (color, shape) => ({
      type: "colorize",
      color,
      shape
    })
  },
  primitives: {
    cube: (options) => ({
      type: "cube",
      ...options
    }),
    sphere: (options) => ({
      type: "sphere",
      ...options
    }),
    cylinder: (options) => ({
      type: "cylinder",
      ...options
    }),
    polygon: (options) => ({
      type: "polygon",
      ...options
    }),
    cuboid: (options) => ({
      type: "cuboid",
      ...options
    }),
    roundedCuboid: (options) => ({
      type: "roundedCuboid",
      ...options
    })
  },
  transforms: {
    rotate: (angles, shape) => ({
      type: "rotate",
      angles,
      shape
    }),
    scale: (factors, shape) => ({
      type: "scale",
      factors,
      shape
    }),
    translate: (vector, shape) => ({
      type: "translate",
      vector,
      shape
    })
  },
  extrusions: {
    extrudeLinear: (options, shape) => ({
      type: "extrudeLinear",
      options,
      shape
    }),
    extrudeRotate: (options, shape) => ({
      type: "extrudeRotate",
      options,
      shape
    })
  },
  maths: {
    vec2: {
      create: (x, y) => [x, y],
      fromValues: (x, y) => [x, y]
    },
    vec3: {
      create: (x, y, z) => [x, y, z],
      fromValues: (x, y, z) => [x, y, z]
    }
  },
  geometries: {
    geom2: {
      create: (points) => ({
        type: "createGeom2",
        points
      })
    },
    geom3: {
      create: (polygons) => ({
        type: "createGeom3",
        polygons
      })
    },
    path2: {
      create: (points) => ({
        type: "createPath2",
        points
      })
    }
  },
  measurements: {
    measureBoundingBox: (shape) => ({
      type: "measureBoundingBox",
      shape
    }),
    measureArea: (shape) => ({
      type: "measureArea",
      shape
    }),
    measureVolume: (shape) => ({
      type: "measureVolume",
      shape
    })
  },
  utils: {
    degToRad: (degrees) => degrees * Math.PI / 180,
    radToDeg: (radians) => radians * 180 / Math.PI
  }
};

// lib/execute-jscad-operations.ts
var executeJscadOperations = (jscad, operation) => {
  if (Array.isArray(operation) && operation.length === 1) {
    return executeJscadOperations(jscad, operation[0]);
  }
  if (Array.isArray(operation)) {
    throw new Error(
      `executeJscadOperations currently doesn't support Array<JscadOperation>, try adding a root union or or executing each element individually`
    );
  }
  const recurse = (op) => executeJscadOperations(jscad, op);
  const { type, ...params } = operation;
  switch (type) {
    case "intersect":
      return jscad.booleans.intersect(...operation.shapes.map(recurse));
    case "subtract":
      return jscad.booleans.subtract(...operation.shapes.map(recurse));
    case "union":
      return jscad.booleans.union(...operation.shapes.map(recurse));
    case "hull":
      return jscad.hulls.hull(...operation.shapes.map(recurse));
    case "hullChain":
      return jscad.hulls.hullChain(...operation.shapes.map(recurse));
    case "colorize":
      return jscad.colors.colorize(operation.color, recurse(operation.shape));
    case "cube":
      return jscad.primitives.cube(params);
    case "sphere":
      return jscad.primitives.sphere(params);
    case "cylinder":
      return jscad.primitives.cylinder(params);
    case "polygon":
      return jscad.primitives.polygon(params);
    case "cuboid":
      return jscad.primitives.cuboid(params);
    case "roundedCuboid":
      return jscad.primitives.roundedCuboid(params);
    case "rotate":
      return jscad.transforms.rotate(operation.angles, recurse(operation.shape));
    case "scale":
      return jscad.transforms.scale(operation.factors, recurse(operation.shape));
    case "translate":
      return jscad.transforms.translate(
        operation.vector,
        recurse(operation.shape)
      );
    case "extrudeLinear":
      return jscad.extrusions.extrudeLinear(
        operation.options,
        recurse(operation.shape)
      );
    case "extrudeRotate":
      return jscad.extrusions.extrudeRotate(
        operation.options,
        recurse(operation.shape)
      );
    case "createGeom2":
      return jscad.geometries.geom2.create(operation.points);
    case "createGeom3":
      return jscad.geometries.geom3.create(operation.polygons);
    case "createPath2":
      return jscad.geometries.path2.create(operation.points);
    case "measureBoundingBox":
      return jscad.measurements.measureBoundingBox(recurse(operation.shape));
    case "measureArea":
      return jscad.measurements.measureArea(recurse(operation.shape));
    case "measureVolume":
      return jscad.measurements.measureVolume(recurse(operation.shape));
    case "degToRad":
      return jscad.utils.degToRad(operation.degrees);
    case "radToDeg":
      return jscad.utils.radToDeg(operation.radians);
    default:
      if (operation.type === void 0) {
        throw new Error(
          `Operation type is undefined. This usually means the operation object is malformed or not properly initialized. Operation: ${JSON.stringify(operation, null, 2).slice(0, 200)}...`
        );
      }
      throw new Error(
        `Unsupported operation type: ${operation.type}. Operation: ${JSON.stringify(operation, null, 2)}`
      );
  }
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  executeJscadOperations,
  jscadPlanner
});
//# sourceMappingURL=index.cjs.map