"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.stubLog = exports.testLog = void 0;
exports.default = buildLog;
const chalk_1 = __importDefault(require("chalk"));
function getProcess() {
    if (typeof process !== 'undefined') {
        return process;
    }
    return null;
}
let lastLogTimeMs = Date.now();
const getMaxLogPrefixesLength = () => {
    return typeof getProcess()?.env?.MAXIMUM_LOG_PREFIXES_LENGTH === 'string'
        ? +getProcess()?.env?.MAXIMUM_LOG_PREFIXES_LENGTH
        : undefined;
};
function buildLog(prefix = undefined, options) {
    const { colors = {}, log, useColors } = options ?? {};
    const { info = 'yellow', error = 'red' } = colors;
    const isInteractive = getProcess()?.stdout?.isTTY ?? false;
    const shouldUseColors = useColors !== false && isInteractive;
    const pre = prefix ? `${prefix} ::` : undefined;
    const transports = {
        ERROR: options?.transportsByLevel?.ERROR,
        INFO: options?.transportsByLevel?.INFO,
        WARN: options?.transportsByLevel?.WARN,
    };
    const logUtil = {
        prefix,
        info(...args) {
            //@ts-ignore
            return write(chalk_1.default?.green?.[info], args, 'INFO');
        },
        warn(...args) {
            //@ts-ignore
            return write(chalk_1.default?.yellow?.[info], args, 'WARN');
        },
        error(...args) {
            //@ts-ignore
            return write(chalk_1.default?.red?.[error], args, 'ERROR');
        },
        buildLog(prefix = undefined, options) {
            return buildLog(`${pre ? `${pre} ` : ''}${prefix}`, {
                log,
                useColors,
                transportsByLevel: transports,
                ...options,
            });
        },
    };
    return logUtil;
    function getTransports(level) {
        const t = transports[level];
        if (!t) {
            return [];
        }
        if (!Array.isArray(t)) {
            return [t];
        }
        return t;
    }
    function write(chalkMethod, rawArgs, level) {
        if (!shouldWrite(getProcess()?.env?.LOG_LEVEL ?? undefined, level)) {
            return '';
        }
        const args = rawArgs.map((a) => a?.toString?.() ?? 'undefined');
        let chalkArgs = [...args];
        let builtPrefix = pre;
        if (pre) {
            const length = getMaxLogPrefixesLength();
            if (typeof length === 'number' && !isNaN(length)) {
                const parts = pre.split(' :: ');
                builtPrefix = parts
                    .splice(parts.length - length, length)
                    .join(' :: ');
            }
            chalkArgs = [builtPrefix, ...chalkArgs];
        }
        const prefix = builtPrefix ? ` ${builtPrefix}` : '';
        let transports = getTransports(level);
        if (transports.length > 0) {
            for (const transport of transports) {
                transport(...[prefix.trim(), ...args].filter((t) => t && t.length > 0));
            }
            return prefix;
        }
        const env = getProcess()?.env ?? {};
        let logMethod = 'log';
        switch (level) {
            case 'ERROR':
                logMethod = 'error';
                break;
            case 'WARN':
                logMethod = 'warn';
                break;
            default:
                logMethod = 'log';
                break;
        }
        const transport = log ??
            (level === 'ERROR' && getProcess()?.stderr?.write
                ? (...args) => {
                    getProcess()?.stderr.write(args.join(' ') + '\n');
                }
                : (console[logMethod] ?? console.log).bind(console));
        let message = shouldUseColors === false
            ? `(${level})${prefix}`
            : chalkMethod?.(...chalkArgs);
        if (env.SHOULD_LOG_TIME_DELTAS !== 'false') {
            const now = Date.now();
            const diff = now - lastLogTimeMs;
            lastLogTimeMs = now;
            message = `(${diff}ms) ${message}`;
        }
        if (env.SHOULD_LOG_TIME !== 'false') {
            message = `(${new Date().toISOString()}) ${message}`;
        }
        if (shouldUseColors === false) {
            transport(message, ...args);
        }
        else {
            transport(message);
        }
        return message;
    }
}
exports.testLog = buildLog('TEST', {
    log: (...parts) => {
        getProcess()?.stderr?.write?.(parts.join(' ') + '\n');
    },
});
exports.stubLog = buildLog('STUB', {
    log: () => { },
    useColors: false,
});
function shouldWrite(maxLogLevel, level) {
    if (maxLogLevel) {
        if (getProcess()?.env?.LOG_LEVEL == 'none') {
            return false;
        }
        if (getProcess()?.env?.LOG_LEVEL == 'error' && level !== 'ERROR') {
            return false;
        }
        if (getProcess()?.env?.LOG_LEVEL == 'warn' && level === 'INFO') {
            return false;
        }
    }
    return true;
}
