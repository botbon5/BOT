"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.formatDate = formatDate;
const path_1 = __importDefault(require("path"));
const globby_1 = __importDefault(require("@sprucelabs/globby"));
const uniqBy_1 = __importDefault(require("lodash/uniqBy"));
const constants_1 = require("../constants");
const SpruceError_1 = __importDefault(require("../errors/SpruceError"));
const disk_utility_1 = __importDefault(require("./disk.utility"));
const names_utility_1 = __importDefault(require("./names.utility"));
function parsePath(cwd, paths) {
    const resolved = disk_utility_1.default.resolvePath(cwd, ...paths);
    const resolvedParts = resolved.split(constants_1.LATEST_HANDLEBARS);
    const dirToRead = resolvedParts[0];
    return { dirToRead, resolved };
}
function formatDate(date) {
    const d = date, year = d.getFullYear();
    let month = '' + (d.getMonth() + 1), day = '' + d.getDate();
    if (month.length < 2) {
        month = '0' + month;
    }
    if (day.length < 2) {
        day = '0' + day;
    }
    return [year, month, day].join('_');
}
const versionUtil = {
    getAllVersions(dirToRead) {
        let matches = [];
        if (dirToRead.includes('*')) {
            matches = globby_1.default.sync(dirToRead);
        }
        else if (disk_utility_1.default.doesFileExist(dirToRead)) {
            matches = disk_utility_1.default.readDir(dirToRead);
        }
        const allDateIsh = (0, uniqBy_1.default)(matches
            .filter((value) => this.isValidVersion(value))
            .map((dateIsh) => this.generateVersion(dateIsh))
            .sort((a, b) => {
            return a.intValue > b.intValue ? 1 : -1;
        }), 'constValue');
        return allDateIsh;
    },
    generateVersion(dateFormattedString) {
        const date = dateFormattedString &&
            dateFormattedString.search(constants_1.LATEST_TOKEN) === -1
            ? dateFormattedString
            : formatDate(new Date());
        const cleaned = date.replace(/[^\d_-]/gi, '');
        return {
            intValue: parseInt(date.replace(/\D/g, ''), 10),
            constValue: `v${names_utility_1.default.toConst(cleaned)}`,
            dirValue: `v${names_utility_1.default.toConst(cleaned)}`,
        };
    },
    latestVersionAtPath(path) {
        const resolved = disk_utility_1.default.resolvePath(path, '');
        const version = this.getAllVersions(resolved);
        const latest = version.pop();
        if (!latest) {
            debugger;
            throw new SpruceError_1.default({
                //@ts-ignore
                code: 'NO_VERSIONING_FOUND',
                friendlyMessage: `Expected versioning (e.g. v2020_07_22) at ${path}`,
            });
        }
        return latest;
    },
    extractVersion(cwd, path) {
        const remainingPath = path.replace(cwd, '');
        const pathParts = remainingPath.split(path_1.default.sep);
        while (pathParts.length > 0) {
            const part = pathParts.pop();
            if (this.isValidVersion(part)) {
                return this.generateVersion(part);
            }
        }
        throw new SpruceError_1.default({
            //@ts-ignore
            code: 'NO_VERSIONING_FOUND',
            friendlyMessage: `Expected versioning (e.g. v2020_07_22) at ${path}`,
        });
    },
    resolvePath(cwd, ...paths) {
        const { dirToRead, resolved } = parsePath(cwd, paths);
        const allDateIsh = this.getAllVersions(dirToRead);
        const latest = allDateIsh.pop();
        if (!latest) {
            debugger;
            throw new Error('no versioning found!');
        }
        return resolved.replace(constants_1.LATEST_HANDLEBARS, latest.dirValue);
    },
    resolveNewLatestPath(cwd, ...paths) {
        const { resolved } = parsePath(cwd, paths);
        return resolved.replace('{{@latest}}', this.generateVersion().dirValue);
    },
    isValidVersion(version) {
        try {
            this.assertValidVersion(version);
            return true;
        }
        catch {
            return false;
        }
    },
    assertValidVersion(version) {
        if (version.search(constants_1.LATEST_TOKEN) === -1 &&
            version.search(/v?\d\d\d\d_\d\d_\d\d/) === -1) {
            throw new SpruceError_1.default({
                //@ts-ignore
                code: 'INVALID_VERSION',
                friendlyMessage: `Versions must be in the form 'vYYYY_MM_DD' and ${version} doesn't match.`,
            });
        }
    },
};
exports.default = versionUtil;
