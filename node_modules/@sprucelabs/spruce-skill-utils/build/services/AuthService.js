"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const os_1 = __importDefault(require("os"));
const schema_1 = require("@sprucelabs/schema");
const disk_utility_1 = __importDefault(require("../utilities/disk.utility"));
const names_utility_1 = __importDefault(require("../utilities/names.utility"));
const EnvService_1 = __importDefault(require("./EnvService"));
const PkgService_1 = __importDefault(require("./PkgService"));
class AuthService {
    constructor(envService, pkgService) {
        this.env = envService;
        this.pkg = pkgService;
    }
    static Auth(cwd) {
        if (!cwd) {
            throw new schema_1.SchemaError({
                code: 'MISSING_PARAMETERS',
                parameters: ['cwd'],
            });
        }
        const pkgService = new PkgService_1.default(cwd);
        const envService = new EnvService_1.default(cwd);
        if (!pkgService.doesExist()) {
            throw new schema_1.SchemaError({
                code: 'INVALID_PARAMETERS',
                parameters: ['cwd'],
                friendlyMessage: 'Could not find a package.json file!',
            });
        }
        const auth = new (this.Class ?? this)(envService, pkgService);
        return auth;
    }
    getLoggedInPerson() {
        if (disk_utility_1.default.doesFileExist(this.personJsonPath)) {
            const contents = disk_utility_1.default.readFile(this.personJsonPath);
            const person = JSON.parse(contents);
            return person;
        }
        return null;
    }
    setLoggedInPerson(person) {
        const normalized = (0, schema_1.normalizeSchemaValues)(personWithTokenSchema, person);
        (0, schema_1.validateSchemaValues)(personWithTokenSchema, normalized);
        const destination = this.personJsonPath;
        disk_utility_1.default.writeFile(destination, JSON.stringify({ ...normalized, isLoggedIn: true }, null, 2));
    }
    logOutPerson() {
        disk_utility_1.default.deleteFile(this.personJsonPath);
    }
    getCurrentSkill() {
        const id = this.env.get('SKILL_ID');
        const apiKey = this.env.get('SKILL_API_KEY');
        const name = this.env.get('SKILL_NAME');
        const slug = this.pkg.get('skill.namespace');
        if (id && apiKey) {
            return {
                id,
                apiKey,
                name,
                slug,
            };
        }
        return null;
    }
    logoutCurrentSkill() {
        this.env.unset('SKILL_ID');
        this.env.unset('SKILL_API_KEY');
        this.env.unset('SKILL_NAME');
    }
    updateCurrentSkill(skill) {
        this.env.set('SKILL_ID', skill.id);
        this.env.set('SKILL_API_KEY', skill.apiKey);
        this.env.set('SKILL_NAME', skill.name);
        this.updateCurrentSkillNamespace(skill.slug);
    }
    updateCurrentSkillNamespace(namespace) {
        this.pkg.set({
            path: 'skill.namespace',
            value: names_utility_1.default.toKebab(namespace),
        });
    }
    get personJsonPath() {
        return disk_utility_1.default.resolvePath(AuthService.homeDir, '.spruce', 'person.json');
    }
}
AuthService.homeDir = os_1.default.homedir();
exports.default = AuthService;
const personWithTokenSchema = (0, schema_1.buildSchema)({
    id: 'personWithToken',
    version: 'v2020_07_22',
    namespace: 'SpruceCli',
    name: '',
    description: 'A stripped down cli user with token details for login',
    fields: {
        /** Id. */
        id: {
            label: 'Id',
            type: 'id',
            isRequired: true,
            options: undefined,
        },
        /** Casual name. The name you can use when talking to this person. */
        casualName: {
            label: 'Casual name',
            type: 'text',
            isRequired: true,
            hint: 'The name you can use when talking to this person.',
            options: undefined,
        },
        /** . */
        token: {
            type: 'text',
            isRequired: true,
            options: undefined,
        },
        /** Logged in. */
        isLoggedIn: {
            label: 'Logged in',
            type: 'boolean',
            options: undefined,
        },
    },
});
