import chalk from 'chalk';
function getProcess() {
    if (typeof process !== 'undefined') {
        return process;
    }
    return null;
}
let lastLogTimeMs = Date.now();
const getMaxLogPrefixesLength = () => {
    var _a, _b, _c, _d;
    return typeof ((_b = (_a = getProcess()) === null || _a === void 0 ? void 0 : _a.env) === null || _b === void 0 ? void 0 : _b.MAXIMUM_LOG_PREFIXES_LENGTH) === 'string'
        ? +((_d = (_c = getProcess()) === null || _c === void 0 ? void 0 : _c.env) === null || _d === void 0 ? void 0 : _d.MAXIMUM_LOG_PREFIXES_LENGTH)
        : undefined;
};
export default function buildLog(prefix = undefined, options) {
    var _a, _b, _c, _d, _e, _f;
    const { colors = {}, log, useColors } = options !== null && options !== void 0 ? options : {};
    const { info = 'yellow', error = 'red' } = colors;
    const isInteractive = (_c = (_b = (_a = getProcess()) === null || _a === void 0 ? void 0 : _a.stdout) === null || _b === void 0 ? void 0 : _b.isTTY) !== null && _c !== void 0 ? _c : false;
    const shouldUseColors = useColors !== false && isInteractive;
    const pre = prefix ? `${prefix} ::` : undefined;
    const transports = {
        ERROR: (_d = options === null || options === void 0 ? void 0 : options.transportsByLevel) === null || _d === void 0 ? void 0 : _d.ERROR,
        INFO: (_e = options === null || options === void 0 ? void 0 : options.transportsByLevel) === null || _e === void 0 ? void 0 : _e.INFO,
        WARN: (_f = options === null || options === void 0 ? void 0 : options.transportsByLevel) === null || _f === void 0 ? void 0 : _f.WARN,
    };
    const logUtil = {
        prefix,
        info(...args) {
            var _a;
            //@ts-ignore
            return write((_a = chalk === null || chalk === void 0 ? void 0 : chalk.green) === null || _a === void 0 ? void 0 : _a[info], args, 'INFO');
        },
        warn(...args) {
            var _a;
            //@ts-ignore
            return write((_a = chalk === null || chalk === void 0 ? void 0 : chalk.yellow) === null || _a === void 0 ? void 0 : _a[info], args, 'WARN');
        },
        error(...args) {
            var _a;
            //@ts-ignore
            return write((_a = chalk === null || chalk === void 0 ? void 0 : chalk.red) === null || _a === void 0 ? void 0 : _a[error], args, 'ERROR');
        },
        buildLog(prefix = undefined, options) {
            return buildLog(`${pre ? `${pre} ` : ''}${prefix}`, Object.assign({ log,
                useColors, transportsByLevel: transports }, options));
        },
    };
    return logUtil;
    function getTransports(level) {
        const t = transports[level];
        if (!t) {
            return [];
        }
        if (!Array.isArray(t)) {
            return [t];
        }
        return t;
    }
    function write(chalkMethod, rawArgs, level) {
        var _a, _b, _c, _d, _e, _f, _g, _h;
        if (!shouldWrite((_c = (_b = (_a = getProcess()) === null || _a === void 0 ? void 0 : _a.env) === null || _b === void 0 ? void 0 : _b.LOG_LEVEL) !== null && _c !== void 0 ? _c : undefined, level)) {
            return '';
        }
        const args = rawArgs.map((a) => { var _a, _b; return (_b = (_a = a === null || a === void 0 ? void 0 : a.toString) === null || _a === void 0 ? void 0 : _a.call(a)) !== null && _b !== void 0 ? _b : 'undefined'; });
        let chalkArgs = [...args];
        let builtPrefix = pre;
        if (pre) {
            const length = getMaxLogPrefixesLength();
            if (typeof length === 'number' && !isNaN(length)) {
                const parts = pre.split(' :: ');
                builtPrefix = parts
                    .splice(parts.length - length, length)
                    .join(' :: ');
            }
            chalkArgs = [builtPrefix, ...chalkArgs];
        }
        const prefix = builtPrefix ? ` ${builtPrefix}` : '';
        let transports = getTransports(level);
        if (transports.length > 0) {
            for (const transport of transports) {
                transport(...[prefix.trim(), ...args].filter((t) => t && t.length > 0));
            }
            return prefix;
        }
        const env = (_e = (_d = getProcess()) === null || _d === void 0 ? void 0 : _d.env) !== null && _e !== void 0 ? _e : {};
        let logMethod = 'log';
        switch (level) {
            case 'ERROR':
                logMethod = 'error';
                break;
            case 'WARN':
                logMethod = 'warn';
                break;
            default:
                logMethod = 'log';
                break;
        }
        const transport = log !== null && log !== void 0 ? log : (level === 'ERROR' && ((_g = (_f = getProcess()) === null || _f === void 0 ? void 0 : _f.stderr) === null || _g === void 0 ? void 0 : _g.write)
            ? (...args) => {
                var _a;
                (_a = getProcess()) === null || _a === void 0 ? void 0 : _a.stderr.write(args.join(' ') + '\n');
            }
            : ((_h = console[logMethod]) !== null && _h !== void 0 ? _h : console.log).bind(console));
        let message = shouldUseColors === false
            ? `(${level})${prefix}`
            : chalkMethod === null || chalkMethod === void 0 ? void 0 : chalkMethod(...chalkArgs);
        if (env.SHOULD_LOG_TIME_DELTAS !== 'false') {
            const now = Date.now();
            const diff = now - lastLogTimeMs;
            lastLogTimeMs = now;
            message = `(${diff}ms) ${message}`;
        }
        if (env.SHOULD_LOG_TIME !== 'false') {
            message = `(${new Date().toISOString()}) ${message}`;
        }
        if (shouldUseColors === false) {
            transport(message, ...args);
        }
        else {
            transport(message);
        }
        return message;
    }
}
export const testLog = buildLog('TEST', {
    log: (...parts) => {
        var _a, _b, _c;
        (_c = (_b = (_a = getProcess()) === null || _a === void 0 ? void 0 : _a.stderr) === null || _b === void 0 ? void 0 : _b.write) === null || _c === void 0 ? void 0 : _c.call(_b, parts.join(' ') + '\n');
    },
});
export const stubLog = buildLog('STUB', {
    log: () => { },
    useColors: false,
});
function shouldWrite(maxLogLevel, level) {
    var _a, _b, _c, _d, _e, _f;
    if (maxLogLevel) {
        if (((_b = (_a = getProcess()) === null || _a === void 0 ? void 0 : _a.env) === null || _b === void 0 ? void 0 : _b.LOG_LEVEL) == 'none') {
            return false;
        }
        if (((_d = (_c = getProcess()) === null || _c === void 0 ? void 0 : _c.env) === null || _d === void 0 ? void 0 : _d.LOG_LEVEL) == 'error' && level !== 'ERROR') {
            return false;
        }
        if (((_f = (_e = getProcess()) === null || _e === void 0 ? void 0 : _e.env) === null || _f === void 0 ? void 0 : _f.LOG_LEVEL) == 'warn' && level === 'INFO') {
            return false;
        }
    }
    return true;
}
