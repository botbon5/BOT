import { expectType } from 'ts-expect';
export * from './assert.utility';
export type RecursivePartial<T> = {
    [P in keyof T]?: T[P] extends (infer U)[] ? RecursivePartial<U>[] : T[P] extends object ? RecursivePartial<T[P]> : T[P];
};
type IfAny<T, Y, N> = 0 extends 1 & T ? Y : N;
type IsAny<T> = IfAny<T, true, never>;
type TypeEqual<T, U> = IsAny<T> extends never ? Exclude<T, U> extends never ? Exclude<U, T> extends never ? true : false : false : false;
declare function isExactType<T, E, Pass = TypeEqual<T, E>>(_: Pass): void;
export interface ISpruceAssert {
    isInstanceOf<T>(test: T, Test: new (...props: any[]) => T, message?: string): void;
    isNumber(actual: any, message?: string): asserts actual is number;
    isType: typeof expectType;
    isExactType: typeof isExactType;
    isArray<T extends any[]>(actual: any, message?: string): asserts actual is T;
    areSameType<T>(actual: T, expected: T): asserts actual is T;
    isEqual<T>(actual: T, expected: T, message?: string): asserts actual is T;
    isNotEqual<T>(actual: T, expected: T, message?: string): asserts actual is T;
    isEqualDeep<T>(actual: T, expected: T, message?: string, shouldAppendDelta?: boolean): asserts actual is T;
    isNotEqualDeep<T>(actual: T, expected: T, message?: string): void;
    isAbove<T>(actual: T, floor: T, message?: string): void;
    isBelow<T>(actual: T, ceiling: T, message?: string): void;
    isUndefined<T>(actual: T, message?: string): void;
    isTruthy<T = any>(value: T, message?: string): asserts value is NonNullable<T>;
    isFalsy(value: any, message?: string): void;
    isTrue(actual: boolean | undefined | null, message?: string): asserts actual is true;
    isFalse(actual: boolean | undefined | null, message?: string): asserts actual is false;
    isObject<T>(actual: T, message?: string): void;
    isLength(actual: any[] | undefined | null, expected: number, message?: string): void;
    isNull(actual: any, message?: string): void;
    doesNotInclude<T>(haystack: T, needle: RecursivePartial<T>, message?: string): void;
    doesNotInclude(haystack: string, needle: string, message?: string): void;
    doesNotInclude(haystack: any, needle: string, message?: string): void;
    doesNotInclude(haystack: any, needle: any, message?: string): void;
    doesInclude<T>(haystack: T, needle: RecursivePartial<T>, message?: string): void;
    doesInclude(haystack: string, needle: string, message?: string): void;
    doesInclude(haystack: any, needle: string, message?: string): void;
    doesInclude(haystack: any, needle: any, message?: string): void;
    isString(actual: any, message?: string): asserts actual is string;
    isFunction(actual: any, message?: string): asserts actual is Function;
    hasAllFunctions(obj: any, functionNames: string[]): void;
    doesThrow(cb: () => any, matcher?: string | RegExp | undefined, msg?: string | undefined): Error;
    doesThrowAsync(cb: () => any | Promise<any>, matcher?: string | RegExp | undefined, msg?: string | undefined): Promise<Error>;
    fail(message?: string): void;
    isBetween(actual: any, floor: number, ceiling: number, message?: string): asserts actual is number;
    isBetweenInclusive(actual: any, floor: number, ceiling: number, message?: string): asserts actual is number;
}
declare const assert: ISpruceAssert;
export default assert;
