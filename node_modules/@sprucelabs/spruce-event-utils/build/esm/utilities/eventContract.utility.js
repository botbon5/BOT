import { EVENT_VERSION_DIVIDER } from '../constants.js';
import SpruceError from '../errors/SpruceError.js';
import eventNameUtil from './eventName.utility.js';
const eventContractUtil = {
    getEventNames(contract, namespace) {
        const names = getEventNames(contract, namespace);
        return names;
    },
    getNamedEventSignatures(contract) {
        return getNamedEventSignatures(contract);
    },
    unifyContracts(contracts, options) {
        if (!contracts || contracts.length === 0) {
            return undefined;
        }
        const { shouldUpsert = false } = options !== null && options !== void 0 ? options : {};
        const unifiedContract = {
            eventSignatures: {},
        };
        let existingNames = [];
        for (const contract of contracts !== null && contracts !== void 0 ? contracts : []) {
            if (!shouldUpsert) {
                const names = Object.keys(contract.eventSignatures);
                for (const name of names) {
                    if (existingNames.indexOf(name) > -1) {
                        throw new SpruceError({
                            code: 'DUPLICATE_EVENT',
                            fullyQualifiedEventName: name,
                        });
                    }
                }
                existingNames.push(...names);
            }
            unifiedContract.eventSignatures = Object.assign(Object.assign({}, unifiedContract.eventSignatures), contract.eventSignatures);
        }
        return unifiedContract;
    },
    resolveToLatestEventName(contract, fullyQualifiedEventName) {
        let match = getNamedSignature(fullyQualifiedEventName, contract);
        if (match) {
            return fullyQualifiedEventName;
        }
        const search = fullyQualifiedEventName + EVENT_VERSION_DIVIDER;
        const matchesOnVersion = Object.keys(contract.eventSignatures).filter((name) => {
            if (name.search(search) === 0) {
                return true;
            }
            return false;
        });
        matchesOnVersion.sort((a, b) => {
            var _a, _b;
            const v1 = (_a = a.split('::').pop()) !== null && _a !== void 0 ? _a : 0;
            const v2 = (_b = b.split('::').pop()) !== null && _b !== void 0 ? _b : 0;
            if (v1 > v2) {
                return 1;
            }
            else if (v1 < v2) {
                return -1;
            }
            return 0;
        });
        const latestVersion = matchesOnVersion.pop();
        match = getNamedSignature(latestVersion, contract);
        if (match) {
            return latestVersion;
        }
        throw new SpruceError({
            code: 'INVALID_EVENT_NAME',
            fullyQualifiedEventName,
            validNames: this.getEventNames(contract),
        });
    },
    getSignatureByName(contract, fullyQualifiedEventName) {
        const resolvedName = this.resolveToLatestEventName(contract, fullyQualifiedEventName);
        let match = getNamedSignature(resolvedName, contract);
        if (!match) {
            throw new SpruceError({
                code: 'INVALID_EVENT_NAME',
                fullyQualifiedEventName,
                validNames: this.getEventNames(contract),
            });
        }
        return match.signature;
    },
};
export default eventContractUtil;
function getEventNames(contract, namespace) {
    let names = Object.keys(contract.eventSignatures);
    if (namespace) {
        names = names.filter((n) => eventNameUtil.split(n).eventNamespace === namespace);
    }
    return names;
}
const getNamedEventSignatures = (contract) => {
    const names = getEventNames(contract);
    const sigs = names.map((name) => {
        return getNamedSignature(name, contract);
    });
    return sigs;
};
function getNamedSignature(name, contract) {
    if (!contract.eventSignatures[name]) {
        return undefined;
    }
    const nameParts = eventNameUtil.split(name);
    return {
        fullyQualifiedEventName: name,
        eventName: nameParts.eventName,
        eventNamespace: nameParts.eventNamespace,
        signature: contract.eventSignatures[name],
        version: nameParts.version,
    };
}
