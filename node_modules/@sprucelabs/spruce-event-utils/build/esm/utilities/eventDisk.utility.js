import pathUtil from 'path';
import { assertOptions } from '@sprucelabs/schema';
import { diskUtil } from '@sprucelabs/spruce-skill-utils';
import SpruceError from '../errors/SpruceError.js';
import eventNameUtil from './eventName.utility.js';
const eventDiskUtil = {
    resolveListenerPath(destination, e) {
        assertOptions(e, ['eventName', 'version']);
        const fqen = eventNameUtil.join(e);
        const { eventName, eventNamespace, version } = eventNameUtil.split(fqen);
        return diskUtil.resolvePath(destination, eventNamespace !== null && eventNamespace !== void 0 ? eventNamespace : '', eventName + '.' + version + '.listener.ts');
    },
    splitPathToListener(match, seperator = '/') {
        const matches = new RegExp(`([a-z0-9\\-]+)\\${seperator}([a-z0-9\\-]+)\\.(v[0-9]{4}_[0-9]{2}_[0-9]{2})\\.listener.[t|j]s`).exec(match);
        if (!matches) {
            throw new Error("Invalid listener path. Must be in a folder structure like '**/src/listeners/{{eventNamespace}}/{{eventName}}.{{version}}.listener.ts");
        }
        const listener = {};
        listener.eventNamespace =
            matches[1] === 'listeners' ? undefined : matches[1];
        listener.version = matches[3];
        listener.eventName = matches[2];
        listener.fullyQualifiedEventName = eventNameUtil.join(Object.assign({}, listener));
        return listener;
    },
    splitPathToEvent(match, seperator = '/') {
        const matches = new RegExp(`([a-z0-9\\-]*)\\${seperator}(v[0-9]{4}_[0-9]{2}_[0-9]{2})\\${seperator}.*?\\.(builder|options)\\.[j|t]s`).exec(match);
        if (!matches) {
            throw new Error("Invalid event path. Must be in a folder structure like '**/src/events/{{eventName}}/{{version}}/emitPayloadSchema.builder.ts");
        }
        const event = {};
        event.eventName = matches[1];
        event.version = matches[2];
        if (!event.eventName || !event.version) {
            throw new Error("Invalid event path. Must be in a folder structure like '**/src/events/{{eventName}}/{{version}}/emitPayloadSchema.builder.ts");
        }
        return event;
    },
    resolveEventPath(destination, e) {
        if (!e || !e.eventName || !e.version) {
            throw new Error("Can't resolve path to event without eventName, eventNamespace, version");
        }
        return pathUtil.join(destination, e.eventName, e.version, e.fileName);
    },
    resolveCombinedEventsContractFile(cwd) {
        try {
            return diskUtil.resolveFileInHashSpruceDir(cwd, 'events', 'events.contract');
        }
        catch (_a) {
            throw new SpruceError({ code: 'EVENT_CONTRACTS_NOT_SYNCED' });
        }
    },
};
export default eventDiskUtil;
