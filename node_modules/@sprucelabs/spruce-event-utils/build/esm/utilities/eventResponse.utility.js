import AbstractSpruceError from '@sprucelabs/error';
import SpruceError from '../errors/SpruceError.js';
const eventResponseUtil = {
    mutatingMapAggregateResponseErrorsToSpruceErrors(results, ClassRef) {
        results.responses = results.responses.map((response) => {
            return this.mutatingMapSingleResonseErrorsToSpruceErrors(response, ClassRef);
        });
        return results;
    },
    mutatingMapSingleResonseErrorsToSpruceErrors(response, ClassRef) {
        if (response.errors) {
            response.errors = response.errors.map((err) => mapError(err, ClassRef));
        }
        return response;
    },
    getFirstResponseOrThrow(emitResponse) {
        var _a;
        if (!((_a = emitResponse === null || emitResponse === void 0 ? void 0 : emitResponse.responses) === null || _a === void 0 ? void 0 : _a[0])) {
            throw new SpruceError({
                code: 'MERCURY_RESPONSE_ERROR',
                responseErrors: [
                    new SpruceError({
                        code: 'EMPTY_MERCURY_RESPONSE',
                    }),
                ],
            });
        }
        const payload = emitResponse.responses[0].payload;
        const errors = emitResponse.responses[0].errors;
        if (errors) {
            throw new SpruceError({
                code: 'MERCURY_RESPONSE_ERROR',
                responseErrors: errors.map((err) => AbstractSpruceError.parse(err, SpruceError)),
            });
        }
        return payload;
    },
    getAllResponsePayloadsAndErrors(emitResponse, ClassRef) {
        const payloads = emitResponse.responses
            .filter((r) => !!r.payload)
            .map((r) => r.payload);
        const results = {
            payloads,
        };
        if (emitResponse.totalErrors > 0) {
            this.mutatingMapAggregateResponseErrorsToSpruceErrors(emitResponse, ClassRef);
            results.errors = [];
            emitResponse.responses.forEach((r) => {
                var _a;
                (_a = r.errors) === null || _a === void 0 ? void 0 : _a.forEach((err) => {
                    var _a;
                    //@ts-ignore
                    (_a = results.errors) === null || _a === void 0 ? void 0 : _a.push(err);
                });
            });
        }
        return results;
    },
};
export default eventResponseUtil;
function mapError(err, ClassRef) {
    const spruceErr = AbstractSpruceError.parse(err, ClassRef);
    if (spruceErr.options.code === 'MERCURY_RESPONSE_ERROR') {
        spruceErr.options.responseErrors = spruceErr.options.responseErrors.map((err) => AbstractSpruceError.parse(err, ClassRef));
    }
    return spruceErr;
}
