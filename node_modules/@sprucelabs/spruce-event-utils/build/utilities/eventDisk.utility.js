"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const path_1 = __importDefault(require("path"));
const schema_1 = require("@sprucelabs/schema");
const spruce_skill_utils_1 = require("@sprucelabs/spruce-skill-utils");
const SpruceError_1 = __importDefault(require("../errors/SpruceError"));
const eventName_utility_1 = __importDefault(require("./eventName.utility"));
const eventDiskUtil = {
    resolveListenerPath(destination, e) {
        (0, schema_1.assertOptions)(e, ['eventName', 'version']);
        const fqen = eventName_utility_1.default.join(e);
        const { eventName, eventNamespace, version } = eventName_utility_1.default.split(fqen);
        return spruce_skill_utils_1.diskUtil.resolvePath(destination, eventNamespace ?? '', eventName + '.' + version + '.listener.ts');
    },
    splitPathToListener(match, seperator = '/') {
        const matches = new RegExp(`([a-z0-9\\-]+)\\${seperator}([a-z0-9\\-]+)\\.(v[0-9]{4}_[0-9]{2}_[0-9]{2})\\.listener.[t|j]s`).exec(match);
        if (!matches) {
            throw new Error("Invalid listener path. Must be in a folder structure like '**/src/listeners/{{eventNamespace}}/{{eventName}}.{{version}}.listener.ts");
        }
        const listener = {};
        listener.eventNamespace =
            matches[1] === 'listeners' ? undefined : matches[1];
        listener.version = matches[3];
        listener.eventName = matches[2];
        listener.fullyQualifiedEventName = eventName_utility_1.default.join({ ...listener });
        return listener;
    },
    splitPathToEvent(match, seperator = '/') {
        const matches = new RegExp(`([a-z0-9\\-]*)\\${seperator}(v[0-9]{4}_[0-9]{2}_[0-9]{2})\\${seperator}.*?\\.(builder|options)\\.[j|t]s`).exec(match);
        if (!matches) {
            throw new Error("Invalid event path. Must be in a folder structure like '**/src/events/{{eventName}}/{{version}}/emitPayloadSchema.builder.ts");
        }
        const event = {};
        event.eventName = matches[1];
        event.version = matches[2];
        if (!event.eventName || !event.version) {
            throw new Error("Invalid event path. Must be in a folder structure like '**/src/events/{{eventName}}/{{version}}/emitPayloadSchema.builder.ts");
        }
        return event;
    },
    resolveEventPath(destination, e) {
        if (!e || !e.eventName || !e.version) {
            throw new Error("Can't resolve path to event without eventName, eventNamespace, version");
        }
        return path_1.default.join(destination, e.eventName, e.version, e.fileName);
    },
    resolveCombinedEventsContractFile(cwd) {
        try {
            return spruce_skill_utils_1.diskUtil.resolveFileInHashSpruceDir(cwd, 'events', 'events.contract');
        }
        catch {
            throw new SpruceError_1.default({ code: 'EVENT_CONTRACTS_NOT_SYNCED' });
        }
    },
};
exports.default = eventDiskUtil;
