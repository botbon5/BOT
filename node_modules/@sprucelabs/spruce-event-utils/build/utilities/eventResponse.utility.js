"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const error_1 = __importDefault(require("@sprucelabs/error"));
const SpruceError_1 = __importDefault(require("../errors/SpruceError"));
const eventResponseUtil = {
    mutatingMapAggregateResponseErrorsToSpruceErrors(results, ClassRef) {
        results.responses = results.responses.map((response) => {
            return this.mutatingMapSingleResonseErrorsToSpruceErrors(response, ClassRef);
        });
        return results;
    },
    mutatingMapSingleResonseErrorsToSpruceErrors(response, ClassRef) {
        if (response.errors) {
            response.errors = response.errors.map((err) => mapError(err, ClassRef));
        }
        return response;
    },
    getFirstResponseOrThrow(emitResponse) {
        if (!emitResponse?.responses?.[0]) {
            throw new SpruceError_1.default({
                code: 'MERCURY_RESPONSE_ERROR',
                responseErrors: [
                    new SpruceError_1.default({
                        code: 'EMPTY_MERCURY_RESPONSE',
                    }),
                ],
            });
        }
        const payload = emitResponse.responses[0].payload;
        const errors = emitResponse.responses[0].errors;
        if (errors) {
            throw new SpruceError_1.default({
                code: 'MERCURY_RESPONSE_ERROR',
                responseErrors: errors.map((err) => error_1.default.parse(err, SpruceError_1.default)),
            });
        }
        return payload;
    },
    getAllResponsePayloadsAndErrors(emitResponse, ClassRef) {
        const payloads = emitResponse.responses
            .filter((r) => !!r.payload)
            .map((r) => r.payload);
        const results = {
            payloads,
        };
        if (emitResponse.totalErrors > 0) {
            this.mutatingMapAggregateResponseErrorsToSpruceErrors(emitResponse, ClassRef);
            results.errors = [];
            emitResponse.responses.forEach((r) => {
                r.errors?.forEach((err) => {
                    //@ts-ignore
                    results.errors?.push(err);
                });
            });
        }
        return results;
    },
};
exports.default = eventResponseUtil;
function mapError(err, ClassRef) {
    const spruceErr = error_1.default.parse(err, ClassRef);
    if (spruceErr.options.code === 'MERCURY_RESPONSE_ERROR') {
        spruceErr.options.responseErrors = spruceErr.options.responseErrors.map((err) => error_1.default.parse(err, ClassRef));
    }
    return spruceErr;
}
