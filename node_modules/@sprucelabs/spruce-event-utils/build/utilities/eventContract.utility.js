"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const constants_1 = require("../constants");
const SpruceError_1 = __importDefault(require("../errors/SpruceError"));
const eventName_utility_1 = __importDefault(require("./eventName.utility"));
const eventContractUtil = {
    getEventNames(contract, namespace) {
        const names = getEventNames(contract, namespace);
        return names;
    },
    getNamedEventSignatures(contract) {
        return getNamedEventSignatures(contract);
    },
    unifyContracts(contracts, options) {
        if (!contracts || contracts.length === 0) {
            return undefined;
        }
        const { shouldUpsert = false } = options ?? {};
        const unifiedContract = {
            eventSignatures: {},
        };
        let existingNames = [];
        for (const contract of contracts ?? []) {
            if (!shouldUpsert) {
                const names = Object.keys(contract.eventSignatures);
                for (const name of names) {
                    if (existingNames.indexOf(name) > -1) {
                        throw new SpruceError_1.default({
                            code: 'DUPLICATE_EVENT',
                            fullyQualifiedEventName: name,
                        });
                    }
                }
                existingNames.push(...names);
            }
            unifiedContract.eventSignatures = {
                ...unifiedContract.eventSignatures,
                ...contract.eventSignatures,
            };
        }
        return unifiedContract;
    },
    resolveToLatestEventName(contract, fullyQualifiedEventName) {
        let match = getNamedSignature(fullyQualifiedEventName, contract);
        if (match) {
            return fullyQualifiedEventName;
        }
        const search = fullyQualifiedEventName + constants_1.EVENT_VERSION_DIVIDER;
        const matchesOnVersion = Object.keys(contract.eventSignatures).filter((name) => {
            if (name.search(search) === 0) {
                return true;
            }
            return false;
        });
        matchesOnVersion.sort((a, b) => {
            const v1 = a.split('::').pop() ?? 0;
            const v2 = b.split('::').pop() ?? 0;
            if (v1 > v2) {
                return 1;
            }
            else if (v1 < v2) {
                return -1;
            }
            return 0;
        });
        const latestVersion = matchesOnVersion.pop();
        match = getNamedSignature(latestVersion, contract);
        if (match) {
            return latestVersion;
        }
        throw new SpruceError_1.default({
            code: 'INVALID_EVENT_NAME',
            fullyQualifiedEventName,
            validNames: this.getEventNames(contract),
        });
    },
    getSignatureByName(contract, fullyQualifiedEventName) {
        const resolvedName = this.resolveToLatestEventName(contract, fullyQualifiedEventName);
        let match = getNamedSignature(resolvedName, contract);
        if (!match) {
            throw new SpruceError_1.default({
                code: 'INVALID_EVENT_NAME',
                fullyQualifiedEventName,
                validNames: this.getEventNames(contract),
            });
        }
        return match.signature;
    },
};
exports.default = eventContractUtil;
function getEventNames(contract, namespace) {
    let names = Object.keys(contract.eventSignatures);
    if (namespace) {
        names = names.filter((n) => eventName_utility_1.default.split(n).eventNamespace === namespace);
    }
    return names;
}
const getNamedEventSignatures = (contract) => {
    const names = getEventNames(contract);
    const sigs = names.map((name) => {
        return getNamedSignature(name, contract);
    });
    return sigs;
};
function getNamedSignature(name, contract) {
    if (!contract.eventSignatures[name]) {
        return undefined;
    }
    const nameParts = eventName_utility_1.default.split(name);
    return {
        fullyQualifiedEventName: name,
        eventName: nameParts.eventName,
        eventNamespace: nameParts.eventNamespace,
        signature: contract.eventSignatures[name],
        version: nameParts.version,
    };
}
