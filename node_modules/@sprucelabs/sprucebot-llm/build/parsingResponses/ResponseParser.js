"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const templates_1 = require("../bots/templates");
const SpruceError_1 = __importDefault(require("../errors/SpruceError"));
const renderPlaceholder_1 = __importDefault(require("./renderPlaceholder"));
class ResponseParser {
    static setInstance(parser) {
        this.instance = parser;
    }
    static getInstance() {
        return this.instance;
    }
    async parse(response, callbacks) {
        let message = response.replace(templates_1.DONE_TOKEN, '').trim();
        let state;
        let callbackResults;
        for (const key of Object.keys(callbacks || {})) {
            const match = message.match((0, renderPlaceholder_1.default)(key));
            if (match) {
                message = await this.invokeCallbackAndDropInLegacyResults(callbacks, key, message);
            }
            let xmlCallMatches = message.match(new RegExp(`<<\\s*${key}\\s*\/>>`, 'g'));
            let data;
            if (!xmlCallMatches) {
                const matchWithJson = message
                    .matchAll(new RegExp(`<<\\s*${key}\\s*>>(.*?)<<\/\\s*${key}\\s*>>`, 'gs'))
                    .next().value;
                xmlCallMatches = matchWithJson?.[0]
                    ? [matchWithJson?.[0]]
                    : null;
                data = matchWithJson?.[1]
                    ? JSON.parse(matchWithJson?.[1])
                    : undefined;
            }
            if (xmlCallMatches) {
                try {
                    callbackResults = await callbacks?.[key]?.cb(data);
                    message = message.replace(xmlCallMatches[0], '').trim();
                }
                catch (error) {
                    throw new SpruceError_1.default({
                        code: 'CALLBACK_ERROR',
                        friendlyMessage: `Error while executing callback (${key}). The error is: ${error.message}`,
                        originalError: error,
                    });
                }
            }
        }
        const matchedCallback = this.findFirstBadCallback(message);
        if (matchedCallback) {
            throw new SpruceError_1.default({
                code: 'INVALID_CALLBACK',
                validCallbacks: Object.keys(callbacks ?? {}),
                matchedCallback,
            });
        }
        const { match, fullMatch } = this.parseState(message);
        if (match && fullMatch) {
            message = message.replace(fullMatch, '').trim();
            state = JSON.parse(match);
        }
        return {
            isDone: this.doesIncludeDoneToken(response),
            state,
            message,
            callbackResults: callbackResults ?? undefined,
        };
    }
    findFirstBadCallback(message) {
        const simpleMatches = message.match(new RegExp(`<<(.*)\/?>>`, 'g'));
        const extraJsonMatches = message.match(new RegExp(`<<.*?>>(.*?)<<\/.*?>>`, 'gs'));
        const matchedCallback = extraJsonMatches?.[0] || simpleMatches?.[0];
        return matchedCallback;
    }
    async invokeCallbackAndDropInLegacyResults(callbacks, key, message) {
        const v = (await callbacks?.[key]?.cb());
        message = message.replace((0, renderPlaceholder_1.default)(key), v ?? '').trim();
        return message;
    }
    doesIncludeDoneToken(response) {
        return response.includes(templates_1.DONE_TOKEN);
    }
    parseState(message) {
        const ESCAPED_BOUNDARY = templates_1.STATE_BOUNDARY.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, '\\$&');
        const searchRegex = new RegExp(`${ESCAPED_BOUNDARY}(.*?)${ESCAPED_BOUNDARY}`);
        const stateMatches = message.match(searchRegex);
        const match = stateMatches?.[1];
        return { match, fullMatch: stateMatches?.[0] };
    }
}
ResponseParser.instance = new ResponseParser();
exports.default = ResponseParser;
