var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { DONE_TOKEN, STATE_BOUNDARY } from '../bots/templates.js';
import SpruceError from '../errors/SpruceError.js';
import renderPlaceholder from './renderPlaceholder.js';
class ResponseParser {
    static setInstance(parser) {
        this.instance = parser;
    }
    static getInstance() {
        return this.instance;
    }
    parse(response, callbacks) {
        return __awaiter(this, void 0, void 0, function* () {
            var _a;
            let message = response.replace(DONE_TOKEN, '').trim();
            let state;
            let callbackResults;
            for (const key of Object.keys(callbacks || {})) {
                const match = message.match(renderPlaceholder(key));
                if (match) {
                    message = yield this.invokeCallbackAndDropInLegacyResults(callbacks, key, message);
                }
                let xmlCallMatches = message.match(new RegExp(`<<\\s*${key}\\s*\/>>`, 'g'));
                let data;
                if (!xmlCallMatches) {
                    const matchWithJson = message
                        .matchAll(new RegExp(`<<\\s*${key}\\s*>>(.*?)<<\/\\s*${key}\\s*>>`, 'gs'))
                        .next().value;
                    xmlCallMatches = (matchWithJson === null || matchWithJson === void 0 ? void 0 : matchWithJson[0])
                        ? [matchWithJson === null || matchWithJson === void 0 ? void 0 : matchWithJson[0]]
                        : null;
                    data = (matchWithJson === null || matchWithJson === void 0 ? void 0 : matchWithJson[1])
                        ? JSON.parse(matchWithJson === null || matchWithJson === void 0 ? void 0 : matchWithJson[1])
                        : undefined;
                }
                if (xmlCallMatches) {
                    try {
                        callbackResults = yield ((_a = callbacks === null || callbacks === void 0 ? void 0 : callbacks[key]) === null || _a === void 0 ? void 0 : _a.cb(data));
                        message = message.replace(xmlCallMatches[0], '').trim();
                    }
                    catch (error) {
                        throw new SpruceError({
                            code: 'CALLBACK_ERROR',
                            friendlyMessage: `Error while executing callback (${key}). The error is: ${error.message}`,
                            originalError: error,
                        });
                    }
                }
            }
            const matchedCallback = this.findFirstBadCallback(message);
            if (matchedCallback) {
                throw new SpruceError({
                    code: 'INVALID_CALLBACK',
                    validCallbacks: Object.keys(callbacks !== null && callbacks !== void 0 ? callbacks : {}),
                    matchedCallback,
                });
            }
            const { match, fullMatch } = this.parseState(message);
            if (match && fullMatch) {
                message = message.replace(fullMatch, '').trim();
                state = JSON.parse(match);
            }
            return {
                isDone: this.doesIncludeDoneToken(response),
                state,
                message,
                callbackResults: callbackResults !== null && callbackResults !== void 0 ? callbackResults : undefined,
            };
        });
    }
    findFirstBadCallback(message) {
        const simpleMatches = message.match(new RegExp(`<<(.*)\/?>>`, 'g'));
        const extraJsonMatches = message.match(new RegExp(`<<.*?>>(.*?)<<\/.*?>>`, 'gs'));
        const matchedCallback = (extraJsonMatches === null || extraJsonMatches === void 0 ? void 0 : extraJsonMatches[0]) || (simpleMatches === null || simpleMatches === void 0 ? void 0 : simpleMatches[0]);
        return matchedCallback;
    }
    invokeCallbackAndDropInLegacyResults(callbacks, key, message) {
        return __awaiter(this, void 0, void 0, function* () {
            var _a;
            const v = (yield ((_a = callbacks === null || callbacks === void 0 ? void 0 : callbacks[key]) === null || _a === void 0 ? void 0 : _a.cb()));
            message = message.replace(renderPlaceholder(key), v !== null && v !== void 0 ? v : '').trim();
            return message;
        });
    }
    doesIncludeDoneToken(response) {
        return response.includes(DONE_TOKEN);
    }
    parseState(message) {
        const ESCAPED_BOUNDARY = STATE_BOUNDARY.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, '\\$&');
        const searchRegex = new RegExp(`${ESCAPED_BOUNDARY}(.*?)${ESCAPED_BOUNDARY}`);
        const stateMatches = message.match(searchRegex);
        const match = stateMatches === null || stateMatches === void 0 ? void 0 : stateMatches[1];
        return { match, fullMatch: stateMatches === null || stateMatches === void 0 ? void 0 : stateMatches[0] };
    }
}
ResponseParser.instance = new ResponseParser();
export default ResponseParser;
