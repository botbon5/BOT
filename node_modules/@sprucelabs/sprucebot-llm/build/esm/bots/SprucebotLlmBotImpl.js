var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { AbstractEventEmitter } from '@sprucelabs/mercury-event-emitter';
import { assertOptions, defaultSchemaValues, } from '@sprucelabs/schema';
import { llmEventContract, } from '../llm.types.js';
import ResponseParser from '../parsingResponses/ResponseParser.js';
class SprucebotLlmBotImpl extends AbstractEventEmitter {
    constructor(options) {
        const { adapter, youAre, stateSchema, state, skill } = options;
        super(llmEventContract);
        this.isDone = false;
        this.messages = [];
        this.adapter = adapter;
        this.youAre = youAre;
        this.stateSchema = stateSchema;
        this.skill = skill;
        this.state = stateSchema
            ? Object.assign(Object.assign({}, defaultSchemaValues(stateSchema)), state)
            : undefined;
    }
    clearMessageHistory() {
        this.messages = [];
    }
    markAsDone() {
        this.isDone = true;
    }
    getIsDone() {
        return this.isDone;
    }
    serialize() {
        var _a, _b, _c;
        const skill = (_a = this.skill) === null || _a === void 0 ? void 0 : _a.serialize();
        return {
            youAre: this.youAre,
            stateSchema: (_b = this.stateSchema) !== null && _b !== void 0 ? _b : skill === null || skill === void 0 ? void 0 : skill.stateSchema,
            state: (_c = this.state) !== null && _c !== void 0 ? _c : skill === null || skill === void 0 ? void 0 : skill.state,
            messages: this.messages,
            skill,
        };
    }
    sendMessage(message, cb) {
        return __awaiter(this, void 0, void 0, function* () {
            var _a, _b, _c, _d;
            assertOptions({ message }, ['message']);
            const llmMessage = {
                from: 'Me',
                message: '',
            };
            if (typeof message === 'string') {
                llmMessage.message = message;
            }
            else {
                llmMessage.message = message.imageDescription;
                llmMessage.imageBase64 = message.imageBase64;
            }
            this.trackMessage(llmMessage);
            const { model, callbacks } = (_b = (_a = this.skill) === null || _a === void 0 ? void 0 : _a.serialize()) !== null && _b !== void 0 ? _b : {};
            const response = yield this.sendMessageToAdapter(model);
            let parsedMessage;
            let isDone;
            let state;
            let callbackResults;
            try {
                const parsed = yield this.parseResponse(response, callbacks);
                parsedMessage = parsed.message;
                isDone = parsed.isDone;
                state = parsed.state;
                callbackResults = parsed.callbackResults;
            }
            catch (err) {
                if (((_c = err.options) === null || _c === void 0 ? void 0 : _c.code) === 'INVALID_CALLBACK' ||
                    ((_d = err.options) === null || _d === void 0 ? void 0 : _d.code) === 'CALLBACK_ERROR') {
                    return this.sendMessage(`Error: ${err.message}`, cb);
                }
                throw err;
            }
            this.isDone = isDone;
            yield this.optionallyUpdateState(state);
            this.trackMessage({
                from: 'You',
                message: response,
            });
            cb === null || cb === void 0 ? void 0 : cb(parsedMessage);
            if (callbackResults) {
                let message;
                if (typeof callbackResults === 'string') {
                    message = `API Results: ${callbackResults}`;
                }
                else {
                    message = {
                        imageBase64: callbackResults.imageBase64,
                        imageDescription: `API Results: ${callbackResults.imageDescription}`,
                    };
                }
                yield this.sendMessage(message, cb);
            }
            return parsedMessage;
        });
    }
    optionallyUpdateState(state) {
        return __awaiter(this, void 0, void 0, function* () {
            var _a;
            if (this.stateSchema && state) {
                yield this.updateState(state);
            }
            else if (state) {
                yield ((_a = this.skill) === null || _a === void 0 ? void 0 : _a.updateState(state));
            }
        });
    }
    parseResponse(response, callbacks) {
        return __awaiter(this, void 0, void 0, function* () {
            const parser = ResponseParser.getInstance();
            const parsed = yield parser.parse(response, callbacks);
            return parsed;
        });
    }
    sendMessageToAdapter(model) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.adapter.sendMessage(this, {
                model,
            });
        });
    }
    trackMessage(m) {
        if (this.messages.length === SprucebotLlmBotImpl.messageMemoryLimit) {
            this.messages.shift();
        }
        this.messages.push(m);
    }
    updateState(newState) {
        return __awaiter(this, void 0, void 0, function* () {
            this.state = Object.assign(Object.assign({}, this.state), newState);
            yield this.emit('did-update-state');
        });
    }
    setSkill(skill) {
        this.skill = skill;
        this.isDone = false;
    }
}
SprucebotLlmBotImpl.messageMemoryLimit = 10;
export default SprucebotLlmBotImpl;
