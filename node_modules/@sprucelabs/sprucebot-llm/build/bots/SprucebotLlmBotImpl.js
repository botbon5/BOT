"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const mercury_event_emitter_1 = require("@sprucelabs/mercury-event-emitter");
const schema_1 = require("@sprucelabs/schema");
const llm_types_1 = require("../llm.types");
const ResponseParser_1 = __importDefault(require("../parsingResponses/ResponseParser"));
class SprucebotLlmBotImpl extends mercury_event_emitter_1.AbstractEventEmitter {
    constructor(options) {
        const { adapter, youAre, stateSchema, state, skill } = options;
        super(llm_types_1.llmEventContract);
        this.isDone = false;
        this.messages = [];
        this.adapter = adapter;
        this.youAre = youAre;
        this.stateSchema = stateSchema;
        this.skill = skill;
        this.state = stateSchema
            ? {
                ...(0, schema_1.defaultSchemaValues)(stateSchema),
                ...state,
            }
            : undefined;
    }
    clearMessageHistory() {
        this.messages = [];
    }
    markAsDone() {
        this.isDone = true;
    }
    getIsDone() {
        return this.isDone;
    }
    serialize() {
        const skill = this.skill?.serialize();
        return {
            youAre: this.youAre,
            stateSchema: this.stateSchema ?? skill?.stateSchema,
            state: this.state ?? skill?.state,
            messages: this.messages,
            skill,
        };
    }
    async sendMessage(message, cb) {
        (0, schema_1.assertOptions)({ message }, ['message']);
        const llmMessage = {
            from: 'Me',
            message: '',
        };
        if (typeof message === 'string') {
            llmMessage.message = message;
        }
        else {
            llmMessage.message = message.imageDescription;
            llmMessage.imageBase64 = message.imageBase64;
        }
        this.trackMessage(llmMessage);
        const { model, callbacks } = this.skill?.serialize() ?? {};
        const response = await this.sendMessageToAdapter(model);
        let parsedMessage;
        let isDone;
        let state;
        let callbackResults;
        try {
            const parsed = await this.parseResponse(response, callbacks);
            parsedMessage = parsed.message;
            isDone = parsed.isDone;
            state = parsed.state;
            callbackResults = parsed.callbackResults;
        }
        catch (err) {
            if (err.options?.code === 'INVALID_CALLBACK' ||
                err.options?.code === 'CALLBACK_ERROR') {
                return this.sendMessage(`Error: ${err.message}`, cb);
            }
            throw err;
        }
        this.isDone = isDone;
        await this.optionallyUpdateState(state);
        this.trackMessage({
            from: 'You',
            message: response,
        });
        cb?.(parsedMessage);
        if (callbackResults) {
            let message;
            if (typeof callbackResults === 'string') {
                message = `API Results: ${callbackResults}`;
            }
            else {
                message = {
                    imageBase64: callbackResults.imageBase64,
                    imageDescription: `API Results: ${callbackResults.imageDescription}`,
                };
            }
            await this.sendMessage(message, cb);
        }
        return parsedMessage;
    }
    async optionallyUpdateState(state) {
        if (this.stateSchema && state) {
            await this.updateState(state);
        }
        else if (state) {
            await this.skill?.updateState(state);
        }
    }
    async parseResponse(response, callbacks) {
        const parser = ResponseParser_1.default.getInstance();
        const parsed = await parser.parse(response, callbacks);
        return parsed;
    }
    async sendMessageToAdapter(model) {
        return await this.adapter.sendMessage(this, {
            model,
        });
    }
    trackMessage(m) {
        if (this.messages.length === SprucebotLlmBotImpl.messageMemoryLimit) {
            this.messages.shift();
        }
        this.messages.push(m);
    }
    async updateState(newState) {
        this.state = { ...this.state, ...newState };
        await this.emit('did-update-state');
    }
    setSkill(skill) {
        this.skill = skill;
        this.isDone = false;
    }
}
SprucebotLlmBotImpl.messageMemoryLimit = 10;
exports.default = SprucebotLlmBotImpl;
