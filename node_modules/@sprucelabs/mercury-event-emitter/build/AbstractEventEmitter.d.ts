import { EmitCallback, EventSignature, MercuryAggregateResponse, MercuryEventEmitter, EventContract, EventNames, ListenerCallback } from '@sprucelabs/mercury-types';
import { Schema, SchemaValues } from '@sprucelabs/schema';
export default class AbstractEventEmitter<Contract extends EventContract> implements MercuryEventEmitter<Contract> {
    private shouldEmitSequentally;
    protected eventContract: EventContract;
    protected listenersByEvent: Record<string, ((payload?: any) => any | Promise<any>)[]>;
    constructor(contract: EventContract, options?: {
        shouldEmitSequentally?: boolean;
    });
    emit<EventName extends EventNames<Contract>, IEventSignature extends EventSignature = Contract['eventSignatures'][EventName], EmitSchema extends Schema = IEventSignature['emitPayloadSchema'] extends Schema ? IEventSignature['emitPayloadSchema'] : never, ResponseSchema extends Schema = IEventSignature['responsePayloadSchema'] extends Schema ? IEventSignature['responsePayloadSchema'] : never>(eventName: EventName, payload?: (EmitSchema extends Schema ? SchemaValues<EmitSchema> : never) | EmitCallback<Contract, EventName>, cb?: EmitCallback<Contract, EventName>): Promise<MercuryAggregateResponse<SchemaValues<ResponseSchema>>>;
    emitAndFlattenResponses<EventName extends EventNames<Contract>, IEventSignature extends EventSignature = Contract['eventSignatures'][EventName], EmitSchema extends Schema = IEventSignature['emitPayloadSchema'] extends Schema ? IEventSignature['emitPayloadSchema'] : never, ResponseSchema extends Schema = IEventSignature['responsePayloadSchema'] extends Schema ? IEventSignature['responsePayloadSchema'] : never>(eventName: EventName, payload?: (EmitSchema extends Schema ? SchemaValues<EmitSchema> : never) | EmitCallback<Contract, EventName>, cb?: EmitCallback<Contract, EventName>): Promise<SchemaValues<ResponseSchema>[]>;
    private emitOne;
    listenCount(eventName: EventNames<Contract>): number;
    mixinContract(contract: EventContract): void;
    protected validateEmitPayload(schema: Schema | undefined | null, actualPayload: any, eventName: string): void;
    protected validateResponsePayload(schema: Schema | undefined | null, actualPayload: any, eventName: string): void;
    private normalizePayloadAndCallback;
    on<EventName extends EventNames<Contract>, IEventSignature extends EventSignature = Contract['eventSignatures'][EventName]>(eventName: EventName, cb: ListenerCallback<IEventSignature>): Promise<void>;
    off(eventName: EventNames<Contract>, cb?: any): Promise<number>;
}
