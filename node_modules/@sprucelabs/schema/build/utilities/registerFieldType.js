"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.validateFieldRegistration = validateFieldRegistration;
exports.default = registerFieldType;
const SpruceError_1 = __importDefault(require("../errors/SpruceError"));
function validateFieldRegistration(registration) {
    const errors = [];
    const builtRegistration = {
        package: '***missing***',
        className: '***missing***',
        type: '***missing***',
        importAs: '***missing***',
        description: '***missing***',
    };
    if (typeof registration !== 'object') {
        errors.push('field_registration_must_be_object');
    }
    else {
        Object.keys(builtRegistration).forEach((untypedKey) => {
            const key = untypedKey;
            if (typeof registration[key] !== 'string') {
                errors.push(`${key}_must_be_string`);
            }
            else {
                //@ts-ignore
                builtRegistration[key] = registration[key];
            }
        });
    }
    if (errors.length > 0) {
        throw new SpruceError_1.default({
            code: 'INVALID_FIELD_REGISTRATION',
            ...builtRegistration,
        });
    }
}
/** Register a new type of field */
function registerFieldType(options) {
    const registration = {
        package: options.package,
        className: options.class.name,
        type: options.type,
        importAs: options.importAs,
        // TODO change this up when typescript supports typing static methods on a class
        // @ts-ignore
        description: options.class.description,
        // TODO change this up when typescript supports typing static methods on a class
        // @ts-ignore
        ...options.class.generateTypeDetails(),
    };
    validateFieldRegistration(registration);
    return registration;
}
