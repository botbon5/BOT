"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const error_1 = __importDefault(require("@sprucelabs/error"));
const ValidateErrorMessageFormatter_1 = require("./ValidateErrorMessageFormatter");
class SpruceError extends error_1.default {
    friendlyMessage() {
        const { options } = this;
        if (options.friendlyMessage) {
            return options.friendlyMessage;
        }
        let message;
        switch (options?.code) {
            case 'DUPLICATE_SCHEMA':
                message = `Duplicate schema -> '${this.buildSchemaName(options)}'.`;
                break;
            case 'SCHEMA_NOT_FOUND':
                message = `Could not find schema -> '${this.buildSchemaName(options)}'.`;
                break;
            case 'TRANSFORMATION_ERROR':
                message = '';
                options.errors?.forEach((error) => {
                    message += `Error transforming '${error.name}':\n`;
                    const m = error.friendlyMessage || error.originalError?.message;
                    if (m) {
                        message += ` - ${m}`;
                    }
                });
                if (message === '') {
                    message = `Could not transform a(n) ${options.incomingTypeof} to the  ${options.fieldType}. The incoming value was ${(JSON.stringify(options.incomingValue), null, 2)}.`;
                }
                break;
            case 'NOT_IMPLEMENTED':
                message = `${options.code}: ${options.instructions}`;
                break;
            case 'INVALID_SCHEMA':
                message = `Invalid schema with id: ${options.schemaId}. ${options.errors.length > 0
                    ? `Errors are: \n\n${options.errors.join('\n')}\n\n`
                    : ``}`;
                break;
            case 'VALIDATION_FAILED': {
                const formatter = new ValidateErrorMessageFormatter_1.ValidateErrorMessageFormatter(this);
                message = formatter.render();
                break;
            }
            case 'MISSING_PARAMETERS':
            case 'UNEXPECTED_PARAMETERS':
            case 'INVALID_PARAMETERS': {
                const map = {
                    MISSING_PARAMETERS: `Missing ${options.parameters.length} parameter${options.parameters.length === 1 ? '' : 's'}`,
                    UNEXPECTED_PARAMETERS: `Found ${options.parameters.length} unexpected parameter${options.parameters.length === 1 ? '' : 's'}`,
                    INVALID_PARAMETERS: `${options.parameters.length} parameter${options.parameters.length === 1 ? '' : 's'} ${options.parameters.length === 1 ? 'is' : 'are'} invalid`,
                };
                message = `${map[options.code]}:\n\n${this.renderParametersWithFriendlyMessages(options.parameters, options.friendlyMessages)}`;
                break;
            }
            case 'FIELDS_NOT_MAPPED':
                message = `The following fields were not mapped because they don't exist in your map: ${options.fields.join(', ')}`;
                break;
            default:
                message = this.message;
        }
        return message;
    }
    renderParametersWithFriendlyMessages(parameters, friendlyMessages) {
        const friendly = (friendlyMessages ?? parameters)
            .filter((m) => !!m)
            .map((m) => `${m}`)
            .join('\n');
        if (!friendly) {
            return '';
        }
        return friendly;
    }
    buildSchemaName(options) {
        return `${options.namespace ? options.namespace + '.' : ''}${options.schemaId}${options.version ? `(version: ${options.version})` : ''}`;
    }
}
exports.default = SpruceError;
