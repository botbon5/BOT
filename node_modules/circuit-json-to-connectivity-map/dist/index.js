// src/findConnectedNetworks.ts
function findConnectedNetworks(connections) {
  const networks = /* @__PURE__ */ new Map();
  let netCounter = 0;
  function getOrCreateNetwork(nodeId) {
    for (const [, network] of networks) {
      if (network.has(nodeId)) {
        return network;
      }
    }
    const newNetwork = /* @__PURE__ */ new Set();
    networks.set(`connectivity_net${netCounter++}`, newNetwork);
    return newNetwork;
  }
  for (const connection of connections) {
    let network = null;
    for (const nodeId of connection) {
      if (!network) {
        network = getOrCreateNetwork(nodeId);
      } else if (!network.has(nodeId)) {
        const existingNetwork = getOrCreateNetwork(nodeId);
        if (existingNetwork !== network) {
          for (const node of existingNetwork) {
            network.add(node);
          }
          networks.delete(
            Array.from(networks.entries()).find(
              ([, net]) => net === existingNetwork
            )[0]
          );
        }
      }
      network.add(nodeId);
    }
  }
  return Object.fromEntries(
    Array.from(networks.entries()).map(([netId, connectedNodes]) => [
      netId,
      Array.from(connectedNodes)
    ])
  );
}

// src/ConnectivityMap.ts
var ConnectivityMap = class {
  netMap;
  idToNetMap;
  constructor(netMap) {
    this.netMap = netMap;
    this.idToNetMap = {};
    for (const [netId, ids] of Object.entries(netMap)) {
      for (const id of ids) {
        this.idToNetMap[id] = netId;
      }
    }
  }
  addConnections(connections) {
    for (const connection of connections) {
      const existingNets = /* @__PURE__ */ new Set();
      for (const id of connection) {
        const existingNetId = this.idToNetMap[id];
        if (existingNetId) {
          existingNets.add(existingNetId);
        }
      }
      let targetNetId;
      if (existingNets.size === 0) {
        targetNetId = `connectivity_net${Object.keys(this.netMap).length}`;
        this.netMap[targetNetId] = [];
      } else if (existingNets.size === 1) {
        targetNetId = existingNets.values().next().value ?? `connectivity_net${Object.keys(this.netMap).length}`;
      } else {
        targetNetId = existingNets.values().next().value ?? `connectivity_net${Object.keys(this.netMap).length}`;
        for (const netId of existingNets) {
          if (netId !== targetNetId) {
            this.netMap[targetNetId].push(...this.netMap[netId]);
            this.netMap[netId] = this.netMap[targetNetId];
            for (const id of this.netMap[targetNetId]) {
              this.idToNetMap[id] = targetNetId;
            }
          }
        }
      }
      for (const id of connection) {
        if (!this.netMap[targetNetId].includes(id)) {
          this.netMap[targetNetId].push(id);
        }
        this.idToNetMap[id] = targetNetId;
      }
    }
  }
  getIdsConnectedToNet(netId) {
    return this.netMap[netId] || [];
  }
  getNetConnectedToId(id) {
    return this.idToNetMap[id];
  }
  areIdsConnected(id1, id2) {
    if (id1 === id2) return true;
    const netId1 = this.getNetConnectedToId(id1);
    if (!netId1) return false;
    const netId2 = this.getNetConnectedToId(id2);
    if (!netId2) return false;
    return netId1 === netId2 || netId2 === id1 || netId2 === id1;
  }
  areAllIdsConnected(ids) {
    const netId = this.getNetConnectedToId(ids[0]);
    for (const id of ids) {
      const nextNetId = this.getNetConnectedToId(id);
      if (nextNetId === void 0) {
        return false;
      }
      if (nextNetId !== netId) {
        return false;
      }
    }
    return true;
  }
};

// src/getSourcePortConnectivityMapFromCircuitJson.ts
var getSourcePortConnectivityMapFromCircuitJson = (circuitJson) => {
  const connections = [];
  for (const element of circuitJson) {
    if (element.type === "source_trace") {
      connections.push([
        ...element.connected_source_port_ids ?? [],
        ...element.connected_source_net_ids ?? []
      ]);
    } else if (element.type === "source_component") {
      if (element.internally_connected_source_port_ids) {
        for (const portGroup of element.internally_connected_source_port_ids) {
          connections.push(portGroup);
        }
      }
    }
  }
  const netMap = findConnectedNetworks(connections);
  return new ConnectivityMap(netMap);
};

// src/getFullConnectivityMapFromCircuitJson.ts
var getFullConnectivityMapFromCircuitJson = (circuitJson) => {
  const connections = [];
  for (const element of circuitJson) {
    if (element.type === "source_trace") {
      connections.push(
        [
          element.source_trace_id,
          ...element.connected_source_port_ids ?? [],
          ...element.connected_source_net_ids ?? []
        ].filter(Boolean)
      );
    } else if (element.type === "pcb_port") {
      const { pcb_port_id, source_port_id } = element;
      if (source_port_id && pcb_port_id) {
        connections.push([source_port_id, pcb_port_id]);
      }
    } else if (element.type === "pcb_smtpad") {
      const { pcb_smtpad_id, pcb_port_id } = element;
      if (pcb_port_id && pcb_smtpad_id) {
        connections.push([pcb_smtpad_id, pcb_port_id]);
      }
    } else if (element.type === "pcb_plated_hole") {
      const { pcb_plated_hole_id, pcb_port_id } = element;
      if (pcb_port_id && pcb_plated_hole_id) {
        connections.push([pcb_plated_hole_id, pcb_port_id]);
      }
    } else if (element.type === "pcb_trace") {
      const { pcb_trace_id, source_trace_id } = element;
      const route = Array.isArray(element.route) ? element.route.filter((rp) => rp && rp.route_type === "wire") : [];
      if (source_trace_id && pcb_trace_id) {
        connections.push([pcb_trace_id, source_trace_id]);
      }
      if (Array.isArray(route)) {
        const startId = route.find(
          (rp) => rp && rp.start_pcb_port_id
        )?.start_pcb_port_id;
        const endId = route.find(
          (rp) => rp && rp.end_pcb_port_id
        )?.end_pcb_port_id;
        if (startId && pcb_trace_id && endId) {
          connections.push([startId, pcb_trace_id, endId]);
        }
      }
    } else if (element.type === "pcb_via") {
      const { pcb_via_id, pcb_trace_id } = element;
      if (pcb_trace_id && pcb_via_id) {
        connections.push([pcb_via_id, pcb_trace_id]);
      }
    } else if (element.type === "source_component") {
      if (element.internally_connected_source_port_ids) {
        for (const portGroup of element.internally_connected_source_port_ids) {
          connections.push(portGroup);
        }
      }
    }
  }
  const netMap = findConnectedNetworks(connections);
  return new ConnectivityMap(netMap);
};

// src/PcbConnectivityMap.ts
import { doesLineIntersectLine } from "@tscircuit/math-utils";
var PcbConnectivityMap = class {
  circuitJson;
  traceIdToElm;
  portIdToElm;
  connMap;
  constructor(circuitJson) {
    this.circuitJson = circuitJson || [];
    this.traceIdToElm = /* @__PURE__ */ new Map();
    this.portIdToElm = /* @__PURE__ */ new Map();
    if (circuitJson) {
      this._buildTraceMap();
      this._buildPortMap();
      this.connMap = this._buildTraceConnectivityMap();
    } else {
      this.connMap = new ConnectivityMap({});
    }
  }
  _buildPortMap() {
    for (const element of this.circuitJson) {
      if (element.type === "pcb_port") {
        this.portIdToElm.set(element.pcb_port_id, element);
      }
    }
  }
  _buildTraceMap() {
    for (const element of this.circuitJson) {
      if (element.type === "pcb_trace") {
        this.traceIdToElm.set(element.pcb_trace_id, element);
      }
    }
  }
  _buildTraceConnectivityMap() {
    const connections = [];
    const traceIds = Array.from(this.traceIdToElm.keys());
    for (let i = 0; i < traceIds.length; i++) {
      for (let j = i + 1; j < traceIds.length; j++) {
        const trace1 = this.traceIdToElm.get(traceIds[i]);
        const trace2 = this.traceIdToElm.get(traceIds[j]);
        if (this._arePcbTracesConnected(trace1, trace2)) {
          connections.push([traceIds[i], traceIds[j]]);
        }
      }
    }
    for (const port of this.portIdToElm.values()) {
      for (const trace of this.traceIdToElm.values()) {
        for (const rp of trace.route) {
          if (rp.route_type === "wire") {
            if (rp.start_pcb_port_id === port.pcb_port_id) {
              connections.push([port.pcb_port_id, trace.pcb_trace_id]);
            } else if (rp.end_pcb_port_id === port.pcb_port_id) {
              connections.push([trace.pcb_trace_id, port.pcb_port_id]);
            }
          }
        }
      }
    }
    return new ConnectivityMap(findConnectedNetworks(connections));
  }
  addTrace(trace) {
    this.traceIdToElm.set(trace.pcb_trace_id, trace);
    const connections = [];
    for (const rp of trace.route) {
      if (rp.route_type === "wire") {
        if (rp.start_pcb_port_id) {
          connections.push([rp.start_pcb_port_id, trace.pcb_trace_id]);
        }
        if (rp.end_pcb_port_id) {
          connections.push([rp.end_pcb_port_id, trace.pcb_trace_id]);
        }
      }
    }
    this.connMap.addConnections(connections);
  }
  _arePcbTracesConnected(trace1, trace2) {
    for (let i = 0; i < trace1.route.length - 1; i++) {
      const segment1A = trace1.route[i];
      const segment1B = trace1.route[i + 1];
      if (segment1A.route_type !== "wire") continue;
      if (segment1B.route_type !== "wire") continue;
      for (let j = 0; j < trace2.route.length - 1; j++) {
        const segment2A = trace2.route[j];
        const segment2B = trace2.route[j + 1];
        if (segment2A.route_type !== "wire") continue;
        if (segment2B.route_type !== "wire") continue;
        const isOverlapping = doesLineIntersectLine(
          [segment1A, segment1B],
          [segment2A, segment2B],
          {
            lineThickness: (segment1A.width + segment2A.width) / 2
          }
        );
        if (isOverlapping) {
          return true;
        }
      }
    }
    return false;
  }
  areTracesConnected(traceId1, traceId2) {
    return this.connMap.areIdsConnected(traceId1, traceId2);
  }
  getAllTracesConnectedToTrace(traceId) {
    const netId = this.connMap.getNetConnectedToId(traceId);
    return netId ? this.connMap.getIdsConnectedToNet(netId).filter((id) => this.traceIdToElm.has(id)).map((id) => this.traceIdToElm.get(id)) : [];
  }
  getAllTracesConnectedToPort(portId) {
    const netId = this.connMap.getNetConnectedToId(portId);
    return netId ? this.connMap.getIdsConnectedToNet(netId).filter((id) => this.traceIdToElm.has(id)).map((id) => this.traceIdToElm.get(id)) : [];
  }
};
export {
  ConnectivityMap,
  PcbConnectivityMap,
  findConnectedNetworks,
  getFullConnectivityMapFromCircuitJson,
  getSourcePortConnectivityMapFromCircuitJson
};
//# sourceMappingURL=index.js.map