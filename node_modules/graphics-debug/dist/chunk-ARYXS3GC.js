import {
  FONT_SIZE_HEIGHT_RATIO,
  FONT_SIZE_WIDTH_RATIO
} from "./chunk-ZGI74PYD.js";

// lib/drawGraphicsToCanvas.ts
import {
  compose,
  scale,
  translate,
  applyToPoint
} from "transformation-matrix";

// site/components/InteractiveGraphics/defaultColors.ts
var defaultColors = [
  "rgba(239, 68, 68, 0.8)",
  // red-300
  "rgba(249, 115, 22, 0.8)",
  // orange-300
  "rgba(245, 158, 11, 0.8)",
  // amber-300
  "rgba(234, 179, 8, 0.8)",
  // yellow-300
  "rgba(132, 204, 22, 0.8)",
  // lime-300
  "rgba(34, 197, 94, 0.8)",
  // green-300
  "rgba(16, 185, 129, 0.8)",
  // emerald-300
  "rgba(20, 184, 166, 0.8)",
  // teal-300
  "rgba(6, 182, 212, 0.8)",
  // cyan-300
  "rgba(14, 165, 233, 0.8)",
  // sky-300
  "rgba(59, 130, 246, 0.8)",
  // blue-300
  "rgba(99, 102, 241, 0.8)",
  // indigo-300
  "rgba(139, 92, 246, 0.8)",
  // violet-300
  "rgba(168, 85, 247, 0.8)",
  // purple-300
  "rgba(217, 70, 239, 0.8)",
  // fuchsia-300
  "rgba(236, 72, 153, 0.8)",
  // pink-300
  "rgba(249, 168, 212, 0.8)",
  // rose-300
  "rgba(161, 161, 170, 0.8)"
  // zinc-300
];

// lib/drawGraphicsToCanvas.ts
function computeTransformFromViewbox(viewbox, canvasWidth, canvasHeight, options = {}) {
  const padding = options.padding ?? 40;
  const yFlip = options.yFlip ?? false;
  let bounds;
  if ("center" in viewbox) {
    const halfWidth = viewbox.width / 2;
    const halfHeight = viewbox.height / 2;
    bounds = {
      minX: viewbox.center.x - halfWidth,
      maxX: viewbox.center.x + halfWidth,
      minY: viewbox.center.y - halfHeight,
      maxY: viewbox.center.y + halfHeight
    };
  } else {
    bounds = viewbox;
  }
  const width = bounds.maxX - bounds.minX || 1;
  const height = bounds.maxY - bounds.minY || 1;
  const scale_factor = Math.min(
    (canvasWidth - 2 * padding) / width,
    (canvasHeight - 2 * padding) / height
  );
  return compose(
    translate(canvasWidth / 2, canvasHeight / 2),
    scale(scale_factor, yFlip ? -scale_factor : scale_factor),
    translate(-(bounds.minX + width / 2), -(bounds.minY + height / 2))
  );
}
function getBounds(graphics) {
  const points = [
    ...graphics.points || [],
    ...(graphics.lines || []).flatMap((line) => line.points),
    ...(graphics.rects || []).flatMap((rect) => {
      const halfWidth = rect.width / 2;
      const halfHeight = rect.height / 2;
      return [
        { x: rect.center.x - halfWidth, y: rect.center.y - halfHeight },
        { x: rect.center.x + halfWidth, y: rect.center.y - halfHeight },
        { x: rect.center.x - halfWidth, y: rect.center.y + halfHeight },
        { x: rect.center.x + halfWidth, y: rect.center.y + halfHeight }
      ];
    }),
    ...(graphics.circles || []).flatMap((circle) => [
      { x: circle.center.x - circle.radius, y: circle.center.y },
      // left
      { x: circle.center.x + circle.radius, y: circle.center.y },
      // right
      { x: circle.center.x, y: circle.center.y - circle.radius },
      // top
      { x: circle.center.x, y: circle.center.y + circle.radius }
      // bottom
    ]),
    ...(graphics.texts || []).flatMap((text) => {
      const fontSize = text.fontSize ?? 12;
      const width = text.text.length * fontSize * FONT_SIZE_WIDTH_RATIO;
      const height = fontSize * FONT_SIZE_HEIGHT_RATIO;
      const anchor = text.anchorSide ?? "center";
      const offsetMap = {
        top_left: { dx: 0, dy: 0 },
        top_center: { dx: -width / 2, dy: 0 },
        top_right: { dx: -width, dy: 0 },
        center_left: { dx: 0, dy: -height / 2 },
        center: { dx: -width / 2, dy: -height / 2 },
        center_right: { dx: -width, dy: -height / 2 },
        bottom_left: { dx: 0, dy: -height },
        bottom_center: { dx: -width / 2, dy: -height },
        bottom_right: { dx: -width, dy: -height }
      };
      const { dx, dy } = offsetMap[anchor];
      const x0 = text.x + dx;
      const y0 = text.y + dy;
      return [
        { x: x0, y: y0 },
        { x: x0 + width, y: y0 + height }
      ];
    })
  ];
  if (points.length === 0) {
    return { minX: -1, maxX: 1, minY: -1, maxY: 1 };
  }
  return points.reduce(
    (bounds, point) => ({
      minX: Math.min(bounds.minX, point.x),
      maxX: Math.max(bounds.maxX, point.x),
      minY: Math.min(bounds.minY, point.y),
      maxY: Math.max(bounds.maxY, point.y)
    }),
    { minX: Infinity, maxX: -Infinity, minY: Infinity, maxY: -Infinity }
  );
}
function drawGraphicsToCanvas(graphics, target, options = {}) {
  const ctx = target instanceof HTMLCanvasElement ? target.getContext("2d") : target;
  if (!ctx) {
    throw new Error("Could not get 2D context from canvas");
  }
  const canvasWidth = target instanceof HTMLCanvasElement ? target.width : target.canvas.width;
  const canvasHeight = target instanceof HTMLCanvasElement ? target.height : target.canvas.height;
  let matrix;
  if (options.transform) {
    matrix = options.transform;
  } else if (options.viewbox) {
    matrix = computeTransformFromViewbox(
      options.viewbox,
      canvasWidth,
      canvasHeight,
      {
        padding: options.padding,
        yFlip: options.yFlip
      }
    );
  } else {
    const bounds = getBounds(graphics);
    const yFlip = graphics.coordinateSystem === "cartesian";
    matrix = computeTransformFromViewbox(bounds, canvasWidth, canvasHeight, {
      padding: options.padding ?? 40,
      yFlip
    });
  }
  ctx.clearRect(0, 0, canvasWidth, canvasHeight);
  ctx.save();
  if (graphics.rects && graphics.rects.length > 0) {
    graphics.rects.forEach((rect) => {
      const halfWidth = rect.width / 2;
      const halfHeight = rect.height / 2;
      const topLeft = applyToPoint(matrix, {
        x: rect.center.x - halfWidth,
        y: rect.center.y - halfHeight
      });
      const bottomRight = applyToPoint(matrix, {
        x: rect.center.x + halfWidth,
        y: rect.center.y + halfHeight
      });
      const width = Math.abs(bottomRight.x - topLeft.x);
      const height = Math.abs(bottomRight.y - topLeft.y);
      ctx.beginPath();
      ctx.rect(
        Math.min(topLeft.x, bottomRight.x),
        Math.min(topLeft.y, bottomRight.y),
        width,
        height
      );
      if (rect.fill) {
        ctx.fillStyle = rect.fill;
        ctx.fill();
      }
      if (rect.stroke) {
        ctx.strokeStyle = rect.stroke;
        ctx.stroke();
      }
    });
  }
  if (graphics.circles && graphics.circles.length > 0) {
    graphics.circles.forEach((circle) => {
      const projected = applyToPoint(matrix, circle.center);
      const scaledRadius = circle.radius * Math.abs(matrix.a);
      ctx.beginPath();
      ctx.arc(projected.x, projected.y, scaledRadius, 0, 2 * Math.PI);
      if (circle.fill) {
        ctx.fillStyle = circle.fill;
        ctx.fill();
      }
      if (circle.stroke) {
        ctx.strokeStyle = circle.stroke ?? "transparent";
        ctx.stroke();
      }
    });
  }
  if (graphics.lines && graphics.lines.length > 0) {
    graphics.lines.forEach((line, lineIndex) => {
      if (line.points.length === 0) return;
      ctx.beginPath();
      const firstPoint = applyToPoint(matrix, line.points[0]);
      ctx.moveTo(firstPoint.x, firstPoint.y);
      for (let i = 1; i < line.points.length; i++) {
        const projected = applyToPoint(matrix, line.points[i]);
        ctx.lineTo(projected.x, projected.y);
      }
      ctx.strokeStyle = line.strokeColor || defaultColors[lineIndex % defaultColors.length];
      if (line.strokeWidth) {
        ctx.lineWidth = line.strokeWidth * matrix.a;
      } else {
        ctx.lineWidth = 2;
      }
      ctx.lineCap = "round";
      if (line.strokeDash) {
        if (typeof line.strokeDash === "string") {
          let dashArray;
          if (line.strokeDash.includes(",")) {
            dashArray = line.strokeDash.split(",").map((s) => parseFloat(s.trim())).filter((n) => !Number.isNaN(n));
          } else {
            const value = parseFloat(line.strokeDash.trim());
            dashArray = !Number.isNaN(value) ? [value] : [];
          }
          ctx.setLineDash(dashArray);
        } else {
          ctx.setLineDash(line.strokeDash.map((n) => n * Math.abs(matrix.a)));
        }
      } else {
        ctx.setLineDash([]);
      }
      ctx.stroke();
    });
  }
  if (graphics.points && graphics.points.length > 0) {
    graphics.points.forEach((point, pointIndex) => {
      const projected = applyToPoint(matrix, point);
      ctx.beginPath();
      ctx.arc(projected.x, projected.y, 3, 0, 2 * Math.PI);
      ctx.fillStyle = point.color || defaultColors[pointIndex % defaultColors.length];
      ctx.fill();
      if (point.label && !options.disableLabels) {
        ctx.fillStyle = point.color || "black";
        ctx.font = "12px sans-serif";
        ctx.fillText(point.label, projected.x + 5, projected.y - 5);
      }
    });
  }
  if (graphics.texts && graphics.texts.length > 0) {
    graphics.texts.forEach((text) => {
      const projected = applyToPoint(matrix, { x: text.x, y: text.y });
      ctx.fillStyle = text.color || "black";
      ctx.font = `${(text.fontSize ?? 12) * Math.abs(matrix.a)}px sans-serif`;
      const anchor = text.anchorSide ?? "center";
      const alignMap = {
        top_left: "left",
        center_left: "left",
        bottom_left: "left",
        top_center: "center",
        center: "center",
        bottom_center: "center",
        top_right: "right",
        center_right: "right",
        bottom_right: "right"
      };
      const baselineMap = {
        top_left: "top",
        top_center: "top",
        top_right: "top",
        center_left: "middle",
        center: "middle",
        center_right: "middle",
        bottom_left: "bottom",
        bottom_center: "bottom",
        bottom_right: "bottom"
      };
      ctx.textAlign = alignMap[anchor];
      ctx.textBaseline = baselineMap[anchor];
      ctx.fillText(text.text, projected.x, projected.y);
    });
  }
  ctx.restore();
}

export {
  defaultColors,
  computeTransformFromViewbox,
  getBounds,
  drawGraphicsToCanvas
};
//# sourceMappingURL=chunk-ARYXS3GC.js.map