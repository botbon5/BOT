import "../chunk-KUBBJEL2.js";
import "../chunk-K5GFS6QZ.js";
import "../chunk-K2IJQPPY.js";
import {
  defaultColors,
  drawGraphicsToCanvas,
  getBounds
} from "../chunk-ARYXS3GC.js";
import "../chunk-NG6H63SM.js";
import "../chunk-LCOO4FCL.js";
import "../chunk-ZGI74PYD.js";
import "../chunk-TJJMMKHI.js";

// site/components/InteractiveGraphics/InteractiveGraphics.tsx
import {
  compose,
  scale,
  translate,
  inverse as inverse2,
  applyToPoint as applyToPoint11
} from "transformation-matrix";
import { useMemo as useMemo8, useState as useState6, useEffect as useEffect3, useCallback } from "react";
import useMouseMatrixTransform from "use-mouse-matrix-transform";
import { SuperGrid } from "react-supergrid";
import useResizeObserver from "@react-hook/resize-observer";

// site/components/InteractiveGraphics/Line.tsx
import { applyToPoint } from "transformation-matrix";
import { useState } from "react";

// site/components/InteractiveGraphics/Tooltip.tsx
import { jsx } from "react/jsx-runtime";
var Tooltip = ({ text }) => {
  return /* @__PURE__ */ jsx(
    "div",
    {
      style: {
        background: "white",
        border: "1px solid #ccc",
        boxShadow: "0 0 10px 0 rgba(0, 0, 0, 0.1)",
        borderRadius: "4px",
        padding: "4px 8px",
        fontSize: "12px",
        minWidth: "150px",
        maxWidth: "300px",
        overflow: "hidden",
        textOverflow: "ellipsis",
        whiteSpace: "pre-wrap",
        zIndex: 100
      },
      children: text
    }
  );
};

// site/utils/distToLineSegment.ts
var distToLineSegment = (px, py, x1, y1, x2, y2) => {
  const A = px - x1;
  const B = py - y1;
  const C = x2 - x1;
  const D = y2 - y1;
  const dot = A * C + B * D;
  const lenSq = C * C + D * D;
  let param = -1;
  if (lenSq !== 0) param = dot / lenSq;
  let xx = 0;
  let yy = 0;
  if (param < 0) {
    xx = x1;
    yy = y1;
  } else if (param > 1) {
    xx = x2;
    yy = y2;
  } else {
    xx = x1 + param * C;
    yy = y1 + param * D;
  }
  const dx = px - xx;
  const dy = py - yy;
  return Math.sqrt(dx * dx + dy * dy);
};

// site/utils/safeLighten.ts
import { lighten } from "polished";
var safeLighten = (amount, color) => {
  try {
    return lighten(amount, color);
  } catch (e) {
    return color;
  }
};

// site/components/InteractiveGraphics/Line.tsx
import { jsx as jsx2, jsxs } from "react/jsx-runtime";
var Line = ({
  line,
  index,
  interactiveState
}) => {
  const { activeLayers, activeStep, realToScreen, onObjectClicked } = interactiveState;
  const {
    points,
    layer,
    step,
    strokeColor,
    strokeWidth = 1 / realToScreen.a,
    strokeDash
  } = line;
  const [isHovered, setIsHovered] = useState(false);
  const [mousePos, setMousePos] = useState({ x: 0, y: 0 });
  const screenPoints = points.map((p) => applyToPoint(realToScreen, p));
  const handleMouseMove = (e) => {
    const rect = e.currentTarget.getBoundingClientRect();
    const mouseX = e.clientX - rect.left;
    const mouseY = e.clientY - rect.top;
    const hoverThreshold = 10;
    setMousePos({ x: mouseX, y: mouseY });
    let isNearLine = false;
    for (let i = 0; i < screenPoints.length - 1; i++) {
      const dist = distToLineSegment(
        mouseX,
        mouseY,
        screenPoints[i].x,
        screenPoints[i].y,
        screenPoints[i + 1].x,
        screenPoints[i + 1].y
      );
      if (dist < hoverThreshold) {
        isNearLine = true;
        break;
      }
    }
    setIsHovered(isNearLine);
  };
  const baseColor = strokeColor ?? defaultColors[index % defaultColors.length];
  return /* @__PURE__ */ jsxs(
    "svg",
    {
      style: {
        position: "absolute",
        top: 0,
        left: 0,
        width: "100%",
        height: "100%"
      },
      onMouseMove: handleMouseMove,
      onMouseLeave: () => setIsHovered(false),
      onClick: isHovered ? () => onObjectClicked?.({
        type: "line",
        index,
        object: line
      }) : void 0,
      children: [
        /* @__PURE__ */ jsx2(
          "polyline",
          {
            points: screenPoints.map((p) => `${p.x},${p.y}`).join(" "),
            stroke: isHovered ? safeLighten(0.2, baseColor) : baseColor,
            fill: "none",
            strokeWidth: strokeWidth * realToScreen.a,
            strokeDasharray: !strokeDash ? void 0 : typeof strokeDash === "string" ? strokeDash : `${strokeDash[0] * realToScreen.a}, ${strokeDash[1] * realToScreen.a}`,
            strokeLinecap: "round"
          }
        ),
        isHovered && line.label && /* @__PURE__ */ jsx2(
          "foreignObject",
          {
            x: mousePos.x,
            y: mousePos.y - 40,
            width: 300,
            height: 40,
            children: /* @__PURE__ */ jsx2(Tooltip, { text: line.label })
          }
        )
      ]
    }
  );
};

// site/components/InteractiveGraphics/Point.tsx
import { applyToPoint as applyToPoint2 } from "transformation-matrix";
import { useState as useState2 } from "react";
import { jsx as jsx3 } from "react/jsx-runtime";
var Point = ({
  point,
  interactiveState,
  index
}) => {
  const { color, label, layer, step } = point;
  const { activeLayers, activeStep, realToScreen, onObjectClicked } = interactiveState;
  const [isHovered, setIsHovered] = useState2(false);
  const screenPoint = applyToPoint2(realToScreen, point);
  const size = 10;
  return /* @__PURE__ */ jsx3(
    "div",
    {
      style: {
        position: "absolute",
        left: screenPoint.x - size / 2,
        top: screenPoint.y - size / 2,
        width: size,
        height: size,
        borderRadius: "50%",
        border: `2px solid ${isHovered ? safeLighten(
          0.2,
          color ?? defaultColors[index % defaultColors.length]
        ) : color ?? defaultColors[index % defaultColors.length]}`,
        cursor: "pointer",
        transition: "border-color 0.2s"
      },
      onMouseEnter: () => setIsHovered(true),
      onMouseLeave: () => setIsHovered(false),
      onClick: () => onObjectClicked?.({
        type: "point",
        index,
        object: point
      }),
      children: isHovered && /* @__PURE__ */ jsx3(
        "div",
        {
          style: {
            position: "absolute",
            bottom: "100%",
            left: "50%",
            transform: "translateX(-50%)",
            marginBottom: 8
          },
          children: /* @__PURE__ */ jsx3(
            Tooltip,
            {
              text: `${label ? `${label}
` : ""}x: ${point.x.toFixed(2)}, y: ${point.y.toFixed(2)}`
            }
          )
        }
      )
    }
  );
};

// site/components/InteractiveGraphics/Rect.tsx
import { applyToPoint as applyToPoint3 } from "transformation-matrix";
import { useState as useState3 } from "react";
import { jsx as jsx4 } from "react/jsx-runtime";
var Rect = ({
  rect,
  interactiveState,
  index
}) => {
  const defaultColor = defaultColors[index % defaultColors.length];
  let { center, width, height, fill, stroke, layer, step } = rect;
  const { activeLayers, activeStep, realToScreen, onObjectClicked } = interactiveState;
  const [isHovered, setIsHovered] = useState3(false);
  const screenCenter = applyToPoint3(realToScreen, center);
  const screenWidth = width * realToScreen.a;
  const screenHeight = height * Math.abs(realToScreen.d);
  const hasStrokeOrFill = fill !== void 0 || stroke !== void 0;
  let backgroundColor = hasStrokeOrFill ? fill || "transparent" : defaultColor;
  if (isHovered) {
    backgroundColor = safeLighten(0.2, backgroundColor);
    stroke = safeLighten(0.2, stroke);
  }
  return /* @__PURE__ */ jsx4(
    "div",
    {
      style: {
        position: "absolute",
        left: screenCenter.x - screenWidth / 2,
        top: screenCenter.y - screenHeight / 2,
        width: screenWidth,
        height: screenHeight,
        backgroundColor,
        border: stroke ? `2px solid ${isHovered ? safeLighten(0.2, stroke) : stroke}` : "none",
        cursor: "pointer",
        transition: "border-color 0.2s"
      },
      onMouseEnter: () => setIsHovered(true),
      onMouseLeave: () => setIsHovered(false),
      onClick: () => onObjectClicked?.({
        type: "rect",
        index,
        object: rect
      }),
      children: isHovered && rect.label && /* @__PURE__ */ jsx4(
        "div",
        {
          style: {
            position: "absolute",
            bottom: "100%",
            left: "50%",
            transform: "translateX(-50%)",
            marginBottom: 8
          },
          children: /* @__PURE__ */ jsx4(Tooltip, { text: rect.label })
        }
      )
    }
  );
};

// site/components/InteractiveGraphics/Circle.tsx
import { applyToPoint as applyToPoint4 } from "transformation-matrix";
import { useState as useState4 } from "react";
import { jsx as jsx5 } from "react/jsx-runtime";
var Circle = ({
  circle,
  interactiveState,
  index
}) => {
  const defaultColor = defaultColors[index % defaultColors.length];
  let { center, radius, fill, stroke, layer, step, label } = circle;
  const { activeLayers, activeStep, realToScreen, onObjectClicked } = interactiveState;
  const [isHovered, setIsHovered] = useState4(false);
  const screenCenter = applyToPoint4(realToScreen, center);
  const screenRadius = radius * realToScreen.a;
  let backgroundColor = fill || defaultColor;
  if (isHovered) {
    backgroundColor = safeLighten(0.2, backgroundColor);
    stroke = stroke ? safeLighten(0.2, stroke) : stroke;
  }
  return /* @__PURE__ */ jsx5(
    "div",
    {
      style: {
        position: "absolute",
        left: screenCenter.x - screenRadius,
        top: screenCenter.y - screenRadius,
        width: screenRadius * 2,
        height: screenRadius * 2,
        borderRadius: "50%",
        backgroundColor,
        border: stroke ? `2px solid ${stroke}` : "none",
        cursor: "pointer",
        transition: "border-color 0.2s"
      },
      onMouseEnter: () => setIsHovered(true),
      onMouseLeave: () => setIsHovered(false),
      onClick: () => onObjectClicked?.({
        type: "circle",
        index,
        object: circle
      }),
      children: isHovered && label && /* @__PURE__ */ jsx5(
        "div",
        {
          style: {
            position: "absolute",
            bottom: "100%",
            left: "50%",
            transform: "translateX(-50%)",
            marginBottom: 8
          },
          children: /* @__PURE__ */ jsx5(Tooltip, { text: label })
        }
      )
    }
  );
};

// site/components/InteractiveGraphics/Text.tsx
import { applyToPoint as applyToPoint5 } from "transformation-matrix";
import { jsx as jsx6 } from "react/jsx-runtime";
var Text = ({
  textObj,
  interactiveState,
  index
}) => {
  const { realToScreen, onObjectClicked } = interactiveState;
  const { x, y, text, color, fontSize, anchorSide } = textObj;
  const screenPos = applyToPoint5(realToScreen, { x, y });
  const transformMap = {
    top_left: "translate(0%, 0%)",
    top_center: "translate(-50%, 0%)",
    top_right: "translate(-100%, 0%)",
    center_left: "translate(0%, -50%)",
    center: "translate(-50%, -50%)",
    center_right: "translate(-100%, -50%)",
    bottom_left: "translate(0%, -100%)",
    bottom_center: "translate(-50%, -100%)",
    bottom_right: "translate(-100%, -100%)"
  };
  const transform = transformMap[anchorSide ?? "center"];
  return /* @__PURE__ */ jsx6(
    "div",
    {
      style: {
        position: "absolute",
        left: screenPos.x,
        top: screenPos.y,
        transform,
        color: color || "black",
        fontSize: fontSize ?? 12,
        whiteSpace: "pre",
        cursor: "default"
      },
      onClick: () => onObjectClicked?.({ type: "text", index, object: textObj }),
      children: text
    }
  );
};

// site/utils/getGraphicsBounds.ts
var getGraphicsBounds = (graphics) => {
  const bounds = {
    minX: Infinity,
    minY: Infinity,
    maxX: -Infinity,
    maxY: -Infinity
  };
  for (const line of graphics.lines ?? []) {
    for (const point of line.points ?? []) {
      bounds.minX = Math.min(bounds.minX, point.x);
      bounds.minY = Math.min(bounds.minY, point.y);
      bounds.maxX = Math.max(bounds.maxX, point.x);
      bounds.maxY = Math.max(bounds.maxY, point.y);
    }
  }
  for (const rect of graphics.rects ?? []) {
    const { center, width, height } = rect;
    const halfWidth = width / 2;
    const halfHeight = height / 2;
    bounds.minX = Math.min(bounds.minX, center.x - halfWidth);
    bounds.minY = Math.min(bounds.minY, center.y - halfHeight);
    bounds.maxX = Math.max(bounds.maxX, center.x + halfWidth);
    bounds.maxY = Math.max(bounds.maxY, center.y + halfHeight);
  }
  for (const point of graphics.points ?? []) {
    bounds.minX = Math.min(bounds.minX, point.x);
    bounds.minY = Math.min(bounds.minY, point.y);
    bounds.maxX = Math.max(bounds.maxX, point.x);
    bounds.maxY = Math.max(bounds.maxY, point.y);
  }
  for (const circle of graphics.circles ?? []) {
    bounds.minX = Math.min(bounds.minX, circle.center.x - circle.radius);
    bounds.minY = Math.min(bounds.minY, circle.center.y - circle.radius);
    bounds.maxX = Math.max(bounds.maxX, circle.center.x + circle.radius);
    bounds.maxY = Math.max(bounds.maxY, circle.center.y + circle.radius);
  }
  for (const text of graphics.texts ?? []) {
    bounds.minX = Math.min(bounds.minX, text.x);
    bounds.minY = Math.min(bounds.minY, text.y);
    bounds.maxX = Math.max(bounds.maxX, text.x);
    bounds.maxY = Math.max(bounds.maxY, text.y);
  }
  return bounds;
};

// site/components/InteractiveGraphics/hooks/useIsPointOnScreen.ts
import { applyToPoint as applyToPoint7 } from "transformation-matrix";
import { useMemo as useMemo2 } from "react";

// site/components/InteractiveGraphics/hooks/useDoesLineIntersectViewport.ts
import { applyToPoint as applyToPoint6 } from "transformation-matrix";
import { useMemo } from "react";
var OFFSCREEN_MARGIN = 5;
var useDoesLineIntersectViewport = (realToScreen, size) => {
  return useMemo(() => {
    return (p1, p2) => {
      const sp1 = applyToPoint6(realToScreen, p1);
      const sp2 = applyToPoint6(realToScreen, p2);
      const left = -OFFSCREEN_MARGIN;
      const right = size.width + OFFSCREEN_MARGIN;
      const top = -OFFSCREEN_MARGIN;
      const bottom = size.height + OFFSCREEN_MARGIN;
      if (sp1.x >= left && sp1.x <= right && sp1.y >= top && sp1.y <= bottom || sp2.x >= left && sp2.x <= right && sp2.y >= top && sp2.y <= bottom) {
        return true;
      }
      const intersects = (a1, a2, b1, b2) => {
        const det = (a2.x - a1.x) * (b2.y - b1.y) - (a2.y - a1.y) * (b2.x - b1.x);
        if (det === 0) return false;
        const lambda = ((b2.y - b1.y) * (b2.x - a1.x) + (b1.x - b2.x) * (b2.y - a1.y)) / det;
        const gamma = ((a1.y - a2.y) * (b2.x - a1.x) + (a2.x - a1.x) * (b2.y - a1.y)) / det;
        return lambda >= 0 && lambda <= 1 && gamma >= 0 && gamma <= 1;
      };
      return (
        // Top edge
        intersects(sp1, sp2, { x: left, y: top }, { x: right, y: top }) || // Right edge
        intersects(sp1, sp2, { x: right, y: top }, { x: right, y: bottom }) || // Bottom edge
        intersects(sp1, sp2, { x: left, y: bottom }, { x: right, y: bottom }) || // Left edge
        intersects(sp1, sp2, { x: left, y: top }, { x: left, y: bottom })
      );
    };
  }, [realToScreen, size]);
};

// site/components/InteractiveGraphics/hooks/useIsPointOnScreen.ts
var useIsPointOnScreen = (realToScreen, size) => {
  return useMemo2(() => {
    return (point) => {
      const screenPoint = applyToPoint7(realToScreen, point);
      return screenPoint.x >= -OFFSCREEN_MARGIN && screenPoint.x <= size.width + OFFSCREEN_MARGIN && screenPoint.y >= -OFFSCREEN_MARGIN && screenPoint.y <= size.height + OFFSCREEN_MARGIN;
    };
  }, [realToScreen, size]);
};

// site/components/InteractiveGraphics/hooks/useFilterLines.ts
import { useMemo as useMemo3 } from "react";
var useFilterLines = (isPointOnScreen, doesLineIntersectViewport, filterLayerAndStep) => {
  return useMemo3(() => {
    return (line) => {
      if (!filterLayerAndStep(line)) return false;
      if (line.points.some((p) => isPointOnScreen(p))) {
        return true;
      }
      for (let i = 0; i < line.points.length - 1; i++) {
        if (doesLineIntersectViewport(line.points[i], line.points[i + 1])) {
          return true;
        }
      }
      if (line.points.length > 2 && line.closed) {
        if (doesLineIntersectViewport(
          line.points[line.points.length - 1],
          line.points[0]
        )) {
          return true;
        }
      }
      return false;
    };
  }, [isPointOnScreen, doesLineIntersectViewport, filterLayerAndStep]);
};

// site/components/InteractiveGraphics/hooks/useFilterPoints.ts
import { useMemo as useMemo4 } from "react";
var useFilterPoints = (isPointOnScreen, filterLayerAndStep) => {
  return useMemo4(() => {
    return (point) => {
      if (!filterLayerAndStep(point)) return false;
      return isPointOnScreen(point);
    };
  }, [isPointOnScreen, filterLayerAndStep]);
};

// site/components/InteractiveGraphics/hooks/useFilterRects.ts
import { useMemo as useMemo5 } from "react";
var useFilterRects = (isPointOnScreen, doesLineIntersectViewport, filterLayerAndStep) => {
  return useMemo5(() => {
    return (rect) => {
      if (!filterLayerAndStep(rect)) return false;
      const { center, width, height } = rect;
      const halfWidth = width / 2;
      const halfHeight = height / 2;
      const topLeft = { x: center.x - halfWidth, y: center.y - halfHeight };
      const topRight = { x: center.x + halfWidth, y: center.y - halfHeight };
      const bottomLeft = { x: center.x - halfWidth, y: center.y + halfHeight };
      const bottomRight = { x: center.x + halfWidth, y: center.y + halfHeight };
      if (isPointOnScreen(center) || isPointOnScreen(topLeft) || isPointOnScreen(topRight) || isPointOnScreen(bottomLeft) || isPointOnScreen(bottomRight)) {
        return true;
      }
      return doesLineIntersectViewport(topLeft, topRight) || doesLineIntersectViewport(topRight, bottomRight) || doesLineIntersectViewport(bottomRight, bottomLeft) || doesLineIntersectViewport(bottomLeft, topLeft);
    };
  }, [isPointOnScreen, doesLineIntersectViewport, filterLayerAndStep]);
};

// site/components/InteractiveGraphics/hooks/useFilterCircles.ts
import { applyToPoint as applyToPoint8 } from "transformation-matrix";
import { useMemo as useMemo6 } from "react";
var useFilterCircles = (isPointOnScreen, filterLayerAndStep, realToScreen, size) => {
  return useMemo6(() => {
    return (circle) => {
      if (!filterLayerAndStep(circle)) return false;
      const { center, radius } = circle;
      if (isPointOnScreen(center) || isPointOnScreen({ x: center.x + radius, y: center.y }) || isPointOnScreen({ x: center.x - radius, y: center.y }) || isPointOnScreen({ x: center.x, y: center.y + radius }) || isPointOnScreen({ x: center.x, y: center.y - radius })) {
        return true;
      }
      const screenCenter = applyToPoint8(realToScreen, center);
      const scale4 = Math.abs(realToScreen.a);
      const screenRadius = radius * scale4;
      const left = -OFFSCREEN_MARGIN;
      const right = size.width + OFFSCREEN_MARGIN;
      const top = -OFFSCREEN_MARGIN;
      const bottom = size.height + OFFSCREEN_MARGIN;
      if (screenCenter.x >= left && screenCenter.x <= right) {
        if (Math.abs(screenCenter.y - top) <= screenRadius || Math.abs(screenCenter.y - bottom) <= screenRadius) {
          return true;
        }
      }
      if (screenCenter.y >= top && screenCenter.y <= bottom) {
        if (Math.abs(screenCenter.x - left) <= screenRadius || Math.abs(screenCenter.x - right) <= screenRadius) {
          return true;
        }
      }
      const cornerDistanceSquared = (cornerX, cornerY) => {
        const dx = screenCenter.x - cornerX;
        const dy = screenCenter.y - cornerY;
        return dx * dx + dy * dy;
      };
      const radiusSquared = screenRadius * screenRadius;
      return cornerDistanceSquared(left, top) <= radiusSquared || cornerDistanceSquared(right, top) <= radiusSquared || cornerDistanceSquared(left, bottom) <= radiusSquared || cornerDistanceSquared(right, bottom) <= radiusSquared;
    };
  }, [isPointOnScreen, filterLayerAndStep, realToScreen, size]);
};

// site/components/InteractiveGraphics/hooks/useFilterTexts.ts
import { useMemo as useMemo7 } from "react";
var useFilterTexts = (isPointOnScreen, filterLayerAndStep) => {
  return useMemo7(() => {
    return (text) => {
      if (!filterLayerAndStep(text)) return false;
      return isPointOnScreen({ x: text.x, y: text.y });
    };
  }, [isPointOnScreen, filterLayerAndStep]);
};

// site/components/DimensionOverlay.tsx
import { useEffect, useRef, useState as useState5 } from "react";
import { applyToPoint as applyToPoint9, identity, inverse } from "transformation-matrix";
import { Fragment, jsx as jsx7, jsxs as jsxs2 } from "react/jsx-runtime";
var DimensionOverlay = ({ children, transform }) => {
  if (!transform) transform = identity();
  const [dimensionToolVisible, setDimensionToolVisible] = useState5(false);
  const [dimensionToolStretching, setDimensionToolStretching] = useState5(false);
  const [dStart, setDStart] = useState5({ x: 0, y: 0 });
  const [dEnd, setDEnd] = useState5({ x: 0, y: 0 });
  const mousePosRef = useRef({ x: 0, y: 0 });
  const containerRef = useRef(null);
  const container = containerRef.current;
  const containerBounds = container?.getBoundingClientRect();
  const bindKeys = () => {
    const container2 = containerRef.current;
    const down = (e) => {
      if (e.key === "d") {
        setDStart({ x: mousePosRef.current.x, y: mousePosRef.current.y });
        setDEnd({ x: mousePosRef.current.x, y: mousePosRef.current.y });
        setDimensionToolVisible((visible) => !visible);
        setDimensionToolStretching(true);
      }
      if (e.key === "Escape") {
        setDimensionToolVisible(false);
        setDimensionToolStretching(false);
      }
    };
    const addKeyListener = () => {
      if (container2) {
        window.addEventListener("keydown", down);
      }
    };
    const removeKeyListener = () => {
      if (container2) {
        window.removeEventListener("keydown", down);
      }
    };
    if (container2) {
      container2.addEventListener("focus", addKeyListener);
      container2.addEventListener("blur", removeKeyListener);
      container2.addEventListener("mouseenter", addKeyListener);
      container2.addEventListener("mouseleave", removeKeyListener);
    }
    return () => {
      if (container2) {
        container2.removeEventListener("focus", addKeyListener);
        container2.removeEventListener("blur", removeKeyListener);
        container2.removeEventListener("mouseenter", addKeyListener);
        container2.removeEventListener("mouseleave", removeKeyListener);
      }
    };
  };
  useEffect(bindKeys, [containerBounds?.width, containerBounds?.height]);
  const screenDStart = applyToPoint9(transform, dStart);
  const screenDEnd = applyToPoint9(transform, dEnd);
  const arrowScreenBounds = {
    left: Math.min(screenDStart.x, screenDEnd.x),
    right: Math.max(screenDStart.x, screenDEnd.x),
    top: Math.min(screenDStart.y, screenDEnd.y),
    bottom: Math.max(screenDStart.y, screenDEnd.y),
    flipX: screenDStart.x > screenDEnd.x,
    flipY: screenDStart.y > screenDEnd.y,
    width: 0,
    height: 0
  };
  arrowScreenBounds.width = arrowScreenBounds.right - arrowScreenBounds.left;
  arrowScreenBounds.height = arrowScreenBounds.bottom - arrowScreenBounds.top;
  return /* @__PURE__ */ jsxs2(
    "div",
    {
      ref: containerRef,
      tabIndex: 0,
      style: { position: "relative" },
      onMouseMove: (e) => {
        const rect = e.currentTarget.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;
        const rwPoint = applyToPoint9(inverse(transform), { x, y });
        mousePosRef.current.x = rwPoint.x;
        mousePosRef.current.y = rwPoint.y;
        if (dimensionToolStretching) {
          setDEnd({ x: rwPoint.x, y: rwPoint.y });
        }
      },
      onMouseDown: () => {
        if (dimensionToolStretching) {
          setDimensionToolStretching(false);
        } else if (dimensionToolVisible) {
          setDimensionToolVisible(false);
        }
      },
      onMouseEnter: () => {
        if (containerRef.current) {
          bindKeys();
        }
      },
      children: [
        children,
        dimensionToolVisible && /* @__PURE__ */ jsxs2(Fragment, { children: [
          /* @__PURE__ */ jsx7(
            "div",
            {
              style: {
                position: "absolute",
                left: arrowScreenBounds.left,
                width: arrowScreenBounds.width,
                textAlign: "center",
                top: screenDStart.y + 2,
                color: "red",
                mixBlendMode: "difference",
                pointerEvents: "none",
                marginTop: arrowScreenBounds.flipY ? 0 : -20,
                fontSize: 12,
                fontFamily: "sans-serif",
                zIndex: 30
              },
              children: Math.abs(dStart.x - dEnd.x).toFixed(2)
            }
          ),
          /* @__PURE__ */ jsx7(
            "div",
            {
              style: {
                position: "absolute",
                left: screenDEnd.x,
                height: arrowScreenBounds.height,
                display: "flex",
                flexDirection: "column",
                justifyContent: "center",
                top: arrowScreenBounds.top,
                color: "red",
                pointerEvents: "none",
                mixBlendMode: "difference",
                fontSize: 12,
                fontFamily: "sans-serif",
                zIndex: 30
              },
              children: /* @__PURE__ */ jsx7(
                "div",
                {
                  style: {
                    marginLeft: arrowScreenBounds.flipX ? "-100%" : 4,
                    paddingRight: 4
                  },
                  children: Math.abs(dStart.y - dEnd.y).toFixed(2)
                }
              )
            }
          ),
          /* @__PURE__ */ jsxs2(
            "svg",
            {
              style: {
                position: "absolute",
                left: 0,
                top: 0,
                pointerEvents: "none",
                mixBlendMode: "difference",
                zIndex: 30
              },
              width: containerBounds?.width || "100%",
              height: containerBounds?.height || "100%",
              children: [
                /* @__PURE__ */ jsx7("defs", { children: /* @__PURE__ */ jsx7(
                  "marker",
                  {
                    id: "head",
                    orient: "auto",
                    markerWidth: "3",
                    markerHeight: "4",
                    refX: "2",
                    refY: "2",
                    children: /* @__PURE__ */ jsx7("path", { d: "M0,0 V4 L2,2 Z", fill: "red" })
                  }
                ) }),
                /* @__PURE__ */ jsx7(
                  "line",
                  {
                    x1: screenDStart.x,
                    y1: screenDStart.y,
                    x2: screenDEnd.x,
                    y2: screenDEnd.y,
                    markerEnd: "url(#head)",
                    strokeWidth: 1.5,
                    fill: "none",
                    stroke: "red"
                  }
                ),
                /* @__PURE__ */ jsx7(
                  "line",
                  {
                    x1: screenDStart.x,
                    y1: screenDStart.y,
                    x2: screenDEnd.x,
                    y2: screenDStart.y,
                    strokeWidth: 1.5,
                    fill: "none",
                    strokeDasharray: "2,2",
                    stroke: "red"
                  }
                ),
                /* @__PURE__ */ jsx7(
                  "line",
                  {
                    x1: screenDEnd.x,
                    y1: screenDStart.y,
                    x2: screenDEnd.x,
                    y2: screenDEnd.y,
                    strokeWidth: 1.5,
                    fill: "none",
                    strokeDasharray: "2,2",
                    stroke: "red"
                  }
                )
              ]
            }
          ),
          /* @__PURE__ */ jsxs2(
            "div",
            {
              style: {
                right: 0,
                bottom: 0,
                position: "absolute",
                color: "red",
                fontFamily: "sans-serif",
                fontSize: 12,
                margin: 4
              },
              children: [
                "(",
                dStart.x.toFixed(2),
                ",",
                dStart.y.toFixed(2),
                ")",
                /* @__PURE__ */ jsx7("br", {}),
                "(",
                dEnd.x.toFixed(2),
                ",",
                dEnd.y.toFixed(2),
                ")",
                /* @__PURE__ */ jsx7("br", {}),
                "dist:",
                " ",
                Math.sqrt(
                  (dEnd.x - dStart.x) ** 2 + (dEnd.y - dStart.y) ** 2
                ).toFixed(2)
              ]
            }
          )
        ] })
      ]
    }
  );
};

// site/utils/getMaxStep.ts
function getMaxStep(graphics) {
  const getMaxStepFromArray = (items) => {
    if (!items || items.length === 0) return 0;
    return items.reduce((max, item) => {
      const step = Number.isNaN(item.step) ? 0 : item.step || 0;
      return Math.max(max, step);
    }, 0);
  };
  const maxPointStep = getMaxStepFromArray(graphics.points);
  const maxLineStep = getMaxStepFromArray(graphics.lines);
  const maxRectStep = getMaxStepFromArray(graphics.rects);
  const maxCircleStep = getMaxStepFromArray(graphics.circles);
  const maxTextStep = getMaxStepFromArray(graphics.texts);
  return Math.max(
    maxPointStep,
    maxLineStep,
    maxRectStep,
    maxCircleStep,
    maxTextStep
  );
}

// site/components/InteractiveGraphics/ContextMenu.tsx
import { useEffect as useEffect2, useRef as useRef2 } from "react";
import { jsx as jsx8, jsxs as jsxs3 } from "react/jsx-runtime";
var ContextMenu = ({
  x,
  y,
  onSaveCamera,
  onClearCamera,
  onAddMark,
  onClearMarks,
  onClose
}) => {
  const menuRef = useRef2(null);
  useEffect2(() => {
    const handleClickOutside = (event) => {
      if (menuRef.current && !menuRef.current.contains(event.target)) {
        onClose();
      }
    };
    document.addEventListener("mousedown", handleClickOutside);
    return () => {
      document.removeEventListener("mousedown", handleClickOutside);
    };
  }, [onClose]);
  const menuStyle = {
    position: "absolute",
    left: x,
    top: y,
    backgroundColor: "white",
    border: "1px solid #ccc",
    borderRadius: 3,
    boxShadow: "0 2px 6px rgba(0,0,0,0.1)",
    padding: 0,
    zIndex: 1e3,
    minWidth: 160,
    fontSize: "12px"
  };
  const menuItemStyle = {
    padding: "4px 8px",
    cursor: "pointer",
    userSelect: "none",
    lineHeight: "1.5"
  };
  const handleItemHover = (e) => {
    e.currentTarget.style.backgroundColor = "#f5f5f5";
  };
  const handleItemLeave = (e) => {
    e.currentTarget.style.backgroundColor = "";
  };
  return /* @__PURE__ */ jsxs3("div", { ref: menuRef, style: menuStyle, children: [
    /* @__PURE__ */ jsx8(
      "div",
      {
        style: menuItemStyle,
        onClick: () => {
          onSaveCamera();
          onClose();
        },
        onMouseEnter: handleItemHover,
        onMouseLeave: handleItemLeave,
        children: "Save Camera Position"
      }
    ),
    /* @__PURE__ */ jsx8(
      "div",
      {
        style: menuItemStyle,
        onClick: () => {
          onClearCamera();
          onClose();
        },
        onMouseEnter: handleItemHover,
        onMouseLeave: handleItemLeave,
        children: "Clear Saved Camera Position"
      }
    ),
    /* @__PURE__ */ jsx8(
      "div",
      {
        style: menuItemStyle,
        onClick: () => {
          onAddMark();
          onClose();
        },
        onMouseEnter: handleItemHover,
        onMouseLeave: handleItemLeave,
        children: "Add Mark"
      }
    ),
    /* @__PURE__ */ jsx8(
      "div",
      {
        style: menuItemStyle,
        onClick: () => {
          onClearMarks();
          onClose();
        },
        onMouseEnter: handleItemHover,
        onMouseLeave: handleItemLeave,
        children: "Clear Marks"
      }
    )
  ] });
};

// site/components/InteractiveGraphics/Marker.tsx
import { applyToPoint as applyToPoint10 } from "transformation-matrix";
import { jsx as jsx9, jsxs as jsxs4 } from "react/jsx-runtime";
var Marker = ({ marker, transform }) => {
  const [screenX, screenY] = applyToPoint10(transform, [marker.x, marker.y]);
  return /* @__PURE__ */ jsx9(
    "svg",
    {
      style: {
        position: "absolute",
        top: 0,
        left: 0,
        pointerEvents: "none",
        zIndex: 900
      },
      children: /* @__PURE__ */ jsxs4("g", { transform: `translate(${screenX}, ${screenY})`, children: [
        /* @__PURE__ */ jsx9(
          "circle",
          {
            r: 7,
            fill: "rgba(255, 0, 0, 0.5)",
            stroke: "rgba(255, 0, 0, 0.8)",
            strokeWidth: 2
          }
        ),
        /* @__PURE__ */ jsx9("circle", { r: 2, fill: "rgba(255, 0, 0, 0.9)" })
      ] })
    }
  );
};

// site/components/InteractiveGraphics/InteractiveGraphics.tsx
import { jsx as jsx10, jsxs as jsxs5 } from "react/jsx-runtime";
var InteractiveGraphics = ({
  graphics,
  onObjectClicked,
  objectLimit
}) => {
  const [activeLayers, setActiveLayers] = useState6(null);
  const [activeStep, setActiveStep] = useState6(null);
  const [showLastStep, setShowLastStep] = useState6(true);
  const [size, setSize] = useState6({ width: 600, height: 600 });
  const [contextMenu, setContextMenu] = useState6(null);
  const [markers, setMarkers] = useState6([]);
  const availableLayers = Array.from(
    /* @__PURE__ */ new Set([
      ...graphics.lines?.map((l) => l.layer).filter(Boolean) ?? [],
      ...graphics.rects?.map((r) => r.layer).filter(Boolean) ?? [],
      ...graphics.points?.map((p) => p.layer).filter(Boolean) ?? [],
      ...graphics.texts?.map((t) => t.layer).filter(Boolean) ?? []
    ])
  );
  const maxStep = getMaxStep(graphics);
  const graphicsBoundsWithPadding = useMemo8(() => {
    const actualBounds = getGraphicsBounds(graphics);
    const width = actualBounds.maxX - actualBounds.minX;
    const height = actualBounds.maxY - actualBounds.minY;
    return {
      minX: actualBounds.minX - width / 10,
      minY: actualBounds.minY - height / 10,
      maxX: actualBounds.maxX + width / 10,
      maxY: actualBounds.maxY + height / 10
    };
  }, [graphics]);
  const getStorageKey = useCallback(() => {
    const path = window.location.pathname;
    const search = window.location.search;
    return `saved-camera-position-${path}${search}`;
  }, []);
  const getDefaultTransform = useCallback(() => {
    return compose(
      translate(size.width / 2, size.height / 2),
      scale(
        Math.min(
          size.width / (graphicsBoundsWithPadding.maxX - graphicsBoundsWithPadding.minX),
          size.height / (graphicsBoundsWithPadding.maxY - graphicsBoundsWithPadding.minY)
        ),
        -Math.min(
          size.width / (graphicsBoundsWithPadding.maxX - graphicsBoundsWithPadding.minX),
          size.height / (graphicsBoundsWithPadding.maxY - graphicsBoundsWithPadding.minY)
        )
      ),
      translate(
        -(graphicsBoundsWithPadding.maxX + graphicsBoundsWithPadding.minX) / 2,
        -(graphicsBoundsWithPadding.maxY + graphicsBoundsWithPadding.minY) / 2
      )
    );
  }, [size, graphicsBoundsWithPadding]);
  const getSavedData = useCallback(() => {
    try {
      const savedData = localStorage.getItem(getStorageKey());
      if (savedData) {
        return JSON.parse(savedData);
      }
    } catch (error) {
      console.error("Error loading saved data:", error);
    }
    return null;
  }, [getStorageKey]);
  const getSavedTransform = useCallback(() => {
    const savedData = getSavedData();
    return savedData?.transform || null;
  }, [getSavedData]);
  const {
    transform: realToScreen,
    ref,
    setTransform
  } = useMouseMatrixTransform({
    initialTransform: getSavedTransform() || getDefaultTransform()
  });
  useResizeObserver(ref, (entry) => {
    setSize({
      width: entry.contentRect.width,
      height: entry.contentRect.height
    });
  });
  useEffect3(() => {
    const savedData = getSavedData();
    if (savedData?.markers) {
      setMarkers(savedData.markers);
    }
  }, [getSavedData]);
  const handleContextMenu = useCallback((event) => {
    event.preventDefault();
    const mouseX = event.clientX;
    const mouseY = event.clientY;
    const rect = event.currentTarget.getBoundingClientRect();
    const elementX = rect.left;
    const elementY = rect.top;
    const viewportWidth = window.innerWidth;
    const viewportHeight = window.innerHeight;
    const menuWidth = 160;
    const menuHeight = 100;
    let x = mouseX - elementX;
    let y = mouseY - elementY;
    if (mouseX > viewportWidth / 2) {
      x = x - menuWidth;
    }
    if (mouseY > viewportHeight / 2) {
      y = y - menuHeight;
    }
    setContextMenu({
      x,
      y,
      clientX: mouseX,
      clientY: mouseY
    });
  }, []);
  const saveToLocalStorage = useCallback(
    (transform, markerPoints) => {
      try {
        const dataToSave = {
          transform,
          markers: markerPoints
        };
        localStorage.setItem(getStorageKey(), JSON.stringify(dataToSave));
      } catch (error) {
        console.error("Error saving data:", error);
      }
    },
    [getStorageKey]
  );
  const handleSaveCamera = useCallback(() => {
    saveToLocalStorage(realToScreen, markers);
  }, [saveToLocalStorage, realToScreen, markers]);
  const handleClearCamera = useCallback(() => {
    try {
      const defaultTransform = getDefaultTransform();
      saveToLocalStorage(defaultTransform, markers);
      setTransform(defaultTransform);
    } catch (error) {
      console.error("Error clearing camera position:", error);
    }
  }, [saveToLocalStorage, getDefaultTransform, setTransform, markers]);
  const handleAddMark = useCallback(() => {
    if (!contextMenu) return;
    try {
      const screenPoint = { x: contextMenu.clientX, y: contextMenu.clientY };
      const rect = ref.current?.getBoundingClientRect();
      if (rect) {
        const screenX = screenPoint.x - rect.left;
        const screenY = screenPoint.y - rect.top;
        const inverseTransform = inverse2(realToScreen);
        const [realX, realY] = applyToPoint11(inverseTransform, [
          screenX,
          screenY
        ]);
        const newMarker = { x: realX, y: realY };
        const newMarkers = [...markers, newMarker];
        setMarkers(newMarkers);
        saveToLocalStorage(realToScreen, newMarkers);
      }
    } catch (error) {
      console.error("Error adding marker:", error);
    }
  }, [contextMenu, ref, realToScreen, markers, saveToLocalStorage]);
  const handleClearMarks = useCallback(() => {
    setMarkers([]);
    saveToLocalStorage(realToScreen, []);
  }, [realToScreen, saveToLocalStorage]);
  const interactiveState = {
    activeLayers,
    activeStep: showLastStep ? maxStep : activeStep,
    realToScreen,
    onObjectClicked
  };
  const showToolbar = availableLayers.length > 1 || maxStep > 0;
  const isPointOnScreen = useIsPointOnScreen(realToScreen, size);
  const doesLineIntersectViewport = useDoesLineIntersectViewport(
    realToScreen,
    size
  );
  const filterLayerAndStep = (obj) => {
    if (activeLayers && obj.layer && !activeLayers.includes(obj.layer))
      return false;
    const selectedStep = showLastStep ? maxStep : activeStep;
    if (selectedStep !== null && obj.step !== void 0 && obj.step !== selectedStep)
      return false;
    return true;
  };
  const filterLines = useFilterLines(
    isPointOnScreen,
    doesLineIntersectViewport,
    filterLayerAndStep
  );
  const filterPoints = useFilterPoints(isPointOnScreen, filterLayerAndStep);
  const filterRects = useFilterRects(
    isPointOnScreen,
    doesLineIntersectViewport,
    filterLayerAndStep
  );
  const filterCircles = useFilterCircles(
    isPointOnScreen,
    filterLayerAndStep,
    realToScreen,
    size
  );
  const filterTexts = useFilterTexts(isPointOnScreen, filterLayerAndStep);
  const filterAndLimit = (objects, filterFn) => {
    if (!objects) return [];
    const filtered = objects.map((obj, index) => ({ ...obj, originalIndex: index })).filter(filterFn);
    return objectLimit ? filtered.slice(-objectLimit) : filtered;
  };
  const filteredLines = useMemo8(
    () => filterAndLimit(graphics.lines, filterLines),
    [graphics.lines, filterLines, objectLimit]
  );
  const filteredRects = useMemo8(
    () => filterAndLimit(graphics.rects, filterRects),
    [graphics.rects, filterRects, objectLimit]
  );
  const filteredPoints = useMemo8(
    () => filterAndLimit(graphics.points, filterPoints),
    [graphics.points, filterPoints, objectLimit]
  );
  const filteredCircles = useMemo8(
    () => filterAndLimit(graphics.circles, filterCircles),
    [graphics.circles, filterCircles, objectLimit]
  );
  const filteredTexts = useMemo8(
    () => filterAndLimit(graphics.texts, filterTexts),
    [graphics.texts, filterTexts, objectLimit]
  );
  const totalFilteredObjects = filteredLines.length + filteredRects.length + filteredPoints.length + filteredCircles.length + filteredTexts.length;
  const isLimitReached = objectLimit && totalFilteredObjects > objectLimit;
  return /* @__PURE__ */ jsxs5("div", { children: [
    showToolbar && /* @__PURE__ */ jsxs5("div", { style: { margin: 8 }, children: [
      availableLayers.length > 1 && /* @__PURE__ */ jsxs5(
        "select",
        {
          value: activeLayers ? activeLayers[0] : "",
          onChange: (e) => {
            const value = e.target.value;
            setActiveLayers(value === "" ? null : [value]);
          },
          style: { marginRight: 8 },
          children: [
            /* @__PURE__ */ jsx10("option", { value: "", children: "All Layers" }),
            availableLayers.map((layer) => /* @__PURE__ */ jsx10("option", { value: layer, children: layer }, layer))
          ]
        }
      ),
      maxStep > 0 && /* @__PURE__ */ jsxs5(
        "div",
        {
          style: { display: "inline-flex", alignItems: "center", gap: 8 },
          children: [
            "Step:",
            /* @__PURE__ */ jsx10(
              "input",
              {
                type: "number",
                min: 0,
                max: maxStep,
                value: activeStep ?? 0,
                onChange: (e) => {
                  const value = parseInt(e.target.value);
                  setShowLastStep(false);
                  setActiveStep(Number.isNaN(value) ? null : value);
                },
                disabled: activeStep === null
              }
            ),
            /* @__PURE__ */ jsxs5("label", { children: [
              /* @__PURE__ */ jsx10(
                "input",
                {
                  type: "checkbox",
                  style: { marginRight: 4 },
                  checked: activeStep !== null,
                  onChange: (e) => {
                    setShowLastStep(false);
                    setActiveStep(e.target.checked ? 0 : null);
                  }
                }
              ),
              "Filter by step"
            ] }),
            /* @__PURE__ */ jsxs5("label", { children: [
              /* @__PURE__ */ jsx10(
                "input",
                {
                  type: "checkbox",
                  style: { marginRight: 4 },
                  checked: showLastStep,
                  onChange: (e) => {
                    setShowLastStep(e.target.checked);
                    setActiveStep(null);
                  }
                }
              ),
              "Show last step"
            ] }),
            isLimitReached && /* @__PURE__ */ jsxs5("span", { style: { color: "red", fontSize: "12px" }, children: [
              "Display limited to ",
              objectLimit,
              " objects. Received:",
              " ",
              totalFilteredObjects,
              "."
            ] })
          ]
        }
      )
    ] }),
    /* @__PURE__ */ jsxs5(
      "div",
      {
        ref,
        style: {
          position: "relative",
          height: 600,
          overflow: "hidden"
        },
        onContextMenu: handleContextMenu,
        children: [
          /* @__PURE__ */ jsxs5(DimensionOverlay, { transform: realToScreen, children: [
            filteredLines.map((line) => /* @__PURE__ */ jsx10(
              Line,
              {
                line,
                index: line.originalIndex,
                interactiveState
              },
              line.originalIndex
            )),
            filteredRects.map((rect) => /* @__PURE__ */ jsx10(
              Rect,
              {
                rect,
                index: rect.originalIndex,
                interactiveState
              },
              rect.originalIndex
            )),
            filteredPoints.map((point) => /* @__PURE__ */ jsx10(
              Point,
              {
                point,
                index: point.originalIndex,
                interactiveState
              },
              point.originalIndex
            )),
            filteredCircles.map((circle) => /* @__PURE__ */ jsx10(
              Circle,
              {
                circle,
                index: circle.originalIndex,
                interactiveState
              },
              circle.originalIndex
            )),
            filteredTexts.map((txt) => /* @__PURE__ */ jsx10(
              Text,
              {
                textObj: txt,
                index: txt.originalIndex,
                interactiveState
              },
              txt.originalIndex
            )),
            /* @__PURE__ */ jsx10(
              SuperGrid,
              {
                stringifyCoord: (x, y) => `${x.toFixed(2)}, ${y.toFixed(2)}`,
                width: size.width,
                height: size.height,
                transform: realToScreen
              }
            )
          ] }),
          markers.map((marker, index) => /* @__PURE__ */ jsx10(
            Marker,
            {
              marker,
              index,
              transform: realToScreen
            },
            index
          )),
          contextMenu && /* @__PURE__ */ jsx10(
            ContextMenu,
            {
              x: contextMenu.x,
              y: contextMenu.y,
              onSaveCamera: handleSaveCamera,
              onClearCamera: handleClearCamera,
              onAddMark: handleAddMark,
              onClearMarks: handleClearMarks,
              onClose: () => setContextMenu(null)
            }
          )
        ]
      }
    )
  ] });
};

// site/components/InteractiveGraphicsCanvas.tsx
import { useRef as useRef3, useEffect as useEffect4, useState as useState7 } from "react";
import useMouseMatrixTransform2 from "use-mouse-matrix-transform";
import { compose as compose2, scale as scale2, translate as translate2 } from "transformation-matrix";
import useResizeObserver2 from "@react-hook/resize-observer";

// site/utils/getGraphicsFilteredByStep.ts
function getGraphicsFilteredByStep(graphics, {
  showLastStep,
  activeStep,
  maxStep
}) {
  const selectedStep = showLastStep ? maxStep : activeStep;
  if (selectedStep === null) {
    return graphics;
  }
  const filteredGraphics = {
    ...graphics,
    points: graphics.points?.filter(
      (p) => p.step === void 0 || p.step === selectedStep
    ),
    lines: graphics.lines?.filter(
      (l) => l.step === void 0 || l.step === selectedStep
    ),
    rects: graphics.rects?.filter(
      (r) => r.step === void 0 || r.step === selectedStep
    ),
    circles: graphics.circles?.filter(
      (c) => c.step === void 0 || c.step === selectedStep
    ),
    texts: graphics.texts?.filter(
      (t) => t.step === void 0 || t.step === selectedStep
    )
  };
  return filteredGraphics;
}

// site/utils/getGraphicsBoundsWithPadding.ts
function getGraphicsBoundsWithPadding(graphics) {
  const bounds = getBounds(graphics);
  const width = bounds.maxX - bounds.minX;
  const height = bounds.maxY - bounds.minY;
  return {
    minX: bounds.minX - width / 10,
    minY: bounds.minY - height / 10,
    maxX: bounds.maxX + width / 10,
    maxY: bounds.maxY + height / 10
  };
}

// site/components/InteractiveGraphicsCanvas.tsx
import { jsx as jsx11, jsxs as jsxs6 } from "react/jsx-runtime";
function InteractiveGraphicsCanvas({
  graphics,
  showLabelsByDefault = true,
  showGrid = true,
  height = 500,
  width = "100%"
}) {
  const canvasRef = useRef3(null);
  const containerRef = useRef3(null);
  const [size, setSize] = useState7({ width: 600, height: 600 });
  const [activeStep, setActiveStep] = useState7(null);
  const [showLabels, setShowLabels] = useState7(showLabelsByDefault);
  const [showLastStep, setShowLastStep] = useState7(true);
  const maxStep = getMaxStep(graphics);
  const filteredGraphics = getGraphicsFilteredByStep(graphics, {
    activeStep,
    showLastStep,
    maxStep
  });
  const graphicsBoundsWithPadding = getGraphicsBoundsWithPadding(graphics);
  const { transform, ref: mouseTransformRef } = useMouseMatrixTransform2({
    initialTransform: compose2(
      translate2(size.width / 2, size.height / 2),
      scale2(
        Math.min(
          size.width / (graphicsBoundsWithPadding.maxX - graphicsBoundsWithPadding.minX),
          size.height / (graphicsBoundsWithPadding.maxY - graphicsBoundsWithPadding.minY)
        ),
        -Math.min(
          size.width / (graphicsBoundsWithPadding.maxX - graphicsBoundsWithPadding.minX),
          size.height / (graphicsBoundsWithPadding.maxY - graphicsBoundsWithPadding.minY)
        )
      ),
      translate2(
        -(graphicsBoundsWithPadding.maxX + graphicsBoundsWithPadding.minX) / 2,
        -(graphicsBoundsWithPadding.maxY + graphicsBoundsWithPadding.minY) / 2
      )
    )
  });
  useResizeObserver2(containerRef, (entry) => {
    setSize({
      width: entry.contentRect.width,
      height: entry.contentRect.height
    });
  });
  const drawCanvas = () => {
    if (!canvasRef.current) return;
    canvasRef.current.width = size.width;
    canvasRef.current.height = size.height;
    drawGraphicsToCanvas(filteredGraphics, canvasRef.current, {
      transform,
      disableLabels: !showLabels
    });
    if (showGrid) {
      drawGrid(canvasRef.current, transform);
    }
  };
  const drawGrid = (canvas, transform2) => {
    const ctx = canvas.getContext("2d");
    if (!ctx) return;
    ctx.save();
    ctx.beginPath();
    const xAxisStart = { x: -1e3, y: 0 };
    const xAxisEnd = { x: 1e3, y: 0 };
    const xAxisStartTransformed = transformPoint(xAxisStart, transform2);
    const xAxisEndTransformed = transformPoint(xAxisEnd, transform2);
    ctx.moveTo(xAxisStartTransformed.x, xAxisStartTransformed.y);
    ctx.lineTo(xAxisEndTransformed.x, xAxisEndTransformed.y);
    const yAxisStart = { x: 0, y: -1e3 };
    const yAxisEnd = { x: 0, y: 1e3 };
    const yAxisStartTransformed = transformPoint(yAxisStart, transform2);
    const yAxisEndTransformed = transformPoint(yAxisEnd, transform2);
    ctx.moveTo(yAxisStartTransformed.x, yAxisStartTransformed.y);
    ctx.lineTo(yAxisEndTransformed.x, yAxisEndTransformed.y);
    ctx.strokeStyle = "#aaa";
    ctx.lineWidth = 1;
    ctx.stroke();
    ctx.beginPath();
    ctx.setLineDash([2, 2]);
    const gridSize = 10;
    for (let x = -100; x <= 100; x += gridSize) {
      if (x === 0) continue;
      const start = transformPoint({ x, y: -100 }, transform2);
      const end = transformPoint({ x, y: 100 }, transform2);
      ctx.moveTo(start.x, start.y);
      ctx.lineTo(end.x, end.y);
    }
    for (let y = -100; y <= 100; y += gridSize) {
      if (y === 0) continue;
      const start = transformPoint({ x: -100, y }, transform2);
      const end = transformPoint({ x: 100, y }, transform2);
      ctx.moveTo(start.x, start.y);
      ctx.lineTo(end.x, end.y);
    }
    ctx.strokeStyle = "#ddd";
    ctx.stroke();
    ctx.restore();
  };
  const transformPoint = (point, matrix) => {
    return {
      x: matrix.a * point.x + matrix.c * point.y + matrix.e,
      y: matrix.b * point.x + matrix.d * point.y + matrix.f
    };
  };
  useEffect4(() => {
    drawCanvas();
  }, [transform, size, filteredGraphics, showGrid, showLabels]);
  return /* @__PURE__ */ jsxs6("div", { style: { display: "flex", flexDirection: "column", gap: "10px" }, children: [
    /* @__PURE__ */ jsxs6("div", { style: { display: "flex", gap: "12px", alignItems: "center" }, children: [
      /* @__PURE__ */ jsxs6("div", { style: { display: "flex", alignItems: "center", gap: "8px" }, children: [
        /* @__PURE__ */ jsxs6("label", { children: [
          /* @__PURE__ */ jsx11(
            "input",
            {
              type: "checkbox",
              style: { marginRight: 4 },
              checked: activeStep !== null,
              onChange: (e) => {
                setActiveStep(e.target.checked ? 0 : null);
              }
            }
          ),
          "Filter by step"
        ] }),
        /* @__PURE__ */ jsx11(
          "input",
          {
            type: "number",
            min: 0,
            max: maxStep,
            value: activeStep ?? 0,
            onChange: (e) => {
              const value = parseInt(e.target.value);
              setShowLastStep(false);
              setActiveStep(Number.isNaN(value) ? 0 : Math.min(value, maxStep));
            },
            disabled: activeStep === null,
            style: { width: "60px" }
          }
        ),
        /* @__PURE__ */ jsxs6("label", { children: [
          /* @__PURE__ */ jsx11(
            "input",
            {
              type: "checkbox",
              style: { marginRight: 4 },
              checked: showLastStep,
              onChange: (e) => {
                setShowLastStep(e.target.checked);
                setActiveStep(null);
              }
            }
          ),
          "Show last step"
        ] })
      ] }),
      /* @__PURE__ */ jsx11("div", { style: { display: "flex", alignItems: "center", gap: "8px" }, children: /* @__PURE__ */ jsxs6("label", { children: [
        /* @__PURE__ */ jsx11(
          "input",
          {
            type: "checkbox",
            style: { marginRight: 4 },
            checked: showLabels,
            onChange: (e) => {
              setShowLabels(e.target.checked);
            }
          }
        ),
        "Show labels"
      ] }) })
    ] }),
    /* @__PURE__ */ jsx11(
      "div",
      {
        ref: (node) => {
          containerRef.current = node;
          if (mouseTransformRef && node) {
            mouseTransformRef.current = node;
          }
        },
        style: {
          position: "relative",
          width,
          height,
          border: "1px solid #ccc",
          overflow: "hidden"
        },
        children: /* @__PURE__ */ jsx11(
          "canvas",
          {
            ref: canvasRef,
            style: {
              position: "absolute",
              top: 0,
              left: 0,
              width,
              height
            }
          }
        )
      }
    )
  ] });
}

// site/components/CanvasGraphics/CanvasGraphics.tsx
import React3, { useRef as useRef4, useEffect as useEffect5, useState as useState8 } from "react";
import useMouseMatrixTransform3 from "use-mouse-matrix-transform";
import { compose as compose3, scale as scale3, translate as translate3 } from "transformation-matrix";
import useResizeObserver3 from "@react-hook/resize-observer";
import { jsx as jsx12 } from "react/jsx-runtime";
function TransformContainer({
  initialTransform,
  children,
  onTransformChange
}) {
  const { transform, ref } = useMouseMatrixTransform3({
    initialTransform
  });
  useEffect5(() => {
    onTransformChange(transform);
  }, [transform, onTransformChange]);
  return /* @__PURE__ */ jsx12(
    "div",
    {
      ref,
      style: {
        position: "relative",
        width: "100%",
        height: "100%"
      },
      children
    }
  );
}
var CanvasGraphics = ({
  graphics,
  width = 600,
  height = 600,
  withGrid = true,
  disableLabels = false,
  initialTransform
}) => {
  const canvasRef = useRef4(null);
  const containerRef = useRef4(null);
  const [size, setSize] = useState8({ width, height });
  const [currentTransform, setCurrentTransform] = useState8(null);
  const graphicsBoundsWithPadding = React3.useMemo(() => {
    const bounds = getBounds(graphics);
    const bWidth = bounds.maxX - bounds.minX;
    const bHeight = bounds.maxY - bounds.minY;
    return {
      minX: bounds.minX - bWidth / 10,
      minY: bounds.minY - bHeight / 10,
      maxX: bounds.maxX + bWidth / 10,
      maxY: bounds.maxY + bHeight / 10
    };
  }, [graphics]);
  const computedInitialTransform = React3.useMemo(() => {
    if (initialTransform) return initialTransform;
    const yFlip = graphics.coordinateSystem === "cartesian";
    return compose3(
      translate3(size.width / 2, size.height / 2),
      scale3(
        Math.min(
          size.width / (graphicsBoundsWithPadding.maxX - graphicsBoundsWithPadding.minX),
          size.height / (graphicsBoundsWithPadding.maxY - graphicsBoundsWithPadding.minY)
        ),
        yFlip ? -Math.min(
          size.width / (graphicsBoundsWithPadding.maxX - graphicsBoundsWithPadding.minX),
          size.height / (graphicsBoundsWithPadding.maxY - graphicsBoundsWithPadding.minY)
        ) : Math.min(
          size.width / (graphicsBoundsWithPadding.maxX - graphicsBoundsWithPadding.minX),
          size.height / (graphicsBoundsWithPadding.maxY - graphicsBoundsWithPadding.minY)
        )
      ),
      translate3(
        -(graphicsBoundsWithPadding.maxX + graphicsBoundsWithPadding.minX) / 2,
        -(graphicsBoundsWithPadding.maxY + graphicsBoundsWithPadding.minY) / 2
      )
    );
  }, [graphics, graphicsBoundsWithPadding, initialTransform, size]);
  const handleTransformChange = React3.useCallback((transform) => {
    setCurrentTransform(transform);
  }, []);
  useResizeObserver3(containerRef, (entry) => {
    setSize({
      width: entry.contentRect.width,
      height: entry.contentRect.height
    });
  });
  const drawCanvas = React3.useCallback(() => {
    if (!canvasRef.current || !currentTransform) return;
    canvasRef.current.width = size.width;
    canvasRef.current.height = size.height;
    drawGraphicsToCanvas(graphics, canvasRef.current, {
      transform: currentTransform,
      disableLabels
    });
    if (withGrid) {
      drawGrid(canvasRef.current, currentTransform);
    }
  }, [canvasRef, currentTransform, graphics, size, withGrid]);
  const drawGrid = (canvas, transform) => {
    const ctx = canvas.getContext("2d");
    if (!ctx) return;
    ctx.save();
    ctx.beginPath();
    const xAxisStart = { x: -1e3, y: 0 };
    const xAxisEnd = { x: 1e3, y: 0 };
    const xAxisStartTransformed = transformPoint(xAxisStart, transform);
    const xAxisEndTransformed = transformPoint(xAxisEnd, transform);
    ctx.moveTo(xAxisStartTransformed.x, xAxisStartTransformed.y);
    ctx.lineTo(xAxisEndTransformed.x, xAxisEndTransformed.y);
    const yAxisStart = { x: 0, y: -1e3 };
    const yAxisEnd = { x: 0, y: 1e3 };
    const yAxisStartTransformed = transformPoint(yAxisStart, transform);
    const yAxisEndTransformed = transformPoint(yAxisEnd, transform);
    ctx.moveTo(yAxisStartTransformed.x, yAxisStartTransformed.y);
    ctx.lineTo(yAxisEndTransformed.x, yAxisEndTransformed.y);
    ctx.strokeStyle = "#aaa";
    ctx.lineWidth = 1;
    ctx.stroke();
    ctx.beginPath();
    ctx.setLineDash([2, 2]);
    const zoomLevel = Math.abs(transform.a);
    const gridSize = Math.pow(10, Math.floor(Math.log10(100 / zoomLevel)));
    const gridRange = Math.ceil(1e3 / gridSize) * gridSize;
    for (let x = -gridRange; x <= gridRange; x += gridSize) {
      if (x === 0) continue;
      const start = transformPoint({ x, y: -gridRange }, transform);
      const end = transformPoint({ x, y: gridRange }, transform);
      ctx.moveTo(start.x, start.y);
      ctx.lineTo(end.x, end.y);
    }
    for (let y = -gridRange; y <= gridRange; y += gridSize) {
      if (y === 0) continue;
      const start = transformPoint({ x: -gridRange, y }, transform);
      const end = transformPoint({ x: gridRange, y }, transform);
      ctx.moveTo(start.x, start.y);
      ctx.lineTo(end.x, end.y);
    }
    ctx.strokeStyle = "#ddd";
    ctx.stroke();
    ctx.restore();
  };
  const transformPoint = (point, matrix) => {
    return {
      x: matrix.a * point.x + matrix.c * point.y + matrix.e,
      y: matrix.b * point.x + matrix.d * point.y + matrix.f
    };
  };
  useEffect5(() => {
    drawCanvas();
  }, [drawCanvas]);
  useEffect5(() => {
    setCurrentTransform(computedInitialTransform);
  }, [computedInitialTransform]);
  return /* @__PURE__ */ jsx12(
    "div",
    {
      ref: containerRef,
      style: {
        position: "relative",
        width: "100%",
        height: `${height}px`,
        border: "1px solid #eee",
        overflow: "hidden"
      },
      children: /* @__PURE__ */ jsx12(
        TransformContainer,
        {
          initialTransform: computedInitialTransform,
          onTransformChange: handleTransformChange,
          children: /* @__PURE__ */ jsx12(
            DimensionOverlay,
            {
              transform: currentTransform || computedInitialTransform,
              children: /* @__PURE__ */ jsx12(
                "canvas",
                {
                  ref: canvasRef,
                  style: {
                    position: "absolute",
                    top: 0,
                    left: 0,
                    width: "100%",
                    height: "100%"
                  }
                }
              )
            }
          )
        }
      )
    }
  );
};
export {
  CanvasGraphics,
  InteractiveGraphics,
  InteractiveGraphicsCanvas
};
//# sourceMappingURL=react.js.map