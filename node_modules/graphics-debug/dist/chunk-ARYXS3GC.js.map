{"version":3,"sources":["../lib/drawGraphicsToCanvas.ts","../site/components/InteractiveGraphics/defaultColors.ts"],"sourcesContent":["import {\n  compose,\n  scale,\n  translate,\n  applyToPoint,\n  type Matrix,\n} from \"transformation-matrix\"\nimport type {\n  GraphicsObject,\n  Viewbox,\n  CenterViewbox,\n  TransformOptions,\n} from \"./types\"\nimport { defaultColors } from \"site/components/InteractiveGraphics/defaultColors\"\nimport { FONT_SIZE_WIDTH_RATIO, FONT_SIZE_HEIGHT_RATIO } from \"./constants\"\n\n/**\n * Computes a transformation matrix based on a provided viewbox\n * Handles both min/max style viewboxes and center/width/height style viewboxes\n */\nexport function computeTransformFromViewbox(\n  viewbox: Viewbox | CenterViewbox,\n  canvasWidth: number,\n  canvasHeight: number,\n  options: { padding?: number; yFlip?: boolean } = {},\n): Matrix {\n  const padding = options.padding ?? 40\n  const yFlip = options.yFlip ?? false\n\n  // Convert CenterViewbox to Viewbox if needed\n  let bounds: Viewbox\n  if (\"center\" in viewbox) {\n    const halfWidth = viewbox.width / 2\n    const halfHeight = viewbox.height / 2\n    bounds = {\n      minX: viewbox.center.x - halfWidth,\n      maxX: viewbox.center.x + halfWidth,\n      minY: viewbox.center.y - halfHeight,\n      maxY: viewbox.center.y + halfHeight,\n    }\n  } else {\n    bounds = viewbox\n  }\n\n  const width = bounds.maxX - bounds.minX || 1\n  const height = bounds.maxY - bounds.minY || 1\n\n  const scale_factor = Math.min(\n    (canvasWidth - 2 * padding) / width,\n    (canvasHeight - 2 * padding) / height,\n  )\n\n  return compose(\n    translate(canvasWidth / 2, canvasHeight / 2),\n    scale(scale_factor, yFlip ? -scale_factor : scale_factor),\n    translate(-(bounds.minX + width / 2), -(bounds.minY + height / 2)),\n  )\n}\n\n/**\n * Computes bounds for a graphics object\n */\nexport function getBounds(graphics: GraphicsObject): Viewbox {\n  const points = [\n    ...(graphics.points || []),\n    ...(graphics.lines || []).flatMap((line) => line.points),\n    ...(graphics.rects || []).flatMap((rect) => {\n      const halfWidth = rect.width / 2\n      const halfHeight = rect.height / 2\n      return [\n        { x: rect.center.x - halfWidth, y: rect.center.y - halfHeight },\n        { x: rect.center.x + halfWidth, y: rect.center.y - halfHeight },\n        { x: rect.center.x - halfWidth, y: rect.center.y + halfHeight },\n        { x: rect.center.x + halfWidth, y: rect.center.y + halfHeight },\n      ]\n    }),\n    ...(graphics.circles || []).flatMap((circle) => [\n      { x: circle.center.x - circle.radius, y: circle.center.y }, // left\n      { x: circle.center.x + circle.radius, y: circle.center.y }, // right\n      { x: circle.center.x, y: circle.center.y - circle.radius }, // top\n      { x: circle.center.x, y: circle.center.y + circle.radius }, // bottom\n    ]),\n    ...(graphics.texts || []).flatMap((text) => {\n      const fontSize = text.fontSize ?? 12\n      const width = text.text.length * fontSize * FONT_SIZE_WIDTH_RATIO\n      const height = fontSize * FONT_SIZE_HEIGHT_RATIO\n      const anchor = text.anchorSide ?? \"center\"\n      const offsetMap: Record<string, { dx: number; dy: number }> = {\n        top_left: { dx: 0, dy: 0 },\n        top_center: { dx: -width / 2, dy: 0 },\n        top_right: { dx: -width, dy: 0 },\n        center_left: { dx: 0, dy: -height / 2 },\n        center: { dx: -width / 2, dy: -height / 2 },\n        center_right: { dx: -width, dy: -height / 2 },\n        bottom_left: { dx: 0, dy: -height },\n        bottom_center: { dx: -width / 2, dy: -height },\n        bottom_right: { dx: -width, dy: -height },\n      }\n      const { dx, dy } = offsetMap[anchor]\n      const x0 = text.x + dx\n      const y0 = text.y + dy\n      return [\n        { x: x0, y: y0 },\n        { x: x0 + width, y: y0 + height },\n      ]\n    }),\n  ]\n\n  if (points.length === 0) {\n    return { minX: -1, maxX: 1, minY: -1, maxY: 1 }\n  }\n\n  return points.reduce(\n    (bounds, point) => ({\n      minX: Math.min(bounds.minX, point.x),\n      maxX: Math.max(bounds.maxX, point.x),\n      minY: Math.min(bounds.minY, point.y),\n      maxY: Math.max(bounds.maxY, point.y),\n    }),\n    { minX: Infinity, maxX: -Infinity, minY: Infinity, maxY: -Infinity },\n  )\n}\n\n/**\n * Draws a graphics object onto a canvas or context\n * @param graphics - The graphics object to draw\n * @param target - The canvas element or 2D context to draw on\n * @param options - Options for controlling the transform and rendering\n */\nexport function drawGraphicsToCanvas(\n  graphics: GraphicsObject,\n  target: HTMLCanvasElement | CanvasRenderingContext2D,\n  options: TransformOptions = {},\n): void {\n  // Get the context\n  const ctx =\n    target instanceof HTMLCanvasElement ? target.getContext(\"2d\") : target\n\n  if (!ctx) {\n    throw new Error(\"Could not get 2D context from canvas\")\n  }\n\n  // Get canvas dimensions\n  const canvasWidth =\n    target instanceof HTMLCanvasElement ? target.width : target.canvas.width\n\n  const canvasHeight =\n    target instanceof HTMLCanvasElement ? target.height : target.canvas.height\n\n  // Get or compute the transform matrix\n  let matrix: Matrix\n\n  if (options.transform) {\n    matrix = options.transform\n  } else if (options.viewbox) {\n    matrix = computeTransformFromViewbox(\n      options.viewbox,\n      canvasWidth,\n      canvasHeight,\n      {\n        padding: options.padding,\n        yFlip: options.yFlip,\n      },\n    )\n  } else {\n    // Auto-compute bounds and transform if not provided\n    const bounds = getBounds(graphics)\n    const yFlip = graphics.coordinateSystem === \"cartesian\"\n    matrix = computeTransformFromViewbox(bounds, canvasWidth, canvasHeight, {\n      padding: options.padding ?? 40,\n      yFlip,\n    })\n  }\n\n  // Clear the canvas\n  ctx.clearRect(0, 0, canvasWidth, canvasHeight)\n\n  // Save the current transform state\n  ctx.save()\n\n  // Draw the graphics elements\n  // Draw rectangles\n  if (graphics.rects && graphics.rects.length > 0) {\n    graphics.rects.forEach((rect) => {\n      const halfWidth = rect.width / 2\n      const halfHeight = rect.height / 2\n\n      const topLeft = applyToPoint(matrix, {\n        x: rect.center.x - halfWidth,\n        y: rect.center.y - halfHeight,\n      })\n\n      const bottomRight = applyToPoint(matrix, {\n        x: rect.center.x + halfWidth,\n        y: rect.center.y + halfHeight,\n      })\n\n      const width = Math.abs(bottomRight.x - topLeft.x)\n      const height = Math.abs(bottomRight.y - topLeft.y)\n\n      ctx.beginPath()\n      ctx.rect(\n        Math.min(topLeft.x, bottomRight.x),\n        Math.min(topLeft.y, bottomRight.y),\n        width,\n        height,\n      )\n\n      if (rect.fill) {\n        ctx.fillStyle = rect.fill\n        ctx.fill()\n      }\n\n      if (rect.stroke) {\n        ctx.strokeStyle = rect.stroke\n        ctx.stroke()\n      }\n    })\n  }\n\n  // Draw circles\n  if (graphics.circles && graphics.circles.length > 0) {\n    graphics.circles.forEach((circle) => {\n      const projected = applyToPoint(matrix, circle.center)\n      const scaledRadius = circle.radius * Math.abs(matrix.a) // Use matrix scale factor\n\n      ctx.beginPath()\n      ctx.arc(projected.x, projected.y, scaledRadius, 0, 2 * Math.PI)\n\n      if (circle.fill) {\n        ctx.fillStyle = circle.fill\n        ctx.fill()\n      }\n\n      if (circle.stroke) {\n        ctx.strokeStyle = circle.stroke ?? \"transparent\"\n        ctx.stroke()\n      }\n    })\n  }\n\n  // Draw lines\n  if (graphics.lines && graphics.lines.length > 0) {\n    graphics.lines.forEach((line, lineIndex) => {\n      if (line.points.length === 0) return\n\n      ctx.beginPath()\n\n      const firstPoint = applyToPoint(matrix, line.points[0])\n      ctx.moveTo(firstPoint.x, firstPoint.y)\n\n      for (let i = 1; i < line.points.length; i++) {\n        const projected = applyToPoint(matrix, line.points[i])\n        ctx.lineTo(projected.x, projected.y)\n      }\n\n      ctx.strokeStyle =\n        line.strokeColor || defaultColors[lineIndex % defaultColors.length]\n      if (line.strokeWidth) {\n        ctx.lineWidth = line.strokeWidth * matrix.a\n      } else {\n        ctx.lineWidth = 2\n      }\n      ctx.lineCap = \"round\"\n\n      if (line.strokeDash) {\n        if (typeof line.strokeDash === \"string\") {\n          // Convert string to array of numbers, handling single values properly\n          let dashArray: number[]\n\n          // If the string contains commas, split and convert to numbers\n          if (line.strokeDash.includes(\",\")) {\n            dashArray = line.strokeDash\n              .split(\",\")\n              .map((s) => parseFloat(s.trim()))\n              .filter((n) => !Number.isNaN(n))\n          } else {\n            // Handle single value case\n            const value = parseFloat(line.strokeDash.trim())\n            dashArray = !Number.isNaN(value) ? [value] : []\n          }\n\n          // Scale dash values based on transform matrix\n          ctx.setLineDash(dashArray)\n        } else {\n          // Handle array format\n          ctx.setLineDash(line.strokeDash.map((n) => n * Math.abs(matrix.a)))\n        }\n      } else {\n        ctx.setLineDash([])\n      }\n\n      ctx.stroke()\n    })\n  }\n\n  // Draw points\n  if (graphics.points && graphics.points.length > 0) {\n    graphics.points.forEach((point, pointIndex) => {\n      const projected = applyToPoint(matrix, point)\n\n      // Draw point as a small circle\n      ctx.beginPath()\n      ctx.arc(projected.x, projected.y, 3, 0, 2 * Math.PI)\n      ctx.fillStyle =\n        point.color || defaultColors[pointIndex % defaultColors.length]\n      ctx.fill()\n\n      // Draw label if present and labels aren't disabled\n      if (point.label && !options.disableLabels) {\n        ctx.fillStyle = point.color || \"black\"\n        ctx.font = \"12px sans-serif\"\n        ctx.fillText(point.label, projected.x + 5, projected.y - 5)\n      }\n    })\n  }\n\n  // Draw texts\n  if (graphics.texts && graphics.texts.length > 0) {\n    graphics.texts.forEach((text) => {\n      const projected = applyToPoint(matrix, { x: text.x, y: text.y })\n      ctx.fillStyle = text.color || \"black\"\n      ctx.font = `${(text.fontSize ?? 12) * Math.abs(matrix.a)}px sans-serif`\n\n      const anchor = text.anchorSide ?? \"center\"\n      const alignMap: Record<string, CanvasTextAlign> = {\n        top_left: \"left\",\n        center_left: \"left\",\n        bottom_left: \"left\",\n        top_center: \"center\",\n        center: \"center\",\n        bottom_center: \"center\",\n        top_right: \"right\",\n        center_right: \"right\",\n        bottom_right: \"right\",\n      }\n      const baselineMap: Record<string, CanvasTextBaseline> = {\n        top_left: \"top\",\n        top_center: \"top\",\n        top_right: \"top\",\n        center_left: \"middle\",\n        center: \"middle\",\n        center_right: \"middle\",\n        bottom_left: \"bottom\",\n        bottom_center: \"bottom\",\n        bottom_right: \"bottom\",\n      }\n      ctx.textAlign = alignMap[anchor]\n      ctx.textBaseline = baselineMap[anchor]\n\n      ctx.fillText(text.text, projected.x, projected.y)\n    })\n  }\n\n  // Restore the original transform\n  ctx.restore()\n}\n","// These are default colors if no color is provided\n// colors are made based on the index of the item in the array\n\nexport const defaultColors = [\n  \"rgba(239, 68, 68, 0.8)\", // red-300\n  \"rgba(249, 115, 22, 0.8)\", // orange-300\n  \"rgba(245, 158, 11, 0.8)\", // amber-300\n  \"rgba(234, 179, 8, 0.8)\", // yellow-300\n  \"rgba(132, 204, 22, 0.8)\", // lime-300\n  \"rgba(34, 197, 94, 0.8)\", // green-300\n  \"rgba(16, 185, 129, 0.8)\", // emerald-300\n  \"rgba(20, 184, 166, 0.8)\", // teal-300\n  \"rgba(6, 182, 212, 0.8)\", // cyan-300\n  \"rgba(14, 165, 233, 0.8)\", // sky-300\n  \"rgba(59, 130, 246, 0.8)\", // blue-300\n  \"rgba(99, 102, 241, 0.8)\", // indigo-300\n  \"rgba(139, 92, 246, 0.8)\", // violet-300\n  \"rgba(168, 85, 247, 0.8)\", // purple-300\n  \"rgba(217, 70, 239, 0.8)\", // fuchsia-300\n  \"rgba(236, 72, 153, 0.8)\", // pink-300\n  \"rgba(249, 168, 212, 0.8)\", // rose-300\n  \"rgba(161, 161, 170, 0.8)\", // zinc-300\n]\n"],"mappings":"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","names":[]}