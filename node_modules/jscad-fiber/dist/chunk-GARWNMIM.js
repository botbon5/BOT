// lib/index.tsx
import ReactReconciler from "react-reconciler";

// lib/create-host-config.ts
import React from "react";

// lib/utils/flattenArray.ts
function flattenArray(arr) {
  return arr.reduce(
    (flat, item) => flat.concat(Array.isArray(item) ? flattenArray(item) : item),
    []
  );
}

// lib/utils/singleElementUnnest.ts
var singleElementUnnest = (element) => {
  if (Array.isArray(element) && element.length === 1) {
    return element[0];
  }
  return element;
};

// lib/create-host-config.ts
function createHostConfig(jscad) {
  const createInstance = (type, props, rootContainerInstance, hostContext, internalInstanceHandle) => {
    const renderChildren = (children) => {
      if (!children) return [];
      if (Array.isArray(children)) {
        return flattenArray(
          children.filter(React.isValidElement).map(
            (child) => createInstance(
              child.type,
              child.props,
              [],
              hostContext,
              internalInstanceHandle
            )
          )
        );
      }
      if (React.isValidElement(children)) {
        return [
          createInstance(
            children.type,
            children.props,
            [],
            hostContext,
            internalInstanceHandle
          )
        ];
      }
      return [];
    };
    if (typeof type === "function") {
      const element = type(props);
      return createInstance(
        element.type,
        element.props,
        rootContainerInstance,
        hostContext,
        internalInstanceHandle
      );
    }
    switch (type) {
      case "cube":
        return jscad.primitives.cube({ size: props.size });
      case "sphere":
        return jscad.primitives.sphere({
          radius: props.radius,
          segments: props.segments
        });
      case "cuboid":
        return jscad.primitives.cuboid({
          size: props.size
        });
      case "roundedCuboid":
        return jscad.primitives.roundedCuboid({
          size: props.size,
          roundRadius: props.roundRadius
        });
      case "geodesicSphere":
        return jscad.primitives.geodesicSphere({
          radius: props.radius,
          frequency: props.frequency
        });
      case "ellipsoid":
        return jscad.primitives.ellipsoid({
          radius: props.radius
        });
      case "cylinder":
        return jscad.primitives.cylinder({
          radius: props.radius,
          height: props.height
        });
      case "roundedCylinder":
        return jscad.primitives.roundedCylinder({
          radius: props.radius,
          height: props.height,
          roundRadius: props.roundRadius
        });
      case "cylinderElliptic":
        return jscad.primitives.cylinderElliptic({
          radius: props.radius,
          height: props.height,
          startRadius: props.startRadius,
          endRadius: props.endRadius,
          startAngle: props.startAngle,
          endAngle: props.endAngle
        });
      case "torus":
        return jscad.primitives.torus({
          innerRadius: props.innerRadius,
          outerRadius: props.outerRadius,
          innerSegments: props.innerSegments,
          outerSegments: props.outerSegments,
          innerRotation: props.innerRotation,
          outerRotation: props.outerRotation,
          startAngle: props.startAngle
        });
      case "jscadPolygon": {
        return jscad.primitives.polygon({
          points: props.points
        });
      }
      case "extrudeLinear": {
        const { children, ...extrudeProps } = props;
        const childrenGeometry = renderChildren(children);
        const extrudedGeometry = jscad.extrusions.extrudeLinear(
          {
            height: extrudeProps.height
            // twistAngle: extrudeProps.twistAngle,
            // twistSteps: extrudeProps.twistSteps,
          },
          childrenGeometry
        );
        return extrudedGeometry;
      }
      case "extrudeRotate": {
        const { children, ...extrudeProps } = props;
        const childrenGeometry = renderChildren(children);
        const extrudedGeometry = jscad.extrusions.extrudeRotate(
          {
            angle: extrudeProps.angle
            // twistAngle: extrudeProps.twistAngle,
            // twistSteps: extrudeProps.twistSteps,
          },
          childrenGeometry
        );
        return extrudedGeometry;
      }
      case "extrudeRectangular": {
        const { children, ...extrudeProps } = props;
        const childrenGeometry = renderChildren(children);
        const extrudedGeometry = jscad.extrusions.extrudeRectangular(
          {
            size: extrudeProps.size,
            height: extrudeProps.height
          },
          childrenGeometry
        );
        return extrudedGeometry;
      }
      case "extrudeHelical": {
        const { children, ...extrudeProps } = props;
        const childrenGeometry = renderChildren(children);
        const extrudedGeometry = jscad.extrusions.extrudeHelical(
          {
            height: extrudeProps.height,
            angle: extrudeProps.angle,
            startAngle: extrudeProps.startAngle || 0,
            pitch: extrudeProps.pitch || 0,
            endOffset: extrudeProps.endOffset || 0,
            segmetsPerRotation: extrudeProps.segmetsPerRotation || 32
          },
          childrenGeometry
        );
        return extrudedGeometry;
      }
      case "extrudeFromSlices": {
        const { baseSlice, ...extrudeProps } = props;
        const extrudedGeometry = jscad.extrusions.extrudeFromSlices(
          extrudeProps,
          baseSlice
        );
        return extrudedGeometry;
      }
      case "project": {
        const { children, ...projectProps } = props;
        const childrenGeometry = renderChildren(children);
        const projectedGeometry = jscad.extrusions.project(
          {
            axis: projectProps.axis,
            origin: projectProps.origin
          },
          childrenGeometry
        );
        return projectedGeometry;
      }
      case "colorize": {
        const { children, ...colorizeProps } = props;
        const childrenGeometry = renderChildren(children);
        const color = colorizeProps.color;
        const colorizedGeometry = jscad.colors.colorize(
          color,
          singleElementUnnest(childrenGeometry)
        );
        return colorizedGeometry;
      }
      case "custom": {
        const { geometry } = props;
        return geometry;
      }
      case "union": {
        const { children } = props;
        if (!Array.isArray(children) || children.length < 2) {
          throw new Error("Union must have at least two children");
        }
        const geometries = children.map(
          (child) => createInstance(
            child.type,
            child.props,
            rootContainerInstance,
            hostContext,
            internalInstanceHandle
          )
        );
        return geometries.reduce((acc, curr) => jscad.booleans.union(acc, curr));
      }
      case "subtract": {
        const { children } = props;
        if (!children || children.length < 2) {
          throw new Error(
            "Subtract must have at least one base component and one component to subtract."
          );
        }
        const validChildren = React.Children.toArray(children).filter(
          React.isValidElement
        );
        if (validChildren.length < 2) {
          throw new Error(
            "Subtract must have at least one base component and one component to subtract."
          );
        }
        const baseGeometry = createInstance(
          validChildren[0].type,
          validChildren[0].props,
          rootContainerInstance,
          hostContext,
          internalInstanceHandle
        );
        const subtractGeometries = flattenArray(
          validChildren.slice(1).map(
            (child) => createInstance(
              child.type,
              child.props,
              rootContainerInstance,
              hostContext,
              internalInstanceHandle
            )
          )
        );
        if (!baseGeometry || subtractGeometries.some((geo) => geo == null)) {
          throw new Error(
            "One or more geometries could not be processed for subtraction."
          );
        }
        return jscad.booleans.subtract(baseGeometry, subtractGeometries);
      }
      case "translate": {
        const { args, children } = props;
        const childrenGeometries = renderChildren(children);
        return jscad.transforms.translate(
          args,
          singleElementUnnest(childrenGeometries)
        );
      }
      case "rotate": {
        const { children, ...rotateProps } = props;
        const childrenGeometries = renderChildren(children);
        const rotateGeometry = jscad.transforms.rotate(
          rotateProps.angles,
          singleElementUnnest(childrenGeometries)
        );
        return rotateGeometry;
      }
      case "hull": {
        const { children } = props;
        if (!Array.isArray(children) || children.length < 2) {
          throw new Error("Hull must have at least two children");
        }
        const geometries = children.map(
          (child) => createInstance(
            child.type,
            child.props,
            rootContainerInstance,
            hostContext,
            internalInstanceHandle
          )
        );
        return jscad.hulls.hull(geometries);
      }
      case "hullChain": {
        const { children } = props;
        if (!Array.isArray(children) || children.length < 2) {
          throw new Error("HullChain must have at least two children");
        }
        const geometries = children.map(
          (child) => createInstance(
            child.type,
            child.props,
            rootContainerInstance,
            hostContext,
            internalInstanceHandle
          )
        );
        return jscad.hulls.hullChain(geometries);
      }
      case "rectangle": {
        const { size } = props;
        return jscad.primitives.rectangle({ size });
      }
      case "circle": {
        const { radius } = props;
        return jscad.primitives.circle({ radius });
      }
      default:
        throw new Error(`Unknown element type: ${type}`);
    }
  };
  const hostConfig = {
    // @ts-ignore
    now: Date.now,
    supportsMutation: true,
    supportsPersistence: false,
    supportsHydration: false,
    createInstance,
    createTextInstance() {
      throw new Error("Text elements are not supported in JSCAD");
    },
    appendInitialChild(parentInstance, child) {
      return parentInstance;
    },
    appendChild(parentInstance, child) {
      return parentInstance;
    },
    removeChild(parentInstance, child) {
      return parentInstance;
    },
    appendChildToContainer(container, child) {
      container.push(child);
    },
    removeChildFromContainer(container, child) {
      const index = container.indexOf(child);
      if (index !== -1) container.splice(index, 1);
    },
    prepareUpdate() {
      return true;
    },
    commitUpdate(instance, updatePayload, type, oldProps, newProps) {
      const newInstance = createInstance(type, newProps, instance, {}, null);
      for (const key in instance) {
        delete instance[key];
      }
      Object.assign(instance, newInstance);
    },
    finalizeInitialChildren() {
      return false;
    },
    prepareForCommit() {
      return null;
    },
    resetAfterCommit() {
    },
    getPublicInstance(instance) {
      return instance;
    },
    getRootHostContext() {
      return {};
    },
    getChildHostContext() {
      return {};
    },
    shouldSetTextContent() {
      return false;
    },
    clearContainer() {
    },
    scheduleTimeout: setTimeout,
    cancelTimeout: clearTimeout,
    noTimeout: -1,
    isPrimaryRenderer: true,
    getCurrentEventPriority: () => 99,
    getInstanceFromNode: () => null,
    beforeActiveInstanceBlur: () => {
    },
    afterActiveInstanceBlur: () => {
    },
    prepareScopeUpdate: () => {
    },
    getInstanceFromScope: () => null,
    detachDeletedInstance: () => {
    }
  };
  return hostConfig;
}

// lib/jscad-fns/circle.tsx
import { jsx } from "react/jsx-runtime";
function Circle({ radius }) {
  return /* @__PURE__ */ jsx("circle", { radius });
}

// lib/jscad-fns/colorize.tsx
import Color from "color";
import { jsx as jsx2 } from "react/jsx-runtime";
function Colorize({ color, children }) {
  if (!Array.isArray(color)) {
    color = Color(color).rgb().array().map((v) => v / 255);
  }
  return /* @__PURE__ */ jsx2("colorize", { color, children });
}

// lib/wrappers/with-color-prop.tsx
import { jsx as jsx3 } from "react/jsx-runtime";
function withColorProp(WrappedComponent) {
  const WithColor = (props) => {
    const { color, ...restProps } = props;
    if (!color) {
      return /* @__PURE__ */ jsx3(WrappedComponent, { ...restProps });
    }
    return /* @__PURE__ */ jsx3(Colorize, { color, children: /* @__PURE__ */ jsx3(WrappedComponent, { ...restProps }) });
  };
  WithColor.displayName = `WithColor(${WrappedComponent.displayName || WrappedComponent.name || "Component"})`;
  return WithColor;
}

// lib/jscad-fns/translate.tsx
import { jsx as jsx4 } from "react/jsx-runtime";
var normalizePointToArray = (point) => {
  if (!point) return null;
  if (Array.isArray(point)) {
    return point;
  }
  return [point.x, point.y, point.z];
};
function Translate({
  offset,
  center,
  x,
  y,
  z,
  children
}) {
  const offsetNorm = normalizePointToArray(offset);
  const centerNorm = normalizePointToArray(center);
  const args = [
    offsetNorm?.[0] || centerNorm?.[0] || x || 0,
    offsetNorm?.[1] || centerNorm?.[1] || y || 0,
    offsetNorm?.[2] || centerNorm?.[2] || z || 0
  ];
  return /* @__PURE__ */ jsx4("translate", { args, children });
}

// lib/wrappers/with-offset-prop.tsx
import { jsx as jsx5 } from "react/jsx-runtime";
function withOffsetProp(WrappedComponent) {
  const WithOffset = (props) => {
    const { center, offset, ...restProps } = props;
    if (!center && !offset) {
      return /* @__PURE__ */ jsx5(WrappedComponent, { ...restProps });
    }
    return /* @__PURE__ */ jsx5(Translate, { offset: center || offset, children: /* @__PURE__ */ jsx5(WrappedComponent, { ...restProps }) });
  };
  WithOffset.displayName = `WithOffset(${WrappedComponent.displayName || WrappedComponent.name || "Component"})`;
  return WithOffset;
}

// lib/jscad-fns/cube.tsx
import { jsx as jsx6 } from "react/jsx-runtime";
var CubeBase = ({ size }) => {
  return /* @__PURE__ */ jsx6("cube", { size });
};
var Cube = withOffsetProp(withColorProp(CubeBase));

// lib/jscad-fns/cuboid.tsx
import { jsx as jsx7 } from "react/jsx-runtime";
var CuboidBase = ({ size }) => {
  return /* @__PURE__ */ jsx7("cuboid", { size });
};
var Cuboid = withOffsetProp(withColorProp(CuboidBase));

// lib/jscad-fns/custom.tsx
import { jsx as jsx8 } from "react/jsx-runtime";
function Custom({ geometry }) {
  return /* @__PURE__ */ jsx8("custom", { geometry });
}

// lib/jscad-fns/rotate.tsx
import { jsx as jsx9 } from "react/jsx-runtime";
var convertToRadians = (value) => {
  if (typeof value === "string") {
    const numericValue = value.replace(/[^\d.-]/g, "");
    const parsedValue = parseFloat(numericValue);
    if (!isNaN(parsedValue)) {
      if (value.toLowerCase().includes("deg")) {
        return parsedValue * Math.PI / 180;
      }
      return parsedValue;
    }
    throw new Error(`Invalid rotation value: ${value}`);
  }
  return value;
};
var processRotation = (value) => {
  if (typeof value === "string" || typeof value === "number") {
    const angle = convertToRadians(value);
    return [0, 0, angle];
  } else if (Array.isArray(value)) {
    return value.map(convertToRadians);
  } else if (value && typeof value === "object") {
    return [
      convertToRadians(value.x),
      convertToRadians(value.y),
      convertToRadians(value.z)
    ];
  }
  return [0, 0, 0];
};
var RotateBase = ({ rotation, angles, children }) => {
  const finalRotation = rotation ? processRotation(rotation) : processRotation(angles);
  return /* @__PURE__ */ jsx9("rotate", { angles: finalRotation, children });
};
var Rotate = withOffsetProp(withColorProp(RotateBase));

// lib/wrappers/with-rotation-prop.tsx
import { jsx as jsx10 } from "react/jsx-runtime";
function withRotationProp(WrappedComponent) {
  const WithRotation = (props) => {
    const { rotation, ...restProps } = props;
    if (!rotation) {
      return /* @__PURE__ */ jsx10(WrappedComponent, { ...restProps });
    }
    return /* @__PURE__ */ jsx10(Rotate, { rotation, children: /* @__PURE__ */ jsx10(WrappedComponent, { ...restProps }) });
  };
  WithRotation.displayName = `WithRotation(${WrappedComponent.displayName || WrappedComponent.name || "Component"})`;
  return WithRotation;
}

// lib/jscad-fns/cylinder.tsx
import { jsx as jsx11 } from "react/jsx-runtime";
var CylinderBase = ({ radius, height }) => {
  return /* @__PURE__ */ jsx11("cylinder", { radius, height });
};
var Cylinder = withColorProp(
  withOffsetProp(withRotationProp(CylinderBase))
);

// lib/jscad-fns/cylinder-elliptic.tsx
import { jsx as jsx12 } from "react/jsx-runtime";
var CylinderEllipticBase = ({
  height,
  startRadius,
  endRadius,
  segments = 32,
  startAngle = 0,
  endAngle = Math.PI * 2
}) => {
  return /* @__PURE__ */ jsx12(
    "cylinderElliptic",
    {
      height,
      startRadius,
      endRadius,
      segments,
      startAngle,
      endAngle
    }
  );
};
var CylinderElliptic = withOffsetProp(
  withColorProp(CylinderEllipticBase)
);

// lib/jscad-fns/ellipsoid.tsx
import { jsx as jsx13 } from "react/jsx-runtime";
var EllipsoidBase = ({ radius }) => {
  return /* @__PURE__ */ jsx13("ellipsoid", { radius });
};
var Ellipsoid = withOffsetProp(withColorProp(EllipsoidBase));

// lib/jscad-fns/extrude-helical.tsx
import { jsx as jsx14 } from "react/jsx-runtime";
var ExtrudeHelicalBase = ({
  height,
  angle,
  startAngle,
  pitch,
  endOffset,
  segmetsPerRotation,
  children
}) => {
  return /* @__PURE__ */ jsx14(
    "extrudeHelical",
    {
      height,
      angle,
      startAngle,
      pitch,
      endOffset,
      segmetsPerRotation,
      children
    }
  );
};
var ExtrudeHelical = withOffsetProp(withColorProp(ExtrudeHelicalBase));

// lib/jscad-fns/extrude-linear.tsx
import { jsx as jsx15 } from "react/jsx-runtime";
var ExtrudeLinearBase = ({
  height,
  twistAngle,
  twistSteps,
  children
}) => {
  return /* @__PURE__ */ jsx15(
    "extrudeLinear",
    {
      height,
      twistAngle,
      twistSteps,
      children
    }
  );
};
var ExtrudeLinear = withOffsetProp(withColorProp(ExtrudeLinearBase));

// lib/jscad-fns/extrude-rectangular.tsx
import { jsx as jsx16 } from "react/jsx-runtime";
var ExtrudeRectangularBase = ({
  size,
  height,
  children
}) => {
  return /* @__PURE__ */ jsx16("extrudeRectangular", { size, height, children });
};
var ExtrudeRectangular = withOffsetProp(
  withColorProp(ExtrudeRectangularBase)
);

// lib/jscad-fns/extrude-rotate.tsx
import { jsx as jsx17 } from "react/jsx-runtime";
var ExtrudeRotateBase = ({
  angle,
  startAngle,
  segments,
  children
}) => {
  return /* @__PURE__ */ jsx17("extrudeRotate", { angle, startAngle, segments, children });
};
var ExtrudeRotate = withOffsetProp(withColorProp(ExtrudeRotateBase));

// lib/jscad-fns/geodesic-sphere.tsx
import { jsx as jsx18 } from "react/jsx-runtime";
var GeodesicSphereBase = ({ radius, frequency }) => {
  return /* @__PURE__ */ jsx18("geodesicSphere", { radius, frequency });
};
var GeodesicSphere = withOffsetProp(withColorProp(GeodesicSphereBase));

// lib/jscad-fns/hull.tsx
import { jsx as jsx19 } from "react/jsx-runtime";
var HullBase = ({ children }) => {
  return /* @__PURE__ */ jsx19("hull", { children });
};
var Hull = withOffsetProp(withColorProp(HullBase));

// lib/jscad-fns/hull-chain.tsx
import { jsx as jsx20 } from "react/jsx-runtime";
var HullChainBase = ({ children }) => {
  return /* @__PURE__ */ jsx20("hullChain", { children });
};
var HullChain = withOffsetProp(withColorProp(HullChainBase));

// lib/jscad-fns/polygon.tsx
import { jsx as jsx21 } from "react/jsx-runtime";
function Polygon({ points }) {
  return /* @__PURE__ */ jsx21("jscadPolygon", { points });
}

// lib/jscad-fns/project.tsx
import { jsx as jsx22 } from "react/jsx-runtime";
function Project({ axis, origin, children }) {
  return /* @__PURE__ */ jsx22("project", { axis, origin, children });
}

// lib/jscad-fns/rectangle.tsx
import { jsx as jsx23 } from "react/jsx-runtime";
function Rectangle({ size }) {
  return /* @__PURE__ */ jsx23("rectangle", { size });
}

// lib/jscad-fns/rounded-cuboid.tsx
import { jsx as jsx24 } from "react/jsx-runtime";
var RoundedCuboidBase = ({ size, roundRadius }) => {
  return /* @__PURE__ */ jsx24("roundedCuboid", { size, roundRadius });
};
var RoundedCuboid = withOffsetProp(withColorProp(RoundedCuboidBase));

// lib/jscad-fns/rounded-cylinder.tsx
import { jsx as jsx25 } from "react/jsx-runtime";
var RoundedCylinderBase = ({
  radius,
  height,
  roundRadius
}) => {
  return /* @__PURE__ */ jsx25(
    "roundedCylinder",
    {
      radius,
      height,
      roundRadius
    }
  );
};
var RoundedCylinder = withOffsetProp(
  withColorProp(RoundedCylinderBase)
);

// lib/jscad-fns/sphere.tsx
import { jsx as jsx26 } from "react/jsx-runtime";
var SphereBase = ({ radius, segments }) => {
  return /* @__PURE__ */ jsx26("sphere", { radius, segments: segments || 32 });
};
var Sphere = withColorProp(withOffsetProp(SphereBase));

// lib/jscad-fns/subtract.tsx
import { jsx as jsx27 } from "react/jsx-runtime";
var SubtractBase = ({ children }) => {
  if (!Array.isArray(children) || children.length < 2) {
    throw new Error("Subtract must have at least two children");
  }
  return /* @__PURE__ */ jsx27("subtract", { children });
};
var Subtract = withOffsetProp(withColorProp(SubtractBase));

// lib/jscad-fns/torus.tsx
import { jsx as jsx28 } from "react/jsx-runtime";
var TorusBase = ({
  innerRadius,
  outerRadius,
  innerSegments = 32,
  outerSegments = 32,
  innerRotation = 0,
  outerRotation = 1,
  startAngle = 0
}) => {
  return /* @__PURE__ */ jsx28(
    "torus",
    {
      innerRadius,
      outerRadius,
      innerSegments,
      outerSegments,
      innerRotation,
      outerRotation,
      startAngle
    }
  );
};
var Torus = withOffsetProp(withColorProp(TorusBase));

// lib/jscad-fns/union.tsx
import { jsx as jsx29 } from "react/jsx-runtime";
function Union({ children }) {
  return /* @__PURE__ */ jsx29("union", { children });
}

// lib/jscad-fns/extrude-from-slices.tsx
import { jsx as jsx30 } from "react/jsx-runtime";
var ExtrudeFromSlicesBase = ({
  numberOfSlices,
  capStart,
  capEnd,
  close,
  repair,
  baseSlice,
  callback
}) => {
  return /* @__PURE__ */ jsx30(
    "extrudeFromSlices",
    {
      numberOfSlices,
      capStart,
      capEnd,
      close,
      repair,
      baseSlice,
      callback
    }
  );
};
var ExtrudeFromSlices = withOffsetProp(
  withColorProp(ExtrudeFromSlicesBase)
);

// lib/hooks/use-render-elements-to-jscad-plan.ts
import React2 from "react";
var useRenderElementsToJscadPlan = (jscad, children) => {
  const { renderer } = React2.useMemo(() => {
    const renderer2 = createJSCADRenderer(jscad);
    return { renderer: renderer2 };
  }, [jscad]);
  const [error, setError] = React2.useState(null);
  const [loading, setLoading] = React2.useState(true);
  const jscadElms = React2.useMemo(() => {
    setLoading(true);
    const jscadElms2 = [];
    const root = renderer.createJSCADRoot(jscadElms2);
    try {
      root.render(children);
      setLoading(false);
      setError(null);
    } catch (err) {
      setError(err);
    }
    return jscadElms2;
  }, [children]);
  return { loading, jscadElms, error };
};

// lib/index.tsx
function createJSCADRenderer(jscad) {
  const hostConfig = createHostConfig(jscad);
  function createJSCADRoot(container) {
    const reconciler = ReactReconciler(hostConfig);
    const root = reconciler.createContainer(
      container,
      0,
      null,
      false,
      null,
      "",
      (error) => console.error(error),
      null
    );
    return {
      render(element) {
        reconciler.updateContainer(element, root, null, () => {
        });
      }
    };
  }
  return { createJSCADRoot };
}

export {
  createHostConfig,
  Circle,
  Colorize,
  normalizePointToArray,
  Translate,
  Cube,
  Cuboid,
  Custom,
  processRotation,
  Rotate,
  Cylinder,
  CylinderElliptic,
  Ellipsoid,
  ExtrudeHelical,
  ExtrudeLinear,
  ExtrudeRectangular,
  ExtrudeRotate,
  GeodesicSphere,
  Hull,
  HullChain,
  Polygon,
  Project,
  Rectangle,
  RoundedCuboid,
  RoundedCylinder,
  Sphere,
  Subtract,
  Torus,
  Union,
  ExtrudeFromSlices,
  useRenderElementsToJscadPlan,
  createJSCADRenderer
};
//# sourceMappingURL=chunk-GARWNMIM.js.map