import {
  createHostConfig,
  createJSCADRenderer
} from "./chunk-GARWNMIM.js";

// lib/useJSCADRenderer.ts
import * as jscad from "@jscad/modeling";
import { useEffect, useMemo, useState } from "react";
import ReactReconciler from "react-reconciler";
import * as THREE from "three";

// lib/convert-csg-to-three-geom.ts
import {
  BufferAttribute,
  BufferGeometry,
  Matrix4
} from "three";
function convertCSGToThreeGeom(csg) {
  if (csg.polygons) {
    const vertices = [];
    const indices = [];
    const colors = [];
    let idx = 0;
    for (const polygon of csg.polygons) {
      for (const vertex of polygon.vertices) {
        vertex.index = idx;
        vertices.push(vertex[0], vertex[1], vertex[2]);
        if (csg.color && csg.color.length >= 3) {
          colors.push(csg.color[0], csg.color[1], csg.color[2]);
        } else {
          colors.push(1, 1, 1);
        }
        idx++;
      }
      const first = polygon.vertices[0].index;
      for (let i = 2; i < polygon.vertices.length; i++) {
        const second = polygon.vertices[i - 1].index;
        const third = polygon.vertices[i].index;
        indices.push(first, second, third);
      }
    }
    const geo = new BufferGeometry();
    geo.setAttribute(
      "position",
      new BufferAttribute(new Float32Array(vertices), 3)
    );
    geo.setIndex(indices);
    if (colors.length > 0) {
      geo.setAttribute(
        "color",
        new BufferAttribute(new Float32Array(colors), 3)
      );
    }
    if (csg.transforms) {
      const transforms = new Matrix4();
      transforms.set(...csg.transforms).transpose();
      geo.applyMatrix4(transforms);
    }
    geo.computeVertexNormals();
    return geo;
  }
  if (csg.sides) {
    const vertices = [];
    const colors = [];
    for (const side of csg.sides) {
      vertices.push(side[0][0], side[0][1], 0);
      if (csg.color && csg.color.length >= 3) {
        colors.push(csg.color[0], csg.color[1], csg.color[2]);
      } else {
        colors.push(1, 1, 1);
      }
    }
    const geo = new BufferGeometry();
    geo.setAttribute(
      "position",
      new BufferAttribute(new Float32Array(vertices), 3)
    );
    if (colors.length > 0) {
      geo.setAttribute(
        "color",
        new BufferAttribute(new Float32Array(colors), 3)
      );
    }
    if (csg.transforms) {
      const transforms = new Matrix4();
      transforms.set(...csg.transforms).transpose();
      geo.applyMatrix4(transforms);
    }
    return geo;
  }
  console.error("Invalid CSG object: neither polygons nor sides found");
  return new BufferGeometry();
}
var convert_csg_to_three_geom_default = convertCSGToThreeGeom;

// lib/useJSCADRenderer.ts
var hostConfig = createHostConfig(jscad);
var reconciler = ReactReconciler(hostConfig);
function useJSCADRenderer(children) {
  const container = useMemo(() => [], []);
  const root = useMemo(() => {
    const root2 = reconciler.createContainer(
      container,
      0,
      null,
      false,
      null,
      "",
      (error) => console.error(error),
      null
    );
    return root2;
  }, [container]);
  const [mesh, setMesh] = useState(null);
  useEffect(() => {
    reconciler.updateContainer(children, root, null, () => {
    });
    const scene = new THREE.Scene();
    container.map((csg) => {
      const geometry = convert_csg_to_three_geom_default(csg);
      if (csg.sides) {
        const material = new THREE.LineBasicMaterial({
          vertexColors: true,
          linewidth: 2
          // Note: linewidth > 1 only works in WebGL 2
        });
        const lineLoop = new THREE.LineLoop(geometry, material);
        scene.add(lineLoop);
      } else {
        const material = new THREE.MeshStandardMaterial({
          vertexColors: true,
          side: THREE.DoubleSide
          // Ensure both sides are visible
        });
        const mesh2 = new THREE.Mesh(geometry, material);
        scene.add(mesh2);
      }
    });
    setMesh(scene);
  }, [children, root, container]);
  return mesh;
}

// lib/components/jscad-three-mesh.tsx
import { jsx } from "react/jsx-runtime";
function JSCadThreeMesh({
  children
}) {
  const mesh = useJSCADRenderer(children);
  if (!mesh) {
    return null;
  }
  return /* @__PURE__ */ jsx("primitive", { object: mesh });
}

// lib/components/jscad-view.tsx
import * as jscad2 from "@jscad/modeling";
import React from "react";
import * as THREE2 from "three";
import { OrbitControls } from "three/examples/jsm/controls/OrbitControls.js";
import { jsx as jsx2 } from "react/jsx-runtime";
var { createJSCADRoot } = createJSCADRenderer(jscad2);
function JsCadView({
  children,
  wireframe,
  zAxisUp = false,
  showGrid = false
}) {
  const containerRef = React.useRef(null);
  const sceneRef = React.useRef(null);
  const gridRef = React.useRef(null);
  React.useEffect(() => {
    if (containerRef.current) {
      let processCGS2 = function(csg) {
        if (Array.isArray(csg)) {
          for (const child of csg) {
            processCGS2(child);
          }
        } else {
          const geometry = convert_csg_to_three_geom_default(csg);
          if (csg.sides) {
            const material = new THREE2.LineBasicMaterial({
              vertexColors: true,
              linewidth: 2
              // Note: linewidth > 1 only works in WebGL 2
            });
            const lineLoop = new THREE2.LineLoop(geometry, material);
            scene.add(lineLoop);
          } else {
            const material = new THREE2.MeshStandardMaterial({
              vertexColors: true,
              wireframe,
              side: THREE2.DoubleSide
              // Ensure both sides are visible
            });
            const mesh = new THREE2.Mesh(geometry, material);
            scene.add(mesh);
          }
        }
      }, animate2 = function() {
        requestAnimationFrame(animate2);
        controls.update();
        renderer.render(scene, camera);
      };
      var processCGS = processCGS2, animate = animate2;
      const jscadGeoms = [];
      const root = createJSCADRoot(jscadGeoms);
      root.render(children);
      const scene = new THREE2.Scene();
      sceneRef.current = scene;
      if (zAxisUp) {
        scene.rotation.x = -Math.PI / 2;
      }
      const camera = new THREE2.PerspectiveCamera(
        75,
        window.innerWidth / window.innerHeight,
        0.1,
        1e3
      );
      const ambientLight = new THREE2.AmbientLight(16777215, 0.5);
      scene.add(ambientLight);
      const directionalLight1 = new THREE2.DirectionalLight(16777215, 0.5);
      directionalLight1.position.set(100, 100, 100);
      scene.add(directionalLight1);
      const directionalLight2 = new THREE2.DirectionalLight(16777215, 0.2);
      directionalLight2.position.set(0, -100, 100);
      scene.add(directionalLight2);
      const directionalLight3 = new THREE2.DirectionalLight(16777215, 0.1);
      directionalLight3.position.set(-100, 100, 100);
      scene.add(directionalLight3);
      const gridHelper = new THREE2.GridHelper(100, 100);
      gridHelper.visible = showGrid;
      if (zAxisUp) {
        gridHelper.rotation.x = -Math.PI / 2;
      }
      scene.add(gridHelper);
      gridRef.current = gridHelper;
      for (const csg of jscadGeoms) {
        processCGS2(csg);
      }
      camera.position.x = 20;
      camera.position.y = 20;
      camera.position.z = 20;
      const renderer = new THREE2.WebGLRenderer();
      renderer.setSize(window.innerWidth, window.innerHeight);
      containerRef.current.appendChild(renderer.domElement);
      const controls = new OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.dampingFactor = 0.25;
      controls.enableZoom = true;
      animate2();
      return () => {
        scene.remove(gridHelper);
        renderer.dispose();
        controls.dispose();
      };
    }
  }, [children, wireframe, zAxisUp, showGrid]);
  React.useEffect(() => {
    if (gridRef.current) {
      gridRef.current.visible = showGrid;
    }
  }, [showGrid]);
  return /* @__PURE__ */ jsx2("div", { ref: containerRef, style: { width: "100%", minHeight: "400px" } });
}
export {
  JSCadThreeMesh,
  JsCadView,
  convertCSGToThreeGeom
};
//# sourceMappingURL=three.js.map