{"version":3,"sources":["../lib/useJSCADRenderer.ts","../lib/convert-csg-to-three-geom.ts","../lib/components/jscad-three-mesh.tsx","../lib/components/jscad-view.tsx"],"sourcesContent":["import * as jscad from \"@jscad/modeling\"\nimport { useEffect, useMemo, useState } from \"react\"\nimport ReactReconciler from \"react-reconciler\"\nimport * as THREE from \"three\"\nimport convertCSGToThreeGeom from \"./convert-csg-to-three-geom\"\nimport { createHostConfig } from \"./create-host-config\"\n\nconst hostConfig = createHostConfig(jscad as any)\nconst reconciler = ReactReconciler(hostConfig)\n\n/**\n * React Hook that initalizes the JSCAD root to render 3D objects\n */\nexport function useJSCADRenderer(children) {\n  const container = useMemo<any[]>(() => [], [])\n\n  const root = useMemo(() => {\n    const root = reconciler.createContainer(\n      container,\n      0,\n      null,\n      false,\n      null,\n      \"\",\n      (error) => console.error(error),\n      null,\n    )\n\n    return root\n  }, [container])\n\n  const [mesh, setMesh] = useState<THREE.Scene | null>(null)\n\n  useEffect(() => {\n    reconciler.updateContainer(children, root, null, () => {})\n\n    const scene = new THREE.Scene()\n\n    container.map((csg) => {\n      const geometry = convertCSGToThreeGeom(csg)\n\n      if (csg.sides) {\n        // 2D shape\n        const material = new THREE.LineBasicMaterial({\n          vertexColors: true,\n          linewidth: 2, // Note: linewidth > 1 only works in WebGL 2\n        })\n        const lineLoop = new THREE.LineLoop(geometry, material)\n        scene.add(lineLoop)\n      } else {\n        // 3D shape\n        const material = new THREE.MeshStandardMaterial({\n          vertexColors: true,\n          side: THREE.DoubleSide, // Ensure both sides are visible\n        })\n        const mesh = new THREE.Mesh(geometry, material)\n        scene.add(mesh)\n      }\n    })\n\n    setMesh(scene)\n  }, [children, root, container])\n\n  return mesh\n}\n","// @ts-nocheck\nimport {\n  BufferAttribute,\n  BufferGeometry,\n  Color,\n  Matrix4,\n  Vector2,\n  Vector3,\n} from \"three\"\n\nexport function convertCSGToThreeGeom(csg): BufferGeometry {\n  if (csg.polygons) {\n    // 3D shape\n    const vertices = []\n    const indices = []\n    const colors = []\n    let idx = 0\n\n    for (const polygon of csg.polygons) {\n      for (const vertex of polygon.vertices) {\n        vertex.index = idx\n        vertices.push(vertex[0], vertex[1], vertex[2])\n        // Add color for each vertex\n        if (csg.color && csg.color.length >= 3) {\n          colors.push(csg.color[0], csg.color[1], csg.color[2])\n        } else {\n          colors.push(1, 1, 1) // Default to white if no color\n        }\n        idx++\n      }\n      const first = polygon.vertices[0].index\n      for (let i = 2; i < polygon.vertices.length; i++) {\n        const second = polygon.vertices[i - 1].index\n        const third = polygon.vertices[i].index\n        indices.push(first, second, third)\n      }\n    }\n\n    const geo = new BufferGeometry()\n    geo.setAttribute(\n      \"position\",\n      new BufferAttribute(new Float32Array(vertices), 3),\n    )\n    geo.setIndex(indices)\n\n    // Add color attribute\n    if (colors.length > 0) {\n      geo.setAttribute(\n        \"color\",\n        new BufferAttribute(new Float32Array(colors), 3),\n      )\n    }\n\n    if (csg.transforms) {\n      const transforms = new Matrix4()\n      transforms.set(...csg.transforms).transpose()\n      geo.applyMatrix4(transforms)\n    }\n    geo.computeVertexNormals()\n\n    return geo\n  }\n  if (csg.sides) {\n    // 2D shape\n    const vertices = []\n    const colors = []\n\n    for (const side of csg.sides) {\n      vertices.push(side[0][0], side[0][1], 0) // Add z-coordinate as 0\n      // Add color for each vertex\n      if (csg.color && csg.color.length >= 3) {\n        colors.push(csg.color[0], csg.color[1], csg.color[2])\n      } else {\n        colors.push(1, 1, 1) // Default to white if no color\n      }\n    }\n\n    const geo = new BufferGeometry()\n    geo.setAttribute(\n      \"position\",\n      new BufferAttribute(new Float32Array(vertices), 3),\n    )\n\n    // Add color attribute\n    if (colors.length > 0) {\n      geo.setAttribute(\n        \"color\",\n        new BufferAttribute(new Float32Array(colors), 3),\n      )\n    }\n\n    if (csg.transforms) {\n      const transforms = new Matrix4()\n      transforms.set(...csg.transforms).transpose()\n      geo.applyMatrix4(transforms)\n    }\n\n    return geo\n  }\n  console.error(\"Invalid CSG object: neither polygons nor sides found\")\n  return new BufferGeometry()\n}\n\nexport default convertCSGToThreeGeom\n","import { useJSCADRenderer } from \"../useJSCADRenderer\"\n\nexport function JSCadThreeMesh({\n  children,\n}: {\n  children: any\n}) {\n  const mesh = useJSCADRenderer(children)\n\n  if (!mesh) {\n    return null\n  }\n\n  //@ts-ignore\n  return <primitive object={mesh} />\n}\n","import * as jscad from \"@jscad/modeling\"\nimport React from \"react\"\nimport * as THREE from \"three\"\nimport { OrbitControls } from \"three/examples/jsm/controls/OrbitControls.js\"\nimport { Cube, Sphere, createJSCADRenderer } from \"..\"\nimport convertCSGToThreeGeom from \"../convert-csg-to-three-geom\"\n\nconst { createJSCADRoot } = createJSCADRenderer(jscad as any)\n\nexport function JsCadView({\n  children,\n  wireframe,\n  zAxisUp = false,\n  showGrid = false,\n}: {\n  children: any\n  wireframe?: boolean\n  zAxisUp?: boolean\n  showGrid?: boolean\n}) {\n  const containerRef = React.useRef<HTMLDivElement>(null)\n  const sceneRef = React.useRef<THREE.Scene | null>(null)\n  const gridRef = React.useRef<THREE.GridHelper | null>(null)\n\n  React.useEffect(() => {\n    if (containerRef.current) {\n      const jscadGeoms: any[] = []\n      const root = createJSCADRoot(jscadGeoms)\n      root.render(children)\n\n      const scene = new THREE.Scene()\n      sceneRef.current = scene\n      if (zAxisUp) {\n        scene.rotation.x = -Math.PI / 2\n      }\n      const camera = new THREE.PerspectiveCamera(\n        75,\n        window.innerWidth / window.innerHeight,\n        0.1,\n        1000,\n      )\n\n      // Add ambient light\n      const ambientLight = new THREE.AmbientLight(0xffffff, 0.5)\n      scene.add(ambientLight)\n\n      // Add directional lights\n      const directionalLight1 = new THREE.DirectionalLight(0xffffff, 0.5)\n      directionalLight1.position.set(100, 100, 100)\n      scene.add(directionalLight1)\n\n      const directionalLight2 = new THREE.DirectionalLight(0xffffff, 0.2)\n      directionalLight2.position.set(0, -100, 100)\n      scene.add(directionalLight2)\n\n      const directionalLight3 = new THREE.DirectionalLight(0xffffff, 0.1)\n      directionalLight3.position.set(-100, 100, 100)\n      scene.add(directionalLight3)\n\n      // Add grid\n      const gridHelper = new THREE.GridHelper(100, 100)\n      gridHelper.visible = showGrid\n      if (zAxisUp) {\n        gridHelper.rotation.x = -Math.PI / 2\n      }\n      scene.add(gridHelper)\n      gridRef.current = gridHelper\n\n      function processCGS(csg: any) {\n        if (Array.isArray(csg)) {\n          for (const child of csg) {\n            processCGS(child)\n          }\n        } else {\n          const geometry = convertCSGToThreeGeom(csg)\n\n          if (csg.sides) {\n            // 2D shape\n            const material = new THREE.LineBasicMaterial({\n              vertexColors: true,\n              linewidth: 2, // Note: linewidth > 1 only works in WebGL 2\n            })\n            const lineLoop = new THREE.LineLoop(geometry, material)\n            scene.add(lineLoop)\n          } else {\n            // 3D shape\n            const material = new THREE.MeshStandardMaterial({\n              vertexColors: true,\n              wireframe: wireframe,\n              side: THREE.DoubleSide, // Ensure both sides are visible\n            })\n            const mesh = new THREE.Mesh(geometry, material)\n            scene.add(mesh)\n          }\n        }\n      }\n\n      for (const csg of jscadGeoms) {\n        processCGS(csg)\n      }\n\n      camera.position.x = 20\n      camera.position.y = 20\n      camera.position.z = 20\n\n      const renderer = new THREE.WebGLRenderer()\n      renderer.setSize(window.innerWidth, window.innerHeight)\n\n      containerRef.current.appendChild(renderer.domElement)\n\n      // Add OrbitControls\n      const controls = new OrbitControls(camera, renderer.domElement)\n      controls.enableDamping = true\n      controls.dampingFactor = 0.25\n      controls.enableZoom = true\n\n      // Animation loop\n      function animate() {\n        requestAnimationFrame(animate)\n        controls.update()\n        renderer.render(scene, camera)\n      }\n      animate()\n\n      // Cleanup function\n      return () => {\n        scene.remove(gridHelper)\n        renderer.dispose()\n        controls.dispose()\n      }\n    }\n  }, [children, wireframe, zAxisUp, showGrid])\n\n  // Update grid visibility when showGrid prop changes\n  React.useEffect(() => {\n    if (gridRef.current) {\n      gridRef.current.visible = showGrid\n    }\n  }, [showGrid])\n\n  return (\n    <div ref={containerRef} style={{ width: \"100%\", minHeight: \"400px\" }} />\n  )\n}\n"],"mappings":";;;;;;AAAA,YAAY,WAAW;AACvB,SAAS,WAAW,SAAS,gBAAgB;AAC7C,OAAO,qBAAqB;AAC5B,YAAY,WAAW;;;ACFvB;AAAA,EACE;AAAA,EACA;AAAA,EAEA;AAAA,OAGK;AAEA,SAAS,sBAAsB,KAAqB;AACzD,MAAI,IAAI,UAAU;AAEhB,UAAM,WAAW,CAAC;AAClB,UAAM,UAAU,CAAC;AACjB,UAAM,SAAS,CAAC;AAChB,QAAI,MAAM;AAEV,eAAW,WAAW,IAAI,UAAU;AAClC,iBAAW,UAAU,QAAQ,UAAU;AACrC,eAAO,QAAQ;AACf,iBAAS,KAAK,OAAO,CAAC,GAAG,OAAO,CAAC,GAAG,OAAO,CAAC,CAAC;AAE7C,YAAI,IAAI,SAAS,IAAI,MAAM,UAAU,GAAG;AACtC,iBAAO,KAAK,IAAI,MAAM,CAAC,GAAG,IAAI,MAAM,CAAC,GAAG,IAAI,MAAM,CAAC,CAAC;AAAA,QACtD,OAAO;AACL,iBAAO,KAAK,GAAG,GAAG,CAAC;AAAA,QACrB;AACA;AAAA,MACF;AACA,YAAM,QAAQ,QAAQ,SAAS,CAAC,EAAE;AAClC,eAAS,IAAI,GAAG,IAAI,QAAQ,SAAS,QAAQ,KAAK;AAChD,cAAM,SAAS,QAAQ,SAAS,IAAI,CAAC,EAAE;AACvC,cAAM,QAAQ,QAAQ,SAAS,CAAC,EAAE;AAClC,gBAAQ,KAAK,OAAO,QAAQ,KAAK;AAAA,MACnC;AAAA,IACF;AAEA,UAAM,MAAM,IAAI,eAAe;AAC/B,QAAI;AAAA,MACF;AAAA,MACA,IAAI,gBAAgB,IAAI,aAAa,QAAQ,GAAG,CAAC;AAAA,IACnD;AACA,QAAI,SAAS,OAAO;AAGpB,QAAI,OAAO,SAAS,GAAG;AACrB,UAAI;AAAA,QACF;AAAA,QACA,IAAI,gBAAgB,IAAI,aAAa,MAAM,GAAG,CAAC;AAAA,MACjD;AAAA,IACF;AAEA,QAAI,IAAI,YAAY;AAClB,YAAM,aAAa,IAAI,QAAQ;AAC/B,iBAAW,IAAI,GAAG,IAAI,UAAU,EAAE,UAAU;AAC5C,UAAI,aAAa,UAAU;AAAA,IAC7B;AACA,QAAI,qBAAqB;AAEzB,WAAO;AAAA,EACT;AACA,MAAI,IAAI,OAAO;AAEb,UAAM,WAAW,CAAC;AAClB,UAAM,SAAS,CAAC;AAEhB,eAAW,QAAQ,IAAI,OAAO;AAC5B,eAAS,KAAK,KAAK,CAAC,EAAE,CAAC,GAAG,KAAK,CAAC,EAAE,CAAC,GAAG,CAAC;AAEvC,UAAI,IAAI,SAAS,IAAI,MAAM,UAAU,GAAG;AACtC,eAAO,KAAK,IAAI,MAAM,CAAC,GAAG,IAAI,MAAM,CAAC,GAAG,IAAI,MAAM,CAAC,CAAC;AAAA,MACtD,OAAO;AACL,eAAO,KAAK,GAAG,GAAG,CAAC;AAAA,MACrB;AAAA,IACF;AAEA,UAAM,MAAM,IAAI,eAAe;AAC/B,QAAI;AAAA,MACF;AAAA,MACA,IAAI,gBAAgB,IAAI,aAAa,QAAQ,GAAG,CAAC;AAAA,IACnD;AAGA,QAAI,OAAO,SAAS,GAAG;AACrB,UAAI;AAAA,QACF;AAAA,QACA,IAAI,gBAAgB,IAAI,aAAa,MAAM,GAAG,CAAC;AAAA,MACjD;AAAA,IACF;AAEA,QAAI,IAAI,YAAY;AAClB,YAAM,aAAa,IAAI,QAAQ;AAC/B,iBAAW,IAAI,GAAG,IAAI,UAAU,EAAE,UAAU;AAC5C,UAAI,aAAa,UAAU;AAAA,IAC7B;AAEA,WAAO;AAAA,EACT;AACA,UAAQ,MAAM,sDAAsD;AACpE,SAAO,IAAI,eAAe;AAC5B;AAEA,IAAO,oCAAQ;;;ADhGf,IAAM,aAAa,iBAAiB,KAAY;AAChD,IAAM,aAAa,gBAAgB,UAAU;AAKtC,SAAS,iBAAiB,UAAU;AACzC,QAAM,YAAY,QAAe,MAAM,CAAC,GAAG,CAAC,CAAC;AAE7C,QAAM,OAAO,QAAQ,MAAM;AACzB,UAAMA,QAAO,WAAW;AAAA,MACtB;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA,CAAC,UAAU,QAAQ,MAAM,KAAK;AAAA,MAC9B;AAAA,IACF;AAEA,WAAOA;AAAA,EACT,GAAG,CAAC,SAAS,CAAC;AAEd,QAAM,CAAC,MAAM,OAAO,IAAI,SAA6B,IAAI;AAEzD,YAAU,MAAM;AACd,eAAW,gBAAgB,UAAU,MAAM,MAAM,MAAM;AAAA,IAAC,CAAC;AAEzD,UAAM,QAAQ,IAAU,YAAM;AAE9B,cAAU,IAAI,CAAC,QAAQ;AACrB,YAAM,WAAW,kCAAsB,GAAG;AAE1C,UAAI,IAAI,OAAO;AAEb,cAAM,WAAW,IAAU,wBAAkB;AAAA,UAC3C,cAAc;AAAA,UACd,WAAW;AAAA;AAAA,QACb,CAAC;AACD,cAAM,WAAW,IAAU,eAAS,UAAU,QAAQ;AACtD,cAAM,IAAI,QAAQ;AAAA,MACpB,OAAO;AAEL,cAAM,WAAW,IAAU,2BAAqB;AAAA,UAC9C,cAAc;AAAA,UACd,MAAY;AAAA;AAAA,QACd,CAAC;AACD,cAAMC,QAAO,IAAU,WAAK,UAAU,QAAQ;AAC9C,cAAM,IAAIA,KAAI;AAAA,MAChB;AAAA,IACF,CAAC;AAED,YAAQ,KAAK;AAAA,EACf,GAAG,CAAC,UAAU,MAAM,SAAS,CAAC;AAE9B,SAAO;AACT;;;AElDS;AAZF,SAAS,eAAe;AAAA,EAC7B;AACF,GAEG;AACD,QAAM,OAAO,iBAAiB,QAAQ;AAEtC,MAAI,CAAC,MAAM;AACT,WAAO;AAAA,EACT;AAGA,SAAO,oBAAC,eAAU,QAAQ,MAAM;AAClC;;;ACfA,YAAYC,YAAW;AACvB,OAAO,WAAW;AAClB,YAAYC,YAAW;AACvB,SAAS,qBAAqB;AA0I1B,gBAAAC,YAAA;AAtIJ,IAAM,EAAE,gBAAgB,IAAI,oBAAoBC,MAAY;AAErD,SAAS,UAAU;AAAA,EACxB;AAAA,EACA;AAAA,EACA,UAAU;AAAA,EACV,WAAW;AACb,GAKG;AACD,QAAM,eAAe,MAAM,OAAuB,IAAI;AACtD,QAAM,WAAW,MAAM,OAA2B,IAAI;AACtD,QAAM,UAAU,MAAM,OAAgC,IAAI;AAE1D,QAAM,UAAU,MAAM;AACpB,QAAI,aAAa,SAAS;AA2CxB,UAASC,cAAT,SAAoB,KAAU;AAC5B,YAAI,MAAM,QAAQ,GAAG,GAAG;AACtB,qBAAW,SAAS,KAAK;AACvB,YAAAA,YAAW,KAAK;AAAA,UAClB;AAAA,QACF,OAAO;AACL,gBAAM,WAAW,kCAAsB,GAAG;AAE1C,cAAI,IAAI,OAAO;AAEb,kBAAM,WAAW,IAAU,yBAAkB;AAAA,cAC3C,cAAc;AAAA,cACd,WAAW;AAAA;AAAA,YACb,CAAC;AACD,kBAAM,WAAW,IAAU,gBAAS,UAAU,QAAQ;AACtD,kBAAM,IAAI,QAAQ;AAAA,UACpB,OAAO;AAEL,kBAAM,WAAW,IAAU,4BAAqB;AAAA,cAC9C,cAAc;AAAA,cACd;AAAA,cACA,MAAY;AAAA;AAAA,YACd,CAAC;AACD,kBAAM,OAAO,IAAU,YAAK,UAAU,QAAQ;AAC9C,kBAAM,IAAI,IAAI;AAAA,UAChB;AAAA,QACF;AAAA,MACF,GAsBSC,WAAT,WAAmB;AACjB,8BAAsBA,QAAO;AAC7B,iBAAS,OAAO;AAChB,iBAAS,OAAO,OAAO,MAAM;AAAA,MAC/B;AArDS,uBAAAD,aAiDA,UAAAC;AA3FT,YAAM,aAAoB,CAAC;AAC3B,YAAM,OAAO,gBAAgB,UAAU;AACvC,WAAK,OAAO,QAAQ;AAEpB,YAAM,QAAQ,IAAU,aAAM;AAC9B,eAAS,UAAU;AACnB,UAAI,SAAS;AACX,cAAM,SAAS,IAAI,CAAC,KAAK,KAAK;AAAA,MAChC;AACA,YAAM,SAAS,IAAU;AAAA,QACvB;AAAA,QACA,OAAO,aAAa,OAAO;AAAA,QAC3B;AAAA,QACA;AAAA,MACF;AAGA,YAAM,eAAe,IAAU,oBAAa,UAAU,GAAG;AACzD,YAAM,IAAI,YAAY;AAGtB,YAAM,oBAAoB,IAAU,wBAAiB,UAAU,GAAG;AAClE,wBAAkB,SAAS,IAAI,KAAK,KAAK,GAAG;AAC5C,YAAM,IAAI,iBAAiB;AAE3B,YAAM,oBAAoB,IAAU,wBAAiB,UAAU,GAAG;AAClE,wBAAkB,SAAS,IAAI,GAAG,MAAM,GAAG;AAC3C,YAAM,IAAI,iBAAiB;AAE3B,YAAM,oBAAoB,IAAU,wBAAiB,UAAU,GAAG;AAClE,wBAAkB,SAAS,IAAI,MAAM,KAAK,GAAG;AAC7C,YAAM,IAAI,iBAAiB;AAG3B,YAAM,aAAa,IAAU,kBAAW,KAAK,GAAG;AAChD,iBAAW,UAAU;AACrB,UAAI,SAAS;AACX,mBAAW,SAAS,IAAI,CAAC,KAAK,KAAK;AAAA,MACrC;AACA,YAAM,IAAI,UAAU;AACpB,cAAQ,UAAU;AA+BlB,iBAAW,OAAO,YAAY;AAC5B,QAAAD,YAAW,GAAG;AAAA,MAChB;AAEA,aAAO,SAAS,IAAI;AACpB,aAAO,SAAS,IAAI;AACpB,aAAO,SAAS,IAAI;AAEpB,YAAM,WAAW,IAAU,qBAAc;AACzC,eAAS,QAAQ,OAAO,YAAY,OAAO,WAAW;AAEtD,mBAAa,QAAQ,YAAY,SAAS,UAAU;AAGpD,YAAM,WAAW,IAAI,cAAc,QAAQ,SAAS,UAAU;AAC9D,eAAS,gBAAgB;AACzB,eAAS,gBAAgB;AACzB,eAAS,aAAa;AAQtB,MAAAC,SAAQ;AAGR,aAAO,MAAM;AACX,cAAM,OAAO,UAAU;AACvB,iBAAS,QAAQ;AACjB,iBAAS,QAAQ;AAAA,MACnB;AAAA,IACF;AAAA,EACF,GAAG,CAAC,UAAU,WAAW,SAAS,QAAQ,CAAC;AAG3C,QAAM,UAAU,MAAM;AACpB,QAAI,QAAQ,SAAS;AACnB,cAAQ,QAAQ,UAAU;AAAA,IAC5B;AAAA,EACF,GAAG,CAAC,QAAQ,CAAC;AAEb,SACE,gBAAAH,KAAC,SAAI,KAAK,cAAc,OAAO,EAAE,OAAO,QAAQ,WAAW,QAAQ,GAAG;AAE1E;","names":["root","mesh","jscad","THREE","jsx","jscad","processCGS","animate"]}