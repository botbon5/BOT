// lib/utils/combineVisualizations.ts
var combineVisualizations = (...visualizations) => {
  const combined = {
    points: [],
    lines: [],
    circles: [],
    rects: []
  };
  visualizations.forEach((viz, i) => {
    if (!viz) return;
    if (viz.lines) {
      combined.lines = [
        ...combined.lines || [],
        ...viz.lines.map((l) => ({ ...l, step: i }))
      ];
    }
    if (viz.points) {
      combined.points = [
        ...combined.points || [],
        ...viz.points.map((p) => ({ ...p, step: i }))
      ];
    }
    if (viz.circles) {
      combined.circles = [
        ...combined.circles || [],
        ...viz.circles.map((c) => ({ ...c, step: i }))
      ];
    }
    if (viz.rects) {
      combined.rects = [
        ...combined.rects || [],
        ...viz.rects.map((r) => ({ ...r, step: i }))
      ];
    }
  });
  return combined;
};

// lib/solvers/BaseSolver.ts
var BaseSolver = class {
  MAX_ITERATIONS = 1e3;
  solved = false;
  failed = false;
  iterations = 0;
  progress = 0;
  error = null;
  activeSubSolver;
  failedSubSolvers;
  timeToSolve;
  stats = {};
  /**
   * For cached solvers
   **/
  cacheHit;
  cacheKey;
  cacheToSolveSpaceTransform;
  /** DO NOT OVERRIDE! Override _step() instead */
  step() {
    if (this.solved) return;
    if (this.failed) return;
    this.iterations++;
    try {
      this._step();
    } catch (e) {
      this.error = `${this.constructor.name} error: ${e}`;
      console.error(this.error);
      this.failed = true;
      throw e;
    }
    if (!this.solved && this.iterations > this.MAX_ITERATIONS) {
      this.tryFinalAcceptance();
    }
    if (!this.solved && this.iterations > this.MAX_ITERATIONS) {
      this.error = `${this.constructor.name} ran out of iterations`;
      console.error(this.error);
      this.failed = true;
    }
    if ("computeProgress" in this) {
      this.progress = this.computeProgress();
    }
  }
  _step() {
  }
  getConstructorParams() {
    throw new Error("getConstructorParams not implemented");
  }
  solve() {
    const startTime = Date.now();
    while (!this.solved && !this.failed) {
      this.step();
    }
    const endTime = Date.now();
    this.timeToSolve = endTime - startTime;
  }
  visualize() {
    return {
      lines: [],
      points: [],
      rects: [],
      circles: []
    };
  }
  /**
   * Called when the solver is about to fail, but we want to see if we have an
   * "acceptable" or "passable" solution. Mostly used for optimizers that
   * have an aggressive early stopping criterion.
   */
  tryFinalAcceptance() {
  }
  /**
   * A lightweight version of the visualize method that can be used to stream
   * progress
   */
  preview() {
    return {
      lines: [],
      points: [],
      rects: [],
      circles: []
    };
  }
};

// node_modules/@babel/runtime/helpers/esm/extends.js
function _extends() {
  return _extends = Object.assign ? Object.assign.bind() : function(n) {
    for (var e = 1; e < arguments.length; e++) {
      var t = arguments[e];
      for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);
    }
    return n;
  }, _extends.apply(null, arguments);
}

// node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js
function _assertThisInitialized(e) {
  if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return e;
}

// node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js
function _setPrototypeOf(t, e) {
  return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t2, e2) {
    return t2.__proto__ = e2, t2;
  }, _setPrototypeOf(t, e);
}

// node_modules/@babel/runtime/helpers/esm/inheritsLoose.js
function _inheritsLoose(t, o) {
  t.prototype = Object.create(o.prototype), t.prototype.constructor = t, _setPrototypeOf(t, o);
}

// node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js
function _getPrototypeOf(t) {
  return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t2) {
    return t2.__proto__ || Object.getPrototypeOf(t2);
  }, _getPrototypeOf(t);
}

// node_modules/@babel/runtime/helpers/esm/isNativeFunction.js
function _isNativeFunction(t) {
  try {
    return -1 !== Function.toString.call(t).indexOf("[native code]");
  } catch (n) {
    return "function" == typeof t;
  }
}

// node_modules/@babel/runtime/helpers/esm/isNativeReflectConstruct.js
function _isNativeReflectConstruct() {
  try {
    var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
  } catch (t2) {
  }
  return (_isNativeReflectConstruct = function _isNativeReflectConstruct2() {
    return !!t;
  })();
}

// node_modules/@babel/runtime/helpers/esm/construct.js
function _construct(t, e, r) {
  if (_isNativeReflectConstruct()) return Reflect.construct.apply(null, arguments);
  var o = [null];
  o.push.apply(o, e);
  var p = new (t.bind.apply(t, o))();
  return r && _setPrototypeOf(p, r.prototype), p;
}

// node_modules/@babel/runtime/helpers/esm/wrapNativeSuper.js
function _wrapNativeSuper(t) {
  var r = "function" == typeof Map ? /* @__PURE__ */ new Map() : void 0;
  return _wrapNativeSuper = function _wrapNativeSuper2(t2) {
    if (null === t2 || !_isNativeFunction(t2)) return t2;
    if ("function" != typeof t2) throw new TypeError("Super expression must either be null or a function");
    if (void 0 !== r) {
      if (r.has(t2)) return r.get(t2);
      r.set(t2, Wrapper);
    }
    function Wrapper() {
      return _construct(t2, arguments, _getPrototypeOf(this).constructor);
    }
    return Wrapper.prototype = Object.create(t2.prototype, {
      constructor: {
        value: Wrapper,
        enumerable: false,
        writable: true,
        configurable: true
      }
    }), _setPrototypeOf(Wrapper, t2);
  }, _wrapNativeSuper(t);
}

// node_modules/polished/dist/polished.esm.js
var ERRORS = {
  "1": "Passed invalid arguments to hsl, please pass multiple numbers e.g. hsl(360, 0.75, 0.4) or an object e.g. rgb({ hue: 255, saturation: 0.4, lightness: 0.75 }).\n\n",
  "2": "Passed invalid arguments to hsla, please pass multiple numbers e.g. hsla(360, 0.75, 0.4, 0.7) or an object e.g. rgb({ hue: 255, saturation: 0.4, lightness: 0.75, alpha: 0.7 }).\n\n",
  "3": "Passed an incorrect argument to a color function, please pass a string representation of a color.\n\n",
  "4": "Couldn't generate valid rgb string from %s, it returned %s.\n\n",
  "5": "Couldn't parse the color string. Please provide the color as a string in hex, rgb, rgba, hsl or hsla notation.\n\n",
  "6": "Passed invalid arguments to rgb, please pass multiple numbers e.g. rgb(255, 205, 100) or an object e.g. rgb({ red: 255, green: 205, blue: 100 }).\n\n",
  "7": "Passed invalid arguments to rgba, please pass multiple numbers e.g. rgb(255, 205, 100, 0.75) or an object e.g. rgb({ red: 255, green: 205, blue: 100, alpha: 0.75 }).\n\n",
  "8": "Passed invalid argument to toColorString, please pass a RgbColor, RgbaColor, HslColor or HslaColor object.\n\n",
  "9": "Please provide a number of steps to the modularScale helper.\n\n",
  "10": "Please pass a number or one of the predefined scales to the modularScale helper as the ratio.\n\n",
  "11": 'Invalid value passed as base to modularScale, expected number or em string but got "%s"\n\n',
  "12": 'Expected a string ending in "px" or a number passed as the first argument to %s(), got "%s" instead.\n\n',
  "13": 'Expected a string ending in "px" or a number passed as the second argument to %s(), got "%s" instead.\n\n',
  "14": 'Passed invalid pixel value ("%s") to %s(), please pass a value like "12px" or 12.\n\n',
  "15": 'Passed invalid base value ("%s") to %s(), please pass a value like "12px" or 12.\n\n',
  "16": "You must provide a template to this method.\n\n",
  "17": "You passed an unsupported selector state to this method.\n\n",
  "18": "minScreen and maxScreen must be provided as stringified numbers with the same units.\n\n",
  "19": "fromSize and toSize must be provided as stringified numbers with the same units.\n\n",
  "20": "expects either an array of objects or a single object with the properties prop, fromSize, and toSize.\n\n",
  "21": "expects the objects in the first argument array to have the properties `prop`, `fromSize`, and `toSize`.\n\n",
  "22": "expects the first argument object to have the properties `prop`, `fromSize`, and `toSize`.\n\n",
  "23": "fontFace expects a name of a font-family.\n\n",
  "24": "fontFace expects either the path to the font file(s) or a name of a local copy.\n\n",
  "25": "fontFace expects localFonts to be an array.\n\n",
  "26": "fontFace expects fileFormats to be an array.\n\n",
  "27": "radialGradient requries at least 2 color-stops to properly render.\n\n",
  "28": "Please supply a filename to retinaImage() as the first argument.\n\n",
  "29": "Passed invalid argument to triangle, please pass correct pointingDirection e.g. 'right'.\n\n",
  "30": "Passed an invalid value to `height` or `width`. Please provide a pixel based unit.\n\n",
  "31": "The animation shorthand only takes 8 arguments. See the specification for more information: http://mdn.io/animation\n\n",
  "32": "To pass multiple animations please supply them in arrays, e.g. animation(['rotate', '2s'], ['move', '1s'])\nTo pass a single animation please supply them in simple values, e.g. animation('rotate', '2s')\n\n",
  "33": "The animation shorthand arrays can only have 8 elements. See the specification for more information: http://mdn.io/animation\n\n",
  "34": "borderRadius expects a radius value as a string or number as the second argument.\n\n",
  "35": 'borderRadius expects one of "top", "bottom", "left" or "right" as the first argument.\n\n',
  "36": "Property must be a string value.\n\n",
  "37": "Syntax Error at %s.\n\n",
  "38": "Formula contains a function that needs parentheses at %s.\n\n",
  "39": "Formula is missing closing parenthesis at %s.\n\n",
  "40": "Formula has too many closing parentheses at %s.\n\n",
  "41": "All values in a formula must have the same unit or be unitless.\n\n",
  "42": "Please provide a number of steps to the modularScale helper.\n\n",
  "43": "Please pass a number or one of the predefined scales to the modularScale helper as the ratio.\n\n",
  "44": "Invalid value passed as base to modularScale, expected number or em/rem string but got %s.\n\n",
  "45": "Passed invalid argument to hslToColorString, please pass a HslColor or HslaColor object.\n\n",
  "46": "Passed invalid argument to rgbToColorString, please pass a RgbColor or RgbaColor object.\n\n",
  "47": "minScreen and maxScreen must be provided as stringified numbers with the same units.\n\n",
  "48": "fromSize and toSize must be provided as stringified numbers with the same units.\n\n",
  "49": "Expects either an array of objects or a single object with the properties prop, fromSize, and toSize.\n\n",
  "50": "Expects the objects in the first argument array to have the properties prop, fromSize, and toSize.\n\n",
  "51": "Expects the first argument object to have the properties prop, fromSize, and toSize.\n\n",
  "52": "fontFace expects either the path to the font file(s) or a name of a local copy.\n\n",
  "53": "fontFace expects localFonts to be an array.\n\n",
  "54": "fontFace expects fileFormats to be an array.\n\n",
  "55": "fontFace expects a name of a font-family.\n\n",
  "56": "linearGradient requries at least 2 color-stops to properly render.\n\n",
  "57": "radialGradient requries at least 2 color-stops to properly render.\n\n",
  "58": "Please supply a filename to retinaImage() as the first argument.\n\n",
  "59": "Passed invalid argument to triangle, please pass correct pointingDirection e.g. 'right'.\n\n",
  "60": "Passed an invalid value to `height` or `width`. Please provide a pixel based unit.\n\n",
  "61": "Property must be a string value.\n\n",
  "62": "borderRadius expects a radius value as a string or number as the second argument.\n\n",
  "63": 'borderRadius expects one of "top", "bottom", "left" or "right" as the first argument.\n\n',
  "64": "The animation shorthand only takes 8 arguments. See the specification for more information: http://mdn.io/animation.\n\n",
  "65": "To pass multiple animations please supply them in arrays, e.g. animation(['rotate', '2s'], ['move', '1s'])\\nTo pass a single animation please supply them in simple values, e.g. animation('rotate', '2s').\n\n",
  "66": "The animation shorthand arrays can only have 8 elements. See the specification for more information: http://mdn.io/animation.\n\n",
  "67": "You must provide a template to this method.\n\n",
  "68": "You passed an unsupported selector state to this method.\n\n",
  "69": 'Expected a string ending in "px" or a number passed as the first argument to %s(), got %s instead.\n\n',
  "70": 'Expected a string ending in "px" or a number passed as the second argument to %s(), got %s instead.\n\n',
  "71": 'Passed invalid pixel value %s to %s(), please pass a value like "12px" or 12.\n\n',
  "72": 'Passed invalid base value %s to %s(), please pass a value like "12px" or 12.\n\n',
  "73": "Please provide a valid CSS variable.\n\n",
  "74": "CSS variable not found and no default was provided.\n\n",
  "75": "important requires a valid style object, got a %s instead.\n\n",
  "76": "fromSize and toSize must be provided as stringified numbers with the same units as minScreen and maxScreen.\n\n",
  "77": 'remToPx expects a value in "rem" but you provided it in "%s".\n\n',
  "78": 'base must be set in "px" or "%" but you set it in "%s".\n'
};
function format() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }
  var a = args[0];
  var b = [];
  var c;
  for (c = 1; c < args.length; c += 1) {
    b.push(args[c]);
  }
  b.forEach(function(d) {
    a = a.replace(/%[a-z]/, d);
  });
  return a;
}
var PolishedError = /* @__PURE__ */ function(_Error) {
  _inheritsLoose(PolishedError2, _Error);
  function PolishedError2(code) {
    var _this;
    if (process.env.NODE_ENV === "production") {
      _this = _Error.call(this, "An error occurred. See https://github.com/styled-components/polished/blob/main/src/internalHelpers/errors.md#" + code + " for more information.") || this;
    } else {
      for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
        args[_key2 - 1] = arguments[_key2];
      }
      _this = _Error.call(this, format.apply(void 0, [ERRORS[code]].concat(args))) || this;
    }
    return _assertThisInitialized(_this);
  }
  return PolishedError2;
}(/* @__PURE__ */ _wrapNativeSuper(Error));
function endsWith(string, suffix) {
  return string.substr(-suffix.length) === suffix;
}
var cssRegex$1 = /^([+-]?(?:\d+|\d*\.\d+))([a-z]*|%)$/;
function stripUnit(value) {
  if (typeof value !== "string") return value;
  var matchedValue = value.match(cssRegex$1);
  return matchedValue ? parseFloat(value) : value;
}
var pxtoFactory = function pxtoFactory2(to) {
  return function(pxval, base) {
    if (base === void 0) {
      base = "16px";
    }
    var newPxval = pxval;
    var newBase = base;
    if (typeof pxval === "string") {
      if (!endsWith(pxval, "px")) {
        throw new PolishedError(69, to, pxval);
      }
      newPxval = stripUnit(pxval);
    }
    if (typeof base === "string") {
      if (!endsWith(base, "px")) {
        throw new PolishedError(70, to, base);
      }
      newBase = stripUnit(base);
    }
    if (typeof newPxval === "string") {
      throw new PolishedError(71, pxval, to);
    }
    if (typeof newBase === "string") {
      throw new PolishedError(72, base, to);
    }
    return "" + newPxval / newBase + to;
  };
};
var pixelsto = pxtoFactory;
var em = pixelsto("em");
var rem = pixelsto("rem");
function colorToInt(color) {
  return Math.round(color * 255);
}
function convertToInt(red, green, blue) {
  return colorToInt(red) + "," + colorToInt(green) + "," + colorToInt(blue);
}
function hslToRgb(hue, saturation, lightness, convert) {
  if (convert === void 0) {
    convert = convertToInt;
  }
  if (saturation === 0) {
    return convert(lightness, lightness, lightness);
  }
  var huePrime = (hue % 360 + 360) % 360 / 60;
  var chroma = (1 - Math.abs(2 * lightness - 1)) * saturation;
  var secondComponent = chroma * (1 - Math.abs(huePrime % 2 - 1));
  var red = 0;
  var green = 0;
  var blue = 0;
  if (huePrime >= 0 && huePrime < 1) {
    red = chroma;
    green = secondComponent;
  } else if (huePrime >= 1 && huePrime < 2) {
    red = secondComponent;
    green = chroma;
  } else if (huePrime >= 2 && huePrime < 3) {
    green = chroma;
    blue = secondComponent;
  } else if (huePrime >= 3 && huePrime < 4) {
    green = secondComponent;
    blue = chroma;
  } else if (huePrime >= 4 && huePrime < 5) {
    red = secondComponent;
    blue = chroma;
  } else if (huePrime >= 5 && huePrime < 6) {
    red = chroma;
    blue = secondComponent;
  }
  var lightnessModification = lightness - chroma / 2;
  var finalRed = red + lightnessModification;
  var finalGreen = green + lightnessModification;
  var finalBlue = blue + lightnessModification;
  return convert(finalRed, finalGreen, finalBlue);
}
var namedColorMap = {
  aliceblue: "f0f8ff",
  antiquewhite: "faebd7",
  aqua: "00ffff",
  aquamarine: "7fffd4",
  azure: "f0ffff",
  beige: "f5f5dc",
  bisque: "ffe4c4",
  black: "000",
  blanchedalmond: "ffebcd",
  blue: "0000ff",
  blueviolet: "8a2be2",
  brown: "a52a2a",
  burlywood: "deb887",
  cadetblue: "5f9ea0",
  chartreuse: "7fff00",
  chocolate: "d2691e",
  coral: "ff7f50",
  cornflowerblue: "6495ed",
  cornsilk: "fff8dc",
  crimson: "dc143c",
  cyan: "00ffff",
  darkblue: "00008b",
  darkcyan: "008b8b",
  darkgoldenrod: "b8860b",
  darkgray: "a9a9a9",
  darkgreen: "006400",
  darkgrey: "a9a9a9",
  darkkhaki: "bdb76b",
  darkmagenta: "8b008b",
  darkolivegreen: "556b2f",
  darkorange: "ff8c00",
  darkorchid: "9932cc",
  darkred: "8b0000",
  darksalmon: "e9967a",
  darkseagreen: "8fbc8f",
  darkslateblue: "483d8b",
  darkslategray: "2f4f4f",
  darkslategrey: "2f4f4f",
  darkturquoise: "00ced1",
  darkviolet: "9400d3",
  deeppink: "ff1493",
  deepskyblue: "00bfff",
  dimgray: "696969",
  dimgrey: "696969",
  dodgerblue: "1e90ff",
  firebrick: "b22222",
  floralwhite: "fffaf0",
  forestgreen: "228b22",
  fuchsia: "ff00ff",
  gainsboro: "dcdcdc",
  ghostwhite: "f8f8ff",
  gold: "ffd700",
  goldenrod: "daa520",
  gray: "808080",
  green: "008000",
  greenyellow: "adff2f",
  grey: "808080",
  honeydew: "f0fff0",
  hotpink: "ff69b4",
  indianred: "cd5c5c",
  indigo: "4b0082",
  ivory: "fffff0",
  khaki: "f0e68c",
  lavender: "e6e6fa",
  lavenderblush: "fff0f5",
  lawngreen: "7cfc00",
  lemonchiffon: "fffacd",
  lightblue: "add8e6",
  lightcoral: "f08080",
  lightcyan: "e0ffff",
  lightgoldenrodyellow: "fafad2",
  lightgray: "d3d3d3",
  lightgreen: "90ee90",
  lightgrey: "d3d3d3",
  lightpink: "ffb6c1",
  lightsalmon: "ffa07a",
  lightseagreen: "20b2aa",
  lightskyblue: "87cefa",
  lightslategray: "789",
  lightslategrey: "789",
  lightsteelblue: "b0c4de",
  lightyellow: "ffffe0",
  lime: "0f0",
  limegreen: "32cd32",
  linen: "faf0e6",
  magenta: "f0f",
  maroon: "800000",
  mediumaquamarine: "66cdaa",
  mediumblue: "0000cd",
  mediumorchid: "ba55d3",
  mediumpurple: "9370db",
  mediumseagreen: "3cb371",
  mediumslateblue: "7b68ee",
  mediumspringgreen: "00fa9a",
  mediumturquoise: "48d1cc",
  mediumvioletred: "c71585",
  midnightblue: "191970",
  mintcream: "f5fffa",
  mistyrose: "ffe4e1",
  moccasin: "ffe4b5",
  navajowhite: "ffdead",
  navy: "000080",
  oldlace: "fdf5e6",
  olive: "808000",
  olivedrab: "6b8e23",
  orange: "ffa500",
  orangered: "ff4500",
  orchid: "da70d6",
  palegoldenrod: "eee8aa",
  palegreen: "98fb98",
  paleturquoise: "afeeee",
  palevioletred: "db7093",
  papayawhip: "ffefd5",
  peachpuff: "ffdab9",
  peru: "cd853f",
  pink: "ffc0cb",
  plum: "dda0dd",
  powderblue: "b0e0e6",
  purple: "800080",
  rebeccapurple: "639",
  red: "f00",
  rosybrown: "bc8f8f",
  royalblue: "4169e1",
  saddlebrown: "8b4513",
  salmon: "fa8072",
  sandybrown: "f4a460",
  seagreen: "2e8b57",
  seashell: "fff5ee",
  sienna: "a0522d",
  silver: "c0c0c0",
  skyblue: "87ceeb",
  slateblue: "6a5acd",
  slategray: "708090",
  slategrey: "708090",
  snow: "fffafa",
  springgreen: "00ff7f",
  steelblue: "4682b4",
  tan: "d2b48c",
  teal: "008080",
  thistle: "d8bfd8",
  tomato: "ff6347",
  turquoise: "40e0d0",
  violet: "ee82ee",
  wheat: "f5deb3",
  white: "fff",
  whitesmoke: "f5f5f5",
  yellow: "ff0",
  yellowgreen: "9acd32"
};
function nameToHex(color) {
  if (typeof color !== "string") return color;
  var normalizedColorName = color.toLowerCase();
  return namedColorMap[normalizedColorName] ? "#" + namedColorMap[normalizedColorName] : color;
}
var hexRegex = /^#[a-fA-F0-9]{6}$/;
var hexRgbaRegex = /^#[a-fA-F0-9]{8}$/;
var reducedHexRegex = /^#[a-fA-F0-9]{3}$/;
var reducedRgbaHexRegex = /^#[a-fA-F0-9]{4}$/;
var rgbRegex = /^rgb\(\s*(\d{1,3})\s*(?:,)?\s*(\d{1,3})\s*(?:,)?\s*(\d{1,3})\s*\)$/i;
var rgbaRegex = /^rgb(?:a)?\(\s*(\d{1,3})\s*(?:,)?\s*(\d{1,3})\s*(?:,)?\s*(\d{1,3})\s*(?:,|\/)\s*([-+]?\d*[.]?\d+[%]?)\s*\)$/i;
var hslRegex = /^hsl\(\s*(\d{0,3}[.]?[0-9]+(?:deg)?)\s*(?:,)?\s*(\d{1,3}[.]?[0-9]?)%\s*(?:,)?\s*(\d{1,3}[.]?[0-9]?)%\s*\)$/i;
var hslaRegex = /^hsl(?:a)?\(\s*(\d{0,3}[.]?[0-9]+(?:deg)?)\s*(?:,)?\s*(\d{1,3}[.]?[0-9]?)%\s*(?:,)?\s*(\d{1,3}[.]?[0-9]?)%\s*(?:,|\/)\s*([-+]?\d*[.]?\d+[%]?)\s*\)$/i;
function parseToRgb(color) {
  if (typeof color !== "string") {
    throw new PolishedError(3);
  }
  var normalizedColor = nameToHex(color);
  if (normalizedColor.match(hexRegex)) {
    return {
      red: parseInt("" + normalizedColor[1] + normalizedColor[2], 16),
      green: parseInt("" + normalizedColor[3] + normalizedColor[4], 16),
      blue: parseInt("" + normalizedColor[5] + normalizedColor[6], 16)
    };
  }
  if (normalizedColor.match(hexRgbaRegex)) {
    var alpha = parseFloat((parseInt("" + normalizedColor[7] + normalizedColor[8], 16) / 255).toFixed(2));
    return {
      red: parseInt("" + normalizedColor[1] + normalizedColor[2], 16),
      green: parseInt("" + normalizedColor[3] + normalizedColor[4], 16),
      blue: parseInt("" + normalizedColor[5] + normalizedColor[6], 16),
      alpha
    };
  }
  if (normalizedColor.match(reducedHexRegex)) {
    return {
      red: parseInt("" + normalizedColor[1] + normalizedColor[1], 16),
      green: parseInt("" + normalizedColor[2] + normalizedColor[2], 16),
      blue: parseInt("" + normalizedColor[3] + normalizedColor[3], 16)
    };
  }
  if (normalizedColor.match(reducedRgbaHexRegex)) {
    var _alpha = parseFloat((parseInt("" + normalizedColor[4] + normalizedColor[4], 16) / 255).toFixed(2));
    return {
      red: parseInt("" + normalizedColor[1] + normalizedColor[1], 16),
      green: parseInt("" + normalizedColor[2] + normalizedColor[2], 16),
      blue: parseInt("" + normalizedColor[3] + normalizedColor[3], 16),
      alpha: _alpha
    };
  }
  var rgbMatched = rgbRegex.exec(normalizedColor);
  if (rgbMatched) {
    return {
      red: parseInt("" + rgbMatched[1], 10),
      green: parseInt("" + rgbMatched[2], 10),
      blue: parseInt("" + rgbMatched[3], 10)
    };
  }
  var rgbaMatched = rgbaRegex.exec(normalizedColor.substring(0, 50));
  if (rgbaMatched) {
    return {
      red: parseInt("" + rgbaMatched[1], 10),
      green: parseInt("" + rgbaMatched[2], 10),
      blue: parseInt("" + rgbaMatched[3], 10),
      alpha: parseFloat("" + rgbaMatched[4]) > 1 ? parseFloat("" + rgbaMatched[4]) / 100 : parseFloat("" + rgbaMatched[4])
    };
  }
  var hslMatched = hslRegex.exec(normalizedColor);
  if (hslMatched) {
    var hue = parseInt("" + hslMatched[1], 10);
    var saturation = parseInt("" + hslMatched[2], 10) / 100;
    var lightness = parseInt("" + hslMatched[3], 10) / 100;
    var rgbColorString = "rgb(" + hslToRgb(hue, saturation, lightness) + ")";
    var hslRgbMatched = rgbRegex.exec(rgbColorString);
    if (!hslRgbMatched) {
      throw new PolishedError(4, normalizedColor, rgbColorString);
    }
    return {
      red: parseInt("" + hslRgbMatched[1], 10),
      green: parseInt("" + hslRgbMatched[2], 10),
      blue: parseInt("" + hslRgbMatched[3], 10)
    };
  }
  var hslaMatched = hslaRegex.exec(normalizedColor.substring(0, 50));
  if (hslaMatched) {
    var _hue = parseInt("" + hslaMatched[1], 10);
    var _saturation = parseInt("" + hslaMatched[2], 10) / 100;
    var _lightness = parseInt("" + hslaMatched[3], 10) / 100;
    var _rgbColorString = "rgb(" + hslToRgb(_hue, _saturation, _lightness) + ")";
    var _hslRgbMatched = rgbRegex.exec(_rgbColorString);
    if (!_hslRgbMatched) {
      throw new PolishedError(4, normalizedColor, _rgbColorString);
    }
    return {
      red: parseInt("" + _hslRgbMatched[1], 10),
      green: parseInt("" + _hslRgbMatched[2], 10),
      blue: parseInt("" + _hslRgbMatched[3], 10),
      alpha: parseFloat("" + hslaMatched[4]) > 1 ? parseFloat("" + hslaMatched[4]) / 100 : parseFloat("" + hslaMatched[4])
    };
  }
  throw new PolishedError(5);
}
function rgbToHsl(color) {
  var red = color.red / 255;
  var green = color.green / 255;
  var blue = color.blue / 255;
  var max = Math.max(red, green, blue);
  var min = Math.min(red, green, blue);
  var lightness = (max + min) / 2;
  if (max === min) {
    if (color.alpha !== void 0) {
      return {
        hue: 0,
        saturation: 0,
        lightness,
        alpha: color.alpha
      };
    } else {
      return {
        hue: 0,
        saturation: 0,
        lightness
      };
    }
  }
  var hue;
  var delta = max - min;
  var saturation = lightness > 0.5 ? delta / (2 - max - min) : delta / (max + min);
  switch (max) {
    case red:
      hue = (green - blue) / delta + (green < blue ? 6 : 0);
      break;
    case green:
      hue = (blue - red) / delta + 2;
      break;
    default:
      hue = (red - green) / delta + 4;
      break;
  }
  hue *= 60;
  if (color.alpha !== void 0) {
    return {
      hue,
      saturation,
      lightness,
      alpha: color.alpha
    };
  }
  return {
    hue,
    saturation,
    lightness
  };
}
function parseToHsl(color) {
  return rgbToHsl(parseToRgb(color));
}
var reduceHexValue = function reduceHexValue2(value) {
  if (value.length === 7 && value[1] === value[2] && value[3] === value[4] && value[5] === value[6]) {
    return "#" + value[1] + value[3] + value[5];
  }
  return value;
};
var reduceHexValue$1 = reduceHexValue;
function numberToHex(value) {
  var hex = value.toString(16);
  return hex.length === 1 ? "0" + hex : hex;
}
function colorToHex(color) {
  return numberToHex(Math.round(color * 255));
}
function convertToHex(red, green, blue) {
  return reduceHexValue$1("#" + colorToHex(red) + colorToHex(green) + colorToHex(blue));
}
function hslToHex(hue, saturation, lightness) {
  return hslToRgb(hue, saturation, lightness, convertToHex);
}
function hsl(value, saturation, lightness) {
  if (typeof value === "number" && typeof saturation === "number" && typeof lightness === "number") {
    return hslToHex(value, saturation, lightness);
  } else if (typeof value === "object" && saturation === void 0 && lightness === void 0) {
    return hslToHex(value.hue, value.saturation, value.lightness);
  }
  throw new PolishedError(1);
}
function hsla(value, saturation, lightness, alpha) {
  if (typeof value === "number" && typeof saturation === "number" && typeof lightness === "number" && typeof alpha === "number") {
    return alpha >= 1 ? hslToHex(value, saturation, lightness) : "rgba(" + hslToRgb(value, saturation, lightness) + "," + alpha + ")";
  } else if (typeof value === "object" && saturation === void 0 && lightness === void 0 && alpha === void 0) {
    return value.alpha >= 1 ? hslToHex(value.hue, value.saturation, value.lightness) : "rgba(" + hslToRgb(value.hue, value.saturation, value.lightness) + "," + value.alpha + ")";
  }
  throw new PolishedError(2);
}
function rgb(value, green, blue) {
  if (typeof value === "number" && typeof green === "number" && typeof blue === "number") {
    return reduceHexValue$1("#" + numberToHex(value) + numberToHex(green) + numberToHex(blue));
  } else if (typeof value === "object" && green === void 0 && blue === void 0) {
    return reduceHexValue$1("#" + numberToHex(value.red) + numberToHex(value.green) + numberToHex(value.blue));
  }
  throw new PolishedError(6);
}
function rgba(firstValue, secondValue, thirdValue, fourthValue) {
  if (typeof firstValue === "string" && typeof secondValue === "number") {
    var rgbValue = parseToRgb(firstValue);
    return "rgba(" + rgbValue.red + "," + rgbValue.green + "," + rgbValue.blue + "," + secondValue + ")";
  } else if (typeof firstValue === "number" && typeof secondValue === "number" && typeof thirdValue === "number" && typeof fourthValue === "number") {
    return fourthValue >= 1 ? rgb(firstValue, secondValue, thirdValue) : "rgba(" + firstValue + "," + secondValue + "," + thirdValue + "," + fourthValue + ")";
  } else if (typeof firstValue === "object" && secondValue === void 0 && thirdValue === void 0 && fourthValue === void 0) {
    return firstValue.alpha >= 1 ? rgb(firstValue.red, firstValue.green, firstValue.blue) : "rgba(" + firstValue.red + "," + firstValue.green + "," + firstValue.blue + "," + firstValue.alpha + ")";
  }
  throw new PolishedError(7);
}
var isRgb = function isRgb2(color) {
  return typeof color.red === "number" && typeof color.green === "number" && typeof color.blue === "number" && (typeof color.alpha !== "number" || typeof color.alpha === "undefined");
};
var isRgba = function isRgba2(color) {
  return typeof color.red === "number" && typeof color.green === "number" && typeof color.blue === "number" && typeof color.alpha === "number";
};
var isHsl = function isHsl2(color) {
  return typeof color.hue === "number" && typeof color.saturation === "number" && typeof color.lightness === "number" && (typeof color.alpha !== "number" || typeof color.alpha === "undefined");
};
var isHsla = function isHsla2(color) {
  return typeof color.hue === "number" && typeof color.saturation === "number" && typeof color.lightness === "number" && typeof color.alpha === "number";
};
function toColorString(color) {
  if (typeof color !== "object") throw new PolishedError(8);
  if (isRgba(color)) return rgba(color);
  if (isRgb(color)) return rgb(color);
  if (isHsla(color)) return hsla(color);
  if (isHsl(color)) return hsl(color);
  throw new PolishedError(8);
}
function curried(f, length, acc) {
  return function fn() {
    var combined = acc.concat(Array.prototype.slice.call(arguments));
    return combined.length >= length ? f.apply(this, combined) : curried(f, length, combined);
  };
}
function curry(f) {
  return curried(f, f.length, []);
}
function adjustHue(degree, color) {
  if (color === "transparent") return color;
  var hslColor = parseToHsl(color);
  return toColorString(_extends({}, hslColor, {
    hue: hslColor.hue + parseFloat(degree)
  }));
}
var curriedAdjustHue = curry(adjustHue);
function guard(lowerBoundary, upperBoundary, value) {
  return Math.max(lowerBoundary, Math.min(upperBoundary, value));
}
function darken(amount, color) {
  if (color === "transparent") return color;
  var hslColor = parseToHsl(color);
  return toColorString(_extends({}, hslColor, {
    lightness: guard(0, 1, hslColor.lightness - parseFloat(amount))
  }));
}
var curriedDarken = curry(darken);
function desaturate(amount, color) {
  if (color === "transparent") return color;
  var hslColor = parseToHsl(color);
  return toColorString(_extends({}, hslColor, {
    saturation: guard(0, 1, hslColor.saturation - parseFloat(amount))
  }));
}
var curriedDesaturate = curry(desaturate);
function lighten(amount, color) {
  if (color === "transparent") return color;
  var hslColor = parseToHsl(color);
  return toColorString(_extends({}, hslColor, {
    lightness: guard(0, 1, hslColor.lightness + parseFloat(amount))
  }));
}
var curriedLighten = curry(lighten);
function mix(weight, color, otherColor) {
  if (color === "transparent") return otherColor;
  if (otherColor === "transparent") return color;
  if (weight === 0) return otherColor;
  var parsedColor1 = parseToRgb(color);
  var color1 = _extends({}, parsedColor1, {
    alpha: typeof parsedColor1.alpha === "number" ? parsedColor1.alpha : 1
  });
  var parsedColor2 = parseToRgb(otherColor);
  var color2 = _extends({}, parsedColor2, {
    alpha: typeof parsedColor2.alpha === "number" ? parsedColor2.alpha : 1
  });
  var alphaDelta = color1.alpha - color2.alpha;
  var x = parseFloat(weight) * 2 - 1;
  var y = x * alphaDelta === -1 ? x : x + alphaDelta;
  var z = 1 + x * alphaDelta;
  var weight1 = (y / z + 1) / 2;
  var weight2 = 1 - weight1;
  var mixedColor = {
    red: Math.floor(color1.red * weight1 + color2.red * weight2),
    green: Math.floor(color1.green * weight1 + color2.green * weight2),
    blue: Math.floor(color1.blue * weight1 + color2.blue * weight2),
    alpha: color1.alpha * parseFloat(weight) + color2.alpha * (1 - parseFloat(weight))
  };
  return rgba(mixedColor);
}
var curriedMix = curry(mix);
var mix$1 = curriedMix;
function opacify(amount, color) {
  if (color === "transparent") return color;
  var parsedColor = parseToRgb(color);
  var alpha = typeof parsedColor.alpha === "number" ? parsedColor.alpha : 1;
  var colorWithAlpha = _extends({}, parsedColor, {
    alpha: guard(0, 1, (alpha * 100 + parseFloat(amount) * 100) / 100)
  });
  return rgba(colorWithAlpha);
}
var curriedOpacify = curry(opacify);
function saturate(amount, color) {
  if (color === "transparent") return color;
  var hslColor = parseToHsl(color);
  return toColorString(_extends({}, hslColor, {
    saturation: guard(0, 1, hslColor.saturation + parseFloat(amount))
  }));
}
var curriedSaturate = curry(saturate);
function setHue(hue, color) {
  if (color === "transparent") return color;
  return toColorString(_extends({}, parseToHsl(color), {
    hue: parseFloat(hue)
  }));
}
var curriedSetHue = curry(setHue);
function setLightness(lightness, color) {
  if (color === "transparent") return color;
  return toColorString(_extends({}, parseToHsl(color), {
    lightness: parseFloat(lightness)
  }));
}
var curriedSetLightness = curry(setLightness);
function setSaturation(saturation, color) {
  if (color === "transparent") return color;
  return toColorString(_extends({}, parseToHsl(color), {
    saturation: parseFloat(saturation)
  }));
}
var curriedSetSaturation = curry(setSaturation);
function shade(percentage, color) {
  if (color === "transparent") return color;
  return mix$1(parseFloat(percentage), "rgb(0, 0, 0)", color);
}
var curriedShade = curry(shade);
function tint(percentage, color) {
  if (color === "transparent") return color;
  return mix$1(parseFloat(percentage), "rgb(255, 255, 255)", color);
}
var curriedTint = curry(tint);
function transparentize(amount, color) {
  if (color === "transparent") return color;
  var parsedColor = parseToRgb(color);
  var alpha = typeof parsedColor.alpha === "number" ? parsedColor.alpha : 1;
  var colorWithAlpha = _extends({}, parsedColor, {
    alpha: guard(0, 1, +(alpha * 100 - parseFloat(amount) * 100).toFixed(2) / 100)
  });
  return rgba(colorWithAlpha);
}
var curriedTransparentize = curry(transparentize);
var curriedTransparentize$1 = curriedTransparentize;

// lib/solvers/colors.ts
var COLORS = [
  "blue",
  "orange",
  "purple",
  "cyan",
  "magenta",
  "yellowgreen",
  "darkgoldenrod",
  "deeppink"
];
var getColorMap = (srj, connMap) => {
  const colorMap = {};
  for (let i = 0; i < srj.connections.length; i++) {
    const connection = srj.connections[i];
    const netName = connMap?.getNetConnectedToId(connection.name);
    if (netName && !colorMap[netName]) {
      colorMap[netName] = `hsl(${i * 300 / srj.connections.length}, 100%, 50%)`;
    }
    colorMap[connection.name] = (netName ? colorMap[netName] : null) ?? `hsl(${i * 340 / srj.connections.length}, 100%, 50%)`;
  }
  return colorMap;
};
var safeTransparentize = (color, amount) => {
  try {
    return curriedTransparentize$1(amount, color);
  } catch (e) {
    console.error(e);
    return color;
  }
};

// lib/utils/mapLayerNameToZ.ts
var mapLayerNameToZ = (layerName, layerCount) => {
  if (layerName === "top") return 0;
  if (layerName === "bottom") return layerCount - 1;
  return parseInt(layerName.slice(5));
};

// lib/utils/getTunedTotalCapacity1.ts
var getTunedTotalCapacity1 = (nodeOrWidth, maxCapacityFactor = 1) => {
  const VIA_DIAMETER = 0.6;
  const TRACE_WIDTH = 0.15;
  const obstacleMargin = 0.2;
  const width = "width" in nodeOrWidth ? nodeOrWidth.width : nodeOrWidth;
  const viaLengthAcross = width / (VIA_DIAMETER / 2 + obstacleMargin);
  const tunedTotalCapacity = (viaLengthAcross / 2) ** 1.1 * maxCapacityFactor;
  if (nodeOrWidth.availableZ?.length === 1 && tunedTotalCapacity > 1) {
    return 1;
  }
  return tunedTotalCapacity;
};
var calculateOptimalCapacityDepth = (initialWidth, targetMinCapacity = 0.5, maxDepth = 16) => {
  let depth = 0;
  let width = initialWidth;
  while (depth < maxDepth) {
    const capacity = getTunedTotalCapacity1({ width });
    if (capacity <= targetMinCapacity) {
      break;
    }
    width /= 2;
    depth++;
  }
  return Math.max(1, depth);
};

// node_modules/quickselect/index.js
function quickselect(arr, k, left = 0, right = arr.length - 1, compare = defaultCompare) {
  while (right > left) {
    if (right - left > 600) {
      const n = right - left + 1;
      const m = k - left + 1;
      const z = Math.log(n);
      const s = 0.5 * Math.exp(2 * z / 3);
      const sd = 0.5 * Math.sqrt(z * s * (n - s) / n) * (m - n / 2 < 0 ? -1 : 1);
      const newLeft = Math.max(left, Math.floor(k - m * s / n + sd));
      const newRight = Math.min(right, Math.floor(k + (n - m) * s / n + sd));
      quickselect(arr, k, newLeft, newRight, compare);
    }
    const t = arr[k];
    let i = left;
    let j = right;
    swap(arr, left, k);
    if (compare(arr[right], t) > 0) swap(arr, left, right);
    while (i < j) {
      swap(arr, i, j);
      i++;
      j--;
      while (compare(arr[i], t) < 0) i++;
      while (compare(arr[j], t) > 0) j--;
    }
    if (compare(arr[left], t) === 0) swap(arr, left, j);
    else {
      j++;
      swap(arr, j, right);
    }
    if (j <= k) left = j + 1;
    if (k <= j) right = j - 1;
  }
}
function swap(arr, i, j) {
  const tmp = arr[i];
  arr[i] = arr[j];
  arr[j] = tmp;
}
function defaultCompare(a, b) {
  return a < b ? -1 : a > b ? 1 : 0;
}

// node_modules/rbush/index.js
var RBush = class {
  constructor(maxEntries = 9) {
    this._maxEntries = Math.max(4, maxEntries);
    this._minEntries = Math.max(2, Math.ceil(this._maxEntries * 0.4));
    this.clear();
  }
  all() {
    return this._all(this.data, []);
  }
  search(bbox) {
    let node = this.data;
    const result = [];
    if (!intersects(bbox, node)) return result;
    const toBBox = this.toBBox;
    const nodesToSearch = [];
    while (node) {
      for (let i = 0; i < node.children.length; i++) {
        const child = node.children[i];
        const childBBox = node.leaf ? toBBox(child) : child;
        if (intersects(bbox, childBBox)) {
          if (node.leaf) result.push(child);
          else if (contains(bbox, childBBox)) this._all(child, result);
          else nodesToSearch.push(child);
        }
      }
      node = nodesToSearch.pop();
    }
    return result;
  }
  collides(bbox) {
    let node = this.data;
    if (!intersects(bbox, node)) return false;
    const nodesToSearch = [];
    while (node) {
      for (let i = 0; i < node.children.length; i++) {
        const child = node.children[i];
        const childBBox = node.leaf ? this.toBBox(child) : child;
        if (intersects(bbox, childBBox)) {
          if (node.leaf || contains(bbox, childBBox)) return true;
          nodesToSearch.push(child);
        }
      }
      node = nodesToSearch.pop();
    }
    return false;
  }
  load(data) {
    if (!(data && data.length)) return this;
    if (data.length < this._minEntries) {
      for (let i = 0; i < data.length; i++) {
        this.insert(data[i]);
      }
      return this;
    }
    let node = this._build(data.slice(), 0, data.length - 1, 0);
    if (!this.data.children.length) {
      this.data = node;
    } else if (this.data.height === node.height) {
      this._splitRoot(this.data, node);
    } else {
      if (this.data.height < node.height) {
        const tmpNode = this.data;
        this.data = node;
        node = tmpNode;
      }
      this._insert(node, this.data.height - node.height - 1, true);
    }
    return this;
  }
  insert(item) {
    if (item) this._insert(item, this.data.height - 1);
    return this;
  }
  clear() {
    this.data = createNode([]);
    return this;
  }
  remove(item, equalsFn) {
    if (!item) return this;
    let node = this.data;
    const bbox = this.toBBox(item);
    const path = [];
    const indexes = [];
    let i, parent, goingUp;
    while (node || path.length) {
      if (!node) {
        node = path.pop();
        parent = path[path.length - 1];
        i = indexes.pop();
        goingUp = true;
      }
      if (node.leaf) {
        const index = findItem(item, node.children, equalsFn);
        if (index !== -1) {
          node.children.splice(index, 1);
          path.push(node);
          this._condense(path);
          return this;
        }
      }
      if (!goingUp && !node.leaf && contains(node, bbox)) {
        path.push(node);
        indexes.push(i);
        i = 0;
        parent = node;
        node = node.children[0];
      } else if (parent) {
        i++;
        node = parent.children[i];
        goingUp = false;
      } else node = null;
    }
    return this;
  }
  toBBox(item) {
    return item;
  }
  compareMinX(a, b) {
    return a.minX - b.minX;
  }
  compareMinY(a, b) {
    return a.minY - b.minY;
  }
  toJSON() {
    return this.data;
  }
  fromJSON(data) {
    this.data = data;
    return this;
  }
  _all(node, result) {
    const nodesToSearch = [];
    while (node) {
      if (node.leaf) result.push(...node.children);
      else nodesToSearch.push(...node.children);
      node = nodesToSearch.pop();
    }
    return result;
  }
  _build(items, left, right, height) {
    const N = right - left + 1;
    let M = this._maxEntries;
    let node;
    if (N <= M) {
      node = createNode(items.slice(left, right + 1));
      calcBBox(node, this.toBBox);
      return node;
    }
    if (!height) {
      height = Math.ceil(Math.log(N) / Math.log(M));
      M = Math.ceil(N / Math.pow(M, height - 1));
    }
    node = createNode([]);
    node.leaf = false;
    node.height = height;
    const N2 = Math.ceil(N / M);
    const N1 = N2 * Math.ceil(Math.sqrt(M));
    multiSelect(items, left, right, N1, this.compareMinX);
    for (let i = left; i <= right; i += N1) {
      const right2 = Math.min(i + N1 - 1, right);
      multiSelect(items, i, right2, N2, this.compareMinY);
      for (let j = i; j <= right2; j += N2) {
        const right3 = Math.min(j + N2 - 1, right2);
        node.children.push(this._build(items, j, right3, height - 1));
      }
    }
    calcBBox(node, this.toBBox);
    return node;
  }
  _chooseSubtree(bbox, node, level, path) {
    while (true) {
      path.push(node);
      if (node.leaf || path.length - 1 === level) break;
      let minArea = Infinity;
      let minEnlargement = Infinity;
      let targetNode;
      for (let i = 0; i < node.children.length; i++) {
        const child = node.children[i];
        const area = bboxArea(child);
        const enlargement = enlargedArea(bbox, child) - area;
        if (enlargement < minEnlargement) {
          minEnlargement = enlargement;
          minArea = area < minArea ? area : minArea;
          targetNode = child;
        } else if (enlargement === minEnlargement) {
          if (area < minArea) {
            minArea = area;
            targetNode = child;
          }
        }
      }
      node = targetNode || node.children[0];
    }
    return node;
  }
  _insert(item, level, isNode) {
    const bbox = isNode ? item : this.toBBox(item);
    const insertPath = [];
    const node = this._chooseSubtree(bbox, this.data, level, insertPath);
    node.children.push(item);
    extend(node, bbox);
    while (level >= 0) {
      if (insertPath[level].children.length > this._maxEntries) {
        this._split(insertPath, level);
        level--;
      } else break;
    }
    this._adjustParentBBoxes(bbox, insertPath, level);
  }
  // split overflowed node into two
  _split(insertPath, level) {
    const node = insertPath[level];
    const M = node.children.length;
    const m = this._minEntries;
    this._chooseSplitAxis(node, m, M);
    const splitIndex = this._chooseSplitIndex(node, m, M);
    const newNode = createNode(node.children.splice(splitIndex, node.children.length - splitIndex));
    newNode.height = node.height;
    newNode.leaf = node.leaf;
    calcBBox(node, this.toBBox);
    calcBBox(newNode, this.toBBox);
    if (level) insertPath[level - 1].children.push(newNode);
    else this._splitRoot(node, newNode);
  }
  _splitRoot(node, newNode) {
    this.data = createNode([node, newNode]);
    this.data.height = node.height + 1;
    this.data.leaf = false;
    calcBBox(this.data, this.toBBox);
  }
  _chooseSplitIndex(node, m, M) {
    let index;
    let minOverlap = Infinity;
    let minArea = Infinity;
    for (let i = m; i <= M - m; i++) {
      const bbox1 = distBBox(node, 0, i, this.toBBox);
      const bbox2 = distBBox(node, i, M, this.toBBox);
      const overlap = intersectionArea(bbox1, bbox2);
      const area = bboxArea(bbox1) + bboxArea(bbox2);
      if (overlap < minOverlap) {
        minOverlap = overlap;
        index = i;
        minArea = area < minArea ? area : minArea;
      } else if (overlap === minOverlap) {
        if (area < minArea) {
          minArea = area;
          index = i;
        }
      }
    }
    return index || M - m;
  }
  // sorts node children by the best axis for split
  _chooseSplitAxis(node, m, M) {
    const compareMinX = node.leaf ? this.compareMinX : compareNodeMinX;
    const compareMinY = node.leaf ? this.compareMinY : compareNodeMinY;
    const xMargin = this._allDistMargin(node, m, M, compareMinX);
    const yMargin = this._allDistMargin(node, m, M, compareMinY);
    if (xMargin < yMargin) node.children.sort(compareMinX);
  }
  // total margin of all possible split distributions where each node is at least m full
  _allDistMargin(node, m, M, compare) {
    node.children.sort(compare);
    const toBBox = this.toBBox;
    const leftBBox = distBBox(node, 0, m, toBBox);
    const rightBBox = distBBox(node, M - m, M, toBBox);
    let margin = bboxMargin(leftBBox) + bboxMargin(rightBBox);
    for (let i = m; i < M - m; i++) {
      const child = node.children[i];
      extend(leftBBox, node.leaf ? toBBox(child) : child);
      margin += bboxMargin(leftBBox);
    }
    for (let i = M - m - 1; i >= m; i--) {
      const child = node.children[i];
      extend(rightBBox, node.leaf ? toBBox(child) : child);
      margin += bboxMargin(rightBBox);
    }
    return margin;
  }
  _adjustParentBBoxes(bbox, path, level) {
    for (let i = level; i >= 0; i--) {
      extend(path[i], bbox);
    }
  }
  _condense(path) {
    for (let i = path.length - 1, siblings; i >= 0; i--) {
      if (path[i].children.length === 0) {
        if (i > 0) {
          siblings = path[i - 1].children;
          siblings.splice(siblings.indexOf(path[i]), 1);
        } else this.clear();
      } else calcBBox(path[i], this.toBBox);
    }
  }
};
function findItem(item, items, equalsFn) {
  if (!equalsFn) return items.indexOf(item);
  for (let i = 0; i < items.length; i++) {
    if (equalsFn(item, items[i])) return i;
  }
  return -1;
}
function calcBBox(node, toBBox) {
  distBBox(node, 0, node.children.length, toBBox, node);
}
function distBBox(node, k, p, toBBox, destNode) {
  if (!destNode) destNode = createNode(null);
  destNode.minX = Infinity;
  destNode.minY = Infinity;
  destNode.maxX = -Infinity;
  destNode.maxY = -Infinity;
  for (let i = k; i < p; i++) {
    const child = node.children[i];
    extend(destNode, node.leaf ? toBBox(child) : child);
  }
  return destNode;
}
function extend(a, b) {
  a.minX = Math.min(a.minX, b.minX);
  a.minY = Math.min(a.minY, b.minY);
  a.maxX = Math.max(a.maxX, b.maxX);
  a.maxY = Math.max(a.maxY, b.maxY);
  return a;
}
function compareNodeMinX(a, b) {
  return a.minX - b.minX;
}
function compareNodeMinY(a, b) {
  return a.minY - b.minY;
}
function bboxArea(a) {
  return (a.maxX - a.minX) * (a.maxY - a.minY);
}
function bboxMargin(a) {
  return a.maxX - a.minX + (a.maxY - a.minY);
}
function enlargedArea(a, b) {
  return (Math.max(b.maxX, a.maxX) - Math.min(b.minX, a.minX)) * (Math.max(b.maxY, a.maxY) - Math.min(b.minY, a.minY));
}
function intersectionArea(a, b) {
  const minX = Math.max(a.minX, b.minX);
  const minY = Math.max(a.minY, b.minY);
  const maxX = Math.min(a.maxX, b.maxX);
  const maxY = Math.min(a.maxY, b.maxY);
  return Math.max(0, maxX - minX) * Math.max(0, maxY - minY);
}
function contains(a, b) {
  return a.minX <= b.minX && a.minY <= b.minY && b.maxX <= a.maxX && b.maxY <= a.maxY;
}
function intersects(a, b) {
  return b.minX <= a.maxX && b.minY <= a.maxY && b.maxX >= a.minX && b.maxY >= a.minY;
}
function createNode(children) {
  return {
    children,
    height: 1,
    leaf: true,
    minX: Infinity,
    minY: Infinity,
    maxX: -Infinity,
    maxY: -Infinity
  };
}
function multiSelect(arr, left, right, n, compare) {
  const stack = [left, right];
  while (stack.length) {
    right = stack.pop();
    left = stack.pop();
    if (right - left <= n) continue;
    const mid = left + Math.ceil((right - left) / n / 2) * n;
    quickselect(arr, mid, left, right, compare);
    stack.push(left, mid, mid, right);
  }
}

// lib/data-structures/RbushIndex.ts
var RbushIndex = class {
  tree;
  constructor(maxEntries = 9) {
    this.tree = new RBush(maxEntries);
  }
  insert(item, minX, minY, maxX, maxY) {
    this.tree.insert({ minX, minY, maxX, maxY, data: item });
  }
  bulkLoad(items) {
    const nodes = items.map(({ item, minX, minY, maxX, maxY }) => ({
      minX,
      minY,
      maxX,
      maxY,
      data: item
    }));
    this.tree.load(nodes);
  }
  search(minX, minY, maxX, maxY) {
    return this.tree.search({ minX, minY, maxX, maxY }).map((n) => n.data);
  }
  clear() {
    this.tree.clear();
  }
};

// node_modules/flatqueue/index.js
var FlatQueue = class {
  constructor() {
    this.ids = [];
    this.values = [];
    this.length = 0;
  }
  clear() {
    this.length = 0;
  }
  push(id, value) {
    let pos = this.length++;
    while (pos > 0) {
      const parent = pos - 1 >> 1;
      const parentValue = this.values[parent];
      if (value >= parentValue) break;
      this.ids[pos] = this.ids[parent];
      this.values[pos] = parentValue;
      pos = parent;
    }
    this.ids[pos] = id;
    this.values[pos] = value;
  }
  pop() {
    if (this.length === 0) return void 0;
    const top = this.ids[0];
    this.length--;
    if (this.length > 0) {
      const id = this.ids[0] = this.ids[this.length];
      const value = this.values[0] = this.values[this.length];
      const halfLength = this.length >> 1;
      let pos = 0;
      while (pos < halfLength) {
        let left = (pos << 1) + 1;
        const right = left + 1;
        let bestIndex = this.ids[left];
        let bestValue = this.values[left];
        const rightValue = this.values[right];
        if (right < this.length && rightValue < bestValue) {
          left = right;
          bestIndex = this.ids[right];
          bestValue = rightValue;
        }
        if (bestValue >= value) break;
        this.ids[pos] = bestIndex;
        this.values[pos] = bestValue;
        pos = left;
      }
      this.ids[pos] = id;
      this.values[pos] = value;
    }
    return top;
  }
  peek() {
    if (this.length === 0) return void 0;
    return this.ids[0];
  }
  peekValue() {
    if (this.length === 0) return void 0;
    return this.values[0];
  }
  shrink() {
    this.ids.length = this.values.length = this.length;
  }
};

// node_modules/flatbush/index.js
var ARRAY_TYPES = [Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array];
var VERSION = 3;
var Flatbush = class _Flatbush {
  /**
   * Recreate a Flatbush index from raw `ArrayBuffer` or `SharedArrayBuffer` data.
   * @param {ArrayBuffer | SharedArrayBuffer} data
   * @param {number} [byteOffset=0] byte offset to the start of the Flatbush buffer in the referenced ArrayBuffer.
   * @returns {Flatbush} index
   */
  static from(data, byteOffset = 0) {
    if (byteOffset % 8 !== 0) {
      throw new Error("byteOffset must be 8-byte aligned.");
    }
    if (!data || data.byteLength === void 0 || data.buffer) {
      throw new Error("Data must be an instance of ArrayBuffer or SharedArrayBuffer.");
    }
    const [magic, versionAndType] = new Uint8Array(data, byteOffset + 0, 2);
    if (magic !== 251) {
      throw new Error("Data does not appear to be in a Flatbush format.");
    }
    const version = versionAndType >> 4;
    if (version !== VERSION) {
      throw new Error(`Got v${version} data when expected v${VERSION}.`);
    }
    const ArrayType = ARRAY_TYPES[versionAndType & 15];
    if (!ArrayType) {
      throw new Error("Unrecognized array type.");
    }
    const [nodeSize] = new Uint16Array(data, byteOffset + 2, 1);
    const [numItems] = new Uint32Array(data, byteOffset + 4, 1);
    return new _Flatbush(numItems, nodeSize, ArrayType, void 0, data, byteOffset);
  }
  /**
   * Create a Flatbush index that will hold a given number of items.
   * @param {number} numItems
   * @param {number} [nodeSize=16] Size of the tree node (16 by default).
   * @param {TypedArrayConstructor} [ArrayType=Float64Array] The array type used for coordinates storage (`Float64Array` by default).
   * @param {ArrayBufferConstructor | SharedArrayBufferConstructor} [ArrayBufferType=ArrayBuffer] The array buffer type used to store data (`ArrayBuffer` by default).
   * @param {ArrayBuffer | SharedArrayBuffer} [data] (Only used internally)
   * @param {number} [byteOffset=0] (Only used internally)
   */
  constructor(numItems, nodeSize = 16, ArrayType = Float64Array, ArrayBufferType = ArrayBuffer, data, byteOffset = 0) {
    if (numItems === void 0) throw new Error("Missing required argument: numItems.");
    if (isNaN(numItems) || numItems <= 0) throw new Error(`Unexpected numItems value: ${numItems}.`);
    this.numItems = +numItems;
    this.nodeSize = Math.min(Math.max(+nodeSize, 2), 65535);
    this.byteOffset = byteOffset;
    let n = numItems;
    let numNodes = n;
    this._levelBounds = [n * 4];
    do {
      n = Math.ceil(n / this.nodeSize);
      numNodes += n;
      this._levelBounds.push(numNodes * 4);
    } while (n !== 1);
    this.ArrayType = ArrayType;
    this.IndexArrayType = numNodes < 16384 ? Uint16Array : Uint32Array;
    const arrayTypeIndex = ARRAY_TYPES.indexOf(this.ArrayType);
    const nodesByteSize = numNodes * 4 * this.ArrayType.BYTES_PER_ELEMENT;
    if (arrayTypeIndex < 0) {
      throw new Error(`Unexpected typed array class: ${ArrayType}.`);
    }
    if (data && data.byteLength !== void 0 && !data.buffer) {
      this.data = data;
      this._boxes = new this.ArrayType(this.data, byteOffset + 8, numNodes * 4);
      this._indices = new this.IndexArrayType(this.data, byteOffset + 8 + nodesByteSize, numNodes);
      this._pos = numNodes * 4;
      this.minX = this._boxes[this._pos - 4];
      this.minY = this._boxes[this._pos - 3];
      this.maxX = this._boxes[this._pos - 2];
      this.maxY = this._boxes[this._pos - 1];
    } else {
      this.data = new ArrayBufferType(8 + nodesByteSize + numNodes * this.IndexArrayType.BYTES_PER_ELEMENT);
      this._boxes = new this.ArrayType(this.data, 8, numNodes * 4);
      this._indices = new this.IndexArrayType(this.data, 8 + nodesByteSize, numNodes);
      this._pos = 0;
      this.minX = Infinity;
      this.minY = Infinity;
      this.maxX = -Infinity;
      this.maxY = -Infinity;
      new Uint8Array(this.data, 0, 2).set([251, (VERSION << 4) + arrayTypeIndex]);
      new Uint16Array(this.data, 2, 1)[0] = nodeSize;
      new Uint32Array(this.data, 4, 1)[0] = numItems;
    }
    this._queue = new FlatQueue();
  }
  /**
   * Add a given rectangle to the index.
   * @param {number} minX
   * @param {number} minY
   * @param {number} maxX
   * @param {number} maxY
   * @returns {number} A zero-based, incremental number that represents the newly added rectangle.
   */
  add(minX, minY, maxX = minX, maxY = minY) {
    const index = this._pos >> 2;
    const boxes = this._boxes;
    this._indices[index] = index;
    boxes[this._pos++] = minX;
    boxes[this._pos++] = minY;
    boxes[this._pos++] = maxX;
    boxes[this._pos++] = maxY;
    if (minX < this.minX) this.minX = minX;
    if (minY < this.minY) this.minY = minY;
    if (maxX > this.maxX) this.maxX = maxX;
    if (maxY > this.maxY) this.maxY = maxY;
    return index;
  }
  /** Perform indexing of the added rectangles. */
  finish() {
    if (this._pos >> 2 !== this.numItems) {
      throw new Error(`Added ${this._pos >> 2} items when expected ${this.numItems}.`);
    }
    const boxes = this._boxes;
    if (this.numItems <= this.nodeSize) {
      boxes[this._pos++] = this.minX;
      boxes[this._pos++] = this.minY;
      boxes[this._pos++] = this.maxX;
      boxes[this._pos++] = this.maxY;
      return;
    }
    const width = this.maxX - this.minX || 1;
    const height = this.maxY - this.minY || 1;
    const hilbertValues = new Uint32Array(this.numItems);
    const hilbertMax = (1 << 16) - 1;
    for (let i = 0, pos = 0; i < this.numItems; i++) {
      const minX = boxes[pos++];
      const minY = boxes[pos++];
      const maxX = boxes[pos++];
      const maxY = boxes[pos++];
      const x = Math.floor(hilbertMax * ((minX + maxX) / 2 - this.minX) / width);
      const y = Math.floor(hilbertMax * ((minY + maxY) / 2 - this.minY) / height);
      hilbertValues[i] = hilbert(x, y);
    }
    sort(hilbertValues, boxes, this._indices, 0, this.numItems - 1, this.nodeSize);
    for (let i = 0, pos = 0; i < this._levelBounds.length - 1; i++) {
      const end = this._levelBounds[i];
      while (pos < end) {
        const nodeIndex = pos;
        let nodeMinX = boxes[pos++];
        let nodeMinY = boxes[pos++];
        let nodeMaxX = boxes[pos++];
        let nodeMaxY = boxes[pos++];
        for (let j = 1; j < this.nodeSize && pos < end; j++) {
          nodeMinX = Math.min(nodeMinX, boxes[pos++]);
          nodeMinY = Math.min(nodeMinY, boxes[pos++]);
          nodeMaxX = Math.max(nodeMaxX, boxes[pos++]);
          nodeMaxY = Math.max(nodeMaxY, boxes[pos++]);
        }
        this._indices[this._pos >> 2] = nodeIndex;
        boxes[this._pos++] = nodeMinX;
        boxes[this._pos++] = nodeMinY;
        boxes[this._pos++] = nodeMaxX;
        boxes[this._pos++] = nodeMaxY;
      }
    }
  }
  /**
   * Search the index by a bounding box.
   * @param {number} minX
   * @param {number} minY
   * @param {number} maxX
   * @param {number} maxY
   * @param {(index: number) => boolean} [filterFn] An optional function for filtering the results.
   * @returns {number[]} An array of indices of items intersecting or touching the given bounding box.
   */
  search(minX, minY, maxX, maxY, filterFn) {
    if (this._pos !== this._boxes.length) {
      throw new Error("Data not yet indexed - call index.finish().");
    }
    let nodeIndex = this._boxes.length - 4;
    const queue = [];
    const results = [];
    while (nodeIndex !== void 0) {
      const end = Math.min(nodeIndex + this.nodeSize * 4, upperBound(nodeIndex, this._levelBounds));
      for (let pos = nodeIndex; pos < end; pos += 4) {
        if (maxX < this._boxes[pos]) continue;
        if (maxY < this._boxes[pos + 1]) continue;
        if (minX > this._boxes[pos + 2]) continue;
        if (minY > this._boxes[pos + 3]) continue;
        const index = this._indices[pos >> 2] | 0;
        if (nodeIndex >= this.numItems * 4) {
          queue.push(index);
        } else if (filterFn === void 0 || filterFn(index)) {
          results.push(index);
        }
      }
      nodeIndex = queue.pop();
    }
    return results;
  }
  /**
   * Search items in order of distance from the given point.
   * @param {number} x
   * @param {number} y
   * @param {number} [maxResults=Infinity]
   * @param {number} [maxDistance=Infinity]
   * @param {(index: number) => boolean} [filterFn] An optional function for filtering the results.
   * @returns {number[]} An array of indices of items found.
   */
  neighbors(x, y, maxResults = Infinity, maxDistance = Infinity, filterFn) {
    if (this._pos !== this._boxes.length) {
      throw new Error("Data not yet indexed - call index.finish().");
    }
    let nodeIndex = this._boxes.length - 4;
    const q = this._queue;
    const results = [];
    const maxDistSquared = maxDistance * maxDistance;
    outer: while (nodeIndex !== void 0) {
      const end = Math.min(nodeIndex + this.nodeSize * 4, upperBound(nodeIndex, this._levelBounds));
      for (let pos = nodeIndex; pos < end; pos += 4) {
        const index = this._indices[pos >> 2] | 0;
        const dx = axisDist(x, this._boxes[pos], this._boxes[pos + 2]);
        const dy = axisDist(y, this._boxes[pos + 1], this._boxes[pos + 3]);
        const dist = dx * dx + dy * dy;
        if (dist > maxDistSquared) continue;
        if (nodeIndex >= this.numItems * 4) {
          q.push(index << 1, dist);
        } else if (filterFn === void 0 || filterFn(index)) {
          q.push((index << 1) + 1, dist);
        }
      }
      while (q.length && q.peek() & 1) {
        const dist = q.peekValue();
        if (dist > maxDistSquared) break outer;
        results.push(q.pop() >> 1);
        if (results.length === maxResults) break outer;
      }
      nodeIndex = q.length ? q.pop() >> 1 : void 0;
    }
    q.clear();
    return results;
  }
};
function axisDist(k, min, max) {
  return k < min ? min - k : k <= max ? 0 : k - max;
}
function upperBound(value, arr) {
  let i = 0;
  let j = arr.length - 1;
  while (i < j) {
    const m = i + j >> 1;
    if (arr[m] > value) {
      j = m;
    } else {
      i = m + 1;
    }
  }
  return arr[i];
}
function sort(values, boxes, indices, left, right, nodeSize) {
  if (Math.floor(left / nodeSize) >= Math.floor(right / nodeSize)) return;
  const pivot = values[left + right >> 1];
  let i = left - 1;
  let j = right + 1;
  while (true) {
    do
      i++;
    while (values[i] < pivot);
    do
      j--;
    while (values[j] > pivot);
    if (i >= j) break;
    swap2(values, boxes, indices, i, j);
  }
  sort(values, boxes, indices, left, j, nodeSize);
  sort(values, boxes, indices, j + 1, right, nodeSize);
}
function swap2(values, boxes, indices, i, j) {
  const temp = values[i];
  values[i] = values[j];
  values[j] = temp;
  const k = 4 * i;
  const m = 4 * j;
  const a = boxes[k];
  const b = boxes[k + 1];
  const c = boxes[k + 2];
  const d = boxes[k + 3];
  boxes[k] = boxes[m];
  boxes[k + 1] = boxes[m + 1];
  boxes[k + 2] = boxes[m + 2];
  boxes[k + 3] = boxes[m + 3];
  boxes[m] = a;
  boxes[m + 1] = b;
  boxes[m + 2] = c;
  boxes[m + 3] = d;
  const e = indices[i];
  indices[i] = indices[j];
  indices[j] = e;
}
function hilbert(x, y) {
  let a = x ^ y;
  let b = 65535 ^ a;
  let c = 65535 ^ (x | y);
  let d = x & (y ^ 65535);
  let A = a | b >> 1;
  let B = a >> 1 ^ a;
  let C = c >> 1 ^ b & d >> 1 ^ c;
  let D = a & c >> 1 ^ d >> 1 ^ d;
  a = A;
  b = B;
  c = C;
  d = D;
  A = a & a >> 2 ^ b & b >> 2;
  B = a & b >> 2 ^ b & (a ^ b) >> 2;
  C ^= a & c >> 2 ^ b & d >> 2;
  D ^= b & c >> 2 ^ (a ^ b) & d >> 2;
  a = A;
  b = B;
  c = C;
  d = D;
  A = a & a >> 4 ^ b & b >> 4;
  B = a & b >> 4 ^ b & (a ^ b) >> 4;
  C ^= a & c >> 4 ^ b & d >> 4;
  D ^= b & c >> 4 ^ (a ^ b) & d >> 4;
  a = A;
  b = B;
  c = C;
  d = D;
  C ^= a & c >> 8 ^ b & d >> 8;
  D ^= b & c >> 8 ^ (a ^ b) & d >> 8;
  a = C ^ C >> 1;
  b = D ^ D >> 1;
  let i0 = x ^ y;
  let i1 = b | 65535 ^ (i0 | a);
  i0 = (i0 | i0 << 8) & 16711935;
  i0 = (i0 | i0 << 4) & 252645135;
  i0 = (i0 | i0 << 2) & 858993459;
  i0 = (i0 | i0 << 1) & 1431655765;
  i1 = (i1 | i1 << 8) & 16711935;
  i1 = (i1 | i1 << 4) & 252645135;
  i1 = (i1 | i1 << 2) & 858993459;
  i1 = (i1 | i1 << 1) & 1431655765;
  return (i1 << 1 | i0) >>> 0;
}

// lib/data-structures/FlatbushIndex.ts
var FlatbushIndex = class {
  index;
  items = [];
  currentIndex = 0;
  constructor(numItems) {
    this.index = new Flatbush(numItems);
  }
  insert(item, minX, minY, maxX, maxY) {
    if (this.currentIndex >= this.index.numItems) {
      throw new Error("Exceeded initial capacity");
    }
    this.items[this.currentIndex] = item;
    this.index.add(minX, minY, maxX, maxY);
    this.currentIndex++;
  }
  finish() {
    this.index.finish();
  }
  search(minX, minY, maxX, maxY) {
    const ids = this.index.search(minX, minY, maxX, maxY);
    return ids.map((id) => this.items[id] || null).filter(Boolean);
  }
  clear() {
    this.items = [];
    this.index = new Flatbush(0);
  }
};

// lib/data-structures/ObstacleTree.ts
var ObstacleSpatialHashIndex = class {
  idx;
  storage = [];
  constructor(implementation = "native", obstacles = []) {
    if (implementation === "flatbush") {
      this.idx = new FlatbushIndex(obstacles.length);
    } else if (implementation === "rbush") {
      this.idx = new RbushIndex();
    } else {
      this.idx = new class {
        shi = new NativeObstacleTree(obstacles);
        insert(item) {
        }
        search(minX, minY, maxX, maxY) {
          const centerX = (minX + maxX) / 2;
          const centerY = (minY + maxY) / 2;
          const width = maxX - minX;
          const height = maxY - minY;
          return this.shi.getNodesInArea(centerX, centerY, width, height);
        }
        clear() {
        }
      }();
    }
    obstacles.forEach((o) => this.insert(o));
    if (implementation === "flatbush") this.idx.finish?.();
  }
  insert(o) {
    this.storage.push(o);
    this.idx.insert(
      o,
      o.center.x - o.width / 2,
      o.center.y - o.height / 2,
      o.center.x + o.width / 2,
      o.center.y + o.height / 2
    );
  }
  search(bbox) {
    return this.idx.search(bbox.minX, bbox.minY, bbox.maxX, bbox.maxY);
  }
  searchArea(centerX, centerY, width, height) {
    return this.search({
      minX: centerX - width / 2,
      minY: centerY - height / 2,
      maxX: centerX + width / 2,
      maxY: centerY + height / 2
    });
  }
};
var NativeObstacleTree = class {
  constructor(obstacles) {
    this.obstacles = obstacles;
    this.buckets = /* @__PURE__ */ new Map();
    let bucketEntriesCount = 0;
    for (let i = 0; i < obstacles.length; i++) {
      const obstacle = obstacles[i];
      const nodeMinX = obstacle.center.x - obstacle.width / 2;
      const nodeMinY = obstacle.center.y - obstacle.height / 2;
      const nodeMaxX = obstacle.center.x + obstacle.width / 2;
      const nodeMaxY = obstacle.center.y + obstacle.height / 2;
      for (let x = nodeMinX; x <= nodeMaxX; x += this.CELL_SIZE) {
        for (let y = nodeMinY; y <= nodeMaxY; y += this.CELL_SIZE) {
          const bucketKey = this.getBucketKey(x, y);
          const bucket = this.buckets.get(bucketKey);
          if (!bucket) {
            this.buckets.set(bucketKey, [[obstacle, i]]);
          } else {
            bucket.push([obstacle, i]);
            bucketEntriesCount++;
          }
        }
      }
    }
  }
  buckets;
  CELL_SIZE = 0.4;
  getBucketKey(x, y) {
    return `${Math.floor(x / this.CELL_SIZE)}x${Math.floor(y / this.CELL_SIZE)}`;
  }
  getNodesInArea(centerX, centerY, width, height) {
    const obstacles = [];
    const alreadyAddedObstacles = /* @__PURE__ */ new Set();
    const minX = centerX - width / 2;
    const minY = centerY - height / 2;
    const maxX = centerX + width / 2;
    const maxY = centerY + height / 2;
    for (let x = minX; x <= maxX; x += this.CELL_SIZE) {
      for (let y = minY; y <= maxY; y += this.CELL_SIZE) {
        const bucketKey = this.getBucketKey(x, y);
        const bucket = this.buckets.get(bucketKey) || [];
        for (const obstacleWithIndex of bucket) {
          if (alreadyAddedObstacles.has(obstacleWithIndex[1])) continue;
          alreadyAddedObstacles.add(obstacleWithIndex[1]);
          obstacles.push(obstacleWithIndex[0]);
        }
      }
    }
    return obstacles;
  }
};

// lib/data-structures/TargetTree.ts
var TargetTree = class {
  constructor(targets) {
    this.targets = targets;
    this.buckets = /* @__PURE__ */ new Map();
    for (let i = 0; i < targets.length; i++) {
      const target = targets[i];
      const targetBucketMinX = Math.floor(target.bounds.minX / this.CELL_SIZE) * this.CELL_SIZE;
      const targetBucketMinY = Math.floor(target.bounds.minY / this.CELL_SIZE) * this.CELL_SIZE;
      const targetMaxX = target.bounds.maxX;
      const targetMaxY = target.bounds.maxY;
      for (let x = targetBucketMinX; x <= targetMaxX; x += this.CELL_SIZE) {
        for (let y = targetBucketMinY; y <= targetMaxY; y += this.CELL_SIZE) {
          const bucketKey = this.getBucketKey(x, y);
          const bucket = this.buckets.get(bucketKey);
          if (!bucket) {
            this.buckets.set(bucketKey, [[target, i]]);
          } else {
            bucket.push([target, i]);
          }
        }
      }
    }
  }
  buckets;
  CELL_SIZE = 5;
  getBucketKey(x, y) {
    return `${Math.floor(x / this.CELL_SIZE)}x${Math.floor(y / this.CELL_SIZE)}`;
  }
  getTargetsInArea(centerX, centerY, width, height) {
    const targets = [];
    const alreadyAddedTargets = /* @__PURE__ */ new Set();
    const minX = Math.floor((centerX - width / 2) / this.CELL_SIZE) * this.CELL_SIZE;
    const minY = Math.floor((centerY - height / 2) / this.CELL_SIZE) * this.CELL_SIZE;
    const maxX = centerX + width / 2;
    const maxY = centerY + height / 2;
    for (let x = minX; x <= maxX; x += this.CELL_SIZE) {
      for (let y = minY; y <= maxY; y += this.CELL_SIZE) {
        const bucketKey = this.getBucketKey(x, y);
        const bucket = this.buckets.get(bucketKey) || [];
        for (const targetWithIndex of bucket) {
          if (alreadyAddedTargets.has(targetWithIndex[1])) continue;
          alreadyAddedTargets.add(targetWithIndex[1]);
          targets.push(targetWithIndex[0]);
        }
      }
    }
    return targets;
  }
};

// lib/solvers/CapacityMeshSolver/CapacityMeshNodeSolver1.ts
var CapacityMeshNodeSolver = class extends BaseSolver {
  constructor(srj, opts = {}) {
    super();
    this.srj = srj;
    this.opts = opts;
    this.MAX_DEPTH = opts?.capacityDepth ?? this.MAX_DEPTH;
    this.MAX_ITERATIONS = 1e5;
    this.layerCount = srj.layerCount ?? 2;
    for (const obstacle of srj.obstacles) {
      if (!obstacle.zLayers) {
        const zLayers = [];
        for (const layer of obstacle.layers) {
          zLayers.push(mapLayerNameToZ(layer, srj.layerCount));
        }
        obstacle.zLayers = zLayers;
      }
    }
    const boundsCenter = {
      x: (srj.bounds.minX + srj.bounds.maxX) / 2,
      y: (srj.bounds.minY + srj.bounds.maxY) / 2
    };
    const boundsSize = {
      width: srj.bounds.maxX - srj.bounds.minX,
      height: srj.bounds.maxY - srj.bounds.minY
    };
    const maxWidthHeight = Math.max(boundsSize.width, boundsSize.height);
    this.unfinishedNodes = [
      {
        capacityMeshNodeId: this.getNextNodeId(),
        center: boundsCenter,
        width: maxWidthHeight,
        height: maxWidthHeight,
        layer: "top",
        availableZ: [0, 1],
        _depth: 0,
        _containsTarget: true,
        _containsObstacle: true,
        _completelyInsideObstacle: false
      }
    ];
    this.finishedNodes = [];
    this.nodeToXYOverlappingObstaclesMap = /* @__PURE__ */ new Map();
    this.obstacleTree = new ObstacleSpatialHashIndex(
      "flatbush",
      this.srj.obstacles
    );
    this.targets = this.computeTargets();
    this.targetTree = new TargetTree(this.targets);
  }
  unfinishedNodes;
  finishedNodes;
  nodeToXYOverlappingObstaclesMap;
  layerCount;
  // targetObstacleMap: Record<string, { obstacle: Obstacle, node: CapacityMeshNode }>
  MAX_DEPTH = 4;
  targets;
  targetTree;
  obstacleTree;
  computeTargets() {
    const targets = [];
    for (const conn of this.srj.connections) {
      for (const ptc of conn.pointsToConnect) {
        const obstacles = this.obstacleTree.searchArea(ptc.x, ptc.y, 0.01, 0.01).filter(
          (o) => o.zLayers.some((z) => ptc.layer === "top" ? z === 0 : z === 1)
        );
        let bounds = {
          minX: ptc.x - 5e-3,
          minY: ptc.y - 5e-3,
          maxX: ptc.x + 5e-3,
          maxY: ptc.y + 5e-3
        };
        if (obstacles.length > 0) {
          bounds = {
            minX: Math.min(...obstacles.map((o) => o.center.x - o.width / 2)),
            minY: Math.min(...obstacles.map((o) => o.center.y - o.height / 2)),
            maxX: Math.max(...obstacles.map((o) => o.center.x + o.width / 2)),
            maxY: Math.max(...obstacles.map((o) => o.center.y + o.height / 2))
          };
        }
        const target = {
          ...ptc,
          connectionName: conn.name,
          availableZ: ptc.layer === "top" ? [0] : [1],
          bounds
        };
        targets.push(target);
      }
    }
    return targets;
  }
  _nextNodeCounter = 0;
  getNextNodeId() {
    return `cn${this._nextNodeCounter++}`;
  }
  getCapacityFromDepth(depth) {
    return (this.MAX_DEPTH - depth + 1) ** 2;
  }
  getTargetIfNodeContainsTarget(node) {
    const nearbyTargets = node.width > this.targetTree.CELL_SIZE * 4 ? this.targets : this.targetTree.getTargetsInArea(
      node.center.x,
      node.center.y,
      node.width,
      node.height
    );
    for (const target of nearbyTargets) {
      if (
        // Check if the node and target bounds overlap
        target.bounds.minX <= node.center.x + node.width / 2 && target.bounds.maxX >= node.center.x - node.width / 2 && target.bounds.minY <= node.center.y + node.height / 2 && target.bounds.maxY >= node.center.y - node.height / 2 && target.availableZ.some((z) => node.availableZ.includes(z))
      ) {
        return target;
      }
    }
    return null;
  }
  getXYOverlappingObstacles(node) {
    const cachedObstacles = this.nodeToXYOverlappingObstaclesMap.get(
      node.capacityMeshNodeId
    );
    if (cachedObstacles) {
      return cachedObstacles;
    }
    const overlappingObstacles = [];
    const nodeLeft = node.center.x - node.width / 2;
    const nodeRight = node.center.x + node.width / 2;
    const nodeTop = node.center.y - node.height / 2;
    const nodeBottom = node.center.y + node.height / 2;
    const obstacles = node._parent ? this.getXYOverlappingObstacles(node._parent) : this.srj.obstacles;
    for (const obstacle of obstacles) {
      const obsLeft = obstacle.center.x - obstacle.width / 2;
      const obsRight = obstacle.center.x + obstacle.width / 2;
      const obsTop = obstacle.center.y - obstacle.height / 2;
      const obsBottom = obstacle.center.y + obstacle.height / 2;
      if (nodeRight >= obsLeft && nodeLeft <= obsRight && nodeBottom >= obsTop && nodeTop <= obsBottom) {
        overlappingObstacles.push(obstacle);
        continue;
      }
      if (nodeLeft >= obsLeft && nodeRight <= obsRight && nodeTop >= obsTop && nodeBottom <= obsBottom) {
        overlappingObstacles.push(obstacle);
        continue;
      }
      if (obsLeft >= nodeLeft && obsRight <= nodeRight && obsTop >= nodeTop && obsBottom <= nodeBottom) {
        overlappingObstacles.push(obstacle);
      }
    }
    this.nodeToXYOverlappingObstaclesMap.set(
      node.capacityMeshNodeId,
      overlappingObstacles
    );
    return overlappingObstacles;
  }
  getXYZOverlappingObstacles(node) {
    const xyOverlappingObstacles = this.getXYOverlappingObstacles(node);
    const xyzOverlappingObstacles = [];
    for (const obstacle of xyOverlappingObstacles) {
      if (node.availableZ.some((z) => obstacle.zLayers.includes(z))) {
        xyzOverlappingObstacles.push(obstacle);
      }
    }
    return xyzOverlappingObstacles;
  }
  /**
   * Checks if the given mesh node overlaps with any obstacle.
   * We treat both obstacles and nodes as axisaligned rectangles.
   */
  doesNodeOverlapObstacle(node) {
    const overlappingObstacles = this.getXYZOverlappingObstacles(node);
    if (overlappingObstacles.length > 0) {
      return true;
    }
    const nodeLeft = node.center.x - node.width / 2;
    const nodeRight = node.center.x + node.width / 2;
    const nodeTop = node.center.y - node.height / 2;
    const nodeBottom = node.center.y + node.height / 2;
    if (nodeLeft < this.srj.bounds.minX || nodeRight > this.srj.bounds.maxX || nodeTop < this.srj.bounds.minY || nodeBottom > this.srj.bounds.maxY) {
      return true;
    }
    return false;
  }
  /**
   * Checks if the entire node is contained within any obstacle.
   */
  isNodeCompletelyInsideObstacle(node) {
    const overlappingObstacles = this.getXYZOverlappingObstacles(node);
    const nodeLeft = node.center.x - node.width / 2;
    const nodeRight = node.center.x + node.width / 2;
    const nodeTop = node.center.y - node.height / 2;
    const nodeBottom = node.center.y + node.height / 2;
    for (const obstacle of overlappingObstacles) {
      const obsLeft = obstacle.center.x - obstacle.width / 2;
      const obsRight = obstacle.center.x + obstacle.width / 2;
      const obsTop = obstacle.center.y - obstacle.height / 2;
      const obsBottom = obstacle.center.y + obstacle.height / 2;
      if (nodeLeft >= obsLeft && nodeRight <= obsRight && nodeTop >= obsTop && nodeBottom <= obsBottom) {
        return true;
      }
    }
    return false;
  }
  getChildNodes(parent) {
    if (parent._depth === this.MAX_DEPTH) return [];
    const childNodes = [];
    const childNodeSize = { width: parent.width / 2, height: parent.height / 2 };
    const childNodePositions = [
      {
        x: parent.center.x - childNodeSize.width / 2,
        y: parent.center.y - childNodeSize.height / 2
      },
      {
        x: parent.center.x + childNodeSize.width / 2,
        y: parent.center.y - childNodeSize.height / 2
      },
      {
        x: parent.center.x - childNodeSize.width / 2,
        y: parent.center.y + childNodeSize.height / 2
      },
      {
        x: parent.center.x + childNodeSize.width / 2,
        y: parent.center.y + childNodeSize.height / 2
      }
    ];
    for (const position of childNodePositions) {
      const childNode = {
        capacityMeshNodeId: this.getNextNodeId(),
        center: position,
        width: childNodeSize.width,
        height: childNodeSize.height,
        layer: parent.layer,
        availableZ: [0, 1],
        _depth: (parent._depth ?? 0) + 1,
        _parent: parent
      };
      childNode._containsObstacle = this.doesNodeOverlapObstacle(childNode);
      const target = this.getTargetIfNodeContainsTarget(childNode);
      if (target) {
        childNode._targetConnectionName = target.connectionName;
        childNode.availableZ = target.availableZ;
        childNode._containsTarget = true;
      }
      if (childNode._containsObstacle) {
        childNode._completelyInsideObstacle = this.isNodeCompletelyInsideObstacle(childNode);
      }
      if (childNode._completelyInsideObstacle && !childNode._containsTarget)
        continue;
      childNodes.push(childNode);
    }
    return childNodes;
  }
  shouldNodeBeXYSubdivided(node) {
    if (node._depth >= this.MAX_DEPTH) return false;
    if (node._containsTarget) return true;
    if (node._containsObstacle && !node._completelyInsideObstacle) return true;
    return false;
  }
  _step() {
    const nextNode = this.unfinishedNodes.pop();
    if (!nextNode) {
      this.solved = true;
      return;
    }
    const newNodes = this.getChildNodes(nextNode);
    const finishedNewNodes = [];
    const unfinishedNewNodes = [];
    for (const newNode of newNodes) {
      const shouldBeSubdivided = this.shouldNodeBeXYSubdivided(newNode);
      if (shouldBeSubdivided) {
        unfinishedNewNodes.push(newNode);
      } else if (!shouldBeSubdivided && !newNode._containsObstacle) {
        finishedNewNodes.push(newNode);
      } else if (!shouldBeSubdivided && newNode._containsTarget) {
        finishedNewNodes.push(newNode);
      }
    }
    this.unfinishedNodes.push(...unfinishedNewNodes);
    this.finishedNodes.push(...finishedNewNodes);
  }
  /**
   * Creates a GraphicsObject to visualize the mesh, its nodes, obstacles, and connection points.
   *
   * - Mesh nodes are rendered as rectangles.
   *   - Nodes that have an obstacle intersection are outlined in red.
   *   - Other nodes are outlined in green.
   * - Lines are drawn from a node to its parent.
   * - Obstacles are drawn as semi-transparent red rectangles.
   * - Points for each connections pointsToConnect are drawn in a unique color.
   */
  visualize() {
    const graphics = {
      lines: [],
      points: [],
      rects: [],
      circles: [],
      coordinateSystem: "cartesian",
      title: "Capacity Mesh Visualization"
    };
    for (const obstacle of this.srj.obstacles) {
      graphics.rects.push({
        center: obstacle.center,
        width: obstacle.width,
        height: obstacle.height,
        fill: obstacle.zLayers?.length === 1 && obstacle.zLayers?.includes(1) ? "rgba(0,0,255,0.3)" : "rgba(255,0,0,0.3)",
        stroke: "red",
        label: ["obstacle", `z: ${obstacle.zLayers.join(",")}`].join("\n")
      });
    }
    const allNodes = [...this.finishedNodes, ...this.unfinishedNodes];
    for (const node of allNodes) {
      const lowestZ = Math.min(...node.availableZ);
      const isNextToBeProcessed = this.unfinishedNodes.length > 0 && node === this.unfinishedNodes[this.unfinishedNodes.length - 1];
      graphics.rects.push({
        center: {
          x: node.center.x + lowestZ * node.width * 0.05,
          y: node.center.y - lowestZ * node.width * 0.05
        },
        width: Math.max(node.width - 2, node.width * 0.8),
        height: Math.max(node.height - 2, node.height * 0.8),
        fill: node._containsObstacle ? "rgba(255,0,0,0.1)" : {
          "0,1": "rgba(0,0,0,0.1)",
          "0": "rgba(0,200,200, 0.1)",
          "1": "rgba(0,0,200, 0.1)"
        }[node.availableZ.join(",")] ?? "rgba(0,200,200,0.1)",
        stroke: isNextToBeProcessed ? "rgba(255,165,0,0.5)" : void 0,
        label: [
          node.capacityMeshNodeId,
          `availableZ: ${node.availableZ.join(",")}`,
          `target? ${node._containsTarget ?? false}`,
          `obs? ${node._containsObstacle ?? false}`,
          `${node.width.toFixed(2)}x${node.height.toFixed(2)}`,
          `capacity: ${getTunedTotalCapacity1(node).toFixed(2)}`
        ].join("\n")
      });
    }
    graphics.rects.sort((a, b) => a.center.y - b.center.y);
    this.srj.connections.forEach((connection, index) => {
      const color = COLORS[index % COLORS.length];
      for (const pt of connection.pointsToConnect) {
        graphics.points.push({
          x: pt.x,
          y: pt.y,
          label: `conn-${index} (${pt.layer})`,
          color
        });
      }
    });
    return graphics;
  }
};

// lib/solvers/CapacityMeshSolver/CapacityMeshNodeSolver2_NodesUnderObstacles.ts
var CapacityMeshNodeSolver2_NodeUnderObstacle = class extends CapacityMeshNodeSolver {
  constructor(srj, opts = {}) {
    super(srj, opts);
    this.srj = srj;
    this.opts = opts;
  }
  VIA_DIAMETER = 0.6;
  OBSTACLE_MARGIN = 0.1;
  isNodeCompletelyOutsideBounds(node) {
    return node.center.x + node.width / 2 < this.srj.bounds.minX || node.center.x - node.width / 2 > this.srj.bounds.maxX || node.center.y + node.height / 2 < this.srj.bounds.minY || node.center.y - node.height / 2 > this.srj.bounds.maxY;
  }
  isNodePartiallyOutsideBounds(node) {
    return node.center.x - node.width / 2 < this.srj.bounds.minX || node.center.x + node.width / 2 > this.srj.bounds.maxX || node.center.y - node.height / 2 < this.srj.bounds.minY || node.center.y + node.height / 2 > this.srj.bounds.maxY;
  }
  createChildNodeAtPosition(parent, opts) {
    const childNode = {
      capacityMeshNodeId: this.getNextNodeId(),
      center: opts.center,
      width: opts.width,
      height: opts.height,
      layer: parent.layer,
      availableZ: opts.availableZ,
      _depth: opts._depth ?? (parent._depth ?? 0) + 1,
      _parent: parent
    };
    const overlappingObstacles = this.getXYZOverlappingObstacles(childNode);
    childNode._containsObstacle = overlappingObstacles.length > 0 || this.isNodePartiallyOutsideBounds(childNode);
    const target = this.getTargetIfNodeContainsTarget(childNode);
    if (target) {
      childNode._targetConnectionName = target.connectionName;
      childNode._containsTarget = true;
    }
    if (childNode._containsObstacle) {
      childNode._completelyInsideObstacle = this.isNodeCompletelyInsideObstacle(childNode);
    }
    return childNode;
  }
  getZSubdivisionChildNodes(node) {
    if (node.availableZ.length === 1) return [];
    const childNodes = [];
    const otherZBlocks = [[0], [1]];
    for (const zBlock of otherZBlocks) {
      const childNode = this.createChildNodeAtPosition(node, {
        center: { ...node.center },
        width: node.width,
        height: node.height,
        availableZ: zBlock,
        // z-subdivision doesn't count towards depth, should be same as parent
        _depth: node._depth
      });
      if (this.isNodeCompletelyOutsideBounds(childNode)) {
        continue;
      }
      childNodes.push(childNode);
    }
    return childNodes;
  }
  getChildNodes(parent) {
    if (parent._depth >= this.MAX_DEPTH) return [];
    const childNodes = [];
    const childNodeSize = { width: parent.width / 2, height: parent.height / 2 };
    const childNodePositions = [
      {
        x: parent.center.x - childNodeSize.width / 2,
        y: parent.center.y - childNodeSize.height / 2
      },
      {
        x: parent.center.x + childNodeSize.width / 2,
        y: parent.center.y - childNodeSize.height / 2
      },
      {
        x: parent.center.x - childNodeSize.width / 2,
        y: parent.center.y + childNodeSize.height / 2
      },
      {
        x: parent.center.x + childNodeSize.width / 2,
        y: parent.center.y + childNodeSize.height / 2
      }
    ];
    for (const position of childNodePositions) {
      const childNode = this.createChildNodeAtPosition(parent, {
        center: position,
        width: childNodeSize.width,
        height: childNodeSize.height,
        availableZ: parent.availableZ
      });
      if (this.isNodeCompletelyOutsideBounds(childNode)) {
        continue;
      }
      childNodes.push(childNode);
    }
    return childNodes;
  }
  shouldNodeBeXYSubdivided(node) {
    if (node._depth >= this.MAX_DEPTH) return false;
    if (node._containsTarget) return true;
    if (node.availableZ.length === 1 && node._depth <= this.MAX_DEPTH)
      return true;
    if (node._containsObstacle && !node._completelyInsideObstacle) return true;
    return false;
  }
  _step() {
    const nextNode = this.unfinishedNodes.pop();
    if (!nextNode) {
      this.solved = true;
      return;
    }
    const childNodes = this.getChildNodes(nextNode);
    const finishedNewNodes = [];
    const unfinishedNewNodes = [];
    for (const childNode of childNodes) {
      const shouldBeXYSubdivided = this.shouldNodeBeXYSubdivided(childNode);
      const shouldBeZSubdivided = childNode.availableZ.length > 1 && !shouldBeXYSubdivided && (childNode._containsObstacle || childNode.width < this.VIA_DIAMETER + this.OBSTACLE_MARGIN);
      if (shouldBeXYSubdivided) {
        unfinishedNewNodes.push(childNode);
      } else if (!shouldBeXYSubdivided && !childNode._containsObstacle && !shouldBeZSubdivided) {
        finishedNewNodes.push(childNode);
      } else if (!shouldBeXYSubdivided && childNode._containsTarget) {
        if (shouldBeZSubdivided) {
          const zSubNodes = this.getZSubdivisionChildNodes(childNode);
          finishedNewNodes.push(
            ...zSubNodes.filter(
              (n) => n._containsTarget || !n._containsObstacle
            )
          );
        } else {
          finishedNewNodes.push(childNode);
        }
      } else if (shouldBeZSubdivided) {
        finishedNewNodes.push(
          ...this.getZSubdivisionChildNodes(childNode).filter(
            (zSubNode) => !zSubNode._containsObstacle
          )
        );
      }
    }
    this.unfinishedNodes.push(...unfinishedNewNodes);
    this.finishedNodes.push(...finishedNewNodes);
  }
};

// lib/solvers/CapacityMeshSolver/getNodeEdgeMap.ts
function getNodeEdgeMap(edges) {
  const nodeEdgeMap = /* @__PURE__ */ new Map();
  for (const edge of edges) {
    for (const nodeId of edge.nodeIds) {
      nodeEdgeMap.set(nodeId, [...nodeEdgeMap.get(nodeId) ?? [], edge]);
    }
  }
  return nodeEdgeMap;
}

// lib/solvers/CapacityMeshSolver/CapacityEdgeToPortSegmentSolver.ts
var CapacityEdgeToPortSegmentSolver = class extends BaseSolver {
  nodes;
  edges;
  capacityPaths;
  nodeMap;
  nodeEdgeMap;
  unprocessedNodeIds;
  nodePortSegments;
  colorMap;
  constructor({
    nodes,
    edges,
    capacityPaths,
    colorMap
  }) {
    super();
    this.nodes = nodes;
    this.edges = edges;
    this.nodeMap = new Map(nodes.map((node) => [node.capacityMeshNodeId, node]));
    this.nodeEdgeMap = getNodeEdgeMap(edges);
    this.capacityPaths = capacityPaths;
    this.colorMap = colorMap ?? {};
    this.unprocessedNodeIds = [
      ...new Set(capacityPaths.flatMap((path) => path.nodeIds))
    ];
    this.nodePortSegments = /* @__PURE__ */ new Map();
  }
  step() {
    const nodeId = this.unprocessedNodeIds.pop();
    if (!nodeId) {
      this.solved = true;
      return;
    }
    const pathsGoingThroughNode = [];
    for (const path of this.capacityPaths) {
      const indexOfNodeInPath = path.nodeIds.indexOf(nodeId);
      if (indexOfNodeInPath !== -1) {
        pathsGoingThroughNode.push({ path, indexOfNodeInPath });
      }
    }
    const node = this.nodeMap.get(nodeId);
    const nodePortSegments = [];
    for (const { path, indexOfNodeInPath } of pathsGoingThroughNode) {
      const entryNodeId = path.nodeIds[indexOfNodeInPath - 1];
      const exitNodeId = path.nodeIds[indexOfNodeInPath + 1];
      for (const adjNodeId of [entryNodeId, exitNodeId]) {
        const adjNode = this.nodeMap.get(adjNodeId);
        if (!adjNode) continue;
        const segment = findOverlappingSegment(node, adjNode);
        const mutuallyAvailableZ = adjNode.availableZ.filter(
          (z) => node.availableZ.includes(z)
        );
        if (mutuallyAvailableZ.length === 0) continue;
        const portSegment = {
          capacityMeshNodeId: nodeId,
          start: segment.start,
          end: segment.end,
          connectionNames: [path.connectionName],
          availableZ: mutuallyAvailableZ
        };
        nodePortSegments.push(portSegment);
      }
    }
    const combinedSegments = combineSegments(nodePortSegments);
    this.nodePortSegments.set(nodeId, combinedSegments);
  }
  visualize() {
    const graphics = {
      lines: [],
      points: [],
      rects: [],
      circles: []
    };
    this.nodePortSegments.forEach((segments, nodeId) => {
      const node = this.nodeMap.get(nodeId);
      segments.forEach((segment) => {
        const isVertical = segment.start.x === segment.end.x;
        const THICKNESS = 0.05;
        for (let i = 0; i < segment.connectionNames.length; i++) {
          const offset = {
            x: 0.05 * Math.max(...segment.availableZ),
            y: 0.05 * Math.max(...segment.availableZ)
          };
          const trueSegmentCenter = {
            x: (segment.start.x + segment.end.x) / 2,
            y: (segment.start.y + segment.end.y) / 2
          };
          const segmentCenter = {
            x: trueSegmentCenter.x + offset.x,
            y: trueSegmentCenter.y + offset.y
          };
          if (offset.x > 0) {
            graphics.lines.push({
              points: [trueSegmentCenter, segmentCenter],
              strokeColor: "rgba(0, 0, 0, 0.25)",
              strokeDash: "5 5"
            });
          }
          graphics.points.push({
            x: segmentCenter.x,
            y: segmentCenter.y,
            label: `${nodeId}: ${segment.connectionNames.join(", ")}
availableZ: ${segment.availableZ.join(",")}
nodePortSegmentId: ${segment.nodePortSegmentId}`
          });
          graphics.lines.push({
            points: [segment.start, segment.end],
            strokeColor: safeTransparentize(
              this.colorMap[segment.connectionNames[i]],
              0.6
            )
          });
        }
      });
    });
    return graphics;
  }
};
function findOverlappingSegment(node, adjNode) {
  const xOverlap = {
    start: Math.max(
      node.center.x - node.width / 2,
      adjNode.center.x - adjNode.width / 2
    ),
    end: Math.min(
      node.center.x + node.width / 2,
      adjNode.center.x + adjNode.width / 2
    )
  };
  const yOverlap = {
    start: Math.max(
      node.center.y - node.height / 2,
      adjNode.center.y - adjNode.height / 2
    ),
    end: Math.min(
      node.center.y + node.height / 2,
      adjNode.center.y + adjNode.height / 2
    )
  };
  const xRange = xOverlap.end - xOverlap.start;
  const yRange = yOverlap.end - yOverlap.start;
  if (xRange < yRange) {
    const x = (xOverlap.start + xOverlap.end) / 2;
    return {
      start: { x, y: yOverlap.start },
      end: { x, y: yOverlap.end }
    };
  } else {
    const y = (yOverlap.start + yOverlap.end) / 2;
    return {
      start: { x: xOverlap.start, y },
      end: { x: xOverlap.end, y }
    };
  }
}
var EPSILON = 1e-9;
function coordsAreEqual(p1, p2) {
  return Math.abs(p1.x - p2.x) < EPSILON && Math.abs(p1.y - p2.y) < EPSILON;
}
function availableZAreEqual(zA1, zA2) {
  if (zA1.length !== zA2.length) {
    return false;
  }
  for (let i = 0; i < zA1.length; i++) {
    if (zA1[i] !== zA2[i]) {
      return false;
    }
  }
  return true;
}
function combineSegments(segments) {
  const mergedSegments = [];
  const remainingSegments = segments.map((s) => ({
    ...s,
    connectionNames: [...s.connectionNames],
    availableZ: [...s.availableZ].sort((a, b) => a - b)
    // Ensure Z is sorted for comparison
  }));
  while (remainingSegments.length > 0) {
    const segmentUnderTest = remainingSegments.pop();
    let foundMatch = false;
    for (let i = 0; i < mergedSegments.length; i++) {
      const mergedSegment = mergedSegments[i];
      const geometryMatch = coordsAreEqual(mergedSegment.start, segmentUnderTest.start) && coordsAreEqual(mergedSegment.end, segmentUnderTest.end) || coordsAreEqual(mergedSegment.start, segmentUnderTest.end) && coordsAreEqual(mergedSegment.end, segmentUnderTest.start);
      const zMatch = availableZAreEqual(
        mergedSegment.availableZ,
        segmentUnderTest.availableZ
      );
      if (geometryMatch && zMatch) {
        const currentConnections = new Set(mergedSegment.connectionNames);
        segmentUnderTest.connectionNames.forEach(
          (cn) => currentConnections.add(cn)
        );
        mergedSegment.connectionNames = Array.from(currentConnections);
        foundMatch = true;
        break;
      }
    }
    if (!foundMatch) {
      mergedSegments.push(segmentUnderTest);
    }
  }
  return mergedSegments;
}

// lib/solvers/CapacityMeshSolver/CapacitySegmentToPointSolver.ts
var CapacitySegmentToPointSolver = class extends BaseSolver {
  unsolvedSegments;
  solvedSegments;
  nodeMap;
  colorMap;
  // We use an extra property on segments to remember assigned points.
  // Each segment will get an added property "assignedPoints" which is an array of:
  // { connectionName: string, point: {x: number, y: number } }
  // This is a temporary extension used by the solver.
  constructor({
    segments,
    colorMap,
    nodes
  }) {
    super();
    this.MAX_ITERATIONS = 1e5;
    this.unsolvedSegments = segments;
    this.solvedSegments = [];
    this.colorMap = colorMap ?? {};
    this.nodeMap = Object.fromEntries(
      nodes.map((node) => [node.capacityMeshNodeId, node])
    );
  }
  /**
   * Perform one iteration step.
   */
  _step() {
    let updated = false;
    const unsolved = [...this.unsolvedSegments];
    for (const seg of unsolved) {
      const n = seg.connectionNames.length;
      if ("assignedPoints" in seg && seg.assignedPoints?.length === n) continue;
      if (n === 1) {
        const center = {
          x: (seg.start.x + seg.end.x) / 2,
          y: (seg.start.y + seg.end.y) / 2,
          z: seg.availableZ[0]
        };
        seg.assignedPoints = [
          { connectionName: seg.connectionNames[0], point: center }
        ];
        this.unsolvedSegments.splice(this.unsolvedSegments.indexOf(seg), 1);
        this.solvedSegments.push(seg);
        updated = true;
      }
    }
    if (!updated && unsolved.length > 0) {
      let candidate = unsolved[0];
      for (const seg of unsolved) {
        if (seg.connectionNames.length < candidate.connectionNames.length) {
          candidate = seg;
        }
      }
      const sortedConnections = [...candidate.connectionNames].sort();
      const dx = candidate.end.x - candidate.start.x;
      const dy = candidate.end.y - candidate.start.y;
      const n = sortedConnections.length;
      const points = [];
      for (let i = 1; i <= n; i++) {
        const fraction = i / (n + 1);
        points.push({
          x: candidate.start.x + dx * fraction,
          y: candidate.start.y + dy * fraction,
          z: candidate.availableZ[0]
        });
      }
      ;
      candidate.assignedPoints = sortedConnections.map(
        (conn, idx) => ({
          connectionName: conn,
          point: points[idx]
        })
      );
      this.unsolvedSegments.splice(this.unsolvedSegments.indexOf(candidate), 1);
      this.solvedSegments.push(candidate);
      updated = true;
    }
    if (this.unsolvedSegments.length === 0) {
      this.solved = true;
    }
  }
  /**
   * Return the assigned points for each segment.
   */
  getNodesWithPortPoints() {
    if (!this.solved) {
      throw new Error(
        "CapacitySegmentToPointSolver not solved, can't give port points yet"
      );
    }
    const map = /* @__PURE__ */ new Map();
    for (const seg of this.solvedSegments) {
      const nodeId = seg.capacityMeshNodeId;
      const node = this.nodeMap[nodeId];
      if (!map.has(nodeId)) {
        map.set(nodeId, {
          capacityMeshNodeId: nodeId,
          portPoints: [],
          center: node.center,
          width: node.width,
          height: node.height
        });
      }
      map.get(nodeId).portPoints.push(
        ...seg.assignedPoints.map((ap) => ({
          ...ap.point,
          connectionName: ap.connectionName
        }))
      );
    }
    return Array.from(map.values());
  }
  /**
   * Return a GraphicsObject that visualizes the segments with assigned points.
   */
  visualize() {
    const graphics = {
      points: [],
      lines: this.solvedSegments.map((seg) => ({
        points: [seg.start, seg.end],
        step: 4
      })),
      rects: [],
      circles: [],
      coordinateSystem: "cartesian",
      title: "Capacity Segment to Point Solver"
    };
    for (let i = 0; i < this.solvedSegments.length; i++) {
      const seg = this.solvedSegments[i];
      for (let j = 0; j < seg.assignedPoints.length; j++) {
        const ap = seg.assignedPoints[j];
        const truePoint = {
          x: ap.point.x,
          y: ap.point.y
        };
        const offsetPoint = {
          x: ap.point.x + ap.point.z * 0.05,
          y: ap.point.y + ap.point.z * 0.05
        };
        if (ap.point.z !== 0) {
          graphics.lines.push({
            points: [truePoint, offsetPoint],
            strokeColor: "rgba(0, 0, 0, 0.25)",
            strokeDash: "5 5",
            step: 4
          });
        }
        graphics.points.push({
          x: offsetPoint.x,
          y: offsetPoint.y,
          label: [
            `${seg.capacityMeshNodeId}-${ap.connectionName}`,
            `z: ${seg.availableZ.join(",")}`,
            `nodePortSegmentId: ${seg.nodePortSegmentId}`
          ].join("\n"),
          color: this.colorMap[ap.connectionName],
          step: 4
        });
      }
    }
    const dashedLines = [];
    const nodeConnections = {};
    for (const seg of this.solvedSegments) {
      const nodeId = seg.capacityMeshNodeId;
      if (!nodeConnections[nodeId]) {
        nodeConnections[nodeId] = {};
      }
      for (const ap of seg.assignedPoints) {
        if (!nodeConnections[nodeId][ap.connectionName]) {
          nodeConnections[nodeId][ap.connectionName] = [];
        }
        nodeConnections[nodeId][ap.connectionName].push({
          x: ap.point.x,
          y: ap.point.y
        });
      }
    }
    for (const nodeId in nodeConnections) {
      for (const conn in nodeConnections[nodeId]) {
        const points = nodeConnections[nodeId][conn];
        if (points.length > 1) {
          dashedLines.push({
            points,
            step: 4,
            strokeDash: "5 5",
            strokeColor: this.colorMap[conn] || "#000"
          });
        }
      }
    }
    graphics.lines.push(...dashedLines);
    return graphics;
  }
};

// node_modules/@tscircuit/math-utils/dist/chunk-3453HRP7.js
function doSegmentsIntersect(p1, q1, p2, q2) {
  const o1 = orientation(p1, q1, p2);
  const o2 = orientation(p1, q1, q2);
  const o3 = orientation(p2, q2, p1);
  const o4 = orientation(p2, q2, q1);
  if (o1 !== o2 && o3 !== o4) {
    return true;
  }
  if (o1 === 0 && onSegment(p1, p2, q1)) return true;
  if (o2 === 0 && onSegment(p1, q2, q1)) return true;
  if (o3 === 0 && onSegment(p2, p1, q2)) return true;
  if (o4 === 0 && onSegment(p2, q1, q2)) return true;
  return false;
}
function orientation(p, q, r) {
  const val = (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);
  if (val === 0) return 0;
  return val > 0 ? 1 : 2;
}
function onSegment(p, q, r) {
  return q.x <= Math.max(p.x, r.x) && q.x >= Math.min(p.x, r.x) && q.y <= Math.max(p.y, r.y) && q.y >= Math.min(p.y, r.y);
}
function pointToSegmentDistance(p, v, w) {
  const l2 = (w.x - v.x) ** 2 + (w.y - v.y) ** 2;
  if (l2 === 0) return distance(p, v);
  let t = ((p.x - v.x) * (w.x - v.x) + (p.y - v.y) * (w.y - v.y)) / l2;
  t = Math.max(0, Math.min(1, t));
  const projection = {
    x: v.x + t * (w.x - v.x),
    y: v.y + t * (w.y - v.y)
  };
  return distance(p, projection);
}
function distance(p1, p2) {
  const dx = p1.x - p2.x;
  const dy = p1.y - p2.y;
  return Math.sqrt(dx * dx + dy * dy);
}
function getSegmentIntersection(a, b, u, v) {
  const dx1 = b.x - a.x;
  const dy1 = b.y - a.y;
  const dx2 = v.x - u.x;
  const dy2 = v.y - u.y;
  const dx3 = a.x - u.x;
  const dy3 = a.y - u.y;
  const denominator = dx1 * dy2 - dy1 * dx2;
  if (Math.abs(denominator) < 1e-10) {
    return null;
  }
  const t = (dy3 * dx2 - dx3 * dy2) / denominator;
  const s = (dx1 * dy3 - dy1 * dx3) / denominator;
  const epsilon = 1e-9;
  if (t >= -epsilon && t <= 1 + epsilon && s >= -epsilon && s <= 1 + epsilon) {
    const intersectionX = a.x + t * dx1;
    const intersectionY = a.y + t * dy1;
    return { x: intersectionX, y: intersectionY };
  }
  return null;
}

// node_modules/@tscircuit/math-utils/dist/chunk-MHHTZHOJ.js
function getBoundingBox(box) {
  const halfWidth = box.width / 2;
  const halfHeight = box.height / 2;
  return {
    minX: box.center.x - halfWidth,
    maxX: box.center.x + halfWidth,
    minY: box.center.y - halfHeight,
    maxY: box.center.y + halfHeight
  };
}
function computeDistanceBetweenBoxes(boxA, boxB) {
  const a = getBoundingBox(boxA);
  const b = getBoundingBox(boxB);
  const dx = Math.max(a.minX - b.maxX, b.minX - a.maxX, 0);
  const dy = Math.max(a.minY - b.maxY, b.minY - a.maxY, 0);
  const pointA = { x: 0, y: 0 };
  const pointB = { x: 0, y: 0 };
  if (dx === 0 && dy === 0) {
    return { distance: 0, pointA: boxA.center, pointB: boxB.center };
  }
  pointA.x = clamp(boxA.center.x, b.minX, b.maxX);
  pointA.y = clamp(boxA.center.y, b.minY, b.maxY);
  pointB.x = clamp(boxB.center.x, a.minX, a.maxX);
  pointB.y = clamp(boxB.center.y, a.minY, a.maxY);
  const distance6 = Math.hypot(pointA.x - pointB.x, pointA.y - pointB.y);
  return { distance: distance6, pointA, pointB };
}
function clamp(value, min, max) {
  return Math.max(min, Math.min(max, value));
}

// node_modules/@tscircuit/math-utils/dist/chunk-FWQGMQBW.js
function segmentToSegmentMinDistance(a, b, u, v) {
  if (a.x === b.x && a.y === b.y) {
    return pointToSegmentDistance(a, u, v);
  }
  if (u.x === v.x && u.y === v.y) {
    return pointToSegmentDistance(u, a, b);
  }
  if (doSegmentsIntersect(a, b, u, v)) {
    return 0;
  }
  const distances = [
    pointToSegmentDistance(a, u, v),
    pointToSegmentDistance(b, u, v),
    pointToSegmentDistance(u, a, b),
    pointToSegmentDistance(v, a, b)
  ];
  return Math.min(...distances);
}
function segmentToBoundsMinDistance(a, b, bounds) {
  const topLeft = { x: bounds.minX, y: bounds.minY };
  const topRight = { x: bounds.maxX, y: bounds.minY };
  const bottomLeft = { x: bounds.minX, y: bounds.maxY };
  const bottomRight = { x: bounds.maxX, y: bounds.maxY };
  if (doSegmentsIntersect(a, b, topLeft, topRight) || doSegmentsIntersect(a, b, topRight, bottomRight) || doSegmentsIntersect(a, b, bottomRight, bottomLeft) || doSegmentsIntersect(a, b, bottomLeft, topLeft)) {
    return 0;
  }
  if (a.x >= bounds.minX && a.x <= bounds.maxX && a.y >= bounds.minY && a.y <= bounds.maxY && b.x >= bounds.minX && b.x <= bounds.maxX && b.y >= bounds.minY && b.y <= bounds.maxY) {
    return 0;
  }
  const distances = [
    pointToSegmentDistance(topLeft, a, b),
    pointToSegmentDistance(topRight, a, b),
    pointToSegmentDistance(bottomLeft, a, b),
    pointToSegmentDistance(bottomRight, a, b)
  ];
  if (a.x >= bounds.minX && a.x <= bounds.maxX && a.y >= bounds.minY && a.y <= bounds.maxY) {
    return 0;
  }
  if (b.x >= bounds.minX && b.x <= bounds.maxX && b.y >= bounds.minY && b.y <= bounds.maxY) {
    return 0;
  }
  if (a.x < bounds.minX || a.x > bounds.maxX || a.y < bounds.minY || a.y > bounds.maxY) {
    const closestX = clamp(a.x, bounds.minX, bounds.maxX);
    const closestY = clamp(a.y, bounds.minY, bounds.maxY);
    distances.push(distance(a, { x: closestX, y: closestY }));
  }
  if (b.x < bounds.minX || b.x > bounds.maxX || b.y < bounds.minY || b.y > bounds.maxY) {
    const closestX = clamp(b.x, bounds.minX, bounds.maxX);
    const closestY = clamp(b.y, bounds.minY, bounds.maxY);
    distances.push(distance(b, { x: closestX, y: closestY }));
  }
  return Math.min(...distances);
}
function segmentToBoxMinDistance(a, b, box) {
  const halfWidth = box.width / 2;
  const halfHeight = box.height / 2;
  const bounds = {
    minX: box.center.x - halfWidth,
    maxX: box.center.x + halfWidth,
    minY: box.center.y - halfHeight,
    maxY: box.center.y + halfHeight
  };
  return segmentToBoundsMinDistance(a, b, bounds);
}
function pointToSegmentClosestPoint(p, a, b) {
  const dx_ab = b.x - a.x;
  const dy_ab = b.y - a.y;
  const l2 = dx_ab * dx_ab + dy_ab * dy_ab;
  if (l2 === 0) return { x: a.x, y: a.y };
  let t = ((p.x - a.x) * dx_ab + (p.y - a.y) * dy_ab) / l2;
  t = Math.max(0, Math.min(1, t));
  const closestPoint = {
    x: a.x + t * dx_ab,
    y: a.y + t * dy_ab
  };
  return closestPoint;
}

// node_modules/@tscircuit/math-utils/dist/chunk-SLG2OU3P.js
function midpoint(p1, p2) {
  return {
    x: (p1.x + p2.x) / 2,
    y: (p1.y + p2.y) / 2
  };
}

// lib/data-structures/SingleRouteCandidatePriorityQueue.ts
var SingleRouteCandidatePriorityQueue = class {
  heap = [];
  constructor(nodes) {
    this.heap = [];
    for (const node of nodes) {
      this.enqueue(node);
    }
  }
  getLeftChildIndex(parentIndex) {
    return 2 * parentIndex + 1;
  }
  getRightChildIndex(parentIndex) {
    return 2 * parentIndex + 2;
  }
  getParentIndex(childIndex) {
    return Math.floor((childIndex - 1) / 2);
  }
  hasLeftChild(index) {
    return this.getLeftChildIndex(index) < this.heap.length;
  }
  hasRightChild(index) {
    return this.getRightChildIndex(index) < this.heap.length;
  }
  hasParent(index) {
    return this.getParentIndex(index) >= 0;
  }
  leftChild(index) {
    return this.heap[this.getLeftChildIndex(index)];
  }
  rightChild(index) {
    return this.heap[this.getRightChildIndex(index)];
  }
  parent(index) {
    return this.heap[this.getParentIndex(index)];
  }
  swap(i, j) {
    const temp = this.heap[i];
    this.heap[i] = this.heap[j];
    this.heap[j] = temp;
  }
  // Removing an element will remove the
  // top element with highest priority then
  // heapifyDown will be called
  dequeue() {
    if (this.heap.length === 0) {
      return null;
    }
    const item = this.heap[0];
    this.heap[0] = this.heap[this.heap.length - 1];
    this.heap.pop();
    this.heapifyDown();
    return item;
  }
  peek() {
    if (this.heap.length === 0) {
      return null;
    }
    return this.heap[0];
  }
  enqueue(item) {
    this.heap.push(item);
    this.heapifyUp();
  }
  heapifyUp() {
    let index = this.heap.length - 1;
    while (this.hasParent(index) && this.parent(index).f > this.heap[index].f) {
      this.swap(this.getParentIndex(index), index);
      index = this.getParentIndex(index);
    }
  }
  heapifyDown() {
    let index = 0;
    while (this.hasLeftChild(index)) {
      let smallerChildIndex = this.getLeftChildIndex(index);
      if (this.hasRightChild(index) && this.rightChild(index).f < this.leftChild(index).f) {
        smallerChildIndex = this.getRightChildIndex(index);
      }
      if (this.heap[index].f < this.heap[smallerChildIndex].f) {
        break;
      } else {
        this.swap(index, smallerChildIndex);
      }
      index = smallerChildIndex;
    }
  }
};

// lib/solvers/HighDensitySolver/SingleHighDensityRouteSolver.ts
var SingleHighDensityRouteSolver = class extends BaseSolver {
  obstacleRoutes;
  bounds;
  boundsSize;
  boundsCenter;
  A;
  B;
  straightLineDistance;
  viaDiameter;
  traceThickness;
  obstacleMargin;
  layerCount;
  minCellSize = 0.05;
  cellStep = 0.05;
  GREEDY_MULTIPLER = 1.1;
  numRoutes;
  VIA_PENALTY_FACTOR = 0.3;
  CELL_SIZE_FACTOR;
  exploredNodes;
  candidates;
  connectionName;
  solvedPath = null;
  futureConnections;
  hyperParameters;
  connMap;
  /** For debugging/animating the exploration */
  debug_exploredNodesOrdered;
  debug_nodesTooCloseToObstacle;
  debug_nodePathToParentIntersectsObstacle;
  debugEnabled = true;
  initialNodeGridOffset;
  constructor(opts) {
    super();
    this.bounds = opts.bounds;
    this.connMap = opts.connMap;
    this.hyperParameters = opts.hyperParameters ?? {};
    this.CELL_SIZE_FACTOR = this.hyperParameters.CELL_SIZE_FACTOR ?? 1;
    this.boundsSize = {
      width: this.bounds.maxX - this.bounds.minX,
      height: this.bounds.maxY - this.bounds.minY
    };
    this.boundsCenter = {
      x: (this.bounds.minX + this.bounds.maxX) / 2,
      y: (this.bounds.minY + this.bounds.maxY) / 2
    };
    this.connectionName = opts.connectionName;
    this.obstacleRoutes = opts.obstacleRoutes;
    this.A = opts.A;
    this.B = opts.B;
    this.viaDiameter = opts.viaDiameter ?? 0.6;
    this.traceThickness = opts.traceThickness ?? 0.15;
    this.obstacleMargin = opts.obstacleMargin ?? 0.2;
    this.layerCount = opts.layerCount ?? 2;
    this.exploredNodes = /* @__PURE__ */ new Set();
    this.straightLineDistance = distance(this.A, this.B);
    this.futureConnections = opts.futureConnections ?? [];
    this.MAX_ITERATIONS = 5e3;
    this.debug_exploredNodesOrdered = [];
    this.debug_nodesTooCloseToObstacle = /* @__PURE__ */ new Set();
    this.debug_nodePathToParentIntersectsObstacle = /* @__PURE__ */ new Set();
    this.numRoutes = this.obstacleRoutes.length + this.futureConnections.length;
    const bestRowOrColumnCount = Math.ceil(5 * (this.numRoutes + 1));
    let numXCells = this.boundsSize.width / this.cellStep;
    let numYCells = this.boundsSize.height / this.cellStep;
    while (numXCells * numYCells > bestRowOrColumnCount ** 2) {
      if (this.cellStep * 2 > opts.minDistBetweenEnteringPoints) {
        break;
      }
      this.cellStep *= 2;
      numXCells = this.boundsSize.width / this.cellStep;
      numYCells = this.boundsSize.height / this.cellStep;
    }
    this.cellStep *= this.CELL_SIZE_FACTOR;
    if (this.futureConnections && this.futureConnections.length === 0 && this.obstacleRoutes.length === 0) {
      this.handleSimpleCases();
    }
    const initialNodePosition = {
      x: Math.round(opts.A.x / (this.cellStep / 2)) * (this.cellStep / 2),
      y: Math.round(opts.A.y / (this.cellStep / 2)) * (this.cellStep / 2)
    };
    this.initialNodeGridOffset = {
      x: initialNodePosition.x - Math.round(opts.A.x / this.cellStep) * this.cellStep,
      y: initialNodePosition.y - Math.round(opts.A.y / this.cellStep) * this.cellStep
    };
    this.candidates = new SingleRouteCandidatePriorityQueue([
      {
        ...opts.A,
        ...initialNodePosition,
        z: opts.A.z ?? 0,
        g: 0,
        h: 0,
        f: 0,
        parent: {
          ...opts.A,
          z: opts.A.z ?? 0,
          g: 0,
          h: 0,
          f: 0,
          parent: null
        }
      }
    ]);
  }
  handleSimpleCases() {
    this.solved = true;
    const { A, B } = this;
    const route = A.z === B.z ? [A, B] : [
      A,
      { ...this.boundsCenter, z: this.A.z },
      {
        ...this.boundsCenter,
        z: B.z
      },
      B
    ];
    this.solvedPath = {
      connectionName: this.connectionName,
      route,
      traceThickness: this.traceThickness,
      viaDiameter: this.viaDiameter,
      vias: this.A.z === this.B.z ? [] : [this.boundsCenter]
    };
  }
  get viaPenaltyDistance() {
    return this.cellStep + this.straightLineDistance * this.VIA_PENALTY_FACTOR;
  }
  isNodeTooCloseToObstacle(node, margin, isVia) {
    margin ??= this.obstacleMargin;
    if (isVia && node.parent) {
      const viasInMyRoute = this.getViasInNodePath(node.parent);
      for (const via of viasInMyRoute) {
        if (distance(node, via) < this.viaDiameter / 2 + margin) {
          return true;
        }
      }
    }
    for (const route of this.obstacleRoutes) {
      const connectedToObstacle = this.connMap?.areIdsConnected?.(
        this.connectionName,
        route.connectionName
      );
      if (!connectedToObstacle) {
        const pointPairs = getSameLayerPointPairs(route);
        for (const pointPair of pointPairs) {
          if ((isVia || pointPair.z === node.z) && pointToSegmentDistance(node, pointPair.A, pointPair.B) < this.traceThickness + margin) {
            return true;
          }
        }
      }
      for (const via of route.vias) {
        if (distance(node, via) < this.viaDiameter / 2 + this.traceThickness / 2 + margin) {
          return true;
        }
      }
    }
    return false;
  }
  isNodeTooCloseToEdge(node, isVia) {
    const margin = isVia ? this.viaDiameter / 2 + this.obstacleMargin / 2 : this.obstacleMargin / 2;
    const tooClose = node.x < this.bounds.minX + margin || node.x > this.bounds.maxX - margin || node.y < this.bounds.minY + margin || node.y > this.bounds.maxY - margin;
    if (tooClose && !isVia) {
      if (distance(node, this.B) < margin * 2 || distance(node, this.A) < margin * 2) {
        return false;
      }
    }
    return tooClose;
  }
  doesPathToParentIntersectObstacle(node) {
    const parent = node.parent;
    if (!parent) return false;
    for (const route of this.obstacleRoutes) {
      const obstacleIsConnectedToNewPath = this.connMap?.areIdsConnected?.(
        this.connectionName,
        route.connectionName
      );
      if (obstacleIsConnectedToNewPath) continue;
      for (const pointPair of getSameLayerPointPairs(route)) {
        if (pointPair.z !== node.z) continue;
        if (doSegmentsIntersect(node, parent, pointPair.A, pointPair.B)) {
          return true;
        }
      }
    }
    return false;
  }
  computeH(node) {
    return distance(node, this.B) + // via penalty
    Math.abs(node.z - this.B.z) * this.viaPenaltyDistance;
  }
  computeG(node) {
    return (node.parent?.g ?? 0) + (node.z === 0 ? 0 : this.viaPenaltyDistance) + distance(node, node.parent);
  }
  computeF(g, h) {
    return g + h * this.GREEDY_MULTIPLER;
  }
  getNodeKey(node) {
    return `${Math.round(node.x / this.cellStep) * this.cellStep},${Math.round(node.y / this.cellStep) * this.cellStep},${node.z}`;
  }
  getNeighbors(node) {
    const neighbors = [];
    const { maxX, minX, maxY, minY } = this.bounds;
    for (let x = -1; x <= 1; x++) {
      for (let y = -1; y <= 1; y++) {
        if (x === 0 && y === 0) continue;
        const neighbor = {
          ...node,
          parent: node,
          x: clamp2(node.x + x * this.cellStep, minX, maxX),
          y: clamp2(node.y + y * this.cellStep, minY, maxY)
        };
        const neighborKey = this.getNodeKey(neighbor);
        if (this.exploredNodes.has(neighborKey)) {
          continue;
        }
        if (this.isNodeTooCloseToObstacle(neighbor)) {
          this.debug_nodesTooCloseToObstacle.add(neighborKey);
          this.exploredNodes.add(neighborKey);
          continue;
        }
        if (this.isNodeTooCloseToEdge(neighbor, false)) {
          this.exploredNodes.add(neighborKey);
          continue;
        }
        if (this.doesPathToParentIntersectObstacle(neighbor)) {
          this.debug_nodePathToParentIntersectsObstacle.add(neighborKey);
          this.exploredNodes.add(neighborKey);
          continue;
        }
        neighbor.g = this.computeG(neighbor);
        neighbor.h = this.computeH(neighbor);
        neighbor.f = this.computeF(neighbor.g, neighbor.h);
        neighbors.push(neighbor);
      }
    }
    const viaNeighbor = {
      ...node,
      parent: node,
      z: node.z === 0 ? this.layerCount - 1 : 0
    };
    if (!this.exploredNodes.has(this.getNodeKey(viaNeighbor)) && !this.isNodeTooCloseToObstacle(
      viaNeighbor,
      this.viaDiameter / 2 + this.obstacleMargin / 2,
      true
    ) && !this.isNodeTooCloseToEdge(viaNeighbor, true)) {
      viaNeighbor.g = this.computeG(viaNeighbor);
      viaNeighbor.h = this.computeH(viaNeighbor);
      viaNeighbor.f = this.computeF(viaNeighbor.g, viaNeighbor.h);
      neighbors.push(viaNeighbor);
    }
    return neighbors;
  }
  getNodePath(node) {
    const path = [];
    while (node) {
      path.push(node);
      node = node.parent;
    }
    return path;
  }
  getViasInNodePath(node) {
    const path = this.getNodePath(node);
    const vias = [];
    for (let i = 0; i < path.length - 1; i++) {
      if (path[i].z !== path[i + 1].z) {
        vias.push({ x: path[i].x, y: path[i].y });
      }
    }
    return vias;
  }
  setSolvedPath(node) {
    const path = this.getNodePath(node);
    path.reverse();
    const vias = [];
    for (let i = 0; i < path.length - 1; i++) {
      if (path[i].z !== path[i + 1].z) {
        vias.push({ x: path[i].x, y: path[i].y });
      }
    }
    this.solvedPath = {
      connectionName: this.connectionName,
      traceThickness: this.traceThickness,
      viaDiameter: this.viaDiameter,
      route: path.map((node2) => ({ x: node2.x, y: node2.y, z: node2.z })).concat([this.B]),
      vias
    };
  }
  computeProgress(currentNode, goalDist, isOnLayer) {
    if (!isOnLayer) goalDist += this.viaPenaltyDistance;
    const goalDistPercent = 1 - goalDist / this.straightLineDistance;
    return Math.max(
      this.progress || 0,
      // 0.112 = ~90% -> 50%
      //         ~25% -> 2%
      //         ~99% -> 94%
      //         ~95% -> 72%
      2 / Math.PI * Math.atan(0.112 * goalDistPercent / (1 - goalDistPercent))
    );
  }
  _step() {
    let currentNode = this.candidates.dequeue();
    let currentNodeKey = currentNode ? this.getNodeKey(currentNode) : void 0;
    while (currentNode && currentNodeKey && this.exploredNodes.has(currentNodeKey)) {
      currentNode = this.candidates.dequeue();
      currentNodeKey = currentNode ? this.getNodeKey(currentNode) : void 0;
    }
    if (!currentNode || !currentNodeKey) {
      this.failed = true;
      return;
    }
    this.exploredNodes.add(currentNodeKey);
    this.debug_exploredNodesOrdered.push(currentNodeKey);
    const goalDist = distance(currentNode, this.B);
    this.progress = this.computeProgress(
      currentNode,
      goalDist,
      currentNode.z === this.B.z
    );
    if (goalDist <= this.cellStep * Math.SQRT2 && currentNode.z === this.B.z && // Make sure the last segment doesn't intersect an obstacle
    !this.doesPathToParentIntersectObstacle({
      ...currentNode,
      parent: currentNode,
      x: this.B.x,
      y: this.B.y
    })) {
      this.solved = true;
      this.setSolvedPath(currentNode);
    }
    const neighbors = this.getNeighbors(currentNode);
    for (const neighbor of neighbors) {
      this.candidates.enqueue(neighbor);
    }
  }
  visualize() {
    const graphics = {
      lines: [],
      points: [],
      rects: [],
      circles: []
    };
    graphics.points.push({
      x: this.A.x,
      y: this.A.y,
      label: `Input A
z: ${this.A.z}`,
      color: "orange"
    });
    graphics.points.push({
      x: this.B.x,
      y: this.B.y,
      label: `Input B
z: ${this.B.z}`,
      color: "orange"
    });
    graphics.lines.push({
      points: [this.A, this.B],
      strokeColor: "rgba(255, 0, 0, 0.5)",
      label: "Direct Input Connection"
    });
    for (let routeIndex = 0; routeIndex < this.obstacleRoutes.length; routeIndex++) {
      const route = this.obstacleRoutes[routeIndex];
      for (let i = 0; i < route.route.length - 1; i++) {
        const z = route.route[i].z;
        graphics.lines.push({
          points: [route.route[i], route.route[i + 1]],
          strokeColor: z === 0 ? "rgba(255, 0, 0, 0.75)" : "rgba(255, 128, 0, 0.25)",
          strokeWidth: route.traceThickness,
          label: "Obstacle Route",
          layer: `obstacle${routeIndex.toString()}`
        });
      }
    }
    for (let i = 0; i < this.debug_exploredNodesOrdered.length; i++) {
      const nodeKey = this.debug_exploredNodesOrdered[i];
      const [x, y, z] = nodeKey.split(",").map(Number);
      if (this.debug_nodesTooCloseToObstacle.has(nodeKey)) continue;
      if (this.debug_nodePathToParentIntersectsObstacle.has(nodeKey)) continue;
      graphics.rects.push({
        center: {
          x: x + this.initialNodeGridOffset.x + z * this.cellStep / 20,
          y: y + this.initialNodeGridOffset.y + z * this.cellStep / 20
        },
        fill: z === 0 ? `rgba(255,0,255,${0.3 - i / this.debug_exploredNodesOrdered.length * 0.2})` : `rgba(0,0,255,${0.3 - i / this.debug_exploredNodesOrdered.length * 0.2})`,
        width: this.cellStep * 0.9,
        height: this.cellStep * 0.9,
        label: `Explored (z=${z})`
      });
    }
    if (this.candidates.peek()) {
      const nextNode = this.candidates.peek();
      graphics.rects.push({
        center: {
          x: nextNode.x + nextNode.z * this.cellStep / 20,
          y: nextNode.y + nextNode.z * this.cellStep / 20
        },
        fill: "rgba(0, 255, 0, 0.8)",
        width: this.cellStep * 0.9,
        height: this.cellStep * 0.9,
        label: `Next (z=${nextNode.z})`
      });
    }
    for (const route of this.obstacleRoutes) {
      for (const via of route.vias) {
        graphics.circles.push({
          center: {
            x: via.x,
            y: via.y
          },
          radius: this.viaDiameter / 2,
          fill: "rgba(255, 0, 0, 0.5)",
          label: "Via"
        });
      }
    }
    if (this.solvedPath) {
      graphics.lines.push({
        points: this.solvedPath.route,
        strokeColor: "green",
        label: "Solved Route"
      });
      for (const via of this.solvedPath.vias) {
        graphics.circles.push({
          center: via,
          radius: this.viaDiameter / 2,
          fill: "green",
          label: "Via"
        });
      }
    }
    return graphics;
  }
};
function getSameLayerPointPairs(route) {
  const pointPairs = [];
  for (let i = 0; i < route.route.length - 1; i++) {
    if (route.route[i].z === route.route[i + 1].z) {
      pointPairs.push({
        z: route.route[i].z,
        A: route.route[i],
        B: route.route[i + 1]
      });
    }
  }
  return pointPairs;
}
function clamp2(value, min, max) {
  return Math.max(min, Math.min(value, max));
}

// lib/solvers/HighDensitySolver/SingleHighDensityRouteSolver6_VertHorzLayer_FutureCost.ts
var SingleHighDensityRouteSolver6_VertHorzLayer_FutureCost = class extends SingleHighDensityRouteSolver {
  FUTURE_CONNECTION_PROX_TRACE_PENALTY_FACTOR = 2;
  FUTURE_CONNECTION_PROX_VIA_PENALTY_FACTOR = 1;
  FUTURE_CONNECTION_PROXIMITY_VD = 10;
  MISALIGNED_DIST_PENALTY_FACTOR = 5;
  VIA_PENALTY_FACTOR_2 = 1;
  FLIP_TRACE_ALIGNMENT_DIRECTION = false;
  constructor(opts) {
    super(opts);
    for (const key in opts.hyperParameters) {
      this[key] = opts.hyperParameters[key];
    }
    const viasThatCanFitHorz = this.boundsSize.width / this.viaDiameter;
    this.VIA_PENALTY_FACTOR = 0.3 * (viasThatCanFitHorz / this.numRoutes) * this.VIA_PENALTY_FACTOR_2;
  }
  getClosestFutureConnectionPoint(node) {
    let minDist = Infinity;
    let closestPoint = null;
    for (const futureConnection of this.futureConnections) {
      for (const point of futureConnection.points) {
        const dist = distance(node, point) + (node.z !== point.z ? this.viaPenaltyDistance : 0);
        if (dist < minDist) {
          minDist = dist;
          closestPoint = point;
        }
      }
    }
    return closestPoint;
  }
  /**
   * Rapidly approaches 0 as the goal distance approaches 0
   */
  diminishCloseToGoal(node) {
    const goalDist = distance(node, this.B);
    return 1 - Math.exp(-goalDist / this.straightLineDistance * 5);
  }
  getFutureConnectionPenalty(node, isVia) {
    let futureConnectionPenalty = 0;
    const closestFuturePoint = this.getClosestFutureConnectionPoint(node);
    const goalDist = distance(node, this.B);
    if (closestFuturePoint) {
      const distToFuturePoint = distance(node, closestFuturePoint);
      if (goalDist <= distToFuturePoint) return 0;
      const maxDist = this.viaDiameter * this.FUTURE_CONNECTION_PROXIMITY_VD;
      const distRatio = distToFuturePoint / maxDist;
      const maxPenalty = isVia ? this.straightLineDistance * this.FUTURE_CONNECTION_PROX_VIA_PENALTY_FACTOR : this.straightLineDistance * this.FUTURE_CONNECTION_PROX_TRACE_PENALTY_FACTOR;
      futureConnectionPenalty = maxPenalty * Math.exp(-distRatio * 5);
    }
    return futureConnectionPenalty;
  }
  computeH(node) {
    const goalDist = distance(node, this.B) ** 1.6;
    const goalDistRatio = goalDist / this.straightLineDistance;
    const baseCost = goalDist + (node.z !== this.B.z ? this.viaPenaltyDistance : 0);
    return baseCost + this.getFutureConnectionPenalty(node, node.z !== node.parent?.z);
  }
  computeG(node) {
    const dx = Math.abs(node.x - node.parent.x);
    const dy = Math.abs(node.y - node.parent.y);
    const dist = Math.sqrt(dx ** 2 + dy ** 2);
    const misalignedDist = !this.FLIP_TRACE_ALIGNMENT_DIRECTION ? node.z === 0 ? dy : dx : node.z === 0 ? dx : dy;
    const baseCost = (node.parent?.g ?? 0) + (node.z === node.parent?.z ? 0 : this.viaPenaltyDistance) + dist + misalignedDist * this.MISALIGNED_DIST_PENALTY_FACTOR;
    return baseCost + this.getFutureConnectionPenalty(node, node.z !== node.parent?.z);
  }
};

// lib/utils/cloneAndShuffleArray.ts
function seededRandom(seed) {
  let s = seed;
  for (let i = 0; i < 10; i++) {
    s = s * 16807 % 2147483647;
  }
  let state0 = s;
  s = (seed * 69069 + 1) % 2147483647;
  for (let i = 0; i < 10; i++) {
    s = s * 48271 % 2147483647;
  }
  let state1 = s;
  return () => {
    let s1 = state0;
    const s0 = state1;
    state0 = s0;
    s1 ^= s1 << 23;
    s1 ^= s1 >>> 17;
    s1 ^= s0;
    s1 ^= s0 >>> 26;
    state1 = s1;
    const result = (state0 + state1) / 4294967296;
    return result - Math.floor(result);
  };
}
var PRESHUFFLED_CASES = {
  1: [[0]],
  2: [
    [0, 1],
    [1, 0]
  ],
  3: [
    [0, 1, 2],
    [2, 0, 1],
    [1, 0, 2],
    [0, 2, 1],
    [1, 2, 0],
    [2, 1, 0]
  ],
  4: [
    [0, 1, 2, 3],
    [2, 0, 1, 3],
    [1, 3, 2, 0],
    [3, 0, 1, 2],
    [0, 2, 1, 3],
    [2, 1, 3, 0],
    [3, 0, 2, 1],
    [1, 2, 0, 3],
    [3, 1, 0, 2],
    [0, 3, 2, 1],
    [2, 3, 0, 1],
    [2, 3, 1, 0],
    [1, 2, 3, 0],
    [3, 1, 2, 0],
    [0, 1, 3, 2],
    [0, 2, 3, 1],
    [0, 3, 1, 2],
    [1, 0, 2, 3],
    [1, 0, 3, 2],
    [1, 3, 0, 2],
    [2, 0, 3, 1],
    [2, 1, 0, 3],
    [3, 2, 0, 1],
    [3, 2, 1, 0]
  ]
};
function cloneAndShuffleArray(arr, seed) {
  if (seed === 0) return arr;
  if (arr.length <= 4) {
    const preshuffledOptions = PRESHUFFLED_CASES[arr.length];
    const preshuffledCase = preshuffledOptions[seed % preshuffledOptions.length];
    return preshuffledCase.map((orderIndex) => arr[orderIndex]);
  }
  const random = seededRandom(seed);
  const shuffled = arr.slice();
  for (let i = 0; i < shuffled.length; i++) {
    const i1 = Math.floor(random() * shuffled.length);
    const i2 = Math.floor(random() * (i + 1));
    [shuffled[i1], shuffled[i2]] = [shuffled[i2], shuffled[i1]];
  }
  return shuffled;
}

// lib/utils/getBoundsFromNodeWithPortPoints.ts
function getBoundsFromNodeWithPortPoints(nodeWithPortPoints) {
  const bounds = {
    minX: nodeWithPortPoints.center.x - nodeWithPortPoints.width / 2,
    maxX: nodeWithPortPoints.center.x + nodeWithPortPoints.width / 2,
    minY: nodeWithPortPoints.center.y - nodeWithPortPoints.height / 2,
    maxY: nodeWithPortPoints.center.y + nodeWithPortPoints.height / 2
  };
  for (const pt of nodeWithPortPoints.portPoints) {
    if (pt.x < bounds.minX) {
      bounds.minX = pt.x;
    }
    if (pt.x > bounds.maxX) {
      bounds.maxX = pt.x;
    }
    if (pt.y < bounds.minY) {
      bounds.minY = pt.y;
    }
    if (pt.y > bounds.maxY) {
      bounds.maxY = pt.y;
    }
  }
  return bounds;
}

// lib/utils/getMinDistBetweenEnteringPoints.ts
var getMinDistBetweenEnteringPoints = (node) => {
  let minDist = Infinity;
  const points = node.portPoints;
  for (let i = 0; i < points.length; i++) {
    for (let j = i + 1; j < points.length; j++) {
      if (points[i].z !== points[j].z) {
        continue;
      }
      const p1 = points[i];
      const p2 = points[j];
      const dist = Math.sqrt((p1.x - p2.x) ** 2 + (p1.y - p2.y) ** 2);
      minDist = Math.min(minDist, dist);
    }
  }
  return minDist === Infinity ? 0 : minDist;
};

// lib/solvers/HighDensitySolver/IntraNodeSolver.ts
var IntraNodeRouteSolver = class extends BaseSolver {
  nodeWithPortPoints;
  colorMap;
  unsolvedConnections;
  totalConnections;
  solvedRoutes;
  failedSubSolvers;
  hyperParameters;
  minDistBetweenEnteringPoints;
  activeSubSolver = null;
  connMap;
  // Legacy compat
  get failedSolvers() {
    return this.failedSubSolvers;
  }
  // Legacy compat
  get activeSolver() {
    return this.activeSubSolver;
  }
  constructor(params) {
    const { nodeWithPortPoints, colorMap } = params;
    super();
    this.nodeWithPortPoints = nodeWithPortPoints;
    this.colorMap = colorMap ?? {};
    this.solvedRoutes = [];
    this.hyperParameters = params.hyperParameters ?? {};
    this.failedSubSolvers = [];
    this.connMap = params.connMap;
    const unsolvedConnectionsMap = /* @__PURE__ */ new Map();
    for (const { connectionName, x, y, z } of nodeWithPortPoints.portPoints) {
      unsolvedConnectionsMap.set(connectionName, [
        ...unsolvedConnectionsMap.get(connectionName) ?? [],
        { x, y, z: z ?? 0 }
      ]);
    }
    this.unsolvedConnections = Array.from(
      unsolvedConnectionsMap.entries().map(([connectionName, points]) => ({
        connectionName,
        points
      }))
    );
    if (this.hyperParameters.SHUFFLE_SEED) {
      this.unsolvedConnections = cloneAndShuffleArray(
        this.unsolvedConnections,
        this.hyperParameters.SHUFFLE_SEED ?? 0
      );
      this.unsolvedConnections = this.unsolvedConnections.map(
        ({ points, ...rest }, i) => ({
          ...rest,
          points: cloneAndShuffleArray(
            points,
            i * 7117 + (this.hyperParameters.SHUFFLE_SEED ?? 0)
          )
        })
      );
    }
    this.totalConnections = this.unsolvedConnections.length;
    this.MAX_ITERATIONS = 1e3 * this.totalConnections ** 1.5;
    this.minDistBetweenEnteringPoints = getMinDistBetweenEnteringPoints(
      this.nodeWithPortPoints
    );
  }
  // handleSimpleNoCrossingsCase() {
  //   // TODO check to make sure there are no crossings due to trace width
  //   this.solved = true
  //   this.solvedRoutes = this.unsolvedConnections.map(
  //     ({ connectionName, points }) => ({
  //       connectionName,
  //       route: points,
  //       traceThickness: 0.1, // TODO load from hyperParameters
  //       viaDiameter: 0.6,
  //       vias: [],
  //     }),
  //   )
  //   this.unsolvedConnections = []
  // }
  computeProgress() {
    return (this.solvedRoutes.length + (this.activeSubSolver?.progress || 0)) / this.totalConnections;
  }
  _step() {
    if (this.activeSubSolver) {
      this.activeSubSolver.step();
      this.progress = this.computeProgress();
      if (this.activeSubSolver.solved) {
        this.solvedRoutes.push(this.activeSubSolver.solvedPath);
        this.activeSubSolver = null;
      } else if (this.activeSubSolver.failed) {
        this.failedSubSolvers.push(this.activeSubSolver);
        this.activeSubSolver = null;
        this.error = this.failedSubSolvers.map((s) => s.error).join("\n");
        this.failed = true;
      }
      return;
    }
    const unsolvedConnection = this.unsolvedConnections.pop();
    this.progress = this.computeProgress();
    if (!unsolvedConnection) {
      this.solved = this.failedSubSolvers.length === 0;
      return;
    }
    if (unsolvedConnection.points.length === 1) {
      return;
    }
    if (unsolvedConnection.points.length === 2) {
      const [A, B] = unsolvedConnection.points;
      if (A.x === B.x && A.y === B.y && A.z === B.z) {
        return;
      }
    }
    const { connectionName, points } = unsolvedConnection;
    this.activeSubSolver = new SingleHighDensityRouteSolver6_VertHorzLayer_FutureCost({
      connectionName,
      minDistBetweenEnteringPoints: this.minDistBetweenEnteringPoints,
      bounds: getBoundsFromNodeWithPortPoints(this.nodeWithPortPoints),
      A: { x: points[0].x, y: points[0].y, z: points[0].z },
      B: {
        x: points[points.length - 1].x,
        y: points[points.length - 1].y,
        z: points[points.length - 1].z
      },
      obstacleRoutes: this.connMap ? this.solvedRoutes.filter(
        (sr) => !this.connMap.areIdsConnected(
          sr.connectionName,
          connectionName
        )
      ) : this.solvedRoutes,
      futureConnections: this.unsolvedConnections,
      layerCount: 2,
      hyperParameters: this.hyperParameters,
      connMap: this.connMap
    });
  }
  visualize() {
    const graphics = {
      lines: [],
      points: [],
      rects: [],
      circles: []
    };
    for (const pt of this.nodeWithPortPoints.portPoints) {
      graphics.points.push({
        x: pt.x,
        y: pt.y,
        label: [pt.connectionName, `layer: ${pt.z}`].join("\n"),
        color: this.colorMap[pt.connectionName] ?? "blue"
      });
    }
    for (let routeIndex = 0; routeIndex < this.solvedRoutes.length; routeIndex++) {
      const route = this.solvedRoutes[routeIndex];
      if (route.route.length > 0) {
        const routeColor = this.colorMap[route.connectionName] ?? "blue";
        for (let i = 0; i < route.route.length - 1; i++) {
          const p1 = route.route[i];
          const p2 = route.route[i + 1];
          graphics.lines.push({
            points: [p1, p2],
            strokeColor: p1.z === 0 ? safeTransparentize(routeColor, 0.2) : safeTransparentize(routeColor, 0.8),
            layer: `route-layer-${p1.z}`,
            step: routeIndex,
            strokeWidth: route.traceThickness
          });
        }
        for (const via of route.vias) {
          graphics.circles.push({
            center: { x: via.x, y: via.y },
            radius: route.viaDiameter / 2,
            fill: safeTransparentize(routeColor, 0.5),
            layer: "via",
            step: routeIndex
          });
        }
      }
    }
    const bounds = getBoundsFromNodeWithPortPoints(this.nodeWithPortPoints);
    const { minX, minY, maxX, maxY } = bounds;
    graphics.lines.push({
      points: [
        { x: minX, y: minY },
        { x: maxX, y: minY },
        { x: maxX, y: maxY },
        { x: minX, y: maxY },
        { x: minX, y: minY }
      ],
      strokeColor: "rgba(255, 0, 0, 0.25)",
      strokeDash: "4 4",
      layer: "border"
    });
    return graphics;
  }
};

// lib/solvers/HyperParameterSupervisorSolver.ts
var HyperParameterSupervisorSolver = class extends BaseSolver {
  GREEDY_MULTIPLIER = 1.2;
  MIN_SUBSTEPS = 1;
  supervisedSolvers;
  winningSolver;
  getHyperParameterDefs() {
    throw new Error("Not implemented");
  }
  getCombinationDefs() {
    return null;
  }
  getHyperParameterCombinations(hyperParameterDefs) {
    if (!hyperParameterDefs) {
      hyperParameterDefs = this.getHyperParameterDefs();
    }
    const combinations = [];
    if (hyperParameterDefs.length === 0) {
      return [{}];
    }
    const [currentDef, ...remainingDefs] = hyperParameterDefs;
    const subCombinations = this.getHyperParameterCombinations(remainingDefs);
    currentDef.possibleValues.forEach((value) => {
      subCombinations.forEach((subCombo) => {
        combinations.push({
          ...subCombo,
          ...value
        });
      });
    });
    return combinations;
  }
  initializeSolvers() {
    const hyperParameterDefs = this.getHyperParameterDefs();
    const combinationDefs = this.getCombinationDefs() ?? [
      hyperParameterDefs.map((def) => def.name)
    ];
    this.supervisedSolvers = [];
    for (const combinationDef of combinationDefs) {
      const hyperParameterCombinations = this.getHyperParameterCombinations(
        hyperParameterDefs.filter((hpd) => combinationDef.includes(hpd.name))
      );
      for (const hyperParameters of hyperParameterCombinations) {
        const solver = this.generateSolver(hyperParameters);
        const g = this.computeG(solver);
        this.supervisedSolvers.push({
          hyperParameters,
          solver,
          h: 0,
          g,
          f: g
        });
      }
    }
  }
  generateSolver(hyperParameters) {
    throw new Error("Not implemented");
  }
  computeG(solver) {
    return solver.iterations / solver.MAX_ITERATIONS;
  }
  computeH(solver) {
    return 1 - (solver.progress || 0);
  }
  computeF(g, h) {
    return g + h * this.GREEDY_MULTIPLIER;
  }
  getSupervisedSolverWithBestFitness() {
    let bestFitness = Infinity;
    let bestSolver = null;
    for (const supervisedSolver of this.supervisedSolvers ?? []) {
      if (supervisedSolver.solver.solved) {
        return supervisedSolver;
      }
      if (supervisedSolver.solver.failed) {
        continue;
      }
      const fitness = supervisedSolver.f;
      if (fitness < bestFitness) {
        bestFitness = fitness;
        bestSolver = supervisedSolver;
      }
    }
    return bestSolver;
  }
  getFailureMessage() {
    return "All solvers failed in hyper solver.";
  }
  _step() {
    if (!this.supervisedSolvers) this.initializeSolvers();
    const supervisedSolver = this.getSupervisedSolverWithBestFitness();
    if (!supervisedSolver) {
      this.failed = true;
      this.error = this.getFailureMessage();
      return;
    }
    for (let i = 0; i < this.MIN_SUBSTEPS; i++) {
      supervisedSolver.solver.step();
    }
    supervisedSolver.g = this.computeG(supervisedSolver.solver);
    supervisedSolver.h = this.computeH(supervisedSolver.solver);
    supervisedSolver.f = this.computeF(supervisedSolver.g, supervisedSolver.h);
    if (supervisedSolver.solver.solved) {
      this.solved = true;
      this.winningSolver = supervisedSolver.solver;
      this.onSolve?.(supervisedSolver);
    }
  }
  onSolve(solver) {
  }
  visualize() {
    const bestSupervisedSolver = this.getSupervisedSolverWithBestFitness();
    let graphics = {
      lines: [],
      circles: [],
      points: [],
      rects: []
    };
    if (bestSupervisedSolver) {
      graphics = bestSupervisedSolver.solver.visualize();
    }
    return graphics;
  }
};

// lib/solvers/HighDensitySolver/TwoRouteHighDensitySolver/findCircleLineIntersections.ts
var findCircleLineIntersections = (circle, line) => {
  const cx = circle.x;
  const cy = circle.y;
  const r = circle.r;
  const x1 = line.p1.x;
  const y1 = line.p1.y;
  const x2 = line.p2.x;
  const y2 = line.p2.y;
  if (Math.abs(x2 - x1) < 1e-3) {
    const x = x1;
    const a = r * r - (x - cx) ** 2;
    if (a < 0) return [];
    if (Math.abs(a) < 1e-3) {
      const y = cy;
      if (y >= Math.min(y1, y2) && y <= Math.max(y1, y2)) {
        return [{ x, y }];
      }
      return [];
    }
    const y_12 = cy + Math.sqrt(a);
    const y_22 = cy - Math.sqrt(a);
    const points2 = [];
    if (y_12 >= Math.min(y1, y2) && y_12 <= Math.max(y1, y2)) {
      points2.push({ x, y: y_12 });
    }
    if (y_22 >= Math.min(y1, y2) && y_22 <= Math.max(y1, y2)) {
      points2.push({ x, y: y_22 });
    }
    return points2;
  }
  const m = (y2 - y1) / (x2 - x1);
  const b = y1 - m * x1;
  const A = 1 + m * m;
  const B = 2 * (m * b - m * cy - cx);
  const C = cx * cx + (b - cy) * (b - cy) - r * r;
  const discriminant = B * B - 4 * A * C;
  if (discriminant < 0) return [];
  if (Math.abs(discriminant) < 1e-3) {
    const x = -B / (2 * A);
    const y = m * x + b;
    if (x >= Math.min(x1, x2) && x <= Math.max(x1, x2) && y >= Math.min(y1, y2) && y <= Math.max(y1, y2)) {
      return [{ x, y }];
    }
    return [];
  }
  const x_1 = (-B + Math.sqrt(discriminant)) / (2 * A);
  const x_2 = (-B - Math.sqrt(discriminant)) / (2 * A);
  const y_1 = m * x_1 + b;
  const y_2 = m * x_2 + b;
  const points = [];
  if (x_1 >= Math.min(x1, x2) && x_1 <= Math.max(x1, x2) && y_1 >= Math.min(y1, y2) && y_1 <= Math.max(y1, y2)) {
    points.push({ x: x_1, y: y_1 });
  }
  if (x_2 >= Math.min(x1, x2) && x_2 <= Math.max(x1, x2) && y_2 >= Math.min(y1, y2) && y_2 <= Math.max(y1, y2)) {
    points.push({ x: x_2, y: y_2 });
  }
  return points;
};

// lib/solvers/HighDensitySolver/TwoRouteHighDensitySolver/computeDumbbellPaths.ts
function computeDumbbellPaths({
  A,
  B,
  C,
  D,
  E,
  F,
  radius,
  margin,
  subdivisions = 0
}) {
  const midpoint2 = (p1, p2) => ({
    x: (p1.x + p2.x) / 2,
    y: (p1.y + p2.y) / 2
  });
  const calculatePoints = (a, b, r) => {
    const dx = b.x - a.x;
    const dy = b.y - a.y;
    const len = Math.sqrt(dx * dx + dy * dy);
    const ux = dx / len;
    const uy = dy / len;
    const px = -uy;
    const py = ux;
    return {
      midpoint: { x: (a.x + b.x) / 2, y: (a.y + b.y) / 2 },
      A_Opp: { x: a.x - ux * r, y: a.y - uy * r },
      A_Right: { x: a.x + px * r, y: a.y + py * r },
      A_Left: { x: a.x - px * r, y: a.y - py * r },
      B_Opp: { x: b.x + ux * r, y: b.y + uy * r },
      B_Right: { x: b.x + px * r, y: b.y + py * r },
      B_Left: { x: b.x - px * r, y: b.y - py * r }
    };
  };
  const isPointOnSegment = (point, segment) => {
    const d1 = distance(point, segment.start);
    const d2 = distance(point, segment.end);
    const segmentLength = distance(segment.start, segment.end);
    const tolerance = 1e-4;
    return Math.abs(d1 + d2 - segmentLength) < tolerance;
  };
  const intersect = (l1, l2) => {
    const { start: p1, end: p2 } = l1;
    const { start: p3, end: p4 } = l2;
    if (isPointOnSegment(p1, l2) || isPointOnSegment(p2, l2) || isPointOnSegment(p3, l1) || isPointOnSegment(p4, l1)) {
      return true;
    }
    const d1x = p2.x - p1.x;
    const d1y = p2.y - p1.y;
    const d2x = p4.x - p3.x;
    const d2y = p4.y - p3.y;
    const det = d1x * d2y - d1y * d2x;
    if (Math.abs(det) < 1e-4) return false;
    const dx = p3.x - p1.x;
    const dy = p3.y - p1.y;
    const t = (dx * d2y - dy * d2x) / det;
    const u = (dx * d1y - dy * d1x) / det;
    return t > 0 && t < 1 && u > 0 && u < 1;
  };
  const doPathsIntersect = (path1, path2) => {
    const segments1 = [];
    for (let i = 0; i < path1.length - 1; i++) {
      segments1.push({ start: path1[i], end: path1[i + 1] });
    }
    const segments2 = [];
    for (let i = 0; i < path2.length - 1; i++) {
      segments2.push({ start: path2[i], end: path2[i + 1] });
    }
    for (const seg1 of segments1) {
      for (const seg2 of segments2) {
        if (intersect(seg1, seg2)) {
          return true;
        }
      }
    }
    return false;
  };
  const pathLength = (points) => {
    let len = 0;
    for (let i = 1; i < points.length; i++) {
      const dx = points[i].x - points[i - 1].x;
      const dy = points[i].y - points[i - 1].y;
      len += Math.sqrt(dx * dx + dy * dy);
    }
    return len;
  };
  const closestPointOnSegment = (segment, circleCenter) => {
    const { start, end } = segment;
    const dx = end.x - start.x;
    const dy = end.y - start.y;
    const segmentLengthSquared = dx * dx + dy * dy;
    if (segmentLengthSquared === 0) return { ...start, t: 0 };
    const t = Math.max(
      0,
      Math.min(
        1,
        ((circleCenter.x - start.x) * dx + (circleCenter.y - start.y) * dy) / segmentLengthSquared
      )
    );
    return {
      x: start.x + t * dx,
      y: start.y + t * dy,
      t
      // Keep track of the parameter for later use
    };
  };
  const getSubdivisionPoint = (segment, circleCenter, r) => {
    const closestPoint = closestPointOnSegment(segment, circleCenter);
    const dist = distance(closestPoint, circleCenter);
    if (dist >= r) return closestPoint;
    const dirX = closestPoint.x - circleCenter.x;
    const dirY = closestPoint.y - circleCenter.y;
    const norm = Math.sqrt(dirX * dirX + dirY * dirY);
    if (norm === 0) {
      const segDirX = segment.end.x - segment.start.x;
      const segDirY = segment.end.y - segment.start.y;
      const segNorm = Math.sqrt(segDirX * segDirX + segDirY * segDirY);
      return {
        x: circleCenter.x + r * segDirX / segNorm,
        y: circleCenter.y + r * segDirY / segNorm,
        t: closestPoint.t,
        isSpecial: true,
        specialType: circleCenter === A ? "A" : "B"
      };
    }
    return {
      x: circleCenter.x + r * dirX / norm,
      y: circleCenter.y + r * dirY / norm,
      t: closestPoint.t,
      isSpecial: true,
      specialType: circleCenter === A ? "A" : "B"
    };
  };
  const subdivideOptimalPath = (path, numSubdivisions) => {
    if (path.length < 2) return path;
    const result = [path[0]];
    for (let i = 0; i < path.length - 1; i++) {
      const segment = { start: path[i], end: path[i + 1] };
      const segmentMidpoint = {
        x: (segment.start.x + segment.end.x) / 2,
        y: (segment.start.y + segment.end.y) / 2
      };
      const midpointDistToA = distance(segmentMidpoint, A);
      const midpointDistToB = distance(segmentMidpoint, B);
      const shouldSubdivide = (midpointDistToA <= radius || midpointDistToB <= radius) && Math.abs(midpointDistToA - midpointDistToB) > 1e-4;
      if (shouldSubdivide) {
        const closestPointA = closestPointOnSegment(segment, A);
        const closestPointB = closestPointOnSegment(segment, B);
        const distToA = distance(closestPointA, A);
        const distToB = distance(closestPointB, B);
        const needsRadiusPointA = distToA < radius;
        const needsRadiusPointB = distToB < radius;
        const adjustedPointA = needsRadiusPointA ? getSubdivisionPoint(segment, A, radius) : null;
        const adjustedPointB = needsRadiusPointB ? getSubdivisionPoint(segment, B, radius) : null;
        let subdivisionPoints = [];
        const segmentLength = distance(segment.start, segment.end);
        if (segmentLength > radius / 2 && numSubdivisions > 0) {
          for (let j = 1; j <= numSubdivisions; j++) {
            const t = j / (numSubdivisions + 1);
            const subPoint = {
              x: segment.start.x + t * (segment.end.x - segment.start.x),
              y: segment.start.y + t * (segment.end.y - segment.start.y),
              t,
              isSpecial: false
            };
            const subDistToA = distance(subPoint, A);
            const subDistToB = distance(subPoint, B);
            if (subDistToA < radius || subDistToB < radius) {
              continue;
            }
            if (adjustedPointA && Math.abs(subPoint.t - adjustedPointA.t) < 0.1) {
              continue;
            }
            if (adjustedPointB && Math.abs(subPoint.t - adjustedPointB.t) < 0.1) {
              continue;
            }
            subdivisionPoints.push(subPoint);
          }
        }
        if (adjustedPointA) {
          subdivisionPoints.push(adjustedPointA);
        }
        if (adjustedPointB) {
          subdivisionPoints.push(adjustedPointB);
        }
        subdivisionPoints.sort((a, b) => a.t - b.t);
        if (subdivisionPoints.length > 1) {
          const filteredPoints = [subdivisionPoints[0]];
          for (let j = 1; j < subdivisionPoints.length; j++) {
            const prev = filteredPoints[filteredPoints.length - 1];
            const curr = subdivisionPoints[j];
            if (distance(prev, curr) > radius / 10) {
              filteredPoints.push(curr);
            }
          }
          subdivisionPoints = filteredPoints;
        }
        subdivisionPoints.forEach((p) => result.push(p));
      }
      result.push(path[i + 1]);
    }
    if (result.length > 1) {
      const filteredResult = [result[0]];
      for (let i = 1; i < result.length; i++) {
        const prev = filteredResult[filteredResult.length - 1];
        const curr = result[i];
        if (distance(prev, curr) > radius / 10) {
          filteredResult.push(curr);
        }
      }
      return filteredResult;
    }
    return result;
  };
  const innerPoints = calculatePoints(A, B, radius);
  const outerPoints = calculatePoints(A, B, radius + margin);
  const getPaths = () => [
    // Path 1: CB_LeftB_OppB_RightMidA_LeftA_OppA_RightD
    [
      C,
      innerPoints.B_Left,
      innerPoints.B_Opp,
      innerPoints.B_Right,
      midpoint2(
        innerPoints.midpoint,
        midpoint2(innerPoints.B_Right, innerPoints.A_Right)
      ),
      midpoint2(
        innerPoints.midpoint,
        midpoint2(innerPoints.A_Left, innerPoints.B_Left)
      ),
      innerPoints.A_Left,
      innerPoints.A_Opp,
      innerPoints.A_Right,
      D
    ],
    // Path 2: CB_RightB_OppB_LeftMidA_RightA_OppA_LeftD
    [
      C,
      innerPoints.B_Right,
      innerPoints.B_Opp,
      innerPoints.B_Left,
      midpoint2(
        innerPoints.midpoint,
        midpoint2(innerPoints.A_Left, innerPoints.B_Left)
      ),
      midpoint2(
        innerPoints.midpoint,
        midpoint2(innerPoints.A_Right, innerPoints.B_Right)
      ),
      innerPoints.A_Right,
      innerPoints.A_Opp,
      innerPoints.A_Left,
      D
    ],
    // Path 3: DB_LeftB_OppB_RightMidA_LeftA_OppA_RightC
    [
      D,
      innerPoints.B_Left,
      innerPoints.B_Opp,
      innerPoints.B_Right,
      midpoint2(
        innerPoints.midpoint,
        midpoint2(innerPoints.A_Right, innerPoints.B_Right)
      ),
      midpoint2(
        innerPoints.midpoint,
        midpoint2(innerPoints.A_Left, innerPoints.B_Left)
      ),
      innerPoints.A_Left,
      innerPoints.A_Opp,
      innerPoints.A_Right,
      C
    ],
    // Path 4: DB_RightB_OppB_LeftMidA_RightA_OppA_LeftC
    [
      D,
      innerPoints.B_Right,
      innerPoints.B_Opp,
      innerPoints.B_Left,
      midpoint2(
        innerPoints.midpoint,
        midpoint2(innerPoints.A_Left, innerPoints.B_Left)
      ),
      midpoint2(
        innerPoints.midpoint,
        midpoint2(innerPoints.A_Right, innerPoints.B_Right)
      ),
      innerPoints.A_Right,
      innerPoints.A_Opp,
      innerPoints.A_Left,
      C
    ]
  ];
  const getJLines = () => {
    const mid_AR_BR = midpoint2(innerPoints.A_Right, innerPoints.B_Right);
    const mid_AL_BL = midpoint2(innerPoints.B_Left, innerPoints.A_Left);
    return [
      /*  Shortest (straight)  */
      { startsAt: "E", goesTo: "B", points: [E, B] },
      { startsAt: "E", goesTo: "A", points: [E, A] },
      { startsAt: "F", goesTo: "B", points: [F, B] },
      { startsAt: "F", goesTo: "A", points: [F, A] },
      /*  Onebend variants  */
      // via the (ARBR) rightside midpoint
      { startsAt: "E", goesTo: "B", points: [E, mid_AR_BR, B] },
      { startsAt: "E", goesTo: "A", points: [E, mid_AR_BR, A] },
      { startsAt: "F", goesTo: "B", points: [F, mid_AR_BR, B] },
      { startsAt: "F", goesTo: "A", points: [F, mid_AR_BR, A] },
      // via the (ALBL) leftside midpoint
      { startsAt: "E", goesTo: "B", points: [E, mid_AL_BL, B] },
      { startsAt: "E", goesTo: "A", points: [E, mid_AL_BL, A] },
      { startsAt: "F", goesTo: "B", points: [F, mid_AL_BL, B] },
      { startsAt: "F", goesTo: "A", points: [F, mid_AL_BL, A] },
      /*  Medium (one outer waypoint)  */
      // rightside outer arc
      {
        startsAt: "E",
        goesTo: "B",
        points: [E, outerPoints.A_Right, mid_AR_BR, B]
      },
      {
        startsAt: "F",
        goesTo: "B",
        points: [F, outerPoints.B_Right, mid_AR_BR, B]
      },
      // leftside outer arc
      {
        startsAt: "E",
        goesTo: "A",
        points: [E, outerPoints.B_Left, mid_AL_BL, A]
      },
      {
        startsAt: "F",
        goesTo: "A",
        points: [F, outerPoints.A_Left, mid_AL_BL, A]
      },
      // crisscross outer arc
      {
        startsAt: "E",
        goesTo: "B",
        points: [E, outerPoints.A_Left, mid_AL_BL, B]
      },
      {
        startsAt: "E",
        goesTo: "A",
        points: [E, outerPoints.B_Right, mid_AR_BR, A]
      },
      /*  Long (two outer waypoints)  */
      {
        startsAt: "E",
        goesTo: "B",
        points: [E, outerPoints.A_Opp, outerPoints.A_Right, mid_AR_BR, B]
      },
      {
        startsAt: "E",
        goesTo: "A",
        points: [E, outerPoints.B_Opp, outerPoints.B_Left, mid_AL_BL, A]
      },
      {
        startsAt: "F",
        goesTo: "B",
        points: [F, outerPoints.A_Opp, outerPoints.A_Left, mid_AL_BL, B]
      },
      {
        startsAt: "F",
        goesTo: "A",
        points: [F, outerPoints.B_Opp, outerPoints.B_Right, mid_AR_BR, A]
      },
      {
        startsAt: "F",
        goesTo: "A",
        points: [F, outerPoints.B_Opp, outerPoints.B_Left, mid_AL_BL, A]
      },
      {
        startsAt: "E",
        goesTo: "B",
        points: [E, outerPoints.A_Opp, outerPoints.A_Left, mid_AL_BL, B]
      },
      {
        startsAt: "E",
        goesTo: "A",
        points: [E, outerPoints.B_Opp, outerPoints.B_Right, mid_AR_BR, A]
      },
      /*  Longest (three outer waypoints)  */
      {
        startsAt: "E",
        goesTo: "B",
        points: [
          E,
          outerPoints.A_Left,
          outerPoints.A_Opp,
          outerPoints.A_Right,
          mid_AR_BR,
          B
        ]
      },
      {
        startsAt: "E",
        goesTo: "A",
        points: [
          E,
          outerPoints.B_Right,
          outerPoints.B_Opp,
          outerPoints.B_Left,
          mid_AL_BL,
          A
        ]
      },
      {
        startsAt: "F",
        goesTo: "B",
        points: [
          F,
          outerPoints.A_Right,
          outerPoints.A_Opp,
          outerPoints.A_Left,
          mid_AL_BL,
          B
        ]
      },
      {
        startsAt: "F",
        goesTo: "A",
        points: [
          F,
          outerPoints.B_Left,
          outerPoints.B_Opp,
          outerPoints.B_Right,
          mid_AR_BR,
          A
        ]
      },
      {
        startsAt: "F",
        goesTo: "A",
        points: [
          F,
          outerPoints.B_Right,
          outerPoints.B_Opp,
          outerPoints.B_Left,
          mid_AL_BL,
          A
        ]
      },
      {
        startsAt: "E",
        goesTo: "B",
        points: [
          E,
          outerPoints.A_Right,
          outerPoints.A_Opp,
          outerPoints.A_Left,
          mid_AL_BL,
          B
        ]
      },
      {
        startsAt: "E",
        goesTo: "A",
        points: [
          E,
          outerPoints.B_Left,
          outerPoints.B_Opp,
          outerPoints.B_Right,
          mid_AR_BR,
          A
        ]
      }
    ].map((l, index) => ({ ...l, index }));
  };
  const subdivideJLinePath = (jLine, oppositePoint, r, m, numSubdivisions) => {
    const path = jLine.points;
    if (path.length < 2) return path;
    const minDistThreshold = r + m;
    const result = [path[0]];
    for (let i = 0; i < path.length - 1; i++) {
      const segment = { start: path[i], end: path[i + 1] };
      const distToOpposite = pointToSegmentDistance(
        oppositePoint,
        segment.start,
        segment.end
      );
      if (distToOpposite < minDistThreshold) {
        const closestPt = closestPointOnSegment(segment, oppositePoint);
        const dirX = closestPt.x - oppositePoint.x;
        const dirY = closestPt.y - oppositePoint.y;
        const norm = Math.sqrt(dirX * dirX + dirY * dirY);
        let adjustedPoint = null;
        if (norm > 1e-6) {
          adjustedPoint = {
            x: oppositePoint.x + minDistThreshold * dirX / norm,
            y: oppositePoint.y + minDistThreshold * dirY / norm
            // We might need 't' if combining with regular subdivisions,
            // but for now, just the adjusted point is needed.
            // t: closestPt.t
          };
        } else {
          const segDirX = segment.end.x - segment.start.x;
          const segDirY = segment.end.y - segment.start.y;
          const segNorm = Math.sqrt(segDirX * segDirX + segDirY * segDirY);
          if (segNorm > 1e-6) {
            adjustedPoint = {
              x: oppositePoint.x + minDistThreshold * segDirX / segNorm,
              y: oppositePoint.y + minDistThreshold * segDirY / segNorm
            };
          } else {
          }
        }
        if (adjustedPoint) {
          if (distance(segment.start, adjustedPoint) > radius / 10) {
            result.push(adjustedPoint);
          }
        }
      }
      const lastPointInResult = result[result.length - 1];
      if (distance(lastPointInResult, segment.end) > radius / 10) {
        result.push(segment.end);
      }
    }
    if (result.length > 1) {
      const filteredResult = [result[0]];
      for (let i = 1; i < result.length; i++) {
        if (distance(filteredResult[filteredResult.length - 1], result[i]) > radius / 10) {
          filteredResult.push(result[i]);
        }
      }
      return filteredResult;
    }
    return result;
  };
  const findOptimalPath = () => {
    const paths = getPaths();
    const validPaths = [];
    for (let i = 0; i < paths.length; i++) {
      const path2 = paths[i];
      const firstSeg = { start: path2[0], end: path2[1] };
      const lastSeg = {
        start: path2[path2.length - 2],
        end: path2[path2.length - 1]
      };
      const midSeg = { start: path2[3], end: path2[4] };
      if (!intersect(firstSeg, lastSeg) && !intersect(firstSeg, midSeg) && !intersect(lastSeg, midSeg)) {
        validPaths.push({
          index: i + 1,
          path: path2,
          length: pathLength(path2)
        });
      }
    }
    if (validPaths.length === 0) {
      return { index: 0, path: [] };
    }
    const optimalPath2 = validPaths.sort((a, b) => a.length - b.length)[0];
    const path = [...optimalPath2.path];
    const firstPoint = path[0];
    const dist3 = distance(firstPoint, path[2]);
    const dist4 = distance(firstPoint, path[3]);
    const closerIdx = dist3 < dist4 ? 2 : 3;
    if (dist3 < distance(firstPoint, path[1]) || dist4 < distance(firstPoint, path[1])) {
      path.splice(1, closerIdx - 1);
    }
    const lastPoint = path[path.length - 1];
    const distM3 = distance(lastPoint, path[path.length - 3]);
    const distM4 = distance(lastPoint, path[path.length - 4]);
    const closerLastIdx = distM3 < distM4 ? path.length - 3 : path.length - 4;
    if (distM3 < distance(lastPoint, path[path.length - 2]) || distM4 < distance(lastPoint, path[path.length - 2])) {
      path.splice(closerLastIdx + 1, path.length - closerLastIdx - 2);
    }
    return {
      index: optimalPath2.index,
      path,
      startsAt: path[0] === C ? "C" : "D",
      goesTo: path[path.length - 1] === C ? "C" : "D"
    };
  };
  const optimalPath = findOptimalPath();
  const subdivided = subdivisions > 0 ? subdivideOptimalPath(optimalPath.path, subdivisions) : optimalPath.path;
  const findJPair = () => {
    if (optimalPath.path.length === 0) return null;
    const jLines = getJLines();
    const minDistFromAB = radius + margin / 2;
    const eLines = jLines.filter((line) => line.startsAt === "E");
    const fLines = jLines.filter((line) => line.startsAt === "F");
    const nonIntersectingELines = [];
    const nonIntersectingFLines = [];
    for (const jLine of eLines) {
      if (doPathsIntersect(jLine.points, optimalPath.path)) continue;
      nonIntersectingELines.push(jLine);
      break;
    }
    for (const jLine of fLines) {
      if (doPathsIntersect(jLine.points, optimalPath.path)) continue;
      nonIntersectingFLines.push(jLine);
      break;
    }
    if (nonIntersectingELines.length === 0 || nonIntersectingFLines.length === 0) {
      return null;
    }
    return {
      line1: nonIntersectingELines[0],
      line2: nonIntersectingFLines[0]
    };
  };
  let jPair = findJPair();
  if (jPair) {
    const oppositePoint1 = jPair.line1.goesTo === "A" ? B : A;
    const oppositePoint2 = jPair.line2.goesTo === "A" ? B : A;
    const subdividedPoints1 = subdivideJLinePath(
      jPair.line1,
      oppositePoint1,
      radius,
      margin,
      subdivisions
      // Use same subdivision count for consistency? Or 0? Let's use 0 for now.
    );
    const subdividedPoints2 = subdivideJLinePath(
      jPair.line2,
      oppositePoint2,
      radius,
      margin,
      subdivisions
      // Use same subdivision count for consistency? Or 0? Let's use 0 for now.
    );
    jPair = {
      line1: { ...jPair.line1, points: subdividedPoints1 },
      line2: { ...jPair.line2, points: subdividedPoints2 }
    };
  }
  return {
    jPair,
    optimalPath: {
      startsAt: optimalPath.startsAt,
      goesTo: optimalPath.goesTo,
      points: subdivided
    }
  };
}

// lib/solvers/HighDensitySolver/TwoRouteHighDensitySolver/TwoCrossingRoutesHighDensitySolver.ts
var TwoCrossingRoutesHighDensitySolver = class extends BaseSolver {
  // Input parameters
  nodeWithPortPoints;
  routes;
  // Configuration parameters
  viaDiameter;
  traceThickness;
  obstacleMargin;
  layerCount = 2;
  debugViaPositions;
  escapeLayer = 1;
  // Solution state
  solvedRoutes = [];
  // Bounds
  bounds;
  constructor(params) {
    super();
    this.nodeWithPortPoints = params.nodeWithPortPoints;
    this.viaDiameter = params?.viaDiameter ?? 0.6;
    this.traceThickness = params?.traceThickness ?? 0.15;
    this.obstacleMargin = params?.obstacleMargin ?? 0.1;
    this.layerCount = params?.layerCount ?? 2;
    this.debugViaPositions = [];
    this.routes = this.extractRoutesFromNode();
    this.bounds = this.calculateBounds();
    if (this.routes.length !== 2) {
      this.failed = true;
      return;
    }
    const [routeA, routeB] = this.routes;
    const routeAStartsAndEndsOnSameLayer = routeA.startPort.z === routeA.endPort.z;
    if (!routeAStartsAndEndsOnSameLayer) {
      this.failed = true;
      return;
    }
    const routeBStartsAndEndsOnSameLayer = routeB.startPort.z === routeB.endPort.z;
    if (!routeBStartsAndEndsOnSameLayer) {
      this.failed = true;
      return;
    }
    const routesAreSameLayer = routeA.startPort.z === routeB.startPort.z;
    if (!routesAreSameLayer) {
      this.failed = true;
      return;
    }
    if (routeA.startPort.z === 0) {
      this.escapeLayer = 1;
    } else {
      this.escapeLayer = 0;
    }
  }
  /**
   * Extract routes that need to be connected from the node data
   */
  extractRoutesFromNode() {
    const routes = [];
    const connectedPorts = this.nodeWithPortPoints.portPoints;
    const connectionGroups = /* @__PURE__ */ new Map();
    for (const connectedPort of connectedPorts) {
      const { connectionName } = connectedPort;
      if (!connectionGroups.has(connectionName)) {
        connectionGroups.set(connectionName, []);
      }
      connectionGroups.get(connectionName)?.push(connectedPort);
    }
    for (const [connectionName, points] of connectionGroups.entries()) {
      if (points.length === 2) {
        routes.push({
          startPort: { ...points[0], z: points[0].z ?? 0 },
          endPort: { ...points[1], z: points[1].z ?? 0 },
          connectionName
        });
      }
    }
    return routes;
  }
  /**
   * Calculate the bounding box of the node
   */
  calculateBounds() {
    return {
      minX: this.nodeWithPortPoints.center.x - this.nodeWithPortPoints.width / 2,
      maxX: this.nodeWithPortPoints.center.x + this.nodeWithPortPoints.width / 2,
      minY: this.nodeWithPortPoints.center.y - this.nodeWithPortPoints.height / 2,
      maxY: this.nodeWithPortPoints.center.y + this.nodeWithPortPoints.height / 2
    };
  }
  /**
   * Check if two routes are crossing
   */
  doRoutesCross(routeA, routeB) {
    return doSegmentsIntersect(
      routeA.startPort,
      routeA.endPort,
      routeB.startPort,
      routeB.endPort
    );
  }
  calculateViaPositions(routeA, routeB) {
    const outerBox = {
      width: this.bounds.maxX - this.bounds.minX,
      height: this.bounds.maxY - this.bounds.minY,
      x: this.bounds.minX,
      y: this.bounds.minY
    };
    const innerBox = {
      width: outerBox.width - 2 * this.obstacleMargin - this.viaDiameter,
      height: outerBox.height - 2 * this.obstacleMargin - this.viaDiameter,
      x: outerBox.x + this.obstacleMargin + this.viaDiameter / 2,
      y: outerBox.y + this.obstacleMargin + this.viaDiameter / 2
    };
    const K1 = this.viaDiameter + this.obstacleMargin;
    const pointA = routeB.startPort;
    const pointB = routeB.endPort;
    const corners = [
      { x: innerBox.x, y: innerBox.y },
      // Top-left (0)
      { x: innerBox.x + innerBox.width, y: innerBox.y },
      // Top-right (1)
      { x: innerBox.x + innerBox.width, y: innerBox.y + innerBox.height },
      // Bottom-right (2)
      { x: innerBox.x, y: innerBox.y + innerBox.height }
      // Bottom-left (3)
    ];
    const distanceBetween = (p1, p2) => {
      return distance(p1, p2);
    };
    const candidatePoints = [];
    corners.forEach((corner, index) => {
      if (distanceBetween(corner, pointA) >= K1 && distanceBetween(corner, pointB) >= K1) {
        candidatePoints.push({ ...corner, type: "corner", index });
      }
    });
    const edges = [
      { p1: corners[0], p2: corners[1] },
      // top
      { p1: corners[1], p2: corners[2] },
      // right
      { p1: corners[2], p2: corners[3] },
      // bottom
      { p1: corners[3], p2: corners[0] }
      // left
    ];
    [pointA, pointB].forEach((circleCenter, circleIndex) => {
      edges.forEach((edge, edgeIndex) => {
        const intersections = findCircleLineIntersections(
          { ...circleCenter, r: K1 },
          edge
        );
        intersections.forEach((point) => {
          const otherCircle = circleIndex === 0 ? pointB : pointA;
          if (distanceBetween(point, otherCircle) >= K1) {
            candidatePoints.push({
              ...point,
              type: "intersection",
              circle: circleIndex,
              edge: edgeIndex
            });
          }
        });
      });
    });
    if (candidatePoints.length < 2) {
      const relaxedK1 = K1 * 0.8;
      corners.forEach((corner, index) => {
        if (distanceBetween(corner, pointA) >= relaxedK1 && distanceBetween(corner, pointB) >= relaxedK1 && !candidatePoints.some((p) => p.x === corner.x && p.y === corner.y)) {
          candidatePoints.push({ ...corner, type: "relaxed_corner", index });
        }
      });
      if (candidatePoints.length < 2) {
        const sortedCorners = [...corners].sort((a, b) => {
          const aMinDist = Math.min(
            distanceBetween(a, pointA),
            distanceBetween(a, pointB)
          );
          const bMinDist = Math.min(
            distanceBetween(b, pointA),
            distanceBetween(b, pointB)
          );
          return bMinDist - aMinDist;
        });
        for (const corner of sortedCorners) {
          if (!candidatePoints.some((p) => p.x === corner.x && p.y === corner.y)) {
            candidatePoints.push({ ...corner, type: "forced_corner" });
            if (candidatePoints.length >= 2) break;
          }
        }
      }
    }
    if (candidatePoints.length < 2) {
      return null;
    }
    let maxDist = 0;
    let optimalPair = [
      candidatePoints[0],
      candidatePoints[candidatePoints.length > 1 ? 1 : 0]
    ];
    for (let i = 0; i < candidatePoints.length; i++) {
      for (let j = i + 1; j < candidatePoints.length; j++) {
        const dist = distanceBetween(candidatePoints[i], candidatePoints[j]);
        if (dist > maxDist) {
          maxDist = dist;
          optimalPair = [candidatePoints[i], candidatePoints[j]];
        }
      }
    }
    let via1 = { x: optimalPair[0].x, y: optimalPair[0].y };
    let via2 = { x: optimalPair[1].x, y: optimalPair[1].y };
    const via1DistToStart = distance(via1, routeA.startPort);
    const via2DistToStart = distance(via2, routeA.startPort);
    if (via2DistToStart < via1DistToStart) {
      ;
      [via1, via2] = [via2, via1];
    }
    return {
      via1,
      via2
    };
  }
  /**
   * Try to solve with routeA going over and routeB staying on layer 0
   */
  trySolveAOverB(routeA, routeB, swapVias = false) {
    const viaPositions = swapVias ? this.calculateViaPositions(routeA, routeB) : this.calculateViaPositions(routeB, routeA);
    if (viaPositions) {
      this.debugViaPositions.push(viaPositions);
    } else {
      return false;
    }
    const { via1, via2 } = this.pushViasFromEndpoints(
      this.moveViasAsCloseAsPossible(viaPositions)
    );
    this.debugViaPositions.push({ via1, via2 });
    const NOT_CIRCULAR_PENALTY_TC = 1.5;
    const { jPair, optimalPath } = computeDumbbellPaths({
      A: via1,
      B: via2,
      C: routeA.startPort,
      D: routeA.endPort,
      E: routeB.startPort,
      F: routeB.endPort,
      // NOTE: Should be traceThickness /2, but we don't currently subdivide
      // enough to make a round enough circle, so we have to add additional margin
      radius: this.viaDiameter / 2 + this.obstacleMargin + this.traceThickness / 2 * NOT_CIRCULAR_PENALTY_TC,
      margin: this.obstacleMargin * 2 + this.traceThickness / 2 * NOT_CIRCULAR_PENALTY_TC,
      subdivisions: 1
    });
    if (!jPair) return false;
    const routeASolution = {
      connectionName: routeA.connectionName,
      route: optimalPath.points.map((p) => ({
        x: p.x,
        y: p.y,
        z: routeA.startPort.z ?? 0
      })),
      traceThickness: this.traceThickness,
      viaDiameter: this.viaDiameter,
      vias: []
    };
    jPair.line2.points.reverse();
    const routeBSolution = {
      connectionName: routeB.connectionName,
      route: [
        ...jPair.line1.points.map((p) => ({
          x: p.x,
          y: p.y,
          z: routeB.startPort.z ?? 0
        })),
        {
          ...jPair.line1.points[jPair.line1.points.length - 1],
          z: this.escapeLayer
        },
        { ...jPair.line2.points[0], z: this.escapeLayer },
        ...jPair.line2.points.map((p) => ({
          x: p.x,
          y: p.y,
          z: routeB.startPort.z ?? 0
        }))
      ],
      traceThickness: this.traceThickness,
      viaDiameter: this.viaDiameter,
      vias: [via1, via2]
    };
    this.solvedRoutes.push(routeASolution, routeBSolution);
    return true;
  }
  pushViasFromEndpoints(viaPositions) {
    const currentVia1 = { ...viaPositions.via1 };
    const currentVia2 = { ...viaPositions.via2 };
    const endpoints = [
      this.routes[0].startPort,
      this.routes[0].endPort,
      this.routes[1].startPort,
      this.routes[1].endPort
    ];
    const optimalDistBtwViaCenters = this.getMinDistanceBetweenViaCenters();
    const minDistanceBtwViaAndEndpoint = this.viaDiameter / 2 + this.traceThickness * 2 + this.obstacleMargin * 2;
    const MAX_ITERS = 10;
    const PUSH_DECAY = 0.9;
    for (let iter = 0; iter < MAX_ITERS; iter++) {
      let via1Moved = false;
      let via2Moved = false;
      const pushDecayFactor = PUSH_DECAY ** iter;
      for (const endpoint of endpoints) {
        const dist1 = distance(currentVia1, endpoint);
        if (dist1 < minDistanceBtwViaAndEndpoint) {
          const overlap = minDistanceBtwViaAndEndpoint - dist1;
          const pushAmount = overlap * pushDecayFactor;
          const dx = currentVia1.x - endpoint.x;
          const dy = currentVia1.y - endpoint.y;
          const norm = Math.sqrt(dx * dx + dy * dy);
          if (norm > 1e-6) {
            currentVia1.x += dx / norm * pushAmount;
            currentVia1.y += dy / norm * pushAmount;
            via1Moved = true;
          }
        }
        const dist2 = distance(currentVia2, endpoint);
        if (dist2 < minDistanceBtwViaAndEndpoint) {
          const overlap = minDistanceBtwViaAndEndpoint - dist2;
          const pushAmount = overlap * pushDecayFactor;
          const dx = currentVia2.x - endpoint.x;
          const dy = currentVia2.y - endpoint.y;
          const norm = Math.sqrt(dx * dx + dy * dy);
          if (norm > 1e-6) {
            currentVia2.x += dx / norm * pushAmount;
            currentVia2.y += dy / norm * pushAmount;
            via2Moved = true;
          }
        }
      }
      const distBetweenVias = distance(currentVia1, currentVia2);
      if (distBetweenVias < optimalDistBtwViaCenters) {
        const overlap = optimalDistBtwViaCenters - distBetweenVias;
        const pushAmount = overlap / 2;
        const dx = currentVia2.x - currentVia1.x;
        const dy = currentVia2.y - currentVia1.y;
        const norm = Math.sqrt(dx * dx + dy * dy);
        if (norm > 1e-6) {
          currentVia1.x -= dx / norm * pushAmount;
          currentVia1.y -= dy / norm * pushAmount;
          currentVia2.x += dx / norm * pushAmount;
          currentVia2.y += dy / norm * pushAmount;
          via1Moved = true;
          via2Moved = true;
        } else {
          currentVia1.x -= pushAmount;
          currentVia2.x += pushAmount;
          via1Moved = true;
          via2Moved = true;
        }
      }
      if (!via1Moved && !via2Moved) {
        break;
      }
    }
    const finalDist = distance(currentVia1, currentVia2);
    if (finalDist < optimalDistBtwViaCenters) {
      const overlap = optimalDistBtwViaCenters - finalDist;
      const pushAmount = overlap / 2;
      const dx = currentVia2.x - currentVia1.x;
      const dy = currentVia2.y - currentVia1.y;
      const norm = Math.sqrt(dx * dx + dy * dy);
      if (norm > 1e-6) {
        currentVia1.x -= dx / norm * pushAmount;
        currentVia1.y -= dy / norm * pushAmount;
        currentVia2.x += dx / norm * pushAmount;
        currentVia2.y += dy / norm * pushAmount;
      } else {
        currentVia1.x -= pushAmount;
        currentVia2.x += pushAmount;
      }
    }
    return { via1: currentVia1, via2: currentVia2 };
  }
  getMinDistanceBetweenViaCenters() {
    return this.viaDiameter + this.traceThickness + this.obstacleMargin * 2;
  }
  moveViasAsCloseAsPossible(viaPositions) {
    const { via1, via2 } = viaPositions;
    const minRequiredDistance = this.getMinDistanceBetweenViaCenters();
    const currentDistance = distance(via1, via2);
    if (currentDistance <= minRequiredDistance) {
      return viaPositions;
    }
    const dirX = via2.x - via1.x;
    const dirY = via2.y - via1.y;
    const dirLength = Math.sqrt(dirX * dirX + dirY * dirY);
    const normDirX = dirX / dirLength;
    const normDirY = dirY / dirLength;
    const midpointX = (via1.x + via2.x) / 2;
    const midpointY = (via1.y + via2.y) / 2;
    const moveDistance = (currentDistance - minRequiredDistance) / 2;
    const newVia1 = {
      x: via1.x + normDirX * moveDistance,
      y: via1.y + normDirY * moveDistance
    };
    const newVia2 = {
      x: via2.x - normDirX * moveDistance,
      y: via2.y - normDirY * moveDistance
    };
    return {
      via1: newVia1,
      via2: newVia2
    };
  }
  handleRoutesDontCross() {
    const [routeA, routeB] = this.routes;
    const routeASolution = {
      connectionName: routeA.connectionName,
      route: [
        {
          x: routeA.startPort.x,
          y: routeA.startPort.y,
          z: routeA.startPort.z ?? 0
        },
        {
          x: routeA.endPort.x,
          y: routeA.endPort.y,
          z: routeA.endPort.z ?? 0
        }
      ],
      traceThickness: this.traceThickness,
      viaDiameter: this.viaDiameter,
      vias: []
    };
    const routeBSolution = {
      connectionName: routeB.connectionName,
      route: [
        {
          x: routeB.startPort.x,
          y: routeB.startPort.y,
          z: routeB.startPort.z ?? 0
        },
        {
          x: routeB.endPort.x,
          y: routeB.endPort.y,
          z: routeB.endPort.z ?? 0
        }
      ],
      traceThickness: this.traceThickness,
      viaDiameter: this.viaDiameter,
      vias: []
    };
    this.solvedRoutes.push(routeASolution, routeBSolution);
    this.solved = true;
    return;
  }
  /**
   * Main step method that attempts to solve the two crossing routes
   */
  _step() {
    if (this.routes.length !== 2) {
      this.failed = true;
      return;
    }
    const [routeA, routeB] = this.routes;
    if (!this.doRoutesCross(routeA, routeB)) {
      this.handleRoutesDontCross();
      return;
    }
    if (this.trySolveAOverB(routeA, routeB)) {
      this.solved = true;
      return;
    }
    if (this.trySolveAOverB(routeB, routeA)) {
      this.solved = true;
      return;
    }
    if (this.trySolveAOverB(routeA, routeB, true)) {
      this.solved = true;
      return;
    }
    if (this.trySolveAOverB(routeB, routeA, true)) {
      this.solved = true;
      return;
    }
    this.failed = true;
  }
  /**
   * Visualization for debugging
   */
  visualize() {
    const graphics = {
      lines: [],
      points: [],
      rects: [],
      circles: []
    };
    graphics.rects.push({
      center: {
        x: (this.bounds.minX + this.bounds.maxX) / 2,
        y: (this.bounds.minY + this.bounds.maxY) / 2
      },
      width: this.bounds.maxX - this.bounds.minX,
      height: this.bounds.maxY - this.bounds.minY,
      stroke: "rgba(0, 0, 0, 0.5)",
      fill: "rgba(240, 240, 240, 0.1)"
    });
    for (const [routeName, route] of [
      ["Route A", this.routes[0]],
      ["Route B", this.routes[1]]
    ]) {
      graphics.points.push({
        x: route.startPort.x,
        y: route.startPort.y,
        label: `${routeName}
${route.connectionName} start`,
        color: "orange"
      });
      graphics.points.push({
        x: route.endPort.x,
        y: route.endPort.y,
        label: `${routeName}
${route.connectionName} end`,
        color: "orange"
      });
      graphics.lines.push({
        points: [route.startPort, route.endPort],
        strokeColor: "rgba(255, 0, 0, 0.5)",
        label: `${routeName}
${route.connectionName} direct`
      });
    }
    for (let i = 0; i < this.debugViaPositions.length; i++) {
      const { via1, via2 } = this.debugViaPositions[i];
      const colors = ["rgba(255, 165, 0, 0.3)", "rgba(128, 0, 128, 0.3)"];
      const color = colors[i % colors.length];
      graphics.circles.push({
        center: via1,
        radius: this.viaDiameter / 2,
        fill: color,
        stroke: "rgba(0, 0, 0, 0.3)",
        label: `Computed Via A (attempt ${i + 1})`
      });
      graphics.circles.push({
        center: via2,
        radius: this.viaDiameter / 2,
        fill: color,
        stroke: "rgba(0, 0, 0, 0.3)",
        label: `Computed Via B (attempt ${i + 1})`
      });
      const safetyMargin = this.viaDiameter / 2 + this.obstacleMargin;
      graphics.circles.push({
        center: via1,
        radius: safetyMargin,
        stroke: color,
        fill: "rgba(0, 0, 0, 0)",
        label: `Debug Via 1 Safety Margin (attempt ${i + 1})`
      });
      graphics.circles.push({
        center: via2,
        radius: safetyMargin,
        stroke: color,
        fill: "rgba(0, 0, 0, 0)",
        label: `Debug Via 2 Safety Margin (attempt ${i + 1})`
      });
      graphics.lines.push({
        points: [
          this.routes[i % 2].startPort,
          via1,
          via2,
          this.routes[i % 2].endPort
        ],
        strokeColor: `${color.substring(0, color.lastIndexOf(","))}, 0.3)`,
        strokeDash: [5, 5],
        label: `Potential Route (attempt ${i + 1})`
      });
    }
    for (let si = 0; si < this.solvedRoutes.length; si++) {
      const route = this.solvedRoutes[si];
      const routeColor = si % 2 === 0 ? "rgba(0, 255, 0, 0.75)" : "rgba(255, 0, 255, 0.75)";
      for (let i = 0; i < route.route.length - 1; i++) {
        const pointA = route.route[i];
        const pointB = route.route[i + 1];
        graphics.lines.push({
          points: [pointA, pointB],
          strokeColor: routeColor,
          strokeDash: pointA.z === 1 ? [0.2, 0.2] : void 0,
          strokeWidth: route.traceThickness,
          label: `${route.connectionName} z=${pointA.z}`
        });
        if (pointA._label) {
          graphics.points.push({
            x: pointA.x,
            y: pointA.y,
            label: pointA._label
          });
        }
      }
      for (const via of route.vias) {
        graphics.circles.push({
          center: via,
          radius: this.viaDiameter / 2,
          fill: "rgba(0, 0, 255, 0.8)",
          stroke: "black",
          label: "Solved Via"
        });
        graphics.circles.push({
          center: via,
          radius: this.viaDiameter / 2 + this.obstacleMargin,
          fill: "rgba(0, 0, 255, 0.3)",
          stroke: "black",
          label: "Solved Via Margin"
        });
      }
    }
    return graphics;
  }
  /**
   * Get the solved routes
   */
  getSolvedRoutes() {
    return this.solvedRoutes;
  }
};

// lib/utils/findClosestPointToABCWithinBounds.ts
function findClosestPointToABCWithinBounds(A, B, C, radius, bounds) {
  const avgPoint = {
    x: (A.x + B.x + C.x) / 3,
    y: (A.y + B.y + C.y) / 3
  };
  const distance6 = (p1, p2) => {
    return Math.sqrt((p2.x - p1.x) ** 2 + (p2.y - p1.y) ** 2);
  };
  const isValidPoint = (point) => {
    const distToA = distance6(point, A);
    const distToB = distance6(point, B);
    const distToC = distance6(point, C);
    const withinBounds2 = point.x >= bounds.minX && point.x <= bounds.maxX && point.y >= bounds.minY && point.y <= bounds.maxY;
    return distToA >= radius && distToB >= radius && distToC >= radius && withinBounds2;
  };
  const isOnBoundary = (point) => {
    const epsilon = 1e-6;
    return Math.abs(point.x - bounds.minX) < epsilon || Math.abs(point.x - bounds.maxX) < epsilon || Math.abs(point.y - bounds.minY) < epsilon || Math.abs(point.y - bounds.maxY) < epsilon;
  };
  if (isValidPoint(avgPoint)) {
    return avgPoint;
  }
  const pointOnCircle = (center, constraint, r) => {
    const vx = center.x - constraint.x;
    const vy = center.y - constraint.y;
    const dist = Math.sqrt(vx * vx + vy * vy);
    if (dist < 1e-10) {
      return { x: constraint.x + r, y: constraint.y };
    }
    return {
      x: constraint.x + vx / dist * r,
      y: constraint.y + vy / dist * r
    };
  };
  const findCircleIntersections = (c1, c2, r) => {
    const dx = c2.x - c1.x;
    const dy = c2.y - c1.y;
    const dist = Math.sqrt(dx * dx + dy * dy);
    if (dist > 2 * r - 1e-10 || dist < 1e-10) {
      return [];
    }
    const a = dist * dist / (2 * dist);
    const h = Math.sqrt(Math.max(0, r * r - a * a));
    const midX = c1.x + dx * a / dist;
    const midY = c1.y + dy * a / dist;
    const intersection1 = {
      x: midX + h * dy / dist,
      y: midY - h * dx / dist
    };
    const intersection2 = {
      x: midX - h * dy / dist,
      y: midY + h * dx / dist
    };
    const result = [];
    const epsilon = 1e-6;
    if (Math.abs(distance6(intersection1, c1) - r) < epsilon && Math.abs(distance6(intersection1, c2) - r) < epsilon) {
      result.push(intersection1);
    }
    if (Math.abs(distance6(intersection2, c1) - r) < epsilon && Math.abs(distance6(intersection2, c2) - r) < epsilon) {
      result.push(intersection2);
    }
    return result;
  };
  const candidateA = pointOnCircle(avgPoint, A, radius);
  const candidateB = pointOnCircle(avgPoint, B, radius);
  const candidateC = pointOnCircle(avgPoint, C, radius);
  const intersectionsAB = findCircleIntersections(A, B, radius);
  const intersectionsBC = findCircleIntersections(B, C, radius);
  const intersectionsCA = findCircleIntersections(C, A, radius);
  const allCandidates = [
    candidateA,
    candidateB,
    candidateC,
    ...intersectionsAB,
    ...intersectionsBC,
    ...intersectionsCA
  ];
  const validCandidates = allCandidates.filter(isValidPoint);
  if (validCandidates.length > 0) {
    const interiorCandidates = validCandidates.filter((p) => !isOnBoundary(p));
    if (interiorCandidates.length > 0) {
      interiorCandidates.sort(
        (a, b) => distance6(a, avgPoint) - distance6(b, avgPoint)
      );
      return interiorCandidates[0];
    }
  }
  const gridStep = 5;
  let bestPoint = null;
  let bestDistance = Infinity;
  for (let x = bounds.minX + 1; x < bounds.maxX; x += gridStep) {
    for (let y = bounds.minY + 1; y < bounds.maxY; y += gridStep) {
      const point = { x, y };
      if (isValidPoint(point)) {
        const dist = distance6(point, avgPoint);
        if (dist < bestDistance) {
          bestDistance = dist;
          bestPoint = point;
        }
      }
    }
  }
  if (bestPoint !== null) {
    return bestPoint;
  }
  const numSamples = 100;
  const boundaryPoints = [];
  for (let i = 0; i <= numSamples; i++) {
    const t = i / numSamples;
    boundaryPoints.push({
      x: bounds.minX + t * (bounds.maxX - bounds.minX),
      y: bounds.minY
    });
    boundaryPoints.push({
      x: bounds.maxX,
      y: bounds.minY + t * (bounds.maxY - bounds.minY)
    });
    boundaryPoints.push({
      x: bounds.maxX - t * (bounds.maxX - bounds.minX),
      y: bounds.maxY
    });
    boundaryPoints.push({
      x: bounds.minX,
      y: bounds.maxY - t * (bounds.maxY - bounds.minY)
    });
  }
  const validBoundaryPoints = boundaryPoints.filter(isValidPoint);
  if (validBoundaryPoints.length > 0) {
    validBoundaryPoints.sort(
      (a, b) => distance6(a, avgPoint) - distance6(b, avgPoint)
    );
    return validBoundaryPoints[0];
  }
  let minViolation = Infinity;
  let leastBadPoint = { x: bounds.minX, y: bounds.minY };
  for (const point of [...allCandidates, ...boundaryPoints]) {
    if (point.x >= bounds.minX && point.x <= bounds.maxX && point.y >= bounds.minY && point.y <= bounds.maxY) {
      const violationA = Math.max(0, radius - distance6(point, A));
      const violationB = Math.max(0, radius - distance6(point, B));
      const violationC = Math.max(0, radius - distance6(point, C));
      const totalViolation = violationA + violationB + violationC;
      if (totalViolation < minViolation) {
        minViolation = totalViolation;
        leastBadPoint = point;
      }
    }
  }
  return leastBadPoint;
}

// lib/utils/findPointToGetAroundCircle.ts
function findPointToGetAroundCircle(A, C, Q) {
  const B = computeTangentPoint(C, A, Q.center, Q.radius);
  const D = computeTangentPoint(A, C, Q.center, Q.radius);
  const distBC = distance2(B, C);
  const distAD = distance2(A, D);
  const minDistThreshold = 1e-6;
  const BIsValid = distBC > minDistThreshold;
  const DIsValid = distAD > minDistThreshold;
  let E;
  if (!BIsValid || !DIsValid) {
    const midAC = {
      x: (A.x + C.x) / 2,
      y: (A.y + C.y) / 2
    };
    const distFromCenter = distance2(midAC, Q.center);
    if (distFromCenter < Q.radius * 1.1) {
      const dirFromCenter = {
        x: (midAC.x - Q.center.x) / distFromCenter,
        y: (midAC.y - Q.center.y) / distFromCenter
      };
      E = {
        x: Q.center.x + dirFromCenter.x * Q.radius * 1.2,
        y: Q.center.y + dirFromCenter.y * Q.radius * 1.2
      };
    } else {
      E = midAC;
    }
  } else {
    E = {
      x: (B.x + D.x) / 2,
      y: (B.y + D.y) / 2
    };
    const distBE = distance2(B, E);
    const distDE = distance2(D, E);
    if (Math.abs(distBE - distDE) > Math.min(distBE, distDE) * 0.5) {
      const distAB = distance2(A, B);
      const distCD = distance2(C, D);
      const totalDist = distAB + distCD;
      if (totalDist > minDistThreshold) {
        const weightB = distCD / totalDist;
        const weightD = distAB / totalDist;
        E = {
          x: B.x * weightB + D.x * weightD,
          y: B.y * weightB + D.y * weightD
        };
      }
    }
    const distEToCenter = distance2(E, Q.center);
    if (distEToCenter < Q.radius * 1.05) {
      const dirFromCenter = {
        x: (E.x - Q.center.x) / distEToCenter,
        y: (E.y - Q.center.y) / distEToCenter
      };
      E = {
        x: Q.center.x + dirFromCenter.x * Q.radius * 1.2,
        y: Q.center.y + dirFromCenter.y * Q.radius * 1.2
      };
    }
  }
  return { B, D, E };
}
function computeTangentPoint(observationPoint, referencePoint, circleCenter, radius) {
  const CQ = [
    circleCenter.x - observationPoint.x,
    circleCenter.y - observationPoint.y
  ];
  const CQLength = Math.sqrt(CQ[0] * CQ[0] + CQ[1] * CQ[1]);
  if (CQLength <= radius) {
    if (CQLength < 1e-8) {
      const refVec = [
        referencePoint.x - observationPoint.x,
        referencePoint.y - observationPoint.y
      ];
      const refLength = Math.sqrt(refVec[0] * refVec[0] + refVec[1] * refVec[1]);
      if (refLength < 1e-8) {
        return {
          x: circleCenter.x + radius,
          y: circleCenter.y
        };
      }
      return {
        x: circleCenter.x + refVec[0] / refLength * radius,
        y: circleCenter.y + refVec[1] / refLength * radius
      };
    }
    const CQUnit2 = [CQ[0] / CQLength, CQ[1] / CQLength];
    return {
      x: circleCenter.x - CQUnit2[0] * radius,
      y: circleCenter.y - CQUnit2[1] * radius
    };
  }
  const CR = [
    referencePoint.x - observationPoint.x,
    referencePoint.y - observationPoint.y
  ];
  const d = Math.sqrt(CQLength * CQLength - radius * radius);
  const CQUnit = [CQ[0] / CQLength, CQ[1] / CQLength];
  const perp1 = [-CQUnit[1], CQUnit[0]];
  const perp2 = [CQUnit[1], -CQUnit[0]];
  const dot1 = CR[0] * perp1[0] + CR[1] * perp1[1];
  const dot2 = CR[0] * perp2[0] + CR[1] * perp2[1];
  const perp = dot1 > dot2 ? perp1 : perp2;
  const sinTheta = radius / CQLength;
  const cosTheta = d / CQLength;
  const unitToTangent = [
    CQUnit[0] * cosTheta + perp[0] * sinTheta,
    CQUnit[1] * cosTheta + perp[1] * sinTheta
  ];
  return {
    x: observationPoint.x + d * unitToTangent[0],
    y: observationPoint.y + d * unitToTangent[1]
  };
}
function distance2(p1, p2) {
  const dx = p2.x - p1.x;
  const dy = p2.y - p1.y;
  return Math.sqrt(dx * dx + dy * dy);
}

// lib/solvers/HighDensitySolver/TwoRouteHighDensitySolver/calculateSideTraversal.ts
var EPSILON2 = 1e-9;
function calculateSegmentTraversal(startPoint, endPoint, bounds, turnDirection = "cw") {
  const startAngle = pointToAngle(startPoint, bounds);
  const endAngle = pointToAngle(endPoint, bounds);
  if (Math.abs(endAngle - startAngle) < EPSILON2) {
    return { left: 0, top: 0, right: 0, bottom: 0 };
  }
  return calculateSidePercentages(startAngle, endAngle, bounds, turnDirection);
}
function calculateTraversalPercentages(A, B, C, bounds, turnDirection) {
  const percentagesAB = calculateSegmentTraversal(A, B, bounds, turnDirection);
  const percentagesBC = calculateSegmentTraversal(B, C, bounds, turnDirection);
  const totalPercentages = {
    left: Math.min(1, percentagesAB.left + percentagesBC.left),
    top: Math.min(1, percentagesAB.top + percentagesBC.top),
    right: Math.min(1, percentagesAB.right + percentagesBC.right),
    bottom: Math.min(1, percentagesAB.bottom + percentagesBC.bottom)
  };
  for (const key in totalPercentages) {
    if (Math.abs(totalPercentages[key]) < EPSILON2) {
      totalPercentages[key] = 0;
    }
  }
  return totalPercentages;
}
function pointToAngle(point, bounds) {
  const width = bounds.maxX - bounds.minX;
  const height = bounds.maxY - bounds.minY;
  if (width < EPSILON2 && height < EPSILON2) return 0;
  const perimeter = 2 * (width + height);
  if (perimeter < EPSILON2) return 0;
  let distance6 = 0;
  if (Math.abs(point.y - bounds.maxY) < EPSILON2 && point.x >= bounds.minX - EPSILON2 && point.x <= bounds.maxX + EPSILON2) {
    distance6 = Math.max(0, Math.min(width, point.x - bounds.minX));
  } else if (Math.abs(point.x - bounds.maxX) < EPSILON2 && point.y >= bounds.minY - EPSILON2 && point.y <= bounds.maxY + EPSILON2) {
    distance6 = width + Math.max(0, Math.min(height, bounds.maxY - point.y));
  } else if (Math.abs(point.y - bounds.minY) < EPSILON2 && point.x >= bounds.minX - EPSILON2 && point.x <= bounds.maxX + EPSILON2) {
    distance6 = width + height + Math.max(0, Math.min(width, bounds.maxX - point.x));
  } else if (Math.abs(point.x - bounds.minX) < EPSILON2 && point.y >= bounds.minY - EPSILON2 && point.y <= bounds.maxY + EPSILON2) {
    distance6 = width + height + width + Math.max(0, Math.min(height, point.y - bounds.minY));
  } else {
    throw new Error(
      `Point (${point.x}, ${point.y}) does not lie on the boundary defined by ${JSON.stringify(bounds)}`
    );
  }
  distance6 = Math.max(0, Math.min(perimeter, distance6));
  return perimeter > EPSILON2 ? distance6 / perimeter * (2 * Math.PI) : 0;
}
function calculateSidePercentages(startAngle, endAngle, bounds, turnDirection) {
  const width = bounds.maxX - bounds.minX;
  const height = bounds.maxY - bounds.minY;
  if (width < EPSILON2 && height < EPSILON2)
    return { left: 0, top: 0, right: 0, bottom: 0 };
  const perimeter = 2 * (width + height);
  if (perimeter < EPSILON2) return { left: 0, top: 0, right: 0, bottom: 0 };
  const angleTopEnd = width / perimeter * (2 * Math.PI);
  const angleRightEnd = (width + height) / perimeter * (2 * Math.PI);
  const angleBottomEnd = (width + width + height) / perimeter * (2 * Math.PI);
  const angleLeftEnd = 2 * Math.PI;
  const sides = [
    { name: "top", start: 0, end: angleTopEnd, length: width },
    { name: "right", start: angleTopEnd, end: angleRightEnd, length: height },
    {
      name: "bottom",
      start: angleRightEnd,
      end: angleBottomEnd,
      length: width
    },
    { name: "left", start: angleBottomEnd, end: angleLeftEnd, length: height }
    // Ends at 2PI
  ];
  const result = { left: 0, top: 0, right: 0, bottom: 0 };
  const calculateTraversalOverlap = (sStart, sEnd, tStart, tEnd, wrapsAround) => {
    const effectiveSEnd = sEnd > 2 * Math.PI - EPSILON2 ? 2 * Math.PI : sEnd;
    if (effectiveSEnd <= sStart + EPSILON2) return 0;
    if (!wrapsAround) {
      const overlapStart = Math.max(sStart, tStart);
      const overlapEnd = Math.min(effectiveSEnd, tEnd);
      return Math.max(0, overlapEnd - overlapStart);
    } else {
      const overlap1Start = Math.max(sStart, tStart);
      const overlap1End = Math.min(effectiveSEnd, 2 * Math.PI);
      const overlap1 = Math.max(0, overlap1End - overlap1Start);
      const overlap2Start = Math.max(sStart, 0);
      const overlap2End = Math.min(effectiveSEnd, tEnd);
      const overlap2 = Math.max(0, overlap2End - overlap2Start);
      return overlap1 + overlap2;
    }
  };
  for (const side of sides) {
    const sideAngleRange = side.end - side.start;
    if (sideAngleRange < EPSILON2 || side.length < EPSILON2) continue;
    let traversedAngleOnSide = 0;
    if (turnDirection === "cw") {
      const wraps = startAngle > endAngle + EPSILON2;
      traversedAngleOnSide = calculateTraversalOverlap(
        side.start,
        side.end,
        startAngle,
        endAngle,
        wraps
      );
    } else {
      const wraps = endAngle > startAngle + EPSILON2;
      traversedAngleOnSide = calculateTraversalOverlap(
        side.start,
        side.end,
        endAngle,
        // Start of equivalent CW traversal
        startAngle,
        // End of equivalent CW traversal
        wraps
      );
    }
    if (traversedAngleOnSide > EPSILON2) {
      const percentage = traversedAngleOnSide / sideAngleRange;
      result[side.name] += Math.max(
        0,
        Number.isFinite(percentage) ? percentage : 0
      );
    }
  }
  for (const key in result) {
    result[key] = Math.max(
      0,
      Math.min(1, result[key])
    );
  }
  return result;
}

// lib/solvers/HighDensitySolver/TwoRouteHighDensitySolver/computeTurnDirection.ts
function triangleDirection({
  angleA,
  angleB,
  angleC
}) {
  const Ax = Math.cos(angleA);
  const Ay = Math.sin(angleA);
  const Bx = Math.cos(angleB);
  const By = Math.sin(angleB);
  const Cx = Math.cos(angleC);
  const Cy = Math.sin(angleC);
  const signedArea = (Bx - Ax) * (Cy - Ay) - (By - Ay) * (Cx - Ax);
  return signedArea < 0 ? "ccw" : "cw";
}
function computeTurnDirection(A, B, C, bounds) {
  const angleA = pointToAngle(A, bounds);
  const angleB = pointToAngle(B, bounds);
  const angleC = pointToAngle(C, bounds);
  return triangleDirection({ angleA, angleB, angleC });
}

// lib/solvers/HighDensitySolver/TwoRouteHighDensitySolver/SingleTransitionCrossingRouteSolver.ts
var SingleTransitionCrossingRouteSolver = class extends BaseSolver {
  // Input parameters
  nodeWithPortPoints;
  routes;
  // Configuration parameters
  viaDiameter;
  traceThickness;
  obstacleMargin;
  layerCount = 2;
  debugViaPositions;
  // Solution state
  solvedRoutes = [];
  // Bounds
  bounds;
  constructor(params) {
    super();
    this.nodeWithPortPoints = params.nodeWithPortPoints;
    this.viaDiameter = params?.viaDiameter ?? 0.6;
    this.traceThickness = params?.traceThickness ?? 0.15;
    this.obstacleMargin = params?.obstacleMargin ?? 0.1;
    this.layerCount = params?.layerCount ?? 2;
    this.debugViaPositions = [];
    this.routes = this.extractRoutesFromNode();
    this.bounds = this.calculateBounds();
    if (this.routes.length !== 2) {
      this.failed = true;
      return;
    }
    const [routeA, routeB] = this.routes;
    const routeAHasTransition = routeA.A.z !== routeA.B.z;
    const routeBHasTransition = routeB.A.z !== routeB.B.z;
    if (routeAHasTransition && routeBHasTransition || !routeAHasTransition && !routeBHasTransition) {
      this.failed = true;
      return;
    }
  }
  /**
   * Extract routes that need to be connected from the node data
   */
  extractRoutesFromNode() {
    const routes = [];
    const connectedPorts = this.nodeWithPortPoints.portPoints;
    const connectionGroups = /* @__PURE__ */ new Map();
    for (const connectedPort of connectedPorts) {
      const { connectionName } = connectedPort;
      if (!connectionGroups.has(connectionName)) {
        connectionGroups.set(connectionName, []);
      }
      connectionGroups.get(connectionName)?.push(connectedPort);
    }
    for (const [connectionName, points] of connectionGroups.entries()) {
      if (points.length === 2) {
        routes.push({
          A: { ...points[0], z: points[0].z ?? 0 },
          B: { ...points[1], z: points[1].z ?? 0 },
          connectionName
        });
      }
    }
    return routes;
  }
  /**
   * Calculate the bounding box of the node
   */
  calculateBounds() {
    return {
      minX: this.nodeWithPortPoints.center.x - this.nodeWithPortPoints.width / 2,
      maxX: this.nodeWithPortPoints.center.x + this.nodeWithPortPoints.width / 2,
      minY: this.nodeWithPortPoints.center.y - this.nodeWithPortPoints.height / 2,
      maxY: this.nodeWithPortPoints.center.y + this.nodeWithPortPoints.height / 2
    };
  }
  /**
   * Check if two routes are crossing
   */
  doRoutesCross(routeA, routeB) {
    return doSegmentsIntersect(routeA.A, routeA.B, routeB.A, routeB.B);
  }
  calculateViaPosition(transitionRoute, flatRoute) {
    const flatRouteZ = flatRoute.A.z;
    const ntrP1 = transitionRoute.A.z !== flatRouteZ ? transitionRoute.A : transitionRoute.B;
    const marginFromBorderWithTrace = this.obstacleMargin * 2 + this.viaDiameter / 2 + this.traceThickness;
    const marginFromBorderWithoutTrace = this.obstacleMargin + this.viaDiameter / 2;
    const A = flatRoute.A;
    const B = ntrP1;
    const C = flatRoute.B;
    const turnDirection = computeTurnDirection(A, B, C, this.bounds);
    const sideTraversal = calculateTraversalPercentages(
      A,
      B,
      C,
      this.bounds,
      turnDirection
    );
    const viaBounds = {
      minX: this.bounds.minX + (sideTraversal.left > 0.5 ? marginFromBorderWithTrace : marginFromBorderWithoutTrace),
      minY: this.bounds.minY + (sideTraversal.bottom > 0.5 ? marginFromBorderWithTrace : marginFromBorderWithoutTrace),
      maxX: this.bounds.maxX - (sideTraversal.right > 0.5 ? marginFromBorderWithTrace : marginFromBorderWithoutTrace),
      maxY: this.bounds.maxY - (sideTraversal.top > 0.5 ? marginFromBorderWithTrace : marginFromBorderWithoutTrace)
    };
    if (viaBounds.maxY < viaBounds.minY) {
      viaBounds.minY = (viaBounds.minY + viaBounds.maxY) / 2;
      viaBounds.maxY = viaBounds.minY;
    }
    if (viaBounds.maxX < viaBounds.minX) {
      viaBounds.minX = (viaBounds.minX + viaBounds.maxX) / 2;
      viaBounds.maxX = viaBounds.minX;
    }
    return findClosestPointToABCWithinBounds(
      A,
      B,
      C,
      marginFromBorderWithTrace,
      viaBounds
    );
  }
  /**
   * Create a single transition route with properly placed via
   */
  createTransitionRoute(start, end, via, connectionName) {
    const route = [
      { x: start.x, y: start.y, z: start.z ?? 0 },
      { x: via.x, y: via.y, z: start.z ?? 0 },
      { x: via.x, y: via.y, z: end.z ?? 0 },
      { x: end.x, y: end.y, z: end.z ?? 0 }
    ];
    return {
      connectionName,
      route,
      traceThickness: this.traceThickness,
      viaDiameter: this.viaDiameter,
      vias: [via]
    };
  }
  /**
   * Create the non-transition route
   */
  createFlatRoute(flatStart, flatEnd, via, otherRouteStart, otherRouteEnd, flatRouteConnectionName) {
    const ntrP1 = otherRouteStart.z !== flatStart.z ? otherRouteStart : otherRouteEnd;
    const middle = (a, b) => {
      return {
        x: (a.x + b.x) / 2,
        y: (a.y + b.y) / 2
      };
    };
    const middleWithMargin = (a, aMargin, b, bMargin) => {
      const dx = b.x - a.x;
      const dy = b.y - a.y;
      const effectiveA = {
        x: a.x + dx * aMargin,
        y: a.y + dy * aMargin
      };
      const effectiveB = {
        x: b.x - dx * bMargin,
        y: b.y - dy * bMargin
      };
      return middle(effectiveA, effectiveB);
    };
    const minDistFromViaToTrace = this.viaDiameter / 2 + this.traceThickness / 2 + this.obstacleMargin;
    const p2 = middleWithMargin(
      via,
      this.viaDiameter,
      otherRouteStart.z !== flatStart.z ? otherRouteStart : otherRouteEnd,
      this.traceThickness
    );
    const viaCircle = {
      center: { x: via.x, y: via.y },
      radius: minDistFromViaToTrace
    };
    const p1 = findPointToGetAroundCircle(flatStart, p2, viaCircle).E;
    const p3 = findPointToGetAroundCircle(p2, flatEnd, viaCircle).E;
    const p0_5 = findPointToGetAroundCircle(flatStart, p1, viaCircle).E;
    const p1_5 = findPointToGetAroundCircle(p1, p2, viaCircle).E;
    const p2_5 = findPointToGetAroundCircle(p2, p3, viaCircle).E;
    const p3_5 = findPointToGetAroundCircle(p3, flatEnd, viaCircle).E;
    const p2_better = findPointToGetAroundCircle(p1_5, p2_5, viaCircle).E;
    return {
      connectionName: flatRouteConnectionName,
      route: [
        { x: flatStart.x, y: flatStart.y, z: flatStart.z ?? 0 },
        { x: p0_5.x, y: p0_5.y, z: flatStart.z ?? 0 },
        { x: p1.x, y: p1.y, z: flatStart.z ?? 0 },
        { x: p1_5.x, y: p1_5.y, z: flatStart.z ?? 0 },
        // { x: p2.x, y: p2.y, z: flatStart.z ?? 0 },
        { x: p2_better.x, y: p2_better.y, z: flatStart.z ?? 0 },
        { x: p2_5.x, y: p2_5.y, z: flatStart.z ?? 0 },
        { x: p3.x, y: p3.y, z: flatStart.z ?? 0 },
        { x: p3_5.x, y: p3_5.y, z: flatStart.z ?? 0 },
        { x: flatEnd.x, y: flatEnd.y, z: flatEnd.z ?? 0 }
      ],
      traceThickness: this.traceThickness,
      viaDiameter: this.viaDiameter,
      vias: []
    };
  }
  /**
   * Try to solve with one route having a transition and the other staying flat
   */
  trySolve() {
    const [routeA, routeB] = this.routes;
    const routeAHasTransition = routeA.A.z !== routeA.B.z;
    const transitionRoute = routeAHasTransition ? routeA : routeB;
    const flatRoute = routeAHasTransition ? routeB : routeA;
    const viaPosition = this.calculateViaPosition(transitionRoute, flatRoute);
    if (viaPosition) {
      this.debugViaPositions.push({ via: viaPosition });
    } else {
      return false;
    }
    const transitionRouteSolution = this.createTransitionRoute(
      transitionRoute.A,
      transitionRoute.B,
      viaPosition,
      transitionRoute.connectionName
    );
    const flatRouteSolution = this.createFlatRoute(
      flatRoute.A,
      flatRoute.B,
      viaPosition,
      transitionRoute.A,
      transitionRoute.B,
      flatRoute.connectionName
    );
    this.solvedRoutes.push(transitionRouteSolution, flatRouteSolution);
    return true;
  }
  /**
   * Main step method that attempts to solve the routes
   */
  _step() {
    if (!this.doRoutesCross(this.routes[0], this.routes[1])) {
      this.failed = true;
      this.error = "Can only solve routes that have a single transition crossing";
      return;
    }
    if (this.trySolve()) {
      this.solved = true;
      return;
    }
    this.failed = true;
  }
  /**
   * Visualization for debugging
   */
  visualize() {
    const graphics = {
      lines: [],
      points: [],
      rects: [],
      circles: []
    };
    graphics.rects.push({
      center: {
        x: (this.bounds.minX + this.bounds.maxX) / 2,
        y: (this.bounds.minY + this.bounds.maxY) / 2
      },
      width: this.bounds.maxX - this.bounds.minX,
      height: this.bounds.maxY - this.bounds.minY,
      stroke: "rgba(0, 0, 0, 0.5)",
      fill: "rgba(240, 240, 240, 0.1)",
      label: "PCB Bounds"
    });
    for (const route of this.routes) {
      graphics.points.push({
        x: route.A.x,
        y: route.A.y,
        label: `${route.connectionName} start (z=${route.A.z})`,
        color: "orange"
      });
      graphics.points.push({
        x: route.B.x,
        y: route.B.y,
        label: `${route.connectionName} end (z=${route.B.z})`,
        color: "orange"
      });
      graphics.lines.push({
        points: [route.A, route.B],
        strokeColor: "rgba(255, 0, 0, 0.5)",
        label: `${route.connectionName} direct`
      });
    }
    for (let i = 0; i < this.debugViaPositions.length; i++) {
      const { via } = this.debugViaPositions[i];
      graphics.circles.push({
        center: via,
        radius: this.viaDiameter / 2,
        fill: "rgba(255, 165, 0, 0.7)",
        stroke: "rgba(0, 0, 0, 0.5)",
        label: `Computed Via (attempt ${i + 1})`
      });
      const safetyMargin = this.viaDiameter / 2 + this.obstacleMargin;
      graphics.circles.push({
        center: via,
        radius: safetyMargin,
        stroke: "rgba(255, 165, 0, 0.7)",
        fill: "rgba(0, 0, 0, 0)",
        label: "Safety Margin"
      });
    }
    for (let si = 0; si < this.solvedRoutes.length; si++) {
      const route = this.solvedRoutes[si];
      const routeColor = si % 2 === 0 ? "rgba(0, 255, 0, 0.75)" : "rgba(255, 0, 255, 0.75)";
      for (let i = 0; i < route.route.length - 1; i++) {
        const pointA = route.route[i];
        const pointB = route.route[i + 1];
        graphics.lines.push({
          points: [pointA, pointB],
          strokeColor: routeColor,
          strokeDash: pointA.z !== route.route[0].z ? [0.2, 0.2] : void 0,
          strokeWidth: route.traceThickness,
          label: `${route.connectionName} z=${pointA.z}`
        });
      }
      for (const via of route.vias) {
        graphics.circles.push({
          center: via,
          radius: this.viaDiameter / 2,
          fill: "rgba(0, 0, 255, 0.8)",
          stroke: "black",
          label: "Solved Via"
        });
        graphics.circles.push({
          center: via,
          radius: this.viaDiameter / 2 + this.obstacleMargin,
          fill: "rgba(0, 0, 255, 0.3)",
          stroke: "black",
          label: "Via Margin"
        });
      }
    }
    return graphics;
  }
  /**
   * Get the solved routes
   */
  getSolvedRoutes() {
    return this.solvedRoutes;
  }
};

// lib/utils/getPortPairs.ts
var getPortPairMap = (nodeWithPortPoints) => {
  const portPairMap = /* @__PURE__ */ new Map();
  nodeWithPortPoints.portPoints.forEach((portPoint) => {
    if (!portPairMap.has(portPoint.connectionName)) {
      portPairMap.set(portPoint.connectionName, {
        start: portPoint,
        end: null,
        connectionName: portPoint.connectionName
      });
    } else {
      portPairMap.get(portPoint.connectionName).end = portPoint;
    }
  });
  return portPairMap;
};

// lib/utils/generateColorMapFromNodeWithPortPoints.ts
var generateColorMapFromNodeWithPortPoints = (nodeWithPortPoints, connMap) => {
  const colorMap = {};
  nodeWithPortPoints.portPoints.forEach((portPoint, i) => {
    colorMap[portPoint.connectionName] = `hsl(${i * 360 / nodeWithPortPoints.portPoints.length}, 100%, 50%)`;
  });
  return colorMap;
};

// lib/solvers/ViaPossibilitiesSolver/ViaPossibilitiesSolver2.ts
var ViaPossibilitiesSolver2 = class extends BaseSolver {
  bounds;
  maxViaCount;
  portPairMap;
  colorMap;
  nodeWidth;
  availableZ;
  hyperParameters;
  VIA_INTERSECTION_BUFFER_DISTANCE = 0.05;
  PLACEHOLDER_WALL_BUFFER_DISTANCE = 0.1;
  NEW_HEAD_WALL_BUFFER_DISTANCE = 0.05;
  unprocessedConnections;
  completedPaths = /* @__PURE__ */ new Map();
  placeholderPaths = /* @__PURE__ */ new Map();
  currentHead;
  currentConnectionName;
  currentPath;
  currentViaCount;
  constructor({
    nodeWithPortPoints,
    colorMap,
    hyperParameters
  }) {
    super();
    this.MAX_ITERATIONS = 1e5;
    this.colorMap = colorMap ?? generateColorMapFromNodeWithPortPoints(nodeWithPortPoints);
    this.maxViaCount = 5;
    this.bounds = getBoundsFromNodeWithPortPoints(nodeWithPortPoints);
    this.nodeWidth = this.bounds.maxX - this.bounds.minX;
    this.portPairMap = getPortPairMap(nodeWithPortPoints);
    this.stats.solutionsFound = 0;
    this.availableZ = nodeWithPortPoints.availableZ ?? [0, 1];
    this.hyperParameters = hyperParameters ?? {
      SHUFFLE_SEED: 0
    };
    this.unprocessedConnections = Array.from(this.portPairMap.keys()).sort();
    if (hyperParameters?.SHUFFLE_SEED) {
      this.unprocessedConnections = cloneAndShuffleArray(
        this.unprocessedConnections,
        hyperParameters.SHUFFLE_SEED
      );
    }
    for (const [connectionName, { start: start2, end }] of this.portPairMap.entries()) {
      if (start2.z === end.z) {
        const isVertical = Math.abs(start2.x - end.x) < 1e-9;
        const isHorizontal = Math.abs(start2.y - end.y) < 1e-9;
        if (isVertical || isHorizontal) {
          this.placeholderPaths.set(connectionName, [
            start2,
            this._padByPlaceholderWallBuffer(start2),
            this._padByPlaceholderWallBuffer(end),
            end
          ]);
        } else {
          this.placeholderPaths.set(connectionName, [start2, end]);
        }
      } else {
        const midX = (start2.x + end.x) / 2;
        const midY = (start2.y + end.y) / 2;
        const midStart = this._padByPlaceholderWallBuffer({
          x: midX,
          y: midY,
          z: start2.z
        });
        const midEnd = this._padByPlaceholderWallBuffer({
          x: midX,
          y: midY,
          z: end.z
        });
        this.placeholderPaths.set(connectionName, [
          start2,
          this._padByPlaceholderWallBuffer(start2),
          midStart,
          midEnd,
          this._padByPlaceholderWallBuffer(end),
          end
        ]);
      }
    }
    this.currentConnectionName = this.unprocessedConnections.pop();
    const start = this.portPairMap.get(this.currentConnectionName).start;
    this.currentHead = this._padByNewHeadWallBuffer(start);
    this.currentPath = [start, this.currentHead];
    this.currentViaCount = 0;
    this.placeholderPaths.delete(this.currentConnectionName);
  }
  _padByNewHeadWallBuffer(point) {
    return {
      x: clamp(
        point.x,
        this.bounds.minX + this.NEW_HEAD_WALL_BUFFER_DISTANCE,
        this.bounds.maxX - this.NEW_HEAD_WALL_BUFFER_DISTANCE
      ),
      y: clamp(
        point.y,
        this.bounds.minY + this.NEW_HEAD_WALL_BUFFER_DISTANCE,
        this.bounds.maxY - this.NEW_HEAD_WALL_BUFFER_DISTANCE
      ),
      z: point.z
    };
  }
  _padByPlaceholderWallBuffer(point) {
    return {
      x: clamp(
        point.x,
        this.bounds.minX + this.PLACEHOLDER_WALL_BUFFER_DISTANCE,
        this.bounds.maxX - this.PLACEHOLDER_WALL_BUFFER_DISTANCE
      ),
      y: clamp(
        point.y,
        this.bounds.minY + this.PLACEHOLDER_WALL_BUFFER_DISTANCE,
        this.bounds.maxY - this.PLACEHOLDER_WALL_BUFFER_DISTANCE
      ),
      z: point.z
    };
  }
  _step() {
    if (this.solved) return;
    const targetEnd = this.portPairMap.get(this.currentConnectionName).end;
    const proposedSegment = [this.currentHead, targetEnd];
    let closestIntersection = null;
    let intersectedSegmentZ = null;
    const checkIntersectionsWithPathMap = (pathMap) => {
      for (const path of pathMap.values()) {
        for (let i = 0; i < path.length - 1; i++) {
          const segment = [path[i], path[i + 1]];
          if (segment[0].x === segment[1].x && segment[0].y === segment[1].y) {
            continue;
          }
          if (segment[0].z !== this.currentHead.z) {
            continue;
          }
          const intersection = getSegmentIntersection(
            proposedSegment[0],
            proposedSegment[1],
            segment[0],
            segment[1]
          );
          if (intersection) {
            const distToIntersection = distance(this.currentHead, intersection);
            if (distToIntersection < 1e-6) continue;
            if (!closestIntersection || distToIntersection < closestIntersection.dist) {
              closestIntersection = {
                point: intersection,
                dist: distToIntersection
              };
              intersectedSegmentZ = segment[0].z;
            }
          }
        }
      }
    };
    checkIntersectionsWithPathMap(this.completedPaths);
    checkIntersectionsWithPathMap(this.placeholderPaths);
    const needsZChange = this.currentHead.z !== targetEnd.z;
    if (closestIntersection || needsZChange) {
      this.currentViaCount++;
      if (this.currentViaCount >= this.maxViaCount) {
        this.failed = true;
        return;
      }
    }
    if (closestIntersection) {
      let viaXY;
      const distToIntersection = closestIntersection.dist;
      if (distToIntersection <= this.VIA_INTERSECTION_BUFFER_DISTANCE + 1e-6) {
        viaXY = midpoint(this.currentHead, closestIntersection.point);
      } else {
        const intersectionPoint = closestIntersection.point;
        const vectorX = intersectionPoint.x - this.currentHead.x;
        const vectorY = intersectionPoint.y - this.currentHead.y;
        const ratio = (distToIntersection - this.VIA_INTERSECTION_BUFFER_DISTANCE) / distToIntersection;
        viaXY = {
          x: this.currentHead.x + vectorX * ratio,
          y: this.currentHead.y + vectorY * ratio
        };
      }
      const nextZ = this.availableZ.find((z) => z !== intersectedSegmentZ);
      if (nextZ === void 0) {
        console.error("Could not determine next Z level for via placement!");
        this.failed = true;
        return;
      }
      const viaPoint1 = { ...viaXY, z: this.currentHead.z };
      const viaPoint2 = { ...viaXY, z: nextZ };
      this.currentPath.push(viaPoint1, viaPoint2);
      this.currentHead = viaPoint2;
    } else if (needsZChange) {
      let viaXY;
      const distToTarget = distance(this.currentHead, targetEnd);
      if (distToTarget < this.VIA_INTERSECTION_BUFFER_DISTANCE) {
        viaXY = midpoint(this.currentHead, targetEnd);
      } else {
        const vectorX = targetEnd.x - this.currentHead.x;
        const vectorY = targetEnd.y - this.currentHead.y;
        const ratio = (distToTarget - this.VIA_INTERSECTION_BUFFER_DISTANCE) / distToTarget;
        viaXY = {
          x: this.currentHead.x + vectorX * ratio,
          y: this.currentHead.y + vectorY * ratio
        };
      }
      const nextZ = targetEnd.z;
      const viaPoint1 = { ...viaXY, z: this.currentHead.z };
      const viaPoint2 = { ...viaXY, z: nextZ };
      this.currentPath.push(viaPoint1, viaPoint2);
      this.currentHead = viaPoint2;
    } else {
      this.currentPath.push(targetEnd);
      this.completedPaths.set(this.currentConnectionName, this.currentPath);
      if (this.unprocessedConnections.length === 0) {
        this.solved = true;
        this.stats.solutionsFound = 1;
      } else {
        this.currentConnectionName = this.unprocessedConnections.pop();
        const { start } = this.portPairMap.get(this.currentConnectionName);
        this.currentHead = this._padByNewHeadWallBuffer(start);
        this.currentPath = [start, this.currentHead];
        this.currentViaCount = 0;
        this.placeholderPaths.delete(this.currentConnectionName);
      }
    }
  }
  visualize() {
    const graphics = {
      points: [],
      lines: [],
      circles: [],
      rects: [],
      title: "Via Possibilities Solver State",
      coordinateSystem: "cartesian"
    };
    const colorMap = this.colorMap;
    graphics.lines.push({
      points: [
        { x: this.bounds.minX, y: this.bounds.minY },
        { x: this.bounds.maxX, y: this.bounds.minY },
        { x: this.bounds.maxX, y: this.bounds.maxY },
        { x: this.bounds.minX, y: this.bounds.maxY },
        { x: this.bounds.minX, y: this.bounds.minY }
      ],
      strokeColor: "gray",
      strokeWidth: 0.01
    });
    for (const [connectionName, { start, end }] of this.portPairMap.entries()) {
      const color = this.colorMap[connectionName] ?? "black";
      graphics.points.push({
        x: start.x,
        y: start.y,
        color,
        label: `Port: ${connectionName} Start (z${start.z})`
      });
      graphics.points.push({
        x: end.x,
        y: end.y,
        color,
        label: `Port: ${connectionName} End (z${end.z})`
      });
    }
    const drawPath = (pathMap, labelPrefix) => {
      for (const [connectionName, path] of pathMap.entries()) {
        const color = colorMap[connectionName] ?? "black";
        for (let i = 0; i < path.length - 1; i++) {
          const p1 = path[i];
          const p2 = path[i + 1];
          if (p1.x === p2.x && p1.y === p2.y && p1.z !== p2.z) {
            graphics.circles.push({
              center: { x: p1.x, y: p1.y },
              radius: 0.3,
              // Diameter 0.6
              fill: safeTransparentize(color, 0.5),
              label: `${labelPrefix}: ${connectionName} Via (z${p1.z}->z${p2.z})`
            });
          } else {
            graphics.lines.push({
              points: [p1, p2],
              strokeColor: safeTransparentize(color, 0.5),
              strokeDash: p1.z === 0 ? void 0 : [0.1, 0.1],
              strokeWidth: 0.1,
              label: `${labelPrefix}: ${connectionName} (z${p1.z})`
            });
          }
        }
      }
    };
    drawPath(this.placeholderPaths, "Placeholder");
    drawPath(this.completedPaths, "Completed");
    if (this.currentPath && this.currentPath.length > 0) {
      const color = colorMap[this.currentConnectionName] ?? "orange";
      for (let i = 0; i < this.currentPath.length - 1; i++) {
        const p1 = this.currentPath[i];
        const p2 = this.currentPath[i + 1];
        if (p1.x === p2.x && p1.y === p2.y && p1.z !== p2.z) {
          graphics.circles.push({
            center: { x: p1.x, y: p1.y },
            radius: 0.3,
            fill: safeTransparentize(color, 0.5),
            label: `Current: ${this.currentConnectionName} Via (z${p1.z}->z${p2.z})`
          });
        } else {
          graphics.lines.push({
            points: [p1, p2],
            strokeColor: safeTransparentize(color, 0.5),
            strokeWidth: 0.15,
            // Thicker
            strokeDash: "2,2",
            // Dashed
            label: `Current: ${this.currentConnectionName} (z${p1.z})`
          });
        }
      }
      graphics.points.push({
        x: this.currentHead.x,
        y: this.currentHead.y,
        color: "green",
        label: `Current Head: ${this.currentConnectionName} (z${this.currentHead.z})`
      });
    }
    return graphics;
  }
};

// lib/utils/getIntraNodeCrossings.ts
var getIntraNodeCrossings = (node) => {
  let numSameLayerCrossings = 0;
  let pointPairs = [];
  const transitionPairPoints = [];
  let numEntryExitLayerChanges = 0;
  for (const A of node.portPoints) {
    if (pointPairs.some((p) => p.connectionName === A.connectionName)) {
      continue;
    }
    if (transitionPairPoints.some((p) => p.connectionName === A.connectionName)) {
      continue;
    }
    const pointPair = {
      connectionName: A.connectionName,
      z: A.z,
      points: [{ x: A.x, y: A.y, z: A.z }]
    };
    for (const B of node.portPoints) {
      if (A.connectionName !== B.connectionName) continue;
      if (A.x === B.x && A.y === B.y) continue;
      pointPair.points.push({ x: B.x, y: B.y, z: B.z });
    }
    if (pointPair.points.some((p) => p.z !== pointPair.z)) {
      numEntryExitLayerChanges++;
      transitionPairPoints.push(pointPair);
      continue;
    }
    pointPairs.push(pointPair);
  }
  pointPairs = pointPairs.filter((p) => p.points.length > 1);
  for (let i = 0; i < pointPairs.length; i++) {
    for (let j = i + 1; j < pointPairs.length; j++) {
      const pair1 = pointPairs[i];
      const pair2 = pointPairs[j];
      if (pair1.z === pair2.z && doSegmentsIntersect(
        pair1.points[0],
        pair1.points[1],
        pair2.points[0],
        pair2.points[1]
      )) {
        numSameLayerCrossings++;
      }
    }
  }
  let numTransitionPairCrossings = 0;
  for (let i = 0; i < transitionPairPoints.length; i++) {
    for (let j = i + 1; j < transitionPairPoints.length; j++) {
      const pair1 = transitionPairPoints[i];
      const pair2 = transitionPairPoints[j];
      if (doSegmentsIntersect(
        pair1.points[0],
        pair1.points[1],
        pair2.points[0],
        pair2.points[1]
      )) {
        numTransitionPairCrossings++;
      }
    }
  }
  return {
    numSameLayerCrossings,
    numEntryExitLayerChanges,
    numTransitionPairCrossings,
    numTransitions: transitionPairPoints.length
  };
};

// lib/solvers/HighDensitySolver/MultiHeadPolyLineIntraNodeSolver/getCentroidsFromInnerBoxIntersections.ts
var EPS = 1e-9;
function almostEqual(a, b, eps = EPS) {
  return Math.abs(a - b) < eps;
}
function pointKey(p, eps = EPS) {
  return `${Math.round(p.x / eps)}:${Math.round(p.y / eps)}`;
}
function cross(ax, ay, bx, by) {
  return ax * by - ay * bx;
}
function segmentIntersection(p, p2, q, q2) {
  const r = { x: p2.x - p.x, y: p2.y - p.y };
  const s = { x: q2.x - q.x, y: q2.y - q.y };
  const denom = cross(r.x, r.y, s.x, s.y);
  if (almostEqual(denom, 0)) return null;
  const qp = { x: q.x - p.x, y: q.y - p.y };
  const t = cross(qp.x, qp.y, s.x, s.y) / denom;
  const u = cross(qp.x, qp.y, r.x, r.y) / denom;
  if (t < -EPS || t > 1 + EPS || u < -EPS || u > 1 + EPS) return null;
  return { x: p.x + t * r.x, y: p.y + t * r.y };
}
function polygonArea(points) {
  let a = 0;
  for (let i = 0, n = points.length; i < n; ++i) {
    const j = (i + 1) % n;
    a += points[i].x * points[j].y - points[j].x * points[i].y;
  }
  return 0.5 * a;
}
function polygonCentroid(points) {
  let a = 0;
  let cx = 0;
  let cy = 0;
  for (let i = 0, n = points.length; i < n; ++i) {
    const j = (i + 1) % n;
    const crossVal = points[i].x * points[j].y - points[j].x * points[i].y;
    a += crossVal;
    cx += (points[i].x + points[j].x) * crossVal;
    cy += (points[i].y + points[j].y) * crossVal;
  }
  a *= 0.5;
  if (almostEqual(a, 0)) return null;
  cx /= 6 * a;
  cy /= 6 * a;
  return { x: cx, y: cy };
}
var Vertex = class {
  x;
  y;
  out;
  // Outgoing half-edge indices
  connectionNames;
  // Names of connections passing through this vertex
  constructor(x, y) {
    this.x = x;
    this.y = y;
    this.out = [];
    this.connectionNames = /* @__PURE__ */ new Set();
  }
};
var HalfEdge = class {
  orig;
  // Vertex index
  dest;
  // Vertex index
  twin;
  // Half-edge index
  next;
  // Half-edge index (around left face)
  visited;
  constructor(orig, dest) {
    this.orig = orig;
    this.dest = dest;
    this.twin = null;
    this.next = null;
    this.visited = false;
  }
};
function getCentroidsFromInnerBoxIntersections(rectangle, userSegments) {
  const rectEdges = [
    {
      start: { x: rectangle.minX, y: rectangle.minY },
      end: { x: rectangle.maxX, y: rectangle.minY }
    },
    {
      start: { x: rectangle.maxX, y: rectangle.minY },
      end: { x: rectangle.maxX, y: rectangle.maxY }
    },
    {
      start: { x: rectangle.maxX, y: rectangle.maxY },
      end: { x: rectangle.minX, y: rectangle.maxY }
    },
    {
      start: { x: rectangle.minX, y: rectangle.maxY },
      end: { x: rectangle.minX, y: rectangle.minY }
    }
  ];
  const segments = [...userSegments, ...rectEdges];
  const breakMap = segments.map(() => []);
  for (let i = 0; i < segments.length; ++i) {
    const s = segments[i];
    breakMap[i].push(s.start, s.end);
  }
  for (let i = 0; i < segments.length; ++i) {
    for (let j = i + 1; j < segments.length; ++j) {
      const p = segmentIntersection(
        segments[i].start,
        segments[i].end,
        segments[j].start,
        segments[j].end
      );
      if (p) {
        breakMap[i].push(p);
        breakMap[j].push(p);
      }
    }
  }
  const vertexId = /* @__PURE__ */ new Map();
  const vertices = [];
  function getVertexId(p) {
    const key = pointKey(p);
    if (!vertexId.has(key)) {
      const id = vertices.length;
      vertexId.set(key, id);
      vertices.push(new Vertex(p.x, p.y));
      return id;
    }
    return vertexId.get(key);
  }
  const undirectedEdges = [];
  for (let i = 0; i < segments.length; ++i) {
    const s = segments[i];
    const list = breakMap[i].slice();
    list.sort((p1, p2) => {
      const dx = s.end.x - s.start.x;
      const dy = s.end.y - s.start.y;
      const t1 = almostEqual(Math.abs(dx), 0) ? (p1.y - s.start.y) / dy : (p1.x - s.start.x) / dx;
      const t2 = almostEqual(Math.abs(dx), 0) ? (p2.y - s.start.y) / dy : (p2.x - s.start.x) / dx;
      return t1 - t2;
    });
    for (let k = 0; k < list.length - 1; ++k) {
      const p1 = list[k];
      const p2 = list[k + 1];
      const v1 = getVertexId(p1);
      const v2 = getVertexId(p2);
      if (v1 !== v2) {
        undirectedEdges.push([v1, v2]);
        if (s.connectionName) {
          vertices[v1].connectionNames.add(s.connectionName);
          vertices[v2].connectionNames.add(s.connectionName);
        }
      }
    }
  }
  const halfEdges = [];
  for (const [v1, v2] of undirectedEdges) {
    const he1 = new HalfEdge(v1, v2);
    const he2 = new HalfEdge(v2, v1);
    he1.twin = halfEdges.length + 1;
    he2.twin = halfEdges.length;
    const id1 = halfEdges.length;
    halfEdges.push(he1, he2);
    vertices[v1].out.push(id1);
    vertices[v2].out.push(id1 + 1);
  }
  for (let vid = 0; vid < vertices.length; ++vid) {
    const v = vertices[vid];
    v.out.sort((e1Idx, e2Idx) => {
      const e1 = halfEdges[e1Idx];
      const e2 = halfEdges[e2Idx];
      const d1 = vertices[e1.dest];
      const d2 = vertices[e2.dest];
      const a1 = Math.atan2(d1.y - v.y, d1.x - v.x);
      const a2 = Math.atan2(d2.y - v.y, d2.x - v.x);
      return a1 - a2;
    });
    const m = v.out.length;
    for (let i = 0; i < m; ++i) {
      const heOutIdx = v.out[i];
      const hePrevIdx = v.out[(i - 1 + m) % m];
      const heOut = halfEdges[heOutIdx];
      if (heOut.twin !== null) {
        halfEdges[heOut.twin].next = hePrevIdx;
      }
    }
  }
  const centroids = [];
  const faces = [];
  for (let h = 0; h < halfEdges.length; ++h) {
    if (halfEdges[h].visited) continue;
    let walk = h;
    const poly = [];
    const faceEdges = [];
    do {
      if (walk === null) break;
      const currentEdge = halfEdges[walk];
      currentEdge.visited = true;
      poly.push(vertices[currentEdge.orig]);
      faceEdges.push(walk);
      walk = currentEdge.next;
    } while (walk !== null && walk !== h && !halfEdges[walk].visited);
    if (poly.length < 3) continue;
    const area = polygonArea(poly);
    if (area > EPS) {
      const c = polygonCentroid(poly);
      if (c) {
        centroids.push(c);
        faces.push({
          vertices: poly.map((v) => ({
            x: v.x,
            y: v.y,
            connectionNames: v.connectionNames.size > 0 ? v.connectionNames : void 0
          })),
          centroid: c
        });
      }
    }
  }
  return { centroids, faces, allVertices: vertices };
}

// lib/solvers/HighDensitySolver/MultiHeadPolyLineIntraNodeSolver/generateBinaryCombinations.ts
function generateBinaryCombinations(oneCount, length) {
  if (oneCount > length) {
    throw new Error("oneCount cannot be greater than length");
  }
  if (oneCount < 0 || length < 0) {
    throw new Error("oneCount and length must be non-negative");
  }
  const result = [];
  function generateCombinations(current, onesLeft, position) {
    if (position === length) {
      if (onesLeft === 0) {
        result.push([...current]);
      }
      return;
    }
    current[position] = 0;
    generateCombinations(current, onesLeft, position + 1);
    if (onesLeft > 0) {
      current[position] = 1;
      generateCombinations(current, onesLeft - 1, position + 1);
    }
  }
  generateCombinations(Array(length).fill(0), oneCount, 0);
  return result;
}

// lib/solvers/HighDensitySolver/MultiHeadPolyLineIntraNodeSolver/getPossibleInitialViaPositions.ts
var getPossibleInitialViaPositions = (params) => {
  const { bounds, portPairsEntries, viaCountVariants } = params;
  const { centroids } = getCentroidsFromInnerBoxIntersections(
    bounds,
    portPairsEntries.map(([_, portPair]) => portPair)
  );
  const result = [];
  for (const viaCountVariant of viaCountVariants) {
    const viaCount = viaCountVariant.reduce((acc, count) => acc + count, 0);
    let viaPositionSource = centroids;
    if (centroids.length < viaCount) {
      viaPositionSource = [];
      const rows = Math.ceil(Math.sqrt(viaCount));
      const cols = rows;
      for (let r = 0; r < rows; r++) {
        for (let c = 0; c < cols; c++) {
          viaPositionSource.push({
            x: bounds.minX + (c + 1) / (cols + 1) * (bounds.maxX - bounds.minX),
            y: bounds.minY + (r + 1) / (rows + 1) * (bounds.maxY - bounds.minY)
          });
        }
      }
    }
    const viaPositionVariants = generateBinaryCombinations(
      viaCount,
      viaPositionSource.length
    );
    for (const viaPositionVariant of viaPositionVariants) {
      const viaPositions = [];
      for (let i = 0; i < viaPositionVariant.length; i++) {
        if (viaPositionVariant[i] === 1) {
          viaPositions.push(viaPositionSource[i]);
        }
      }
      result.push({
        viaPositions,
        viaCountVariant
      });
    }
  }
  return result;
};

// lib/solvers/HighDensitySolver/MultiHeadPolyLineIntraNodeSolver/getEveryPossibleOrdering.ts
var getEveryPossibleOrdering = (ar) => {
  if (ar.length === 0) {
    return [[]];
  }
  const result = [];
  for (let i = 0; i < ar.length; i++) {
    const firstElement = ar[i];
    const rest = [...ar.slice(0, i), ...ar.slice(i + 1)];
    const permutationsOfRest = getEveryPossibleOrdering(rest);
    for (const perm of permutationsOfRest) {
      result.push([firstElement, ...perm]);
    }
  }
  return result;
};

// lib/solvers/HighDensitySolver/MultiHeadPolyLineIntraNodeSolver/createSymmetricArray.ts
function createSymmetricArray(length, oneCount) {
  const result = new Array(length).fill(0);
  if (oneCount === 0) return result;
  if (oneCount === length) return result.fill(1);
  if (oneCount <= length / 2) {
    const gap = Math.floor(length / oneCount);
    const start = Math.floor((length - (gap * (oneCount - 1) + 1)) / 2);
    for (let i = 0; i < oneCount; i++) {
      result[start + i * gap] = 1;
    }
  } else {
    const zeroCount = length - oneCount;
    const gap = Math.floor(length / zeroCount);
    const start = Math.floor((length - (gap * (zeroCount - 1) + 1)) / 2);
    result.fill(1);
    for (let i = 0; i < zeroCount; i++) {
      result[start + i * gap] = 0;
    }
  }
  return result;
}

// lib/solvers/HighDensitySolver/MultiHeadPolyLineIntraNodeSolver/constructMiddlePointsWithViaPositions.ts
var constructMiddlePointsWithViaPositions = (params) => {
  const {
    start,
    end,
    segmentsPerPolyline,
    viaPositions,
    viaCount,
    availableZ
  } = params;
  const viaIndices = createSymmetricArray(segmentsPerPolyline, viaCount);
  const middlePoints = viaIndices.map(() => null);
  let viasAdded = 0;
  let lastZ = start.z1;
  const availableZOffset = availableZ.indexOf(start.z1);
  for (let i = 0; i < viaIndices.length; i++) {
    if (viaIndices[i] === 1) {
      const nextZ = availableZ[(availableZOffset + viasAdded + 1) % availableZ.length];
      middlePoints[i] = {
        ...viaPositions[viasAdded],
        z1: lastZ,
        z2: nextZ
      };
      lastZ = nextZ;
      viasAdded++;
    }
  }
  let left = start;
  for (let i = 0; i < middlePoints.length; i++) {
    if (middlePoints[i]) {
      left = middlePoints[i];
      continue;
    }
    let right = end;
    let rightIndex = middlePoints.length;
    for (let u = i + 1; u < middlePoints.length; u++) {
      if (middlePoints[u]) {
        right = middlePoints[u];
        rightIndex = u;
        break;
      }
    }
    const N = rightIndex - i;
    const dx = right.x - left.x;
    const dy = right.y - left.y;
    for (let t = 1 / (N + 1), ti = 0; ; t += 1 / (N + 1), ti++) {
      if (i + ti === rightIndex) break;
      middlePoints[i + ti] = {
        x: left.x + dx * t,
        y: left.y + dy * t,
        z1: left.z2,
        z2: left.z2
      };
    }
  }
  return middlePoints;
};

// lib/solvers/HighDensitySolver/MultiHeadPolyLineIntraNodeSolver/getEveryCombinationFromChoiceArray.ts
var getEveryCombinationFromChoiceArray = (choiceArray) => {
  if (!choiceArray || choiceArray.length === 0) {
    return [[]];
  }
  let results = [[]];
  for (const choiceSet of choiceArray) {
    const newResults = [];
    for (const combination of results) {
      for (const choice of choiceSet) {
        newResults.push([...combination, choice]);
      }
    }
    results = newResults;
  }
  return results;
};

// lib/solvers/HighDensitySolver/MultiHeadPolyLineIntraNodeSolver/computeViaCountVariants.ts
var computeViaCountVariants = (portPairsEntries, segmentsPerPolyline, maxViaCount, minViaCount) => {
  const possibleViaCountsPerPolyline = [];
  for (const [, portPair] of portPairsEntries) {
    const needsLayerChange = portPair.start.z1 !== portPair.end.z1;
    const possibleCounts = [];
    for (let i = 0; i <= segmentsPerPolyline; i++) {
      const isOdd = i % 2 !== 0;
      if (needsLayerChange && isOdd) {
        possibleCounts.push(i);
      } else if (!needsLayerChange && !isOdd) {
        possibleCounts.push(i);
      }
    }
    possibleViaCountsPerPolyline.push(possibleCounts);
  }
  if (possibleViaCountsPerPolyline.length === 0) {
    return [[]];
  }
  let variants = getEveryCombinationFromChoiceArray(
    possibleViaCountsPerPolyline
  ).filter((variant) => {
    for (let i = 0; i < variant.length; i++) {
      const viaCount = variant.reduce((acc, count) => acc + count, 0);
      if (viaCount < minViaCount) return false;
    }
    return true;
  });
  variants = variants.filter((variant) => {
    for (let i = 0; i < portPairsEntries.length; i++) {
      const [, portPair1] = portPairsEntries[i];
      if (portPair1.start.z1 !== portPair1.start.z2) {
        if (variant[i] === 0) return false;
      }
    }
    return true;
  });
  variants = variants.filter((variant) => {
    for (let i = 0; i < portPairsEntries.length; i++) {
      const [, portPair1] = portPairsEntries[i];
      if (portPairsEntries[i][1].start.z1 !== portPairsEntries[i][1].start.z2)
        continue;
      for (let j = i + 1; j < portPairsEntries.length; j++) {
        if (portPairsEntries[j][1].start.z1 !== portPairsEntries[j][1].start.z2)
          continue;
        const [, portPair2] = portPairsEntries[j];
        if (portPair1.start.z1 === portPair1.end.z1 && portPair2.start.z1 === portPair2.end.z1 && portPair1.start.z1 === portPair2.start.z1 && doSegmentsIntersect(
          portPair1.start,
          portPair1.end,
          portPair2.start,
          portPair2.end
        )) {
          if (variant[i] + variant[j] < 2) return false;
        }
      }
    }
    return true;
  });
  variants = variants.filter((variant) => {
    const viaCount = variant.reduce((acc, count) => acc + count, 0);
    if (viaCount > maxViaCount) return false;
    return true;
  });
  return variants;
};

// lib/solvers/HighDensitySolver/MultiHeadPolyLineIntraNodeSolver/withinBounds.ts
var withinBounds = (point, bounds, padding = 0) => {
  return point.x >= bounds.minX + padding && point.x <= bounds.maxX - padding && point.y >= bounds.minY + padding && point.y <= bounds.maxY - padding;
};

// lib/solvers/HighDensitySolver/MultiHeadPolyLineIntraNodeSolver/detectMultiConnectionClosedFacesWithoutVias.ts
var EPS2 = 1e-9;
function almostEqual2(a, b) {
  return Math.abs(a - b) < EPS2;
}
function pointKey2(p) {
  return `${Math.round(p.x / EPS2)}:${Math.round(p.y / EPS2)}`;
}
function cross2(ax, ay, bx, by) {
  return ax * by - ay * bx;
}
function segmentIntersection2(p1, p2, q1, q2) {
  const r = { x: p2.x - p1.x, y: p2.y - p1.y };
  const s = { x: q2.x - q1.x, y: q2.y - q1.y };
  const rxs = cross2(r.x, r.y, s.x, s.y);
  const qp = { x: q1.x - p1.x, y: q1.y - p1.y };
  if (almostEqual2(rxs, 0)) {
    return null;
  }
  const t = cross2(qp.x, qp.y, s.x, s.y) / rxs;
  const u = cross2(qp.x, qp.y, r.x, r.y) / rxs;
  if (t >= -EPS2 && t <= 1 + EPS2 && u >= -EPS2 && u <= 1 + EPS2) {
    return { x: p1.x + t * r.x, y: p1.y + t * r.y };
  }
  return null;
}
function isOnSegment(p, a, b) {
  const d_ap = Math.hypot(p.x - a.x, p.y - a.y);
  const d_pb = Math.hypot(p.x - b.x, p.y - b.y);
  const d_ab = Math.hypot(a.x - b.x, a.y - b.y);
  return almostEqual2(d_ap + d_pb, d_ab);
}
function detectMultiConnectionClosedFacesWithoutVias(polyLines, bounds) {
  const allSegments = [];
  const viaPoints = /* @__PURE__ */ new Map();
  for (const polyLine of polyLines) {
    const path = [polyLine.start, ...polyLine.mPoints, polyLine.end];
    for (let i = 0; i < path.length - 1; i++) {
      const p1 = path[i];
      const p2 = path[i + 1];
      const layer = p1.z2;
      allSegments.push({
        start: { x: p1.x, y: p1.y },
        end: { x: p2.x, y: p2.y },
        connectionName: polyLine.connectionName,
        layer
      });
      if (p1.z1 !== p1.z2) {
        const key = pointKey2(p1);
        if (!viaPoints.has(key)) {
          viaPoints.set(key, {
            point: p1,
            connectionName: polyLine.connectionName
          });
        }
      }
    }
    const lastPoint = path[path.length - 1];
    if (lastPoint.z1 !== lastPoint.z2) {
      const key = pointKey2(lastPoint);
      if (!viaPoints.has(key)) {
        viaPoints.set(key, {
          point: lastPoint,
          connectionName: polyLine.connectionName
        });
      }
    }
  }
  const boundaryLayer = 0;
  const boundarySegments = [
    {
      start: { x: bounds.minX, y: bounds.minY },
      end: { x: bounds.maxX, y: bounds.minY },
      connectionName: null,
      layer: boundaryLayer
    },
    {
      start: { x: bounds.maxX, y: bounds.minY },
      end: { x: bounds.maxX, y: bounds.maxY },
      connectionName: null,
      layer: boundaryLayer
    },
    {
      start: { x: bounds.maxX, y: bounds.maxY },
      end: { x: bounds.minX, y: bounds.maxY },
      connectionName: null,
      layer: boundaryLayer
    },
    {
      start: { x: bounds.minX, y: bounds.maxY },
      end: { x: bounds.minX, y: bounds.minY },
      connectionName: null,
      layer: boundaryLayer
    }
  ];
  allSegments.push(...boundarySegments);
  const verticesMap = /* @__PURE__ */ new Map();
  let vertexIdCounter = 0;
  function getOrCreateVertex(p, connectionName) {
    const key = pointKey2(p);
    let vertex = verticesMap.get(key);
    if (!vertex) {
      const isVia = viaPoints.has(key);
      vertex = {
        id: vertexIdCounter++,
        x: p.x,
        y: p.y,
        isVia,
        connectionNames: /* @__PURE__ */ new Set(),
        outgoingEdges: []
      };
      verticesMap.set(key, vertex);
      if (isVia && viaPoints.get(key)) {
        vertex.connectionNames.add(viaPoints.get(key).connectionName);
      }
    }
    if (connectionName) {
      vertex.connectionNames.add(connectionName);
    }
    return vertex;
  }
  for (const seg of allSegments) {
    getOrCreateVertex(seg.start, seg.connectionName);
    getOrCreateVertex(seg.end, seg.connectionName);
  }
  const segmentBreakpoints = /* @__PURE__ */ new Map();
  for (const segment of allSegments) {
    segmentBreakpoints.set(segment, []);
  }
  for (let i = 0; i < allSegments.length; i++) {
    for (let j = i + 1; j < allSegments.length; j++) {
      if (allSegments[i].layer !== allSegments[j].layer) continue;
      const intersection = segmentIntersection2(
        allSegments[i].start,
        allSegments[i].end,
        allSegments[j].start,
        allSegments[j].end
      );
      if (intersection) {
        getOrCreateVertex(intersection);
        if (isOnSegment(intersection, allSegments[i].start, allSegments[i].end)) {
          segmentBreakpoints.get(allSegments[i]).push(intersection);
        }
        if (isOnSegment(intersection, allSegments[j].start, allSegments[j].end)) {
          segmentBreakpoints.get(allSegments[j]).push(intersection);
        }
      }
    }
  }
  const halfEdges = [];
  let edgeIdCounter = 0;
  for (const segment of allSegments) {
    const pointsOnSegment = [
      segment.start,
      ...segmentBreakpoints.get(segment),
      segment.end
    ];
    pointsOnSegment.sort((a, b) => {
      const dx = segment.end.x - segment.start.x;
      const dy = segment.end.y - segment.start.y;
      if (Math.abs(dx) > Math.abs(dy)) {
        return (a.x - segment.start.x) / dx - (b.x - segment.start.x) / dx;
      } else {
        return Math.abs(dy) < EPS2 ? 0 : (a.y - segment.start.y) / dy - (b.y - segment.start.y) / dy;
      }
    });
    const uniquePoints = [];
    if (pointsOnSegment.length > 0) {
      uniquePoints.push(pointsOnSegment[0]);
      for (let i = 1; i < pointsOnSegment.length; i++) {
        if (!almostEqual2(pointsOnSegment[i].x, pointsOnSegment[i - 1].x) || !almostEqual2(pointsOnSegment[i].y, pointsOnSegment[i - 1].y)) {
          uniquePoints.push(pointsOnSegment[i]);
        }
      }
    }
    for (let i = 0; i < uniquePoints.length - 1; i++) {
      const p1 = uniquePoints[i];
      const p2 = uniquePoints[i + 1];
      const v1 = getOrCreateVertex(p1, segment.connectionName);
      const v2 = getOrCreateVertex(p2, segment.connectionName);
      if (v1 === v2) continue;
      const edge1 = {
        id: edgeIdCounter++,
        origin: v1,
        twin: null,
        // Will be set later
        next: null,
        // Will be set later
        face: null,
        // Will be set later
        connectionName: segment.connectionName,
        layer: segment.layer,
        visited: false
      };
      const edge2 = {
        id: edgeIdCounter++,
        origin: v2,
        twin: edge1,
        next: null,
        face: null,
        connectionName: segment.connectionName,
        // Twin carries same info
        layer: segment.layer,
        visited: false
      };
      edge1.twin = edge2;
      halfEdges.push(edge1, edge2);
      v1.outgoingEdges.push(edge1);
      v2.outgoingEdges.push(edge2);
    }
  }
  for (const vertex of verticesMap.values()) {
    vertex.outgoingEdges.sort((e1, e2) => {
      const p1 = e1.twin.origin;
      const p2 = e2.twin.origin;
      const angle1 = Math.atan2(p1.y - vertex.y, p1.x - vertex.x);
      const angle2 = Math.atan2(p2.y - vertex.y, p2.x - vertex.x);
      return angle1 - angle2;
    });
    const numEdges = vertex.outgoingEdges.length;
    for (let i = 0; i < numEdges; i++) {
      const currentEdge = vertex.outgoingEdges[i];
      const prevEdge = vertex.outgoingEdges[(i - 1 + numEdges) % numEdges];
      if (currentEdge.twin) {
        currentEdge.twin.next = prevEdge;
      }
    }
  }
  const faces = [];
  let faceIdCounter = 0;
  let outerFace = null;
  let maxArea = -Infinity;
  for (const edge of halfEdges) {
    if (edge.visited) continue;
    const face = {
      id: faceIdCounter++,
      outerComponent: edge,
      innerComponents: [],
      isOuterFace: false
      // Assume internal first
    };
    faces.push(face);
    let currentEdge = edge;
    const faceEdges = [];
    const faceVertices = [];
    const faceConnectionNames = /* @__PURE__ */ new Set();
    let faceArea = 0;
    do {
      if (!currentEdge || currentEdge.visited) {
        console.warn(
          "Face traversal encountered visited edge or null, breaking loop.",
          face.id
        );
        faceEdges.length = 0;
        break;
      }
      currentEdge.visited = true;
      currentEdge.face = face;
      faceEdges.push(currentEdge);
      faceVertices.push(currentEdge.origin);
      if (currentEdge.connectionName !== null) {
        faceConnectionNames.add(currentEdge.connectionName);
      }
      const p1 = currentEdge.origin;
      const p2 = currentEdge.twin.origin;
      faceArea += p1.x * p2.y - p2.x * p1.y;
      currentEdge = currentEdge.next;
    } while (currentEdge !== edge && currentEdge !== null);
    if (currentEdge !== edge) {
      console.warn(`Face ${face.id} did not close properly.`);
      faces.pop();
      faceIdCounter--;
      continue;
    }
    faceArea = 0.5 * Math.abs(faceArea);
    if (faceArea > maxArea) {
      maxArea = faceArea;
      if (outerFace) outerFace.isOuterFace = false;
      outerFace = face;
      face.isOuterFace = true;
    }
    if (!face.isOuterFace && faceEdges.length > 0) {
      const actualConnectionNames = [...faceConnectionNames].filter(
        (name) => name !== null
      );
      if (actualConnectionNames.length > 1) {
        let viaFoundOnFace = false;
        for (const vertex of faceVertices) {
          if (vertex.isVia) {
            viaFoundOnFace = true;
            break;
          }
        }
        if (!viaFoundOnFace) {
          return true;
        }
      }
    }
  }
  return false;
}

// lib/solvers/HighDensitySolver/MultiHeadPolyLineIntraNodeSolver/MultiHeadPolyLineIntraNodeSolver.ts
var MultiHeadPolyLineIntraNodeSolver = class extends BaseSolver {
  nodeWithPortPoints;
  colorMap;
  hyperParameters;
  connMap;
  candidates;
  bounds;
  solvedRoutes = [];
  unsolvedConnections = [];
  SEGMENTS_PER_POLYLINE;
  cellSize;
  MAX_CANDIDATES = 5e4;
  viaDiameter = 0.6;
  obstacleMargin = 0.1;
  traceWidth = 0.15;
  availableZ = [];
  uniqueConnections = 0;
  BOUNDARY_PADDING;
  lastCandidate = null;
  maxViaCount;
  minViaCount;
  phase = "setup";
  progress = 0;
  constructor(params) {
    super();
    this.MAX_ITERATIONS = 1e4;
    this.nodeWithPortPoints = params.nodeWithPortPoints;
    this.colorMap = params.colorMap ?? generateColorMapFromNodeWithPortPoints(params.nodeWithPortPoints);
    this.hyperParameters = params.hyperParameters ?? {};
    this.SEGMENTS_PER_POLYLINE = params.hyperParameters?.SEGMENTS_PER_POLYLINE ?? 3;
    this.BOUNDARY_PADDING = params.hyperParameters?.BOUNDARY_PADDING ?? 0.05;
    this.connMap = params.connMap;
    this.cellSize = this.nodeWithPortPoints.width / 1024;
    this.candidates = [];
    this.availableZ = this.nodeWithPortPoints.availableZ ?? [0, 1];
    this.bounds = {
      minX: this.nodeWithPortPoints.center.x - this.nodeWithPortPoints.width / 2,
      maxX: this.nodeWithPortPoints.center.x + this.nodeWithPortPoints.width / 2,
      minY: this.nodeWithPortPoints.center.y - this.nodeWithPortPoints.height / 2,
      maxY: this.nodeWithPortPoints.center.y + this.nodeWithPortPoints.height / 2
    };
    const areaInsideNode = this.nodeWithPortPoints.width * this.nodeWithPortPoints.height;
    const areaPerVia = (this.viaDiameter + this.obstacleMargin * 2 + this.traceWidth / 2) ** 2;
    const uniqueConnections = new Set(
      this.nodeWithPortPoints.portPoints.map((pp) => pp.connectionName)
    ).size;
    this.uniqueConnections = uniqueConnections;
    const { numSameLayerCrossings, numTransitions } = getIntraNodeCrossings(
      this.nodeWithPortPoints
    );
    this.minViaCount = numSameLayerCrossings * 2 + numTransitions;
    this.maxViaCount = Math.min(
      Math.floor(areaInsideNode / areaPerVia),
      Math.ceil(uniqueConnections * 1.5)
    );
    if (this.minViaCount > this.SEGMENTS_PER_POLYLINE * (uniqueConnections / 2)) {
      this.failed = true;
      this.error = `Not possible to solve problem with given SEGMENTS_PER_POLYLINE (${this.SEGMENTS_PER_POLYLINE}), atleast ${this.minViaCount} vias are required`;
      return;
    }
    if (this.maxViaCount > this.SEGMENTS_PER_POLYLINE) {
      this.maxViaCount = this.SEGMENTS_PER_POLYLINE;
    }
    if (this.maxViaCount < this.minViaCount) {
      this.maxViaCount = this.minViaCount;
    }
  }
  /**
   * minGaps is a list of distances representing the "gap" between segments
   * on each layer.
   *
   * Each minGaps number represents the gap for a polyline pair, for example if
   * you have 3 polylines, you would have 3 minGaps...
   *
   * [ p1 -> p2 , p1 -> p3, p2 -> p3 ]
   */
  computeMinGapBtwPolyLines(polyLines) {
    const minGaps = [];
    const polyLineSegmentsByLayer = [];
    const polyLineVias = [];
    for (let i = 0; i < polyLines.length; i++) {
      const polyLine = polyLines[i];
      const path = [polyLine.start, ...polyLine.mPoints, polyLine.end];
      const segmentsByLayer = new Map(
        this.availableZ.map((z) => [z, []])
      );
      for (let i2 = 0; i2 < path.length - 1; i2++) {
        const segment = [path[i2], path[i2 + 1]];
        segmentsByLayer.get(segment[0].z2).push(segment);
      }
      polyLineSegmentsByLayer.push(segmentsByLayer);
      polyLineVias.push(path.filter((p) => p.z1 !== p.z2));
    }
    for (let i = 0; i < polyLines.length; i++) {
      const path1SegmentsByLayer = polyLineSegmentsByLayer[i];
      const path1Vias = polyLineVias[i];
      for (let j = i + 1; j < polyLines.length; j++) {
        if (this.connMap?.areIdsConnected(
          polyLines[i].connectionName,
          polyLines[j].connectionName
        )) {
          continue;
        }
        const path2SegmentsByLayer = polyLineSegmentsByLayer[j];
        const path2Vias = polyLineVias[j];
        let minGap = 1;
        for (const zLayer of this.availableZ) {
          const path1Segments = path1SegmentsByLayer.get(zLayer) ?? [];
          const path2Segments = path2SegmentsByLayer.get(zLayer) ?? [];
          for (const segment1 of path1Segments) {
            for (const segment2 of path2Segments) {
              minGap = Math.min(
                minGap,
                segmentToSegmentMinDistance(
                  segment1[0],
                  segment1[1],
                  segment2[0],
                  segment2[1]
                ) - this.traceWidth
              );
            }
          }
          for (const via of path1Vias) {
            for (const segment of path2Segments) {
              minGap = Math.min(
                minGap,
                pointToSegmentDistance(via, segment[0], segment[1]) - this.traceWidth / 2 - this.viaDiameter / 2
              );
            }
          }
          for (const via of path2Vias) {
            for (const segment of path1Segments) {
              minGap = Math.min(
                minGap,
                pointToSegmentDistance(via, segment[0], segment[1]) - this.traceWidth / 2 - this.viaDiameter / 2
              );
            }
          }
          for (const via1 of path1Vias) {
            for (const via2 of path2Vias) {
              minGap = Math.min(minGap, distance(via1, via2) - this.viaDiameter);
            }
          }
        }
        minGaps.push(minGap);
      }
    }
    return minGaps;
  }
  insertCandidate(candidate) {
    let low = 0;
    let high = this.candidates.length - 1;
    while (low <= high) {
      const mid = Math.floor((low + high) / 2);
      if (this.candidates[mid].f < candidate.f) {
        low = mid + 1;
      } else {
        high = mid - 1;
      }
    }
    this.candidates.splice(low, 0, candidate);
  }
  /**
   * Unlike most A* solvers with one initial candidate, we create a candidate
   * for each configuration of vias we want to test, this way when computing
   * neighbors we never consider changing layers
   */
  setupInitialPolyLines() {
    const portPairs = /* @__PURE__ */ new Map();
    this.nodeWithPortPoints.portPoints.forEach((portPoint) => {
      if (!portPairs.has(portPoint.connectionName)) {
        portPairs.set(portPoint.connectionName, {
          start: {
            ...portPoint,
            z1: portPoint.z ?? 0,
            z2: portPoint.z ?? 0
          },
          end: null
        });
      } else {
        portPairs.get(portPoint.connectionName).end = {
          ...portPoint,
          z1: portPoint.z ?? 0,
          z2: portPoint.z ?? 0
        };
      }
    });
    for (const [connectionName, portPair] of portPairs.entries()) {
      if (portPair.end === null) {
        portPairs.delete(connectionName);
      }
    }
    if (portPairs.size === 0) {
      this.failed = true;
      this.error = "No port pairs found, can't solve";
      return;
    }
    const portPairsEntries = Array.from(portPairs.entries());
    const viaCountVariants = computeViaCountVariants(
      portPairsEntries,
      this.SEGMENTS_PER_POLYLINE,
      this.maxViaCount,
      this.minViaCount
    );
    const possibleViaPositions = getPossibleInitialViaPositions({
      portPairsEntries,
      viaCountVariants,
      bounds: this.bounds
    });
    const possibleViaPositionsWithReorderings = [];
    for (const { viaCountVariant, viaPositions } of possibleViaPositions) {
      const viaPositionsWithReorderings = getEveryPossibleOrdering(viaPositions);
      for (const viaPositions2 of viaPositionsWithReorderings) {
        possibleViaPositionsWithReorderings.push({
          viaCountVariant,
          viaPositions: viaPositions2
        });
      }
    }
    for (const {
      viaPositions,
      viaCountVariant
    } of possibleViaPositionsWithReorderings) {
      const polyLines = [];
      let viaPositionIndicesUsed = 0;
      for (let i = 0; i < portPairsEntries.length; i++) {
        const [connectionName, portPair] = portPairsEntries[i];
        const viaCount = viaCountVariant[i];
        const viaPositionsForPolyline = viaPositions.slice(
          viaPositionIndicesUsed,
          viaPositionIndicesUsed + viaCount
        );
        const middlePoints = constructMiddlePointsWithViaPositions({
          start: portPair.start,
          end: portPair.end,
          segmentsPerPolyline: this.SEGMENTS_PER_POLYLINE,
          viaPositions: viaPositionsForPolyline,
          viaCount,
          availableZ: this.availableZ
        });
        viaPositionIndicesUsed += viaCount;
        polyLines.push({
          connectionName,
          start: portPair.start,
          end: portPair.end,
          mPoints: middlePoints
        });
      }
      const hasClosedSameLayerFace = detectMultiConnectionClosedFacesWithoutVias(polyLines, this.bounds);
      if (hasClosedSameLayerFace) continue;
      const minGaps = this.computeMinGapBtwPolyLines(polyLines);
      const h = this.computeH({ minGaps, forces: [] });
      const newCandidate = {
        polyLines,
        g: 0,
        h,
        f: h,
        viaCount: viaCountVariant.reduce((acc, count) => acc + count, 0),
        minGaps
        // hasClosedSameLayerFace
      };
      if (this.checkIfSolved(newCandidate)) {
        this.candidates = [newCandidate];
        return;
      }
      this.candidates.push(newCandidate);
      if (this.candidates.length > this.MAX_CANDIDATES) {
        return;
      }
    }
    this.candidates.sort((a, b) => a.f - b.f);
  }
  /**
   * g is the cost of each candidate, we consider complexity (deviation from
   * the straight line path for # of operations). This means g increases by
   * 1 from the parent for each operation
   */
  computeG(polyLines, candidate) {
    return candidate.g + 5e-6 + candidate.viaCount * 5e-6 * 100;
  }
  /**
   * h is the heuristic cost of each candidate.
   */
  computeH(candidate) {
    let totalForceMagnitude = 0;
    for (const force of candidate.forces ?? []) {
      for (const forceMap of force) {
        for (const force2 of forceMap.values()) {
          totalForceMagnitude += force2.fx * force2.fx + force2.fy * force2.fy;
        }
      }
    }
    return totalForceMagnitude;
  }
  getNeighbors(candidate) {
    const { polyLines } = candidate;
    const numPolyLines = polyLines.length;
    const FORCE_MAGNITUDE = 0.02;
    const VIA_FORCE_MULTIPLIER = 2;
    const INSIDE_VIA_FORCE_MULTIPLIER = 4;
    const SEGMENT_FORCE_MULTIPLIER = 1;
    const FORCE_DECAY_RATE = 6;
    const BOUNDARY_FORCE_STRENGTH = 8e-3;
    const EPSILON4 = 1e-6;
    const forces = Array.from(
      { length: numPolyLines },
      (_, i) => Array.from({ length: polyLines[i].mPoints.length }, () => /* @__PURE__ */ new Map())
    );
    const addForceContribution = (targetLineIndex, targetPointIndexInFullPath, sourceId, fx, fy) => {
      if (targetPointIndexInFullPath > 0 && targetPointIndexInFullPath < polyLines[targetLineIndex].mPoints.length + 1) {
        const targetMPointIndex = targetPointIndexInFullPath - 1;
        const forceMap = forces[targetLineIndex][targetMPointIndex];
        const existingForce = forceMap.get(sourceId) || { fx: 0, fy: 0 };
        forceMap.set(sourceId, {
          fx: existingForce.fx + fx,
          fy: existingForce.fy + fy
        });
      }
    };
    for (let i = 0; i < numPolyLines; i++) {
      for (let j = i + 1; j < numPolyLines; j++) {
        const polyLine1 = polyLines[i];
        const polyLine2 = polyLines[j];
        const points1 = [polyLine1.start, ...polyLine1.mPoints, polyLine1.end];
        const points2 = [polyLine2.start, ...polyLine2.mPoints, polyLine2.end];
        const segments1 = [];
        const vias1 = [];
        for (let k = 0; k < points1.length - 1; k++) {
          segments1.push({
            p1: points1[k],
            p2: points1[k + 1],
            layer: points1[k].z2,
            p1Idx: k,
            p2Idx: k + 1
          });
        }
        points1.forEach((p, k) => {
          if (p.z1 !== p.z2)
            vias1.push({ point: p, layers: [p.z1, p.z2], index: k });
        });
        const segments2 = [];
        const vias2 = [];
        for (let k = 0; k < points2.length - 1; k++) {
          segments2.push({
            p1: points2[k],
            p2: points2[k + 1],
            layer: points2[k].z2,
            p1Idx: k,
            p2Idx: k + 1
          });
        }
        points2.forEach((p, k) => {
          if (p.z1 !== p.z2)
            vias2.push({ point: p, layers: [p.z1, p.z2], index: k });
        });
        for (const seg1 of segments1) {
          for (const seg2 of segments2) {
            if (seg1.layer === seg2.layer) {
              const minDist = segmentToSegmentMinDistance(
                seg1.p1,
                seg1.p2,
                seg2.p1,
                seg2.p2
              );
              if (minDist < EPSILON4) continue;
              const center1 = {
                x: (seg1.p1.x + seg1.p2.x) / 2,
                y: (seg1.p1.y + seg1.p2.y) / 2
              };
              const center2 = {
                x: (seg2.p1.x + seg2.p2.x) / 2,
                y: (seg2.p1.y + seg2.p2.y) / 2
              };
              const dx = center1.x - center2.x;
              const dy = center1.y - center2.y;
              const dSq = dx * dx + dy * dy;
              if (dSq > EPSILON4) {
                const dist = Math.sqrt(dSq);
                const forceMag = SEGMENT_FORCE_MULTIPLIER * FORCE_MAGNITUDE * Math.exp(-FORCE_DECAY_RATE * dist);
                const fx = dx / dist * forceMag;
                const fy = dy / dist * forceMag;
                const sourceIdSeg2 = `seg:${j}:${seg2.p1Idx}:${seg2.p2Idx}`;
                const sourceIdSeg1 = `seg:${i}:${seg1.p1Idx}:${seg1.p2Idx}`;
                const endpointForce = (ep, epIdx, otherSeg, targetLine, oppLine, srcIdOpp, srcIdThis) => {
                  const cp = pointToSegmentClosestPoint(
                    ep,
                    otherSeg.p1,
                    otherSeg.p2
                  );
                  const dx2 = ep.x - cp.x;
                  const dy2 = ep.y - cp.y;
                  const dSq2 = dx2 * dx2 + dy2 * dy2;
                  if (dSq2 <= EPSILON4) return;
                  const dist2 = Math.sqrt(dSq2);
                  const mag = SEGMENT_FORCE_MULTIPLIER * FORCE_MAGNITUDE * Math.exp(-FORCE_DECAY_RATE * dist2);
                  const fx2 = dx2 / dist2 * mag;
                  const fy2 = dy2 / dist2 * mag;
                  addForceContribution(targetLine, epIdx, srcIdOpp, fx2, fy2);
                  addForceContribution(
                    oppLine,
                    otherSeg.p1Idx,
                    srcIdThis,
                    -fx2 / 2,
                    -fy2 / 2
                  );
                  addForceContribution(
                    oppLine,
                    otherSeg.p2Idx,
                    srcIdThis,
                    -fx2 / 2,
                    -fy2 / 2
                  );
                };
                endpointForce(
                  seg1.p1,
                  seg1.p1Idx,
                  seg2,
                  i,
                  j,
                  sourceIdSeg2,
                  sourceIdSeg1
                );
                endpointForce(
                  seg1.p2,
                  seg1.p2Idx,
                  seg2,
                  i,
                  j,
                  sourceIdSeg2,
                  sourceIdSeg1
                );
                endpointForce(
                  seg2.p1,
                  seg2.p1Idx,
                  seg1,
                  j,
                  i,
                  sourceIdSeg1,
                  sourceIdSeg2
                );
                endpointForce(
                  seg2.p2,
                  seg2.p2Idx,
                  seg1,
                  j,
                  i,
                  sourceIdSeg1,
                  sourceIdSeg2
                );
              }
            }
          }
        }
        for (const via1 of vias1) {
          for (const seg2 of segments2) {
            if (via1.layers.includes(seg2.layer)) {
              const closestPointOnSeg = pointToSegmentClosestPoint(
                via1.point,
                seg2.p1,
                seg2.p2
              );
              const dx = via1.point.x - closestPointOnSeg.x;
              const dy = via1.point.y - closestPointOnSeg.y;
              const dSq = dx * dx + dy * dy;
              if (dSq > EPSILON4) {
                const dist = Math.sqrt(dSq);
                let forceMultiplier = VIA_FORCE_MULTIPLIER;
                let effectiveDistance = dist;
                if (dist < this.viaDiameter / 2) {
                  forceMultiplier *= INSIDE_VIA_FORCE_MULTIPLIER;
                  effectiveDistance = Math.max(EPSILON4, dist);
                } else {
                  effectiveDistance = Math.max(
                    EPSILON4,
                    dist - this.viaDiameter / 2
                  );
                }
                const forceMag = forceMultiplier * FORCE_MAGNITUDE * Math.exp(-FORCE_DECAY_RATE * effectiveDistance);
                const fx_j_on_i = dx / dist * forceMag;
                const fy_j_on_i = dy / dist * forceMag;
                const sourceIdSeg2 = `seg:${j}:${seg2.p1Idx}:${seg2.p2Idx}`;
                addForceContribution(
                  i,
                  via1.index,
                  sourceIdSeg2,
                  fx_j_on_i,
                  fy_j_on_i
                );
                const sourceIdVia1 = `via:${i}:${via1.index}`;
                addForceContribution(
                  j,
                  seg2.p1Idx,
                  sourceIdVia1,
                  -fx_j_on_i / 2,
                  -fy_j_on_i / 2
                );
                addForceContribution(
                  j,
                  seg2.p2Idx,
                  sourceIdVia1,
                  -fx_j_on_i / 2,
                  -fy_j_on_i / 2
                );
              }
            }
          }
        }
        for (const via2 of vias2) {
          for (const seg1 of segments1) {
            if (via2.layers.includes(seg1.layer)) {
              const closestPointOnSeg = pointToSegmentClosestPoint(
                via2.point,
                seg1.p1,
                seg1.p2
              );
              const dx = via2.point.x - closestPointOnSeg.x;
              const dy = via2.point.y - closestPointOnSeg.y;
              const dSq = dx * dx + dy * dy;
              if (dSq > EPSILON4) {
                const dist = Math.sqrt(dSq);
                let forceMultiplier = VIA_FORCE_MULTIPLIER;
                let effectiveDistance = dist;
                if (dist < this.viaDiameter / 2) {
                  forceMultiplier *= INSIDE_VIA_FORCE_MULTIPLIER;
                  effectiveDistance = Math.max(EPSILON4, dist);
                } else {
                  effectiveDistance = Math.max(
                    EPSILON4,
                    dist - this.viaDiameter / 2
                  );
                }
                const forceMag = forceMultiplier * FORCE_MAGNITUDE * Math.exp(-FORCE_DECAY_RATE * effectiveDistance);
                const fx_i_on_j = dx / dist * forceMag;
                const fy_i_on_j = dy / dist * forceMag;
                const sourceIdSeg1 = `seg:${i}:${seg1.p1Idx}:${seg1.p2Idx}`;
                addForceContribution(
                  j,
                  via2.index,
                  sourceIdSeg1,
                  fx_i_on_j,
                  fy_i_on_j
                );
                const sourceIdVia2 = `via:${j}:${via2.index}`;
                addForceContribution(
                  i,
                  seg1.p1Idx,
                  sourceIdVia2,
                  -fx_i_on_j / 2,
                  -fy_i_on_j / 2
                );
                addForceContribution(
                  i,
                  seg1.p2Idx,
                  sourceIdVia2,
                  -fx_i_on_j / 2,
                  -fy_i_on_j / 2
                );
              }
            }
          }
        }
        for (const via1 of vias1) {
          for (const via2 of vias2) {
            const commonLayers = via1.layers.filter(
              (z) => via2.layers.includes(z)
            );
            if (commonLayers.length > 0) {
              const dx = via1.point.x - via2.point.x;
              const dy = via1.point.y - via2.point.y;
              const dSq = dx * dx + dy * dy;
              if (dSq > EPSILON4) {
                const dist = Math.sqrt(dSq);
                let forceMultiplier = VIA_FORCE_MULTIPLIER;
                let effectiveDistance = dist;
                if (dist < this.viaDiameter) {
                  forceMultiplier *= INSIDE_VIA_FORCE_MULTIPLIER;
                  effectiveDistance = Math.max(EPSILON4, dist);
                } else {
                  effectiveDistance = Math.max(EPSILON4, dist - this.viaDiameter);
                }
                const forceMag = forceMultiplier * FORCE_MAGNITUDE * Math.exp(-FORCE_DECAY_RATE * effectiveDistance);
                const fx_j_on_i = dx / dist * forceMag;
                const fy_j_on_i = dy / dist * forceMag;
                const sourceIdVia2 = `via:${j}:${via2.index}`;
                const sourceIdVia1 = `via:${i}:${via1.index}`;
                addForceContribution(
                  i,
                  via1.index,
                  sourceIdVia2,
                  fx_j_on_i,
                  fy_j_on_i
                );
                addForceContribution(
                  j,
                  via2.index,
                  sourceIdVia1,
                  -fx_j_on_i,
                  -fy_j_on_i
                );
              }
            }
          }
        }
      }
    }
    for (let i = 0; i < numPolyLines; i++) {
      const polyLine = polyLines[i];
      const points = [polyLine.start, ...polyLine.mPoints, polyLine.end];
      const vias = [];
      points.forEach((p, k) => {
        if (p.z1 !== p.z2)
          vias.push({ point: p, layers: [p.z1, p.z2], index: k });
      });
      if (vias.length < 2) continue;
      for (let v1Idx = 0; v1Idx < vias.length; v1Idx++) {
        for (let v2Idx = v1Idx + 1; v2Idx < vias.length; v2Idx++) {
          const via1 = vias[v1Idx];
          const via2 = vias[v2Idx];
          const dx = via1.point.x - via2.point.x;
          const dy = via1.point.y - via2.point.y;
          const dSq = dx * dx + dy * dy;
          if (dSq > EPSILON4) {
            const dist = Math.sqrt(dSq);
            let forceMultiplier = VIA_FORCE_MULTIPLIER;
            let effectiveDistance = dist;
            if (dist < this.viaDiameter) {
              forceMultiplier *= INSIDE_VIA_FORCE_MULTIPLIER;
              effectiveDistance = Math.max(EPSILON4, dist);
            } else {
              effectiveDistance = Math.max(EPSILON4, dist - this.viaDiameter);
            }
            const forceMag = forceMultiplier * FORCE_MAGNITUDE * Math.exp(-FORCE_DECAY_RATE * effectiveDistance);
            const fx_2_on_1 = dx / dist * forceMag;
            const fy_2_on_1 = dy / dist * forceMag;
            const sourceIdVia2 = `via:${i}:${via2.index}`;
            const sourceIdVia1 = `via:${i}:${via1.index}`;
            addForceContribution(
              i,
              via1.index,
              sourceIdVia2,
              fx_2_on_1,
              fy_2_on_1
            );
            addForceContribution(
              i,
              via2.index,
              sourceIdVia1,
              -fx_2_on_1,
              -fy_2_on_1
            );
          }
        }
      }
    }
    const newPolyLines = polyLines.map((pl) => ({
      ...pl,
      mPoints: pl.mPoints.map((mp) => ({ ...mp }))
    }));
    let pointsMoved = false;
    for (let i = 0; i < numPolyLines; i++) {
      for (let k = 0; k < newPolyLines[i].mPoints.length; k++) {
        const mPoint = newPolyLines[i].mPoints[k];
        const forceMap = forces[i][k];
        const netForce = { fx: 0, fy: 0 };
        for (const force of forceMap.values()) {
          netForce.fx += force.fx;
          netForce.fy += force.fy;
        }
        const isVia = mPoint.z1 !== mPoint.z2;
        let newX = mPoint.x + netForce.fx;
        let newY = mPoint.y + netForce.fy;
        if (isVia) {
          const radius = this.viaDiameter / 2;
          let boundaryForceX = 0;
          let boundaryForceY = 0;
          const baseForceMargin = this.viaDiameter / 2;
          const forceMargin = baseForceMargin + this.BOUNDARY_PADDING;
          const minX = this.bounds.minX + forceMargin;
          const maxX = this.bounds.maxX - forceMargin;
          const minY = this.bounds.minY + forceMargin;
          const maxY = this.bounds.maxY - forceMargin;
          const distOutsideMinX = minX + radius - mPoint.x;
          const distOutsideMaxX = mPoint.x - (maxX - radius);
          const distOutsideMinY = minY + radius - mPoint.y;
          const distOutsideMaxY = mPoint.y - (maxY - radius);
          if (distOutsideMinX > 0) {
            boundaryForceX = BOUNDARY_FORCE_STRENGTH * (Math.exp(distOutsideMinX / (this.obstacleMargin * 2)) - 1);
          } else if (distOutsideMaxX > 0) {
            boundaryForceX = -BOUNDARY_FORCE_STRENGTH * (Math.exp(distOutsideMaxX / (this.obstacleMargin * 2)) - 1);
          }
          if (distOutsideMinY > 0) {
            boundaryForceY = BOUNDARY_FORCE_STRENGTH * (Math.exp(distOutsideMinY / (this.obstacleMargin * 2)) - 1);
          } else if (distOutsideMaxY > 0) {
            boundaryForceY = -BOUNDARY_FORCE_STRENGTH * (Math.exp(distOutsideMaxY / (this.obstacleMargin * 2)) - 1);
          }
          netForce.fx += boundaryForceX;
          netForce.fy += boundaryForceY;
          newX = mPoint.x + netForce.fx;
          newY = mPoint.y + netForce.fy;
        } else {
          const basePadding = this.traceWidth / 2;
          const padding = basePadding + this.BOUNDARY_PADDING;
          newX = Math.max(
            this.bounds.minX + padding,
            Math.min(this.bounds.maxX - padding, newX)
          );
          newY = Math.max(
            this.bounds.minY + padding,
            Math.min(this.bounds.maxY - padding, newY)
          );
        }
        if (Math.abs(netForce.fx) < EPSILON4 && Math.abs(netForce.fy) < EPSILON4) {
          continue;
        }
        if (Math.abs(mPoint.x - newX) > EPSILON4 || Math.abs(mPoint.y - newY) > EPSILON4) {
          mPoint.x = newX;
          mPoint.y = newY;
          pointsMoved = true;
        }
      }
    }
    if (!pointsMoved) {
      return [];
    }
    const minGaps = this.computeMinGapBtwPolyLines(newPolyLines);
    const g = this.computeG(newPolyLines, candidate);
    const h = this.computeH({ minGaps, forces });
    const newNeighbor = {
      polyLines: newPolyLines,
      g,
      h,
      // The rounding of g is for fun animations (prevents flashing btw multiple candidate paths)
      f: Math.round(g * 5) / 5 + h,
      minGaps,
      forces,
      // Store the calculated forces
      viaCount: candidate.viaCount
    };
    return [newNeighbor];
  }
  checkIfSolved(candidate) {
    const minGapsToOtherConnectionsValid = candidate.minGaps.every(
      (minGap) => minGap >= this.obstacleMargin
    );
    const allPointsWithinBounds = candidate.polyLines.every((polyLine) => {
      return polyLine.mPoints.every((mPoint) => {
        const basePadding = mPoint.z1 !== mPoint.z2 ? this.viaDiameter / 2 : this.traceWidth / 2;
        const padding = basePadding + this.BOUNDARY_PADDING;
        return withinBounds(mPoint, this.bounds, padding);
      });
    });
    return minGapsToOtherConnectionsValid && allPointsWithinBounds;
  }
  // ------------------------------------------------------------------
  //  Try accepting the best candidate even if normal solving failed.
  // ------------------------------------------------------------------
  tryFinalAcceptance() {
    const minGapTarget = this.hyperParameters?.MINIMUM_FINAL_ACCEPTANCE_GAP ?? void 0;
    if (minGapTarget === void 0 || this.lastCandidate === null || this.lastCandidate.minGaps.length === 0)
      return;
    const minGapAchieved = Math.min(...this.lastCandidate.minGaps);
    if (minGapAchieved >= minGapTarget) {
      this.solved = true;
      this._setSolvedRoutes();
      return;
    }
    return;
  }
  _step() {
    if (this.phase === "setup") {
      this.setupInitialPolyLines();
      this.phase = "solving";
      return;
    }
    const currentCandidate = this.candidates.shift();
    if (!currentCandidate) {
      this.tryFinalAcceptance();
      if (this.solved) return;
      this.failed = true;
      this.error = "No candidates left";
      return;
    }
    this.lastCandidate = currentCandidate;
    if (this.checkIfSolved(currentCandidate)) {
      this.solved = true;
      this._setSolvedRoutes();
      return;
    }
    if (!currentCandidate) {
      this.failed = true;
      return;
    }
    const neighbors = this.getNeighbors(currentCandidate);
    for (const neighbor of neighbors) {
      this.insertCandidate(neighbor);
    }
  }
  visualize() {
    const graphicsObject = {
      points: [],
      lines: [],
      rects: [],
      circles: [],
      coordinateSystem: "cartesian",
      title: "MultiHeadPolyLineIntraNodeSolver Visualization"
    };
    graphicsObject.lines.push({
      points: [
        { x: this.bounds.minX, y: this.bounds.minY },
        { x: this.bounds.maxX, y: this.bounds.minY },
        { x: this.bounds.maxX, y: this.bounds.maxY },
        { x: this.bounds.minX, y: this.bounds.maxY },
        { x: this.bounds.minX, y: this.bounds.minY }
      ],
      strokeColor: "gray"
    });
    const candidateToVisualize = this.lastCandidate ?? this.candidates[0];
    if (candidateToVisualize?.hasClosedSameLayerFace) {
      const rectWidth = (this.bounds.maxX - this.bounds.minX) * 0.1;
      const rectHeight = (this.bounds.maxY - this.bounds.minY) * 0.1;
      graphicsObject.rects.push({
        center: {
          x: this.bounds.maxX + rectWidth * 0.6,
          // Position slightly outside top-right
          y: this.bounds.maxY + rectHeight * 0.6
        },
        width: rectWidth,
        height: rectHeight,
        fill: "red",
        label: "HAS CLOSED FACE"
      });
    }
    for (const pt of this.nodeWithPortPoints.portPoints) {
      graphicsObject.points.push({
        x: pt.x,
        y: pt.y,
        // Assuming port points represent a single layer entry/exit, use z or default to 0
        label: `${pt.connectionName} (Port z=${pt.z ?? 0})`,
        color: this.colorMap[pt.connectionName] ?? "blue"
      });
    }
    if (candidateToVisualize) {
      candidateToVisualize.polyLines.forEach((polyLine, polyLineIndex) => {
        const color = this.colorMap[polyLine.connectionName] ?? "purple";
        const pointsInPolyline = [
          polyLine.start,
          ...polyLine.mPoints,
          polyLine.end
        ];
        for (let i = 0; i < pointsInPolyline.length - 1; i++) {
          const p1 = pointsInPolyline[i];
          const p2 = pointsInPolyline[i + 1];
          const segmentLayer = p1.z2;
          const isLayer0 = segmentLayer === 0;
          const segmentColor = isLayer0 ? color : safeTransparentize(color, 0.5);
          graphicsObject.lines.push({
            points: [p1, p2],
            strokeColor: segmentColor,
            strokeWidth: this.traceWidth,
            // TODO: Use actual trace thickness from HighDensityRoute?
            strokeDash: !isLayer0 ? [0.15, 0.15] : void 0,
            // Dashed for layers > 0
            label: `${polyLine.connectionName} segment (z=${segmentLayer})`
          });
        }
        pointsInPolyline.forEach((point, pointIndex) => {
          const isVia = point.z1 !== point.z2;
          const pointLayer = point.z1;
          const isMPoint = pointIndex > 0 && pointIndex < pointsInPolyline.length - 1;
          let label = "";
          let forceLabel = "";
          if (isMPoint) {
            const mPointIndex = pointIndex - 1;
            const forceMap = candidateToVisualize.forces?.[polyLineIndex]?.[mPointIndex];
            if (forceMap && forceMap.size > 0) {
              const netForce = { fx: 0, fy: 0 };
              forceMap.forEach((force, sourceId) => {
                netForce.fx += force.fx;
                netForce.fy += force.fy;
                if (Math.abs(force.fx) > 1e-6 || Math.abs(force.fy) > 1e-6) {
                  const parts = sourceId.split(":");
                  const sourceType = parts[0];
                  const applyingLineIndex = parseInt(parts[1], 10);
                  const applyingPolyline = candidateToVisualize.polyLines[applyingLineIndex];
                  const applyingColor = this.colorMap[applyingPolyline.connectionName] ?? "gray";
                  const forceScale = 20;
                  const forceEndPoint = {
                    x: point.x + force.fx * forceScale,
                    y: point.y + force.fy * forceScale
                  };
                  let sourceLabel = applyingPolyline.connectionName;
                  if (sourceType === "via") {
                    const pointIdx = parseInt(parts[2], 10);
                    sourceLabel += ` Via ${pointIdx}`;
                  } else if (sourceType === "seg") {
                    const p1Idx = parseInt(parts[2], 10);
                    const p2Idx = parseInt(parts[3], 10);
                    sourceLabel += ` Seg ${p1Idx}-${p2Idx}`;
                  }
                  graphicsObject.lines.push({
                    points: [point, forceEndPoint],
                    strokeColor: applyingColor,
                    // Color by applying polyline
                    strokeWidth: 0.02,
                    strokeDash: "2,2",
                    // Dashed line for force
                    label: `Force by ${sourceLabel} on ${polyLine.connectionName} mPoint ${mPointIndex}`
                  });
                }
              });
              if (Math.abs(netForce.fx) > 1e-6 || Math.abs(netForce.fy) > 1e-6) {
                forceLabel = `
Net Force: (${netForce.fx.toFixed(3)}, ${netForce.fy.toFixed(3)})`;
              }
            }
          }
          if (isVia) {
            label = `Via (${polyLine.connectionName} z=${point.z1} -> z=${point.z2})${forceLabel}`;
            graphicsObject.circles.push({
              center: point,
              radius: this.viaDiameter / 2,
              fill: safeTransparentize(color, 0.5),
              // Distinct Via color
              label
            });
          } else {
            if (isMPoint) {
              const isLayer0 = pointLayer === 0;
              const pointColor = isLayer0 ? color : safeTransparentize(color, 0.5);
              label = `mPoint (${polyLine.connectionName} z=${pointLayer})${forceLabel}`;
              graphicsObject.circles.push({
                center: point,
                radius: this.cellSize / 8,
                // Smaller circle for mPoints
                fill: pointColor,
                label
              });
            }
          }
        });
      });
    }
    return graphicsObject;
  }
  _setSolvedRoutes() {
    if (!this.solved || !this.lastCandidate) {
      return [];
    }
    const solvedRoutes = [];
    for (const polyLine of this.lastCandidate.polyLines) {
      const routePoints = [];
      const vias = [];
      const fullPath = [polyLine.start, ...polyLine.mPoints, polyLine.end];
      for (let i = 0; i < fullPath.length; i++) {
        const currentPoint = fullPath[i];
        routePoints.push({
          x: currentPoint.x,
          y: currentPoint.y,
          z: currentPoint.z1
        });
        if (currentPoint.z1 !== currentPoint.z2) {
          vias.push({ x: currentPoint.x, y: currentPoint.y });
          routePoints.push({
            x: currentPoint.x,
            y: currentPoint.y,
            z: currentPoint.z2
          });
        }
      }
      solvedRoutes.push({
        connectionName: polyLine.connectionName,
        traceThickness: this.traceWidth,
        viaDiameter: this.viaDiameter,
        route: routePoints,
        vias
      });
    }
    this.solvedRoutes = solvedRoutes;
  }
};

// lib/solvers/HighDensitySolver/MultiHeadPolyLineIntraNodeSolver/MultiHeadPolyLineIntraNodeSolver2_Optimized.ts
var MultiHeadPolyLineIntraNodeSolver2 = class extends MultiHeadPolyLineIntraNodeSolver {
  computeG(polyLines, candidate) {
    return candidate.g + 5e-6 + candidate.viaCount * 5e-6 * 100;
  }
  /**
   * We don't use the heuristic because we don't queue new candidates with this
   * solver
   */
  computeH(candidate) {
    const { minGaps } = candidate;
    let collisionScore = 0;
    for (const gap of minGaps) {
      if (gap < 0) {
        collisionScore += this.obstacleMargin;
      }
      if (gap < this.obstacleMargin) {
        collisionScore += this.obstacleMargin - gap;
      }
    }
    return collisionScore * 0.011;
  }
  _step() {
    if (this.phase === "setup") {
      this.setupInitialPolyLines();
      this.phase = "solving";
      return;
    }
    const currentCandidate = this.candidates.shift();
    if (!currentCandidate) {
      this.tryFinalAcceptance();
      if (this.solved) return;
      this.failed = true;
      return;
    }
    this.lastCandidate = currentCandidate;
    if (this.checkIfSolved(currentCandidate)) {
      this.solved = true;
      this._setSolvedRoutes();
      return;
    }
    let lastStepMoved = false;
    let magForceApplied = 0;
    const stepsToRun = currentCandidate.magForceApplied === void 0 ? 1 : 10;
    for (let step = 0; step < stepsToRun; step++) {
      const result = this.applyForcesToPolyLines(currentCandidate.polyLines);
      magForceApplied += result.magForceApplied;
      lastStepMoved = result.lastStepMoved;
      if (!result.lastStepMoved) break;
    }
    currentCandidate.magForceApplied = magForceApplied;
    currentCandidate.minGaps = this.computeMinGapBtwPolyLines(
      currentCandidate.polyLines
    );
    if (this.checkIfSolved(currentCandidate)) {
      this.solved = true;
      this._setSolvedRoutes();
      return;
    }
    currentCandidate.g = this.computeG(
      currentCandidate.polyLines,
      currentCandidate
    );
    currentCandidate.h = this.computeH(currentCandidate);
    currentCandidate.f = currentCandidate.g + currentCandidate.h;
    if (lastStepMoved) {
      this.insertCandidate(currentCandidate);
    }
  }
  /**
   * Applies repulsive forces between polylines (segments and vias) and boundary forces
   * directly modifying the input polyLines array.
   * Returns true if any mPoint was moved, false otherwise.
   */
  applyForcesToPolyLines(polyLines) {
    let magForceApplied = 0;
    const numPolyLines = polyLines.length;
    const FORCE_MAGNITUDE = 0.02;
    const VIA_FORCE_MULTIPLIER = 2;
    const INSIDE_VIA_FORCE_MULTIPLIER = 4;
    const SEGMENT_FORCE_MULTIPLIER = 1;
    const FORCE_DECAY_RATE = 6;
    const BOUNDARY_FORCE_STRENGTH = 8e-3;
    const EPSILON4 = 1e-6;
    const netForces = Array.from(
      { length: numPolyLines },
      (_, i) => Array.from({ length: polyLines[i].mPoints.length }, () => ({
        fx: 0,
        fy: 0
      }))
    );
    const addNetForce = (lineIndex, pointIndexInFullPath, fx, fy) => {
      if (pointIndexInFullPath > 0 && pointIndexInFullPath < polyLines[lineIndex].mPoints.length + 1) {
        const mPointIndex = pointIndexInFullPath - 1;
        netForces[lineIndex][mPointIndex].fx += fx;
        netForces[lineIndex][mPointIndex].fy += fy;
      }
    };
    const endpointForce = (ep, epIdx, otherSeg, targetLine, oppLine) => {
      const cp = pointToSegmentClosestPoint(ep, otherSeg.p1, otherSeg.p2);
      const dx = ep.x - cp.x;
      const dy = ep.y - cp.y;
      const dSq = dx * dx + dy * dy;
      if (dSq <= EPSILON4) return;
      const dist = Math.sqrt(dSq);
      const mag = SEGMENT_FORCE_MULTIPLIER * FORCE_MAGNITUDE * Math.exp(-FORCE_DECAY_RATE * dist);
      const fx = dx / dist * mag;
      const fy = dy / dist * mag;
      addNetForce(targetLine, epIdx, fx, fy);
      addNetForce(oppLine, otherSeg.p1Idx, -fx / 2, -fy / 2);
      addNetForce(oppLine, otherSeg.p2Idx, -fx / 2, -fy / 2);
    };
    for (let i = 0; i < numPolyLines; i++) {
      for (let j = i + 1; j < numPolyLines; j++) {
        const polyLine1 = polyLines[i];
        const polyLine2 = polyLines[j];
        const points1 = [polyLine1.start, ...polyLine1.mPoints, polyLine1.end];
        const points2 = [polyLine2.start, ...polyLine2.mPoints, polyLine2.end];
        const segments1 = [];
        const vias1 = [];
        for (let k = 0; k < points1.length - 1; k++) {
          segments1.push({
            p1: points1[k],
            p2: points1[k + 1],
            layer: points1[k].z2,
            p1Idx: k,
            p2Idx: k + 1
          });
        }
        points1.forEach((p, k) => {
          if (p.z1 !== p.z2)
            vias1.push({ point: p, layers: [p.z1, p.z2], index: k });
        });
        const segments2 = [];
        const vias2 = [];
        for (let k = 0; k < points2.length - 1; k++) {
          segments2.push({
            p1: points2[k],
            p2: points2[k + 1],
            layer: points2[k].z2,
            p1Idx: k,
            p2Idx: k + 1
          });
        }
        points2.forEach((p, k) => {
          if (p.z1 !== p.z2)
            vias2.push({ point: p, layers: [p.z1, p.z2], index: k });
        });
        for (const seg1 of segments1) {
          for (const seg2 of segments2) {
            if (seg1.layer === seg2.layer) {
              const minDist = segmentToSegmentMinDistance(
                seg1.p1,
                seg1.p2,
                seg2.p1,
                seg2.p2
              );
              endpointForce(seg1.p1, seg1.p1Idx, seg2, i, j);
              endpointForce(seg1.p2, seg1.p2Idx, seg2, i, j);
              endpointForce(seg2.p1, seg2.p1Idx, seg1, j, i);
              endpointForce(seg2.p2, seg2.p2Idx, seg1, j, i);
            }
          }
        }
        for (const via1 of vias1) {
          for (const seg2 of segments2) {
            if (via1.layers.includes(seg2.layer)) {
              const closestPointOnSeg = pointToSegmentClosestPoint(
                via1.point,
                seg2.p1,
                seg2.p2
              );
              const dx = via1.point.x - closestPointOnSeg.x;
              const dy = via1.point.y - closestPointOnSeg.y;
              const dSq = dx * dx + dy * dy;
              if (dSq > EPSILON4) {
                const dist = Math.sqrt(dSq);
                let forceMultiplier = VIA_FORCE_MULTIPLIER;
                let effectiveDistance = dist;
                if (dist < this.viaDiameter / 2) {
                  forceMultiplier *= INSIDE_VIA_FORCE_MULTIPLIER;
                  effectiveDistance = Math.max(EPSILON4, dist);
                } else {
                  effectiveDistance = Math.max(
                    EPSILON4,
                    dist - this.viaDiameter / 2
                  );
                }
                const forceMag = forceMultiplier * FORCE_MAGNITUDE * Math.exp(-FORCE_DECAY_RATE * effectiveDistance);
                const fx_j_on_i = dx / dist * forceMag;
                const fy_j_on_i = dy / dist * forceMag;
                addNetForce(i, via1.index, fx_j_on_i, fy_j_on_i);
                addNetForce(j, seg2.p1Idx, -fx_j_on_i / 2, -fy_j_on_i / 2);
                addNetForce(j, seg2.p2Idx, -fx_j_on_i / 2, -fy_j_on_i / 2);
              }
            }
          }
        }
        for (const via2 of vias2) {
          for (const seg1 of segments1) {
            if (via2.layers.includes(seg1.layer)) {
              const closestPointOnSeg = pointToSegmentClosestPoint(
                via2.point,
                seg1.p1,
                seg1.p2
              );
              const dx = via2.point.x - closestPointOnSeg.x;
              const dy = via2.point.y - closestPointOnSeg.y;
              const dSq = dx * dx + dy * dy;
              if (dSq > EPSILON4) {
                const dist = Math.sqrt(dSq);
                let forceMultiplier = VIA_FORCE_MULTIPLIER;
                let effectiveDistance = dist;
                if (dist < this.viaDiameter / 2) {
                  forceMultiplier *= INSIDE_VIA_FORCE_MULTIPLIER;
                  effectiveDistance = Math.max(EPSILON4, dist);
                } else {
                  effectiveDistance = Math.max(
                    EPSILON4,
                    dist - this.viaDiameter / 2
                  );
                }
                const forceMag = forceMultiplier * FORCE_MAGNITUDE * Math.exp(-FORCE_DECAY_RATE * effectiveDistance);
                const fx_i_on_j = dx / dist * forceMag;
                const fy_i_on_j = dy / dist * forceMag;
                addNetForce(j, via2.index, fx_i_on_j, fy_i_on_j);
                addNetForce(i, seg1.p1Idx, -fx_i_on_j / 2, -fy_i_on_j / 2);
                addNetForce(i, seg1.p2Idx, -fx_i_on_j / 2, -fy_i_on_j / 2);
              }
            }
          }
        }
        for (const via1 of vias1) {
          for (const via2 of vias2) {
            const commonLayers = via1.layers.filter(
              (z) => via2.layers.includes(z)
            );
            if (commonLayers.length > 0) {
              const dx = via1.point.x - via2.point.x;
              const dy = via1.point.y - via2.point.y;
              const dSq = dx * dx + dy * dy;
              if (dSq > EPSILON4) {
                const dist = Math.sqrt(dSq);
                let forceMultiplier = VIA_FORCE_MULTIPLIER;
                let effectiveDistance = dist;
                if (dist < this.viaDiameter) {
                  forceMultiplier *= INSIDE_VIA_FORCE_MULTIPLIER;
                  effectiveDistance = Math.max(EPSILON4, dist);
                } else {
                  effectiveDistance = Math.max(EPSILON4, dist - this.viaDiameter);
                }
                const forceMag = forceMultiplier * FORCE_MAGNITUDE * Math.exp(-FORCE_DECAY_RATE * effectiveDistance);
                const fx_j_on_i = dx / dist * forceMag;
                const fy_j_on_i = dy / dist * forceMag;
                addNetForce(i, via1.index, fx_j_on_i, fy_j_on_i);
                addNetForce(j, via2.index, -fx_j_on_i, -fy_j_on_i);
              }
            }
          }
        }
      }
    }
    for (let i = 0; i < numPolyLines; i++) {
      const polyLine = polyLines[i];
      const points = [polyLine.start, ...polyLine.mPoints, polyLine.end];
      const vias = [];
      points.forEach((p, k) => {
        if (p.z1 !== p.z2)
          vias.push({ point: p, layers: [p.z1, p.z2], index: k });
      });
      if (vias.length < 2) continue;
      for (let v1Idx = 0; v1Idx < vias.length; v1Idx++) {
        for (let v2Idx = v1Idx + 1; v2Idx < vias.length; v2Idx++) {
          const via1 = vias[v1Idx];
          const via2 = vias[v2Idx];
          const dx = via1.point.x - via2.point.x;
          const dy = via1.point.y - via2.point.y;
          const dSq = dx * dx + dy * dy;
          if (dSq > EPSILON4) {
            const dist = Math.sqrt(dSq);
            let forceMultiplier = VIA_FORCE_MULTIPLIER;
            let effectiveDistance = dist;
            if (dist < this.viaDiameter) {
              forceMultiplier *= INSIDE_VIA_FORCE_MULTIPLIER;
              effectiveDistance = Math.max(EPSILON4, dist);
            } else {
              effectiveDistance = Math.max(EPSILON4, dist - this.viaDiameter);
            }
            const forceMag = forceMultiplier * FORCE_MAGNITUDE * Math.exp(-FORCE_DECAY_RATE * effectiveDistance);
            const fx_2_on_1 = dx / dist * forceMag;
            const fy_2_on_1 = dy / dist * forceMag;
            addNetForce(i, via1.index, fx_2_on_1, fy_2_on_1);
            addNetForce(i, via2.index, -fx_2_on_1, -fy_2_on_1);
          }
        }
      }
    }
    let pointsMoved = false;
    for (let i = 0; i < numPolyLines; i++) {
      for (let k = 0; k < polyLines[i].mPoints.length; k++) {
        const mPoint = polyLines[i].mPoints[k];
        const netForce = netForces[i][k];
        const isVia = mPoint.z1 !== mPoint.z2;
        let currentForceX = netForce.fx;
        let currentForceY = netForce.fy;
        let newX = mPoint.x + currentForceX;
        let newY = mPoint.y + currentForceY;
        if (isVia) {
          const radius = this.viaDiameter / 2;
          let boundaryForceX = 0;
          let boundaryForceY = 0;
          const baseForceMargin = this.viaDiameter / 2;
          const forceMargin = baseForceMargin + this.BOUNDARY_PADDING;
          const minX = this.bounds.minX + forceMargin;
          const maxX = this.bounds.maxX - forceMargin;
          const minY = this.bounds.minY + forceMargin;
          const maxY = this.bounds.maxY - forceMargin;
          const distOutsideMinX = minX + radius - mPoint.x;
          const distOutsideMaxX = mPoint.x - (maxX - radius);
          const distOutsideMinY = minY + radius - mPoint.y;
          const distOutsideMaxY = mPoint.y - (maxY - radius);
          if (distOutsideMinX > 0) {
            boundaryForceX = BOUNDARY_FORCE_STRENGTH * (Math.exp(distOutsideMinX / (this.obstacleMargin * 2)) - 1);
          } else if (distOutsideMaxX > 0) {
            boundaryForceX = -BOUNDARY_FORCE_STRENGTH * (Math.exp(distOutsideMaxX / (this.obstacleMargin * 2)) - 1);
          }
          if (distOutsideMinY > 0) {
            boundaryForceY = BOUNDARY_FORCE_STRENGTH * (Math.exp(distOutsideMinY / (this.obstacleMargin * 2)) - 1);
          } else if (distOutsideMaxY > 0) {
            boundaryForceY = -BOUNDARY_FORCE_STRENGTH * (Math.exp(distOutsideMaxY / (this.obstacleMargin * 2)) - 1);
          }
          currentForceX += boundaryForceX;
          currentForceY += boundaryForceY;
          newX = mPoint.x + currentForceX;
          newY = mPoint.y + currentForceY;
        } else {
          const basePadding = this.traceWidth / 2;
          const padding = basePadding + this.BOUNDARY_PADDING;
          newX = Math.max(
            this.bounds.minX + padding,
            Math.min(this.bounds.maxX - padding, newX)
          );
          newY = Math.max(
            this.bounds.minY + padding,
            Math.min(this.bounds.maxY - padding, newY)
          );
        }
        if (Math.abs(currentForceX) < EPSILON4 && Math.abs(currentForceY) < EPSILON4) {
          continue;
        }
        const forceMag = Math.sqrt(
          currentForceX * currentForceX + currentForceY * currentForceY
        );
        magForceApplied += forceMag;
        if (Math.abs(mPoint.x - newX) > EPSILON4 || Math.abs(mPoint.y - newY) > EPSILON4) {
          mPoint.x = newX;
          mPoint.y = newY;
          pointsMoved = true;
        }
      }
    }
    return { lastStepMoved: pointsMoved, magForceApplied };
  }
};

// lib/solvers/HighDensitySolver/MultiHeadPolyLineIntraNodeSolver/MultiHeadPolyLineIntraNodeSolver3_ViaPossibilitiesSolverIntegration.ts
var hashPolyLines = (polyLines) => {
  return polyLines.flatMap(
    (pl) => `${pl.connectionName}-${pl.mPoints.map((mp) => `${mp.x.toFixed(2)},${mp.y.toFixed(2)},${mp.z1},${mp.z2}`)}`
  ).sort().join("|");
};
function factorial(n) {
  if (!Number.isInteger(n) || n < 0) {
    throw new RangeError("n must be a non-negative integer");
  }
  let result = 1;
  for (let i = 2; i <= n; i++) {
    result *= i;
  }
  return result;
}
var MultiHeadPolyLineIntraNodeSolver3 = class extends MultiHeadPolyLineIntraNodeSolver2 {
  constructor(params) {
    super(params);
    this.MAX_ITERATIONS = 1e3;
  }
  createInitialCandidateFromSeed(shuffleSeed) {
    const viaSolver = new ViaPossibilitiesSolver2({
      nodeWithPortPoints: this.nodeWithPortPoints,
      colorMap: this.colorMap,
      // Pass relevant hyperparameters if needed, e.g., shuffle seed
      hyperParameters: {
        SHUFFLE_SEED: shuffleSeed
      }
    });
    viaSolver.solve();
    if (viaSolver.failed || !viaSolver.solved) {
      return null;
    }
    const polyLines = [];
    let totalViaCount = 0;
    for (const [
      connectionName,
      pathPoints
    ] of viaSolver.completedPaths.entries()) {
      if (pathPoints.length < 2) {
        console.warn(
          `Skipping connection "${connectionName}" due to insufficient points (${pathPoints.length}) in ViaPossibilitiesSolver2 path.`
        );
        continue;
      }
      const startPoint = pathPoints[0];
      const endPoint = pathPoints[pathPoints.length - 1];
      const middlePointsRaw = pathPoints.slice(1, -1);
      const mPoints = [];
      let currentViaCount = 0;
      let lastZ = startPoint.z;
      for (let i = 0; i < middlePointsRaw.length; i++) {
        const currentRawPoint = middlePointsRaw[i];
        const nextRawPoint = i + 1 < middlePointsRaw.length ? middlePointsRaw[i + 1] : endPoint;
        const isViaStart = i + 1 < middlePointsRaw.length && currentRawPoint.x === nextRawPoint.x && currentRawPoint.y === nextRawPoint.y && currentRawPoint.z !== nextRawPoint.z;
        const z1 = lastZ;
        const z2 = isViaStart ? nextRawPoint.z : currentRawPoint.z;
        mPoints.push({
          x: currentRawPoint.x,
          y: currentRawPoint.y,
          z1,
          z2
        });
        if (z1 !== z2) {
          currentViaCount++;
          i++;
          lastZ = z2;
        } else {
          lastZ = currentRawPoint.z;
        }
      }
      totalViaCount += currentViaCount;
      const targetSegmentCount = this.SEGMENTS_PER_POLYLINE;
      let currentSegments = mPoints.length + 1;
      while (currentSegments < targetSegmentCount) {
        let longestSegmentLength = -1;
        let longestSegmentIndex = -1;
        let p1 = null;
        let p2 = null;
        const fullPathPoints = [
          {
            ...startPoint,
            z1: startPoint.z,
            z2: startPoint.z,
            connectionName
          },
          ...mPoints,
          { ...endPoint, z1: endPoint.z, z2: endPoint.z, connectionName }
        ];
        for (let k = 0; k < fullPathPoints.length - 1; k++) {
          const segP1 = fullPathPoints[k];
          const segP2 = fullPathPoints[k + 1];
          if (segP1.x === segP2.x && segP1.y === segP2.y) {
            continue;
          }
          const len = distance(segP1, segP2);
          if (len > longestSegmentLength) {
            longestSegmentLength = len;
            longestSegmentIndex = k;
            p1 = segP1;
            p2 = segP2;
          }
        }
        if (longestSegmentIndex === -1 || !p1 || !p2) {
          console.warn(
            `Could not find longest segment for ${connectionName} while trying to reach ${targetSegmentCount} segments.`
          );
          break;
        }
        const midX = (p1.x + p2.x) / 2;
        const midY = (p1.y + p2.y) / 2;
        const segmentZ = p1.z2;
        const newMPoint = {
          x: midX,
          y: midY,
          z1: segmentZ,
          // New point is on the same layer
          z2: segmentZ
        };
        mPoints.splice(longestSegmentIndex, 0, newMPoint);
        currentSegments++;
      }
      polyLines.push({
        connectionName,
        start: {
          // Use original start/end points from ViaSolver
          ...startPoint,
          z1: startPoint.z,
          z2: startPoint.z
          // Start point is not a via itself
        },
        end: {
          ...endPoint,
          z1: endPoint.z,
          // End point uses its own Z as z1
          z2: endPoint.z
          // End point is not a via itself
        },
        mPoints
      });
    }
    if (polyLines.length === 0) {
      this.failed = true;
      this.error = "No valid polylines generated from ViaPossibilitiesSolver2.";
      console.error(this.error);
      return null;
    }
    const minGaps = this.computeMinGapBtwPolyLines(polyLines);
    const h = this.computeH({ minGaps, forces: [] });
    const initialCandidate = {
      polyLines,
      g: 0,
      h,
      f: 0 + h,
      // f = g + h
      viaCount: totalViaCount,
      minGaps
    };
    initialCandidate.g = this.computeG(polyLines, initialCandidate);
    initialCandidate.f = initialCandidate.g + initialCandidate.h;
    return initialCandidate;
  }
  setupInitialPolyLines() {
    this.candidates = [];
    const maxCandidatesToGenerate = Math.min(
      2e3,
      factorial(this.uniqueConnections)
    );
    const candidatePolylineHashes = /* @__PURE__ */ new Set();
    for (let i = 0; i < maxCandidatesToGenerate; i++) {
      const newCandidate = this.createInitialCandidateFromSeed(i);
      if (!newCandidate) continue;
      const newCandidatePolylineHash = hashPolyLines(newCandidate.polyLines);
      if (candidatePolylineHashes.has(newCandidatePolylineHash)) continue;
      candidatePolylineHashes.add(newCandidatePolylineHash);
      this.candidates.push(newCandidate);
    }
    this.candidates.sort((a, b) => a.f - b.f);
  }
};

// lib/solvers/HyperHighDensitySolver/HyperSingleIntraNodeSolver.ts
var HyperSingleIntraNodeSolver = class extends HyperParameterSupervisorSolver {
  constructorParams;
  solvedRoutes = [];
  nodeWithPortPoints;
  connMap;
  constructor(opts) {
    super();
    this.nodeWithPortPoints = opts.nodeWithPortPoints;
    this.connMap = opts.connMap;
    this.constructorParams = opts;
    this.MAX_ITERATIONS = 25e4;
    this.GREEDY_MULTIPLIER = 5;
    this.MIN_SUBSTEPS = 100;
  }
  getCombinationDefs() {
    return [
      ["multiHeadPolyLine"],
      ["majorCombinations", "orderings6", "cellSizeFactor"],
      ["noVias"],
      ["orderings50"],
      ["flipTraceAlignmentDirection", "orderings6"],
      ["closedFormTwoTrace"]
    ];
  }
  getHyperParameterDefs() {
    return [
      {
        name: "majorCombinations",
        possibleValues: [
          {
            FUTURE_CONNECTION_PROX_TRACE_PENALTY_FACTOR: 2,
            FUTURE_CONNECTION_PROX_VIA_PENALTY_FACTOR: 1,
            FUTURE_CONNECTION_PROXIMITY_VD: 10,
            MISALIGNED_DIST_PENALTY_FACTOR: 5
          },
          {
            FUTURE_CONNECTION_PROX_TRACE_PENALTY_FACTOR: 1,
            FUTURE_CONNECTION_PROX_VIA_PENALTY_FACTOR: 0.5,
            FUTURE_CONNECTION_PROXIMITY_VD: 5,
            MISALIGNED_DIST_PENALTY_FACTOR: 2
          },
          {
            FUTURE_CONNECTION_PROX_TRACE_PENALTY_FACTOR: 10,
            FUTURE_CONNECTION_PROX_VIA_PENALTY_FACTOR: 1,
            FUTURE_CONNECTION_PROXIMITY_VD: 5,
            MISALIGNED_DIST_PENALTY_FACTOR: 10,
            VIA_PENALTY_FACTOR_2: 1
          }
        ]
      },
      {
        name: "orderings6",
        possibleValues: [
          {
            SHUFFLE_SEED: 0
          },
          {
            SHUFFLE_SEED: 1
          },
          {
            SHUFFLE_SEED: 2
          },
          {
            SHUFFLE_SEED: 3
          },
          {
            SHUFFLE_SEED: 4
          },
          {
            SHUFFLE_SEED: 5
          }
        ]
      },
      {
        name: "cellSizeFactor",
        possibleValues: [
          {
            CELL_SIZE_FACTOR: 0.5
          },
          {
            CELL_SIZE_FACTOR: 1
          }
        ]
      },
      {
        name: "flipTraceAlignmentDirection",
        possibleValues: [
          {
            FLIP_TRACE_ALIGNMENT_DIRECTION: true
          }
        ]
      },
      {
        name: "noVias",
        possibleValues: [
          {
            CELL_SIZE_FACTOR: 2,
            VIA_PENALTY_FACTOR_2: 10
          }
        ]
      },
      {
        name: "orderings50",
        possibleValues: Array.from({ length: 50 }, (_, i) => ({
          SHUFFLE_SEED: 100 + i
        }))
      },
      {
        name: "closedFormTwoTrace",
        possibleValues: [
          {
            CLOSED_FORM_TWO_TRACE_SAME_LAYER: true
          },
          {
            CLOSED_FORM_TWO_TRACE_TRANSITION_CROSSING: true
          }
        ]
      },
      {
        name: "multiHeadPolyLine",
        possibleValues: [
          {
            MULTI_HEAD_POLYLINE_SOLVER: true,
            SEGMENTS_PER_POLYLINE: 6,
            BOUNDARY_PADDING: 0.05
          },
          {
            MULTI_HEAD_POLYLINE_SOLVER: true,
            SEGMENTS_PER_POLYLINE: 6,
            BOUNDARY_PADDING: -0.05,
            // Allow vias/traces outside the boundary
            ITERATION_PENALTY: 1e4,
            MINIMUM_FINAL_ACCEPTANCE_GAP: 1e-3
          }
        ]
      }
    ];
  }
  computeG(solver) {
    if (solver?.hyperParameters?.MULTI_HEAD_POLYLINE_SOLVER) {
      return 1e3 + ((solver.hyperParameters?.ITERATION_PENALTY ?? 0) + solver.iterations) / 1e4 + 1e4 * (solver.hyperParameters.SEGMENTS_PER_POLYLINE - 3);
    }
    return solver.iterations / 1e4;
  }
  computeH(solver) {
    return 1 - (solver.progress || 0);
  }
  generateSolver(hyperParameters) {
    if (hyperParameters.CLOSED_FORM_TWO_TRACE_SAME_LAYER) {
      return new TwoCrossingRoutesHighDensitySolver({
        nodeWithPortPoints: this.nodeWithPortPoints
      });
    }
    if (hyperParameters.CLOSED_FORM_TWO_TRACE_TRANSITION_CROSSING) {
      return new SingleTransitionCrossingRouteSolver({
        nodeWithPortPoints: this.nodeWithPortPoints
      });
    }
    if (hyperParameters.MULTI_HEAD_POLYLINE_SOLVER) {
      return new MultiHeadPolyLineIntraNodeSolver3({
        nodeWithPortPoints: this.nodeWithPortPoints,
        connMap: this.connMap,
        hyperParameters
      });
    }
    return new IntraNodeRouteSolver({
      ...this.constructorParams,
      hyperParameters
    });
  }
  onSolve(solver) {
    this.solvedRoutes = solver.solver.solvedRoutes;
  }
};

// lib/utils/mergeRouteSegments.ts
function mergeRouteSegments(route, connectionName, color) {
  const segments = [];
  let currentSegment = null;
  for (let i = 0; i < route.length; i++) {
    const point = route[i];
    if (!currentSegment) {
      currentSegment = {
        points: [{ x: point.x, y: point.y }],
        z: point.z,
        connectionName,
        color
      };
    } else if (currentSegment.z === point.z) {
      currentSegment.points.push({ x: point.x, y: point.y });
    } else {
      segments.push(currentSegment);
      currentSegment = {
        points: [{ x: point.x, y: point.y }],
        z: point.z,
        connectionName,
        color
      };
    }
    if (i === route.length - 1 && currentSegment) {
      segments.push(currentSegment);
    }
  }
  return segments;
}

// lib/solvers/HighDensitySolver/HighDensitySolver.ts
var HighDensitySolver = class extends BaseSolver {
  unsolvedNodePortPoints;
  routes;
  colorMap;
  // Defaults as specified: viaDiameter of 0.6 and traceThickness of 0.15
  defaultViaDiameter = 0.6;
  defaultTraceThickness = 0.15;
  failedSolvers;
  activeSubSolver = null;
  connMap;
  constructor({
    nodePortPoints,
    colorMap,
    connMap
  }) {
    super();
    this.unsolvedNodePortPoints = nodePortPoints;
    this.colorMap = colorMap ?? {};
    this.connMap = connMap;
    this.routes = [];
    this.failedSolvers = [];
    this.MAX_ITERATIONS = 1e6;
  }
  /**
   * Each iteration, pop an unsolved node and attempt to find the routes inside
   * of it.
   */
  _step() {
    if (this.activeSubSolver) {
      this.activeSubSolver.step();
      if (this.activeSubSolver.solved) {
        this.routes.push(...this.activeSubSolver.solvedRoutes);
        this.activeSubSolver = null;
      } else if (this.activeSubSolver.failed) {
        this.failedSolvers.push(this.activeSubSolver);
        this.activeSubSolver = null;
      }
      return;
    }
    if (this.unsolvedNodePortPoints.length === 0) {
      if (this.failedSolvers.length > 0) {
        this.solved = false;
        this.failed = true;
        this.error = `Failed to solve ${this.failedSolvers.length} nodes, ${this.failedSolvers.slice(0, 5).map((fs) => fs.nodeWithPortPoints.capacityMeshNodeId)}. err0: ${this.failedSolvers[0].error}.`;
        return;
      }
      this.solved = true;
      return;
    }
    const node = this.unsolvedNodePortPoints.pop();
    this.activeSubSolver = new HyperSingleIntraNodeSolver({
      nodeWithPortPoints: node,
      colorMap: this.colorMap,
      connMap: this.connMap
    });
  }
  visualize() {
    let graphics = {
      lines: [],
      points: [],
      rects: [],
      circles: []
    };
    for (const route of this.routes) {
      const mergedSegments = mergeRouteSegments(
        route.route,
        route.connectionName,
        this.colorMap[route.connectionName]
      );
      for (const segment of mergedSegments) {
        graphics.lines.push({
          points: segment.points,
          label: segment.connectionName,
          strokeColor: segment.z === 0 ? segment.color : safeTransparentize(segment.color, 0.75),
          layer: `z${segment.z}`,
          strokeWidth: route.traceThickness,
          strokeDash: segment.z !== 0 ? "10, 5" : void 0
        });
      }
      for (const via of route.vias) {
        graphics.circles.push({
          center: via,
          layer: "z0,1",
          radius: route.viaDiameter / 2,
          fill: this.colorMap[route.connectionName],
          label: `${route.connectionName} via`
        });
      }
    }
    for (const solver of this.failedSolvers) {
      const node = solver.nodeWithPortPoints;
      const rectWidth = node.width * 0.1;
      const rectHeight = node.height * 0.1;
      graphics.rects.push({
        center: {
          x: node.center.x - rectWidth / 2,
          y: node.center.y - rectHeight / 2
        },
        layer: "did_not_connect",
        width: rectWidth,
        height: rectHeight,
        fill: "red",
        label: `Failed: ${node.capacityMeshNodeId}`
      });
      const connectionGroups = {};
      for (const pt of node.portPoints) {
        if (!connectionGroups[pt.connectionName]) {
          connectionGroups[pt.connectionName] = [];
        }
        connectionGroups[pt.connectionName].push({ x: pt.x, y: pt.y, z: pt.z });
      }
      for (const [connectionName, points] of Object.entries(connectionGroups)) {
        for (let i = 0; i < points.length - 1; i++) {
          const start = points[i];
          const end = points[i + 1];
          graphics.lines.push({
            points: [start, end],
            strokeColor: "red",
            strokeDash: "10, 5",
            layer: "did_not_connect"
          });
        }
      }
    }
    if (this.activeSubSolver) {
      graphics = combineVisualizations(
        graphics,
        this.activeSubSolver.visualize()
      );
    }
    return graphics;
  }
};

// node_modules/circuit-json-to-connectivity-map/dist/index.js
var ConnectivityMap = class {
  netMap;
  idToNetMap;
  constructor(netMap) {
    this.netMap = netMap;
    this.idToNetMap = {};
    for (const [netId, ids] of Object.entries(netMap)) {
      for (const id of ids) {
        this.idToNetMap[id] = netId;
      }
    }
  }
  addConnections(connections) {
    for (const connection of connections) {
      const existingNets = /* @__PURE__ */ new Set();
      for (const id of connection) {
        const existingNetId = this.idToNetMap[id];
        if (existingNetId) {
          existingNets.add(existingNetId);
        }
      }
      let targetNetId;
      if (existingNets.size === 0) {
        targetNetId = `connectivity_net${Object.keys(this.netMap).length}`;
        this.netMap[targetNetId] = [];
      } else if (existingNets.size === 1) {
        targetNetId = existingNets.values().next().value ?? `connectivity_net${Object.keys(this.netMap).length}`;
      } else {
        targetNetId = existingNets.values().next().value ?? `connectivity_net${Object.keys(this.netMap).length}`;
        for (const netId of existingNets) {
          if (netId !== targetNetId) {
            this.netMap[targetNetId].push(...this.netMap[netId]);
            this.netMap[netId] = this.netMap[targetNetId];
            for (const id of this.netMap[targetNetId]) {
              this.idToNetMap[id] = targetNetId;
            }
          }
        }
      }
      for (const id of connection) {
        if (!this.netMap[targetNetId].includes(id)) {
          this.netMap[targetNetId].push(id);
        }
        this.idToNetMap[id] = targetNetId;
      }
    }
  }
  getIdsConnectedToNet(netId) {
    return this.netMap[netId] || [];
  }
  getNetConnectedToId(id) {
    return this.idToNetMap[id];
  }
  areIdsConnected(id1, id2) {
    if (id1 === id2) return true;
    const netId1 = this.getNetConnectedToId(id1);
    if (!netId1) return false;
    const netId2 = this.getNetConnectedToId(id2);
    if (!netId2) return false;
    return netId1 === netId2 || netId2 === id1 || netId2 === id1;
  }
  areAllIdsConnected(ids) {
    const netId = this.getNetConnectedToId(ids[0]);
    for (const id of ids) {
      const nextNetId = this.getNetConnectedToId(id);
      if (nextNetId === void 0) {
        return false;
      }
      if (nextNetId !== netId) {
        return false;
      }
    }
    return true;
  }
};

// lib/utils/getConnectivityMapFromSimpleRouteJson.ts
var getConnectivityMapFromSimpleRouteJson = (srj) => {
  const connMap = new ConnectivityMap({});
  for (const connection of srj.connections) {
    for (const point of connection.pointsToConnect) {
      if ("pcb_port_id" in point && point.pcb_port_id) {
        connMap.addConnections([[connection.name, point.pcb_port_id]]);
      }
    }
  }
  for (const obstacle of srj.obstacles) {
    connMap.addConnections([obstacle.connectedTo]);
  }
  return connMap;
};

// lib/solvers/NetToPointPairsSolver/buildMinimumSpanningTree.ts
var KDNode = class {
  point;
  left = null;
  right = null;
  constructor(point) {
    this.point = point;
  }
};
var KDTree = class {
  root = null;
  constructor(points) {
    if (points.length > 0) {
      this.root = this.buildTree(points, 0);
    }
  }
  buildTree(points, depth) {
    const axis = depth % 2 === 0 ? "x" : "y";
    points.sort((a, b) => a[axis] - b[axis]);
    const medianIndex = Math.floor(points.length / 2);
    const node = new KDNode(points[medianIndex]);
    if (medianIndex > 0) {
      node.left = this.buildTree(points.slice(0, medianIndex), depth + 1);
    }
    if (medianIndex < points.length - 1) {
      node.right = this.buildTree(points.slice(medianIndex + 1), depth + 1);
    }
    return node;
  }
  // Find the nearest neighbor to a query point
  findNearestNeighbor(queryPoint) {
    if (!this.root) {
      throw new Error("Tree is empty");
    }
    const best = this.root.point;
    const bestDistance = this.distance(queryPoint, best);
    this.nearestNeighborSearch(this.root, queryPoint, 0, best, bestDistance);
    return best;
  }
  nearestNeighborSearch(node, queryPoint, depth, best, bestDistance) {
    if (!node) {
      return best;
    }
    const axis = depth % 2 ? "x" : "y";
    const currentDistance = this.distance(queryPoint, node.point);
    if (currentDistance < bestDistance) {
      best = node.point;
      bestDistance = currentDistance;
    }
    const axisDiff = queryPoint[axis] - node.point[axis];
    const firstBranch = axisDiff <= 0 ? node.left : node.right;
    const secondBranch = axisDiff <= 0 ? node.right : node.left;
    best = this.nearestNeighborSearch(
      firstBranch,
      queryPoint,
      depth + 1,
      best,
      bestDistance
    );
    bestDistance = this.distance(queryPoint, best);
    if (Math.abs(axisDiff) < bestDistance) {
      best = this.nearestNeighborSearch(
        secondBranch,
        queryPoint,
        depth + 1,
        best,
        bestDistance
      );
    }
    return best;
  }
  // Find k nearest neighbors
  findKNearestNeighbors(queryPoint, k) {
    if (!this.root) {
      return [];
    }
    const neighbors = [];
    this.kNearestNeighborSearch(this.root, queryPoint, 0, neighbors, k);
    return neighbors.sort((a, b) => a.distance - b.distance).slice(0, k).map((n) => n.point);
  }
  kNearestNeighborSearch(node, queryPoint, depth, neighbors, k) {
    if (!node) {
      return;
    }
    const axis = depth % 2 ? "x" : "y";
    const currentDistance = this.distance(queryPoint, node.point);
    neighbors.push({ point: node.point, distance: currentDistance });
    const axisDiff = queryPoint[axis] - node.point[axis];
    const firstBranch = axisDiff <= 0 ? node.left : node.right;
    const secondBranch = axisDiff <= 0 ? node.right : node.left;
    this.kNearestNeighborSearch(
      firstBranch,
      queryPoint,
      depth + 1,
      neighbors,
      k
    );
    let kthDistance = Infinity;
    if (neighbors.length >= k) {
      neighbors.sort((a, b) => a.distance - b.distance);
      kthDistance = neighbors[k - 1]?.distance || Infinity;
    }
    if (Math.abs(axisDiff) < kthDistance || neighbors.length < k) {
      this.kNearestNeighborSearch(
        secondBranch,
        queryPoint,
        depth + 1,
        neighbors,
        k
      );
    }
  }
  // Calculate Euclidean distance between two points
  distance(a, b) {
    return Math.sqrt((a.x - b.x) ** 2 + (a.y - b.y) ** 2);
  }
};
var DisjointSet = class {
  parent = /* @__PURE__ */ new Map();
  rank = /* @__PURE__ */ new Map();
  constructor(points) {
    for (const point of points) {
      const key = this.pointToKey(point);
      this.parent.set(key, key);
      this.rank.set(key, 0);
    }
  }
  pointToKey(point) {
    return `${point.x},${point.y}`;
  }
  find(point) {
    const key = this.pointToKey(point);
    if (!this.parent.has(key)) {
      throw new Error(`Point ${key} not found in DisjointSet`);
    }
    let root = key;
    while (root !== this.parent.get(root)) {
      root = this.parent.get(root);
    }
    let current = key;
    while (current !== root) {
      const next = this.parent.get(current);
      this.parent.set(current, root);
      current = next;
    }
    return root;
  }
  union(pointA, pointB) {
    const rootA = this.find(pointA);
    const rootB = this.find(pointB);
    if (rootA === rootB) {
      return false;
    }
    const rankA = this.rank.get(rootA) || 0;
    const rankB = this.rank.get(rootB) || 0;
    if (rankA < rankB) {
      this.parent.set(rootA, rootB);
    } else if (rankA > rankB) {
      this.parent.set(rootB, rootA);
    } else {
      this.parent.set(rootB, rootA);
      this.rank.set(rootA, rankA + 1);
    }
    return true;
  }
};
function buildMinimumSpanningTree(points) {
  if (points.length <= 1) {
    return [];
  }
  const kdTree = new KDTree(points);
  const edges = [];
  const k = Math.min(10, points.length - 1);
  for (const point of points) {
    const neighbors = kdTree.findKNearestNeighbors(point, k + 1);
    for (const neighbor of neighbors) {
      if (point.x === neighbor.x && point.y === neighbor.y) {
        continue;
      }
      const distance6 = Math.sqrt(
        (point.x - neighbor.x) ** 2 + (point.y - neighbor.y) ** 2
      );
      edges.push({
        from: point,
        to: neighbor,
        weight: distance6
      });
    }
  }
  edges.sort((a, b) => a.weight - b.weight);
  const disjointSet = new DisjointSet(points);
  const mstEdges = [];
  for (const edge of edges) {
    if (disjointSet.union(edge.from, edge.to)) {
      mstEdges.push(edge);
      if (mstEdges.length === points.length - 1) {
        break;
      }
    }
  }
  return mstEdges;
}

// lib/solvers/NetToPointPairsSolver/NetToPointPairsSolver.ts
var NetToPointPairsSolver = class extends BaseSolver {
  constructor(ogSrj, colorMap = {}) {
    super();
    this.ogSrj = ogSrj;
    this.colorMap = colorMap;
    this.unprocessedConnections = [...ogSrj.connections];
    this.newConnections = [];
  }
  unprocessedConnections;
  newConnections;
  _step() {
    if (this.unprocessedConnections.length === 0) {
      this.solved = true;
      return;
    }
    const connection = this.unprocessedConnections.pop();
    const externalGroups = connection.externallyConnectedPointIds ?? [];
    const pointIdToGroup = /* @__PURE__ */ new Map();
    externalGroups.forEach(
      (group, idx) => group.forEach((pid) => pointIdToGroup.set(pid, idx))
    );
    const areExternallyConnected = (a, b) => {
      if (!a.pointId || !b.pointId) return false;
      const g1 = pointIdToGroup.get(a.pointId);
      const g2 = pointIdToGroup.get(b.pointId);
      return g1 !== void 0 && g1 === g2;
    };
    if (connection.pointsToConnect.length === 2) {
      if (areExternallyConnected(
        connection.pointsToConnect[0],
        connection.pointsToConnect[1]
      )) {
        return;
      }
      this.newConnections.push(connection);
      return;
    }
    const edges = buildMinimumSpanningTree(connection.pointsToConnect);
    let mstIdx = 0;
    for (const edge of edges) {
      if (areExternallyConnected(edge.from, edge.to)) continue;
      this.newConnections.push({
        pointsToConnect: [edge.from, edge.to],
        name: `${connection.name}_mst${mstIdx++}`
      });
    }
  }
  getNewSimpleRouteJson() {
    return {
      ...this.ogSrj,
      connections: this.newConnections
    };
  }
  visualize() {
    const graphics = {
      lines: [],
      points: [],
      rects: [],
      circles: [],
      coordinateSystem: "cartesian",
      title: "Net To Point Pairs Visualization"
    };
    this.unprocessedConnections.forEach((connection) => {
      connection.pointsToConnect.forEach((point) => {
        graphics.points.push({
          x: point.x,
          y: point.y,
          color: "red",
          label: connection.name
        });
      });
      const fullyConnectedEdgeCount = connection.pointsToConnect.length ** 2;
      const random = seededRandom(0);
      const alreadyPlacedEdges = /* @__PURE__ */ new Set();
      for (let i = 0; i < Math.max(
        fullyConnectedEdgeCount,
        connection.pointsToConnect.length * 2
      ); i++) {
        const a = Math.floor(random() * connection.pointsToConnect.length);
        const b = Math.floor(random() * connection.pointsToConnect.length);
        if (alreadyPlacedEdges.has(`${a}-${b}`)) continue;
        alreadyPlacedEdges.add(`${a}-${b}`);
        graphics.lines.push({
          points: [
            connection.pointsToConnect[a],
            connection.pointsToConnect[b]
          ],
          strokeColor: "rgba(255,0,0,0.25)"
        });
      }
    });
    this.newConnections.forEach((connection) => {
      const color = this.colorMap?.[connection.name] || "blue";
      connection.pointsToConnect.forEach((point) => {
        graphics.points.push({
          x: point.x,
          y: point.y,
          color,
          label: connection.name
        });
      });
      for (let i = 0; i < connection.pointsToConnect.length - 1; i++) {
        for (let j = i + 1; j < connection.pointsToConnect.length; j++) {
          graphics.lines.push({
            points: [
              connection.pointsToConnect[i],
              connection.pointsToConnect[j]
            ],
            strokeColor: color
          });
        }
      }
    });
    return graphics;
  }
};

// lib/utils/mapZToLayerName.ts
var mapZToLayerName = (z, layerCount) => {
  if (z < 0 || z >= layerCount) {
    throw new Error(`Invalid z "${z}" for layer count: ${layerCount}`);
  }
  if (z === 0) return "top";
  if (z === layerCount - 1) return "bottom";
  return `inner${z}`;
};

// lib/utils/convertHdRouteToSimplifiedRoute.ts
var convertHdRouteToSimplifiedRoute = (hdRoute, layerCount) => {
  const result = [];
  if (hdRoute.route.length === 0) return result;
  let currentLayerPoints = [];
  let currentZ = hdRoute.route[0].z;
  for (let i = 0; i < hdRoute.route.length; i++) {
    const point = hdRoute.route[i];
    if (point.z !== currentZ) {
      const layerName2 = mapZToLayerName(currentZ, layerCount);
      for (const layerPoint of currentLayerPoints) {
        result.push({
          route_type: "wire",
          x: layerPoint.x,
          y: layerPoint.y,
          width: hdRoute.traceThickness,
          layer: layerName2
        });
      }
      const viaExists = hdRoute.vias.some(
        (via) => Math.abs(via.x - point.x) < 1e-3 && Math.abs(via.y - point.y) < 1e-3
      );
      if (viaExists) {
        const fromLayer = mapZToLayerName(currentZ, layerCount);
        const toLayer = mapZToLayerName(point.z, layerCount);
        result.push({
          route_type: "via",
          x: point.x,
          y: point.y,
          from_layer: fromLayer,
          to_layer: toLayer
        });
      }
      currentLayerPoints = [point];
      currentZ = point.z;
    } else {
      currentLayerPoints.push(point);
    }
  }
  const layerName = mapZToLayerName(currentZ, layerCount);
  for (const layerPoint of currentLayerPoints) {
    result.push({
      route_type: "wire",
      x: layerPoint.x,
      y: layerPoint.y,
      width: hdRoute.traceThickness,
      layer: layerName
    });
  }
  return result;
};

// lib/solvers/RouteStitchingSolver/SingleHighDensityRouteStitchSolver.ts
var SingleHighDensityRouteStitchSolver = class extends BaseSolver {
  mergedHdRoute;
  remainingHdRoutes;
  start;
  end;
  colorMap;
  constructor(opts) {
    super();
    this.remainingHdRoutes = [...opts.hdRoutes];
    this.colorMap = opts.colorMap ?? {};
    if (opts.hdRoutes.length === 0) {
      this.start = opts.start;
      this.end = opts.end;
      const routePoints = [
        { x: opts.start.x, y: opts.start.y, z: opts.start.z }
      ];
      const vias = [];
      if (opts.start.z !== opts.end.z) {
        routePoints.push({ x: opts.start.x, y: opts.start.y, z: opts.end.z });
        vias.push({ x: opts.start.x, y: opts.start.y });
      }
      routePoints.push({ x: opts.end.x, y: opts.end.y, z: opts.end.z });
      this.mergedHdRoute = {
        connectionName: opts.connectionName,
        route: routePoints,
        vias,
        viaDiameter: opts.defaultViaDiameter ?? 0.6,
        // Use default or fallback
        traceThickness: opts.defaultTraceThickness ?? 0.15
        // Use default or fallback
      };
      this.solved = true;
      return;
    }
    const { firstRoute } = this.getDisjointedRoute();
    const firstRouteToStartDist = Math.min(
      distance(firstRoute.route[0], opts.start),
      distance(firstRoute.route[firstRoute.route.length - 1], opts.start)
    );
    const firstRouteToEndDist = Math.min(
      distance(firstRoute.route[0], opts.end),
      distance(firstRoute.route[firstRoute.route.length - 1], opts.end)
    );
    if (firstRouteToStartDist < firstRouteToEndDist) {
      this.start = opts.start;
      this.end = opts.end;
    } else {
      this.start = opts.end;
      this.end = opts.start;
    }
    this.mergedHdRoute = {
      connectionName: opts.connectionName,
      // Use mandatory connectionName
      route: [
        {
          x: this.start.x,
          y: this.start.y,
          z: this.start.z
        }
      ],
      vias: [],
      viaDiameter: firstRoute.viaDiameter,
      traceThickness: firstRoute.traceThickness
    };
  }
  /**
   * Scan `remainingHdRoutes` and find a route that has **one** end that is not
   * within `5e-6` of the start or end of any other route on the same layer.
   * That lonely end marks one extremity of the whole chain, which we use as
   * our starting segment. If no such route exists (e.g., the data form a loop),
   * we simply return the first route so the solver can proceed.
   */
  getDisjointedRoute() {
    const TOL = 5e-6;
    for (const candidate of this.remainingHdRoutes) {
      const candidateEnds = [
        candidate.route[0],
        candidate.route[candidate.route.length - 1]
      ];
      const hasLonelyEnd = candidateEnds.some((end) => {
        return !this.remainingHdRoutes.some((other) => {
          if (other === candidate) return false;
          const otherEnds = [
            other.route[0],
            other.route[other.route.length - 1]
          ];
          return otherEnds.some(
            (oe) => oe.z === end.z && distance(end, oe) < TOL
          );
        });
      });
      if (hasLonelyEnd) {
        return { firstRoute: candidate };
      }
    }
    return { firstRoute: this.remainingHdRoutes[0] };
  }
  _step() {
    if (this.remainingHdRoutes.length === 0) {
      this.mergedHdRoute.route.push({
        x: this.end.x,
        y: this.end.y,
        z: this.end.z
      });
      this.solved = true;
      return;
    }
    const lastMergedPoint = this.mergedHdRoute.route[this.mergedHdRoute.route.length - 1];
    let closestRouteIndex = 0;
    let matchedOn = "first";
    let closestDistance = Infinity;
    for (let i = 0; i < this.remainingHdRoutes.length; i++) {
      const hdRoute = this.remainingHdRoutes[i];
      const lastPointInCandidate = hdRoute.route[hdRoute.route.length - 1];
      const firstPointInCandidate = hdRoute.route[0];
      const distToFirst = distance(lastMergedPoint, firstPointInCandidate);
      const distToLast = distance(lastMergedPoint, lastPointInCandidate);
      if (distToFirst < closestDistance && lastMergedPoint.z === firstPointInCandidate.z) {
        closestDistance = distToFirst;
        closestRouteIndex = i;
        matchedOn = "first";
      }
      if (distToLast < closestDistance && lastMergedPoint.z === lastPointInCandidate.z) {
        closestDistance = distToLast;
        closestRouteIndex = i;
        matchedOn = "last";
      }
    }
    const hdRouteToMerge = this.remainingHdRoutes[closestRouteIndex];
    this.remainingHdRoutes.splice(closestRouteIndex, 1);
    if (matchedOn === "first") {
      this.mergedHdRoute.route.push(...hdRouteToMerge.route);
    } else {
      this.mergedHdRoute.route.push(...[...hdRouteToMerge.route].reverse());
    }
    this.mergedHdRoute.vias.push(...hdRouteToMerge.vias);
  }
  visualize() {
    const graphics = {
      points: [],
      lines: [],
      circles: [],
      title: "Single High Density Route Stitch Solver"
    };
    graphics.points?.push(
      {
        x: this.start.x,
        y: this.start.y,
        color: "green",
        label: "Start"
      },
      {
        x: this.end.x,
        y: this.end.y,
        color: "red",
        label: "End"
      }
    );
    if (this.mergedHdRoute && this.mergedHdRoute.route.length > 1) {
      graphics.lines?.push({
        points: this.mergedHdRoute.route.map((point) => ({
          x: point.x,
          y: point.y
        })),
        strokeColor: "green"
      });
      for (const point of this.mergedHdRoute.route) {
        graphics.points?.push({
          x: point.x,
          y: point.y,
          color: "green"
        });
      }
      for (const via of this.mergedHdRoute.vias) {
        graphics.circles?.push({
          center: { x: via.x, y: via.y },
          radius: this.mergedHdRoute.viaDiameter / 2,
          fill: "green"
        });
      }
    }
    for (const [i, hdRoute] of this.remainingHdRoutes.entries()) {
      const routeColor = this.colorMap[hdRoute.connectionName] ?? "gray";
      if (hdRoute.route.length > 1) {
        graphics.lines?.push({
          points: hdRoute.route.map((point) => ({ x: point.x, y: point.y })),
          strokeColor: routeColor
        });
      }
      for (let pi = 0; pi < hdRoute.route.length; pi++) {
        const point = hdRoute.route[pi];
        graphics.points?.push({
          x: point.x + (i % 2 - 0.5) / 500 + (pi % 8 - 4) / 1e3,
          // Keep slight offset for visibility
          y: point.y + (i % 2 - 0.5) / 500 + (pi % 8 - 4) / 1e3,
          color: routeColor,
          label: `Route ${hdRoute.connectionName} ${point === hdRoute.route[0] ? "First" : point === hdRoute.route[hdRoute.route.length - 1] ? "Last" : ""}`
        });
      }
      for (const via of hdRoute.vias) {
        graphics.circles?.push({
          center: { x: via.x, y: via.y },
          radius: hdRoute.viaDiameter / 2,
          fill: routeColor
        });
      }
    }
    return graphics;
  }
};

// lib/solvers/RouteStitchingSolver/MultipleHighDensityRouteStitchSolver.ts
var MultipleHighDensityRouteStitchSolver = class extends BaseSolver {
  unsolvedRoutes;
  activeSolver = null;
  mergedHdRoutes = [];
  colorMap = {};
  defaultTraceThickness;
  defaultViaDiameter;
  constructor(opts) {
    super();
    this.colorMap = opts.colorMap ?? {};
    if (opts.hdRoutes.length > 0) {
      this.defaultTraceThickness = opts.hdRoutes[0].traceThickness;
      this.defaultViaDiameter = opts.hdRoutes[0].viaDiameter;
    } else {
      this.defaultTraceThickness = 0.15;
      this.defaultViaDiameter = 0.6;
    }
    this.unsolvedRoutes = opts.connections.map((c) => ({
      connectionName: c.name,
      hdRoutes: opts.hdRoutes.filter((r) => r.connectionName === c.name),
      start: {
        ...c.pointsToConnect[0],
        z: mapLayerNameToZ(c.pointsToConnect[0].layer, opts.layerCount)
      },
      end: {
        ...c.pointsToConnect[1],
        z: mapLayerNameToZ(c.pointsToConnect[1].layer, opts.layerCount)
      }
    }));
    this.MAX_ITERATIONS = 1e5;
  }
  _step() {
    if (this.activeSolver) {
      this.activeSolver.step();
      if (this.activeSolver.solved) {
        this.mergedHdRoutes.push(this.activeSolver.mergedHdRoute);
        this.activeSolver = null;
      } else if (this.activeSolver.failed) {
        this.failed = true;
        this.error = this.activeSolver.error;
      }
      return;
    }
    const unsolvedRoute = this.unsolvedRoutes.pop();
    if (!unsolvedRoute) {
      this.solved = true;
      return;
    }
    this.activeSolver = new SingleHighDensityRouteStitchSolver({
      connectionName: unsolvedRoute.connectionName,
      hdRoutes: unsolvedRoute.hdRoutes,
      start: unsolvedRoute.start,
      end: unsolvedRoute.end,
      colorMap: this.colorMap,
      defaultTraceThickness: this.defaultTraceThickness,
      defaultViaDiameter: this.defaultViaDiameter
    });
  }
  visualize() {
    const graphics = {
      points: [],
      lines: [],
      circles: [],
      title: "Multiple High Density Route Stitch Solver"
    };
    if (this.activeSolver) {
      const activeSolverGraphics = this.activeSolver.visualize();
      if (activeSolverGraphics.points?.length) {
        graphics.points?.push(...activeSolverGraphics.points);
      }
      if (activeSolverGraphics.lines?.length) {
        graphics.lines?.push(...activeSolverGraphics.lines);
      }
      if (activeSolverGraphics.circles?.length) {
        graphics.circles?.push(...activeSolverGraphics.circles);
      }
      if (activeSolverGraphics.rects?.length) {
        graphics.rects = activeSolverGraphics.rects;
      }
    }
    for (const [i, mergedRoute] of this.mergedHdRoutes.entries()) {
      const solvedColor = this.colorMap[mergedRoute.connectionName] ?? `hsl(120, 100%, ${40 + i * 10 % 40}%)`;
      for (let j = 0; j < mergedRoute.route.length - 1; j++) {
        const p1 = mergedRoute.route[j];
        const p2 = mergedRoute.route[j + 1];
        const segmentColor = p1.z !== 0 ? safeTransparentize(solvedColor, 0.5) : solvedColor;
        graphics.lines?.push({
          points: [
            { x: p1.x, y: p1.y },
            { x: p2.x, y: p2.y }
          ],
          strokeColor: segmentColor,
          strokeWidth: mergedRoute.traceThickness
        });
      }
      for (const point of mergedRoute.route) {
        const pointColor = point.z !== 0 ? safeTransparentize(solvedColor, 0.5) : solvedColor;
        graphics.points?.push({
          x: point.x,
          y: point.y,
          color: pointColor
        });
      }
      for (const via of mergedRoute.vias) {
        graphics.circles?.push({
          center: { x: via.x, y: via.y },
          radius: mergedRoute.viaDiameter / 2,
          fill: solvedColor
          // Keep vias solid color for visibility
        });
      }
    }
    for (const unsolvedRoute of this.unsolvedRoutes) {
      const routeColor = this.colorMap[unsolvedRoute.connectionName] ?? "gray";
      graphics.points?.push(
        {
          x: unsolvedRoute.start.x,
          y: unsolvedRoute.start.y,
          color: routeColor,
          label: `${unsolvedRoute.connectionName} Start (z=${unsolvedRoute.start.z})`
        },
        {
          x: unsolvedRoute.end.x,
          y: unsolvedRoute.end.y,
          color: routeColor,
          label: `${unsolvedRoute.connectionName} End (z=${unsolvedRoute.end.z})`
        }
      );
      graphics.lines?.push({
        points: [
          { x: unsolvedRoute.start.x, y: unsolvedRoute.start.y },
          { x: unsolvedRoute.end.x, y: unsolvedRoute.end.y }
        ],
        strokeColor: routeColor,
        strokeDash: "2 2"
      });
      for (const hdRoute of unsolvedRoute.hdRoutes) {
        if (hdRoute.route.length > 1) {
          graphics.lines?.push({
            points: hdRoute.route.map((point) => ({ x: point.x, y: point.y })),
            strokeColor: safeTransparentize(routeColor, 0.5),
            // Use routeColor
            strokeDash: "10 5"
          });
        }
        for (const via of hdRoute.vias) {
          graphics.circles?.push({
            center: { x: via.x, y: via.y },
            radius: hdRoute.viaDiameter / 2,
            fill: routeColor
            // Use routeColor
          });
        }
      }
    }
    return graphics;
  }
};

// lib/utils/convertSrjToGraphicsObject.ts
var convertSrjToGraphicsObject = (srj) => {
  const lines = [];
  const circles = [];
  const points = [];
  const colorMap = getColorMap(srj);
  const layerCount = 2;
  if (srj.connections) {
    for (const connection of srj.connections) {
      for (const point of connection.pointsToConnect) {
        points.push({
          x: point.x,
          y: point.y,
          color: colorMap[connection.name],
          layer: point.layer ?? ("z" in point ? mapZToLayerName(point.z, layerCount) : "top"),
          label: `${connection.name} (${point.layer})`
        });
      }
    }
  }
  if (srj.traces) {
    for (const trace of srj.traces) {
      for (let j = 0; j < trace.route.length - 1; j++) {
        const routePoint = trace.route[j];
        const nextRoutePoint = trace.route[j + 1];
        if (routePoint.route_type === "via") {
          circles.push({
            center: { x: routePoint.x, y: routePoint.y },
            radius: 0.3,
            // 0.6 via diameter
            fill: "blue",
            stroke: "none",
            layer: "z0,1"
          });
        } else if (routePoint.route_type === "wire" && nextRoutePoint.route_type === "wire" && nextRoutePoint.layer === routePoint.layer) {
          lines.push({
            points: [
              { x: routePoint.x, y: routePoint.y },
              { x: nextRoutePoint.x, y: nextRoutePoint.y }
            ],
            layer: `z${mapLayerNameToZ(routePoint.layer, layerCount)}`,
            strokeWidth: 0.15,
            strokeColor: safeTransparentize(
              {
                top: "red",
                bottom: "blue",
                inner1: "green",
                inner2: "yellow"
              }[routePoint.layer],
              0.5
            )
            // For some reason this is too small, likely a graphics-debug bug
            // strokeWidth: 0.15,
          });
        }
      }
    }
  }
  return {
    rects: srj.obstacles.map(
      (o) => ({
        center: o.center,
        width: o.width,
        height: o.height,
        fill: "rgba(255,0,0,0.5)",
        layer: `z${o.layers.map(mapLayerNameToZ).join(",")}`
      })
    ),
    circles,
    lines,
    points
  };
};

// lib/solvers/UnravelSolver/getNodesNearNode.ts
function getNodesNearNode(params) {
  const { nodeId, nodeIdToSegmentIds, segmentIdToNodeIds, hops } = params;
  if (hops === 0) return [nodeId];
  const visitedNodes = /* @__PURE__ */ new Set([nodeId]);
  const exploreQueue = [{ nodeId, remainingHops: hops }];
  while (exploreQueue.length > 0) {
    const { nodeId: node, remainingHops } = exploreQueue.shift();
    if (remainingHops === 0) continue;
    const segments = nodeIdToSegmentIds.get(node) || [];
    for (const segmentId of segments) {
      const adjacentNodeIds = segmentIdToNodeIds.get(segmentId) || [];
      for (const adjacentNodeId of adjacentNodeIds) {
        if (!visitedNodes.has(adjacentNodeId)) {
          visitedNodes.add(adjacentNodeId);
          exploreQueue.push({
            nodeId: adjacentNodeId,
            remainingHops: remainingHops - 1
          });
        }
      }
    }
  }
  return Array.from(visitedNodes);
}

// lib/solvers/UnravelSolver/createPointModificationsHash.ts
var createPointModificationsHash = (pointModifications) => {
  return Array.from(pointModifications.entries()).map(
    ([id, { x, y, z }]) => `${id}(${x?.toFixed(3) ?? ""},${y?.toFixed(3) ?? ""},${z ?? ""})`
  ).sort().join("&");
};

// lib/solvers/UnravelSolver/hasZRangeOverlap.ts
var hasZRangeOverlap = (A_z1, A_z2, B_z1, B_z2) => {
  const Amin = Math.min(A_z1, A_z2);
  const Amax = Math.max(A_z1, A_z2);
  const Bmin = Math.min(B_z1, B_z2);
  const Bmax = Math.max(B_z1, B_z2);
  return Amin <= Bmax && Amax >= Bmin;
};

// lib/solvers/UnravelSolver/getIssuesInSection.ts
var getIssuesInSection = (section, nodeMap, pointModifications, connMap) => {
  const issues = [];
  const points = new Map(section.originalPointMap);
  for (const [segmentPointId, modPoint] of pointModifications.entries()) {
    const ogPoint = points.get(segmentPointId);
    points.set(segmentPointId, {
      x: modPoint.x ?? ogPoint.x,
      y: modPoint.y ?? ogPoint.y,
      z: modPoint.z ?? ogPoint.z
    });
  }
  for (const nodeId of section.allNodeIds) {
    const node = nodeMap.get(nodeId);
    if (!node) continue;
    const nodeSegmentPairs = section.segmentPairsInNode.get(nodeId);
    for (const pair of nodeSegmentPairs) {
      const A = points.get(pair[0]);
      const B = points.get(pair[1]);
      if (A.z !== B.z) {
        issues.push({
          type: "transition_via",
          segmentPoints: pair,
          capacityMeshNodeId: nodeId,
          probabilityOfFailure: 0
        });
      }
    }
    for (let i = 0; i < nodeSegmentPairs.length; i++) {
      for (let j = i + 1; j < nodeSegmentPairs.length; j++) {
        if (connMap?.areIdsConnected(
          nodeSegmentPairs[i][0],
          nodeSegmentPairs[i][1]
        )) {
          continue;
        }
        const pair1 = nodeSegmentPairs[i];
        const pair2 = nodeSegmentPairs[j];
        const A = points.get(pair1[0]);
        const B = points.get(pair1[1]);
        const C = points.get(pair2[0]);
        const D = points.get(pair2[1]);
        if (!hasZRangeOverlap(A.z, B.z, C.z, D.z)) continue;
        const areCrossing = doSegmentsIntersect(A, B, C, D);
        const isSameLayer = A.z === B.z && C.z === D.z && A.z === C.z;
        if (areCrossing) {
          if (isSameLayer) {
            issues.push({
              type: "same_layer_crossing",
              segmentPoints: [pair1, pair2],
              capacityMeshNodeId: nodeId,
              crossingLine1: pair1,
              crossingLine2: pair2,
              probabilityOfFailure: 0
            });
          } else if (A.z === B.z && C.z !== D.z) {
            issues.push({
              type: "single_transition_crossing",
              segmentPoints: [pair1, pair2],
              capacityMeshNodeId: nodeId,
              sameLayerCrossingLine: pair1,
              transitionCrossingLine: pair2,
              probabilityOfFailure: 0
            });
          } else if (A.z !== B.z && C.z === D.z) {
            issues.push({
              type: "single_transition_crossing",
              segmentPoints: [pair1, pair2],
              capacityMeshNodeId: nodeId,
              sameLayerCrossingLine: pair2,
              transitionCrossingLine: pair1,
              probabilityOfFailure: 0
            });
          } else if (A.z !== B.z && C.z !== D.z) {
            issues.push({
              type: "double_transition_crossing",
              segmentPoints: [pair1, pair2],
              capacityMeshNodeId: nodeId,
              crossingLine1: pair1,
              crossingLine2: pair2,
              probabilityOfFailure: 0
            });
          }
        }
      }
    }
  }
  return issues;
};

// lib/solvers/UnravelSolver/applyOperationToPointModifications.ts
var applyOperationToPointModifications = (pointModifications, operation, getPointInCandidate) => {
  if (operation.type === "change_layer") {
    for (const segmentPointId of operation.segmentPointIds) {
      const existingMods = pointModifications.get(segmentPointId) || {};
      pointModifications.set(segmentPointId, {
        ...existingMods,
        z: operation.newZ
      });
    }
  } else if (operation.type === "swap_position_on_segment") {
    const [ASpId, BSpId] = operation.segmentPointIds;
    const A = getPointInCandidate(ASpId);
    const B = getPointInCandidate(BSpId);
    const existingModsA = pointModifications.get(ASpId) || {};
    const existingModsB = pointModifications.get(BSpId) || {};
    pointModifications.set(ASpId, {
      ...existingModsA,
      x: B.x,
      y: B.y
    });
    pointModifications.set(BSpId, {
      ...existingModsB,
      x: A.x,
      y: A.y
    });
  } else if (operation.type === "combined") {
    for (const subOperation of operation.operations) {
      applyOperationToPointModifications(
        pointModifications,
        subOperation,
        getPointInCandidate
      );
    }
  }
};

// lib/solvers/UnravelSolver/createSegmentPointMap.ts
var createSegmentPointMap = (dedupedSegments, segmentIdToNodeIds) => {
  const segmentPointMap = /* @__PURE__ */ new Map();
  const nodeToSegmentPointMap = /* @__PURE__ */ new Map();
  const segmentToSegmentPointMap = /* @__PURE__ */ new Map();
  const segmentPoints = [];
  let highestSegmentPointId = 0;
  for (const segment of dedupedSegments) {
    for (const point of segment.assignedPoints) {
      const sp = {
        segmentPointId: `SP${highestSegmentPointId++}`,
        segmentId: segment.nodePortSegmentId,
        capacityMeshNodeIds: segmentIdToNodeIds.get(
          segment.nodePortSegmentId
        ),
        connectionName: point.connectionName,
        x: point.point.x,
        y: point.point.y,
        z: point.point.z,
        directlyConnectedSegmentPointIds: []
      };
      segmentPointMap.set(sp.segmentPointId, sp);
      for (const nodeId of sp.capacityMeshNodeIds) {
        nodeToSegmentPointMap.set(nodeId, [
          ...nodeToSegmentPointMap.get(nodeId) ?? [],
          sp.segmentPointId
        ]);
      }
      segmentToSegmentPointMap.set(segment.nodePortSegmentId, [
        ...segmentToSegmentPointMap.get(segment.nodePortSegmentId) ?? [],
        sp.segmentPointId
      ]);
      segmentPoints.push(sp);
    }
  }
  return {
    segmentPointMap,
    nodeToSegmentPointMap,
    segmentToSegmentPointMap
  };
};

// lib/solvers/UnravelSolver/calculateCrossingProbabilityOfFailure.ts
var calculateNodeProbabilityOfFailure = (node, numSameLayerCrossings, numEntryExitLayerChanges, numTransitionCrossings) => {
  if (node?._containsTarget) return 0;
  const totalCapacity = getTunedTotalCapacity1(node);
  const estNumVias = numSameLayerCrossings * 0.82 + numEntryExitLayerChanges * 0.41 + numTransitionCrossings * 0.2;
  const estUsedCapacity = (estNumVias / 2) ** 1.1;
  const approxProb = estUsedCapacity / totalCapacity;
  return approxProb;
};

// lib/solvers/UnravelSolver/UnravelSectionSolver.ts
var UnravelSectionSolver = class extends BaseSolver {
  nodeMap;
  dedupedSegments;
  dedupedSegmentMap;
  MUTABLE_HOPS = 1;
  unravelSection;
  candidates = [];
  lastProcessedCandidate = null;
  bestCandidate = null;
  originalCandidate;
  rootNodeId;
  nodeIdToSegmentIds;
  segmentIdToNodeIds;
  colorMap;
  tunedNodeCapacityMap;
  MAX_CANDIDATES = 500;
  iterationsSinceImprovement = 0;
  hyperParameters;
  selectedCandidateIndex = null;
  queuedOrExploredCandidatePointModificationHashes = /* @__PURE__ */ new Set();
  constructorParams;
  constructor(params) {
    super();
    this.constructorParams = params;
    this.MUTABLE_HOPS = params.MUTABLE_HOPS ?? this.MUTABLE_HOPS;
    this.MAX_ITERATIONS = 5e4;
    this.hyperParameters = {
      ...params.hyperParameters,
      MAX_ITERATIONS_WITHOUT_IMPROVEMENT: 200
    };
    this.nodeMap = params.nodeMap;
    this.dedupedSegments = params.dedupedSegments;
    if (params.dedupedSegmentMap) {
      this.dedupedSegmentMap = params.dedupedSegmentMap;
    } else {
      this.dedupedSegmentMap = /* @__PURE__ */ new Map();
      for (const segment of this.dedupedSegments) {
        this.dedupedSegmentMap.set(segment.nodePortSegmentId, segment);
      }
    }
    this.nodeIdToSegmentIds = params.nodeIdToSegmentIds;
    this.segmentIdToNodeIds = params.segmentIdToNodeIds;
    this.rootNodeId = params.rootNodeId;
    this.colorMap = params.colorMap ?? {};
    this.unravelSection = this.createUnravelSection({
      segmentPointMap: params.segmentPointMap,
      nodeToSegmentPointMap: params.nodeToSegmentPointMap,
      segmentToSegmentPointMap: params.segmentToSegmentPointMap
    });
    this.tunedNodeCapacityMap = /* @__PURE__ */ new Map();
    for (const nodeId of this.unravelSection.allNodeIds) {
      this.tunedNodeCapacityMap.set(
        nodeId,
        getTunedTotalCapacity1(this.nodeMap.get(nodeId))
      );
    }
    this.originalCandidate = this.createInitialCandidate();
    this.candidates = [this.originalCandidate];
  }
  getConstructorParams() {
    return {
      ...this.constructorParams,
      // use the section maps instead of the global maps
      segmentPointMap: this.unravelSection.segmentPointMap,
      nodeToSegmentPointMap: this.unravelSection.segmentPointsInNode,
      segmentToSegmentPointMap: this.unravelSection.segmentPointsInSegment
    };
  }
  createUnravelSection(largeSpMaps) {
    const mutableNodeIds = getNodesNearNode({
      nodeId: this.rootNodeId,
      nodeIdToSegmentIds: this.nodeIdToSegmentIds,
      segmentIdToNodeIds: this.segmentIdToNodeIds,
      hops: this.MUTABLE_HOPS
    });
    const allSectionNodeIds = getNodesNearNode({
      nodeId: this.rootNodeId,
      nodeIdToSegmentIds: this.nodeIdToSegmentIds,
      segmentIdToNodeIds: this.segmentIdToNodeIds,
      hops: this.MUTABLE_HOPS + 1
    });
    const immutableNodeIds = Array.from(
      new Set(allSectionNodeIds).difference(new Set(mutableNodeIds))
    );
    if (!largeSpMaps?.segmentPointMap) {
      largeSpMaps = createSegmentPointMap(
        this.dedupedSegments,
        this.segmentIdToNodeIds
      );
    }
    const segmentPointsInNode = /* @__PURE__ */ new Map();
    for (const nodeId of allSectionNodeIds) {
      segmentPointsInNode.set(
        nodeId,
        largeSpMaps.nodeToSegmentPointMap.get(nodeId)
      );
    }
    const sectionPointMap = /* @__PURE__ */ new Map();
    for (const nodeId of allSectionNodeIds) {
      for (const segmentPointId of segmentPointsInNode.get(nodeId)) {
        const point = largeSpMaps.segmentPointMap.get(segmentPointId);
        sectionPointMap.set(segmentPointId, point);
      }
    }
    const segmentPoints = Array.from(sectionPointMap.values());
    const segmentPointsInSegment = /* @__PURE__ */ new Map();
    for (const segmentPoint of segmentPoints) {
      segmentPointsInSegment.set(segmentPoint.segmentId, [
        ...segmentPointsInSegment.get(segmentPoint.segmentId) ?? [],
        segmentPoint.segmentPointId
      ]);
    }
    for (const [nodeId, segmentPoints2] of segmentPointsInNode.entries()) {
      for (let i = 0; i < segmentPoints2.length; i++) {
        const A = largeSpMaps.segmentPointMap.get(segmentPoints2[i]);
        for (let j = i + 1; j < segmentPoints2.length; j++) {
          const B = largeSpMaps.segmentPointMap.get(segmentPoints2[j]);
          if (B.segmentPointId === A.segmentPointId) continue;
          if (B.segmentId === A.segmentId) continue;
          if (B.connectionName !== A.connectionName) continue;
          if (B.directlyConnectedSegmentPointIds.includes(A.segmentPointId))
            continue;
          A.directlyConnectedSegmentPointIds.push(B.segmentPointId);
          B.directlyConnectedSegmentPointIds.push(A.segmentPointId);
        }
      }
    }
    const segmentPairsInNode = /* @__PURE__ */ new Map();
    for (const nodeId of allSectionNodeIds) {
      segmentPairsInNode.set(nodeId, []);
    }
    for (const A of segmentPoints) {
      for (const nodeId of A.capacityMeshNodeIds) {
        const segmentPairs = segmentPairsInNode.get(nodeId);
        if (!segmentPairs) continue;
        for (const BId of A.directlyConnectedSegmentPointIds) {
          const B = largeSpMaps.segmentPointMap.get(BId);
          if (B.segmentPointId === A.segmentPointId) continue;
          if (!B.capacityMeshNodeIds.some((nId) => nId === nodeId)) continue;
          if (!segmentPairs.some(
            ([a, b]) => a === A.segmentPointId && b === B.segmentPointId || a === B.segmentPointId && b === A.segmentPointId
          )) {
            segmentPairs.push([A.segmentPointId, B.segmentPointId]);
          }
        }
      }
    }
    const mutableSegmentIds = /* @__PURE__ */ new Set();
    for (const nodeId of mutableNodeIds) {
      for (const segmentId of this.nodeIdToSegmentIds.get(nodeId)) {
        const allNodeIdsWithSegment = this.segmentIdToNodeIds.get(segmentId);
        if (allNodeIdsWithSegment.every(
          (nodeId2) => !this.nodeMap.get(nodeId2)._containsTarget
        )) {
          mutableSegmentIds.add(segmentId);
        }
      }
    }
    const mutableSegmentPointIds = /* @__PURE__ */ new Set();
    for (const sp of segmentPoints) {
      if (sp.capacityMeshNodeIds.some((id) => mutableNodeIds.includes(id))) {
        mutableSegmentPointIds.add(sp.segmentPointId);
      }
    }
    return {
      allNodeIds: allSectionNodeIds,
      mutableNodeIds,
      immutableNodeIds,
      mutableSegmentIds,
      segmentPairsInNode,
      segmentPointMap: sectionPointMap,
      segmentPointsInNode,
      segmentPointsInSegment,
      originalPointMap: sectionPointMap,
      mutableSegmentPointIds
    };
  }
  createInitialCandidate() {
    const pointModifications = /* @__PURE__ */ new Map();
    const issues = getIssuesInSection(
      this.unravelSection,
      this.nodeMap,
      pointModifications
    );
    const g = this.computeG({
      issues,
      originalCandidate: {},
      operationsPerformed: 0,
      operation: {}
    });
    return {
      pointModifications,
      g,
      h: 0,
      f: g,
      operationsPerformed: 0,
      candidateHash: createPointModificationsHash(pointModifications),
      // candidateFullHash: createFullPointModificationsHash(
      //   this.unravelSection.segmentPointMap,
      //   pointModifications,
      // ),
      // Ensure original candidate has issues calculated
      issues: getIssuesInSection(
        this.unravelSection,
        this.nodeMap,
        pointModifications
      )
    };
  }
  get nextCandidate() {
    return this.candidates[0] ?? null;
  }
  getPointInCandidate(candidate, segmentPointId) {
    const originalPoint = this.unravelSection.segmentPointMap.get(segmentPointId);
    const modifications = candidate.pointModifications.get(segmentPointId);
    return {
      x: modifications?.x ?? originalPoint.x,
      y: modifications?.y ?? originalPoint.y,
      z: modifications?.z ?? originalPoint.z,
      segmentId: originalPoint.segmentId
    };
  }
  getOperationsForIssue(candidate, issue) {
    const operations = [];
    if (issue.type === "transition_via") {
      const [APointId, BPointId] = issue.segmentPoints;
      const pointA = this.getPointInCandidate(candidate, APointId);
      const pointB = this.getPointInCandidate(candidate, BPointId);
      const aAvailableZ = this.dedupedSegmentMap.get(
        pointA.segmentId
      ).availableZ;
      const bAvailableZ = this.dedupedSegmentMap.get(
        pointB.segmentId
      ).availableZ;
      if (this.unravelSection.mutableSegmentPointIds.has(APointId) && aAvailableZ.includes(pointB.z)) {
        operations.push({
          type: "change_layer",
          newZ: pointB.z,
          segmentPointIds: [APointId]
        });
      }
      if (this.unravelSection.mutableSegmentPointIds.has(BPointId) && bAvailableZ.includes(pointA.z)) {
        operations.push({
          type: "change_layer",
          newZ: pointA.z,
          segmentPointIds: [BPointId]
        });
      }
    }
    if (issue.type === "same_layer_crossing") {
      const [APointId, BPointId] = issue.crossingLine1;
      const [CPointId, DPointId] = issue.crossingLine2;
      const sharedSegments = [];
      const A = this.unravelSection.segmentPointMap.get(APointId);
      const B = this.unravelSection.segmentPointMap.get(BPointId);
      const C = this.unravelSection.segmentPointMap.get(CPointId);
      const D = this.unravelSection.segmentPointMap.get(DPointId);
      const AIsMutable = this.unravelSection.mutableSegmentPointIds.has(APointId);
      const BIsMutable = this.unravelSection.mutableSegmentPointIds.has(BPointId);
      const CIsMutable = this.unravelSection.mutableSegmentPointIds.has(CPointId);
      const DIsMutable = this.unravelSection.mutableSegmentPointIds.has(DPointId);
      if (AIsMutable && CIsMutable && A.segmentId === C.segmentId) {
        sharedSegments.push([APointId, CPointId]);
      }
      if (AIsMutable && DIsMutable && A.segmentId === D.segmentId) {
        sharedSegments.push([APointId, DPointId]);
      }
      if (BIsMutable && CIsMutable && B.segmentId === C.segmentId) {
        sharedSegments.push([BPointId, CPointId]);
      }
      if (BIsMutable && DIsMutable && B.segmentId === D.segmentId) {
        sharedSegments.push([BPointId, DPointId]);
      }
      for (const [EPointId, FPointId] of sharedSegments) {
        operations.push({
          type: "swap_position_on_segment",
          segmentPointIds: [EPointId, FPointId]
        });
      }
      const aSegment = this.dedupedSegmentMap.get(A.segmentId);
      const bSegment = this.dedupedSegmentMap.get(B.segmentId);
      const cSegment = this.dedupedSegmentMap.get(C.segmentId);
      const dSegment = this.dedupedSegmentMap.get(D.segmentId);
      const isNewZAvailableForAll = (segmentObjects, newZ) => {
        return segmentObjects.every((seg) => seg.availableZ.includes(newZ));
      };
      if (AIsMutable && BIsMutable) {
        const newZ = A.z === 0 ? 1 : 0;
        if (isNewZAvailableForAll([aSegment, bSegment], newZ)) {
          operations.push({
            type: "change_layer",
            newZ,
            segmentPointIds: [APointId, BPointId]
          });
        }
      }
      if (CIsMutable && DIsMutable) {
        const newZ = C.z === 0 ? 1 : 0;
        if (isNewZAvailableForAll([cSegment, dSegment], newZ)) {
          operations.push({
            type: "change_layer",
            newZ,
            segmentPointIds: [CPointId, DPointId]
          });
        }
      }
      if (AIsMutable) {
        const newZ = A.z === 0 ? 1 : 0;
        if (aSegment.availableZ.includes(newZ)) {
          operations.push({
            type: "change_layer",
            newZ,
            segmentPointIds: [APointId]
          });
        }
      }
      if (BIsMutable) {
        const newZ = B.z === 0 ? 1 : 0;
        if (bSegment.availableZ.includes(newZ)) {
          operations.push({
            type: "change_layer",
            newZ,
            segmentPointIds: [BPointId]
          });
        }
      }
      if (CIsMutable) {
        const newZ = C.z === 0 ? 1 : 0;
        if (cSegment.availableZ.includes(newZ)) {
          operations.push({
            type: "change_layer",
            newZ,
            segmentPointIds: [CPointId]
          });
        }
      }
      if (DIsMutable) {
        const newZ = D.z === 0 ? 1 : 0;
        if (dSegment.availableZ.includes(newZ)) {
          operations.push({
            type: "change_layer",
            newZ,
            segmentPointIds: [DPointId]
          });
        }
      }
    }
    return operations;
  }
  computeG(params) {
    const { issues, originalCandidate, operationsPerformed, operation } = params;
    const nodeProblemCounts = /* @__PURE__ */ new Map();
    for (const issue of issues) {
      if (!nodeProblemCounts.has(issue.capacityMeshNodeId)) {
        nodeProblemCounts.set(issue.capacityMeshNodeId, {
          numTransitionCrossings: 0,
          numSameLayerCrossings: 0,
          numEntryExitLayerChanges: 0
        });
      }
      const nodeProblemCount = nodeProblemCounts.get(issue.capacityMeshNodeId);
      if (issue.type === "transition_via") {
        nodeProblemCount.numTransitionCrossings++;
      } else if (issue.type === "same_layer_crossing") {
        nodeProblemCount.numSameLayerCrossings++;
      } else if (issue.type === "double_transition_crossing" || issue.type === "single_transition_crossing") {
        nodeProblemCount.numEntryExitLayerChanges++;
      } else if (issue.type === "same_layer_trace_imbalance_with_low_capacity") {
      }
    }
    function log1mexp(x) {
      if (x < -Math.LN2) return Math.log(1 - Math.exp(x));
      else return Math.log(-Math.expm1(x));
    }
    let logSuccess = 0;
    for (const [
      nodeId,
      {
        numEntryExitLayerChanges,
        numSameLayerCrossings,
        numTransitionCrossings
      }
    ] of nodeProblemCounts) {
      const node = this.nodeMap.get(nodeId);
      const estPf = Math.min(
        calculateNodeProbabilityOfFailure(
          node,
          numSameLayerCrossings,
          numEntryExitLayerChanges,
          numTransitionCrossings
        ),
        0.999999
      );
      const log1mPf = Math.log(1 - estPf);
      logSuccess += log1mPf;
    }
    const logPf = log1mexp(logSuccess);
    return logPf;
  }
  getUnexploredNeighborByApplyingOperation(currentCandidate, operation) {
    const pointModifications = new Map(currentCandidate.pointModifications);
    applyOperationToPointModifications(
      pointModifications,
      operation,
      (segmentPointId) => this.getPointInCandidate(currentCandidate, segmentPointId)
    );
    const candidateHash = createPointModificationsHash(pointModifications);
    if (this.queuedOrExploredCandidatePointModificationHashes.has(candidateHash)) {
      return null;
    }
    const issues = getIssuesInSection(
      this.unravelSection,
      this.nodeMap,
      pointModifications
    );
    const operationsPerformed = currentCandidate.operationsPerformed + 1;
    const g = this.computeG({
      issues,
      originalCandidate: currentCandidate,
      operationsPerformed,
      operation
    });
    return {
      issues,
      g,
      h: 0,
      f: g,
      pointModifications,
      candidateHash,
      // TODO PERFORMANCE allow disabling this
      // candidateFullHash: createFullPointModificationsHash(
      //   this.unravelSection.segmentPointMap,
      //   pointModifications,
      // ),
      operationsPerformed
    };
  }
  getNeighborOperationsForCandidate(candidate) {
    return candidate.issues.flatMap(
      (issue) => this.getOperationsForIssue(candidate, issue)
    );
  }
  getNeighbors(candidate) {
    const neighbors = [];
    const operations = this.getNeighborOperationsForCandidate(candidate);
    for (const operation of operations) {
      const neighbor = this.getUnexploredNeighborByApplyingOperation(
        candidate,
        operation
      );
      if (!neighbor) continue;
      neighbors.push(neighbor);
    }
    return neighbors;
  }
  _step() {
    const candidate = this.candidates.shift();
    this.iterationsSinceImprovement++;
    if (this.iterationsSinceImprovement > this.hyperParameters.MAX_ITERATIONS_WITHOUT_IMPROVEMENT) {
      this.solved = true;
      return;
    }
    if (!candidate) {
      this.solved = true;
      return;
    }
    this.lastProcessedCandidate = candidate;
    if (candidate.f < (this.bestCandidate?.f ?? Infinity)) {
      this.bestCandidate = candidate;
      this.iterationsSinceImprovement = 0;
    }
    this.getNeighbors(candidate).forEach((neighbor) => {
      const isPartialHashExplored = this.queuedOrExploredCandidatePointModificationHashes.has(
        neighbor.candidateHash
      );
      if (isPartialHashExplored) return;
      this.queuedOrExploredCandidatePointModificationHashes.add(
        neighbor.candidateHash
      );
      this.candidates.push(neighbor);
    });
    this.candidates.sort((a, b) => a.f - b.f);
    this.candidates.length = Math.min(
      this.candidates.length,
      this.MAX_CANDIDATES
    );
  }
  visualize() {
    const graphics = {
      points: [],
      lines: [],
      rects: [],
      circles: [],
      coordinateSystem: "cartesian",
      title: "Unravel Section Solver"
    };
    let candidate = null;
    if (this.selectedCandidateIndex !== null) {
      if (this.selectedCandidateIndex === "best") {
        candidate = this.bestCandidate;
      } else if (this.selectedCandidateIndex === "original") {
        candidate = this.originalCandidate;
      } else {
        candidate = this.candidates[this.selectedCandidateIndex];
      }
    } else if (this.solved) {
      candidate = this.bestCandidate;
    } else {
      candidate = this.lastProcessedCandidate || this.candidates[0];
    }
    if (!candidate) return graphics;
    const modifiedSegmentPoints = /* @__PURE__ */ new Map();
    for (const [segmentPointId, segmentPoint] of this.unravelSection.segmentPointMap) {
      const modifiedPoint = { ...segmentPoint };
      const modification = candidate.pointModifications.get(segmentPointId);
      if (modification) {
        if (modification.x !== void 0) modifiedPoint.x = modification.x;
        if (modification.y !== void 0) modifiedPoint.y = modification.y;
        if (modification.z !== void 0) modifiedPoint.z = modification.z;
      }
      modifiedSegmentPoints.set(segmentPointId, modifiedPoint);
    }
    for (const [segmentPointId, segmentPoint] of modifiedSegmentPoints) {
      graphics.points.push({
        x: segmentPoint.x,
        y: segmentPoint.y,
        label: `${segmentPointId}
Segment: ${segmentPoint.segmentId} ${this.unravelSection.mutableSegmentIds.has(segmentPoint.segmentId) ? "MUTABLE" : "IMMUTABLE"}
Layer: ${segmentPoint.z}`,
        color: this.colorMap[segmentPoint.connectionName] || "#000"
      });
    }
    const nodeStatsMap = /* @__PURE__ */ new Map();
    for (const nodeId of this.unravelSection.allNodeIds) {
      nodeStatsMap.set(nodeId, {
        numTransitionCrossings: 0,
        numSameLayerCrossings: 0,
        numEntryExitLayerChanges: 0,
        estPf: 0
      });
    }
    for (const issue of candidate.issues) {
      const stats = nodeStatsMap.get(issue.capacityMeshNodeId);
      if (issue.type === "transition_via") {
        stats.numTransitionCrossings++;
      } else if (issue.type === "same_layer_crossing") {
        stats.numSameLayerCrossings++;
      } else if (issue.type === "double_transition_crossing" || issue.type === "single_transition_crossing") {
        stats.numEntryExitLayerChanges++;
      }
    }
    for (const [nodeId, stats] of nodeStatsMap.entries()) {
      const node = this.nodeMap.get(nodeId);
      stats.estPf = calculateNodeProbabilityOfFailure(
        node,
        stats.numSameLayerCrossings,
        stats.numEntryExitLayerChanges,
        stats.numTransitionCrossings
      );
    }
    for (const nodeId of this.unravelSection.allNodeIds) {
      const node = this.nodeMap.get(nodeId);
      const isMutable = this.unravelSection.mutableNodeIds.includes(nodeId);
      const stats = nodeStatsMap.get(nodeId);
      const label = [
        `${nodeId} (${isMutable ? "MUT" : "IMM"})`,
        `${node.width.toFixed(2)}x${node.height.toFixed(2)}`,
        `Pf: ${stats.estPf.toFixed(3)}`,
        `TC: ${stats.numTransitionCrossings}`,
        // Transition Crossings (Vias)
        `SLC: ${stats.numSameLayerCrossings}`,
        // Same Layer Crossings
        `EELC: ${stats.numEntryExitLayerChanges}`
        // Entry/Exit Layer Changes
      ].join("\n");
      graphics.rects.push({
        center: node.center,
        label,
        color: isMutable ? "green" : "red",
        width: node.width / 8,
        height: node.height / 8
      });
    }
    for (const [segmentId, segmentPointIds] of this.unravelSection.segmentPointsInSegment) {
      if (segmentPointIds.length <= 1) continue;
      const points = segmentPointIds.map(
        (spId) => modifiedSegmentPoints.get(spId)
      );
      for (let i = 0; i < points.length - 1; i++) {
        graphics.lines.push({
          points: [
            { x: points[i].x, y: points[i].y },
            { x: points[i + 1].x, y: points[i + 1].y }
          ],
          strokeColor: this.colorMap[segmentId] || "#000"
        });
      }
    }
    for (const [segmentPointId, segmentPoint] of modifiedSegmentPoints) {
      for (const connectedPointId of segmentPoint.directlyConnectedSegmentPointIds) {
        if (segmentPointId < connectedPointId) {
          const connectedPoint = modifiedSegmentPoints.get(connectedPointId);
          if (!connectedPoint) continue;
          const sameLayer = segmentPoint.z === connectedPoint.z;
          const commonLayer = segmentPoint.z;
          let strokeDash;
          if (sameLayer) {
            strokeDash = commonLayer === 0 ? void 0 : "10 5";
          } else {
            strokeDash = "3 3 10";
          }
          graphics.lines.push({
            points: [
              { x: segmentPoint.x, y: segmentPoint.y },
              { x: connectedPoint.x, y: connectedPoint.y }
            ],
            strokeDash,
            strokeColor: this.colorMap[segmentPoint.connectionName] || "#000"
          });
        }
      }
    }
    for (const issue of candidate.issues) {
      const node = this.nodeMap.get(issue.capacityMeshNodeId);
      if (issue.type === "transition_via") {
        for (const segmentPointId of issue.segmentPoints) {
          const segmentPoint = modifiedSegmentPoints.get(segmentPointId);
          graphics.circles.push({
            center: { x: segmentPoint.x, y: segmentPoint.y },
            radius: node.width / 16,
            stroke: "#ff0000",
            fill: "rgba(255, 0, 0, 0.2)",
            label: `Via Issue
${segmentPointId}
Layer: ${segmentPoint.z}`
          });
        }
      } else if (issue.type === "same_layer_crossing") {
        for (const [sp1Id, sp2Id] of [
          issue.crossingLine1,
          issue.crossingLine2
        ]) {
          const sp1 = modifiedSegmentPoints.get(sp1Id);
          const sp2 = modifiedSegmentPoints.get(sp2Id);
          graphics.lines.push({
            points: [
              { x: sp1.x, y: sp1.y },
              { x: sp2.x, y: sp2.y }
            ],
            strokeColor: "rgba(255,0,0,0.2)",
            strokeWidth: node.width / 32
          });
        }
      }
    }
    for (const [segmentPointId, modification] of candidate.pointModifications) {
      const modifiedPoint = modifiedSegmentPoints.get(segmentPointId);
      const originalPoint = this.unravelSection.segmentPointMap.get(segmentPointId);
      graphics.circles.push({
        center: { x: modifiedPoint.x, y: modifiedPoint.y },
        radius: 0.05,
        stroke: "#0000ff",
        fill: "rgba(0, 0, 255, 0.2)",
        label: `${segmentPointId}
Original: (${originalPoint.x.toFixed(2)}, ${originalPoint.y.toFixed(2)}, ${originalPoint.z})
New: (${modifiedPoint.x.toFixed(2)}, ${modifiedPoint.y.toFixed(2)}, ${modifiedPoint.z})`
      });
    }
    return graphics;
  }
};

// lib/solvers/UnravelSolver/CachedUnravelSectionSolver.ts
import objectHash from "object-hash";

// lib/cache/InMemoryCache.ts
var InMemoryCache = class {
  cacheHitsByPrefix = {};
  cacheMissesByPrefix = {};
  isSyncCache = true;
  cacheHits = 0;
  cacheMisses = 0;
  cache = /* @__PURE__ */ new Map();
  /**
   * Retrieves a cached solution synchronously based on the cache key.
   * Increments cache hit/miss counters.
   * @param cacheKey The key to look up in the cache.
   * @returns The cached solution if found, otherwise undefined.
   */
  getCachedSolutionSync(cacheKey) {
    const cachedSolution = this.cache.get(cacheKey);
    if (cachedSolution !== void 0) {
      this.cacheHits++;
      return structuredClone(cachedSolution);
    } else {
      this.cacheMisses++;
      return void 0;
    }
  }
  /**
   * Retrieves a cached solution asynchronously. Wraps the synchronous method.
   * @param cacheKey The key to look up in the cache.
   * @returns A promise that resolves with the cached solution or undefined.
   */
  async getCachedSolution(cacheKey) {
    return this.getCachedSolutionSync(cacheKey);
  }
  /**
   * Stores a solution in the cache synchronously.
   * Uses structured cloning to store a copy, preventing external modifications.
   * @param cacheKey The key under which to store the solution.
   * @param cachedSolution The solution data to cache.
   */
  setCachedSolutionSync(cacheKey, cachedSolution) {
    this.cache.set(cacheKey, structuredClone(cachedSolution));
  }
  /**
   * Stores a solution in the cache asynchronously. Wraps the synchronous method.
   * @param cacheKey The key under which to store the solution.
   * @param cachedSolution The solution data to cache.
   * @returns A promise that resolves when the solution is cached.
   */
  async setCachedSolution(cacheKey, cachedSolution) {
    this.setCachedSolutionSync(cacheKey, cachedSolution);
  }
  /**
   * Clears the entire cache and resets hit/miss counters.
   */
  clearCache() {
    this.cache.clear();
    this.cacheHits = 0;
    this.cacheMisses = 0;
  }
  getAllCacheKeys() {
    return Array.from(this.cache.keys());
  }
};

// lib/cache/LocalStorageCache.ts
var CACHE_PREFIX = "tscircuit_autorouter_cache_";
var LocalStorageCache = class {
  isSyncCache = true;
  cacheHits = 0;
  cacheMisses = 0;
  cacheHitsByPrefix = {};
  cacheMissesByPrefix = {};
  constructor() {
  }
  getKey(cacheKey) {
    return `${CACHE_PREFIX}${cacheKey}`;
  }
  /**
   * Retrieves a cached solution synchronously from localStorage.
   * Increments cache hit/miss counters.
   * @param cacheKey The key to look up in the cache.
   * @returns The cached solution if found and parsed correctly, otherwise undefined.
   */
  getCachedSolutionSync(cacheKey) {
    if (typeof localStorage === "undefined") return void 0;
    const key = this.getKey(cacheKey);
    try {
      const cachedItem = localStorage.getItem(key);
      if (cachedItem !== null) {
        const solution = JSON.parse(cachedItem);
        this.cacheHits++;
        const prefix = cacheKey.split(":")[0];
        this.cacheHitsByPrefix[prefix] = (this.cacheHitsByPrefix[prefix] || 0) + 1;
        return solution;
      } else {
        this.cacheMisses++;
        const prefix = cacheKey.split(":")[0];
        this.cacheMissesByPrefix[prefix] = (this.cacheMissesByPrefix[prefix] || 0) + 1;
        return void 0;
      }
    } catch (error) {
      console.error(`Error getting cached solution sync for ${key}:`, error);
      this.cacheMisses++;
      const prefix = cacheKey.split(":")[0];
      this.cacheMissesByPrefix[prefix] = (this.cacheMissesByPrefix[prefix] || 0) + 1;
      return void 0;
    }
  }
  /**
   * Retrieves a cached solution asynchronously. Wraps the synchronous method.
   * @param cacheKey The key to look up in the cache.
   * @returns A promise that resolves with the cached solution or undefined.
   */
  async getCachedSolution(cacheKey) {
    return this.getCachedSolutionSync(cacheKey);
  }
  /**
   * Stores a solution in localStorage synchronously.
   * The solution is JSON stringified before storing.
   * @param cacheKey The key under which to store the solution.
   * @param cachedSolution The solution data to cache.
   */
  setCachedSolutionSync(cacheKey, cachedSolution) {
    if (typeof localStorage === "undefined") return;
    const key = this.getKey(cacheKey);
    try {
      const stringifiedSolution = JSON.stringify(cachedSolution);
      localStorage.setItem(key, stringifiedSolution);
    } catch (error) {
      console.error(`Error setting cached solution sync for ${key}:`, error);
      if (error instanceof DOMException && (error.name === "QuotaExceededError" || error.name === "NS_ERROR_DOM_QUOTA_REACHED")) {
        console.warn(
          `LocalStorage quota exceeded. Failed to cache solution for ${key}. Consider clearing the cache.`
        );
      }
    }
  }
  /**
   * Stores a solution in the cache asynchronously. Wraps the synchronous method.
   * @param cacheKey The key under which to store the solution.
   * @param cachedSolution The solution data to cache.
   * @returns A promise that resolves when the solution is cached.
   */
  async setCachedSolution(cacheKey, cachedSolution) {
    this.setCachedSolutionSync(cacheKey, cachedSolution);
  }
  /**
   * Clears all cache entries created by this instance from localStorage
   * and resets hit/miss counters.
   */
  clearCache() {
    if (typeof localStorage === "undefined") return;
    try {
      const keysToRemove = [];
      for (let i = 0; i < localStorage.length; i++) {
        const key = localStorage.key(i);
        if (key?.startsWith(CACHE_PREFIX)) {
          keysToRemove.push(key);
        }
      }
      keysToRemove.forEach((key) => localStorage.removeItem(key));
      console.log(
        `Cleared ${keysToRemove.length} items from LocalStorage cache.`
      );
    } catch (error) {
      console.error("Error clearing LocalStorage cache:", error);
    } finally {
      this.cacheHits = 0;
      this.cacheMisses = 0;
      this.cacheHitsByPrefix = {};
      this.cacheMissesByPrefix = {};
    }
  }
  getAllCacheKeys() {
    const cacheKeys = [];
    for (let i = 0; i < 1e4; i++) {
      const keyName = localStorage.key(i);
      if (!keyName) break;
      if (!keyName.includes(CACHE_PREFIX)) continue;
      cacheKeys.push(keyName);
    }
    return cacheKeys;
  }
};

// lib/cache/setupGlobalCaches.ts
function getGlobalLocalStorageCache() {
  if (!globalThis.TSCIRCUIT_AUTOROUTER_LOCAL_STORAGE_CACHE) {
    setupGlobalCaches();
  }
  return globalThis.TSCIRCUIT_AUTOROUTER_LOCAL_STORAGE_CACHE;
}
function getGlobalInMemoryCache() {
  if (!globalThis.TSCIRCUIT_AUTOROUTER_IN_MEMORY_CACHE) {
    setupGlobalCaches();
  }
  return globalThis.TSCIRCUIT_AUTOROUTER_IN_MEMORY_CACHE;
}
function setupGlobalCaches() {
  globalThis.TSCIRCUIT_AUTOROUTER_LOCAL_STORAGE_CACHE ??= new LocalStorageCache();
  globalThis.TSCIRCUIT_AUTOROUTER_IN_MEMORY_CACHE ??= new InMemoryCache();
}

// node_modules/transformation-matrix/src/applyToPoint.js
function applyToPoint(matrix, point) {
  return Array.isArray(point) ? [
    matrix.a * point[0] + matrix.c * point[1] + matrix.e,
    matrix.b * point[0] + matrix.d * point[1] + matrix.f
  ] : {
    x: matrix.a * point.x + matrix.c * point.y + matrix.e,
    y: matrix.b * point.x + matrix.d * point.y + matrix.f
  };
}

// node_modules/transformation-matrix/src/translate.js
function translate(tx, ty = 0) {
  return {
    a: 1,
    c: 0,
    e: tx,
    b: 0,
    d: 1,
    f: ty
  };
}

// node_modules/transformation-matrix/src/rotate.js
var { cos, sin, PI } = Math;

// node_modules/transformation-matrix/src/skew.js
var { tan } = Math;

// node_modules/transformation-matrix/src/fromTransformAttribute.autogenerated.js
function peg$subclass(child, parent) {
  function C() {
    this.constructor = child;
  }
  C.prototype = parent.prototype;
  child.prototype = new C();
}
function peg$SyntaxError(message, expected, found, location) {
  var self = Error.call(this, message);
  if (Object.setPrototypeOf) {
    Object.setPrototypeOf(self, peg$SyntaxError.prototype);
  }
  self.expected = expected;
  self.found = found;
  self.location = location;
  self.name = "SyntaxError";
  return self;
}
peg$subclass(peg$SyntaxError, Error);
function peg$padEnd(str, targetLength, padString) {
  padString = padString || " ";
  if (str.length > targetLength) {
    return str;
  }
  targetLength -= str.length;
  padString += padString.repeat(targetLength);
  return str + padString.slice(0, targetLength);
}
peg$SyntaxError.prototype.format = function(sources) {
  var str = "Error: " + this.message;
  if (this.location) {
    var src = null;
    var k;
    for (k = 0; k < sources.length; k++) {
      if (sources[k].source === this.location.source) {
        src = sources[k].text.split(/\r\n|\n|\r/g);
        break;
      }
    }
    var s = this.location.start;
    var offset_s = this.location.source && typeof this.location.source.offset === "function" ? this.location.source.offset(s) : s;
    var loc = this.location.source + ":" + offset_s.line + ":" + offset_s.column;
    if (src) {
      var e = this.location.end;
      var filler = peg$padEnd("", offset_s.line.toString().length, " ");
      var line = src[s.line - 1];
      var last = s.line === e.line ? e.column : line.length + 1;
      var hatLen = last - s.column || 1;
      str += "\n --> " + loc + "\n" + filler + " |\n" + offset_s.line + " | " + line + "\n" + filler + " | " + peg$padEnd("", s.column - 1, " ") + peg$padEnd("", hatLen, "^");
    } else {
      str += "\n at " + loc;
    }
  }
  return str;
};
peg$SyntaxError.buildMessage = function(expected, found) {
  var DESCRIBE_EXPECTATION_FNS = {
    literal: function(expectation) {
      return '"' + literalEscape(expectation.text) + '"';
    },
    class: function(expectation) {
      var escapedParts = expectation.parts.map(function(part) {
        return Array.isArray(part) ? classEscape(part[0]) + "-" + classEscape(part[1]) : classEscape(part);
      });
      return "[" + (expectation.inverted ? "^" : "") + escapedParts.join("") + "]";
    },
    any: function() {
      return "any character";
    },
    end: function() {
      return "end of input";
    },
    other: function(expectation) {
      return expectation.description;
    }
  };
  function hex(ch) {
    return ch.charCodeAt(0).toString(16).toUpperCase();
  }
  function literalEscape(s) {
    return s.replace(/\\/g, "\\\\").replace(/"/g, '\\"').replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
      return "\\x0" + hex(ch);
    }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
      return "\\x" + hex(ch);
    });
  }
  function classEscape(s) {
    return s.replace(/\\/g, "\\\\").replace(/\]/g, "\\]").replace(/\^/g, "\\^").replace(/-/g, "\\-").replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
      return "\\x0" + hex(ch);
    }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
      return "\\x" + hex(ch);
    });
  }
  function describeExpectation(expectation) {
    return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
  }
  function describeExpected(expected2) {
    var descriptions = expected2.map(describeExpectation);
    var i, j;
    descriptions.sort();
    if (descriptions.length > 0) {
      for (i = 1, j = 1; i < descriptions.length; i++) {
        if (descriptions[i - 1] !== descriptions[i]) {
          descriptions[j] = descriptions[i];
          j++;
        }
      }
      descriptions.length = j;
    }
    switch (descriptions.length) {
      case 1:
        return descriptions[0];
      case 2:
        return descriptions[0] + " or " + descriptions[1];
      default:
        return descriptions.slice(0, -1).join(", ") + ", or " + descriptions[descriptions.length - 1];
    }
  }
  function describeFound(found2) {
    return found2 ? '"' + literalEscape(found2) + '"' : "end of input";
  }
  return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
};

// lib/solvers/UnravelSolver/CachedUnravelSectionSolver.ts
var approximateCoordinate = (coord) => {
  return (Math.round(coord * 20) / 20).toFixed(2);
};
var approximateDeltaCoordinate = (coord) => {
  return (Math.round(coord * 1e3) / 1e3).toFixed(3);
};
setupGlobalCaches();
var CachedUnravelSectionSolver = class extends UnravelSectionSolver {
  cacheHit = false;
  cacheProvider;
  hasAttemptedToUseCache = false;
  constructor(params) {
    super(params);
    this.cacheProvider = params.cacheProvider === void 0 ? getGlobalLocalStorageCache() : params.cacheProvider;
  }
  _step() {
    if (!this.hasAttemptedToUseCache && this.cacheProvider) {
      if (this.attemptToUseCacheSync()) return;
    }
    super._step();
    if ((this.solved || this.failed) && this.cacheProvider) {
      this.saveToCacheSync();
    }
  }
  computeCacheKeyAndTransform() {
    const rootNode = this.nodeMap.get(this.rootNodeId);
    const realToCacheTransform = translate(
      -rootNode.center.x,
      -rootNode.center.y
    );
    const nodeIdMap = /* @__PURE__ */ new Map();
    const reverseNodeIdMap = /* @__PURE__ */ new Map();
    const segmentIdMap = /* @__PURE__ */ new Map();
    const reverseSegmentIdMap = /* @__PURE__ */ new Map();
    const segmentPointIdMap = /* @__PURE__ */ new Map();
    const reverseSegmentPointIdMap = /* @__PURE__ */ new Map();
    let nodeCounter = 0;
    let segmentCounter = 0;
    let spCounter = 0;
    const sortedNodeIds = [...this.unravelSection.allNodeIds].sort(
      (aNId, bNId) => {
        const n1 = this.nodeMap.get(aNId);
        const n2 = this.nodeMap.get(bNId);
        if (n1.center.x !== n2.center.x) {
          return n1.center.x - n2.center.x;
        }
        return n1.center.y - n2.center.y;
      }
    );
    for (const nodeId of sortedNodeIds) {
      const normId = `node_${nodeCounter++}`;
      nodeIdMap.set(nodeId, normId);
      reverseNodeIdMap.set(normId, nodeId);
    }
    const sortedSegmentPointIds = [
      ...Array.from(this.unravelSection.segmentPointMap.entries()).sort(([, a], [, b]) => {
        if (a.x !== b.x) {
          return a.x - b.x;
        }
        return a.y - b.y;
      }).map(([id]) => id)
    ].sort();
    for (const spId of sortedSegmentPointIds) {
      const normSpId = `sp_${spCounter++}`;
      segmentPointIdMap.set(spId, normSpId);
      reverseSegmentPointIdMap.set(normSpId, spId);
      const segmentId = this.unravelSection.segmentPointMap.get(spId).segmentId;
      if (!segmentIdMap.has(segmentId)) {
        const normSegId = `seg_${segmentCounter++}`;
        segmentIdMap.set(segmentId, normSegId);
        reverseSegmentIdMap.set(normSegId, segmentId);
      }
    }
    const normalizedNodes = {};
    for (const [nodeId, normNodeId] of nodeIdMap.entries()) {
      const node = this.nodeMap.get(nodeId);
      const transformedCenter = applyToPoint(realToCacheTransform, node.center);
      normalizedNodes[normNodeId] = {
        // ...node,
        width: node.width,
        // TODO: Scale width/height if transform includes scaling
        height: node.height,
        availableZ: node.availableZ,
        center: {
          x: approximateCoordinate(transformedCenter.x),
          y: approximateCoordinate(transformedCenter.y)
        }
      };
    }
    const normalizedSegmentPoints = {};
    for (const [spId, normSpId] of segmentPointIdMap.entries()) {
      const sp = this.unravelSection.segmentPointMap.get(spId);
      const transformedPoint = applyToPoint(realToCacheTransform, {
        x: sp.x,
        y: sp.y
      });
      normalizedSegmentPoints[normSpId] = {
        x: approximateCoordinate(transformedPoint.x),
        y: approximateCoordinate(transformedPoint.y),
        z: sp.z
        // Z is not transformed by 2D matrix
        // segmentId: segmentIdMap.get(sp.segmentId)!,
        // connectionName: sp.connectionName,
      };
    }
    const keyData = {
      hyperParameters: this.hyperParameters,
      normalizedNodes,
      normalizedSegmentPoints,
      mutableHops: this.MUTABLE_HOPS
    };
    const cacheKey = `unravelsec:${objectHash(keyData)}`;
    const cacheToSolveSpaceTransform = {
      realToCacheTransform,
      nodeIdMap,
      segmentIdMap,
      segmentPointIdMap,
      reverseNodeIdMap,
      reverseSegmentIdMap,
      reverseSegmentPointIdMap
    };
    this.cacheKey = cacheKey;
    this.cacheToSolveSpaceTransform = cacheToSolveSpaceTransform;
    return { cacheKey, cacheToSolveSpaceTransform };
  }
  applyCachedSolution(cachedSolution) {
    if (cachedSolution.success === false) {
      this.failed = true;
      return;
    }
    if (!this.cacheToSolveSpaceTransform) {
      console.error("Cache transform not available to apply cached solution.");
      return;
    }
    const {
      // realToCacheTransform, // Not needed to apply deltas
      reverseSegmentPointIdMap,
      reverseNodeIdMap
      // Needed if issues depend on node IDs
    } = this.cacheToSolveSpaceTransform;
    const pointModifications = /* @__PURE__ */ new Map();
    for (const [
      normSpId,
      normDelta
      // normDelta.dx and normDelta.dy are strings here
    ] of cachedSolution.bestCandidatePointModificationsDelta) {
      const originalSpId = reverseSegmentPointIdMap.get(normSpId);
      if (!originalSpId) {
        console.warn(
          `Could not find original ID for normalized SP ID: ${normSpId} when applying cache.`
        );
        continue;
      }
      const originalSegmentPoint = this.unravelSection.segmentPointMap.get(originalSpId);
      if (!originalSegmentPoint) {
        console.warn(
          `Could not find original segment point for ID: ${originalSpId} when applying cache.`
        );
        continue;
      }
      const modifiedPoint = {};
      if (normDelta.dx !== void 0) {
        const dxNum = parseFloat(normDelta.dx);
        if (!Number.isNaN(dxNum)) {
          modifiedPoint.x = originalSegmentPoint.x + dxNum;
        } else {
          console.warn(`Failed to parse cached dx coordinate: ${normDelta.dx}`);
        }
      }
      if (normDelta.dy !== void 0) {
        const dyNum = parseFloat(normDelta.dy);
        if (!Number.isNaN(dyNum)) {
          modifiedPoint.y = originalSegmentPoint.y + dyNum;
        } else {
          console.warn(`Failed to parse cached dy coordinate: ${normDelta.dy}`);
        }
      }
      if (normDelta.dz !== void 0) {
        modifiedPoint.z = originalSegmentPoint.z + normDelta.dz;
      }
      if (Object.keys(modifiedPoint).length > 0) {
        pointModifications.set(originalSpId, modifiedPoint);
      }
    }
    const issues = getIssuesInSection(
      this.unravelSection,
      this.nodeMap,
      pointModifications
    );
    this.bestCandidate = {
      pointModifications,
      issues,
      f: cachedSolution.bestCandidateF,
      g: cachedSolution.bestCandidateF,
      // Assume g is the main component off for cached solution
      h: 0,
      // Heuristic is 0 when solution is loaded
      operationsPerformed: -1,
      // Indicate it's from cache, operation count unknown
      candidateHash: createPointModificationsHash(pointModifications)
    };
    this.cacheHit = true;
    this.solved = true;
  }
  attemptToUseCacheSync() {
    this.hasAttemptedToUseCache = true;
    if (!this.cacheProvider?.isSyncCache) {
      console.log(
        "Cache provider is not synchronous, skipping sync cache check."
      );
      return false;
    }
    if (!this.cacheKey) {
      this.computeCacheKeyAndTransform();
    }
    if (!this.cacheKey) {
      console.error("Failed to compute cache key.");
      return false;
    }
    try {
      const cachedSolution = this.cacheProvider.getCachedSolutionSync(
        this.cacheKey
      );
      if (cachedSolution) {
        this.applyCachedSolution(cachedSolution);
        return true;
      } else {
      }
    } catch (error) {
      console.error("Error attempting to use cache:", error);
    }
    return false;
  }
  saveToCacheSync() {
    if (this.failed) {
      this.cacheProvider?.setCachedSolutionSync(this.cacheKey, {
        success: false
      });
      return;
    }
    if (!this.bestCandidate) return;
    const {
      // realToCacheTransform, // Not needed to calculate deltas
      segmentPointIdMap
    } = this.cacheToSolveSpaceTransform;
    const normalizedDeltas = [];
    for (const [
      originalSpId,
      modifiedPoint
      // This contains the absolute modified coordinates {x?, y?, z?}
    ] of this.bestCandidate.pointModifications.entries()) {
      const normSpId = segmentPointIdMap.get(originalSpId);
      if (!normSpId) {
        console.warn(
          `Could not find normalized ID for original SP ID: ${originalSpId} when saving to cache.`
        );
        continue;
      }
      const originalSegmentPoint = this.unravelSection.segmentPointMap.get(originalSpId);
      if (!originalSegmentPoint) {
        console.warn(
          `Could not find original segment point for ID: ${originalSpId} when saving cache.`
        );
        continue;
      }
      const normDelta = {};
      let hasDelta = false;
      if (modifiedPoint.x !== void 0) {
        const dx = modifiedPoint.x - originalSegmentPoint.x;
        const approxDx = approximateDeltaCoordinate(dx);
        if (parseFloat(approxDx) !== 0) {
          normDelta.dx = approxDx;
          hasDelta = true;
        }
      }
      if (modifiedPoint.y !== void 0) {
        const dy = modifiedPoint.y - originalSegmentPoint.y;
        const approxDy = approximateDeltaCoordinate(dy);
        if (parseFloat(approxDy) !== 0) {
          normDelta.dy = approxDy;
          hasDelta = true;
        }
      }
      if (modifiedPoint.z !== void 0) {
        const dz = modifiedPoint.z - originalSegmentPoint.z;
        if (dz !== 0) {
          normDelta.dz = dz;
          hasDelta = true;
        }
      }
      if (hasDelta) {
        normalizedDeltas.push([normSpId, normDelta]);
      }
    }
    const cachedSolution = {
      success: true,
      bestCandidatePointModificationsDelta: normalizedDeltas,
      bestCandidateF: this.bestCandidate.f
    };
    this.cacheProvider?.setCachedSolutionSync(this.cacheKey, cachedSolution);
  }
};

// lib/solvers/UnravelSolver/getDedupedSegments.ts
var getDedupedSegments = (assignedSegments) => {
  const dedupedSegments = [];
  const dedupedSegPointMap = /* @__PURE__ */ new Map();
  let highestSegmentId = -1;
  for (const seg of assignedSegments) {
    const segKey = `${seg.start.x}-${seg.start.y}-${seg.end.x}-${seg.end.y}-${seg.availableZ.join(",")}`;
    const existingSeg = dedupedSegPointMap.get(segKey);
    if (!existingSeg) {
      highestSegmentId++;
      seg.nodePortSegmentId = `SEG${highestSegmentId}`;
      dedupedSegPointMap.set(segKey, seg);
      dedupedSegments.push(seg);
      continue;
    }
    seg.nodePortSegmentId = existingSeg.nodePortSegmentId;
  }
  return dedupedSegments;
};

// lib/utils/getIntraNodeCrossingsFromSegmentPoints.ts
var getIntraNodeCrossingsFromSegmentPoints = (segmentPoints) => {
  let numSameLayerCrossings = 0;
  let numEntryExitLayerChanges = 0;
  let numTransitionCrossings = 0;
  const connectionGroups = /* @__PURE__ */ new Map();
  for (const point of segmentPoints) {
    if (!connectionGroups.has(point.connectionName)) {
      connectionGroups.set(point.connectionName, []);
    }
    connectionGroups.get(point.connectionName).push(point);
  }
  const pointPairs = [];
  const transitionPairPoints = [];
  for (const [connectionName, points] of connectionGroups.entries()) {
    if (points.length < 2) continue;
    const firstPoint = points[0];
    for (let i = 1; i < points.length; i++) {
      const secondPoint = points[i];
      const pointPair = {
        connectionName,
        z: firstPoint.z,
        points: [firstPoint, secondPoint]
      };
      if (firstPoint.z !== secondPoint.z) {
        numEntryExitLayerChanges++;
        transitionPairPoints.push({
          connectionName,
          points: [firstPoint, secondPoint]
        });
      } else {
        pointPairs.push(pointPair);
      }
    }
  }
  for (let i = 0; i < pointPairs.length; i++) {
    for (let j = i + 1; j < pointPairs.length; j++) {
      const pair1 = pointPairs[i];
      const pair2 = pointPairs[j];
      if (pair1.z === pair2.z && doSegmentsIntersect(
        pair1.points[0],
        pair1.points[1],
        pair2.points[0],
        pair2.points[1]
      )) {
        numSameLayerCrossings++;
      }
    }
  }
  for (let i = 0; i < transitionPairPoints.length; i++) {
    for (let j = i + 1; j < transitionPairPoints.length; j++) {
      const pair1 = transitionPairPoints[i];
      const pair2 = transitionPairPoints[j];
      if (doSegmentsIntersect(
        pair1.points[0],
        pair1.points[1],
        pair2.points[0],
        pair2.points[1]
      )) {
        numTransitionCrossings++;
      }
    }
  }
  for (let i = 0; i < transitionPairPoints.length; i++) {
    for (let j = 0; j < pointPairs.length; j++) {
      const pair1 = transitionPairPoints[i];
      const pair2 = pointPairs[j];
      if (doSegmentsIntersect(
        pair1.points[0],
        pair1.points[1],
        pair2.points[0],
        pair2.points[1]
      )) {
        numTransitionCrossings++;
      }
    }
  }
  return {
    numSameLayerCrossings,
    numEntryExitLayerChanges,
    numTransitionCrossings
  };
};

// lib/solvers/UnravelSolver/UnravelMultiSectionSolver.ts
var UnravelMultiSectionSolver = class extends BaseSolver {
  nodeMap;
  dedupedSegmentMap;
  dedupedSegments;
  nodeIdToSegmentIds;
  segmentIdToNodeIds;
  nodeToSegmentPointMap;
  segmentToSegmentPointMap;
  colorMap;
  tunedNodeCapacityMap;
  MAX_NODE_ATTEMPTS = 2;
  MUTABLE_HOPS = 1;
  ACCEPTABLE_PF = 0.05;
  MAX_ITERATIONS_WITHOUT_IMPROVEMENT = 200;
  /**
   * Probability of failure for each node
   */
  nodePfMap;
  attemptsToFixNode;
  activeSubSolver = null;
  segmentPointMap;
  cacheProvider = null;
  constructor({
    assignedSegments,
    colorMap,
    nodes,
    cacheProvider
  }) {
    super();
    this.stats.successfulOptimizations = 0;
    this.stats.failedOptimizations = 0;
    this.stats.cacheHits = 0;
    this.stats.cacheMisses = 0;
    this.cacheProvider = cacheProvider ?? null;
    this.MAX_ITERATIONS = 1e6;
    this.dedupedSegments = getDedupedSegments(assignedSegments);
    this.dedupedSegmentMap = /* @__PURE__ */ new Map();
    for (const segment of this.dedupedSegments) {
      this.dedupedSegmentMap.set(segment.nodePortSegmentId, segment);
    }
    this.nodeMap = /* @__PURE__ */ new Map();
    for (const node of nodes) {
      this.nodeMap.set(node.capacityMeshNodeId, node);
    }
    this.nodeIdToSegmentIds = /* @__PURE__ */ new Map();
    this.segmentIdToNodeIds = /* @__PURE__ */ new Map();
    this.attemptsToFixNode = /* @__PURE__ */ new Map();
    for (const segment of assignedSegments) {
      this.segmentIdToNodeIds.set(segment.nodePortSegmentId, [
        ...this.segmentIdToNodeIds.get(segment.nodePortSegmentId) ?? [],
        segment.capacityMeshNodeId
      ]);
      this.nodeIdToSegmentIds.set(segment.capacityMeshNodeId, [
        ...this.nodeIdToSegmentIds.get(segment.capacityMeshNodeId) ?? [],
        segment.nodePortSegmentId
      ]);
    }
    this.colorMap = colorMap ?? {};
    this.tunedNodeCapacityMap = /* @__PURE__ */ new Map();
    for (const [nodeId, node] of this.nodeMap) {
      this.tunedNodeCapacityMap.set(nodeId, getTunedTotalCapacity1(node));
    }
    const { segmentPointMap, nodeToSegmentPointMap, segmentToSegmentPointMap } = createSegmentPointMap(this.dedupedSegments, this.segmentIdToNodeIds);
    this.segmentPointMap = segmentPointMap;
    this.nodeToSegmentPointMap = nodeToSegmentPointMap;
    this.segmentToSegmentPointMap = segmentToSegmentPointMap;
    this.nodePfMap = this.computeInitialPfMap();
  }
  computeInitialPfMap() {
    const pfMap = /* @__PURE__ */ new Map();
    for (const [nodeId, node] of this.nodeMap.entries()) {
      pfMap.set(nodeId, this.computeNodePf(node));
    }
    return pfMap;
  }
  computeNodePf(node) {
    const {
      numSameLayerCrossings,
      numEntryExitLayerChanges,
      numTransitionCrossings
    } = getIntraNodeCrossingsFromSegmentPoints(
      (this.nodeToSegmentPointMap.get(node.capacityMeshNodeId) ?? []).map(
        (segPointId) => this.segmentPointMap.get(segPointId)
      )
    );
    const probabilityOfFailure = calculateNodeProbabilityOfFailure(
      node,
      numSameLayerCrossings,
      numEntryExitLayerChanges,
      numTransitionCrossings
    );
    return probabilityOfFailure;
  }
  _step() {
    if (this.iterations >= this.MAX_ITERATIONS - 1) {
      this.solved = true;
      return;
    }
    if (!this.activeSubSolver) {
      let highestPfNodeId = null;
      let highestPf = 0;
      for (const [nodeId, pf] of this.nodePfMap.entries()) {
        const pfReduced = pf * (1 - (this.attemptsToFixNode.get(nodeId) ?? 0) / this.MAX_NODE_ATTEMPTS);
        if (pfReduced > highestPf) {
          highestPf = pf;
          highestPfNodeId = nodeId;
        }
      }
      if (!highestPfNodeId || highestPf < this.ACCEPTABLE_PF) {
        this.solved = true;
        return;
      }
      this.attemptsToFixNode.set(
        highestPfNodeId,
        (this.attemptsToFixNode.get(highestPfNodeId) ?? 0) + 1
      );
      this.activeSubSolver = new CachedUnravelSectionSolver({
        dedupedSegments: this.dedupedSegments,
        dedupedSegmentMap: this.dedupedSegmentMap,
        nodeMap: this.nodeMap,
        nodeIdToSegmentIds: this.nodeIdToSegmentIds,
        segmentIdToNodeIds: this.segmentIdToNodeIds,
        colorMap: this.colorMap,
        rootNodeId: highestPfNodeId,
        MUTABLE_HOPS: this.MUTABLE_HOPS,
        segmentPointMap: this.segmentPointMap,
        nodeToSegmentPointMap: this.nodeToSegmentPointMap,
        segmentToSegmentPointMap: this.segmentToSegmentPointMap,
        cacheProvider: this.cacheProvider
      });
    }
    this.activeSubSolver.step();
    const { bestCandidate, originalCandidate, lastProcessedCandidate } = this.activeSubSolver;
    if (this.activeSubSolver.failed) {
      this.stats.failedOptimizations += 1;
      this.activeSubSolver = null;
      return;
    }
    if (this.activeSubSolver.solved) {
      if (this.activeSubSolver.cacheHit) {
        this.stats.cacheHits += 1;
      } else {
        this.stats.cacheMisses += 1;
      }
      const foundBetterSolution = bestCandidate && bestCandidate.g < originalCandidate.g;
      if (foundBetterSolution) {
        this.stats.successfulOptimizations += 1;
        for (const [
          segmentPointId,
          pointModification
        ] of bestCandidate.pointModifications.entries()) {
          const segmentPoint = this.segmentPointMap.get(segmentPointId);
          segmentPoint.x = pointModification.x ?? segmentPoint.x;
          segmentPoint.y = pointModification.y ?? segmentPoint.y;
          segmentPoint.z = pointModification.z ?? segmentPoint.z;
        }
        for (const nodeId of this.activeSubSolver.unravelSection.allNodeIds) {
          this.nodePfMap.set(
            nodeId,
            this.computeNodePf(this.nodeMap.get(nodeId))
          );
        }
      } else {
        this.stats.failedOptimizations += 1;
      }
      this.activeSubSolver = null;
    }
  }
  visualize() {
    if (this.activeSubSolver) {
      return this.activeSubSolver.visualize();
    }
    const graphics = {
      lines: [],
      points: [],
      rects: [],
      circles: [],
      coordinateSystem: "cartesian",
      title: "Unravel Multi Section Solver"
    };
    for (const [nodeId, node] of this.nodeMap.entries()) {
      const probabilityOfFailure = this.nodePfMap.get(nodeId) || 0;
      const pf = Math.min(probabilityOfFailure, 1);
      const red = Math.floor(255 * pf);
      const green = Math.floor(255 * (1 - pf));
      const color = `rgb(${red}, ${green}, 0)`;
      if ((this.attemptsToFixNode.get(nodeId) ?? 0) === 0 && pf === 0) {
        continue;
      }
      graphics.rects.push({
        center: node.center,
        label: [
          nodeId,
          `${node.width.toFixed(2)}x${node.height.toFixed(2)}`,
          `Pf: ${probabilityOfFailure.toFixed(3)}`
        ].join("\n"),
        color,
        width: node.width / 8,
        height: node.height / 8
      });
    }
    for (const segmentPoint of this.segmentPointMap.values()) {
      const segment = this.dedupedSegmentMap.get(segmentPoint.segmentId);
      graphics.points.push({
        x: segmentPoint.x,
        y: segmentPoint.y,
        label: [
          segmentPoint.segmentPointId,
          segmentPoint.segmentId,
          `z: ${segmentPoint.z}`,
          `segment.availableZ: ${segment?.availableZ.join(",")}`
        ].join("\n"),
        color: this.colorMap[segmentPoint.connectionName] || "#000"
      });
    }
    const pointsBySegment = /* @__PURE__ */ new Map();
    for (const point of this.segmentPointMap.values()) {
      if (!pointsBySegment.has(point.segmentId)) {
        pointsBySegment.set(point.segmentId, []);
      }
      pointsBySegment.get(point.segmentId).push(point);
    }
    for (const [segmentId, points] of pointsBySegment.entries()) {
      if (points.length < 2) continue;
      const sortedPoints = [...points].sort(
        (a, b) => a.x !== b.x ? a.x - b.x : a.y - b.y
      );
      for (let i = 0; i < sortedPoints.length - 1; i++) {
        graphics.lines.push({
          points: [
            { x: sortedPoints[i].x, y: sortedPoints[i].y },
            { x: sortedPoints[i + 1].x, y: sortedPoints[i + 1].y }
          ],
          strokeColor: this.colorMap[segmentId] || "#000"
        });
      }
    }
    const processedConnections = /* @__PURE__ */ new Set();
    const allPoints = Array.from(this.segmentPointMap.values());
    for (let i = 0; i < allPoints.length; i++) {
      const point1 = allPoints[i];
      for (let j = i + 1; j < allPoints.length; j++) {
        const point2 = allPoints[j];
        if (point1.connectionName !== point2.connectionName || point1.segmentId === point2.segmentId) {
          continue;
        }
        const hasSharedNode = point1.capacityMeshNodeIds.some(
          (nodeId) => point2.capacityMeshNodeIds.includes(nodeId)
        );
        if (hasSharedNode) {
          const connectionKey = `${point1.segmentPointId}-${point2.segmentPointId}`;
          if (processedConnections.has(connectionKey)) continue;
          processedConnections.add(connectionKey);
          const sameLayer = point1.z === point2.z;
          const layer = point1.z;
          let strokeDash;
          if (sameLayer) {
            strokeDash = layer === 0 ? void 0 : "10 5";
          } else {
            strokeDash = "3 3 10";
          }
          graphics.lines.push({
            points: [
              { x: point1.x, y: point1.y },
              { x: point2.x, y: point2.y }
            ],
            strokeDash,
            strokeColor: this.colorMap[point1.connectionName] || "#666"
          });
        }
      }
    }
    return graphics;
  }
  getNodesWithPortPoints() {
    if (!this.solved) {
      throw new Error(
        "CapacitySegmentToPointSolver not solved, can't give port points yet"
      );
    }
    const nodeWithPortPointsMap = /* @__PURE__ */ new Map();
    for (const segment of this.dedupedSegments) {
      const segId = segment.nodePortSegmentId;
      for (const nodeId of this.segmentIdToNodeIds.get(segId)) {
        const node = this.nodeMap.get(nodeId);
        if (!nodeWithPortPointsMap.has(nodeId)) {
          nodeWithPortPointsMap.set(nodeId, {
            capacityMeshNodeId: nodeId,
            portPoints: [],
            center: node.center,
            width: node.width,
            height: node.height
          });
        }
      }
    }
    for (const segmentPoint of this.segmentPointMap.values()) {
      for (const nodeId of segmentPoint.capacityMeshNodeIds) {
        const nodeWithPortPoints = nodeWithPortPointsMap.get(nodeId);
        if (nodeWithPortPoints) {
          nodeWithPortPoints.portPoints.push({
            x: segmentPoint.x,
            y: segmentPoint.y,
            z: segmentPoint.z,
            connectionName: segmentPoint.connectionName
          });
        }
      }
    }
    return Array.from(nodeWithPortPointsMap.values());
  }
};

// lib/utils/createRectFromCapacityNode.ts
var createRectFromCapacityNode = (node, opts = {}) => {
  const lowestZ = Math.min(...node.availableZ);
  return {
    center: !opts.rectMargin || opts.zOffset ? {
      x: node.center.x + lowestZ * node.width * (opts.zOffset ?? 0.05),
      y: node.center.y - lowestZ * node.width * (opts.zOffset ?? 0.05)
    } : node.center,
    width: opts.rectMargin ? node.width - opts.rectMargin * 2 : Math.max(node.width - 0.5, node.width * 0.8),
    height: opts.rectMargin ? node.height - opts.rectMargin * 2 : Math.max(node.height - 0.5, node.height * 0.8),
    fill: node._containsObstacle ? "rgba(255,0,0,0.1)" : {
      "0,1": "rgba(0,0,0,0.1)",
      "0": "rgba(0,200,200, 0.1)",
      "1": "rgba(0,0,200, 0.1)"
    }[node.availableZ.join(",")] ?? "rgba(0,200,200,0.1)",
    layer: `z${node.availableZ.join(",")}`,
    label: [
      node.capacityMeshNodeId,
      `availableZ: ${node.availableZ.join(",")}`,
      `${node._containsTarget ? "containsTarget" : ""}`,
      `${node._containsObstacle ? "containsObstacle" : ""}`
    ].filter(Boolean).join("\n")
  };
};

// lib/solvers/CapacityPathingSolver/CapacityPathingSolver.ts
var CapacityPathingSolver = class extends BaseSolver {
  connectionsWithNodes;
  usedNodeCapacityMap;
  simpleRouteJson;
  nodes;
  edges;
  GREEDY_MULTIPLIER = 1.1;
  MAX_CANDIDATES_IN_MEMORY = 1e4;
  nodeMap;
  nodeEdgeMap;
  connectionNameToGoalNodeIds;
  colorMap;
  maxDepthOfNodes;
  activeCandidateStraightLineDistance;
  debug_lastNodeCostMap;
  hyperParameters;
  constructor({
    simpleRouteJson,
    nodes,
    edges,
    colorMap,
    MAX_ITERATIONS = 1e6,
    hyperParameters = {}
  }) {
    super();
    this.MAX_ITERATIONS = MAX_ITERATIONS;
    this.simpleRouteJson = simpleRouteJson;
    this.nodes = nodes;
    this.edges = edges;
    this.colorMap = colorMap ?? {};
    const { connectionsWithNodes, connectionNameToGoalNodeIds } = this.getConnectionsWithNodes();
    this.connectionsWithNodes = connectionsWithNodes;
    this.connectionNameToGoalNodeIds = connectionNameToGoalNodeIds;
    this.hyperParameters = hyperParameters;
    this.usedNodeCapacityMap = new Map(
      this.nodes.map((node) => [node.capacityMeshNodeId, 0])
    );
    this.nodeMap = new Map(
      this.nodes.map((node) => [node.capacityMeshNodeId, node])
    );
    this.nodeEdgeMap = getNodeEdgeMap(this.edges);
    this.maxDepthOfNodes = Math.max(
      ...this.nodes.map((node) => node._depth ?? 0)
    );
    this.debug_lastNodeCostMap = /* @__PURE__ */ new Map();
  }
  getTotalCapacity(node) {
    const depth = node._depth ?? 0;
    return (this.maxDepthOfNodes - depth + 1) ** 2;
  }
  getConnectionsWithNodes() {
    const connectionsWithNodes = [];
    const nodesWithTargets = this.nodes.filter((node) => node._containsTarget);
    const connectionNameToGoalNodeIds = /* @__PURE__ */ new Map();
    for (const connection of this.simpleRouteJson.connections) {
      const nodesForConnection = [];
      for (const point of connection.pointsToConnect) {
        let closestNode = this.nodes[0];
        let minDistance = Number.MAX_VALUE;
        for (const node of nodesWithTargets) {
          const distance6 = Math.sqrt(
            (node.center.x - point.x) ** 2 + (node.center.y - point.y) ** 2
          );
          if (distance6 < minDistance) {
            minDistance = distance6;
            closestNode = node;
          }
        }
        nodesForConnection.push(closestNode);
      }
      if (nodesForConnection.length < 2) {
        throw new Error(
          `Not enough nodes for connection "${connection.name}", only ${nodesForConnection.length} found`
        );
      }
      connectionNameToGoalNodeIds.set(
        connection.name,
        nodesForConnection.map((n) => n.capacityMeshNodeId)
      );
      connectionsWithNodes.push({
        connection,
        nodes: nodesForConnection,
        pathFound: false,
        straightLineDistance: distance(
          nodesForConnection[0].center,
          nodesForConnection[nodesForConnection.length - 1].center
        )
      });
    }
    connectionsWithNodes.sort(
      (a, b) => a.straightLineDistance - b.straightLineDistance
    );
    return { connectionsWithNodes, connectionNameToGoalNodeIds };
  }
  currentConnectionIndex = 0;
  candidates;
  visitedNodes;
  computeG(prevCandidate, node, endGoal) {
    return prevCandidate.g + this.getDistanceBetweenNodes(prevCandidate.node, node);
  }
  computeH(prevCandidate, node, endGoal) {
    return this.getDistanceBetweenNodes(node, endGoal);
  }
  getBacktrackedPath(candidate) {
    const path = [];
    let currentCandidate = candidate;
    while (currentCandidate) {
      path.push(currentCandidate.node);
      currentCandidate = currentCandidate.prevCandidate;
    }
    return path;
  }
  getNeighboringNodes(node) {
    return this.nodeEdgeMap.get(node.capacityMeshNodeId).flatMap(
      (edge) => edge.nodeIds.filter((n) => n !== node.capacityMeshNodeId)
    ).map((n) => this.nodeMap.get(n));
  }
  getCapacityPaths() {
    const capacityPaths = [];
    for (const connection of this.connectionsWithNodes) {
      const path = connection.path;
      if (path) {
        capacityPaths.push({
          capacityPathId: connection.connection.name,
          connectionName: connection.connection.name,
          nodeIds: path.map((node) => node.capacityMeshNodeId)
        });
      }
    }
    return capacityPaths;
  }
  doesNodeHaveCapacityForTrace(node, prevNode) {
    const usedCapacity = this.usedNodeCapacityMap.get(node.capacityMeshNodeId) ?? 0;
    const totalCapacity = this.getTotalCapacity(node);
    if (node.availableZ.length === 1 && !node._containsTarget && usedCapacity > 0)
      return false;
    let additionalCapacityRequirement = 0;
    if (node.availableZ.length > 1 && prevNode.availableZ.length === 1) {
      additionalCapacityRequirement += 0.5;
    }
    return usedCapacity + additionalCapacityRequirement < totalCapacity;
  }
  canTravelThroughObstacle(node, connectionName) {
    const goalNodeIds = this.connectionNameToGoalNodeIds.get(connectionName);
    return goalNodeIds?.includes(node.capacityMeshNodeId) ?? false;
  }
  getDistanceBetweenNodes(A, B) {
    return Math.sqrt(
      (A.center.x - B.center.x) ** 2 + (A.center.y - B.center.y) ** 2
    );
  }
  reduceCapacityAlongPath(nextConnection) {
    for (const node of nextConnection.path ?? []) {
      this.usedNodeCapacityMap.set(
        node.capacityMeshNodeId,
        this.usedNodeCapacityMap.get(node.capacityMeshNodeId) + 1
      );
    }
  }
  isConnectedToEndGoal(node, endGoal) {
    return this.nodeEdgeMap.get(node.capacityMeshNodeId).some((edge) => edge.nodeIds.includes(endGoal.capacityMeshNodeId));
  }
  _step() {
    const nextConnection = this.connectionsWithNodes[this.currentConnectionIndex];
    if (!nextConnection) {
      this.solved = true;
      return;
    }
    const [start, end] = nextConnection.nodes;
    if (!this.candidates) {
      this.candidates = [{ prevCandidate: null, node: start, f: 0, g: 0, h: 0 }];
      this.debug_lastNodeCostMap = /* @__PURE__ */ new Map();
      this.visitedNodes = /* @__PURE__ */ new Set([start.capacityMeshNodeId]);
      this.activeCandidateStraightLineDistance = distance(
        start.center,
        end.center
      );
    }
    this.candidates.sort((a, b) => a.f - b.f);
    const currentCandidate = this.candidates.shift();
    if (this.candidates.length > this.MAX_CANDIDATES_IN_MEMORY) {
      this.candidates.splice(
        this.MAX_CANDIDATES_IN_MEMORY,
        this.candidates.length - this.MAX_CANDIDATES_IN_MEMORY
      );
    }
    if (!currentCandidate) {
      console.error(
        `Ran out of candidates on connection ${nextConnection.connection.name}`
      );
      this.currentConnectionIndex++;
      this.candidates = null;
      this.visitedNodes = null;
      this.failed = true;
      return;
    }
    if (this.isConnectedToEndGoal(currentCandidate.node, end)) {
      nextConnection.path = this.getBacktrackedPath({
        prevCandidate: currentCandidate,
        node: end,
        f: 0,
        g: 0,
        h: 0
      });
      this.reduceCapacityAlongPath(nextConnection);
      this.currentConnectionIndex++;
      this.candidates = null;
      this.visitedNodes = null;
      return;
    }
    const neighborNodes = this.getNeighboringNodes(currentCandidate.node);
    for (const neighborNode of neighborNodes) {
      if (this.visitedNodes?.has(neighborNode.capacityMeshNodeId)) {
        continue;
      }
      if (!this.doesNodeHaveCapacityForTrace(neighborNode, currentCandidate.node)) {
        continue;
      }
      const connectionName = this.connectionsWithNodes[this.currentConnectionIndex].connection.name;
      if (neighborNode._containsObstacle && !this.canTravelThroughObstacle(neighborNode, connectionName)) {
        continue;
      }
      const g = this.computeG(currentCandidate, neighborNode, end);
      const h = this.computeH(currentCandidate, neighborNode, end);
      const f = g + h * this.GREEDY_MULTIPLIER;
      this.debug_lastNodeCostMap.set(neighborNode.capacityMeshNodeId, {
        f,
        g,
        h
      });
      const newCandidate = {
        prevCandidate: currentCandidate,
        node: neighborNode,
        f,
        g,
        h
      };
      this.candidates.push(newCandidate);
    }
    this.visitedNodes.add(currentCandidate.node.capacityMeshNodeId);
  }
  visualize() {
    const graphics = {
      lines: [],
      points: [],
      rects: [],
      circles: []
    };
    if (this.connectionsWithNodes) {
      for (let i = 0; i < this.connectionsWithNodes.length; i++) {
        const conn = this.connectionsWithNodes[i];
        if (conn.path && conn.path.length > 0) {
          const pathPoints = conn.path.map(
            ({ center: { x, y }, width, availableZ }) => ({
              // slight offset to allow viewing overlapping paths
              x: x + (i % 10 + i % 19) * (5e-3 * width),
              y: y + (i % 10 + i % 19) * (5e-3 * width),
              availableZ
            })
          );
          graphics.lines.push({
            points: pathPoints,
            strokeColor: this.colorMap[conn.connection.name]
          });
          for (let u = 0; u < pathPoints.length; u++) {
            const point = pathPoints[u];
            graphics.points.push({
              x: point.x,
              y: point.y,
              label: [
                `conn: ${conn.connection.name}`,
                `node: ${conn.path[u].capacityMeshNodeId}`,
                `z: ${point.availableZ.join(",")}`
              ].join("\n")
            });
          }
        }
      }
    }
    for (const node of this.nodes) {
      const usedCapacity = this.usedNodeCapacityMap.get(node.capacityMeshNodeId) ?? 0;
      const totalCapacity = this.getTotalCapacity(node);
      const nodeCosts = this.debug_lastNodeCostMap.get(node.capacityMeshNodeId);
      graphics.rects.push({
        ...createRectFromCapacityNode(node, {
          rectMargin: 0.025,
          zOffset: 0.01
        }),
        label: [
          `${node.capacityMeshNodeId}`,
          `${usedCapacity}/${totalCapacity}`,
          `${node.width.toFixed(2)}x${node.height.toFixed(2)}`,
          `g: ${nodeCosts?.g !== void 0 ? nodeCosts.g.toFixed(2) : "?"}`,
          `h: ${nodeCosts?.h !== void 0 ? nodeCosts.h.toFixed(2) : "?"}`,
          `f: ${nodeCosts?.f !== void 0 ? nodeCosts.f.toFixed(2) : "?"}`,
          `z: ${node.availableZ.join(", ")}`
        ].join("\n"),
        stroke: usedCapacity > totalCapacity + 0.5 ? "red" : void 0
      });
    }
    if (this.connectionsWithNodes) {
      for (const conn of this.connectionsWithNodes) {
        if (conn.connection?.pointsToConnect) {
          for (const point of conn.connection.pointsToConnect) {
            graphics.points.push({
              x: point.x,
              y: point.y,
              label: [`pointsToConnect ${conn.connection.name}`].join("\n")
            });
          }
        }
      }
    }
    const nextConnection = this.connectionsWithNodes[this.currentConnectionIndex];
    if (nextConnection) {
      const [start, end] = nextConnection.connection.pointsToConnect;
      graphics.lines.push({
        points: [
          { x: start.x, y: start.y },
          { x: end.x, y: end.y }
        ],
        strokeColor: "red",
        strokeDash: "10 5"
      });
    }
    if (this.candidates) {
      const topCandidates = this.candidates.slice(0, 5);
      const connectionName = this.connectionsWithNodes[this.currentConnectionIndex].connection.name;
      topCandidates.forEach((candidate, index) => {
        const opacity = 0.5 * (1 - index / 5);
        const backtrackedPath = this.getBacktrackedPath(candidate);
        graphics.lines.push({
          points: backtrackedPath.map(({ center: { x, y } }) => ({ x, y })),
          strokeColor: safeTransparentize(
            this.colorMap[connectionName] ?? "red",
            1 - opacity
          )
        });
      });
    }
    return graphics;
  }
};

// lib/solvers/CapacityPathingSolver/CapacityPathingSolver5.ts
var CapacityPathingSolver5 = class extends CapacityPathingSolver {
  NEGATIVE_CAPACITY_PENALTY_FACTOR = 1;
  REDUCED_CAPACITY_PENALTY_FACTOR = 1;
  constructor(...args) {
    super(...args);
    this.GREEDY_MULTIPLIER = 2.5;
  }
  get maxCapacityFactor() {
    return this.hyperParameters.MAX_CAPACITY_FACTOR ?? 1;
  }
  getTotalCapacity(node) {
    return getTunedTotalCapacity1(node, this.maxCapacityFactor);
  }
  /**
   * Penalty you pay for using this node
   */
  getNodeCapacityPenalty(node) {
    const MAX_PENALTY = node.width + node.height;
    const MIN_PENALTY = 0.05;
    const START_PENALIZING_CAPACITY_WHEN_IT_DROPS_BELOW = 2;
    const totalCapacity = this.getTotalCapacity(node);
    const usedCapacity = this.usedNodeCapacityMap.get(node.capacityMeshNodeId) ?? 0;
    const remainingCapacity = totalCapacity - usedCapacity;
    if (remainingCapacity > START_PENALIZING_CAPACITY_WHEN_IT_DROPS_BELOW) {
      return MIN_PENALTY;
    }
    const penalty = (MAX_PENALTY - MIN_PENALTY) * Math.max(
      1,
      (START_PENALIZING_CAPACITY_WHEN_IT_DROPS_BELOW - remainingCapacity) / (MAX_PENALTY - MIN_PENALTY)
    ) + MIN_PENALTY;
    return penalty;
  }
  /**
   * We're rewarding travel into big nodes.
   *
   * To minimize shortest path, you'd want to comment this out.
   */
  getDistanceBetweenNodes(A, B) {
    const dx = A.center.x - B.center.x;
    const dy = A.center.y - B.center.y;
    return Math.sqrt(dx ** 2 + dy ** 2);
  }
  computeG(prevCandidate, node, endGoal) {
    return prevCandidate.g + this.getDistanceBetweenNodes(prevCandidate.node, node) + this.getNodeCapacityPenalty(node);
  }
  computeH(prevCandidate, node, endGoal) {
    return this.getDistanceBetweenNodes(node, endGoal) + this.getNodeCapacityPenalty(node);
  }
};

// lib/solvers/CapacityPathingSectionSolver/CapacityPathingGreedySolver.ts
var CapacityPathingGreedySolver = class extends CapacityPathingSolver5 {
  doesNodeHaveCapacityForTrace(node, prevNode) {
    return true;
  }
  getNodeCapacityPenalty(node) {
    const mmPenaltyFactor = 2;
    const MIN_PENALTY = 0.05;
    const totalCapacity = this.getTotalCapacity(node);
    const usedCapacity = this.usedNodeCapacityMap.get(node.capacityMeshNodeId) ?? 0;
    const remainingCapacity = totalCapacity - usedCapacity - 1;
    if (remainingCapacity > 0) {
      return 0;
    }
    let singleLayerUsagePenaltyFactor = 1;
    if (node.availableZ.length === 1) {
      singleLayerUsagePenaltyFactor = 10;
    }
    return (MIN_PENALTY + Math.abs(remainingCapacity) * mmPenaltyFactor) * singleLayerUsagePenaltyFactor;
  }
};

// lib/utils/getLinesBetweenNodes.ts
function getEdgeIntersectionPoint(startPoint, endPoint, rect) {
  const dx = endPoint.x - startPoint.x;
  const dy = endPoint.y - startPoint.y;
  if (Math.abs(dx) < 1e-9 && Math.abs(dy) < 1e-9) return startPoint;
  const halfWidth = rect.width / 2;
  const halfHeight = rect.height / 2;
  const minX = rect.center.x - halfWidth;
  const maxX = rect.center.x + halfWidth;
  const minY = rect.center.y - halfHeight;
  const maxY = rect.center.y + halfHeight;
  let tmin = 0;
  let tmax = Infinity;
  if (Math.abs(dx) > 1e-9) {
    const tx1 = (minX - startPoint.x) / dx;
    const tx2 = (maxX - startPoint.x) / dx;
    tmin = Math.max(tmin, Math.min(tx1, tx2));
    tmax = Math.min(tmax, Math.max(tx1, tx2));
  } else if (startPoint.x < minX || startPoint.x > maxX) {
    return startPoint;
  }
  if (Math.abs(dy) > 1e-9) {
    const ty1 = (minY - startPoint.y) / dy;
    const ty2 = (maxY - startPoint.y) / dy;
    tmin = Math.max(tmin, Math.min(ty1, ty2));
    tmax = Math.min(tmax, Math.max(ty1, ty2));
  } else if (startPoint.y < minY || startPoint.y > maxY) {
    return startPoint;
  }
  if (tmax < tmin || tmin === Infinity || tmin < -1e9) {
    return startPoint;
  }
  const intersectX = startPoint.x + dx * tmin;
  const intersectY = startPoint.y + dy * tmin;
  return { x: intersectX, y: intersectY };
}
function getLinesBetweenNodes(nodeA, nodeB) {
  const centerA = nodeA.center;
  const centerB = nodeB.center;
  const intersectA = getEdgeIntersectionPoint(centerA, centerB, nodeA);
  const intersectB = getEdgeIntersectionPoint(centerB, centerA, nodeB);
  const vec = { dx: centerB.x - centerA.x, dy: centerB.y - centerA.y };
  const len = Math.sqrt(vec.dx * vec.dx + vec.dy * vec.dy);
  let lineStart = intersectA;
  let lineEnd = intersectB;
  if (len > 1e-9) {
    const unitVec = { x: vec.dx / len, y: vec.dy / len };
    const marginA = 0.3 * nodeA.width;
    const marginB = 0.3 * nodeB.width;
    const distIntersectAIntersectB = Math.sqrt(
      (intersectB.x - intersectA.x) ** 2 + (intersectB.y - intersectA.y) ** 2
    );
    if (marginA + marginB < distIntersectAIntersectB) {
      lineStart = {
        x: intersectA.x + unitVec.x * marginA,
        y: intersectA.y + unitVec.y * marginA
      };
      lineEnd = {
        x: intersectB.x - unitVec.x * marginB,
        y: intersectB.y - unitVec.y * marginB
      };
    } else {
      lineStart = intersectA;
      lineEnd = intersectB;
    }
  }
  return { lineStart, lineEnd };
}

// lib/solvers/CapacityPathingSectionSolver/computeSectionScore.ts
var calculateNodeProbabilityOfFailure2 = (usedCapacity, totalCapacity, layerCount) => {
  if (usedCapacity < totalCapacity) return 0;
  if (totalCapacity < 1 && usedCapacity <= 1) return 0;
  const ratioOverTotal = usedCapacity / totalCapacity;
  if (layerCount === 1 && usedCapacity > 1) {
    return 1 - 0.01 ** usedCapacity;
  }
  const k = 2;
  const adjustedRatio = ratioOverTotal - 1;
  return 1 - Math.exp(-k * adjustedRatio);
};
var calculateSingleNodeLogSuccessProbability = (usedCapacity, totalCapacity, node) => {
  if (node._containsTarget) return 0;
  if (usedCapacity <= totalCapacity) return 0;
  const probabilityOfFailure = calculateNodeProbabilityOfFailure2(
    usedCapacity,
    totalCapacity,
    node.availableZ.length
  );
  const probabilityOfSuccess = 1 - probabilityOfFailure;
  if (probabilityOfSuccess <= 0) {
    return -1e9;
  } else {
    return Math.log(probabilityOfSuccess);
  }
};
var computeSectionScore = ({
  totalNodeCapacityMap,
  usedNodeCapacityMap,
  nodeMap,
  sectionNodeIds
  // Destructure sectionNodeIds here
}) => {
  let logProbabilityOfSuccessSum = 0;
  const nodesToConsider = sectionNodeIds ?? new Set(usedNodeCapacityMap.keys());
  for (const nodeId of nodesToConsider) {
    if (!totalNodeCapacityMap.has(nodeId)) continue;
    const node = nodeMap.get(nodeId);
    if (!node) continue;
    const totalCapacity = totalNodeCapacityMap.get(nodeId);
    const usedCapacity = usedNodeCapacityMap.get(nodeId) ?? 0;
    logProbabilityOfSuccessSum += calculateSingleNodeLogSuccessProbability(
      usedCapacity,
      totalCapacity,
      node
    );
  }
  return logProbabilityOfSuccessSum;
};

// lib/solvers/CapacityPathingSectionSolver/visualizeSection.ts
function visualizeSection({
  sectionNodes,
  sectionEdges,
  sectionConnectionTerminals,
  completedPaths,
  // Added completedPaths
  nodeMap,
  colorMap,
  centerNodeId,
  title,
  nodeOpacity = 0.1,
  usedNodeCapacityMap,
  // Destructure added params
  totalCapacityMap
  // Destructure added params
}) {
  const graphics = {
    points: [],
    lines: [],
    rects: [],
    circles: [],
    title
  };
  const sectionNodeIds = new Set(sectionNodes.map((n) => n.capacityMeshNodeId));
  for (const node of sectionNodes) {
    let nodeFill = `rgba(128, 128, 128, ${nodeOpacity})`;
    let nodeStroke = `rgba(128, 128, 128, ${nodeOpacity})`;
    const availableZ = node.availableZ ?? [];
    const hasZ0 = availableZ.includes(0);
    const hasZ1 = availableZ.includes(1);
    if (hasZ0 && hasZ1) {
      nodeFill = `rgba(128, 0, 128, ${nodeOpacity})`;
      nodeStroke = `rgba(128, 0, 128, ${nodeOpacity})`;
    } else if (hasZ0) {
      nodeFill = `rgba(0, 0, 255, ${nodeOpacity})`;
      nodeStroke = `rgba(0, 0, 255, ${nodeOpacity})`;
    } else if (hasZ1) {
      nodeFill = `rgba(255, 0, 0, ${nodeOpacity})`;
      nodeStroke = `rgba(255, 0, 0, ${nodeOpacity})`;
    }
    if (centerNodeId && node.capacityMeshNodeId === centerNodeId) {
      nodeFill = `rgba(0, 255, 0, ${nodeOpacity})`;
      nodeStroke = `rgba(0, 128, 0, ${nodeOpacity})`;
    }
    graphics.rects.push({
      ...createRectFromCapacityNode(node),
      fill: nodeFill,
      stroke: nodeStroke,
      label: `${node.capacityMeshNodeId}
(Section Node)
Z: ${availableZ.join(",")}`
    });
    const rectIndex = graphics.rects.length - 1;
    if (usedNodeCapacityMap && totalCapacityMap) {
      const used = usedNodeCapacityMap.get(node.capacityMeshNodeId) ?? 0;
      const total = totalCapacityMap.get(node.capacityMeshNodeId) ?? 0;
      const percent = total > 0 ? (used / total * 100).toFixed(1) : "N/A";
      const probabilityOfFailure = calculateNodeProbabilityOfFailure2(
        used,
        total,
        node.availableZ.length
      );
      graphics.rects[rectIndex].label += `
${used.toFixed(
        1
      )} / ${total.toFixed(1)}
${percent}% (Pf: ${(probabilityOfFailure * 100).toFixed(1)}%)`;
      if (probabilityOfFailure > 0.2) {
        graphics.rects[rectIndex].stroke = safeTransparentize(
          "red",
          (0.8 + nodeOpacity) * 0.7
        );
      }
    }
  }
  for (const edge of sectionEdges) {
    const [nodeIdA, nodeIdB] = edge.nodeIds;
    const nodeA = nodeMap.get(nodeIdA);
    const nodeB = nodeMap.get(nodeIdB);
    if (nodeA && nodeB) {
      const { lineStart, lineEnd } = getLinesBetweenNodes(nodeA, nodeB);
      graphics.lines.push({
        points: [lineStart, lineEnd],
        strokeColor: `rgba(0, 0, 0, ${0.2 * Math.min(1, nodeOpacity / 0.1)})`
        // Light gray for intra-section edges
      });
    }
  }
  sectionConnectionTerminals.forEach((terminal, index) => {
    const startNode = nodeMap.get(terminal.startNodeId);
    const endNode = nodeMap.get(terminal.endNodeId);
    const connectionColor = colorMap[terminal.connectionName] ?? "black";
    const isStartInSection = startNode && sectionNodeIds.has(startNode.capacityMeshNodeId);
    const isEndInSection = endNode && sectionNodeIds.has(endNode.capacityMeshNodeId);
    const offsetMultiplier = (index + index / 50) % 5;
    let startOffsetX = 0;
    let startOffsetY = 0;
    let endOffsetX = 0;
    let endOffsetY = 0;
    if (isStartInSection && startNode) {
      const baseOffset = 0.02 * Math.min(startNode.width, startNode.height);
      startOffsetX = baseOffset * offsetMultiplier;
      startOffsetY = baseOffset * offsetMultiplier;
      graphics.points.push({
        x: startNode.center.x + startOffsetX,
        y: startNode.center.y + startOffsetY,
        color: connectionColor,
        label: `Start: ${terminal.connectionName}
(${terminal.startNodeId})`
      });
      graphics.lines.push({
        points: [
          { x: startNode.center.x, y: startNode.center.y },
          {
            x: startNode.center.x + startOffsetX,
            y: startNode.center.y + startOffsetY
          }
        ],
        strokeColor: "gray",
        strokeDash: "2 2"
      });
    }
    if (isEndInSection && endNode) {
      const baseOffset = 0.02 * Math.min(endNode.width, endNode.height);
      endOffsetX = baseOffset * offsetMultiplier;
      endOffsetY = baseOffset * offsetMultiplier;
      graphics.points.push({
        x: endNode.center.x + endOffsetX,
        y: endNode.center.y + endOffsetY,
        color: connectionColor,
        label: `End: ${terminal.connectionName}
(${terminal.endNodeId})`
      });
      graphics.lines.push({
        points: [
          { x: endNode.center.x, y: endNode.center.y },
          {
            x: endNode.center.x + endOffsetX,
            y: endNode.center.y + endOffsetY
          }
        ],
        strokeColor: "gray",
        strokeDash: "2 2"
      });
    }
    if (isStartInSection && isEndInSection && startNode && endNode) {
      graphics.lines.push({
        points: [
          {
            x: startNode.center.x + startOffsetX,
            y: startNode.center.y + startOffsetY
          },
          {
            x: endNode.center.x + endOffsetX,
            y: endNode.center.y + endOffsetY
          }
        ],
        strokeColor: connectionColor,
        strokeDash: "5 5"
      });
    }
  });
  if (completedPaths) {
    completedPaths.forEach((solvedPathData, index) => {
      if (solvedPathData.path && solvedPathData.path.length > 0) {
        const pathColor = colorMap[solvedPathData.connectionName] ?? "gray";
        const offset = {
          x: (index + index / 50) % 5 * 0.03,
          y: (index + index / 50) % 5 * 0.03
        };
        graphics.lines.push({
          points: solvedPathData.path.map(({ center: { x, y } }) => ({
            x: x + offset.x,
            y: y + offset.y
          })),
          strokeColor: safeTransparentize(pathColor, 0.2)
          // Make solved paths semi-transparent
          // strokeWidth: 0.03,
        });
      }
    });
  }
  return graphics;
}

// lib/solvers/CapacityPathingSectionSolver/computeSectionNodesTerminalsAndEdges.ts
var computeSectionNodesTerminalsAndEdges = (opts) => {
  const {
    centerNodeId,
    connectionsWithNodes,
    nodeMap,
    edges,
    nodeEdgeMap,
    expansionDegrees
  } = opts;
  const sectionNodeIds = /* @__PURE__ */ new Set();
  const queue = [
    { nodeId: centerNodeId, depth: 0 }
  ];
  sectionNodeIds.add(centerNodeId);
  let head = 0;
  while (head < queue.length) {
    const { nodeId, depth } = queue[head++];
    if (depth >= expansionDegrees) continue;
    const neighbors = nodeEdgeMap.get(nodeId)?.flatMap((edge) => edge.nodeIds.filter((id) => id !== nodeId)) ?? [];
    for (const neighborId of neighbors) {
      if (!sectionNodeIds.has(neighborId)) {
        sectionNodeIds.add(neighborId);
        queue.push({ nodeId: neighborId, depth: depth + 1 });
      }
    }
  }
  const sectionNodes = Array.from(sectionNodeIds).map((id) => nodeMap.get(id));
  const sectionEdges = edges.filter((edge) => {
    const [nodeIdA, nodeIdB] = edge.nodeIds;
    return sectionNodeIds.has(nodeIdA) && sectionNodeIds.has(nodeIdB);
  });
  const sectionConnectionTerminals = [];
  for (const conn of connectionsWithNodes) {
    if (!conn.path) continue;
    let startNodeId = null;
    let endNodeId = null;
    for (const node of conn.path) {
      if (sectionNodeIds.has(node.capacityMeshNodeId)) {
        startNodeId = node.capacityMeshNodeId;
        break;
      }
    }
    for (let i = conn.path.length - 1; i >= 0; i--) {
      const node = conn.path[i];
      if (sectionNodeIds.has(node.capacityMeshNodeId)) {
        endNodeId = node.capacityMeshNodeId;
        break;
      }
    }
    if (startNodeId && endNodeId) {
      sectionConnectionTerminals.push({
        connectionName: conn.connection.name,
        startNodeId,
        endNodeId
      });
    }
  }
  return {
    sectionConnectionTerminals,
    sectionNodes,
    sectionEdges,
    centerNodeId
  };
};

// lib/solvers/CapacityPathingSectionSolver/CapacityPathingSingleSectionSolver.ts
var CapacityPathingSingleSectionSolver = class extends BaseSolver {
  GREEDY_MULTIPLIER = 1.5;
  sectionNodes;
  sectionEdges;
  sectionConnectionTerminals;
  nodeMap;
  // Map of nodes *within the section*
  nodeEdgeMap;
  // Edges *within the section*
  colorMap;
  usedNodeCapacityMap;
  // Tracks capacity usage *within this solver's run*
  totalNodeCapacityMap;
  // Added: Stores total capacity for each node
  centerNodeId;
  currentSectionScore = 0;
  MAX_CANDIDATES_IN_MEMORY = 1e4;
  // A* state
  currentConnectionIndex = 0;
  candidates = null;
  visitedNodes = null;
  queuedNodes = null;
  activeCandidateStraightLineDistance;
  debug_lastNodeCostMap = /* @__PURE__ */ new Map();
  // TODO: Decide if maxCapacityFactor needs to be configurable via hyperParameters
  maxCapacityFactor = 1;
  // Default, similar to CapacityPathingSolver5
  constructor(params) {
    super();
    this.MAX_ITERATIONS = 1e4;
    this.centerNodeId = params.centerNodeId;
    this.sectionNodes = params.sectionNodes;
    this.sectionEdges = params.sectionEdges;
    this.sectionConnectionTerminals = params.sectionConnectionTerminals.map(
      (t) => ({ ...t, path: void 0 })
    );
    this.nodeMap = params.nodeMap ?? new Map(this.sectionNodes.map((n) => [n.capacityMeshNodeId, n]));
    this.nodeEdgeMap = params.nodeEdgeMap ?? getNodeEdgeMap(this.sectionEdges);
    this.colorMap = params.colorMap ?? {};
    this.usedNodeCapacityMap = new Map(
      this.sectionNodes.map((node) => [node.capacityMeshNodeId, 0])
    );
    this.totalNodeCapacityMap = new Map(
      this.sectionNodes.map((node) => [
        node.capacityMeshNodeId,
        this.getTotalCapacity(node)
      ])
    );
    const initialSectionNodeIds = new Set(
      this.sectionNodes.map((n) => n.capacityMeshNodeId)
    );
    this.currentSectionScore = computeSectionScore({
      totalNodeCapacityMap: this.totalNodeCapacityMap,
      usedNodeCapacityMap: this.usedNodeCapacityMap,
      // Reflects initial capacities
      nodeMap: this.nodeMap,
      sectionNodeIds: initialSectionNodeIds
    });
    if (params.hyperParameters?.SHUFFLE_SEED) {
      this.sectionConnectionTerminals = cloneAndShuffleArray(
        this.sectionConnectionTerminals,
        params.hyperParameters?.SHUFFLE_SEED
      );
    }
  }
  // --- Methods adapted from CapacityPathingSolver & CapacityPathingSolver5 ---
  // Adapted from CapacityPathingSolver5
  getTotalCapacity(node) {
    return getTunedTotalCapacity1(node, this.maxCapacityFactor);
  }
  // Adapted from CapacityPathingSolver5
  getNodeCapacityPenalty(node) {
    if (!this.nodeMap.has(node.capacityMeshNodeId)) return Infinity;
    const mmPenaltyFactor = 4;
    const MIN_PENALTY = 0.05;
    const totalCapacity = this.getTotalCapacity(node);
    const usedCapacity = this.usedNodeCapacityMap.get(node.capacityMeshNodeId) ?? 0;
    const remainingCapacity = totalCapacity - usedCapacity - 1;
    if (remainingCapacity > 0) {
      return 0;
    }
    let singleLayerUsagePenaltyFactor = 1;
    if (node.availableZ.length === 1) {
      singleLayerUsagePenaltyFactor = 10;
    }
    return (MIN_PENALTY + remainingCapacity ** 2 * mmPenaltyFactor) * singleLayerUsagePenaltyFactor;
  }
  // Adapted from CapacityPathingSolver5 (using simple distance)
  getDistanceBetweenNodes(A, B) {
    const dx = A.center.x - B.center.x;
    const dy = A.center.y - B.center.y;
    return Math.sqrt(dx ** 2 + dy ** 2);
  }
  // Adapted from CapacityPathingSolver5
  computeG(prevCandidate, node, endGoal) {
    return prevCandidate.g + this.getDistanceBetweenNodes(prevCandidate.node, node) + this.getNodeCapacityPenalty(node);
  }
  // Adapted from CapacityPathingSolver5
  computeH(prevCandidate, node, endGoal) {
    return this.getDistanceBetweenNodes(node, endGoal) + this.getNodeCapacityPenalty(node);
  }
  // Adapted from CapacityPathingSolver
  getBacktrackedPath(candidate) {
    const path = [];
    let currentCandidate = candidate;
    while (currentCandidate) {
      path.push(currentCandidate.node);
      if (this.nodeMap.has(currentCandidate.node.capacityMeshNodeId)) {
        currentCandidate = currentCandidate.prevCandidate;
      } else {
        console.warn("Backtracked path went outside section bounds");
        break;
      }
    }
    return path.reverse();
  }
  // Adapted from CapacityPathingSolver - uses section's nodeEdgeMap
  getNeighboringNodes(node) {
    if (!this.nodeMap.has(node.capacityMeshNodeId)) return [];
    return this.nodeEdgeMap.get(node.capacityMeshNodeId)?.flatMap(
      (edge) => edge.nodeIds.filter((n) => n !== node.capacityMeshNodeId)
    ).map((nId) => this.nodeMap.get(nId)).filter(Boolean) ?? [];
  }
  // Adapted from CapacityPathingSolver - uses section's nodeEdgeMap
  isConnectedToEndGoal(node, endGoal) {
    if (!this.nodeMap.has(node.capacityMeshNodeId) || !this.nodeMap.has(endGoal.capacityMeshNodeId))
      return false;
    return (this.nodeEdgeMap.get(node.capacityMeshNodeId) ?? []).some(
      (edge) => edge.nodeIds.includes(endGoal.capacityMeshNodeId)
    );
  }
  // Adapted from CapacityPathingSolver - uses section's capacity map and total capacity calculation
  doesNodeHaveCapacityForTrace(node, prevNode) {
    return true;
  }
  // Adapted from CapacityPathingSolver - uses section's capacity map
  reduceCapacityAlongPath(path) {
    for (const pathNode of path) {
      if (this.usedNodeCapacityMap.has(pathNode.capacityMeshNodeId)) {
        const nodeId = pathNode.capacityMeshNodeId;
        const nodeInSection = this.nodeMap.get(nodeId);
        if (!nodeInSection) {
          console.warn(
            `Node ${nodeId} from path not found in section's nodeMap during score update.`
          );
          continue;
        }
        const totalCapacity = this.totalNodeCapacityMap.get(nodeId);
        const oldUsedCapacity = this.usedNodeCapacityMap.get(nodeId) ?? 0;
        const oldNodeScoreContribution = calculateSingleNodeLogSuccessProbability(
          oldUsedCapacity,
          totalCapacity,
          nodeInSection
          // Use the node object from the section's map
        );
        this.currentSectionScore -= oldNodeScoreContribution;
        const newUsedCapacity = oldUsedCapacity + 1;
        this.usedNodeCapacityMap.set(nodeId, newUsedCapacity);
        const newNodeScoreContribution = calculateSingleNodeLogSuccessProbability(
          newUsedCapacity,
          totalCapacity,
          nodeInSection
          // Use the node object from the section's map
        );
        this.currentSectionScore += newNodeScoreContribution;
      }
    }
  }
  getSolvedSectionScore() {
    return this.currentSectionScore;
  }
  _step() {
    const currentTerminal = this.sectionConnectionTerminals[this.currentConnectionIndex];
    if (!currentTerminal) {
      this.solved = true;
      return;
    }
    const startNode = this.nodeMap.get(currentTerminal.startNodeId);
    const endNode = this.nodeMap.get(currentTerminal.endNodeId);
    if (!startNode || !endNode) {
      console.error(
        `Start or end node not found in section for connection ${currentTerminal.connectionName}`
      );
      this.currentConnectionIndex++;
      this.candidates = null;
      this.visitedNodes = null;
      return;
    }
    if (!this.candidates) {
      this._setupAStar(startNode, endNode);
    }
    const candidates = this.candidates;
    if (candidates.length === 0) {
      this._handleCandidatesExhausted(currentTerminal);
      return;
    }
    candidates.sort((a, b) => a.f - b.f);
    const currentCandidate = candidates.shift();
    if (candidates.length > this.MAX_CANDIDATES_IN_MEMORY) {
      candidates.splice(
        this.MAX_CANDIDATES_IN_MEMORY,
        candidates.length - this.MAX_CANDIDATES_IN_MEMORY
      );
    }
    this.visitedNodes.add(currentCandidate.node.capacityMeshNodeId);
    if (currentCandidate.node.capacityMeshNodeId === endNode.capacityMeshNodeId) {
      this._handleGoalReached(currentCandidate, currentTerminal, endNode);
      return;
    }
    const neighborNodes = this.getNeighboringNodes(currentCandidate.node);
    for (const neighborNode of neighborNodes) {
      if (this.queuedNodes?.has(neighborNode.capacityMeshNodeId)) {
        continue;
      }
      if (!this.doesNodeHaveCapacityForTrace(neighborNode, currentCandidate.node)) {
        continue;
      }
      if (neighborNode._containsObstacle) {
        const isStartTerminal = neighborNode.capacityMeshNodeId === currentTerminal.startNodeId;
        const isEndTerminal = neighborNode.capacityMeshNodeId === currentTerminal.endNodeId;
        if (!isStartTerminal && !isEndTerminal) {
          continue;
        }
      }
      const g = this.computeG(currentCandidate, neighborNode, endNode);
      const h = this.computeH(currentCandidate, neighborNode, endNode);
      const f = g + h * this.GREEDY_MULTIPLIER;
      this.debug_lastNodeCostMap.set(neighborNode.capacityMeshNodeId, {
        f,
        g,
        h
      });
      const newCandidate = {
        prevCandidate: currentCandidate,
        node: neighborNode,
        f,
        g,
        h
      };
      this.queuedNodes?.add(neighborNode.capacityMeshNodeId);
      candidates.push(newCandidate);
    }
  }
  computeProgress() {
    const totalConnections = this.sectionConnectionTerminals.length;
    if (totalConnections === 0) return 1;
    const completedConnections = this.currentConnectionIndex;
    let progress = completedConnections / totalConnections;
    if (this.currentConnectionIndex < totalConnections && this.candidates && this.candidates.length > 0 && this.activeCandidateStraightLineDistance && this.activeCandidateStraightLineDistance > 0) {
      const bestCandidate = this.candidates.reduce(
        (best, current) => current.f < best.f ? current : best
      );
      const currentConnectionProgress = Math.max(
        0,
        Math.min(
          1,
          1 - bestCandidate.h / this.activeCandidateStraightLineDistance
        )
      );
      progress += currentConnectionProgress / totalConnections;
    } else if (this.solved) {
      progress = 1;
    }
    return Math.min(1, progress);
  }
  _setupAStar(startNode, endNode) {
    this.candidates = [
      { prevCandidate: null, node: startNode, f: 0, g: 0, h: 0 }
    ];
    this.visitedNodes = /* @__PURE__ */ new Set([startNode.capacityMeshNodeId]);
    this.debug_lastNodeCostMap = /* @__PURE__ */ new Map();
    this.activeCandidateStraightLineDistance = distance(
      startNode.center,
      endNode.center
    );
    const initialH = this.computeH(null, startNode, endNode);
    this.candidates[0].h = initialH;
    this.candidates[0].f = initialH * this.GREEDY_MULTIPLIER;
    this.debug_lastNodeCostMap.set(startNode.capacityMeshNodeId, {
      f: this.candidates[0].f,
      g: 0,
      h: initialH
    });
    this.queuedNodes = /* @__PURE__ */ new Set([startNode.capacityMeshNodeId]);
  }
  _handleCandidatesExhausted(currentTerminal) {
    console.error(
      `Ran out of candidates for section connection ${currentTerminal.connectionName}`
    );
    this.currentConnectionIndex++;
    this.candidates = null;
    this.visitedNodes = null;
    this.queuedNodes = null;
  }
  _handleGoalReached(currentCandidate, currentTerminal, endNode) {
    const path = this.getBacktrackedPath(currentCandidate);
    currentTerminal.path = path;
    this.reduceCapacityAlongPath(path);
    this.currentConnectionIndex++;
    this.candidates = null;
    this.visitedNodes = null;
    this.queuedNodes = null;
  }
  visualize() {
    const completedPathsForViz = this.sectionConnectionTerminals.filter((t) => t.path && t.path.length > 0).map((t) => ({
      connectionName: t.connectionName,
      path: t.path
      // Assert path is defined due to filter
    }));
    const baseGraphics = visualizeSection({
      sectionNodes: this.sectionNodes,
      sectionEdges: this.sectionEdges,
      sectionConnectionTerminals: this.sectionConnectionTerminals,
      // Still pass terminals for start/end points
      completedPaths: completedPathsForViz,
      // Pass the solved paths
      nodeMap: this.nodeMap,
      // Pass the section's node map
      colorMap: this.colorMap,
      centerNodeId: null,
      // No single center node for pathing visualization
      title: `Section Pathing: Conn ${this.currentConnectionIndex + 1}/${this.sectionConnectionTerminals.length} (${this.sectionNodes.length} nodes)`,
      nodeOpacity: 0.1
    });
    for (const node of this.sectionNodes) {
      const rectIndex = baseGraphics.rects.findIndex(
        (r) => r.label?.includes(node.capacityMeshNodeId)
      );
      if (rectIndex !== -1) {
        const costs = this.debug_lastNodeCostMap.get(node.capacityMeshNodeId);
        const usedCapacity = this.usedNodeCapacityMap.get(node.capacityMeshNodeId) ?? 0;
        const totalCapacity = this.getTotalCapacity(node);
        const capacityLabel = `${usedCapacity.toFixed(1)}/${totalCapacity.toFixed(
          1
        )}`;
        const costLabel = costs ? `f:${costs.f.toFixed(1)} g:${costs.g.toFixed(
          1
        )} h:${costs.h.toFixed(1)}` : "cost:?";
        baseGraphics.rects[rectIndex].label = [
          node.capacityMeshNodeId,
          `Cap: ${capacityLabel}`,
          costLabel,
          `Z: ${node.availableZ.join(",")}`
        ].join("\n");
        if (usedCapacity > totalCapacity) {
          baseGraphics.rects[rectIndex].stroke = safeTransparentize("red", 0.7);
        }
      }
    }
    if (this.candidates && this.candidates.length > 0) {
      const topCandidates = this.candidates.slice().sort((a, b) => a.f - b.f).slice(0, 5);
      const currentTerminal = this.sectionConnectionTerminals[this.currentConnectionIndex];
      const connectionName = currentTerminal?.connectionName ?? "unknown";
      const connectionColor = this.colorMap[connectionName] ?? "purple";
      topCandidates.forEach((candidate, index) => {
        const opacity = 0.8 * (1 - index / 5);
        const path = this.getBacktrackedPath(candidate);
        if (path.length > 0) {
          baseGraphics.lines.push({
            points: path.map(({ center: { x, y } }) => ({ x, y })),
            strokeColor: safeTransparentize(connectionColor, 1 - opacity),
            strokeWidth: 0.05
          });
        }
      });
    }
    return baseGraphics;
  }
};
var CapacityPathingSingleSectionPathingSolver = CapacityPathingSingleSectionSolver;

// lib/solvers/CapacityPathingSectionSolver/HyperCapacityPathingSingleSectionSolver.ts
var range = (n) => Array.from({ length: n }, (_, i) => i);
var HyperCapacityPathingSingleSectionSolver = class extends HyperParameterSupervisorSolver {
  constructorParams;
  constructor(params) {
    super();
    this.MAX_ITERATIONS = 1e5;
    this.constructorParams = params;
  }
  // TODO this needs to use the section score, ideally incorporating the current best candidate
  // of the paths being explored inside the single section
  computeG(solver) {
    return -solver.getSolvedSectionScore();
  }
  computeH(solver) {
    return 0;
  }
  getCombinationDefs() {
    const numConnections = this.constructorParams.sectionConnectionTerminals.length;
    if (numConnections === 2) {
      return [["orderings2_for2"]];
    } else if (numConnections === 3) {
      return [["orderings6_for3"]];
    } else if (numConnections === 4) {
      return [["orderings24_for4"]];
    }
    return [["orderings30"]];
  }
  getFailureMessage() {
    return `All CapacityPathingSingleSection solvers failed for "${this.centerNodeId}"`;
  }
  getHyperParameterDefs() {
    return [
      {
        name: "orderings2_for2",
        possibleValues: range(2).map((i) => ({
          SHUFFLE_SEED: i
        }))
      },
      {
        name: "orderings6_for3",
        possibleValues: range(6).map((i) => ({
          SHUFFLE_SEED: i
        }))
      },
      {
        name: "orderings24_for4",
        possibleValues: range(24).map((i) => ({
          SHUFFLE_SEED: i
        }))
      },
      {
        name: "orderings30",
        possibleValues: range(30).map((i) => ({
          SHUFFLE_SEED: i
        }))
      }
    ];
  }
  generateSolver(hyperParameters) {
    return new CapacityPathingSingleSectionPathingSolver({
      ...this.constructorParams,
      hyperParameters: {
        ...this.constructorParams.hyperParameters,
        ...hyperParameters
      }
    });
  }
  onSolve({
    solver
  }) {
    this.winningSolver = solver;
  }
  get centerNodeId() {
    return this.constructorParams.centerNodeId;
  }
  get sectionNodes() {
    return this.constructorParams.sectionNodes;
  }
  get sectionConnectionTerminals() {
    return this.winningSolver?.sectionConnectionTerminals;
  }
};

// lib/solvers/CapacityPathingSectionSolver/CachedHyperCapacityPathingSingleSectionSolver.ts
import objectHash2 from "object-hash";
var roundCapacity = (capacity) => Math.floor(capacity * 10) / 10;
var CachedHyperCapacityPathingSingleSectionSolver = class extends HyperCapacityPathingSingleSectionSolver {
  cacheHit = false;
  cacheProvider;
  hasAttemptedToUseCache = false;
  sectionNodeIdSet;
  cachedSectionConnectionTerminals = null;
  sectionScore = 0;
  constructor(params) {
    params.nodeMap = params.nodeMap ?? new Map(params.sectionNodes.map((n) => [n.capacityMeshNodeId, n]));
    super(params);
    this.sectionNodeIdSet = new Set(
      params.sectionNodes.map((sn) => sn.capacityMeshNodeId)
    );
    this.cacheProvider = params.cacheProvider === void 0 ? getGlobalInMemoryCache() : params.cacheProvider;
  }
  _step() {
    if (!this.hasAttemptedToUseCache && this.cacheProvider) {
      if (this.attemptToUseCacheSync()) return;
    }
    super._step();
    if ((this.solved || this.failed) && this.cacheProvider) {
      this.saveToCacheSync();
    }
  }
  _computeBfsOrderingOfNodesInSection() {
    const seenNodeIds = new Set(this.constructorParams.centerNodeId);
    const ordering = [];
    const candidates = [
      {
        ancestorCapacitySum: 0,
        capacity: 0,
        g: 0,
        capacityMeshNodeId: this.constructorParams.centerNodeId
      }
    ];
    while (candidates.length > 0) {
      candidates.sort((a, b) => b.g - a.g);
      const candidate = candidates.pop();
      if (!candidate) break;
      ordering.push(candidate.capacityMeshNodeId);
      const neighborNodeIds = this.constructorParams.nodeEdgeMap.get(candidate.capacityMeshNodeId).flatMap((edge) => edge.nodeIds).filter((nodeId) => !seenNodeIds.has(nodeId)).filter((nodeId) => this.sectionNodeIdSet.has(nodeId));
      for (const neighborNodeId of neighborNodeIds) {
        seenNodeIds.add(neighborNodeId);
        const neighbor = this.constructorParams.nodeMap.get(neighborNodeId);
        const capacity = getTunedTotalCapacity1(neighbor);
        candidates.push({
          ancestorCapacitySum: candidate.g,
          capacity,
          g: candidate.g + capacity,
          capacityMeshNodeId: neighborNodeId
        });
      }
    }
    return ordering;
  }
  computeCacheKeyAndTransform() {
    const nodeOrdering = this._computeBfsOrderingOfNodesInSection();
    const realToCacheSpaceNodeIdMap = /* @__PURE__ */ new Map();
    const cacheSpaceToRealNodeIdMap = /* @__PURE__ */ new Map();
    nodeOrdering.forEach((realNodeId, i) => {
      const cacheNodeId = `node${i}`;
      realToCacheSpaceNodeIdMap.set(realNodeId, cacheNodeId);
      cacheSpaceToRealNodeIdMap.set(cacheNodeId, realNodeId);
    });
    const node_capacity_map = {};
    for (const realNodeId of nodeOrdering) {
      const cacheNodeId = realToCacheSpaceNodeIdMap.get(realNodeId);
      const node = this.constructorParams.nodeMap.get(realNodeId);
      const capacity = getTunedTotalCapacity1(node);
      node_capacity_map[cacheNodeId] = roundCapacity(capacity).toFixed(
        1
      );
    }
    const node_edge_map_set = /* @__PURE__ */ new Set();
    const node_edge_map = [];
    for (const realNodeId1 of nodeOrdering) {
      const cacheNodeId1 = realToCacheSpaceNodeIdMap.get(realNodeId1);
      const neighbors = this.constructorParams.nodeEdgeMap.get(realNodeId1) ?? [];
      for (const edge of neighbors) {
        const realNodeId2 = edge.nodeIds.find((id) => id !== realNodeId1);
        if (this.sectionNodeIdSet.has(realNodeId2)) {
          const cacheNodeId2 = realToCacheSpaceNodeIdMap.get(realNodeId2);
          const pair = [cacheNodeId1, cacheNodeId2].sort();
          const pairKey = `${pair[0]}-${pair[1]}`;
          if (!node_edge_map_set.has(pairKey)) {
            node_edge_map.push(pair);
            node_edge_map_set.add(pairKey);
          }
        }
      }
    }
    node_edge_map.sort((a, b) => {
      if (a[0] !== b[0]) return a[0].localeCompare(b[0]);
      return a[1].localeCompare(b[1]);
    });
    const terminals = {};
    const cacheSpaceToRealConnectionId = /* @__PURE__ */ new Map();
    const connectionPairMap = /* @__PURE__ */ new Map();
    for (const conn of this.constructorParams.sectionConnectionTerminals) {
      const cacheStartNodeId = realToCacheSpaceNodeIdMap.get(conn.startNodeId);
      const cacheEndNodeId = realToCacheSpaceNodeIdMap.get(conn.endNodeId);
      const [sortedStartId, sortedEndId] = [
        cacheStartNodeId,
        cacheEndNodeId
      ].sort();
      const pairKey = `${sortedStartId}->${sortedEndId}`;
      const pairIndex = connectionPairMap.get(pairKey) ?? 0;
      connectionPairMap.set(pairKey, pairIndex + 1);
      const cacheSpaceConnectionId = `${sortedStartId}->${sortedEndId}::${pairIndex}`;
      terminals[cacheSpaceConnectionId] = {
        start: sortedStartId,
        end: sortedEndId
      };
      cacheSpaceToRealConnectionId.set(
        cacheSpaceConnectionId,
        // Use the canonically sorted key
        conn.connectionName
      );
    }
    const cacheKeyContent = {
      node_capacity_map,
      node_edge_map,
      terminals
    };
    const cacheKey = `capacitypathing:${objectHash2(cacheKeyContent)}`;
    const cacheToSolveSpaceTransform = {
      cacheSpaceToRealConnectionId,
      cacheSpaceToRealNodeId: cacheSpaceToRealNodeIdMap
    };
    this.cacheKey = cacheKey;
    this.cacheToSolveSpaceTransform = cacheToSolveSpaceTransform;
    return { cacheKey, cacheToSolveSpaceTransform };
  }
  applyCachedSolution(cachedSolution) {
    if (!this.cacheToSolveSpaceTransform) {
      console.error(
        "Cache transform not available, cannot apply cached solution."
      );
      this.failed = true;
      return;
    }
    if (!cachedSolution.success) {
      this.failed = true;
      this.cacheHit = true;
      return;
    }
    this.cachedSectionConnectionTerminals = [];
    const { cacheSpaceToRealNodeId, cacheSpaceToRealConnectionId } = this.cacheToSolveSpaceTransform;
    for (const [cacheConnId, cachePathNodeIds] of Object.entries(
      cachedSolution.solutionPaths
    )) {
      const realConnectionName = cacheSpaceToRealConnectionId.get(
        cacheConnId
      );
      if (!realConnectionName) {
        console.warn(`Could not find real connection name for ${cacheConnId}`);
        continue;
      }
      const originalTerminal = this.constructorParams.sectionConnectionTerminals.find(
        (t) => t.connectionName === realConnectionName
      );
      if (!originalTerminal) {
        console.warn(
          `Could not find original terminal for connection name ${realConnectionName}`
        );
        continue;
      }
      const realPathNodes = cachePathNodeIds.map(
        (cacheNodeId) => {
          const realNodeId = cacheSpaceToRealNodeId.get(cacheNodeId);
          if (!realNodeId) {
            throw new Error(
              `Could not map cache node ID ${cacheNodeId} to real node ID for connection ${realConnectionName}`
            );
          }
          const node = this.constructorParams.nodeMap.get(realNodeId);
          if (!node) {
            throw new Error(
              `Could not find node with ID ${realNodeId} in nodeMap for connection ${realConnectionName}`
            );
          }
          return node;
        }
      );
      this.cachedSectionConnectionTerminals.push({
        ...originalTerminal,
        path: realPathNodes
      });
    }
    this.sectionScore = cachedSolution.sectionScore;
    this.solved = true;
    this.cacheHit = true;
  }
  attemptToUseCacheSync() {
    this.hasAttemptedToUseCache = true;
    if (!this.cacheProvider?.isSyncCache) {
      console.log(
        "Cache provider is not synchronous, skipping sync cache check."
      );
      return false;
    }
    if (!this.cacheKey) {
      this.computeCacheKeyAndTransform();
    }
    if (!this.cacheKey) {
      console.error("Failed to compute cache key.");
      return false;
    }
    try {
      const cachedSolution = this.cacheProvider.getCachedSolutionSync(
        this.cacheKey
      );
      if (cachedSolution) {
        this.applyCachedSolution(
          cachedSolution
        );
        return true;
      }
    } catch (error) {
      console.error("Error attempting to use cache:", error);
    }
    return false;
  }
  saveToCacheSync() {
    if (!this.cacheKey) {
      console.error("Cannot save to cache without cache key.");
      return;
    }
    if (!this.cacheToSolveSpaceTransform) {
      console.error(
        "Cache transform not available, cannot save solution to cache."
      );
      return;
    }
    let cachedSolution;
    if (this.failed) {
      cachedSolution = { success: false };
    } else if (this.solved) {
      const solutionPathsInCacheSpace = {};
      const { cacheSpaceToRealNodeId, cacheSpaceToRealConnectionId } = this.cacheToSolveSpaceTransform;
      const realToCacheSpaceNodeId = /* @__PURE__ */ new Map();
      for (const [cacheId, realId] of cacheSpaceToRealNodeId) {
        realToCacheSpaceNodeId.set(realId, cacheId);
      }
      const realToCacheSpaceConnectionId = /* @__PURE__ */ new Map();
      for (const [cacheConnId, realConnName] of cacheSpaceToRealConnectionId) {
        realToCacheSpaceConnectionId.set(realConnName, cacheConnId);
      }
      const realSolutionPaths = [];
      if (super.sectionConnectionTerminals) {
        for (const terminal of super.sectionConnectionTerminals) {
          if (terminal.path && terminal.path.length > 0) {
            const realPathNodeIds = terminal.path.map(
              (node) => node.capacityMeshNodeId
            );
            realSolutionPaths.push([terminal.connectionName, realPathNodeIds]);
          }
        }
      }
      for (const [realConnectionName, realPathNodeIds] of realSolutionPaths) {
        const cacheConnectionId = realToCacheSpaceConnectionId.get(realConnectionName);
        if (!cacheConnectionId) {
          console.warn(
            `Could not find cache space connection ID for ${realConnectionName} when saving to cache.`
          );
          continue;
        }
        const cachePathNodeIds = realPathNodeIds.map((realNodeId) => {
          const cacheNodeId = realToCacheSpaceNodeId.get(realNodeId);
          if (!cacheNodeId) {
            throw new Error(
              `Could not map real node ID ${realNodeId} to cache node ID for connection ${realConnectionName} when saving to cache.`
            );
          }
          return cacheNodeId;
        });
        solutionPathsInCacheSpace[cacheConnectionId] = cachePathNodeIds;
      }
      cachedSolution = {
        success: true,
        sectionScore: this.sectionScore,
        solutionPaths: solutionPathsInCacheSpace
      };
    } else {
      return;
    }
    try {
      this.cacheProvider?.setCachedSolutionSync(this.cacheKey, cachedSolution);
    } catch (error) {
      console.error("Error saving solution to cache:", error);
    }
  }
  get sectionConnectionTerminals() {
    if (this.cacheHit && this.solved && this.cachedSectionConnectionTerminals) {
      console.log("returning the cached section connection terminals");
      return this.cachedSectionConnectionTerminals;
    }
    return super.sectionConnectionTerminals;
  }
  visualize() {
    if (!this.cacheHit) return super.visualize();
    const graphics = visualizeSection({
      sectionNodes: this.constructorParams.sectionNodes,
      sectionEdges: this.constructorParams.sectionEdges,
      sectionConnectionTerminals: this.cachedSectionConnectionTerminals,
      completedPaths: this.cachedSectionConnectionTerminals.map((t) => ({
        connectionName: t.connectionName,
        path: t.path
      })),
      nodeMap: this.constructorParams.nodeMap,
      colorMap: this.constructorParams.colorMap,
      title: "CachedHyperCapacityPathingSingleSectionSolver"
    });
    return graphics;
  }
};

// lib/solvers/CapacityPathingSectionSolver/CapacityPathingMultiSectionSolver.ts
var CapacityPathingMultiSectionSolver = class extends BaseSolver {
  simpleRouteJson;
  nodes;
  edges;
  nodeEdgeMap;
  connectionsWithNodes = [];
  // Initialize here
  colorMap;
  initialSolver;
  cacheProvider;
  stage = "initialization";
  nodeMap = /* @__PURE__ */ new Map();
  allNodeIdsSet;
  usedNodeCapacityMap = /* @__PURE__ */ new Map();
  totalNodeCapacityMap = /* @__PURE__ */ new Map();
  // Added
  nodeCapacityPercentMap = /* @__PURE__ */ new Map();
  nodeOptimizationAttemptCountMap = /* @__PURE__ */ new Map();
  currentSection = null;
  sectionSolver = null;
  currentScheduleIndex = 0;
  stats;
  // Adjusting this schedule is a trade-off between optimization speed and quality.
  OPTIMIZATION_SCHEDULE = [
    {
      MAX_ATTEMPTS_PER_NODE: 1,
      MAX_EXPANSION_DEGREES: 3,
      MINIMUM_PROBABILITY_OF_FAILURE_TO_OPTIMIZE: 0.05
    },
    {
      MAX_ATTEMPTS_PER_NODE: 2,
      MAX_EXPANSION_DEGREES: 5,
      MINIMUM_PROBABILITY_OF_FAILURE_TO_OPTIMIZE: 0.2
    },
    {
      MAX_ATTEMPTS_PER_NODE: 3,
      MAX_EXPANSION_DEGREES: 7,
      MINIMUM_PROBABILITY_OF_FAILURE_TO_OPTIMIZE: 0.9
    }
  ];
  get currentSchedule() {
    return this.OPTIMIZATION_SCHEDULE[this.currentScheduleIndex] ?? null;
  }
  constructor(params) {
    super();
    this.stats = {
      successfulOptimizations: 0,
      failedOptimizations: 0,
      failedSectionSolvers: 0,
      startingScore: 0,
      scheduleScores: this.OPTIMIZATION_SCHEDULE.map(
        ({ MAX_EXPANSION_DEGREES }) => ({
          maxExpansionDegrees: MAX_EXPANSION_DEGREES,
          endingScore: 0,
          endingHighestNodePf: 0,
          sectionAttempts: 0
        })
      ),
      cacheHits: 0,
      cacheMisses: 0
    };
    this.MAX_ITERATIONS = params.MAX_ITERATIONS ?? 1e7;
    this.cacheProvider = params.cacheProvider;
    this.simpleRouteJson = params.simpleRouteJson;
    this.nodes = params.nodes;
    this.edges = params.edges;
    this.nodeEdgeMap = getNodeEdgeMap(this.edges);
    this.colorMap = params.colorMap ?? {};
    this.nodeMap = new Map(
      this.nodes.map((node) => [node.capacityMeshNodeId, node])
    );
    this.nodeEdgeMap = getNodeEdgeMap(this.edges);
    this.initialSolver = params.initialPathingSolver || new CapacityPathingGreedySolver({
      simpleRouteJson: this.simpleRouteJson,
      nodes: this.nodes,
      edges: this.edges,
      colorMap: this.colorMap
    });
    this.activeSubSolver = this.initialSolver;
    for (const node of this.nodes) {
      const totalCapacity = this.initialSolver.getTotalCapacity(node);
      this.totalNodeCapacityMap.set(node.capacityMeshNodeId, totalCapacity);
    }
    this.allNodeIdsSet = new Set(this.nodes.map((n) => n.capacityMeshNodeId));
  }
  _stepInitialization() {
    this.initialSolver?.step();
    if (this.initialSolver?.failed) {
      this.failed = true;
      this.error = this.initialSolver.error;
      return;
    }
    if (this.initialSolver?.solved) {
      this.usedNodeCapacityMap = new Map(this.initialSolver.usedNodeCapacityMap);
      for (const node of this.nodes) {
        const totalCapacity = this.totalNodeCapacityMap.get(node.capacityMeshNodeId) ?? 0;
        const usedCapacity = this.usedNodeCapacityMap.get(node.capacityMeshNodeId) ?? 0;
        const percentUsed = totalCapacity > 0 ? usedCapacity / totalCapacity : 0;
        this.nodeCapacityPercentMap.set(node.capacityMeshNodeId, percentUsed);
        this.nodeOptimizationAttemptCountMap.set(node.capacityMeshNodeId, 0);
      }
      this.connectionsWithNodes = this.initialSolver.connectionsWithNodes;
      this.stats.startingScore = computeSectionScore({
        totalNodeCapacityMap: this.totalNodeCapacityMap,
        usedNodeCapacityMap: this.usedNodeCapacityMap,
        nodeMap: this.nodeMap,
        sectionNodeIds: this.allNodeIdsSet
      });
      this.stage = "section-optimization";
    }
  }
  _getNextNodeToOptimize() {
    let highestNodePfDivAttempts = 0;
    let highestNodePf = 0;
    let nodeWithHighestPercentCapacityUsed = null;
    for (const node of this.nodes) {
      if (node._containsTarget) continue;
      const attemptCount = this.nodeOptimizationAttemptCountMap.get(
        node.capacityMeshNodeId
      );
      const totalCapacity = this.totalNodeCapacityMap.get(
        node.capacityMeshNodeId
      );
      const nodePf = calculateNodeProbabilityOfFailure2(
        this.usedNodeCapacityMap.get(node.capacityMeshNodeId) ?? 0,
        totalCapacity,
        node.availableZ.length
      );
      const nodePfDivAttempts = nodePf / (attemptCount + 1);
      if (attemptCount < this.currentSchedule.MAX_ATTEMPTS_PER_NODE && nodePfDivAttempts > highestNodePfDivAttempts && nodePf > this.currentSchedule.MINIMUM_PROBABILITY_OF_FAILURE_TO_OPTIMIZE) {
        highestNodePfDivAttempts = nodePfDivAttempts;
        highestNodePf = nodePf;
        nodeWithHighestPercentCapacityUsed = node.capacityMeshNodeId;
      }
    }
    return nodeWithHighestPercentCapacityUsed;
  }
  getOverallScore() {
    let highestNodePf = 0;
    for (const node of this.nodes) {
      if (node._containsTarget) continue;
      const totalCapacity = this.totalNodeCapacityMap.get(
        node.capacityMeshNodeId
      );
      const nodePf = calculateNodeProbabilityOfFailure2(
        this.usedNodeCapacityMap.get(node.capacityMeshNodeId) ?? 0,
        totalCapacity,
        node.availableZ.length
      );
      if (nodePf > highestNodePf) {
        highestNodePf = nodePf;
      }
    }
    return {
      highestNodePf,
      score: computeSectionScore({
        totalNodeCapacityMap: this.totalNodeCapacityMap,
        usedNodeCapacityMap: this.usedNodeCapacityMap,
        nodeMap: this.nodeMap,
        sectionNodeIds: this.allNodeIdsSet
      })
    };
  }
  _stepSectionOptimization() {
    if (!this.sectionSolver) {
      const centerNodeId = this._getNextNodeToOptimize();
      if (!centerNodeId) {
        const { highestNodePf, score } = this.getOverallScore();
        this.stats.scheduleScores[this.currentScheduleIndex].endingHighestNodePf = highestNodePf;
        this.stats.scheduleScores[this.currentScheduleIndex].endingScore = score;
        this.currentScheduleIndex++;
        if (!this.currentSchedule) {
          this.solved = true;
        }
        return;
      }
      const section = computeSectionNodesTerminalsAndEdges({
        centerNodeId,
        connectionsWithNodes: this.connectionsWithNodes,
        nodeMap: this.nodeMap,
        edges: this.edges,
        expansionDegrees: this.currentSchedule.MAX_EXPANSION_DEGREES,
        // Corrected
        nodeEdgeMap: this.nodeEdgeMap
      });
      this.stats.scheduleScores[this.currentScheduleIndex].sectionAttempts++;
      this.currentSection = section;
      this.sectionSolver = new CachedHyperCapacityPathingSingleSectionSolver({
        sectionNodes: this.currentSection.sectionNodes,
        sectionEdges: this.currentSection.sectionEdges,
        sectionConnectionTerminals: this.currentSection.sectionConnectionTerminals,
        colorMap: this.colorMap,
        centerNodeId: this.currentSection.centerNodeId,
        nodeEdgeMap: this.nodeEdgeMap,
        hyperParameters: {
          EXPANSION_DEGREES: this.currentSchedule.MAX_EXPANSION_DEGREES
        },
        cacheProvider: this.cacheProvider
      });
      this.activeSubSolver = this.sectionSolver;
      this.nodeOptimizationAttemptCountMap.set(
        centerNodeId,
        (this.nodeOptimizationAttemptCountMap.get(centerNodeId) ?? 0) + 1
      );
    }
    this.sectionSolver.step();
    if (this.sectionSolver.failed || this.sectionSolver.solved) {
      if (this.sectionSolver.cacheHit) {
        this.stats.cacheHits++;
      } else {
        this.stats.cacheMisses++;
      }
    }
    if (this.sectionSolver.failed) {
      console.warn(
        `Section solver failed for node ${this.currentSection.centerNodeId}. Error: ${this.sectionSolver.error}`
      );
      this.stats.failedSectionSolvers++;
      this.stats.failedOptimizations++;
      this.sectionSolver = null;
      this.activeSubSolver = null;
      return;
    }
    if (this.sectionSolver.solved) {
      const sectionConnectionTerminals = this.sectionSolver.sectionConnectionTerminals;
      const sectionNodes = this.sectionSolver.sectionNodes;
      const centerNodeId = this.sectionSolver.centerNodeId;
      this.sectionSolver = null;
      this.activeSubSolver = null;
      if (!sectionConnectionTerminals) {
        console.warn(
          `Pathing sub-solver for section ${this.currentSection.centerNodeId} did not complete successfully. Discarding results.`
        );
        return;
      }
      const sectionNodeIds = new Set(
        sectionNodes.map((n) => n.capacityMeshNodeId)
      );
      const beforeScore = computeSectionScore({
        totalNodeCapacityMap: this.totalNodeCapacityMap,
        usedNodeCapacityMap: this.usedNodeCapacityMap,
        nodeMap: this.nodeMap,
        sectionNodeIds
      });
      const afterUsedCapacityMap = new Map(this.usedNodeCapacityMap);
      const newSectionPaths = sectionConnectionTerminals;
      for (const terminal of newSectionPaths) {
        const originalConnection = this.connectionsWithNodes.find(
          (conn) => conn.connection.name === terminal.connectionName
        );
        if (originalConnection?.path) {
          for (const node of originalConnection.path) {
            if (sectionNodeIds.has(node.capacityMeshNodeId)) {
              const currentUsage = afterUsedCapacityMap.get(node.capacityMeshNodeId) ?? 0;
              afterUsedCapacityMap.set(
                node.capacityMeshNodeId,
                Math.max(0, currentUsage - 1)
              );
            }
          }
        }
      }
      for (const terminal of newSectionPaths) {
        if (terminal.path) {
          for (const node of terminal.path) {
            if (sectionNodeIds.has(node.capacityMeshNodeId)) {
              afterUsedCapacityMap.set(
                node.capacityMeshNodeId,
                (afterUsedCapacityMap.get(node.capacityMeshNodeId) ?? 0) + 1
              );
            }
          }
        }
      }
      const afterScore = computeSectionScore({
        totalNodeCapacityMap: this.totalNodeCapacityMap,
        usedNodeCapacityMap: afterUsedCapacityMap,
        nodeMap: this.nodeMap,
        sectionNodeIds
      });
      if (afterScore > beforeScore) {
        this.stats.successfulOptimizations++;
        this._mergeSolvedSectionPaths({
          centerNodeId,
          sectionConnectionTerminals
        });
        this._recalculateNodeCapacityUsage();
      } else {
        this.stats.failedOptimizations++;
      }
    }
  }
  /**
   * Merges the paths found by a successful section solver back into the main
   * connectionsWithNodes list.
   */
  _mergeSolvedSectionPaths({
    centerNodeId,
    sectionConnectionTerminals
  }) {
    for (const solvedTerminal of sectionConnectionTerminals) {
      if (!solvedTerminal.path) {
        console.warn(
          `No path found for connection ${solvedTerminal.connectionName} in section ${centerNodeId}`
        );
        continue;
      }
      const originalConnection = this.connectionsWithNodes.find(
        (conn) => conn.connection.name === solvedTerminal.connectionName
      );
      if (!originalConnection || !originalConnection.path) {
        console.warn(
          `Original connection or path not found for ${solvedTerminal.connectionName} while merging section ${centerNodeId}`
        );
        continue;
      }
      const originalPath = originalConnection.path;
      const newSectionPath = solvedTerminal.path;
      const startIndex = originalPath.findIndex(
        (node) => node.capacityMeshNodeId === solvedTerminal.startNodeId
      );
      const endIndex = originalPath.findIndex(
        (node) => node.capacityMeshNodeId === solvedTerminal.endNodeId
      );
      if (startIndex === -1 || endIndex === -1) {
        console.warn(
          `Could not find start/end nodes (${solvedTerminal.startNodeId}/${solvedTerminal.endNodeId}) in original path for ${solvedTerminal.connectionName}`
        );
        continue;
      }
      const [actualStartIndex, actualEndIndex] = startIndex <= endIndex ? [startIndex, endIndex] : [endIndex, startIndex];
      const pathBefore = originalPath.slice(0, actualStartIndex);
      const pathAfter = originalPath.slice(actualEndIndex + 1);
      let orientedNewSectionPath = newSectionPath;
      if (newSectionPath.length > 0 && originalPath[actualStartIndex] && // Check if node exists
      newSectionPath[0].capacityMeshNodeId !== originalPath[actualStartIndex].capacityMeshNodeId) {
        if (newSectionPath[newSectionPath.length - 1].capacityMeshNodeId === originalPath[actualStartIndex].capacityMeshNodeId) {
          orientedNewSectionPath = [...newSectionPath].reverse();
        } else {
          console.warn(
            `New section path for ${solvedTerminal.connectionName} doesn't align with original path boundaries. Skipping merge for this connection.`
          );
          continue;
        }
      }
      originalConnection.path = [
        ...pathBefore,
        ...orientedNewSectionPath,
        ...pathAfter
      ];
    }
  }
  /**
   * Recalculates node capacity usage based on the current connectionsWithNodes
   * and updates the nodeCapacityPercentMap.
   */
  _recalculateNodeCapacityUsage() {
    this.usedNodeCapacityMap.clear();
    for (const conn of this.connectionsWithNodes) {
      if (!conn.path) continue;
      for (const node of conn.path) {
        this.usedNodeCapacityMap.set(
          node.capacityMeshNodeId,
          (this.usedNodeCapacityMap.get(node.capacityMeshNodeId) ?? 0) + 1
        );
      }
    }
    for (const node of this.nodes) {
      const totalCapacity = this.totalNodeCapacityMap.get(node.capacityMeshNodeId) ?? 0;
      const usedCapacity = this.usedNodeCapacityMap.get(node.capacityMeshNodeId) ?? 0;
      const percentUsed = totalCapacity > 0 ? usedCapacity / totalCapacity : 0;
      this.nodeCapacityPercentMap.set(node.capacityMeshNodeId, percentUsed);
    }
  }
  getCapacityPaths() {
    const capacityPaths = [];
    for (const connection of this.connectionsWithNodes) {
      const path = connection.path;
      if (path) {
        capacityPaths.push({
          capacityPathId: connection.connection.name,
          connectionName: connection.connection.name,
          nodeIds: path.map((node) => node.capacityMeshNodeId)
        });
      }
    }
    return capacityPaths;
  }
  _step() {
    if (this.iterations >= this.MAX_ITERATIONS - 1) {
      this.solved = true;
      return;
    }
    if (this.stage === "initialization") {
      this._stepInitialization();
    } else if (this.stage === "section-optimization") {
      this._stepSectionOptimization();
    }
  }
  visualize() {
    const completedPathsForViz = this.connectionsWithNodes.filter((conn) => conn.path && conn.path.length > 0).map((conn) => ({
      connectionName: conn.connection.name,
      path: conn.path
      // Assert path exists due to filter
    }));
    return visualizeSection({
      nodeMap: this.nodeMap,
      // Still show terminals for context, even if paths are drawn separately
      sectionConnectionTerminals: this.connectionsWithNodes.map((conn) => ({
        connectionName: conn.connection.name,
        startNodeId: conn.path?.[0]?.capacityMeshNodeId,
        endNodeId: conn.path?.[conn.path.length - 1]?.capacityMeshNodeId
        // path: conn.path // Optionally pass the path here too if visualizeSection uses it for terminals
      })),
      completedPaths: completedPathsForViz,
      // Pass the final paths
      sectionNodes: this.nodes,
      sectionEdges: this.edges,
      colorMap: this.colorMap,
      totalCapacityMap: this.totalNodeCapacityMap,
      usedNodeCapacityMap: this.usedNodeCapacityMap,
      nodeOpacity: 0.05,
      title: "Capacity Pathing Multi-Section Solver (Solved)"
    });
  }
};

// lib/solvers/StrawSolver/StrawSolver.ts
var StrawSolver = class extends BaseSolver {
  multiLayerNodes;
  strawNodes;
  skippedNodes;
  unprocessedNodes;
  strawSize;
  nodeIdCounter;
  constructor(params) {
    super();
    this.MAX_ITERATIONS = 1e5;
    this.strawSize = params.strawSize ?? 0.5;
    this.multiLayerNodes = [];
    this.strawNodes = [];
    this.skippedNodes = [];
    this.nodeIdCounter = 0;
    this.unprocessedNodes = [];
    for (const node of params.nodes) {
      if (node.availableZ.length === 1) {
        this.unprocessedNodes.push(node);
      } else {
        this.multiLayerNodes.push(node);
      }
    }
  }
  getCapacityOfMultiLayerNodesWithinBounds(bounds) {
    let totalCapacity = 0;
    for (const node of this.multiLayerNodes) {
      const nodeMinX = node.center.x - node.width / 2;
      const nodeMaxX = node.center.x + node.width / 2;
      const nodeMinY = node.center.y - node.height / 2;
      const nodeMaxY = node.center.y + node.height / 2;
      const overlapMinX = Math.max(bounds.minX, nodeMinX);
      const overlapMaxX = Math.min(bounds.maxX, nodeMaxX);
      const overlapMinY = Math.max(bounds.minY, nodeMinY);
      const overlapMaxY = Math.min(bounds.maxY, nodeMaxY);
      if (overlapMinX < overlapMaxX && overlapMinY < overlapMaxY) {
        const overlapWidth = overlapMaxX - overlapMinX;
        const overlapHeight = overlapMaxY - overlapMinY;
        const overlapArea = overlapWidth * overlapHeight;
        const nodeArea = node.width * node.height;
        const proportion = overlapArea / nodeArea;
        totalCapacity += getTunedTotalCapacity1(node) * proportion;
      }
    }
    return totalCapacity;
  }
  getSurroundingCapacities(node) {
    const searchDistance = Math.min(node.width, node.height);
    const leftSurroundingCapacity = this.getCapacityOfMultiLayerNodesWithinBounds({
      minX: node.center.x - node.width / 2 - searchDistance,
      maxX: node.center.x - node.width / 2,
      minY: node.center.y - node.height / 2,
      maxY: node.center.y + node.height / 2
    });
    const rightSurroundingCapacity = this.getCapacityOfMultiLayerNodesWithinBounds({
      minX: node.center.x + node.width / 2,
      maxX: node.center.x + node.width / 2 + searchDistance,
      minY: node.center.y - node.height / 2,
      maxY: node.center.y + node.height / 2
    });
    const topSurroundingCapacity = this.getCapacityOfMultiLayerNodesWithinBounds({
      minX: node.center.x - node.width / 2,
      maxX: node.center.x + node.width / 2,
      minY: node.center.y - node.height / 2 - searchDistance,
      maxY: node.center.y - node.height / 2
    });
    const bottomSurroundingCapacity = this.getCapacityOfMultiLayerNodesWithinBounds({
      minX: node.center.x - node.width / 2,
      maxX: node.center.x + node.width / 2,
      minY: node.center.y + node.height / 2,
      maxY: node.center.y + node.height / 2 + searchDistance
    });
    return {
      leftSurroundingCapacity,
      rightSurroundingCapacity,
      topSurroundingCapacity,
      bottomSurroundingCapacity
    };
  }
  /**
   * Creates straw nodes from a single-layer node based on surrounding capacities
   */
  createStrawsForNode(node) {
    const result = [];
    const {
      leftSurroundingCapacity,
      rightSurroundingCapacity,
      topSurroundingCapacity,
      bottomSurroundingCapacity
    } = this.getSurroundingCapacities(node);
    const horizontalCapacity = leftSurroundingCapacity + rightSurroundingCapacity;
    const verticalCapacity = topSurroundingCapacity + bottomSurroundingCapacity;
    const layerPrefersFactor = 1;
    const effectiveHorizontalCapacity = horizontalCapacity * layerPrefersFactor;
    if (effectiveHorizontalCapacity > verticalCapacity) {
      const numStraws = Math.floor(node.height / this.strawSize);
      const strawHeight = node.height / numStraws;
      for (let i = 0; i < numStraws; i++) {
        const strawCenterY = node.center.y - node.height / 2 + i * strawHeight + strawHeight / 2;
        result.push({
          capacityMeshNodeId: `${node.capacityMeshNodeId}_straw${i}`,
          center: { x: node.center.x, y: strawCenterY },
          width: node.width,
          height: strawHeight,
          layer: node.layer,
          availableZ: [...node.availableZ],
          _depth: node._depth,
          _strawNode: true,
          _strawParentCapacityMeshNodeId: node.capacityMeshNodeId
        });
      }
    } else {
      const numStraws = Math.floor(node.width / this.strawSize);
      const strawWidth = node.width / numStraws;
      for (let i = 0; i < numStraws; i++) {
        const strawCenterX = node.center.x - node.width / 2 + i * strawWidth + strawWidth / 2;
        result.push({
          capacityMeshNodeId: `${node.capacityMeshNodeId}_straw${i}`,
          center: { x: strawCenterX, y: node.center.y },
          width: strawWidth,
          height: node.height,
          layer: node.layer,
          availableZ: [...node.availableZ],
          _depth: node._depth,
          _strawNode: true,
          _strawParentCapacityMeshNodeId: node.capacityMeshNodeId
        });
      }
    }
    return result;
  }
  getResultNodes() {
    return [...this.multiLayerNodes, ...this.strawNodes, ...this.skippedNodes];
  }
  _step() {
    const rootNode = this.unprocessedNodes.pop();
    if (!rootNode) {
      this.solved = true;
      return;
    }
    if (rootNode.width < this.strawSize && rootNode.height < this.strawSize) {
      this.skippedNodes.push(rootNode);
      return;
    }
    if (rootNode._containsTarget) {
      this.skippedNodes.push(rootNode);
      return;
    }
    const strawNodes = this.createStrawsForNode(rootNode);
    this.strawNodes.push(...strawNodes);
  }
  visualize() {
    const graphics = {
      rects: [],
      lines: [],
      points: [],
      circles: [],
      title: "Straw Solver"
    };
    for (const node of this.unprocessedNodes) {
      graphics.rects.push({
        center: node.center,
        width: node.width,
        height: node.height,
        fill: "rgba(200, 200, 200, 0.5)",
        stroke: "rgba(0, 0, 0, 0.5)",
        label: `${node.capacityMeshNodeId}
Unprocessed
${node.width}x${node.height}`
      });
    }
    for (const node of this.strawNodes) {
      const color = node.availableZ[0] === 0 ? "rgba(0, 150, 255, 0.5)" : "rgba(255, 100, 0, 0.5)";
      graphics.rects.push({
        center: node.center,
        width: node.width,
        height: node.height,
        fill: color,
        stroke: "rgba(0, 0, 0, 0.5)",
        label: `${node.capacityMeshNodeId}
Layer: ${node.availableZ[0]}
${node.width}x${node.height}`,
        layer: `z${node.availableZ.join(",")}`
      });
    }
    for (const node of this.multiLayerNodes) {
      graphics.rects.push({
        center: node.center,
        width: node.width * 0.9,
        height: node.height * 0.9,
        fill: "rgba(100, 255, 100, 0.5)",
        stroke: "rgba(0, 0, 0, 0.5)",
        layer: `z${node.availableZ.join(",")}`,
        label: `${node.capacityMeshNodeId}
Layers: ${node.availableZ.join(",")}
${node.width}x${node.height}`
      });
    }
    return graphics;
  }
};

// lib/utils/areNodesBordering.ts
function areNodesBordering(node1, node2) {
  const n1Left = node1.center.x - node1.width / 2;
  const n1Right = node1.center.x + node1.width / 2;
  const n1Top = node1.center.y - node1.height / 2;
  const n1Bottom = node1.center.y + node1.height / 2;
  const n2Left = node2.center.x - node2.width / 2;
  const n2Right = node2.center.x + node2.width / 2;
  const n2Top = node2.center.y - node2.height / 2;
  const n2Bottom = node2.center.y + node2.height / 2;
  const epsilon = 1e-3;
  const shareVerticalBorder = (Math.abs(n1Right - n2Left) < epsilon || Math.abs(n1Left - n2Right) < epsilon) && Math.min(n1Bottom, n2Bottom) - Math.max(n1Top, n2Top) >= epsilon;
  const shareHorizontalBorder = (Math.abs(n1Bottom - n2Top) < epsilon || Math.abs(n1Top - n2Bottom) < epsilon) && Math.min(n1Right, n2Right) - Math.max(n1Left, n2Left) >= epsilon;
  return shareVerticalBorder || shareHorizontalBorder;
}

// lib/data-structures/CapacityNodeTree.ts
var CapacityNodeTree = class {
  constructor(nodes) {
    this.nodes = nodes;
    this.buckets = /* @__PURE__ */ new Map();
    for (const node of nodes) {
      const nodeMinX = node.center.x - node.width / 2;
      const nodeMinY = node.center.y - node.height / 2;
      const nodeMaxX = node.center.x + node.width / 2;
      const nodeMaxY = node.center.y + node.height / 2;
      for (let x = nodeMinX; x <= nodeMaxX; x += this.CELL_SIZE) {
        for (let y = nodeMinY; y <= nodeMaxY; y += this.CELL_SIZE) {
          const bucketKey = this.getBucketKey(x, y);
          const bucket = this.buckets.get(bucketKey);
          if (!bucket) {
            this.buckets.set(bucketKey, [node]);
          } else {
            bucket.push(node);
          }
        }
      }
    }
  }
  buckets;
  CELL_SIZE = 0.4;
  getBucketKey(x, y) {
    return `${Math.floor(x / this.CELL_SIZE)}x${Math.floor(y / this.CELL_SIZE)}`;
  }
  getNodesInArea(centerX, centerY, width, height) {
    const nodes = [];
    const alreadyAddedNodes = /* @__PURE__ */ new Set();
    const minX = centerX - width / 2;
    const minY = centerY - height / 2;
    const maxX = centerX + width / 2;
    const maxY = centerY + height / 2;
    for (let x = minX; x <= maxX; x += this.CELL_SIZE) {
      for (let y = minY; y <= maxY; y += this.CELL_SIZE) {
        const bucketKey = this.getBucketKey(x, y);
        const bucket = this.buckets.get(bucketKey) || [];
        for (const node of bucket) {
          if (alreadyAddedNodes.has(node.capacityMeshNodeId)) continue;
          alreadyAddedNodes.add(node.capacityMeshNodeId);
          nodes.push(node);
        }
      }
    }
    return nodes;
  }
};

// lib/solvers/SingleLayerNodeMerger/SingleLayerNodeMergerSolver.ts
var EPSILON3 = 5e-3;
var SingleLayerNodeMergerSolver = class extends BaseSolver {
  nodeMap;
  currentBatchNodeIds;
  absorbedNodeIds;
  nextBatchNodeIds;
  batchHadModifications;
  hasComputedAdjacentNodeIds = false;
  newNodes;
  constructor(nodes) {
    super();
    this.nodeMap = /* @__PURE__ */ new Map();
    this.MAX_ITERATIONS = 1e5;
    for (const node of nodes) {
      this.nodeMap.set(node.capacityMeshNodeId, node);
    }
    this.newNodes = [];
    this.absorbedNodeIds = /* @__PURE__ */ new Set();
    const unprocessedNodesWithArea = [];
    for (const node of nodes) {
      if (node.availableZ.length > 1) {
        this.newNodes.push(node);
        this.absorbedNodeIds.add(node.capacityMeshNodeId);
      } else {
        unprocessedNodesWithArea.push([node, node.width * node.height]);
      }
    }
    unprocessedNodesWithArea.sort((a, b) => a[1] - b[1]);
    for (const [node, area] of unprocessedNodesWithArea) {
      const unprocessedNode = {
        ...node,
        center: { ...node.center }
      };
      this.nodeMap.set(node.capacityMeshNodeId, unprocessedNode);
    }
    this.currentBatchNodeIds = unprocessedNodesWithArea.map(
      ([node]) => node.capacityMeshNodeId
    );
    this.nextBatchNodeIds = [];
    this.batchHadModifications = false;
  }
  computeAdjacentNodeIdsForFirstBatch(nodes) {
    const nodeTrees = [
      new CapacityNodeTree(nodes.filter((n) => n.availableZ[0] === 0)),
      new CapacityNodeTree(nodes.filter((n) => n.availableZ[0] === 1))
    ];
    for (const node of nodes) {
      const adjacentNodes = [];
      const z = node.availableZ[0];
      const nodesInArea = nodeTrees[z].getNodesInArea(
        node.center.x,
        node.center.y,
        node.width * 4,
        node.height * 4
      );
      for (const unprocessedNode of nodesInArea) {
        if (unprocessedNode._containsTarget && unprocessedNode._targetConnectionName !== node._targetConnectionName)
          continue;
        if (unprocessedNode.capacityMeshNodeId === node.capacityMeshNodeId)
          continue;
        if (!areNodesBordering(node, unprocessedNode)) continue;
        adjacentNodes.push(unprocessedNode);
      }
      node._adjacentNodeIds = adjacentNodes.map((n) => n.capacityMeshNodeId);
    }
  }
  // getAdjacentSameLayerUnprocessedNodes1(rootNode: CapacityMeshNode) {
  //   const adjacentNodes: CapacityMeshNode[] = []
  //   for (const unprocessedNodeId of this.currentBatchNodeIds) {
  //     const unprocessedNode = this.nodeMap.get(unprocessedNodeId)!
  //     if (!areNodesBordering(rootNode, unprocessedNode)) continue
  //     if (unprocessedNode.availableZ[0] !== rootNode.availableZ[0]) continue
  //     if (
  //       unprocessedNode._containsTarget &&
  //       unprocessedNode._targetConnectionName !== rootNode._targetConnectionName
  //     )
  //       continue
  //     if (this.absorbedNodeIds.has(unprocessedNodeId)) continue
  //     adjacentNodes.push(unprocessedNode)
  //   }
  //   return adjacentNodes
  // }
  getAdjacentSameLayerUnprocessedNodes(rootNode) {
    return this.getAdjacentSameLayerUnprocessedNodes2(rootNode);
  }
  getAdjacentSameLayerUnprocessedNodes2(rootNode) {
    const adjacentNodes = [];
    const unprocessedAdjNodes = Array.from(
      new Set(
        (rootNode._adjacentNodeIds ?? []).map((a) => this.nodeMap.get(a))
      )
    );
    unprocessedAdjNodes.sort((a, b) => a.width * a.height - b.width * b.height);
    for (const unprocessedNode of unprocessedAdjNodes) {
      if (this.absorbedNodeIds.has(unprocessedNode.capacityMeshNodeId)) continue;
      adjacentNodes.push(unprocessedNode);
    }
    return adjacentNodes;
  }
  _step() {
    if (!this.hasComputedAdjacentNodeIds) {
      this.computeAdjacentNodeIdsForFirstBatch(
        this.currentBatchNodeIds.map((id) => this.nodeMap.get(id))
      );
      this.hasComputedAdjacentNodeIds = true;
    }
    let rootNodeId = this.currentBatchNodeIds.pop();
    while (rootNodeId && this.absorbedNodeIds.has(rootNodeId)) {
      rootNodeId = this.currentBatchNodeIds.pop();
    }
    if (!rootNodeId) {
      if (this.batchHadModifications) {
        this.currentBatchNodeIds = this.nextBatchNodeIds.sort((a, b) => {
          const A = this.nodeMap.get(a);
          const B = this.nodeMap.get(b);
          return A.width * A.height - B.width * B.height;
        });
        this.nextBatchNodeIds = [];
        this.batchHadModifications = false;
        return;
      }
      this.solved = true;
      this.newNodes.push(
        ...this.nextBatchNodeIds.map((id) => this.nodeMap.get(id))
      );
      return;
    }
    const rootNode = this.nodeMap.get(rootNodeId);
    let rootNodeHasGrown = false;
    const adjacentNodes = this.getAdjacentSameLayerUnprocessedNodes(rootNode);
    if (adjacentNodes.length === 0) {
      this.nextBatchNodeIds.push(rootNodeId);
      return;
    }
    const absorbAdjacentNodeIds = (nodesToAbsorb) => {
      for (const adjNode of nodesToAbsorb) {
        this.absorbedNodeIds.add(adjNode.capacityMeshNodeId);
      }
      rootNode._adjacentNodeIds = Array.from(
        new Set(
          [
            ...rootNode._adjacentNodeIds ?? [],
            ...nodesToAbsorb.flatMap((n) => n._adjacentNodeIds ?? [])
          ].filter((id) => !this.absorbedNodeIds.has(id))
        )
      );
    };
    const adjacentNodesToLeft = adjacentNodes.filter(
      (adjNode) => adjNode.center.x < rootNode.center.x && Math.abs(adjNode.center.y - rootNode.center.y) < rootNode.height / 2
    );
    if (adjacentNodesToLeft.length > 0) {
      const { width: leftAdjNodeWidth, height: leftAdjNodeHeight } = adjacentNodesToLeft[0];
      const leftAdjNodesAreAllSameSize = adjacentNodesToLeft.every(
        (adjNode) => adjNode.width === leftAdjNodeWidth && adjNode.height === leftAdjNodeHeight
      );
      const leftAdjNodesTakeUpEntireHeight = Math.abs(
        adjacentNodesToLeft.reduce((acc, adjNode) => {
          return acc + adjNode.height;
        }, 0) - rootNode.height
      ) < EPSILON3;
      if (leftAdjNodesTakeUpEntireHeight && leftAdjNodesAreAllSameSize) {
        rootNode.width += leftAdjNodeWidth;
        rootNode.center.x = rootNode.center.x - leftAdjNodeWidth / 2;
        absorbAdjacentNodeIds(adjacentNodesToLeft);
        rootNodeHasGrown = true;
      }
    }
    const adjacentNodesToRight = adjacentNodes.filter(
      (adjNode) => adjNode.center.x > rootNode.center.x && Math.abs(adjNode.center.y - rootNode.center.y) < rootNode.height / 2
    );
    if (adjacentNodesToRight.length > 0 && !rootNodeHasGrown) {
      const { width: rightAdjNodeWidth, height: rightAdjNodeHeight } = adjacentNodesToRight[0];
      const rightAdjNodesAreAllSameSize = adjacentNodesToRight.every(
        (adjNode) => adjNode.width === rightAdjNodeWidth && adjNode.height === rightAdjNodeHeight
      );
      const rightAdjNodesTakeUpEntireHeight = Math.abs(
        adjacentNodesToRight.reduce((acc, adjNode) => {
          return acc + adjNode.height;
        }, 0) - rootNode.height
      ) < EPSILON3;
      if (rightAdjNodesTakeUpEntireHeight && rightAdjNodesAreAllSameSize) {
        rootNode.width += rightAdjNodeWidth;
        rootNode.center.x = rootNode.center.x + rightAdjNodeWidth / 2;
        absorbAdjacentNodeIds(adjacentNodesToRight);
        rootNodeHasGrown = true;
      }
    }
    const adjacentNodesToTop = adjacentNodes.filter(
      (adjNode) => adjNode.center.y > rootNode.center.y && Math.abs(adjNode.center.x - rootNode.center.x) < rootNode.width / 2
    );
    if (adjacentNodesToTop.length > 0 && !rootNodeHasGrown) {
      const { width: topAdjNodeWidth, height: topAdjNodeHeight } = adjacentNodesToTop[0];
      const topAdjNodesAreAllSameSize = adjacentNodesToTop.every(
        (adjNode) => adjNode.width === topAdjNodeWidth && adjNode.height === topAdjNodeHeight
      );
      const topAdjNodesTakeUpEntireWidth = Math.abs(
        adjacentNodesToTop.reduce((acc, adjNode) => {
          return acc + adjNode.width;
        }, 0) - rootNode.width
      ) < EPSILON3;
      if (topAdjNodesTakeUpEntireWidth && topAdjNodesAreAllSameSize) {
        rootNode.height += topAdjNodeHeight;
        rootNode.center.y = rootNode.center.y + topAdjNodeHeight / 2;
        absorbAdjacentNodeIds(adjacentNodesToTop);
        rootNodeHasGrown = true;
      }
    }
    const adjacentNodesToBottom = adjacentNodes.filter(
      (adjNode) => adjNode.center.y < rootNode.center.y && Math.abs(adjNode.center.x - rootNode.center.x) < rootNode.width / 2
    );
    if (adjacentNodesToBottom.length > 0 && !rootNodeHasGrown) {
      const { width: bottomAdjNodeWidth, height: bottomAdjNodeHeight } = adjacentNodesToBottom[0];
      const bottomAdjNodesAreAllSameSize = adjacentNodesToBottom.every(
        (adjNode) => adjNode.width === bottomAdjNodeWidth && adjNode.height === bottomAdjNodeHeight
      );
      const bottomAdjNodesTakeUpEntireWidth = Math.abs(
        adjacentNodesToBottom.reduce((acc, adjNode) => {
          return acc + adjNode.width;
        }, 0) - rootNode.width
      ) < EPSILON3;
      if (bottomAdjNodesTakeUpEntireWidth && bottomAdjNodesAreAllSameSize) {
        rootNode.height += bottomAdjNodeHeight;
        rootNode.center.y = rootNode.center.y - bottomAdjNodeHeight / 2;
        absorbAdjacentNodeIds(adjacentNodesToBottom);
        rootNodeHasGrown = true;
      }
    }
    if (rootNodeHasGrown) {
      this.batchHadModifications = true;
      this.currentBatchNodeIds.push(rootNodeId);
    } else {
      this.nextBatchNodeIds.unshift(rootNodeId);
    }
  }
  visualize() {
    const graphics = {
      circles: [],
      lines: [],
      points: [],
      rects: [],
      coordinateSystem: "cartesian",
      title: "Same Layer Node Merger"
    };
    for (const node of this.newNodes) {
      graphics.rects.push(createRectFromCapacityNode(node));
    }
    const nextNodeIdInBatch = this.currentBatchNodeIds[this.currentBatchNodeIds.length - 1];
    let adjacentNodes;
    if (nextNodeIdInBatch) {
      adjacentNodes = this.getAdjacentSameLayerUnprocessedNodes(
        this.nodeMap.get(nextNodeIdInBatch)
      );
    }
    for (const nodeId of this.currentBatchNodeIds) {
      const node = this.nodeMap.get(nodeId);
      if (this.absorbedNodeIds.has(nodeId)) continue;
      if (node) {
        const rect = createRectFromCapacityNode(node, {
          rectMargin: 0.01
        });
        if (nodeId === nextNodeIdInBatch) {
          rect.stroke = "rgba(0, 255, 0, 0.8)";
        } else if (adjacentNodes?.some(
          (adjNode) => adjNode.capacityMeshNodeId === nodeId
        )) {
          rect.stroke = "rgba(128, 0, 128, 0.8)";
        } else {
          rect.stroke = "rgba(255, 165, 0, 0.8)";
        }
        rect.layer = `z${node.availableZ.join(",")}`;
        rect.label = `${rect.label}
(unprocessed)`;
        graphics.rects.push(rect);
      }
    }
    for (const nodeId of this.nextBatchNodeIds) {
      const node = this.nodeMap.get(nodeId);
      if (this.absorbedNodeIds.has(nodeId)) continue;
      if (node) {
        const rect = createRectFromCapacityNode(node, {
          rectMargin: 0.01
        });
        rect.layer = `z${node.availableZ.join(",")}`;
        rect.stroke = "rgba(0, 217, 255, 0.8)";
        rect.label = `${rect.label}
x: ${node.center.x}, y: ${node.center.y}
${node.width}x${node.height}
(next batch)`;
        graphics.rects.push(rect);
      }
    }
    return graphics;
  }
};

// lib/solvers/SimplifiedPathSolver/SingleSimplifiedPathSolver.ts
var SingleSimplifiedPathSolver = class extends BaseSolver {
  newRoute;
  newVias;
  headIndex = 0;
  tailIndex = 0;
  inputRoute;
  otherHdRoutes;
  obstacles;
  connMap;
  colorMap;
  constructor(params) {
    super();
    this.inputRoute = params.inputRoute;
    this.otherHdRoutes = params.otherHdRoutes;
    this.obstacles = params.obstacles;
    this.connMap = params.connMap;
    this.colorMap = params.colorMap;
    this.newRoute = [this.inputRoute.route[0]];
    this.newVias = [];
  }
  getConstructorParams() {
    return {
      inputRoute: this.inputRoute,
      otherHdRoutes: this.otherHdRoutes,
      obstacles: this.obstacles,
      connMap: this.connMap.netMap,
      colorMap: this.colorMap
    };
  }
  get simplifiedRoute() {
    return {
      connectionName: this.inputRoute.connectionName,
      traceThickness: this.inputRoute.traceThickness,
      viaDiameter: this.inputRoute.viaDiameter,
      route: this.newRoute,
      vias: this.newVias
    };
  }
  isValidPath(pointsInRoute) {
    throw new Error("Not implemented");
  }
  _step() {
    throw new Error("Not implemented");
  }
  getVisualsForNewRouteAndObstacles() {
    const graphics = {
      lines: [],
      points: [],
      circles: [],
      rects: [],
      coordinateSystem: "cartesian",
      title: "Simplified Path Solver"
    };
    for (let i = 0; i < this.inputRoute.route.length - 1; i++) {
      graphics.lines.push({
        points: [
          { x: this.inputRoute.route[i].x, y: this.inputRoute.route[i].y },
          {
            x: this.inputRoute.route[i + 1].x,
            y: this.inputRoute.route[i + 1].y
          }
        ],
        strokeColor: "rgba(255, 0, 0, 0.8)",
        strokeDash: this.inputRoute.route[i].z === 1 ? "5, 5" : void 0,
        layer: `z${this.inputRoute.route[i].z.toString()}`
      });
    }
    for (let i = 0; i < this.newRoute.length; i++) {
      if (i < this.newRoute.length - 1) {
        graphics.lines.push({
          points: [
            { x: this.newRoute[i].x, y: this.newRoute[i].y },
            { x: this.newRoute[i + 1].x, y: this.newRoute[i + 1].y }
          ],
          strokeWidth: 0.15,
          strokeColor: "rgba(0, 255, 0, 0.8)",
          strokeDash: this.newRoute[i].z === 1 ? [0.4, 0.4] : void 0,
          layer: `z${this.newRoute[i].z.toString()}`
        });
      }
      graphics.points.push({
        x: this.newRoute[i].x,
        y: this.newRoute[i].y,
        color: "rgba(0, 255, 0, 0.8)",
        label: `z: ${this.newRoute[i].z}`,
        layer: `z${this.newRoute[i].z.toString()}`
      });
    }
    for (const via of this.newVias) {
      graphics.circles.push({
        center: via,
        radius: this.inputRoute.viaDiameter / 2,
        fill: "rgba(0, 0, 255, 0.5)"
      });
    }
    for (const obstacle of this.obstacles) {
      graphics.rects.push({
        center: obstacle.center,
        width: obstacle.width,
        height: obstacle.height,
        fill: obstacle.layers?.includes("top") ? "rgba(255, 0, 0, 0.3)" : obstacle.layers?.includes("bottom") ? "rgba(0, 0, 255, 0.3)" : "rgba(128, 128, 128, 0.3)"
      });
    }
    for (const route of this.otherHdRoutes) {
      for (let i = 0; i < route.route.length - 1; i++) {
        graphics.lines.push({
          points: [
            { x: route.route[i].x, y: route.route[i].y },
            { x: route.route[i + 1].x, y: route.route[i + 1].y }
          ],
          strokeWidth: 0.15,
          strokeColor: route.route[i].z === 0 ? "rgba(255, 0, 255, 0.5)" : route.route[i].z === 1 ? "rgba(128, 0, 128, 0.5)" : "rgba(0, 0, 255, 0.5)",
          // bottom layer (blue)
          layer: `z${route.route[i].z.toString()}`
        });
      }
    }
    if ("filteredObstaclePathSegments" in this) {
      const filteredObstaclePathSegments = this.filteredObstaclePathSegments;
      for (const [start, end] of filteredObstaclePathSegments) {
        graphics.lines.push({
          points: [start, end]
        });
      }
    }
    return graphics;
  }
};

// lib/utils/calculate45DegreePaths.ts
var calculate45DegreePaths = (pointA, pointB) => {
  const result = [];
  const dx = Math.abs(pointB.x - pointA.x);
  const dy = Math.abs(pointB.y - pointA.y);
  const signX = pointB.x > pointA.x ? 1 : -1;
  const signY = pointB.y > pointA.y ? 1 : -1;
  const midPoint1 = {
    x: pointB.x - signX * Math.abs(pointB.y - pointA.y),
    y: pointA.y
  };
  if ((midPoint1.x - pointA.x) * signX >= 0 && (midPoint1.x - pointB.x) * signX <= 0) {
    result.push([pointA, midPoint1, pointB]);
  }
  const midPoint2 = {
    x: pointA.x,
    y: pointB.y - signY * Math.abs(pointB.x - pointA.x)
  };
  if ((midPoint2.y - pointA.y) * signY >= 0 && (midPoint2.y - pointB.y) * signY <= 0) {
    result.push([pointA, midPoint2, pointB]);
  }
  const minDist = Math.min(dx, dy);
  const midPoint3 = {
    x: pointA.x + signX * minDist,
    y: pointA.y + signY * minDist
  };
  if ((midPoint3.x - pointA.x) * signX >= 0 && (midPoint3.x - pointB.x) * signX <= 0 && (midPoint3.y - pointA.y) * signY >= 0 && (midPoint3.y - pointB.y) * signY <= 0) {
    result.push([pointA, midPoint3, pointB]);
  }
  return result;
};

// lib/utils/minimumDistanceBetweenSegments.ts
function minimumDistanceBetweenSegments(A1, A2, B1, B2) {
  if (segmentsIntersect(A1, A2, B1, B2)) {
    return 0;
  }
  const distA1 = pointToSegmentDistance6(A1, B1, B2);
  const distA2 = pointToSegmentDistance6(A2, B1, B2);
  const distB1 = pointToSegmentDistance6(B1, A1, A2);
  const distB2 = pointToSegmentDistance6(B2, A1, A2);
  return Math.min(distA1, distA2, distB1, distB2);
}
function pointToSegmentDistance6(P, Q1, Q2) {
  const v = { x: Q2.x - Q1.x, y: Q2.y - Q1.y };
  const w = { x: P.x - Q1.x, y: P.y - Q1.y };
  const c1 = dotProduct(w, v);
  if (c1 <= 0) {
    return distance5(P, Q1);
  }
  const c2 = dotProduct(v, v);
  if (c2 <= c1) {
    return distance5(P, Q2);
  }
  const b = c1 / c2;
  const Pb = {
    x: Q1.x + b * v.x,
    y: Q1.y + b * v.y
  };
  return distance5(P, Pb);
}
function dotProduct(v1, v2) {
  return v1.x * v2.x + v1.y * v2.y;
}
function distance5(p1, p2) {
  const dx = p2.x - p1.x;
  const dy = p2.y - p1.y;
  return Math.sqrt(dx * dx + dy * dy);
}
function orientation3(p, q, r) {
  const val = (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);
  if (val === 0) return 0;
  return val > 0 ? 1 : 2;
}
function onSegment3(p, q, r) {
  return q.x <= Math.max(p.x, r.x) && q.x >= Math.min(p.x, r.x) && q.y <= Math.max(p.y, r.y) && q.y >= Math.min(p.y, r.y);
}
function segmentsIntersect(A1, A2, B1, B2) {
  const o1 = orientation3(A1, A2, B1);
  const o2 = orientation3(A1, A2, B2);
  const o3 = orientation3(B1, B2, A1);
  const o4 = orientation3(B1, B2, A2);
  if (o1 !== o2 && o3 !== o4) return true;
  if (o1 === 0 && onSegment3(A1, B1, A2)) return true;
  if (o2 === 0 && onSegment3(A1, B2, A2)) return true;
  if (o3 === 0 && onSegment3(B1, A1, B2)) return true;
  if (o4 === 0 && onSegment3(B1, A2, B2)) return true;
  return false;
}

// lib/data-structures/SegmentTree.ts
var getSegmentBounds = (segment) => {
  return {
    minX: Math.min(segment[0].x, segment[1].x),
    maxX: Math.max(segment[0].x, segment[1].x),
    minY: Math.min(segment[0].y, segment[1].y),
    maxY: Math.max(segment[0].y, segment[1].y)
  };
};
var SegmentTree = class {
  // traceThickness + obstacleMargin
  constructor(segments) {
    this.segments = segments;
    this.buckets = /* @__PURE__ */ new Map();
    const segmentsById = /* @__PURE__ */ new Map();
    for (const segment of segments) {
      const segmentKey = this.getSegmentKey(segment);
      if (segmentsById.has(segmentKey)) continue;
      segmentsById.set(segmentKey, segment);
      const bounds = getSegmentBounds(segment);
      const minIndexX = Math.floor(bounds.minX / this.CELL_SIZE);
      const maxIndexX = Math.floor(bounds.maxX / this.CELL_SIZE);
      const minIndexY = Math.floor(bounds.minY / this.CELL_SIZE);
      const maxIndexY = Math.floor(bounds.maxY / this.CELL_SIZE);
      for (let ix = minIndexX; ix <= maxIndexX; ix++) {
        for (let iy = minIndexY; iy <= maxIndexY; iy++) {
          const bucketKey = `${ix}x${iy}`;
          const bucket = this.buckets.get(bucketKey);
          const segmentWithId = [
            segment[0],
            segment[1],
            segmentKey
          ];
          if (!bucket) {
            this.buckets.set(bucketKey, [segmentWithId]);
          } else {
            bucket.push(segmentWithId);
          }
        }
      }
    }
  }
  buckets;
  CELL_SIZE = 0.4;
  SEGMENT_MARGIN = 0.4;
  getBucketKey(x, y) {
    return `${Math.floor(x / this.CELL_SIZE)}x${Math.floor(y / this.CELL_SIZE)}`;
  }
  getSegmentKey(segment) {
    return `${segment[0].x}-${segment[0].y}-${segment[0].z}-${segment[1].x}-${segment[1].y}-${segment[1].z}`;
  }
  getSegmentsThatCouldIntersect(A, B) {
    const segments = [];
    const alreadyAddedSegments = /* @__PURE__ */ new Set();
    const minX = Math.min(A.x, B.x) - this.SEGMENT_MARGIN;
    const minY = Math.min(A.y, B.y) - this.SEGMENT_MARGIN;
    const maxX = Math.max(A.x, B.x) + this.SEGMENT_MARGIN;
    const maxY = Math.max(A.y, B.y) + this.SEGMENT_MARGIN;
    const minIndexX = Math.floor(minX / this.CELL_SIZE);
    const maxIndexX = Math.floor(maxX / this.CELL_SIZE);
    const minIndexY = Math.floor(minY / this.CELL_SIZE);
    const maxIndexY = Math.floor(maxY / this.CELL_SIZE);
    for (let ix = minIndexX; ix <= maxIndexX; ix++) {
      for (let iy = minIndexY; iy <= maxIndexY; iy++) {
        const bucketKey = `${ix}x${iy}`;
        const bucket = this.buckets.get(bucketKey);
        if (bucket) {
          for (const segment of bucket) {
            const key = segment[2];
            if (!alreadyAddedSegments.has(key)) {
              alreadyAddedSegments.add(key);
              segments.push(segment);
            }
          }
        }
      }
    }
    return segments;
  }
};

// lib/solvers/SimplifiedPathSolver/SingleSimplifiedPathSolver5_Deg45.ts
var SingleSimplifiedPathSolver5 = class extends SingleSimplifiedPathSolver {
  pathSegments = [];
  totalPathLength = 0;
  headDistanceAlongPath = 0;
  tailDistanceAlongPath = 0;
  minStepSize = 0.25;
  // Default step size, can be adjusted
  lastValidPath = null;
  // Store the current valid path
  lastValidPathHeadDistance = 0;
  /** Amount the step size is reduced when the step isn't possible */
  STEP_SIZE_REDUCTION_FACTOR = 0.25;
  maxStepSize = 4;
  currentStepSize = this.maxStepSize;
  lastHeadMoveDistance = 0;
  cachedValidPathSegments;
  filteredObstacles = [];
  filteredObstaclePathSegments = [];
  filteredVias = [];
  segmentTree;
  OBSTACLE_MARGIN = 0.1;
  TRACE_THICKNESS = 0.15;
  TAIL_JUMP_RATIO = 0.8;
  constructor(params) {
    super(params);
    this.cachedValidPathSegments = /* @__PURE__ */ new Set();
    if (this.inputRoute.route.length <= 1) {
      this.newRoute = [...this.inputRoute.route];
      this.solved = true;
      return;
    }
    const bounds = this.inputRoute.route.reduce(
      (acc, point) => {
        acc.minX = Math.min(acc.minX, point.x);
        acc.maxX = Math.max(acc.maxX, point.x);
        acc.minY = Math.min(acc.minY, point.y);
        acc.maxY = Math.max(acc.maxY, point.y);
        return acc;
      },
      { minX: Infinity, maxX: -Infinity, minY: Infinity, maxY: -Infinity }
    );
    const boundsBox = {
      center: {
        x: (bounds.minX + bounds.maxX) / 2,
        y: (bounds.minY + bounds.maxY) / 2
      },
      width: bounds.maxX - bounds.minX,
      height: bounds.maxY - bounds.minY
    };
    this.filteredObstacles = this.obstacles.filter(
      (obstacle) => !obstacle.connectedTo.some(
        (id) => this.connMap.areIdsConnected(this.inputRoute.connectionName, id)
      )
    ).filter((obstacle) => {
      if (obstacle.connectedTo.some(
        (obsId) => this.connMap.areIdsConnected(this.inputRoute.connectionName, obsId)
      )) {
        return false;
      }
      const { distance: distance6 } = computeDistanceBetweenBoxes(boundsBox, obstacle);
      if (distance6 < this.OBSTACLE_MARGIN + 0.5) {
        return true;
      }
      return false;
    });
    this.filteredObstaclePathSegments = this.otherHdRoutes.flatMap(
      (hdRoute) => {
        if (this.connMap.areIdsConnected(
          this.inputRoute.connectionName,
          hdRoute.connectionName
        )) {
          return [];
        }
        const route = hdRoute.route;
        const segments = [];
        for (let i = 0; i < route.length - 1; i++) {
          const start = route[i];
          const end = route[i + 1];
          const minX = Math.min(start.x, end.x);
          const maxX = Math.max(start.x, end.x);
          const minY = Math.min(start.y, end.y);
          const maxY = Math.max(start.y, end.y);
          if (minX <= bounds.maxX && maxX >= bounds.minX && minY <= bounds.maxY && maxY >= bounds.minY) {
            segments.push([start, end]);
          }
        }
        return segments;
      }
    );
    this.segmentTree = new SegmentTree(this.filteredObstaclePathSegments);
    this.filteredVias = this.otherHdRoutes.flatMap((hdRoute) => {
      if (this.connMap.areIdsConnected(
        this.inputRoute.connectionName,
        hdRoute.connectionName
      )) {
        return [];
      }
      const vias = hdRoute.vias;
      const filteredVias = [];
      for (const via of vias) {
        const margin = this.OBSTACLE_MARGIN + this.TRACE_THICKNESS / 2 + hdRoute.viaDiameter / 2;
        const minX = via.x - margin;
        const maxX = via.x + margin;
        const minY = via.y - margin;
        const maxY = via.y + margin;
        if (minX <= bounds.maxX && maxX >= bounds.minX && minY <= bounds.maxY && maxY >= bounds.minY) {
          filteredVias.push({ ...via, diameter: hdRoute.viaDiameter });
        }
      }
      return filteredVias;
    });
    this.computePathSegments();
  }
  // Compute the path segments and their distances
  computePathSegments() {
    let cumulativeDistance = 0;
    for (let i = 0; i < this.inputRoute.route.length - 1; i++) {
      const start = this.inputRoute.route[i];
      const end = this.inputRoute.route[i + 1];
      const length = Math.sqrt((end.x - start.x) ** 2 + (end.y - start.y) ** 2) + i / 1e4;
      this.pathSegments.push({
        start,
        end,
        length,
        startDistance: cumulativeDistance,
        endDistance: cumulativeDistance + length
      });
      cumulativeDistance += length;
    }
    this.totalPathLength = cumulativeDistance;
  }
  // Helper to check if two points are the same
  arePointsEqual(p1, p2) {
    return p1.x === p2.x && p1.y === p2.y && p1.z === p2.z;
  }
  // Get point at a specific distance along the path
  getPointAtDistance(distance6) {
    distance6 = Math.max(0, Math.min(distance6, this.totalPathLength));
    const segment = this.pathSegments.find(
      (seg) => distance6 >= seg.startDistance && distance6 <= seg.endDistance
    );
    if (!segment) {
      return this.inputRoute.route[this.inputRoute.route.length - 1];
    }
    const factor = (distance6 - segment.startDistance) / segment.length;
    return {
      x: segment.start.x + factor * (segment.end.x - segment.start.x),
      y: segment.start.y + factor * (segment.end.y - segment.start.y),
      z: factor < 0.5 ? segment.start.z : segment.end.z
      // Z doesn't interpolate - use the segment's start z value
    };
  }
  // Find nearest index in the original route for a given distance
  getNearestIndexForDistance(distance6) {
    if (distance6 <= 0) return 0;
    if (distance6 >= this.totalPathLength)
      return this.inputRoute.route.length - 1;
    const segmentIndex = this.pathSegments.findIndex(
      (seg) => distance6 >= seg.startDistance && distance6 <= seg.endDistance
    );
    if (segmentIndex === -1) return 0;
    const segment = this.pathSegments[segmentIndex];
    const midDistance = (segment.startDistance + segment.endDistance) / 2;
    return distance6 > midDistance ? segmentIndex + 1 : segmentIndex;
  }
  // Check if a path segment is valid
  isValidPathSegment(start, end) {
    for (const obstacle of this.filteredObstacles) {
      if (!obstacle.zLayers?.includes(start.z)) {
        continue;
      }
      const distToObstacle = segmentToBoxMinDistance(start, end, obstacle);
      if (distToObstacle < this.OBSTACLE_MARGIN + this.TRACE_THICKNESS / 2) {
        return false;
      }
    }
    const segmentsThatCouldIntersect = this.segmentTree.getSegmentsThatCouldIntersect(start, end);
    for (const [otherSegA, otherSegB, segId] of segmentsThatCouldIntersect) {
      if (otherSegA.z === start.z && otherSegB.z === start.z) {
        const distBetweenSegments = minimumDistanceBetweenSegments(
          { x: start.x, y: start.y },
          { x: end.x, y: end.y },
          { x: otherSegA.x, y: otherSegA.y },
          { x: otherSegB.x, y: otherSegB.y }
        );
        if (distBetweenSegments < this.OBSTACLE_MARGIN + this.TRACE_THICKNESS) {
          return false;
        }
      }
    }
    for (const via of this.filteredVias) {
      if (pointToSegmentDistance(via, start, end) < this.OBSTACLE_MARGIN + via.diameter / 2 + this.TRACE_THICKNESS / 2) {
        return false;
      }
    }
    return true;
  }
  // Check if a path with multiple points is valid
  isValidPath(pointsInRoute) {
    if (pointsInRoute.length < 2) return true;
    for (let i = 0; i < pointsInRoute.length - 1; i++) {
      if (pointsInRoute[i].z !== pointsInRoute[i + 1].z) {
        return false;
      }
    }
    for (let i = 0; i < pointsInRoute.length - 1; i++) {
      if (!this.isValidPathSegment(pointsInRoute[i], pointsInRoute[i + 1])) {
        return false;
      }
    }
    return true;
  }
  // Find a valid 45-degree path between two points
  find45DegreePath(start, end) {
    if (this.arePointsEqual(start, end)) {
      return [start];
    }
    if (start.z !== end.z) {
      return null;
    }
    const possiblePaths = calculate45DegreePaths(
      { x: start.x, y: start.y },
      { x: end.x, y: end.y }
    );
    for (const path of possiblePaths) {
      const fullPath = path.map((p) => ({ x: p.x, y: p.y, z: start.z }));
      if (this.isValidPath(fullPath)) {
        return fullPath;
      }
    }
    return null;
  }
  // Add a path to the result, skipping the first point if it's already added
  addPathToResult(path) {
    if (path.length === 0) return;
    for (let i = 0; i < path.length; i++) {
      if (i === 0 && this.newRoute.length > 0 && this.arePointsEqual(this.newRoute[this.newRoute.length - 1], path[i])) {
        continue;
      }
      this.newRoute.push(path[i]);
    }
    this.currentStepSize = this.maxStepSize;
  }
  moveHead(distance6) {
    this.lastHeadMoveDistance = distance6;
    this.headDistanceAlongPath = Math.min(
      this.headDistanceAlongPath + distance6,
      this.totalPathLength
    );
  }
  stepBackAndReduceStepSize() {
    this.headDistanceAlongPath = Math.max(
      this.tailDistanceAlongPath,
      this.headDistanceAlongPath - this.lastHeadMoveDistance
    );
    this.currentStepSize = Math.max(
      this.minStepSize,
      this.currentStepSize * this.STEP_SIZE_REDUCTION_FACTOR
    );
  }
  _step() {
    const tailHasReachedEnd = this.tailDistanceAlongPath >= this.totalPathLength;
    const headHasReachedEnd = this.headDistanceAlongPath >= this.totalPathLength;
    if (tailHasReachedEnd) {
      const lastPoint = this.inputRoute.route[this.inputRoute.route.length - 1];
      if (this.newRoute.length === 0 || !this.arePointsEqual(this.newRoute[this.newRoute.length - 1], lastPoint)) {
        this.newRoute.push(lastPoint);
      }
      this.solved = true;
      return;
    }
    if (headHasReachedEnd) {
      const tailPoint2 = this.getPointAtDistance(this.tailDistanceAlongPath);
      const endPoint = this.inputRoute.route[this.inputRoute.route.length - 1];
      const path452 = this.find45DegreePath(tailPoint2, endPoint);
      if (path452) {
        this.addPathToResult(path452);
        this.solved = true;
        return;
      } else {
        if (this.lastValidPath) {
          this.addPathToResult(this.lastValidPath);
          this.lastValidPath = null;
          this.tailDistanceAlongPath = this.lastValidPathHeadDistance;
        } else {
          this.newRoute.push(endPoint);
          this.solved = true;
        }
      }
    }
    this.moveHead(this.currentStepSize);
    const tailPoint = this.getPointAtDistance(this.tailDistanceAlongPath);
    const headPoint = this.getPointAtDistance(this.headDistanceAlongPath);
    const tailIndex = this.getNearestIndexForDistance(
      this.tailDistanceAlongPath
    );
    const headIndex = this.getNearestIndexForDistance(
      this.headDistanceAlongPath
    );
    let layerChangeBtwHeadAndTail = false;
    let layerChangeAtDistance = -1;
    for (let i = tailIndex; i < headIndex; i++) {
      if (i + 1 < this.inputRoute.route.length && this.inputRoute.route[i].z !== this.inputRoute.route[i + 1].z) {
        layerChangeBtwHeadAndTail = true;
        const changeSegmentIndex = i;
        layerChangeAtDistance = this.pathSegments[changeSegmentIndex].startDistance;
        break;
      }
    }
    if (layerChangeBtwHeadAndTail && this.lastHeadMoveDistance > this.minStepSize) {
      this.stepBackAndReduceStepSize();
      return;
    }
    if (layerChangeBtwHeadAndTail && layerChangeAtDistance > 0) {
      const indexAfterLayerChange = this.getNearestIndexForDistance(layerChangeAtDistance) + 1;
      const pointAfterChange = this.inputRoute.route[indexAfterLayerChange];
      const viaLocation = { x: pointAfterChange.x, y: pointAfterChange.y };
      if (this.lastValidPath) {
        this.addPathToResult(this.lastValidPath);
        this.lastValidPath = null;
      }
      const lastPointInNewRoute = this.newRoute[this.newRoute.length - 1];
      if (lastPointInNewRoute.x !== viaLocation.x || lastPointInNewRoute.y !== viaLocation.y) {
        this.newRoute.push({
          x: viaLocation.x,
          y: viaLocation.y,
          z: lastPointInNewRoute.z
          // Use the Z of the layer we are leaving
        });
      }
      this.newVias.push(viaLocation);
      this.newRoute.push({
        x: viaLocation.x,
        y: viaLocation.y,
        z: pointAfterChange.z
        // Use the Z of the layer we are entering
      });
      this.currentStepSize = this.maxStepSize;
      const segmentIndexAfterChange = this.pathSegments.findIndex(
        (seg) => seg.start === pointAfterChange
      );
      if (segmentIndexAfterChange !== -1) {
        this.tailDistanceAlongPath = this.pathSegments[segmentIndexAfterChange].startDistance;
        this.headDistanceAlongPath = this.tailDistanceAlongPath;
        this.lastValidPath = null;
        this.lastValidPathHeadDistance = this.tailDistanceAlongPath;
      } else if (indexAfterLayerChange < this.inputRoute.route.length) {
        console.warn(
          "Fallback used for tailDistanceAlongPath after layer change"
        );
        const segment = this.pathSegments.find(
          (seg) => seg.start === this.inputRoute.route[indexAfterLayerChange]
        );
        if (segment) {
          this.tailDistanceAlongPath = segment.startDistance;
          this.headDistanceAlongPath = this.tailDistanceAlongPath;
          this.lastValidPath = null;
          this.lastValidPathHeadDistance = this.tailDistanceAlongPath;
        } else {
          console.error(
            "Could not find segment start after layer change, path might be incomplete."
          );
          this.solved = true;
        }
      } else {
        console.warn("Layer change occurred at the end of the path.");
        this.solved = true;
      }
      return;
    }
    const path45 = this.find45DegreePath(tailPoint, headPoint);
    if (!path45 && this.lastHeadMoveDistance > this.minStepSize) {
      this.stepBackAndReduceStepSize();
      return;
    }
    if (!path45 && !this.lastValidPath) {
      const oldTailPoint = this.getPointAtDistance(this.tailDistanceAlongPath);
      this.tailDistanceAlongPath += this.minStepSize;
      this.moveHead(this.minStepSize);
      const newTailIndex = this.getNearestIndexForDistance(
        this.tailDistanceAlongPath
      );
      const newTailPoint = this.inputRoute.route[newTailIndex];
      const lastRoutePoint = this.inputRoute.route[this.inputRoute.route.length - 1];
      if (!this.arePointsEqual(oldTailPoint, newTailPoint) && !this.arePointsEqual(newTailPoint, lastRoutePoint)) {
        this.newRoute.push(newTailPoint);
      }
      return;
    }
    if (path45) {
      this.lastValidPath = path45;
      this.lastValidPathHeadDistance = this.headDistanceAlongPath;
      return;
    }
    if (this.lastValidPath) {
      this.addPathToResult(this.lastValidPath);
      this.lastValidPath = null;
      this.tailDistanceAlongPath = this.lastValidPathHeadDistance;
      this.moveHead(this.minStepSize);
    }
  }
  visualize() {
    const graphics = this.getVisualsForNewRouteAndObstacles();
    const tailPoint = this.getPointAtDistance(this.tailDistanceAlongPath);
    const headPoint = this.getPointAtDistance(this.headDistanceAlongPath);
    graphics.points.push({
      x: tailPoint.x,
      y: tailPoint.y,
      color: "yellow",
      label: ["Tail", `z: ${tailPoint.z}`].join("\n")
    });
    graphics.points.push({
      x: headPoint.x,
      y: headPoint.y,
      color: "orange",
      label: ["Head", `z: ${headPoint.z}`].join("\n")
    });
    const tentativeHead = this.getPointAtDistance(
      this.headDistanceAlongPath + this.currentStepSize
    );
    graphics.points.push({
      x: tentativeHead.x,
      y: tentativeHead.y,
      color: "red",
      label: ["Tentative Head", `z: ${tentativeHead.z}`].join("\n")
    });
    let distance6 = 0;
    while (distance6 < this.totalPathLength) {
      const point = this.getPointAtDistance(distance6);
      graphics.circles.push({
        center: {
          x: point.x,
          y: point.y
        },
        radius: 0.05,
        fill: "rgba(100, 100, 100, 0.5)"
      });
      distance6 += this.totalPathLength / 20;
    }
    if (this.lastValidPath && this.lastValidPath.length > 1) {
      for (let i = 0; i < this.lastValidPath.length - 1; i++) {
        graphics.lines.push({
          points: [
            { x: this.lastValidPath[i].x, y: this.lastValidPath[i].y },
            {
              x: this.lastValidPath[i + 1].x,
              y: this.lastValidPath[i + 1].y
            }
          ],
          strokeColor: "rgba(0, 255, 255, 0.9)",
          // Bright cyan
          strokeDash: "3, 3"
          // Dashed line to indicate it's a prospective path
        });
      }
    }
    return graphics;
  }
};

// lib/solvers/SimplifiedPathSolver/MultiSimplifiedPathSolver.ts
var MultiSimplifiedPathSolver = class extends BaseSolver {
  simplifiedHdRoutes;
  currentUnsimplifiedHdRouteIndex = 0;
  activeSubSolver = null;
  unsimplifiedHdRoutes;
  obstacles;
  connMap;
  colorMap;
  constructor(params) {
    super();
    this.MAX_ITERATIONS = 1e8;
    this.unsimplifiedHdRoutes = params.unsimplifiedHdRoutes;
    this.obstacles = params.obstacles;
    this.connMap = params.connMap || new ConnectivityMap({});
    this.colorMap = params.colorMap || {};
    this.simplifiedHdRoutes = [];
  }
  _step() {
    const hdRoute = this.unsimplifiedHdRoutes[this.currentUnsimplifiedHdRouteIndex];
    if (!this.activeSubSolver) {
      if (!hdRoute) {
        this.solved = true;
        return;
      }
      this.activeSubSolver = new SingleSimplifiedPathSolver5({
        inputRoute: hdRoute,
        otherHdRoutes: this.unsimplifiedHdRoutes.slice(this.currentUnsimplifiedHdRouteIndex + 1).concat(this.simplifiedHdRoutes),
        obstacles: this.obstacles,
        connMap: this.connMap,
        colorMap: this.colorMap
      });
      this.currentUnsimplifiedHdRouteIndex++;
      return;
    }
    this.activeSubSolver.step();
    if (this.activeSubSolver.solved) {
      this.simplifiedHdRoutes.push(this.activeSubSolver.simplifiedRoute);
      this.activeSubSolver = null;
    }
  }
  visualize() {
    if (this.activeSubSolver) {
      return this.activeSubSolver.visualize();
    }
    const graphics = {
      lines: [],
      points: [],
      circles: [],
      rects: [],
      coordinateSystem: "cartesian",
      title: "Multi Simplified Path Solver"
    };
    for (const route of this.unsimplifiedHdRoutes) {
      if (this.simplifiedHdRoutes.some(
        (r) => r.connectionName === route.connectionName
      )) {
        continue;
      }
      for (let i = 0; i < route.route.length - 1; i++) {
        graphics.lines.push({
          points: [
            { x: route.route[i].x, y: route.route[i].y },
            { x: route.route[i + 1].x, y: route.route[i + 1].y }
          ],
          strokeColor: route.route[i].z === 1 ? "rgba(0, 0, 255, 0.4)" : "rgba(255, 0, 0, 0.4)",
          strokeWidth: 0.15,
          strokeDash: route.route[i].z === 1 ? [0.5, 0.5] : void 0
        });
      }
      for (const via of route.vias || []) {
        graphics.circles.push({
          center: via,
          radius: route.viaDiameter / 2 || 0.3,
          // Default radius if viaDiameter not specified
          fill: "rgba(0, 0, 255, 0.4)"
        });
      }
    }
    for (const route of this.simplifiedHdRoutes) {
      const routeColor = this.colorMap?.[route.connectionName] || "rgba(128, 128, 128, 0.8)";
      for (let i = 0; i < route.route.length - 1; i++) {
        graphics.lines.push({
          points: [
            { x: route.route[i].x, y: route.route[i].y },
            { x: route.route[i + 1].x, y: route.route[i + 1].y }
          ],
          strokeWidth: 0.15,
          strokeColor: routeColor,
          strokeDash: route.route[i].z === 1 ? [0.5, 0.5] : void 0,
          step: 1
        });
      }
      for (const via of route.vias || []) {
        graphics.circles.push({
          center: via,
          radius: route.viaDiameter / 2,
          fill: "rgba(0, 0, 255, 0.5)",
          step: 1
        });
      }
    }
    for (const route of this.unsimplifiedHdRoutes) {
      for (let i = 0; i < route.route.length - 1; i++) {
        graphics.lines.push({
          points: [
            { x: route.route[i].x, y: route.route[i].y },
            { x: route.route[i + 1].x, y: route.route[i + 1].y }
          ],
          strokeWidth: 0.15,
          strokeColor: "rgba(255, 0, 0, 0.2)",
          strokeDash: [0.5, 0.5],
          step: 0,
          layer: `z${route.route[i].z.toString()}`
        });
      }
      for (const point of route.vias) {
        graphics.circles.push({
          center: { x: point.x, y: point.y },
          radius: route.viaDiameter / 2,
          fill: "rgba(255, 0, 0, 0.2)",
          step: 0
        });
      }
    }
    for (const obstacle of this.obstacles) {
      graphics.rects.push({
        center: obstacle.center,
        width: obstacle.width,
        height: obstacle.height,
        fill: obstacle.layers?.includes("top") ? "rgba(255, 0, 0, 0.3)" : obstacle.layers?.includes("bottom") ? "rgba(0, 0, 255, 0.3)" : "rgba(128, 128, 128, 0.3)"
      });
    }
    if (this.currentUnsimplifiedHdRouteIndex < this.unsimplifiedHdRoutes.length) {
      const currentRoute = this.unsimplifiedHdRoutes[this.currentUnsimplifiedHdRouteIndex];
      if (currentRoute.route.length > 0) {
        graphics.circles.push({
          center: {
            x: currentRoute.route[0].x,
            y: currentRoute.route[0].y
          },
          radius: 0.2,
          fill: "yellow",
          label: "Current"
        });
      }
    }
    return graphics;
  }
};

// lib/solvers/CapacityMeshSolver/CapacityMeshEdgeSolver.ts
var CapacityMeshEdgeSolver = class extends BaseSolver {
  constructor(nodes) {
    super();
    this.nodes = nodes;
    this.edges = [];
  }
  edges;
  /** Only used for visualization, dynamically instantiated if necessary */
  nodeMap;
  getNextCapacityMeshEdgeId() {
    return `ce${this.edges.length}`;
  }
  _step() {
    this.edges = [];
    for (let i = 0; i < this.nodes.length; i++) {
      for (let j = i + 1; j < this.nodes.length; j++) {
        const strawNodesWithSameParent = this.nodes[i]._strawNode && this.nodes[j]._strawNode && this.nodes[i]._strawParentCapacityMeshNodeId === this.nodes[j]._strawParentCapacityMeshNodeId;
        if (!strawNodesWithSameParent && areNodesBordering(this.nodes[i], this.nodes[j]) && this.doNodesHaveSharedLayer(this.nodes[i], this.nodes[j])) {
          this.edges.push({
            capacityMeshEdgeId: this.getNextCapacityMeshEdgeId(),
            nodeIds: [
              this.nodes[i].capacityMeshNodeId,
              this.nodes[j].capacityMeshNodeId
            ]
          });
        }
      }
    }
    this.handleTargetNodes();
    this.solved = true;
  }
  handleTargetNodes() {
    const targetNodes = this.nodes.filter((node) => node._containsTarget);
    for (const targetNode of targetNodes) {
      const hasEdge = this.edges.some(
        (edge) => edge.nodeIds.includes(targetNode.capacityMeshNodeId)
      );
      if (hasEdge) continue;
      let nearestNode = null;
      let nearestDistance = Infinity;
      for (const node of this.nodes) {
        if (node._containsObstacle) continue;
        if (node._containsTarget) continue;
        const dist = distance(targetNode.center, node.center);
        if (dist < nearestDistance) {
          nearestDistance = dist;
          nearestNode = node;
        }
      }
      if (nearestNode) {
        this.edges.push({
          capacityMeshEdgeId: this.getNextCapacityMeshEdgeId(),
          nodeIds: [
            targetNode.capacityMeshNodeId,
            nearestNode.capacityMeshNodeId
          ]
        });
      }
    }
  }
  doNodesHaveSharedLayer(node1, node2) {
    return node1.availableZ.some((z) => node2.availableZ.includes(z));
  }
  visualize() {
    const edgeCount = /* @__PURE__ */ new Map();
    for (const edge of this.edges) {
      for (const nodeId of edge.nodeIds) {
        edgeCount.set(nodeId, 1 + (edgeCount.get(nodeId) ?? 0));
      }
    }
    const graphics = {
      lines: [],
      points: [],
      rects: this.nodes.map((node) => {
        const lowestZ = Math.min(...node.availableZ);
        return {
          width: Math.max(node.width - 2, node.width * 0.8),
          height: Math.max(node.height - 2, node.height * 0.8),
          center: {
            x: node.center.x + lowestZ * node.width * 0.05,
            y: node.center.y - lowestZ * node.width * 0.05
          },
          fill: node._containsObstacle ? "rgba(255,0,0,0.1)" : {
            "0,1": "rgba(0,0,0,0.1)",
            "0": "rgba(0,200,200, 0.1)",
            "1": "rgba(0,0,200, 0.1)"
          }[node.availableZ.join(",")] ?? "rgba(0,200,200,0.1)",
          label: [
            node.capacityMeshNodeId,
            `availableZ: ${node.availableZ.join(",")}`,
            `target? ${node._containsTarget ?? false}`,
            `obs? ${node._containsObstacle ?? false}`,
            `conn: ${edgeCount.get(node.capacityMeshNodeId) ?? 0}`
          ].join("\n"),
          layer: `z${node.availableZ.join(",")}`
        };
      }),
      circles: []
    };
    if (!this.nodeMap) {
      this.nodeMap = /* @__PURE__ */ new Map();
      for (const node of this.nodes) {
        this.nodeMap.set(node.capacityMeshNodeId, node);
      }
    }
    for (const edge of this.edges) {
      const node1 = this.nodeMap.get(edge.nodeIds[0]);
      const node2 = this.nodeMap.get(edge.nodeIds[1]);
      if (node1?.center && node2?.center) {
        const lowestZ1 = Math.min(...node1.availableZ);
        const lowestZ2 = Math.min(...node2.availableZ);
        const nodeCenter1Adj = {
          x: node1.center.x + lowestZ1 * node1.width * 0.05,
          y: node1.center.y - lowestZ1 * node1.width * 0.05
        };
        const nodeCenter2Adj = {
          x: node2.center.x + lowestZ2 * node2.width * 0.05,
          y: node2.center.y - lowestZ2 * node2.width * 0.05
        };
        const availableZ = Array.from(
          /* @__PURE__ */ new Set([...node1.availableZ, ...node2.availableZ])
        ).sort();
        graphics.lines.push({
          layer: `z${availableZ.join(",")}`,
          points: [nodeCenter1Adj, nodeCenter2Adj],
          strokeDash: node1.availableZ.join(",") === node2.availableZ.join(",") ? void 0 : "10 5"
        });
      }
    }
    return graphics;
  }
};

// lib/solvers/CapacityMeshSolver/CapacityMeshEdgeSolver2_NodeTreeOptimization.ts
var CapacityMeshEdgeSolver2_NodeTreeOptimization = class extends CapacityMeshEdgeSolver {
  constructor(nodes) {
    super(nodes);
    this.nodes = nodes;
    this.MAX_ITERATIONS = 1e7;
    this.nodeTree = new CapacityNodeTree(this.nodes);
    this.currentNodeIndex = 0;
    this.edgeSet = /* @__PURE__ */ new Set();
  }
  nodeTree;
  currentNodeIndex;
  edgeSet;
  _step() {
    if (this.currentNodeIndex >= this.nodes.length) {
      this.handleTargetNodes();
      this.solved = true;
      return;
    }
    const A = this.nodes[this.currentNodeIndex];
    const maybeAdjNodes = this.nodeTree.getNodesInArea(
      A.center.x,
      A.center.y,
      A.width * 2,
      A.height * 2
    );
    for (const B of maybeAdjNodes) {
      const areBordering = areNodesBordering(A, B);
      if (!areBordering) continue;
      const strawNodesWithSameParent = A._strawNode && B._strawNode && A._strawParentCapacityMeshNodeId === B._strawParentCapacityMeshNodeId;
      if (A.capacityMeshNodeId !== B.capacityMeshNodeId && // Don't connect a node to itself
      !strawNodesWithSameParent && this.doNodesHaveSharedLayer(A, B) && !this.edgeSet.has(`${A.capacityMeshNodeId}-${B.capacityMeshNodeId}`)) {
        this.edgeSet.add(`${A.capacityMeshNodeId}-${B.capacityMeshNodeId}`);
        this.edgeSet.add(`${B.capacityMeshNodeId}-${A.capacityMeshNodeId}`);
        this.edges.push({
          capacityMeshEdgeId: this.getNextCapacityMeshEdgeId(),
          nodeIds: [A.capacityMeshNodeId, B.capacityMeshNodeId]
        });
      }
    }
    this.currentNodeIndex++;
  }
};

// lib/solvers/DeadEndSolver/DeadEndSolver.ts
var DeadEndSolver = class extends BaseSolver {
  removedNodeIds;
  targetNodeIds;
  leaves;
  leavesIndex;
  adjacencyList;
  /** Only used for visualization, dynamically instantiated if necessary */
  nodeMap;
  // Store the nodes and edges just for visualization purposes
  nodes;
  edges;
  constructor({
    nodes,
    edges
  }) {
    super();
    this.MAX_ITERATIONS = nodes.length;
    this.nodes = nodes;
    this.edges = edges;
    this.removedNodeIds = /* @__PURE__ */ new Set();
    this.targetNodeIds = new Set(
      nodes.filter((n) => n._containsTarget).map((n) => n.capacityMeshNodeId)
    );
    this.adjacencyList = new Map(
      nodes.map(({ capacityMeshNodeId }) => [capacityMeshNodeId, /* @__PURE__ */ new Set()])
    );
    for (const {
      nodeIds: [u, v]
    } of edges) {
      this.adjacencyList.get(u).add(v);
      this.adjacencyList.get(v).add(u);
    }
    this.leavesIndex = 0;
    this.leaves = [...this.adjacencyList.entries()].filter(([_, neighbours]) => neighbours.size === 1).filter(([nodeId, _]) => !this.targetNodeIds.has(nodeId)).map(([nodeId, _]) => nodeId);
  }
  _step() {
    if (this.leavesIndex === this.leaves.length) {
      this.solved = true;
      return;
    }
    const leaf = this.leaves[this.leavesIndex];
    const [neighbor] = this.adjacencyList.get(leaf);
    const neighborsOfLeafNeighbor = this.adjacencyList.get(neighbor);
    neighborsOfLeafNeighbor.delete(leaf);
    this.removedNodeIds.add(leaf);
    if (neighborsOfLeafNeighbor.size === 1 && !this.targetNodeIds.has(neighbor)) {
      this.leaves.push(neighbor);
    }
    this.leavesIndex += 1;
    if (this.leavesIndex === this.leaves.length) {
      this.solved = true;
    }
  }
  visualize() {
    if (!this.nodeMap) {
      this.nodeMap = /* @__PURE__ */ new Map();
      for (const node of this.nodes) {
        this.nodeMap.set(node.capacityMeshNodeId, node);
      }
    }
    const edgeCount = /* @__PURE__ */ new Map();
    for (const edge of this.edges) {
      for (const nodeId of edge.nodeIds) {
        edgeCount.set(nodeId, 1 + (edgeCount.get(nodeId) ?? 0));
      }
    }
    const graphics = {
      lines: [],
      points: [],
      rects: this.nodes.map((node) => {
        const lowestZ = Math.min(...node.availableZ);
        return {
          width: Math.max(node.width - 2, node.width * 0.8),
          height: Math.max(node.height - 2, node.height * 0.8),
          center: {
            x: node.center.x + lowestZ * node.width * 0.05,
            y: node.center.y - lowestZ * node.width * 0.05
          },
          fill: node._containsObstacle ? "rgba(255,0,0,0.1)" : {
            "0,1": "rgba(0,0,0,0.1)",
            "0": "rgba(0,200,200, 0.1)",
            "1": "rgba(0,0,200, 0.1)"
          }[node.availableZ.join(",")] ?? "rgba(0,200,200,0.1)",
          label: [
            node.capacityMeshNodeId,
            `availableZ: ${node.availableZ.join(",")}`,
            `target? ${node._containsTarget ?? false}`,
            `obs? ${node._containsObstacle ?? false}`,
            `conn: ${edgeCount.get(node.capacityMeshNodeId) ?? 0}`
          ].join("\n"),
          layer: `z${node.availableZ.join(",")}`
        };
      }),
      circles: []
    };
    for (const edge of this.edges) {
      const node1 = this.nodeMap.get(edge.nodeIds[0]);
      const node2 = this.nodeMap.get(edge.nodeIds[1]);
      if (node1?.center && node2?.center) {
        const lowestZ1 = Math.min(...node1.availableZ);
        const lowestZ2 = Math.min(...node2.availableZ);
        const nodeCenter1Adj = {
          x: node1.center.x + lowestZ1 * node1.width * 0.05,
          y: node1.center.y - lowestZ1 * node1.width * 0.05
        };
        const nodeCenter2Adj = {
          x: node2.center.x + lowestZ2 * node2.width * 0.05,
          y: node2.center.y - lowestZ2 * node2.width * 0.05
        };
        const availableZ = Array.from(
          /* @__PURE__ */ new Set([...node1.availableZ, ...node2.availableZ])
        ).sort();
        graphics.lines.push({
          layer: `z${availableZ.join(",")}`,
          points: [nodeCenter1Adj, nodeCenter2Adj],
          strokeDash: node1.availableZ.join(",") === node2.availableZ.join(",") ? void 0 : "10 5",
          strokeColor: edge.nodeIds.some(
            (nodeId) => this.removedNodeIds.has(nodeId)
          ) ? safeTransparentize("black", 0.9) : void 0
        });
      }
    }
    return graphics;
  }
};

// lib/data-structures/HighDensityRouteSpatialIndex.ts
var getSegmentBounds2 = (segment) => {
  return {
    minX: Math.min(segment[0].x, segment[1].x),
    maxX: Math.max(segment[0].x, segment[1].x),
    minY: Math.min(segment[0].y, segment[1].y),
    maxY: Math.max(segment[0].y, segment[1].y)
  };
};
function computeDistSq(p1, p2) {
  const dx = p1.x - p2.x;
  const dy = p1.y - p2.y;
  return dx * dx + dy * dy;
}
function pointToSegmentDistanceSq(p, a, b) {
  const l2 = computeDistSq(a, b);
  if (l2 === 0) return computeDistSq(p, a);
  let t = ((p.x - a.x) * (b.x - a.x) + (p.y - a.y) * (b.y - a.y)) / l2;
  t = Math.max(0, Math.min(1, t));
  const projection = {
    x: a.x + t * (b.x - a.x),
    y: a.y + t * (b.y - a.y)
  };
  return computeDistSq(p, projection);
}
function segmentToSegmentDistanceSq(a, b, c, d) {
  if (doSegmentsIntersect(a, b, c, d)) {
    return 0;
  }
  const pA = { x: a.x, y: a.y };
  const pB = { x: b.x, y: b.y };
  const pC = { x: c.x, y: c.y };
  const pD = { x: d.x, y: d.y };
  return Math.min(
    pointToSegmentDistanceSq(pA, pC, pD),
    pointToSegmentDistanceSq(pB, pC, pD),
    pointToSegmentDistanceSq(pC, pA, pB),
    pointToSegmentDistanceSq(pD, pA, pB)
  );
}
var HighDensityRouteSpatialIndex = class {
  segmentBuckets;
  viaBuckets;
  // New: Store vias
  routes;
  CELL_SIZE;
  constructor(routes, cellSize = 1) {
    this.segmentBuckets = /* @__PURE__ */ new Map();
    this.viaBuckets = /* @__PURE__ */ new Map();
    this.routes = /* @__PURE__ */ new Map();
    this.CELL_SIZE = cellSize;
    const epsilon = 1e-9;
    for (const route of routes) {
      if (!route || !route.connectionName) {
        console.warn("Skipping route with missing data:", route);
        continue;
      }
      if (this.routes.has(route.connectionName)) {
        console.warn(
          `Skipping duplicate route connectionName: ${route.connectionName}`
        );
        continue;
      }
      this.routes.set(route.connectionName, route);
      if (route.route && route.route.length >= 2) {
        for (let i = 0; i < route.route.length - 1; i++) {
          const p1 = route.route[i];
          const p2 = route.route[i + 1];
          if (p1.x === p2.x && p1.y === p2.y) continue;
          const segment = [p1, p2];
          const bounds = getSegmentBounds2(segment);
          const segmentInfo = {
            segmentId: `${route.connectionName}-seg-${i}`,
            segment,
            parentRoute: route
          };
          const minIndexX = Math.floor(bounds.minX / this.CELL_SIZE);
          const maxIndexX = Math.floor((bounds.maxX + epsilon) / this.CELL_SIZE);
          const minIndexY = Math.floor(bounds.minY / this.CELL_SIZE);
          const maxIndexY = Math.floor((bounds.maxY + epsilon) / this.CELL_SIZE);
          for (let ix = minIndexX; ix <= maxIndexX; ix++) {
            for (let iy = minIndexY; iy <= maxIndexY; iy++) {
              const bucketKey = `${ix}x${iy}`;
              let bucketList = this.segmentBuckets.get(bucketKey);
              if (!bucketList) {
                bucketList = [];
                this.segmentBuckets.set(bucketKey, bucketList);
              }
              bucketList.push(segmentInfo);
            }
          }
        }
      }
      if (route.vias && route.vias.length > 0) {
        for (let i = 0; i < route.vias.length; i++) {
          const via = route.vias[i];
          if (via === void 0 || via === null) continue;
          const storedVia = {
            viaId: `${route.connectionName}-via-${i}`,
            x: via.x,
            y: via.y,
            parentRoute: route
          };
          const ix = Math.floor(via.x / this.CELL_SIZE);
          const iy = Math.floor(via.y / this.CELL_SIZE);
          const bucketKey = `${ix}x${iy}`;
          let bucketList = this.viaBuckets.get(bucketKey);
          if (!bucketList) {
            bucketList = [];
            this.viaBuckets.set(bucketKey, bucketList);
          }
          bucketList.push(storedVia);
        }
      }
    }
  }
  /**
   * Finds routes that potentially conflict with a given line segment within a margin.
   * Checks both segments and vias.
   * @param segmentStart Start point of the query segment.
   * @param segmentEnd End point of the query segment.
   * @param margin The minimum required clearance distance from the query segment's centerline.
   * @returns An array of conflicting routes and their minimum distance to the segment.
   */
  getConflictingRoutesForSegment(segmentStart, segmentEnd, margin) {
    const querySegment = [segmentStart, segmentEnd];
    const bounds = getSegmentBounds2(querySegment);
    const searchMinX = bounds.minX - margin;
    const searchMinY = bounds.minY - margin;
    const searchMaxX = bounds.maxX + margin;
    const searchMaxY = bounds.maxY + margin;
    const epsilon = 1e-9;
    const minIndexX = Math.floor(searchMinX / this.CELL_SIZE);
    const maxIndexX = Math.floor((searchMaxX + epsilon) / this.CELL_SIZE);
    const minIndexY = Math.floor(searchMinY / this.CELL_SIZE);
    const maxIndexY = Math.floor((searchMaxY + epsilon) / this.CELL_SIZE);
    const conflictingRouteData = /* @__PURE__ */ new Map();
    const checkedSegments = /* @__PURE__ */ new Set();
    const checkedVias = /* @__PURE__ */ new Set();
    const queryP1 = { x: segmentStart.x, y: segmentStart.y };
    const queryP2 = { x: segmentEnd.x, y: segmentEnd.y };
    for (let ix = minIndexX; ix <= maxIndexX; ix++) {
      for (let iy = minIndexY; iy <= maxIndexY; iy++) {
        const bucketKey = `${ix}x${iy}`;
        const segmentBucketList = this.segmentBuckets.get(bucketKey);
        if (segmentBucketList) {
          for (const segmentInfo of segmentBucketList) {
            if (checkedSegments.has(segmentInfo.segmentId)) continue;
            checkedSegments.add(segmentInfo.segmentId);
            const route = segmentInfo.parentRoute;
            const [p1, p2] = segmentInfo.segment;
            const requiredSeparation = margin + route.traceThickness / 2;
            const requiredSeparationSq = requiredSeparation * requiredSeparation;
            const distSq3 = segmentToSegmentDistanceSq(
              segmentStart,
              segmentEnd,
              p1,
              p2
            );
            if (distSq3 < requiredSeparationSq) {
              const routeName = route.connectionName;
              const existing = conflictingRouteData.get(routeName);
              if (!existing || distSq3 < existing.minDistSq) {
                conflictingRouteData.set(routeName, {
                  route,
                  minDistSq: distSq3
                });
              }
            }
          }
        }
        const viaBucketList = this.viaBuckets.get(bucketKey);
        if (viaBucketList) {
          for (const viaInfo of viaBucketList) {
            if (checkedVias.has(viaInfo.viaId)) continue;
            checkedVias.add(viaInfo.viaId);
            const route = viaInfo.parentRoute;
            const viaPoint = { x: viaInfo.x, y: viaInfo.y };
            const requiredSeparation = margin + route.viaDiameter / 2;
            const requiredSeparationSq = requiredSeparation * requiredSeparation;
            const distSq3 = pointToSegmentDistanceSq(viaPoint, queryP1, queryP2);
            if (distSq3 < requiredSeparationSq) {
              const routeName = route.connectionName;
              const existing = conflictingRouteData.get(routeName);
              if (!existing || distSq3 < existing.minDistSq) {
                conflictingRouteData.set(routeName, {
                  route,
                  minDistSq: distSq3
                });
              }
            }
          }
        }
      }
    }
    const results = [];
    for (const data of conflictingRouteData.values()) {
      results.push({
        conflictingRoute: data.route,
        distance: Math.sqrt(data.minDistSq)
      });
    }
    return results;
  }
  /**
   * Finds routes that pass near a given point within a margin.
   * Checks both segments and vias.
   * @param point The query point {x, y}. Z is ignored.
   * @param margin The minimum required clearance distance from the query point.
   * @returns An array of conflicting routes and their minimum distance to the point.
   */
  getConflictingRoutesNearPoint(point, margin) {
    const searchMinX = point.x - margin;
    const searchMinY = point.y - margin;
    const searchMaxX = point.x + margin;
    const searchMaxY = point.y + margin;
    const epsilon = 1e-9;
    const minIndexX = Math.floor(searchMinX / this.CELL_SIZE);
    const maxIndexX = Math.floor((searchMaxX + epsilon) / this.CELL_SIZE);
    const minIndexY = Math.floor(searchMinY / this.CELL_SIZE);
    const maxIndexY = Math.floor((searchMaxY + epsilon) / this.CELL_SIZE);
    const conflictingRouteData = /* @__PURE__ */ new Map();
    const checkedSegments = /* @__PURE__ */ new Set();
    const checkedVias = /* @__PURE__ */ new Set();
    for (let ix = minIndexX; ix <= maxIndexX; ix++) {
      for (let iy = minIndexY; iy <= maxIndexY; iy++) {
        const bucketKey = `${ix}x${iy}`;
        const segmentBucketList = this.segmentBuckets.get(bucketKey);
        if (segmentBucketList) {
          for (const segmentInfo of segmentBucketList) {
            if (checkedSegments.has(segmentInfo.segmentId)) continue;
            checkedSegments.add(segmentInfo.segmentId);
            const route = segmentInfo.parentRoute;
            const p1 = {
              x: segmentInfo.segment[0].x,
              y: segmentInfo.segment[0].y
            };
            const p2 = {
              x: segmentInfo.segment[1].x,
              y: segmentInfo.segment[1].y
            };
            const requiredSeparation = margin + route.traceThickness / 2;
            const requiredSeparationSq = requiredSeparation * requiredSeparation;
            const distSq3 = pointToSegmentDistanceSq(point, p1, p2);
            if (distSq3 < requiredSeparationSq) {
              const routeName = route.connectionName;
              const existing = conflictingRouteData.get(routeName);
              if (!existing || distSq3 < existing.minDistSq) {
                conflictingRouteData.set(routeName, {
                  route,
                  minDistSq: distSq3
                });
              }
            }
          }
        }
        const viaBucketList = this.viaBuckets.get(bucketKey);
        if (viaBucketList) {
          for (const viaInfo of viaBucketList) {
            if (checkedVias.has(viaInfo.viaId)) continue;
            checkedVias.add(viaInfo.viaId);
            const route = viaInfo.parentRoute;
            const viaPoint = { x: viaInfo.x, y: viaInfo.y };
            const requiredSeparation = margin + route.viaDiameter / 2;
            const requiredSeparationSq = requiredSeparation * requiredSeparation;
            const distSq3 = computeDistSq(point, viaPoint);
            if (distSq3 < requiredSeparationSq) {
              const routeName = route.connectionName;
              const existing = conflictingRouteData.get(routeName);
              if (!existing || distSq3 < existing.minDistSq) {
                conflictingRouteData.set(routeName, {
                  route,
                  minDistSq: distSq3
                });
              }
            }
          }
        }
      }
    }
    const results = [];
    for (const data of conflictingRouteData.values()) {
      results.push({
        conflictingRoute: data.route,
        distance: Math.sqrt(data.minDistSq)
      });
    }
    return results;
  }
};

// lib/solvers/UselessViaRemovalSolver/SingleRouteUselessViaRemovalSolver.ts
var SingleRouteUselessViaRemovalSolver = class extends BaseSolver {
  obstacleSHI;
  hdRouteSHI;
  unsimplifiedRoute;
  routeSections;
  currentSectionIndex;
  TRACE_THICKNESS = 0.15;
  OBSTACLE_MARGIN = 0.1;
  constructor(params) {
    super();
    this.currentSectionIndex = 1;
    this.obstacleSHI = params.obstacleSHI;
    this.hdRouteSHI = params.hdRouteSHI;
    this.unsimplifiedRoute = params.unsimplifiedRoute;
    this.routeSections = this.breakRouteIntoSections(this.unsimplifiedRoute);
  }
  breakRouteIntoSections(route) {
    const routeSections = [];
    const routePoints = route.route;
    if (routePoints.length === 0) return [];
    let currentSection = {
      startIndex: 0,
      endIndex: -1,
      z: routePoints[0].z,
      points: [routePoints[0]]
    };
    for (let i = 1; i < routePoints.length; i++) {
      if (routePoints[i].z === currentSection.z) {
        currentSection.points.push(routePoints[i]);
      } else {
        currentSection.endIndex = i - 1;
        routeSections.push(currentSection);
        currentSection = {
          startIndex: i,
          endIndex: -1,
          z: routePoints[i].z,
          points: [routePoints[i]]
        };
      }
    }
    currentSection.endIndex = routePoints.length - 1;
    routeSections.push(currentSection);
    return routeSections;
  }
  _step() {
    if (this.currentSectionIndex >= this.routeSections.length - 1) {
      this.solved = true;
      return;
    }
    const prevSection = this.routeSections[this.currentSectionIndex - 1];
    const currentSection = this.routeSections[this.currentSectionIndex];
    const nextSection = this.routeSections[this.currentSectionIndex + 1];
    if (prevSection.z !== nextSection.z) {
      this.currentSectionIndex++;
      return;
    }
    const targetZ = prevSection.z;
    if (this.canSectionMoveToLayer({ currentSection, targetZ })) {
      currentSection.z = targetZ;
      currentSection.points = currentSection.points.map((p) => ({
        ...p,
        z: targetZ
      }));
      this.currentSectionIndex += 2;
      return;
    }
    this.currentSectionIndex++;
    return;
  }
  canSectionMoveToLayer({
    currentSection,
    targetZ
  }) {
    for (let i = 0; i < currentSection.points.length - 1; i++) {
      const A = { ...currentSection.points[i], z: targetZ };
      const B = { ...currentSection.points[i + 1], z: targetZ };
      const conflictingRoutes = this.hdRouteSHI.getConflictingRoutesForSegment(
        A,
        B,
        this.TRACE_THICKNESS
      );
      for (const { conflictingRoute, distance: distance6 } of conflictingRoutes) {
        if (conflictingRoute.connectionName === this.unsimplifiedRoute.connectionName)
          continue;
        if (distance6 < this.TRACE_THICKNESS + conflictingRoute.traceThickness) {
          return false;
        }
      }
      const segmentBox = {
        centerX: (A.x + B.x) / 2,
        centerY: (A.y + B.y) / 2,
        width: Math.abs(A.x - B.x),
        height: Math.abs(A.y - B.y)
      };
      const obstacles = this.obstacleSHI.searchArea(
        segmentBox.centerX,
        segmentBox.centerY,
        segmentBox.width + (this.TRACE_THICKNESS + this.OBSTACLE_MARGIN) * 2,
        // Expand search width
        segmentBox.height + (this.TRACE_THICKNESS + this.OBSTACLE_MARGIN) * 2
        // Expand search height
      );
      for (const obstacle of obstacles) {
        const distToObstacle = segmentToBoxMinDistance(A, B, obstacle);
        if (distToObstacle < this.TRACE_THICKNESS + this.OBSTACLE_MARGIN) {
          return false;
        }
      }
    }
    return true;
  }
  getConstructorParams() {
    return {
      obstacleSHI: this.obstacleSHI,
      hdRouteSHI: this.hdRouteSHI,
      unsimplifiedRoute: this.unsimplifiedRoute
    };
  }
  getOptimizedHdRoute() {
    const route = this.routeSections.flatMap((section) => section.points);
    const vias = [];
    for (let i = 0; i < route.length - 1; i++) {
      if (route[i].z !== route[i + 1].z) {
        vias.push({
          x: route[i].x,
          y: route[i].y
        });
      }
    }
    return {
      connectionName: this.unsimplifiedRoute.connectionName,
      route,
      traceThickness: this.unsimplifiedRoute.traceThickness,
      vias,
      viaDiameter: this.unsimplifiedRoute.viaDiameter
    };
  }
  visualize() {
    const graphics = {
      circles: [],
      lines: [],
      points: [],
      rects: [],
      coordinateSystem: "cartesian",
      title: "Single Route Useless Via Removal Solver"
    };
    for (let i = 0; i < this.routeSections.length; i++) {
      const section = this.routeSections[i];
      graphics.lines.push({
        points: section.points,
        strokeWidth: this.TRACE_THICKNESS,
        strokeColor: i === this.currentSectionIndex ? "orange" : section.z === 0 ? "red" : "blue"
      });
    }
    return graphics;
  }
};

// lib/solvers/UselessViaRemovalSolver/UselessViaRemovalSolver.ts
var UselessViaRemovalSolver = class extends BaseSolver {
  constructor(input) {
    super();
    this.input = input;
    this.MAX_ITERATIONS = 1e6;
    this.unsimplifiedHdRoutes = input.unsimplifiedHdRoutes;
    this.optimizedHdRoutes = [];
    this.unprocessedRoutes = [...input.unsimplifiedHdRoutes];
    this.obstacleSHI = new ObstacleSpatialHashIndex("flatbush", input.obstacles);
    this.hdRouteSHI = new HighDensityRouteSpatialIndex(
      this.unsimplifiedHdRoutes
    );
  }
  unsimplifiedHdRoutes;
  optimizedHdRoutes;
  unprocessedRoutes;
  activeSubSolver = null;
  obstacleSHI = null;
  hdRouteSHI = null;
  _step() {
    if (this.activeSubSolver) {
      this.activeSubSolver.step();
      if (this.activeSubSolver.solved) {
        this.optimizedHdRoutes.push(this.activeSubSolver.getOptimizedHdRoute());
        this.activeSubSolver = null;
      } else if (this.activeSubSolver.failed || this.activeSubSolver.error) {
        this.error = this.activeSubSolver.error;
        this.failed = true;
      }
      return;
    }
    const unprocessedRoute = this.unprocessedRoutes.shift();
    if (!unprocessedRoute) {
      this.solved = true;
      return;
    }
    this.activeSubSolver = new SingleRouteUselessViaRemovalSolver({
      hdRouteSHI: this.hdRouteSHI,
      obstacleSHI: this.obstacleSHI,
      unsimplifiedRoute: unprocessedRoute
    });
  }
  getOptimizedHdRoutes() {
    return this.optimizedHdRoutes;
  }
  visualize() {
    const visualization = {
      lines: [],
      points: [],
      rects: [],
      circles: [],
      coordinateSystem: "cartesian",
      title: "Useless Via Removal Solver"
    };
    for (const obstacle of this.input.obstacles) {
      let fillColor = "rgba(128, 128, 128, 0.2)";
      const strokeColor = "rgba(128, 128, 128, 0.5)";
      const isOnLayer0 = obstacle.zLayers?.includes(0);
      const isOnLayer1 = obstacle.zLayers?.includes(1);
      if (isOnLayer0 && isOnLayer1) {
        fillColor = "rgba(128, 0, 128, 0.2)";
      } else if (isOnLayer0) {
        fillColor = "rgba(255, 0, 0, 0.2)";
      } else if (isOnLayer1) {
        fillColor = "rgba(0, 0, 255, 0.2)";
      }
      visualization.rects.push({
        center: obstacle.center,
        width: obstacle.width,
        height: obstacle.height,
        fill: fillColor,
        label: `Obstacle (Z: ${obstacle.zLayers?.join(", ")})`
      });
    }
    for (const route of this.optimizedHdRoutes) {
      if (route.route.length === 0) continue;
      const color = this.input.colorMap[route.connectionName] || "#888888";
      for (let i = 0; i < route.route.length - 1; i++) {
        const current = route.route[i];
        const next = route.route[i + 1];
        if (current.z === next.z) {
          visualization.lines.push({
            points: [
              { x: current.x, y: current.y },
              { x: next.x, y: next.y }
            ],
            strokeColor: current.z === 0 ? "red" : "blue",
            strokeWidth: route.traceThickness,
            label: `${route.connectionName} (z=${current.z})`
          });
        }
      }
      for (const via of route.vias) {
        visualization.circles.push({
          center: { x: via.x, y: via.y },
          radius: route.viaDiameter / 2,
          fill: "rgba(255, 0, 255, 0.5)",
          label: `${route.connectionName} via`
        });
      }
    }
    if (this.activeSubSolver) {
      visualization.lines.push(
        ...this.activeSubSolver.visualize().lines ?? []
      );
    }
    return visualization;
  }
};

// lib/solvers/AutoroutingPipelineSolver.ts
function definePipelineStep(solverName, solverClass, getConstructorParams, opts = {}) {
  return {
    solverName,
    solverClass,
    getConstructorParams,
    onSolved: opts.onSolved
  };
}
var AutoroutingPipelineSolver = class extends BaseSolver {
  constructor(srj, opts = {}) {
    super();
    this.srj = srj;
    this.opts = opts;
    this.MAX_ITERATIONS = 1e8;
    if (opts.capacityDepth === void 0) {
      const boundsWidth = srj.bounds.maxX - srj.bounds.minX;
      const boundsHeight = srj.bounds.maxY - srj.bounds.minY;
      const maxWidthHeight = Math.max(boundsWidth, boundsHeight);
      const targetMinCapacity = opts.targetMinCapacity ?? 0.5;
      opts.capacityDepth = calculateOptimalCapacityDepth(
        maxWidthHeight,
        targetMinCapacity
      );
    }
    this.connMap = getConnectivityMapFromSimpleRouteJson(srj);
    this.colorMap = getColorMap(srj, this.connMap);
    this.cacheProvider = opts.cacheProvider === void 0 ? getGlobalInMemoryCache() : opts.cacheProvider === null ? null : opts.cacheProvider;
    this.startTimeOfPhase = {};
    this.endTimeOfPhase = {};
    this.timeSpentOnPhase = {};
  }
  netToPointPairsSolver;
  nodeSolver;
  nodeTargetMerger;
  edgeSolver;
  initialPathingSolver;
  pathingOptimizer;
  edgeToPortSegmentSolver;
  colorMap;
  segmentToPointSolver;
  unravelMultiSectionSolver;
  segmentToPointOptimizer;
  highDensityRouteSolver;
  highDensityStitchSolver;
  singleLayerNodeMerger;
  strawSolver;
  deadEndSolver;
  uselessViaRemovalSolver1;
  uselessViaRemovalSolver2;
  multiSimplifiedPathSolver1;
  multiSimplifiedPathSolver2;
  startTimeOfPhase;
  endTimeOfPhase;
  timeSpentOnPhase;
  activeSubSolver = null;
  connMap;
  srjWithPointPairs;
  capacityNodes = null;
  capacityEdges = null;
  cacheProvider = null;
  pipelineDef = [
    definePipelineStep(
      "netToPointPairsSolver",
      NetToPointPairsSolver,
      (cms) => [cms.srj, cms.colorMap],
      {
        onSolved: (cms) => {
          cms.srjWithPointPairs = cms.netToPointPairsSolver?.getNewSimpleRouteJson();
          cms.colorMap = getColorMap(cms.srjWithPointPairs, this.connMap);
          cms.connMap = getConnectivityMapFromSimpleRouteJson(
            cms.srjWithPointPairs
          );
        }
      }
    ),
    definePipelineStep(
      "nodeSolver",
      CapacityMeshNodeSolver2_NodeUnderObstacle,
      (cms) => [
        cms.netToPointPairsSolver?.getNewSimpleRouteJson() || cms.srj,
        cms.opts
      ],
      {
        onSolved: (cms) => {
          cms.capacityNodes = cms.nodeSolver?.finishedNodes;
        }
      }
    ),
    // definePipelineStep("nodeTargetMerger", CapacityNodeTargetMerger, (cms) => [
    //   cms.nodeSolver?.finishedNodes || [],
    //   cms.srj.obstacles,
    //   cms.connMap,
    // ]),
    // definePipelineStep("nodeTargetMerger", CapacityNodeTargetMerger2, (cms) => [
    //   cms.nodeSolver?.finishedNodes || [],
    //   cms.srj.obstacles,
    //   cms.connMap,
    //   cms.colorMap,
    //   cms.srj.connections,
    // ]),
    definePipelineStep(
      "singleLayerNodeMerger",
      SingleLayerNodeMergerSolver,
      (cms) => [cms.nodeSolver?.finishedNodes],
      {
        onSolved: (cms) => {
          cms.capacityNodes = cms.singleLayerNodeMerger?.newNodes;
        }
      }
    ),
    definePipelineStep(
      "strawSolver",
      StrawSolver,
      (cms) => [{ nodes: cms.singleLayerNodeMerger?.newNodes }],
      {
        onSolved: (cms) => {
          cms.capacityNodes = cms.strawSolver?.getResultNodes();
        }
      }
    ),
    definePipelineStep(
      "edgeSolver",
      CapacityMeshEdgeSolver2_NodeTreeOptimization,
      (cms) => [cms.capacityNodes],
      {
        onSolved: (cms) => {
          cms.capacityEdges = cms.edgeSolver?.edges;
        }
      }
    ),
    definePipelineStep(
      "deadEndSolver",
      DeadEndSolver,
      (cms) => [{ nodes: cms.capacityNodes, edges: cms.capacityEdges }],
      {
        onSolved: (cms) => {
          const removedNodeIds = cms.deadEndSolver?.removedNodeIds;
          cms.capacityNodes = cms.capacityNodes.filter(
            (n) => !removedNodeIds.has(n.capacityMeshNodeId)
          );
          cms.capacityEdges = cms.capacityEdges.filter(
            (e) => e.nodeIds.every((nodeId) => !removedNodeIds.has(nodeId))
          );
        }
      }
    ),
    definePipelineStep(
      "initialPathingSolver",
      CapacityPathingGreedySolver,
      (cms) => [
        {
          simpleRouteJson: cms.srjWithPointPairs,
          nodes: cms.capacityNodes,
          edges: cms.capacityEdges || [],
          colorMap: cms.colorMap,
          hyperParameters: {
            MAX_CAPACITY_FACTOR: 1
          }
        }
      ]
    ),
    definePipelineStep(
      "pathingOptimizer",
      // CapacityPathingSolver5,
      CapacityPathingMultiSectionSolver,
      (cms) => [
        // Replaced solver class
        {
          initialPathingSolver: cms.initialPathingSolver,
          simpleRouteJson: cms.srjWithPointPairs,
          nodes: cms.capacityNodes,
          edges: cms.capacityEdges || [],
          colorMap: cms.colorMap,
          cacheProvider: cms.cacheProvider,
          hyperParameters: {
            MAX_CAPACITY_FACTOR: 1
          }
        }
      ]
    ),
    definePipelineStep(
      "edgeToPortSegmentSolver",
      CapacityEdgeToPortSegmentSolver,
      (cms) => [
        {
          nodes: cms.capacityNodes,
          edges: cms.capacityEdges || [],
          capacityPaths: cms.pathingOptimizer?.getCapacityPaths() || [],
          colorMap: cms.colorMap
        }
      ]
    ),
    definePipelineStep(
      "segmentToPointSolver",
      CapacitySegmentToPointSolver,
      (cms) => {
        const allSegments = [];
        if (cms.edgeToPortSegmentSolver?.nodePortSegments) {
          cms.edgeToPortSegmentSolver.nodePortSegments.forEach((segs) => {
            allSegments.push(...segs);
          });
        }
        return [
          {
            segments: allSegments,
            colorMap: cms.colorMap,
            nodes: cms.capacityNodes
          }
        ];
      }
    ),
    // definePipelineStep(
    //   "segmentToPointOptimizer",
    //   CapacitySegmentPointOptimizer,
    //   (cms) => [
    //     {
    //       assignedSegments: cms.segmentToPointSolver?.solvedSegments || [],
    //       colorMap: cms.colorMap,
    //       nodes: cms.nodeTargetMerger?.newNodes || [],
    //     },
    //   ],
    // ),
    definePipelineStep(
      "unravelMultiSectionSolver",
      UnravelMultiSectionSolver,
      (cms) => [
        {
          assignedSegments: cms.segmentToPointSolver?.solvedSegments || [],
          colorMap: cms.colorMap,
          nodes: cms.capacityNodes,
          cacheProvider: this.cacheProvider
        }
      ]
    ),
    definePipelineStep("highDensityRouteSolver", HighDensitySolver, (cms) => [
      {
        nodePortPoints: cms.unravelMultiSectionSolver?.getNodesWithPortPoints() ?? cms.segmentToPointOptimizer?.getNodesWithPortPoints() ?? [],
        colorMap: cms.colorMap,
        connMap: cms.connMap
      }
    ]),
    definePipelineStep(
      "highDensityStitchSolver",
      MultipleHighDensityRouteStitchSolver,
      (cms) => [
        {
          connections: cms.srjWithPointPairs.connections,
          hdRoutes: cms.highDensityRouteSolver.routes,
          colorMap: cms.colorMap,
          layerCount: cms.srj.layerCount
        }
      ]
    ),
    definePipelineStep(
      "uselessViaRemovalSolver1",
      UselessViaRemovalSolver,
      (cms) => [
        {
          unsimplifiedHdRoutes: cms.highDensityStitchSolver.mergedHdRoutes,
          obstacles: cms.srj.obstacles,
          colorMap: cms.colorMap,
          layerCount: cms.srj.layerCount
        }
      ]
    ),
    definePipelineStep(
      "multiSimplifiedPathSolver1",
      MultiSimplifiedPathSolver,
      (cms) => [
        {
          unsimplifiedHdRoutes: cms.uselessViaRemovalSolver1?.getOptimizedHdRoutes() || cms.highDensityStitchSolver.mergedHdRoutes,
          obstacles: cms.srj.obstacles,
          connMap: cms.connMap,
          colorMap: cms.colorMap
        }
      ]
    ),
    definePipelineStep(
      "uselessViaRemovalSolver2",
      UselessViaRemovalSolver,
      (cms) => [
        {
          unsimplifiedHdRoutes: cms.multiSimplifiedPathSolver1.simplifiedHdRoutes,
          obstacles: cms.srj.obstacles,
          colorMap: cms.colorMap,
          layerCount: cms.srj.layerCount
        }
      ]
    ),
    definePipelineStep(
      "multiSimplifiedPathSolver2",
      MultiSimplifiedPathSolver,
      (cms) => [
        {
          unsimplifiedHdRoutes: cms.uselessViaRemovalSolver2?.getOptimizedHdRoutes(),
          obstacles: cms.srj.obstacles,
          connMap: cms.connMap,
          colorMap: cms.colorMap
        }
      ]
    )
  ];
  currentPipelineStepIndex = 0;
  _step() {
    const pipelineStepDef = this.pipelineDef[this.currentPipelineStepIndex];
    if (!pipelineStepDef) {
      this.solved = true;
      return;
    }
    if (this.activeSubSolver) {
      this.activeSubSolver.step();
      if (this.activeSubSolver.solved) {
        this.endTimeOfPhase[pipelineStepDef.solverName] = performance.now();
        this.timeSpentOnPhase[pipelineStepDef.solverName] = this.endTimeOfPhase[pipelineStepDef.solverName] - this.startTimeOfPhase[pipelineStepDef.solverName];
        pipelineStepDef.onSolved?.(this);
        this.activeSubSolver = null;
        this.currentPipelineStepIndex++;
      } else if (this.activeSubSolver.failed) {
        this.error = this.activeSubSolver?.error;
        this.failed = true;
        this.activeSubSolver = null;
      }
      return;
    }
    const constructorParams = pipelineStepDef.getConstructorParams(this);
    this.activeSubSolver = new pipelineStepDef.solverClass(...constructorParams);
    this[pipelineStepDef.solverName] = this.activeSubSolver;
    this.timeSpentOnPhase[pipelineStepDef.solverName] = 0;
    this.startTimeOfPhase[pipelineStepDef.solverName] = performance.now();
  }
  solveUntilPhase(phase) {
    while (this.getCurrentPhase() !== phase) {
      this.step();
    }
  }
  getCurrentPhase() {
    return this.pipelineDef[this.currentPipelineStepIndex]?.solverName ?? "none";
  }
  visualize() {
    if (!this.solved && this.activeSubSolver)
      return this.activeSubSolver.visualize();
    const netToPPSolver = this.netToPointPairsSolver?.visualize();
    const nodeViz = this.nodeSolver?.visualize();
    const nodeTargetMergerViz = this.nodeTargetMerger?.visualize();
    const singleLayerNodeMergerViz = this.singleLayerNodeMerger?.visualize();
    const strawSolverViz = this.strawSolver?.visualize();
    const edgeViz = this.edgeSolver?.visualize();
    const deadEndViz = this.deadEndSolver?.visualize();
    const initialPathingViz = this.initialPathingSolver?.visualize();
    const pathingOptimizerViz = this.pathingOptimizer?.visualize();
    const edgeToPortSegmentViz = this.edgeToPortSegmentSolver?.visualize();
    const segmentToPointViz = this.segmentToPointSolver?.visualize();
    const segmentOptimizationViz = this.unravelMultiSectionSolver?.visualize() ?? this.segmentToPointOptimizer?.visualize();
    const highDensityViz = this.highDensityRouteSolver?.visualize();
    const highDensityStitchViz = this.highDensityStitchSolver?.visualize();
    const uselessViaRemovalViz1 = this.uselessViaRemovalSolver1?.visualize();
    const uselessViaRemovalViz2 = this.uselessViaRemovalSolver2?.visualize();
    const simplifiedPathSolverViz1 = this.multiSimplifiedPathSolver1?.visualize();
    const simplifiedPathSolverViz2 = this.multiSimplifiedPathSolver2?.visualize();
    const problemViz = {
      points: [
        ...this.srj.connections.flatMap(
          (c) => c.pointsToConnect.map((p) => ({
            ...p,
            label: `${c.name} ${p.pcb_port_id ?? ""}`
          }))
        )
      ],
      rects: [
        ...(this.srj.obstacles ?? []).map((o) => ({
          ...o,
          fill: o.layers?.includes("top") ? "rgba(255,0,0,0.25)" : o.layers?.includes("bottom") ? "rgba(0,0,255,0.25)" : "rgba(255,0,0,0.25)",
          label: o.layers?.join(", ")
        }))
      ],
      lines: [
        {
          points: [
            // Add five points representing the bounds of the PCB
            {
              x: this.srj.bounds?.minX ?? -50,
              y: this.srj.bounds?.minY ?? -50
            },
            { x: this.srj.bounds?.maxX ?? 50, y: this.srj.bounds?.minY ?? -50 },
            { x: this.srj.bounds?.maxX ?? 50, y: this.srj.bounds?.maxY ?? 50 },
            { x: this.srj.bounds?.minX ?? -50, y: this.srj.bounds?.maxY ?? 50 },
            {
              x: this.srj.bounds?.minX ?? -50,
              y: this.srj.bounds?.minY ?? -50
            }
            // Close the rectangle
          ],
          strokeColor: "rgba(255,0,0,0.25)"
        }
      ]
    };
    const visualizations = [
      problemViz,
      netToPPSolver,
      nodeViz,
      nodeTargetMergerViz,
      singleLayerNodeMergerViz,
      strawSolverViz,
      edgeViz,
      deadEndViz,
      initialPathingViz,
      pathingOptimizerViz,
      edgeToPortSegmentViz,
      segmentToPointViz,
      segmentOptimizationViz,
      highDensityViz ? combineVisualizations(problemViz, highDensityViz) : null,
      highDensityStitchViz,
      uselessViaRemovalViz1,
      simplifiedPathSolverViz1,
      uselessViaRemovalViz2,
      simplifiedPathSolverViz2,
      this.solved ? combineVisualizations(
        problemViz,
        convertSrjToGraphicsObject(this.getOutputSimpleRouteJson())
      ) : null
    ].filter(Boolean);
    return combineVisualizations(...visualizations);
  }
  /**
   * A lightweight version of the visualize method that can be used to stream
   * progress
   *
   * We return the most relevant graphic for the stage:
   * 1. netToPointPairs output
   * 2. Capacity Planning Output
   * 3. High Density Route Solver Output, max 200 lines
   */
  preview() {
    if (this.highDensityRouteSolver) {
      const lines = [];
      for (let i = this.highDensityRouteSolver.routes.length - 1; i >= 0; i--) {
        const route = this.highDensityRouteSolver.routes[i];
        lines.push({
          points: route.route.map((n) => ({
            x: n.x,
            y: n.y
          })),
          strokeColor: this.colorMap[route.connectionName]
        });
        if (lines.length > 200) break;
      }
      return { lines };
    }
    if (this.pathingOptimizer) {
      const lines = [];
      for (const connection of this.pathingOptimizer.connectionsWithNodes) {
        if (!connection.path) continue;
        lines.push({
          points: connection.path.map((n) => ({
            x: n.center.x,
            y: n.center.y
          })),
          strokeColor: this.colorMap[connection.connection.name]
        });
      }
      return { lines };
    }
    if (this.netToPointPairsSolver) {
      return this.netToPointPairsSolver?.visualize();
    }
    return {};
  }
  /**
   * Get original connection name from connection name with MST suffix
   * @param mstConnectionName The MST-suffixed connection name (e.g. "connection1_mst0")
   * @returns The original connection name (e.g. "connection1")
   */
  getOriginalConnectionName(mstConnectionName) {
    const match = mstConnectionName.match(/^(.+?)_mst\d+$/);
    return match ? match[1] : mstConnectionName;
  }
  _getOutputHdRoutes() {
    return this.multiSimplifiedPathSolver2?.simplifiedHdRoutes ?? this.uselessViaRemovalSolver2?.getOptimizedHdRoutes() ?? this.multiSimplifiedPathSolver1?.simplifiedHdRoutes ?? this.uselessViaRemovalSolver1?.getOptimizedHdRoutes() ?? this.highDensityStitchSolver.mergedHdRoutes;
  }
  /**
   * Returns the SimpleRouteJson with routes converted to SimplifiedPcbTraces
   */
  getOutputSimplifiedPcbTraces() {
    if (!this.solved || !this.highDensityRouteSolver) {
      throw new Error("Cannot get output before solving is complete");
    }
    const traces = [];
    const allHdRoutes = this._getOutputHdRoutes();
    for (const connection of this.netToPointPairsSolver?.newConnections ?? []) {
      const netConnectionName = this.srj.connections.find(
        (c) => c.name === connection.name
      )?.netConnectionName;
      const hdRoutes = allHdRoutes.filter(
        (r) => r.connectionName === connection.name
      );
      for (let i = 0; i < hdRoutes.length; i++) {
        const hdRoute = hdRoutes[i];
        const simplifiedPcbTrace = {
          type: "pcb_trace",
          pcb_trace_id: `${connection.name}_${i}`,
          connection_name: netConnectionName ?? this.getOriginalConnectionName(connection.name),
          route: convertHdRouteToSimplifiedRoute(hdRoute, this.srj.layerCount)
        };
        traces.push(simplifiedPcbTrace);
      }
    }
    return traces;
  }
  getOutputSimpleRouteJson() {
    return {
      ...this.srj,
      traces: this.getOutputSimplifiedPcbTraces()
    };
  }
};
var CapacityMeshSolver = AutoroutingPipelineSolver;
export {
  CapacityMeshSolver,
  InMemoryCache,
  LocalStorageCache,
  calculateOptimalCapacityDepth,
  convertSrjToGraphicsObject,
  getGlobalInMemoryCache,
  getGlobalLocalStorageCache,
  getTunedTotalCapacity1,
  setupGlobalCaches
};
//# sourceMappingURL=index.js.map