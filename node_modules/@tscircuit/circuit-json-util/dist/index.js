// lib/cju.ts
import * as Soup from "circuit-json";

// lib/subtree.ts
function connect(map, a, b) {
  if (!a || !b)
    return;
  let setA = map.get(a);
  if (!setA) {
    setA = /* @__PURE__ */ new Set();
    map.set(a, setA);
  }
  setA.add(b);
  let setB = map.get(b);
  if (!setB) {
    setB = /* @__PURE__ */ new Set();
    map.set(b, setB);
  }
  setB.add(a);
}
function buildSubtree(soup, opts) {
  if (!opts.subcircuit_id && !opts.source_group_id)
    return [...soup];
  const idMap = /* @__PURE__ */ new Map();
  for (const elm of soup) {
    const idVal = elm[`${elm.type}_id`];
    if (typeof idVal === "string") {
      idMap.set(idVal, elm);
    }
  }
  const adj = /* @__PURE__ */ new Map();
  for (const elm of soup) {
    const entries = Object.entries(elm);
    for (const [key, val] of entries) {
      if (key === "parent_source_group_id")
        continue;
      if (key.endsWith("_id") && typeof val === "string") {
        const other = idMap.get(val);
        connect(adj, elm, other);
      } else if (key.endsWith("_ids") && Array.isArray(val)) {
        for (const v of val) {
          if (typeof v === "string") {
            const other = idMap.get(v);
            connect(adj, elm, other);
          }
        }
      }
    }
  }
  const queue = [];
  const included = /* @__PURE__ */ new Set();
  for (const elm of soup) {
    if (opts.subcircuit_id && elm.subcircuit_id === opts.subcircuit_id || opts.source_group_id && (elm.source_group_id === opts.source_group_id || Array.isArray(elm.member_source_group_ids) && elm.member_source_group_ids.includes(
      opts.source_group_id
    ))) {
      queue.push(elm);
      included.add(elm);
    }
  }
  while (queue.length > 0) {
    const elm = queue.shift();
    const neighbors = adj.get(elm);
    if (!neighbors)
      continue;
    for (const n of neighbors) {
      if (!included.has(n)) {
        included.add(n);
        queue.push(n);
      }
    }
  }
  return soup.filter((e) => included.has(e));
}

// lib/cju.ts
var cju = (circuitJsonInput, options = {}) => {
  const circuitJson = circuitJsonInput;
  let internalStore = circuitJson._internal_store;
  if (!internalStore) {
    internalStore = {
      counts: {},
      editCount: 0
    };
    circuitJson._internal_store = internalStore;
    for (const elm of circuitJson) {
      const type = elm.type;
      const idVal = elm[`${type}_id`];
      if (!idVal)
        continue;
      const idNum = Number.parseInt(idVal.split("_").pop());
      if (!Number.isNaN(idNum)) {
        internalStore.counts[type] = Math.max(
          internalStore.counts[type] ?? 0,
          idNum
        );
      }
    }
  }
  const su2 = new Proxy(
    {},
    {
      get: (proxy_target, prop) => {
        if (prop === "toArray") {
          return () => {
            ;
            circuitJson.editCount = internalStore.editCount;
            return circuitJson;
          };
        }
        if (prop === "editCount") {
          return internalStore.editCount;
        }
        if (prop === "subtree") {
          return (opts) => cju(buildSubtree(circuitJson, opts), options);
        }
        const component_type = prop;
        return {
          get: (id) => circuitJson.find(
            (e) => e.type === component_type && e[`${component_type}_id`] === id
          ),
          getUsing: (using) => {
            const keys = Object.keys(using);
            if (keys.length !== 1) {
              throw new Error(
                "getUsing requires exactly one key, e.g. { pcb_component_id }"
              );
            }
            const join_key = keys[0];
            const join_type = join_key.replace("_id", "");
            const joiner = circuitJson.find(
              (e) => e.type === join_type && e[join_key] === using[join_key]
            );
            if (!joiner)
              return null;
            return circuitJson.find(
              (e) => e.type === component_type && e[`${component_type}_id`] === joiner[`${component_type}_id`]
            );
          },
          getWhere: (where) => {
            const keys = Object.keys(where);
            return circuitJson.find(
              (e) => e.type === component_type && keys.every((key) => e[key] === where[key])
            );
          },
          list: (where) => {
            const keys = !where ? [] : Object.keys(where);
            return circuitJson.filter(
              (e) => e.type === component_type && keys.every((key) => e[key] === where[key])
            );
          },
          insert: (elm) => {
            internalStore.counts[component_type] ??= -1;
            internalStore.counts[component_type]++;
            const index = internalStore.counts[component_type];
            const newElm = {
              type: component_type,
              [`${component_type}_id`]: `${component_type}_${index}`,
              ...elm
            };
            if (options.validateInserts) {
              const parser = Soup[component_type] ?? Soup.any_soup_element;
              parser.parse(newElm);
            }
            circuitJson.push(newElm);
            internalStore.editCount++;
            return newElm;
          },
          delete: (id) => {
            const elm = circuitJson.find(
              (e) => e[`${component_type}_id`] === id
            );
            if (!elm)
              return;
            circuitJson.splice(circuitJson.indexOf(elm), 1);
            internalStore.editCount++;
          },
          update: (id, newProps) => {
            const elm = circuitJson.find(
              (e) => e.type === component_type && e[`${component_type}_id`] === id
            );
            if (!elm)
              return null;
            Object.assign(elm, newProps);
            internalStore.editCount++;
            return elm;
          },
          select: (selector) => {
            if (component_type === "source_component") {
              return circuitJson.find(
                (e) => e.type === "source_component" && e.name === selector.replace(/\./g, "")
              );
            } else if (component_type === "pcb_port" || component_type === "source_port" || component_type === "schematic_port") {
              const [component_name, port_selector] = selector.replace(/\./g, "").split(/[\s\>]+/);
              const source_component = circuitJson.find(
                (e) => e.type === "source_component" && e.name === component_name
              );
              if (!source_component)
                return null;
              const source_port = circuitJson.find(
                (e) => e.type === "source_port" && e.source_component_id === source_component.source_component_id && (e.name === port_selector || (e.port_hints ?? []).includes(port_selector))
              );
              if (!source_port)
                return null;
              if (component_type === "source_port")
                return source_port;
              if (component_type === "pcb_port") {
                return circuitJson.find(
                  (e) => e.type === "pcb_port" && e.source_port_id === source_port.source_port_id
                );
              } else if (component_type === "schematic_port") {
                return circuitJson.find(
                  (e) => e.type === "schematic_port" && e.source_port_id === source_port.source_port_id
                );
              }
            }
          }
        };
      }
    }
  );
  return su2;
};
cju.unparsed = cju;
var su = cju;
var cju_default = cju;

// lib/cju-indexed.ts
import * as Soup2 from "circuit-json";
function createIdKey(element) {
  const type = element.type;
  return `${type}:${element[`${type}_id`]}`;
}
var cjuIndexed = (soup, options = {}) => {
  let internalStore = soup._internal_store_indexed;
  if (!internalStore) {
    internalStore = {
      counts: {},
      editCount: 0,
      indexes: {}
    };
    for (const elm of soup) {
      const type = elm.type;
      const idVal = elm[`${type}_id`];
      if (!idVal)
        continue;
      const idNum = Number.parseInt(idVal.split("_").pop() || "");
      if (!Number.isNaN(idNum)) {
        internalStore.counts[type] = Math.max(
          internalStore.counts[type] ?? 0,
          idNum
        );
      }
    }
    const indexConfig = options.indexConfig || {};
    const indexes = internalStore.indexes;
    if (indexConfig.byId) {
      indexes.byId = /* @__PURE__ */ new Map();
    }
    if (indexConfig.byType) {
      indexes.byType = /* @__PURE__ */ new Map();
    }
    if (indexConfig.byRelation) {
      indexes.byRelation = /* @__PURE__ */ new Map();
    }
    if (indexConfig.bySubcircuit) {
      indexes.bySubcircuit = /* @__PURE__ */ new Map();
    }
    if (indexConfig.byCustomField && indexConfig.byCustomField.length > 0) {
      indexes.byCustomField = /* @__PURE__ */ new Map();
      for (const field of indexConfig.byCustomField) {
        indexes.byCustomField.set(field, /* @__PURE__ */ new Map());
      }
    }
    for (const element of soup) {
      if (indexConfig.byId) {
        const idKey = createIdKey(element);
        indexes.byId.set(idKey, element);
      }
      if (indexConfig.byType) {
        const elementsOfType = indexes.byType.get(element.type) || [];
        elementsOfType.push(element);
        indexes.byType.set(element.type, elementsOfType);
      }
      if (indexConfig.byRelation) {
        const elementEntries = Object.entries(element);
        for (const [key, value] of elementEntries) {
          if (key.endsWith("_id") && key !== `${element.type}_id` && typeof value === "string") {
            const relationTypeMap = indexes.byRelation.get(key) || /* @__PURE__ */ new Map();
            const relatedElements = relationTypeMap.get(value) || [];
            relatedElements.push(element);
            relationTypeMap.set(value, relatedElements);
            indexes.byRelation.set(key, relationTypeMap);
          }
        }
      }
      if (indexConfig.bySubcircuit && "subcircuit_id" in element) {
        const subcircuitId = element.subcircuit_id;
        if (subcircuitId && typeof subcircuitId === "string") {
          const subcircuitElements = indexes.bySubcircuit.get(subcircuitId) || [];
          subcircuitElements.push(element);
          indexes.bySubcircuit.set(subcircuitId, subcircuitElements);
        }
      }
      if (indexConfig.byCustomField && indexes.byCustomField) {
        for (const field of indexConfig.byCustomField) {
          if (field in element) {
            const fieldValue = element[field];
            if (fieldValue !== void 0 && (typeof fieldValue === "string" || typeof fieldValue === "number")) {
              const fieldValueStr = String(fieldValue);
              const fieldMap = indexes.byCustomField.get(field);
              const elementsWithFieldValue = fieldMap.get(fieldValueStr) || [];
              elementsWithFieldValue.push(element);
              fieldMap.set(fieldValueStr, elementsWithFieldValue);
            }
          }
        }
      }
    }
    ;
    soup._internal_store_indexed = internalStore;
  }
  const suIndexed = new Proxy(
    {},
    {
      get: (proxy_target, prop) => {
        if (prop === "toArray") {
          return () => {
            ;
            soup.editCount = internalStore.editCount;
            return soup;
          };
        }
        if (prop === "editCount") {
          return internalStore.editCount;
        }
        const component_type = prop;
        return {
          get: (id) => {
            const indexConfig = options.indexConfig || {};
            if (indexConfig.byId && internalStore.indexes.byId) {
              return internalStore.indexes.byId.get(
                `${component_type}:${id}`
              ) || null;
            }
            if (indexConfig.byType && internalStore.indexes.byType) {
              const elementsOfType = internalStore.indexes.byType.get(component_type) || [];
              return elementsOfType.find(
                (e) => e[`${component_type}_id`] === id
              ) || null;
            }
            return soup.find(
              (e) => e.type === component_type && e[`${component_type}_id`] === id
            ) || null;
          },
          getUsing: (using) => {
            const indexConfig = options.indexConfig || {};
            const keys = Object.keys(using);
            if (keys.length !== 1) {
              throw new Error(
                "getUsing requires exactly one key, e.g. { pcb_component_id }"
              );
            }
            const join_key = keys[0];
            const join_type = join_key.replace("_id", "");
            if (indexConfig.byRelation && internalStore.indexes.byRelation) {
              const relationMap = internalStore.indexes.byRelation.get(join_key);
              if (relationMap) {
                const relatedElements = relationMap.get(using[join_key]) || [];
                const joiner2 = relatedElements.find((e) => e.type === join_type);
                if (!joiner2)
                  return null;
                const joinerId = joiner2[`${component_type}_id`];
                if (indexConfig.byId && internalStore.indexes.byId) {
                  return internalStore.indexes.byId.get(
                    `${component_type}:${joinerId}`
                  ) || null;
                }
                if (indexConfig.byType && internalStore.indexes.byType) {
                  const elementsOfType = internalStore.indexes.byType.get(component_type) || [];
                  return elementsOfType.find(
                    (e) => e[`${component_type}_id`] === joinerId
                  ) || null;
                }
                return soup.find(
                  (e) => e.type === component_type && e[`${component_type}_id`] === joinerId
                ) || null;
              }
            }
            const joiner = soup.find(
              (e) => e.type === join_type && e[join_key] === using[join_key]
            );
            if (!joiner)
              return null;
            return soup.find(
              (e) => e.type === component_type && e[`${component_type}_id`] === joiner[`${component_type}_id`]
            ) || null;
          },
          getWhere: (where) => {
            const indexConfig = options.indexConfig || {};
            const keys = Object.keys(where);
            if (keys.length === 1 && indexConfig.byCustomField && internalStore.indexes.byCustomField) {
              const field = keys[0];
              const fieldMap = internalStore.indexes.byCustomField.get(field);
              if (fieldMap) {
                const fieldValue = String(where[field]);
                const elementsWithFieldValue = fieldMap.get(fieldValue) || [];
                return elementsWithFieldValue.find(
                  (e) => e.type === component_type
                ) || null;
              }
            }
            if ("subcircuit_id" in where && indexConfig.bySubcircuit && internalStore.indexes.bySubcircuit) {
              const subcircuitId = where.subcircuit_id;
              const subcircuitElements = internalStore.indexes.bySubcircuit.get(subcircuitId) || [];
              return subcircuitElements.find(
                (e) => e.type === component_type && keys.every((key) => e[key] === where[key])
              ) || null;
            }
            if (indexConfig.byType && internalStore.indexes.byType) {
              const elementsOfType = internalStore.indexes.byType.get(component_type) || [];
              return elementsOfType.find(
                (e) => keys.every((key) => e[key] === where[key])
              ) || null;
            }
            return soup.find(
              (e) => e.type === component_type && keys.every((key) => e[key] === where[key])
            ) || null;
          },
          list: (where) => {
            const indexConfig = options.indexConfig || {};
            const keys = !where ? [] : Object.keys(where);
            if (keys.length === 0 && indexConfig.byType && internalStore.indexes.byType) {
              return internalStore.indexes.byType.get(component_type) || [];
            }
            if (keys.length === 1 && keys[0] === "subcircuit_id" && indexConfig.bySubcircuit && internalStore.indexes.bySubcircuit) {
              const subcircuitId = where.subcircuit_id;
              const subcircuitElements = internalStore.indexes.bySubcircuit.get(subcircuitId) || [];
              return subcircuitElements.filter(
                (e) => e.type === component_type
              );
            }
            let elementsToFilter;
            if (indexConfig.byType && internalStore.indexes.byType) {
              elementsToFilter = internalStore.indexes.byType.get(component_type) || [];
            } else {
              elementsToFilter = soup.filter((e) => e.type === component_type);
            }
            if (keys.length > 0) {
              return elementsToFilter.filter(
                (e) => keys.every((key) => e[key] === where[key])
              );
            }
            return elementsToFilter;
          },
          insert: (elm) => {
            internalStore.counts[component_type] ??= -1;
            internalStore.counts[component_type]++;
            const index = internalStore.counts[component_type];
            const newElm = {
              type: component_type,
              [`${component_type}_id`]: `${component_type}_${index}`,
              ...elm
            };
            if (options.validateInserts) {
              const parser = Soup2[component_type] ?? Soup2.any_soup_element;
              parser.parse(newElm);
            }
            soup.push(newElm);
            internalStore.editCount++;
            const indexConfig = options.indexConfig || {};
            if (indexConfig.byId && internalStore.indexes.byId) {
              const idKey = createIdKey(newElm);
              internalStore.indexes.byId.set(idKey, newElm);
            }
            if (indexConfig.byType && internalStore.indexes.byType) {
              const elementsOfType = internalStore.indexes.byType.get(component_type) || [];
              elementsOfType.push(newElm);
              internalStore.indexes.byType.set(component_type, elementsOfType);
            }
            if (indexConfig.byRelation && internalStore.indexes.byRelation) {
              const elementEntries = Object.entries(newElm);
              for (const [key, value] of elementEntries) {
                if (key.endsWith("_id") && key !== `${newElm.type}_id` && typeof value === "string") {
                  const relationTypeMap = internalStore.indexes.byRelation.get(key) || /* @__PURE__ */ new Map();
                  const relatedElements = relationTypeMap.get(value) || [];
                  relatedElements.push(newElm);
                  relationTypeMap.set(value, relatedElements);
                  internalStore.indexes.byRelation.set(key, relationTypeMap);
                }
              }
            }
            if (indexConfig.bySubcircuit && internalStore.indexes.bySubcircuit && "subcircuit_id" in newElm) {
              const subcircuitId = newElm.subcircuit_id;
              if (subcircuitId && typeof subcircuitId === "string") {
                const subcircuitElements = internalStore.indexes.bySubcircuit.get(subcircuitId) || [];
                subcircuitElements.push(newElm);
                internalStore.indexes.bySubcircuit.set(
                  subcircuitId,
                  subcircuitElements
                );
              }
            }
            if (indexConfig.byCustomField && internalStore.indexes.byCustomField) {
              for (const field of indexConfig.byCustomField) {
                if (field in newElm) {
                  const fieldValue = newElm[field];
                  if (fieldValue !== void 0 && (typeof fieldValue === "string" || typeof fieldValue === "number")) {
                    const fieldValueStr = String(fieldValue);
                    const fieldMap = internalStore.indexes.byCustomField.get(field);
                    const elementsWithFieldValue = fieldMap.get(fieldValueStr) || [];
                    elementsWithFieldValue.push(newElm);
                    fieldMap.set(fieldValueStr, elementsWithFieldValue);
                  }
                }
              }
            }
            return newElm;
          },
          delete: (id) => {
            const indexConfig = options.indexConfig || {};
            let elm;
            if (indexConfig.byId && internalStore.indexes.byId) {
              elm = internalStore.indexes.byId.get(`${component_type}:${id}`);
            } else if (indexConfig.byType && internalStore.indexes.byType) {
              const elementsOfType = internalStore.indexes.byType.get(component_type) || [];
              elm = elementsOfType.find(
                (e) => e[`${component_type}_id`] === id
              );
            } else {
              elm = soup.find((e) => e[`${component_type}_id`] === id);
            }
            if (!elm)
              return;
            const elmIndex = soup.indexOf(elm);
            if (elmIndex >= 0) {
              soup.splice(elmIndex, 1);
              internalStore.editCount++;
            }
            if (indexConfig.byId && internalStore.indexes.byId) {
              const idKey = createIdKey(elm);
              internalStore.indexes.byId.delete(idKey);
            }
            if (indexConfig.byType && internalStore.indexes.byType) {
              const elementsOfType = internalStore.indexes.byType.get(component_type) || [];
              const filteredElements = elementsOfType.filter(
                (e) => e[`${component_type}_id`] !== id
              );
              internalStore.indexes.byType.set(component_type, filteredElements);
            }
            if (indexConfig.byRelation && internalStore.indexes.byRelation) {
              for (const [
                relationKey,
                relationMap
              ] of internalStore.indexes.byRelation.entries()) {
                for (const [relationValue, elements] of relationMap.entries()) {
                  const updatedElements = elements.filter((e) => e !== elm);
                  if (updatedElements.length === 0) {
                    relationMap.delete(relationValue);
                  } else {
                    relationMap.set(relationValue, updatedElements);
                  }
                }
              }
            }
            if (indexConfig.bySubcircuit && internalStore.indexes.bySubcircuit && "subcircuit_id" in elm) {
              const subcircuitId = elm.subcircuit_id;
              if (subcircuitId) {
                const subcircuitElements = internalStore.indexes.bySubcircuit.get(subcircuitId) || [];
                const updatedElements = subcircuitElements.filter(
                  (e) => e !== elm
                );
                if (updatedElements.length === 0) {
                  internalStore.indexes.bySubcircuit.delete(subcircuitId);
                } else {
                  internalStore.indexes.bySubcircuit.set(
                    subcircuitId,
                    updatedElements
                  );
                }
              }
            }
            if (indexConfig.byCustomField && internalStore.indexes.byCustomField) {
              for (const fieldMap of internalStore.indexes.byCustomField.values()) {
                for (const [fieldValue, elements] of fieldMap.entries()) {
                  const updatedElements = elements.filter((e) => e !== elm);
                  if (updatedElements.length === 0) {
                    fieldMap.delete(fieldValue);
                  } else {
                    fieldMap.set(fieldValue, updatedElements);
                  }
                }
              }
            }
          },
          update: (id, newProps) => {
            const indexConfig = options.indexConfig || {};
            let elm;
            if (indexConfig.byId && internalStore.indexes.byId) {
              elm = internalStore.indexes.byId.get(`${component_type}:${id}`);
            } else if (indexConfig.byType && internalStore.indexes.byType) {
              const elementsOfType = internalStore.indexes.byType.get(component_type) || [];
              elm = elementsOfType.find(
                (e) => e[`${component_type}_id`] === id
              );
            } else {
              elm = soup.find(
                (e) => e.type === component_type && e[`${component_type}_id`] === id
              );
            }
            if (!elm)
              return null;
            if (indexConfig.byRelation && internalStore.indexes.byRelation) {
              const elementEntries = Object.entries(elm);
              for (const [key, value] of elementEntries) {
                if (key.endsWith("_id") && key !== `${elm.type}_id` && typeof value === "string") {
                  if (key in newProps && newProps[key] !== value) {
                    const relationTypeMap = internalStore.indexes.byRelation.get(key);
                    if (relationTypeMap) {
                      const relatedElements = relationTypeMap.get(value) || [];
                      const updatedElements = relatedElements.filter(
                        (e) => e !== elm
                      );
                      if (updatedElements.length === 0) {
                        relationTypeMap.delete(value);
                      } else {
                        relationTypeMap.set(value, updatedElements);
                      }
                    }
                  }
                }
              }
            }
            if (indexConfig.bySubcircuit && internalStore.indexes.bySubcircuit && "subcircuit_id" in elm && "subcircuit_id" in newProps) {
              const oldSubcircuitId = elm.subcircuit_id;
              const newSubcircuitId = newProps.subcircuit_id;
              if (oldSubcircuitId !== newSubcircuitId) {
                const subcircuitElements = internalStore.indexes.bySubcircuit.get(oldSubcircuitId) || [];
                const updatedElements = subcircuitElements.filter(
                  (e) => e !== elm
                );
                if (updatedElements.length === 0) {
                  internalStore.indexes.bySubcircuit.delete(oldSubcircuitId);
                } else {
                  internalStore.indexes.bySubcircuit.set(
                    oldSubcircuitId,
                    updatedElements
                  );
                }
              }
            }
            if (indexConfig.byCustomField && internalStore.indexes.byCustomField) {
              for (const field of indexConfig.byCustomField) {
                if (field in elm && field in newProps && elm[field] !== newProps[field]) {
                  const fieldMap = internalStore.indexes.byCustomField.get(field);
                  if (fieldMap) {
                    const oldValue = String(elm[field]);
                    const elements = fieldMap.get(oldValue) || [];
                    const updatedElements = elements.filter((e) => e !== elm);
                    if (updatedElements.length === 0) {
                      fieldMap.delete(oldValue);
                    } else {
                      fieldMap.set(oldValue, updatedElements);
                    }
                  }
                }
              }
            }
            Object.assign(elm, newProps);
            internalStore.editCount++;
            if (indexConfig.byRelation && internalStore.indexes.byRelation) {
              const elementEntries = Object.entries(elm);
              for (const [key, value] of elementEntries) {
                if (key.endsWith("_id") && key !== `${elm.type}_id` && typeof value === "string") {
                  if (key in newProps) {
                    const relationTypeMap = internalStore.indexes.byRelation.get(key) || /* @__PURE__ */ new Map();
                    const relatedElements = relationTypeMap.get(value) || [];
                    if (!relatedElements.includes(elm)) {
                      relatedElements.push(elm);
                      relationTypeMap.set(value, relatedElements);
                      internalStore.indexes.byRelation.set(key, relationTypeMap);
                    }
                  }
                }
              }
            }
            if (indexConfig.bySubcircuit && internalStore.indexes.bySubcircuit && "subcircuit_id" in elm && "subcircuit_id" in newProps) {
              const subcircuitId = elm.subcircuit_id;
              if (subcircuitId && typeof subcircuitId === "string") {
                const subcircuitElements = internalStore.indexes.bySubcircuit.get(subcircuitId) || [];
                if (!subcircuitElements.includes(elm)) {
                  subcircuitElements.push(elm);
                  internalStore.indexes.bySubcircuit.set(
                    subcircuitId,
                    subcircuitElements
                  );
                }
              }
            }
            if (indexConfig.byCustomField && internalStore.indexes.byCustomField) {
              for (const field of indexConfig.byCustomField) {
                if (field in elm && field in newProps) {
                  const fieldValue = elm[field];
                  if (fieldValue !== void 0 && (typeof fieldValue === "string" || typeof fieldValue === "number")) {
                    const fieldValueStr = String(fieldValue);
                    const fieldMap = internalStore.indexes.byCustomField.get(field);
                    const elementsWithFieldValue = fieldMap.get(fieldValueStr) || [];
                    if (!elementsWithFieldValue.includes(elm)) {
                      elementsWithFieldValue.push(elm);
                      fieldMap.set(fieldValueStr, elementsWithFieldValue);
                    }
                  }
                }
              }
            }
            return elm;
          },
          select: (selector) => {
            if (component_type === "source_component") {
              return soup.find(
                (e) => e.type === "source_component" && e.name === selector.replace(/\./g, "")
              ) || null;
            } else if (component_type === "pcb_port" || component_type === "source_port" || component_type === "schematic_port") {
              const [component_name, port_selector] = selector.replace(/\./g, "").split(/[\s\>]+/);
              const source_component = soup.find(
                (e) => e.type === "source_component" && e.name === component_name
              );
              if (!source_component)
                return null;
              const source_port = soup.find(
                (e) => e.type === "source_port" && e.source_component_id === source_component.source_component_id && (e.name === port_selector || (e.port_hints ?? []).includes(port_selector))
              );
              if (!source_port)
                return null;
              if (component_type === "source_port")
                return source_port;
              if (component_type === "pcb_port") {
                return soup.find(
                  (e) => e.type === "pcb_port" && e.source_port_id === source_port.source_port_id
                ) || null;
              } else if (component_type === "schematic_port") {
                return soup.find(
                  (e) => e.type === "schematic_port" && e.source_port_id === source_port.source_port_id
                ) || null;
              }
            }
            return null;
          }
        };
      }
    }
  );
  return suIndexed;
};
cjuIndexed.unparsed = cjuIndexed;
var cju_indexed_default = cjuIndexed;

// lib/transform-soup-elements.ts
import { applyToPoint, decomposeTSR } from "transformation-matrix";

// lib/direction-to-vec.ts
var directionToVec = (direction) => {
  if (direction === "up")
    return { x: 0, y: 1 };
  else if (direction === "down")
    return { x: 0, y: -1 };
  else if (direction === "left")
    return { x: -1, y: 0 };
  else if (direction === "right")
    return { x: 1, y: 0 };
  else
    throw new Error("Invalid direction");
};
var vecToDirection = ({ x, y }) => {
  if (x > y)
    y = 0;
  if (y > x)
    x = 0;
  if (x > 0 && y === 0)
    return "right";
  else if (x < 0 && y === 0)
    return "left";
  else if (x === 0 && y > 0)
    return "up";
  else if (x === 0 && y < 0)
    return "down";
  else
    throw new Error(`Invalid vector for direction conversion (${x}, ${y})`);
};
var rotateClockwise = (direction) => {
  if (direction === "up")
    return "right";
  else if (direction === "right")
    return "down";
  else if (direction === "down")
    return "left";
  else if (direction === "left")
    return "up";
  throw new Error(`Invalid direction: ${direction}`);
};
var rotateCounterClockwise = (direction) => {
  if (direction === "up")
    return "left";
  else if (direction === "left")
    return "down";
  else if (direction === "down")
    return "right";
  else if (direction === "right")
    return "up";
  throw new Error(`Invalid direction: ${direction}`);
};
var rotateDirection = (direction, num90DegreeClockwiseTurns) => {
  while (num90DegreeClockwiseTurns > 0) {
    direction = rotateClockwise(direction);
    num90DegreeClockwiseTurns--;
  }
  while (num90DegreeClockwiseTurns < 0) {
    direction = rotateCounterClockwise(direction);
    num90DegreeClockwiseTurns++;
  }
  return direction;
};
var oppositeDirection = (direction) => {
  if (direction === "up")
    return "down";
  else if (direction === "down")
    return "up";
  else if (direction === "left")
    return "right";
  else if (direction === "right")
    return "left";
  throw new Error(`Invalid direction: ${direction}`);
};
var oppositeSide = (sideOrDir) => {
  if (sideOrDir === "top" || sideOrDir === "up")
    return "bottom";
  else if (sideOrDir === "bottom" || sideOrDir === "down")
    return "top";
  else if (sideOrDir === "left")
    return "right";
  else if (sideOrDir === "right")
    return "left";
  throw new Error(`Invalid sideOrDir: ${sideOrDir}`);
};

// lib/transform-soup-elements.ts
var transformSchematicElement = (elm, matrix) => {
  if (elm.type === "schematic_component") {
    elm.center = applyToPoint(matrix, elm.center);
  } else if (elm.type === "schematic_port") {
    elm.center = applyToPoint(matrix, elm.center);
    if (elm.facing_direction) {
      elm.facing_direction = rotateDirection(
        elm.facing_direction,
        -(Math.atan2(matrix.b, matrix.a) / Math.PI) * 2
      );
    }
  } else if (elm.type === "schematic_text") {
    elm.position = applyToPoint(matrix, elm.position);
  } else if (elm.type === "schematic_trace") {
  } else if (elm.type === "schematic_box") {
    const { x, y } = applyToPoint(matrix, { x: elm.x, y: elm.y });
    elm.x = x;
    elm.y = y;
  } else if (elm.type === "schematic_line") {
    const { x: x1, y: y1 } = applyToPoint(matrix, { x: elm.x1, y: elm.y1 });
    const { x: x2, y: y2 } = applyToPoint(matrix, { x: elm.x2, y: elm.y2 });
    elm.x1 = x1;
    elm.y1 = y1;
    elm.x2 = x2;
    elm.y2 = y2;
  }
  return elm;
};
var transformSchematicElements = (elms, matrix) => {
  return elms.map((elm) => transformSchematicElement(elm, matrix));
};
var transformPCBElement = (elm, matrix) => {
  if (elm.type === "pcb_plated_hole" || elm.type === "pcb_hole" || elm.type === "pcb_via" || elm.type === "pcb_smtpad" || elm.type === "pcb_port") {
    const { x, y } = applyToPoint(matrix, {
      x: Number(elm.x),
      y: Number(elm.y)
    });
    elm.x = x;
    elm.y = y;
  } else if (elm.type === "pcb_keepout" || elm.type === "pcb_board") {
    elm.center = applyToPoint(matrix, elm.center);
  } else if (elm.type === "pcb_silkscreen_text" || elm.type === "pcb_fabrication_note_text") {
    elm.anchor_position = applyToPoint(matrix, elm.anchor_position);
  } else if (elm.type === "pcb_silkscreen_circle" || elm.type === "pcb_silkscreen_rect" || elm.type === "pcb_component") {
    elm.center = applyToPoint(matrix, elm.center);
  } else if (elm.type === "pcb_silkscreen_path" || elm.type === "pcb_trace" || elm.type === "pcb_fabrication_note_path") {
    elm.route = elm.route.map((rp) => {
      const tp = applyToPoint(matrix, rp);
      rp.x = tp.x;
      rp.y = tp.y;
      return rp;
    });
  } else if (elm.type === "pcb_silkscreen_line") {
    const p1 = { x: elm.x1, y: elm.y1 };
    const p2 = { x: elm.x2, y: elm.y2 };
    const p1t = applyToPoint(matrix, p1);
    const p2t = applyToPoint(matrix, p2);
    elm.x1 = p1t.x;
    elm.y1 = p1t.y;
    elm.x2 = p2t.x;
    elm.y2 = p2t.y;
  } else if (elm.type === "cad_component") {
    const newPos = applyToPoint(matrix, {
      x: elm.position.x,
      y: elm.position.y
    });
    elm.position.x = newPos.x;
    elm.position.y = newPos.y;
  }
  return elm;
};
var transformPCBElements = (elms, matrix) => {
  const tsr = decomposeTSR(matrix);
  const flipPadWidthHeight = Math.round(tsr.rotation.angle / (Math.PI / 2)) % 2 === 1;
  let transformedElms = elms.map((elm) => transformPCBElement(elm, matrix));
  if (flipPadWidthHeight) {
    transformedElms = transformedElms.map((elm) => {
      if (elm.type === "pcb_smtpad" && elm.shape === "rect") {
        ;
        [elm.width, elm.height] = [elm.height, elm.width];
      }
      return elm;
    });
  }
  return transformedElms;
};

// lib/apply-selector.ts
import * as parsel from "parsel-js";

// lib/convert-abbreviation-to-soup-element-type.ts
var convertAbbrToType = (abbr) => {
  switch (abbr) {
    case "port":
      return "source_port";
    case "net":
      return "source_net";
    case "power":
      return "simple_power_source";
  }
  return abbr;
};

// lib/apply-selector.ts
var filterByType = (elements, type) => {
  type = convertAbbrToType(type);
  return elements.filter(
    (elm) => "ftype" in elm && elm.ftype === type || elm.type === type
  );
};
var applySelector = (elements, selectorRaw) => {
  const selectorAST = parsel.parse(selectorRaw);
  return applySelectorAST(elements, selectorAST);
};
var doesElmMatchClassName = (elm, className) => "name" in elm && elm.name === className || "port_hints" in elm && elm.port_hints?.includes(className);
var applySelectorAST = (elements, selectorAST) => {
  switch (selectorAST.type) {
    case "complex": {
      switch (selectorAST.combinator) {
        case " ":
        case ">": {
          const { left, right } = selectorAST;
          if (left.type === "class" || left.type === "type") {
            let matchElms;
            if (left.type === "class") {
              matchElms = elements.filter(
                (elm) => doesElmMatchClassName(elm, left.name)
              );
            } else if (left.type === "type") {
              matchElms = filterByType(elements, left.name);
            } else {
              matchElms = [];
            }
            const childrenOfMatchingElms = matchElms.flatMap(
              (matchElm) => elements.filter(
                (elm) => elm[`${matchElm.type}_id`] === matchElm[`${matchElm.type}_id`] && elm !== matchElm
              )
            );
            return applySelectorAST(childrenOfMatchingElms, right);
          } else {
            throw new Error(`unsupported selector type "${left.type}" `);
          }
        }
        default: {
          throw new Error(
            `Couldn't apply selector AST for complex combinator "${selectorAST.combinator}"`
          );
        }
      }
      return [];
    }
    case "compound": {
      const conditionsToMatch = selectorAST.list.map((part) => {
        switch (part.type) {
          case "class": {
            return (elm) => doesElmMatchClassName(elm, part.name);
          }
          case "type": {
            const name = convertAbbrToType(part.name);
            return (elm) => elm.type === name;
          }
        }
      });
      return elements.filter(
        (elm) => conditionsToMatch.every((condFn) => condFn?.(elm))
      );
    }
    case "type": {
      return filterByType(elements, selectorAST.name);
    }
    case "class": {
      return elements.filter(
        (elm) => doesElmMatchClassName(elm, selectorAST.name)
      );
    }
    default: {
      throw new Error(
        `Couldn't apply selector AST for type: "${selectorAST.type}" ${JSON.stringify(selectorAST, null, " ")}`
      );
    }
  }
};

// lib/get-element-id.ts
var getElementId = (elm) => {
  const type = elm.type;
  const id = elm[`${type}_id`];
  return id;
};

// lib/get-element-by-id.ts
var getElementById = (soup, id) => {
  return soup.find((elm) => getElementId(elm) === id) ?? null;
};

// lib/readable-name-functions/get-readable-name-for-pcb-trace.ts
function getReadableNameForPcbTrace(soup, pcb_trace_id) {
  const pcbTrace = cju(soup).pcb_trace.get(pcb_trace_id);
  if (!pcbTrace) {
    return `trace[${pcb_trace_id}]`;
  }
  const connectedPcbPortIds = pcbTrace.route.flatMap((point) => [point.start_pcb_port_id, point.end_pcb_port_id]).filter(Boolean);
  if (connectedPcbPortIds.length === 0) {
    return `trace[${pcb_trace_id}]`;
  }
  function getComponentAndPortInfo(pcb_port_id) {
    const pcbPort = cju(soup).pcb_port.get(pcb_port_id);
    if (!pcbPort)
      return null;
    const pcbComponent = cju(soup).pcb_component.get(pcbPort.pcb_component_id);
    if (!pcbComponent)
      return null;
    const sourceComponent = cju(soup).source_component.get(
      pcbComponent.source_component_id
    );
    if (!sourceComponent)
      return null;
    const sourcePort = cju(soup).source_port.get(pcbPort.source_port_id);
    const portHint = sourcePort?.port_hints ? sourcePort.port_hints[1] : "";
    return {
      componentName: sourceComponent.name,
      portHint
    };
  }
  const selectorParts = connectedPcbPortIds.map((portId) => {
    const info = getComponentAndPortInfo(portId);
    if (info) {
      return `.${info.componentName} > port.${info.portHint}`;
    }
    return `port[${portId}]`;
  });
  return `trace[${selectorParts.join(", ")}]`;
}

// lib/readable-name-functions/get-readable-name-for-pcb-port.ts
var getReadableNameForPcbPort = (soup, pcb_port_id) => {
  const pcbPort = cju(soup).pcb_port.get(pcb_port_id);
  if (!pcbPort) {
    return `pcb_port[#${pcb_port_id}]`;
  }
  const pcbComponent = cju(soup).pcb_component.get(pcbPort?.pcb_component_id);
  if (!pcbComponent) {
    return `pcb_port[#${pcb_port_id}]`;
  }
  const sourceComponent = cju(soup).source_component.get(
    pcbComponent.source_component_id
  );
  if (!sourceComponent) {
    return `pcb_port[#${pcb_port_id}]`;
  }
  const sourcePort = cju(soup).source_port.get(pcbPort.source_port_id);
  if (!sourcePort) {
    return `pcb_port[#${pcb_port_id}]`;
  }
  let padIdentifier;
  if (sourcePort?.port_hints && sourcePort.port_hints.length > 0) {
    padIdentifier = sourcePort.port_hints[0];
  } else if (sourcePort.port_hints && sourcePort.port_hints.length > 0) {
    padIdentifier = sourcePort.port_hints[0];
  } else {
    padIdentifier = pcb_port_id;
  }
  return `pcb_port[.${sourceComponent.name} > .${padIdentifier}]`;
};

// lib/readable-name-functions/get-readable-name-for-pcb-smtpad.ts
function getReadableNameForPcbSmtpad(soup, pcb_smtpad_id) {
  const pcbSmtpad = cju(soup).pcb_smtpad.get(pcb_smtpad_id);
  if (!pcbSmtpad || !pcbSmtpad.pcb_port_id) {
    return `smtpad[${pcb_smtpad_id}]`;
  }
  return getReadableNameForPcbPort(soup, pcbSmtpad.pcb_port_id);
}

// lib/readable-name-functions/get-readable-name-for-element.ts
var getReadableNameForElement = (soup, elm) => {
  if (typeof elm === "string") {
    const elmObj = getElementById(soup, elm);
    if (!elmObj)
      `unknown (could not find element with id ${elm})`;
    return getReadableNameForElement(soup, elmObj);
  }
  switch (elm.type) {
    case "pcb_port":
      return getReadableNameForPcbPort(soup, elm.pcb_port_id);
    case "pcb_smtpad":
      return getReadableNameForPcbSmtpad(soup, elm.pcb_smtpad_id);
    case "pcb_trace":
      return getReadableNameForPcbTrace(soup, elm.pcb_trace_id);
    case "source_component":
      return `source_component[${elm.name}]`;
    default:
      return `${elm.type}[#${getElementId(elm)}]`;
  }
};

// lib/get-bounds-of-pcb-elements.ts
var getBoundsOfPcbElements = (elements) => {
  let minX = Number.POSITIVE_INFINITY;
  let minY = Number.POSITIVE_INFINITY;
  let maxX = Number.NEGATIVE_INFINITY;
  let maxY = Number.NEGATIVE_INFINITY;
  for (const elm of elements) {
    if (!elm.type.startsWith("pcb_"))
      continue;
    let centerX;
    let centerY;
    let width;
    let height;
    if ("x" in elm && "y" in elm) {
      centerX = Number(elm.x);
      centerY = Number(elm.y);
    }
    if ("outer_diameter" in elm) {
      width = Number(elm.outer_diameter);
      height = Number(elm.outer_diameter);
    }
    if ("width" in elm) {
      width = Number(elm.width);
    }
    if ("height" in elm) {
      height = Number(elm.height);
    }
    if ("center" in elm) {
      centerX = elm.center.x;
      centerY = elm.center.y;
    }
    if (centerX !== void 0 && centerY !== void 0) {
      minX = Math.min(minX, centerX);
      minY = Math.min(minY, centerY);
      maxX = Math.max(maxX, centerX);
      maxY = Math.max(maxY, centerY);
      if (width !== void 0 && height !== void 0) {
        minX = Math.min(minX, centerX - width / 2);
        minY = Math.min(minY, centerY - height / 2);
        maxX = Math.max(maxX, centerX + width / 2);
        maxY = Math.max(maxY, centerY + height / 2);
      }
      if ("radius" in elm) {
        minX = Math.min(minX, centerX - elm.radius);
        minY = Math.min(minY, centerY - elm.radius);
        maxX = Math.max(maxX, centerX + elm.radius);
        maxY = Math.max(maxY, centerY + elm.radius);
      }
    } else if (elm.type === "pcb_trace") {
      for (const point of elm.route) {
        minX = Math.min(minX, point.x);
        minY = Math.min(minY, point.y);
        maxX = Math.max(maxX, point.x);
        maxY = Math.max(maxY, point.y);
      }
    }
  }
  return { minX, minY, maxX, maxY };
};

// lib/utils/string-hash.ts
function stringHash(str) {
  let hash = 0;
  if (str.length == 0)
    return hash;
  for (var i = 0; i < str.length; i++) {
    var char = str.charCodeAt(i);
    hash = (hash << 5) - hash + char;
    hash = hash & hash;
  }
  return Math.abs(hash);
}

// lib/utils/get-layout-debug-object.ts
var nice_color_palettes = [
  ["#69d2e7", "#a7dbd8", "#e0e4cc", "#f38630", "#fa6900"],
  ["#fe4365", "#fc9d9a", "#f9cdad", "#c8c8a9", "#83af9b"],
  ["#ecd078", "#d95b43", "#c02942", "#542437", "#53777a"],
  ["#556270", "#4ecdc4", "#c7f464", "#ff6b6b", "#c44d58"],
  ["#774f38", "#e08e79", "#f1d4af", "#ece5ce", "#c5e0dc"],
  ["#e8ddcb", "#cdb380", "#036564", "#033649", "#031634"],
  ["#490a3d", "#bd1550", "#e97f02", "#f8ca00", "#8a9b0f"],
  ["#594f4f", "#547980", "#45ada8", "#9de0ad", "#e5fcc2"],
  ["#00a0b0", "#6a4a3c", "#cc333f", "#eb6841", "#edc951"],
  ["#e94e77", "#d68189", "#c6a49a", "#c6e5d9", "#f4ead5"],
  ["#3fb8af", "#7fc7af", "#dad8a7", "#ff9e9d", "#ff3d7f"],
  ["#d9ceb2", "#948c75", "#d5ded9", "#7a6a53", "#99b2b7"],
  ["#ffffff", "#cbe86b", "#f2e9e1", "#1c140d", "#cbe86b"],
  ["#efffcd", "#dce9be", "#555152", "#2e2633", "#99173c"],
  ["#343838", "#005f6b", "#008c9e", "#00b4cc", "#00dffc"],
  ["#413e4a", "#73626e", "#b38184", "#f0b49e", "#f7e4be"],
  ["#ff4e50", "#fc913a", "#f9d423", "#ede574", "#e1f5c4"],
  ["#99b898", "#fecea8", "#ff847c", "#e84a5f", "#2a363b"],
  ["#655643", "#80bca3", "#f6f7bd", "#e6ac27", "#bf4d28"],
  ["#00a8c6", "#40c0cb", "#f9f2e7", "#aee239", "#8fbe00"],
  ["#351330", "#424254", "#64908a", "#e8caa4", "#cc2a41"],
  ["#554236", "#f77825", "#d3ce3d", "#f1efa5", "#60b99a"],
  ["#5d4157", "#838689", "#a8caba", "#cad7b2", "#ebe3aa"],
  ["#8c2318", "#5e8c6a", "#88a65e", "#bfb35a", "#f2c45a"],
  ["#fad089", "#ff9c5b", "#f5634a", "#ed303c", "#3b8183"],
  ["#ff4242", "#f4fad2", "#d4ee5e", "#e1edb9", "#f0f2eb"],
  ["#f8b195", "#f67280", "#c06c84", "#6c5b7b", "#355c7d"],
  ["#d1e751", "#ffffff", "#000000", "#4dbce9", "#26ade4"],
  ["#1b676b", "#519548", "#88c425", "#bef202", "#eafde6"],
  ["#5e412f", "#fcebb6", "#78c0a8", "#f07818", "#f0a830"],
  ["#bcbdac", "#cfbe27", "#f27435", "#f02475", "#3b2d38"],
  ["#452632", "#91204d", "#e4844a", "#e8bf56", "#e2f7ce"],
  ["#eee6ab", "#c5bc8e", "#696758", "#45484b", "#36393b"],
  ["#f0d8a8", "#3d1c00", "#86b8b1", "#f2d694", "#fa2a00"],
  ["#2a044a", "#0b2e59", "#0d6759", "#7ab317", "#a0c55f"],
  ["#f04155", "#ff823a", "#f2f26f", "#fff7bd", "#95cfb7"],
  ["#b9d7d9", "#668284", "#2a2829", "#493736", "#7b3b3b"],
  ["#bbbb88", "#ccc68d", "#eedd99", "#eec290", "#eeaa88"],
  ["#b3cc57", "#ecf081", "#ffbe40", "#ef746f", "#ab3e5b"],
  ["#a3a948", "#edb92e", "#f85931", "#ce1836", "#009989"],
  ["#300030", "#480048", "#601848", "#c04848", "#f07241"],
  ["#67917a", "#170409", "#b8af03", "#ccbf82", "#e33258"],
  ["#aab3ab", "#c4cbb7", "#ebefc9", "#eee0b7", "#e8caaf"],
  ["#e8d5b7", "#0e2430", "#fc3a51", "#f5b349", "#e8d5b9"],
  ["#ab526b", "#bca297", "#c5ceae", "#f0e2a4", "#f4ebc3"],
  ["#607848", "#789048", "#c0d860", "#f0f0d8", "#604848"],
  ["#b6d8c0", "#c8d9bf", "#dadabd", "#ecdbbc", "#fedcba"],
  ["#a8e6ce", "#dcedc2", "#ffd3b5", "#ffaaa6", "#ff8c94"],
  ["#3e4147", "#fffedf", "#dfba69", "#5a2e2e", "#2a2c31"],
  ["#fc354c", "#29221f", "#13747d", "#0abfbc", "#fcf7c5"],
  ["#cc0c39", "#e6781e", "#c8cf02", "#f8fcc1", "#1693a7"],
  ["#1c2130", "#028f76", "#b3e099", "#ffeaad", "#d14334"],
  ["#a7c5bd", "#e5ddcb", "#eb7b59", "#cf4647", "#524656"],
  ["#dad6ca", "#1bb0ce", "#4f8699", "#6a5e72", "#563444"],
  ["#5c323e", "#a82743", "#e15e32", "#c0d23e", "#e5f04c"],
  ["#edebe6", "#d6e1c7", "#94c7b6", "#403b33", "#d3643b"],
  ["#fdf1cc", "#c6d6b8", "#987f69", "#e3ad40", "#fcd036"],
  ["#230f2b", "#f21d41", "#ebebbc", "#bce3c5", "#82b3ae"],
  ["#b9d3b0", "#81bda4", "#b28774", "#f88f79", "#f6aa93"],
  ["#3a111c", "#574951", "#83988e", "#bcdea5", "#e6f9bc"],
  ["#5e3929", "#cd8c52", "#b7d1a3", "#dee8be", "#fcf7d3"],
  ["#1c0113", "#6b0103", "#a30006", "#c21a01", "#f03c02"],
  ["#000000", "#9f111b", "#b11623", "#292c37", "#cccccc"],
  ["#382f32", "#ffeaf2", "#fcd9e5", "#fbc5d8", "#f1396d"],
  ["#e3dfba", "#c8d6bf", "#93ccc6", "#6cbdb5", "#1a1f1e"],
  ["#f6f6f6", "#e8e8e8", "#333333", "#990100", "#b90504"],
  ["#1b325f", "#9cc4e4", "#e9f2f9", "#3a89c9", "#f26c4f"],
  ["#a1dbb2", "#fee5ad", "#faca66", "#f7a541", "#f45d4c"],
  ["#c1b398", "#605951", "#fbeec2", "#61a6ab", "#accec0"],
  ["#5e9fa3", "#dcd1b4", "#fab87f", "#f87e7b", "#b05574"],
  ["#951f2b", "#f5f4d7", "#e0dfb1", "#a5a36c", "#535233"],
  ["#8dccad", "#988864", "#fea6a2", "#f9d6ac", "#ffe9af"],
  ["#2d2d29", "#215a6d", "#3ca2a2", "#92c7a3", "#dfece6"],
  ["#413d3d", "#040004", "#c8ff00", "#fa023c", "#4b000f"],
  ["#eff3cd", "#b2d5ba", "#61ada0", "#248f8d", "#605063"],
  ["#ffefd3", "#fffee4", "#d0ecea", "#9fd6d2", "#8b7a5e"],
  ["#cfffdd", "#b4dec1", "#5c5863", "#a85163", "#ff1f4c"],
  ["#9dc9ac", "#fffec7", "#f56218", "#ff9d2e", "#919167"],
  ["#4e395d", "#827085", "#8ebe94", "#ccfc8e", "#dc5b3e"],
  ["#a8a7a7", "#cc527a", "#e8175d", "#474747", "#363636"],
  ["#f8edd1", "#d88a8a", "#474843", "#9d9d93", "#c5cfc6"],
  ["#046d8b", "#309292", "#2fb8ac", "#93a42a", "#ecbe13"],
  ["#f38a8a", "#55443d", "#a0cab5", "#cde9ca", "#f1edd0"],
  ["#a70267", "#f10c49", "#fb6b41", "#f6d86b", "#339194"],
  ["#ff003c", "#ff8a00", "#fabe28", "#88c100", "#00c176"],
  ["#ffedbf", "#f7803c", "#f54828", "#2e0d23", "#f8e4c1"],
  ["#4e4d4a", "#353432", "#94ba65", "#2790b0", "#2b4e72"],
  ["#0ca5b0", "#4e3f30", "#fefeeb", "#f8f4e4", "#a5b3aa"],
  ["#4d3b3b", "#de6262", "#ffb88c", "#ffd0b3", "#f5e0d3"],
  ["#fffbb7", "#a6f6af", "#66b6ab", "#5b7c8d", "#4f2958"],
  ["#edf6ee", "#d1c089", "#b3204d", "#412e28", "#151101"],
  ["#9d7e79", "#ccac95", "#9a947c", "#748b83", "#5b756c"],
  ["#fcfef5", "#e9ffe1", "#cdcfb7", "#d6e6c3", "#fafbe3"],
  ["#9cddc8", "#bfd8ad", "#ddd9ab", "#f7af63", "#633d2e"],
  ["#30261c", "#403831", "#36544f", "#1f5f61", "#0b8185"],
  ["#aaff00", "#ffaa00", "#ff00aa", "#aa00ff", "#00aaff"],
  ["#d1313d", "#e5625c", "#f9bf76", "#8eb2c5", "#615375"],
  ["#ffe181", "#eee9e5", "#fad3b2", "#ffba7f", "#ff9c97"],
  ["#73c8a9", "#dee1b6", "#e1b866", "#bd5532", "#373b44"],
  ["#805841", "#dcf7f3", "#fffcdd", "#ffd8d8", "#f5a2a2"]
];
var getDebugLayoutObject = (lo) => {
  let {
    x,
    y,
    width,
    height
  } = {
    ...lo,
    ...lo.size,
    ...lo.center,
    ...lo.position
  };
  if (lo.x1 !== void 0 && lo.x2 !== void 0 && lo.y1 !== void 0 && lo.y2 !== void 0) {
    x = (lo.x1 + lo.x2) / 2;
    y = (lo.y1 + lo.y2) / 2;
    width = Math.abs(lo.x1 - lo.x2);
    height = Math.abs(lo.y1 - lo.y2);
  }
  if (lo.points && Array.isArray(lo.points) && lo.points.length > 0) {
    const xCoords = lo.points.map((point) => point.x);
    const yCoords = lo.points.map((point) => point.y);
    const minX = Math.min(...xCoords);
    const maxX = Math.max(...xCoords);
    const minY = Math.min(...yCoords);
    const maxY = Math.max(...yCoords);
    x = (minX + maxX) / 2;
    y = (minY + maxY) / 2;
    width = maxX - minX;
    height = maxY - minY;
  }
  const title = lo.text || lo.name || lo.source?.text || lo.source?.name || "?";
  const content = lo;
  if (x === void 0 || y === void 0)
    return null;
  if (width === void 0) {
    if ("outer_diameter" in lo) {
      width = lo.outer_diameter;
      height = lo.outer_diameter;
    }
  }
  if (width === void 0 || height === void 0) {
    width = 0.1;
    height = 0.1;
  }
  return {
    x,
    y,
    width,
    height,
    title,
    content,
    bg_color: nice_color_palettes[stringHash(lo.type || title) % nice_color_palettes.length]?.[4] ?? "#f00"
  };
};

// lib/utils/is-truthy.ts
var isTruthy = (value) => Boolean(value);

// lib/find-bounds-and-center.ts
var findBoundsAndCenter = (elements) => {
  const debugObjects = elements.filter((elm) => elm.type.startsWith("pcb_")).concat(
    elements.filter((elm) => elm.type === "pcb_trace").flatMap((elm) => elm.route)
  ).map((elm) => getDebugLayoutObject(elm)).filter(isTruthy);
  if (debugObjects.length === 0)
    return { center: { x: 0, y: 0 }, width: 0, height: 0 };
  let minX = debugObjects[0].x - debugObjects[0].width / 2;
  let maxX = debugObjects[0].x + debugObjects[0].width / 2;
  let minY = debugObjects[0].y - debugObjects[0].height / 2;
  let maxY = debugObjects[0].y + debugObjects[0].height / 2;
  for (const obj of debugObjects.slice(1)) {
    minX = Math.min(minX, obj.x - obj.width / 2);
    maxX = Math.max(maxX, obj.x + obj.width / 2);
    minY = Math.min(minY, obj.y - obj.height / 2);
    maxY = Math.max(maxY, obj.y + obj.height / 2);
  }
  const width = maxX - minX;
  const height = maxY - minY;
  const center = { x: minX + width / 2, y: minY + height / 2 };
  return { center, width, height };
};

// lib/get-primary-id.ts
var getPrimaryId = (element) => {
  return element[`${element.type}_id`];
};

// lib/reposition-pcb-component.ts
import { translate } from "transformation-matrix";
var repositionPcbComponentTo = (circuitJson, pcb_component_id, newCenter) => {
  const pcbComponent = circuitJson.find(
    (e) => e.type === "pcb_component" && e.pcb_component_id === pcb_component_id
  );
  if (!pcbComponent)
    return;
  const currentCenter = "center" in pcbComponent ? pcbComponent.center : { x: pcbComponent.x, y: pcbComponent.y };
  const dx = newCenter.x - currentCenter.x;
  const dy = newCenter.y - currentCenter.y;
  const portIds = circuitJson.filter(
    (e) => e.type === "pcb_port" && e.pcb_component_id === pcb_component_id
  ).map((e) => e.pcb_port_id);
  const elementsToMove = circuitJson.filter((elm) => {
    if (elm === pcbComponent)
      return true;
    const anyElm = elm;
    if (anyElm.pcb_component_id === pcb_component_id)
      return true;
    if (Array.isArray(anyElm.pcb_component_ids) && anyElm.pcb_component_ids.includes(pcb_component_id))
      return true;
    if (anyElm.pcb_port_id && portIds.includes(anyElm.pcb_port_id))
      return true;
    if (Array.isArray(anyElm.pcb_port_ids) && anyElm.pcb_port_ids.some((id) => portIds.includes(id)))
      return true;
    if (anyElm.start_pcb_port_id && portIds.includes(anyElm.start_pcb_port_id))
      return true;
    if (anyElm.end_pcb_port_id && portIds.includes(anyElm.end_pcb_port_id))
      return true;
    if (Array.isArray(anyElm.route) && anyElm.route.some(
      (pt) => pt.start_pcb_port_id && portIds.includes(pt.start_pcb_port_id) || pt.end_pcb_port_id && portIds.includes(pt.end_pcb_port_id)
    ))
      return true;
    return false;
  });
  const matrix = translate(dx, dy);
  transformPCBElements(elementsToMove, matrix);
};
export {
  applySelector,
  applySelectorAST,
  buildSubtree,
  cju_default as cju,
  cju_indexed_default as cjuIndexed,
  directionToVec,
  findBoundsAndCenter,
  getBoundsOfPcbElements,
  getElementById,
  getElementId,
  getPrimaryId,
  getReadableNameForElement,
  getReadableNameForPcbPort,
  getReadableNameForPcbSmtpad,
  getReadableNameForPcbTrace,
  oppositeDirection,
  oppositeSide,
  repositionPcbComponentTo,
  rotateClockwise,
  rotateCounterClockwise,
  rotateDirection,
  su,
  transformPCBElement,
  transformPCBElements,
  transformSchematicElement,
  transformSchematicElements,
  vecToDirection
};
//# sourceMappingURL=index.js.map