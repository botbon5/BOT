// lib/su.ts
import * as Soup from "circuit-json";
var su = (soup, options = {}) => {
  let internalStore = soup._internal_store;
  if (!internalStore) {
    internalStore = {
      counts: {}
    };
    soup._internal_store = internalStore;
    for (const elm of soup) {
      const type = elm.type;
      const idVal = elm[`${type}_id`];
      if (!idVal)
        continue;
      const idNum = Number.parseInt(idVal.split("_").pop());
      if (!Number.isNaN(idNum)) {
        internalStore.counts[type] = Math.max(
          internalStore.counts[type] ?? 0,
          idNum
        );
      }
    }
  }
  const su2 = new Proxy(
    {},
    {
      get: (proxy_target, component_type) => {
        if (component_type === "toArray") {
          return () => soup;
        }
        return {
          get: (id) => soup.find(
            (e) => e.type === component_type && e[`${component_type}_id`] === id
          ),
          getUsing: (using) => {
            const keys = Object.keys(using);
            if (keys.length !== 1) {
              throw new Error(
                "getUsing requires exactly one key, e.g. { pcb_component_id }"
              );
            }
            const join_key = keys[0];
            const join_type = join_key.replace("_id", "");
            const joiner = soup.find(
              (e) => e.type === join_type && e[join_key] === using[join_key]
            );
            if (!joiner)
              return null;
            return soup.find(
              (e) => e.type === component_type && e[`${component_type}_id`] === joiner[`${component_type}_id`]
            );
          },
          getWhere: (where) => {
            const keys = Object.keys(where);
            return soup.find(
              (e) => e.type === component_type && keys.every((key) => e[key] === where[key])
            );
          },
          list: (where) => {
            const keys = !where ? [] : Object.keys(where);
            return soup.filter(
              (e) => e.type === component_type && keys.every((key) => e[key] === where[key])
            );
          },
          insert: (elm) => {
            internalStore.counts[component_type] ??= -1;
            internalStore.counts[component_type]++;
            const index = internalStore.counts[component_type];
            const newElm = {
              type: component_type,
              [`${component_type}_id`]: `${component_type}_${index}`,
              ...elm
            };
            if (options.validateInserts) {
              const parser = Soup[component_type] ?? Soup.any_soup_element;
              parser.parse(newElm);
            }
            soup.push(newElm);
            return newElm;
          },
          delete: (id) => {
            const elm = soup.find(
              (e) => e[`${component_type}_id`] === id
            );
            if (!elm)
              return;
            soup.splice(soup.indexOf(elm), 1);
          },
          update: (id, newProps) => {
            const elm = soup.find(
              (e) => e[`${component_type}_id`] === id
            );
            if (!elm)
              return;
            Object.assign(elm, newProps);
            return elm;
          },
          select: (selector) => {
            if (component_type === "source_component") {
              return soup.find(
                (e) => e.type === "source_component" && e.name === selector.replace(/\./g, "")
              );
            } else if (component_type === "pcb_port" || component_type === "source_port" || component_type === "schematic_port") {
              const [component_name, port_selector] = selector.replace(/\./g, "").split(/[\s\>]+/);
              const source_component = soup.find(
                (e) => e.type === "source_component" && e.name === component_name
              );
              if (!source_component)
                return null;
              const source_port = soup.find(
                (e) => e.type === "source_port" && e.source_component_id === source_component.source_component_id && (e.name === port_selector || (e.port_hints ?? []).includes(port_selector))
              );
              if (!source_port)
                return null;
              if (component_type === "source_port")
                return source_port;
              if (component_type === "pcb_port") {
                return soup.find(
                  (e) => e.type === "pcb_port" && e.source_port_id === source_port.source_port_id
                );
              } else if (component_type === "schematic_port") {
                return soup.find(
                  (e) => e.type === "schematic_port" && e.source_port_id === source_port.source_port_id
                );
              }
            }
          }
        };
      }
    }
  );
  return su2;
};
su.unparsed = su;
var su_default = su;

// lib/transform-soup-elements.ts
import { applyToPoint, decomposeTSR } from "transformation-matrix";

// lib/direction-to-vec.ts
var directionToVec = (direction) => {
  if (direction === "up")
    return { x: 0, y: 1 };
  else if (direction === "down")
    return { x: 0, y: -1 };
  else if (direction === "left")
    return { x: -1, y: 0 };
  else if (direction === "right")
    return { x: 1, y: 0 };
  else
    throw new Error("Invalid direction");
};
var vecToDirection = ({ x, y }) => {
  if (x > y)
    y = 0;
  if (y > x)
    x = 0;
  if (x > 0 && y === 0)
    return "right";
  else if (x < 0 && y === 0)
    return "left";
  else if (x === 0 && y > 0)
    return "up";
  else if (x === 0 && y < 0)
    return "down";
  else
    throw new Error(`Invalid vector for direction conversion (${x}, ${y})`);
};
var rotateClockwise = (direction) => {
  if (direction === "up")
    return "right";
  else if (direction === "right")
    return "down";
  else if (direction === "down")
    return "left";
  else if (direction === "left")
    return "up";
  throw new Error(`Invalid direction: ${direction}`);
};
var rotateCounterClockwise = (direction) => {
  if (direction === "up")
    return "left";
  else if (direction === "left")
    return "down";
  else if (direction === "down")
    return "right";
  else if (direction === "right")
    return "up";
  throw new Error(`Invalid direction: ${direction}`);
};
var rotateDirection = (direction, num90DegreeClockwiseTurns) => {
  while (num90DegreeClockwiseTurns > 0) {
    direction = rotateClockwise(direction);
    num90DegreeClockwiseTurns--;
  }
  while (num90DegreeClockwiseTurns < 0) {
    direction = rotateCounterClockwise(direction);
    num90DegreeClockwiseTurns++;
  }
  return direction;
};
var oppositeDirection = (direction) => {
  if (direction === "up")
    return "down";
  else if (direction === "down")
    return "up";
  else if (direction === "left")
    return "right";
  else if (direction === "right")
    return "left";
  throw new Error(`Invalid direction: ${direction}`);
};
var oppositeSide = (sideOrDir) => {
  if (sideOrDir === "top" || sideOrDir === "up")
    return "bottom";
  else if (sideOrDir === "bottom" || sideOrDir === "down")
    return "top";
  else if (sideOrDir === "left")
    return "right";
  else if (sideOrDir === "right")
    return "left";
  throw new Error(`Invalid sideOrDir: ${sideOrDir}`);
};

// lib/transform-soup-elements.ts
var transformSchematicElement = (elm, matrix) => {
  if (elm.type === "schematic_component") {
    elm.center = applyToPoint(matrix, elm.center);
  } else if (elm.type === "schematic_port") {
    elm.center = applyToPoint(matrix, elm.center);
    if (elm.facing_direction) {
      elm.facing_direction = rotateDirection(
        elm.facing_direction,
        -(Math.atan2(matrix.b, matrix.a) / Math.PI) * 2
      );
    }
  } else if (elm.type === "schematic_text") {
    elm.position = applyToPoint(matrix, elm.position);
  } else if (elm.type === "schematic_trace") {
  } else if (elm.type === "schematic_box") {
    const { x, y } = applyToPoint(matrix, { x: elm.x, y: elm.y });
    elm.x = x;
    elm.y = y;
  } else if (elm.type === "schematic_line") {
    const { x: x1, y: y1 } = applyToPoint(matrix, { x: elm.x1, y: elm.y1 });
    const { x: x2, y: y2 } = applyToPoint(matrix, { x: elm.x2, y: elm.y2 });
    elm.x1 = x1;
    elm.y1 = y1;
    elm.x2 = x2;
    elm.y2 = y2;
  }
  return elm;
};
var transformSchematicElements = (elms, matrix) => {
  return elms.map((elm) => transformSchematicElement(elm, matrix));
};
var transformPCBElement = (elm, matrix) => {
  if (elm.type === "pcb_plated_hole" || elm.type === "pcb_hole" || elm.type === "pcb_via" || elm.type === "pcb_smtpad" || elm.type === "pcb_port") {
    const { x, y } = applyToPoint(matrix, { x: elm.x, y: elm.y });
    elm.x = x;
    elm.y = y;
  } else if (elm.type === "pcb_keepout" || elm.type === "pcb_board") {
    elm.center = applyToPoint(matrix, elm.center);
  } else if (elm.type === "pcb_silkscreen_text" || elm.type === "pcb_fabrication_note_text") {
    elm.anchor_position = applyToPoint(matrix, elm.anchor_position);
  } else if (elm.type === "pcb_silkscreen_circle" || elm.type === "pcb_silkscreen_rect" || elm.type === "pcb_component") {
    elm.center = applyToPoint(matrix, elm.center);
  } else if (elm.type === "pcb_silkscreen_path" || elm.type === "pcb_trace" || elm.type === "pcb_fabrication_note_path") {
    elm.route = elm.route.map((rp) => {
      const tp = applyToPoint(matrix, rp);
      rp.x = tp.x;
      rp.y = tp.y;
      return rp;
    });
  } else if (elm.type === "pcb_silkscreen_line") {
    const p1 = { x: elm.x1, y: elm.y1 };
    const p2 = { x: elm.x2, y: elm.y2 };
    const p1t = applyToPoint(matrix, p1);
    const p2t = applyToPoint(matrix, p2);
    elm.x1 = p1t.x;
    elm.y1 = p1t.y;
    elm.x2 = p2t.x;
    elm.y2 = p2t.y;
  } else if (elm.type === "cad_component") {
    const newPos = applyToPoint(matrix, {
      x: elm.position.x,
      y: elm.position.y
    });
    elm.position.x = newPos.x;
    elm.position.y = newPos.y;
  }
  return elm;
};
var transformPCBElements = (elms, matrix) => {
  const tsr = decomposeTSR(matrix);
  const flipPadWidthHeight = Math.round(tsr.rotation.angle / (Math.PI / 2)) % 2 === 1;
  let transformedElms = elms.map((elm) => transformPCBElement(elm, matrix));
  if (flipPadWidthHeight) {
    transformedElms = transformedElms.map((elm) => {
      if (elm.type === "pcb_smtpad" && elm.shape === "rect") {
        ;
        [elm.width, elm.height] = [elm.height, elm.width];
      }
      return elm;
    });
  }
  return transformedElms;
};

// lib/apply-selector.ts
import * as parsel from "parsel-js";

// lib/convert-abbreviation-to-soup-element-type.ts
var convertAbbrToType = (abbr) => {
  switch (abbr) {
    case "port":
      return "source_port";
    case "net":
      return "source_net";
    case "power":
      return "simple_power_source";
  }
  return abbr;
};

// lib/apply-selector.ts
var filterByType = (elements, type) => {
  type = convertAbbrToType(type);
  return elements.filter(
    (elm) => "ftype" in elm && elm.ftype === type || elm.type === type
  );
};
var applySelector = (elements, selectorRaw) => {
  const selectorAST = parsel.parse(selectorRaw);
  return applySelectorAST(elements, selectorAST);
};
var doesElmMatchClassName = (elm, className) => "name" in elm && elm.name === className || "port_hints" in elm && elm.port_hints?.includes(className);
var applySelectorAST = (elements, selectorAST) => {
  switch (selectorAST.type) {
    case "complex": {
      switch (selectorAST.combinator) {
        case " ":
        case ">": {
          const { left, right } = selectorAST;
          if (left.type === "class" || left.type === "type") {
            let matchElms;
            if (left.type === "class") {
              matchElms = elements.filter(
                (elm) => doesElmMatchClassName(elm, left.name)
              );
            } else if (left.type === "type") {
              matchElms = filterByType(elements, left.name);
            } else {
              matchElms = [];
            }
            const childrenOfMatchingElms = matchElms.flatMap(
              (matchElm) => elements.filter(
                (elm) => elm[`${matchElm.type}_id`] === matchElm[`${matchElm.type}_id`] && elm !== matchElm
              )
            );
            return applySelectorAST(childrenOfMatchingElms, right);
          } else {
            throw new Error(`unsupported selector type "${left.type}" `);
          }
        }
        default: {
          throw new Error(
            `Couldn't apply selector AST for complex combinator "${selectorAST.combinator}"`
          );
        }
      }
      return [];
    }
    case "compound": {
      const conditionsToMatch = selectorAST.list.map((part) => {
        switch (part.type) {
          case "class": {
            return (elm) => doesElmMatchClassName(elm, part.name);
          }
          case "type": {
            const name = convertAbbrToType(part.name);
            return (elm) => elm.type === name;
          }
        }
      });
      return elements.filter(
        (elm) => conditionsToMatch.every((condFn) => condFn?.(elm))
      );
    }
    case "type": {
      return filterByType(elements, selectorAST.name);
    }
    case "class": {
      return elements.filter(
        (elm) => doesElmMatchClassName(elm, selectorAST.name)
      );
    }
    default: {
      throw new Error(
        `Couldn't apply selector AST for type: "${selectorAST.type}" ${JSON.stringify(selectorAST, null, " ")}`
      );
    }
  }
};

// lib/get-element-id.ts
var getElementId = (elm) => {
  const type = elm.type;
  const id = elm[`${type}_id`];
  return id;
};

// lib/get-element-by-id.ts
var getElementById = (soup, id) => {
  return soup.find((elm) => getElementId(elm) === id) ?? null;
};

// lib/readable-name-functions/get-readable-name-for-pcb-trace.ts
function getReadableNameForPcbTrace(soup, pcb_trace_id) {
  const pcbTrace = su(soup).pcb_trace.get(pcb_trace_id);
  if (!pcbTrace) {
    return `trace[${pcb_trace_id}]`;
  }
  const connectedPcbPortIds = pcbTrace.route.flatMap((point) => [point.start_pcb_port_id, point.end_pcb_port_id]).filter(Boolean);
  if (connectedPcbPortIds.length === 0) {
    return `trace[${pcb_trace_id}]`;
  }
  function getComponentAndPortInfo(pcb_port_id) {
    const pcbPort = su(soup).pcb_port.get(pcb_port_id);
    if (!pcbPort)
      return null;
    const pcbComponent = su(soup).pcb_component.get(pcbPort.pcb_component_id);
    if (!pcbComponent)
      return null;
    const sourceComponent = su(soup).source_component.get(
      pcbComponent.source_component_id
    );
    if (!sourceComponent)
      return null;
    const sourcePort = su(soup).source_port.get(pcbPort.source_port_id);
    const portHint = sourcePort?.port_hints ? sourcePort.port_hints[1] : "";
    return {
      componentName: sourceComponent.name,
      portHint
    };
  }
  const selectorParts = connectedPcbPortIds.map((portId) => {
    const info = getComponentAndPortInfo(portId);
    if (info) {
      return `.${info.componentName} > port.${info.portHint}`;
    }
    return `port[${portId}]`;
  });
  return `trace[${selectorParts.join(", ")}]`;
}

// lib/readable-name-functions/get-readable-name-for-pcb-port.ts
var getReadableNameForPcbPort = (soup, pcb_port_id) => {
  const pcbPort = su(soup).pcb_port.get(pcb_port_id);
  if (!pcbPort) {
    return `pcb_port[#${pcb_port_id}]`;
  }
  const pcbComponent = su(soup).pcb_component.get(pcbPort?.pcb_component_id);
  if (!pcbComponent) {
    return `pcb_port[#${pcb_port_id}]`;
  }
  const sourceComponent = su(soup).source_component.get(
    pcbComponent.source_component_id
  );
  if (!sourceComponent) {
    return `pcb_port[#${pcb_port_id}]`;
  }
  const sourcePort = su(soup).source_port.get(pcbPort.source_port_id);
  if (!sourcePort) {
    return `pcb_port[#${pcb_port_id}]`;
  }
  let padIdentifier;
  if (sourcePort?.port_hints && sourcePort.port_hints.length > 0) {
    padIdentifier = sourcePort.port_hints[0];
  } else if (sourcePort.port_hints && sourcePort.port_hints.length > 0) {
    padIdentifier = sourcePort.port_hints[0];
  } else {
    padIdentifier = pcb_port_id;
  }
  return `pcb_port[.${sourceComponent.name} > .${padIdentifier}]`;
};

// lib/readable-name-functions/get-readable-name-for-pcb-smtpad.ts
function getReadableNameForPcbSmtpad(soup, pcb_smtpad_id) {
  const pcbSmtpad = su(soup).pcb_smtpad.get(pcb_smtpad_id);
  if (!pcbSmtpad || !pcbSmtpad.pcb_port_id) {
    return `smtpad[${pcb_smtpad_id}]`;
  }
  return getReadableNameForPcbPort(soup, pcbSmtpad.pcb_port_id);
}

// lib/readable-name-functions/get-readable-name-for-element.ts
var getReadableNameForElement = (soup, elm) => {
  if (typeof elm === "string") {
    const elmObj = getElementById(soup, elm);
    if (!elmObj)
      `unknown (could not find element with id ${elm})`;
    return getReadableNameForElement(soup, elmObj);
  }
  switch (elm.type) {
    case "pcb_port":
      return getReadableNameForPcbPort(soup, elm.pcb_port_id);
    case "pcb_smtpad":
      return getReadableNameForPcbSmtpad(soup, elm.pcb_smtpad_id);
    case "pcb_trace":
      return getReadableNameForPcbTrace(soup, elm.pcb_trace_id);
    case "source_component":
      return `source_component[${elm.name}]`;
    default:
      return `${elm.type}[#${getElementId(elm)}]`;
  }
};

// lib/get-bounds-of-pcb-elements.ts
var getBoundsOfPcbElements = (elements) => {
  let minX = Number.POSITIVE_INFINITY;
  let minY = Number.POSITIVE_INFINITY;
  let maxX = Number.NEGATIVE_INFINITY;
  let maxY = Number.NEGATIVE_INFINITY;
  for (const elm of elements) {
    if (!elm.type.startsWith("pcb_"))
      continue;
    if ("x" in elm && "y" in elm) {
      minX = Math.min(minX, elm.x);
      minY = Math.min(minY, elm.y);
      maxX = Math.max(maxX, elm.x);
      maxY = Math.max(maxY, elm.y);
      if ("width" in elm) {
        maxX = Math.max(maxX, elm.x + elm.width);
      }
      if ("height" in elm) {
        maxY = Math.max(maxY, elm.y + elm.height);
      }
      if ("radius" in elm) {
        minX = Math.min(minX, elm.x - elm.radius);
        minY = Math.min(minY, elm.y - elm.radius);
        maxX = Math.max(maxX, elm.x + elm.radius);
        maxY = Math.max(maxY, elm.y + elm.radius);
      }
    } else if (elm.type === "pcb_trace") {
      for (const point of elm.route) {
        minX = Math.min(minX, point.x);
        minY = Math.min(minY, point.y);
        maxX = Math.max(maxX, point.x);
        maxY = Math.max(maxY, point.y);
      }
    }
  }
  return { minX, minY, maxX, maxY };
};

// lib/utils/string-hash.ts
function stringHash(str) {
  let hash = 0;
  if (str.length == 0)
    return hash;
  for (var i = 0; i < str.length; i++) {
    var char = str.charCodeAt(i);
    hash = (hash << 5) - hash + char;
    hash = hash & hash;
  }
  return Math.abs(hash);
}

// lib/utils/get-layout-debug-object.ts
var nice_color_palettes = [
  ["#69d2e7", "#a7dbd8", "#e0e4cc", "#f38630", "#fa6900"],
  ["#fe4365", "#fc9d9a", "#f9cdad", "#c8c8a9", "#83af9b"],
  ["#ecd078", "#d95b43", "#c02942", "#542437", "#53777a"],
  ["#556270", "#4ecdc4", "#c7f464", "#ff6b6b", "#c44d58"],
  ["#774f38", "#e08e79", "#f1d4af", "#ece5ce", "#c5e0dc"],
  ["#e8ddcb", "#cdb380", "#036564", "#033649", "#031634"],
  ["#490a3d", "#bd1550", "#e97f02", "#f8ca00", "#8a9b0f"],
  ["#594f4f", "#547980", "#45ada8", "#9de0ad", "#e5fcc2"],
  ["#00a0b0", "#6a4a3c", "#cc333f", "#eb6841", "#edc951"],
  ["#e94e77", "#d68189", "#c6a49a", "#c6e5d9", "#f4ead5"],
  ["#3fb8af", "#7fc7af", "#dad8a7", "#ff9e9d", "#ff3d7f"],
  ["#d9ceb2", "#948c75", "#d5ded9", "#7a6a53", "#99b2b7"],
  ["#ffffff", "#cbe86b", "#f2e9e1", "#1c140d", "#cbe86b"],
  ["#efffcd", "#dce9be", "#555152", "#2e2633", "#99173c"],
  ["#343838", "#005f6b", "#008c9e", "#00b4cc", "#00dffc"],
  ["#413e4a", "#73626e", "#b38184", "#f0b49e", "#f7e4be"],
  ["#ff4e50", "#fc913a", "#f9d423", "#ede574", "#e1f5c4"],
  ["#99b898", "#fecea8", "#ff847c", "#e84a5f", "#2a363b"],
  ["#655643", "#80bca3", "#f6f7bd", "#e6ac27", "#bf4d28"],
  ["#00a8c6", "#40c0cb", "#f9f2e7", "#aee239", "#8fbe00"],
  ["#351330", "#424254", "#64908a", "#e8caa4", "#cc2a41"],
  ["#554236", "#f77825", "#d3ce3d", "#f1efa5", "#60b99a"],
  ["#5d4157", "#838689", "#a8caba", "#cad7b2", "#ebe3aa"],
  ["#8c2318", "#5e8c6a", "#88a65e", "#bfb35a", "#f2c45a"],
  ["#fad089", "#ff9c5b", "#f5634a", "#ed303c", "#3b8183"],
  ["#ff4242", "#f4fad2", "#d4ee5e", "#e1edb9", "#f0f2eb"],
  ["#f8b195", "#f67280", "#c06c84", "#6c5b7b", "#355c7d"],
  ["#d1e751", "#ffffff", "#000000", "#4dbce9", "#26ade4"],
  ["#1b676b", "#519548", "#88c425", "#bef202", "#eafde6"],
  ["#5e412f", "#fcebb6", "#78c0a8", "#f07818", "#f0a830"],
  ["#bcbdac", "#cfbe27", "#f27435", "#f02475", "#3b2d38"],
  ["#452632", "#91204d", "#e4844a", "#e8bf56", "#e2f7ce"],
  ["#eee6ab", "#c5bc8e", "#696758", "#45484b", "#36393b"],
  ["#f0d8a8", "#3d1c00", "#86b8b1", "#f2d694", "#fa2a00"],
  ["#2a044a", "#0b2e59", "#0d6759", "#7ab317", "#a0c55f"],
  ["#f04155", "#ff823a", "#f2f26f", "#fff7bd", "#95cfb7"],
  ["#b9d7d9", "#668284", "#2a2829", "#493736", "#7b3b3b"],
  ["#bbbb88", "#ccc68d", "#eedd99", "#eec290", "#eeaa88"],
  ["#b3cc57", "#ecf081", "#ffbe40", "#ef746f", "#ab3e5b"],
  ["#a3a948", "#edb92e", "#f85931", "#ce1836", "#009989"],
  ["#300030", "#480048", "#601848", "#c04848", "#f07241"],
  ["#67917a", "#170409", "#b8af03", "#ccbf82", "#e33258"],
  ["#aab3ab", "#c4cbb7", "#ebefc9", "#eee0b7", "#e8caaf"],
  ["#e8d5b7", "#0e2430", "#fc3a51", "#f5b349", "#e8d5b9"],
  ["#ab526b", "#bca297", "#c5ceae", "#f0e2a4", "#f4ebc3"],
  ["#607848", "#789048", "#c0d860", "#f0f0d8", "#604848"],
  ["#b6d8c0", "#c8d9bf", "#dadabd", "#ecdbbc", "#fedcba"],
  ["#a8e6ce", "#dcedc2", "#ffd3b5", "#ffaaa6", "#ff8c94"],
  ["#3e4147", "#fffedf", "#dfba69", "#5a2e2e", "#2a2c31"],
  ["#fc354c", "#29221f", "#13747d", "#0abfbc", "#fcf7c5"],
  ["#cc0c39", "#e6781e", "#c8cf02", "#f8fcc1", "#1693a7"],
  ["#1c2130", "#028f76", "#b3e099", "#ffeaad", "#d14334"],
  ["#a7c5bd", "#e5ddcb", "#eb7b59", "#cf4647", "#524656"],
  ["#dad6ca", "#1bb0ce", "#4f8699", "#6a5e72", "#563444"],
  ["#5c323e", "#a82743", "#e15e32", "#c0d23e", "#e5f04c"],
  ["#edebe6", "#d6e1c7", "#94c7b6", "#403b33", "#d3643b"],
  ["#fdf1cc", "#c6d6b8", "#987f69", "#e3ad40", "#fcd036"],
  ["#230f2b", "#f21d41", "#ebebbc", "#bce3c5", "#82b3ae"],
  ["#b9d3b0", "#81bda4", "#b28774", "#f88f79", "#f6aa93"],
  ["#3a111c", "#574951", "#83988e", "#bcdea5", "#e6f9bc"],
  ["#5e3929", "#cd8c52", "#b7d1a3", "#dee8be", "#fcf7d3"],
  ["#1c0113", "#6b0103", "#a30006", "#c21a01", "#f03c02"],
  ["#000000", "#9f111b", "#b11623", "#292c37", "#cccccc"],
  ["#382f32", "#ffeaf2", "#fcd9e5", "#fbc5d8", "#f1396d"],
  ["#e3dfba", "#c8d6bf", "#93ccc6", "#6cbdb5", "#1a1f1e"],
  ["#f6f6f6", "#e8e8e8", "#333333", "#990100", "#b90504"],
  ["#1b325f", "#9cc4e4", "#e9f2f9", "#3a89c9", "#f26c4f"],
  ["#a1dbb2", "#fee5ad", "#faca66", "#f7a541", "#f45d4c"],
  ["#c1b398", "#605951", "#fbeec2", "#61a6ab", "#accec0"],
  ["#5e9fa3", "#dcd1b4", "#fab87f", "#f87e7b", "#b05574"],
  ["#951f2b", "#f5f4d7", "#e0dfb1", "#a5a36c", "#535233"],
  ["#8dccad", "#988864", "#fea6a2", "#f9d6ac", "#ffe9af"],
  ["#2d2d29", "#215a6d", "#3ca2a2", "#92c7a3", "#dfece6"],
  ["#413d3d", "#040004", "#c8ff00", "#fa023c", "#4b000f"],
  ["#eff3cd", "#b2d5ba", "#61ada0", "#248f8d", "#605063"],
  ["#ffefd3", "#fffee4", "#d0ecea", "#9fd6d2", "#8b7a5e"],
  ["#cfffdd", "#b4dec1", "#5c5863", "#a85163", "#ff1f4c"],
  ["#9dc9ac", "#fffec7", "#f56218", "#ff9d2e", "#919167"],
  ["#4e395d", "#827085", "#8ebe94", "#ccfc8e", "#dc5b3e"],
  ["#a8a7a7", "#cc527a", "#e8175d", "#474747", "#363636"],
  ["#f8edd1", "#d88a8a", "#474843", "#9d9d93", "#c5cfc6"],
  ["#046d8b", "#309292", "#2fb8ac", "#93a42a", "#ecbe13"],
  ["#f38a8a", "#55443d", "#a0cab5", "#cde9ca", "#f1edd0"],
  ["#a70267", "#f10c49", "#fb6b41", "#f6d86b", "#339194"],
  ["#ff003c", "#ff8a00", "#fabe28", "#88c100", "#00c176"],
  ["#ffedbf", "#f7803c", "#f54828", "#2e0d23", "#f8e4c1"],
  ["#4e4d4a", "#353432", "#94ba65", "#2790b0", "#2b4e72"],
  ["#0ca5b0", "#4e3f30", "#fefeeb", "#f8f4e4", "#a5b3aa"],
  ["#4d3b3b", "#de6262", "#ffb88c", "#ffd0b3", "#f5e0d3"],
  ["#fffbb7", "#a6f6af", "#66b6ab", "#5b7c8d", "#4f2958"],
  ["#edf6ee", "#d1c089", "#b3204d", "#412e28", "#151101"],
  ["#9d7e79", "#ccac95", "#9a947c", "#748b83", "#5b756c"],
  ["#fcfef5", "#e9ffe1", "#cdcfb7", "#d6e6c3", "#fafbe3"],
  ["#9cddc8", "#bfd8ad", "#ddd9ab", "#f7af63", "#633d2e"],
  ["#30261c", "#403831", "#36544f", "#1f5f61", "#0b8185"],
  ["#aaff00", "#ffaa00", "#ff00aa", "#aa00ff", "#00aaff"],
  ["#d1313d", "#e5625c", "#f9bf76", "#8eb2c5", "#615375"],
  ["#ffe181", "#eee9e5", "#fad3b2", "#ffba7f", "#ff9c97"],
  ["#73c8a9", "#dee1b6", "#e1b866", "#bd5532", "#373b44"],
  ["#805841", "#dcf7f3", "#fffcdd", "#ffd8d8", "#f5a2a2"]
];
var getDebugLayoutObject = (lo) => {
  let {
    x,
    y,
    width,
    height
  } = {
    ...lo,
    ...lo.size,
    ...lo.center,
    ...lo.position
  };
  if (lo.x1 !== void 0 && lo.x2 !== void 0 && lo.y1 !== void 0 && lo.y2 !== void 0) {
    x = (lo.x1 + lo.x2) / 2;
    y = (lo.y1 + lo.y2) / 2;
    width = Math.abs(lo.x1 - lo.x2);
    height = Math.abs(lo.y1 - lo.y2);
  }
  const title = lo.text || lo.name || lo.source?.text || lo.source?.name || "?";
  const content = lo;
  if (x === void 0 || y === void 0)
    return null;
  if (width === void 0) {
    if ("outer_diameter" in lo) {
      width = lo.outer_diameter;
      height = lo.outer_diameter;
    }
  }
  if (width === void 0 || height === void 0) {
    width = 0.1;
    height = 0.1;
  }
  return {
    x,
    y,
    width,
    height,
    title,
    content,
    bg_color: nice_color_palettes[stringHash(lo.type || title) % nice_color_palettes.length]?.[4] ?? "#f00"
  };
};

// lib/utils/is-truthy.ts
var isTruthy = (value) => Boolean(value);

// lib/find-bounds-and-center.ts
var findBoundsAndCenter = (elements) => {
  const debugObjects = elements.filter((elm) => elm.type.startsWith("pcb_")).concat(
    elements.filter((elm) => elm.type === "pcb_trace").flatMap((elm) => elm.route)
  ).map((elm) => getDebugLayoutObject(elm)).filter(isTruthy);
  if (debugObjects.length === 0)
    return { center: { x: 0, y: 0 }, width: 0, height: 0 };
  let minX = debugObjects[0].x - debugObjects[0].width / 2;
  let maxX = debugObjects[0].x + debugObjects[0].width / 2;
  let minY = debugObjects[0].y - debugObjects[0].height / 2;
  let maxY = debugObjects[0].y + debugObjects[0].height / 2;
  for (const obj of debugObjects.slice(1)) {
    minX = Math.min(minX, obj.x - obj.width / 2);
    maxX = Math.max(maxX, obj.x + obj.width / 2);
    minY = Math.min(minY, obj.y - obj.height / 2);
    maxY = Math.max(maxY, obj.y + obj.height / 2);
  }
  const width = maxX - minX;
  const height = maxY - minY;
  const center = { x: minX + width / 2, y: minY + height / 2 };
  return { center, width, height };
};
export {
  applySelector,
  applySelectorAST,
  directionToVec,
  findBoundsAndCenter,
  getBoundsOfPcbElements,
  getElementById,
  getElementId,
  getReadableNameForElement,
  getReadableNameForPcbPort,
  getReadableNameForPcbSmtpad,
  getReadableNameForPcbTrace,
  oppositeDirection,
  oppositeSide,
  rotateClockwise,
  rotateCounterClockwise,
  rotateDirection,
  su_default as su,
  transformPCBElement,
  transformPCBElements,
  transformSchematicElement,
  transformSchematicElements,
  vecToDirection
};
//# sourceMappingURL=index.js.map