var __defProp = Object.defineProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};

// lib/solvers/BaseSolver.ts
var BaseSolver = class {
  MAX_ITERATIONS = 1e3;
  solved = false;
  failed = false;
  iterations = 0;
  progress = 0;
  error = null;
  _activeSubSolver;
  usedSubSolvers = [];
  failedSubSolvers;
  timeToSolve;
  stats = {};
  /** DO NOT OVERRIDE! Override _step() instead */
  step() {
    if (this.solved) return;
    if (this.failed) return;
    this.iterations++;
    try {
      this._step();
    } catch (e) {
      this.error = `${this.constructor.name} error: ${e}`;
      console.error(this.error);
      this.failed = true;
      throw e;
    }
    if (!this.solved && this.iterations > this.MAX_ITERATIONS) {
      this.error = `${this.constructor.name} ran out of iterations`;
      console.error(this.error);
      this.failed = true;
    }
    if ("computeProgress" in this) {
      this.progress = this.computeProgress();
    }
  }
  _step() {
  }
  getStatsSummary() {
    return `${this.iterations} iterations`;
  }
  get activeSubSolver() {
    return this._activeSubSolver;
  }
  getConstructorParams() {
    throw new Error("getConstructorParams not implemented");
  }
  clearActiveSubSolver() {
    this._activeSubSolver = null;
  }
  setActiveSubSolver(subSolver) {
    this._activeSubSolver = subSolver;
    if (subSolver) {
      this.usedSubSolvers.push(subSolver);
    }
  }
  visualize() {
    return [];
  }
  solve() {
    const startTime = Date.now();
    while (!this.solved && !this.failed) {
      this.step();
    }
    const endTime = Date.now();
    this.timeToSolve = endTime - startTime;
  }
};

// lib/netlist/NetlistBuilder.ts
var NetlistBuilder = class {
  netlist;
  constructor() {
    this.netlist = {
      boxes: [],
      nets: [],
      connections: []
    };
  }
  addBox(box) {
    if (!this.netlist.boxes.find((b) => b.boxId === box.boxId)) {
      this.netlist.boxes.push(box);
    }
  }
  addNet(net) {
    const existing = this.netlist.nets.find((n) => n.netId === net.netId);
    if (existing) {
      if (net.isGround) existing.isGround = true;
      if (net.isPositivePower) existing.isPositivePower = true;
    } else {
      this.netlist.nets.push(net);
    }
  }
  // Helper: Check if two port references are the same
  areSamePortRef(a, b) {
    if ("boxId" in a && "boxId" in b) {
      return a.boxId === b.boxId && a.pinNumber === b.pinNumber;
    }
    if ("netId" in a && "netId" in b) {
      return a.netId === b.netId;
    }
    if ("junctionId" in a && "junctionId" in b) {
      return a.junctionId === b.junctionId;
    }
    return false;
  }
  // Helper: Check if a port is in a given connection
  isPortInConnection(port, connection) {
    return connection.connectedPorts.some(
      (p) => this.areSamePortRef(port, p)
    );
  }
  // Helper: Find the connection that contains a given port
  findConnectionContaining(port) {
    return this.netlist.connections.find(
      (conn) => this.isPortInConnection(port, conn)
    );
  }
  connect(port1PRef, port2PRef) {
    if (!port1PRef || !port2PRef || this.areSamePortRef(port1PRef, port2PRef)) {
      return;
    }
    const port1 = "junctionId" in port1PRef ? { netId: port1PRef.junctionId } : port1PRef;
    const port2 = "junctionId" in port2PRef ? { netId: port2PRef.junctionId } : port2PRef;
    const conn1 = this.findConnectionContaining(port1);
    const conn2 = this.findConnectionContaining(port2);
    if (conn1 && conn2) {
      if (conn1 === conn2) {
        return;
      }
      for (const p of conn2.connectedPorts) {
        if (!this.isPortInConnection(p, conn1)) {
          conn1.connectedPorts.push(p);
        }
      }
      this.netlist.connections = this.netlist.connections.filter(
        (c) => c !== conn2
      );
    } else if (conn1) {
      if (!this.isPortInConnection(port2, conn1)) {
        conn1.connectedPorts.push(port2);
      }
    } else if (conn2) {
      if (!this.isPortInConnection(port1, conn2)) {
        conn2.connectedPorts.push(port1);
      }
    } else {
      this.netlist.connections.push({
        connectedPorts: [port1, port2]
      });
    }
  }
  getNetlist() {
    return structuredClone(this.netlist);
  }
};

// lib/netlist/getReadableNetlist.ts
var getPinConnectionLabel = (boxId, pinNumber, connections) => {
  const relevantConnections = connections.filter(
    (conn) => conn.connectedPorts.some(
      (p) => "boxId" in p && p.boxId === boxId && p.pinNumber === pinNumber
    )
  );
  if (relevantConnections.length === 0) {
    return null;
  }
  if (relevantConnections.length > 1) {
    return "...";
  }
  const connection = relevantConnections[0];
  const otherPorts = connection.connectedPorts.filter((p) => {
    if ("boxId" in p && typeof p.boxId === "string" && typeof p.pinNumber === "number") {
      return !(p.boxId === boxId && p.pinNumber === pinNumber);
    }
    return true;
  });
  if (otherPorts.length === 0) {
    return null;
  }
  const connectionsString = otherPorts.map((p) => {
    if ("boxId" in p && typeof p.boxId === "string") {
      return `${p.boxId}.${p.pinNumber}`;
    }
    if ("netId" in p && typeof p.netId === "string") {
      return p.netId;
    }
    return null;
  }).filter(Boolean).join(",");
  return connectionsString.length > 14 ? `${connectionsString.substring(0, 13)}\u2026` : connectionsString;
};
var formatCell = (content, cellWidth) => {
  const contentLen = content.length;
  if (contentLen >= cellWidth) {
    return content.substring(0, cellWidth > 0 ? cellWidth : 0);
  }
  const paddingTotal = cellWidth - contentLen;
  const paddingLeft = Math.floor(paddingTotal / 2);
  const paddingRight = paddingTotal - paddingLeft;
  return " ".repeat(paddingLeft) + content + " ".repeat(paddingRight);
};
var drawBoxAscii = (box, connections) => {
  const output = [];
  const { boxId, leftPinCount, rightPinCount, topPinCount, bottomPinCount } = box;
  const BOX_INNER_WIDTH = 16;
  const SIDE_PADDING_WIDTH = 20;
  const lp = leftPinCount;
  const rp = rightPinCount;
  const tp = topPinCount;
  const bp = bottomPinCount;
  const bodyHeight = Math.max(lp, rp, 1);
  const maxDisplayableBoxIdLength = BOX_INNER_WIDTH - 2;
  let displayBoxId = boxId;
  if (boxId.length > maxDisplayableBoxIdLength) {
    displayBoxId = `${boxId.substring(0, maxDisplayableBoxIdLength - 1)}\u2026`;
  }
  const innerWidth = BOX_INNER_WIDTH;
  if (tp > 0) {
    let labelsRow = "";
    let pinsRow = "";
    let connectorsRow = "";
    const baseCellWidth = Math.floor(innerWidth / tp);
    const remainderCells = innerWidth % tp;
    const cellWidths = Array(tp).fill(baseCellWidth);
    for (let i = 0; i < remainderCells; i++) {
      cellWidths[i % tp]++;
    }
    for (let i = 0; i < tp; i++) {
      const currentTopPinNumber = lp + bp + rp + i + 1;
      const pinStr = currentTopPinNumber.toString();
      const connLabel = getPinConnectionLabel(boxId, currentTopPinNumber, connections) ?? "";
      const cellWidth = cellWidths[i];
      labelsRow += formatCell(connLabel, cellWidth);
      pinsRow += formatCell(pinStr, cellWidth);
      connectorsRow += formatCell("\u2502", cellWidth);
    }
    output.push(" ".repeat(SIDE_PADDING_WIDTH + 1) + labelsRow);
    output.push(" ".repeat(SIDE_PADDING_WIDTH + 1) + connectorsRow);
    output.push(" ".repeat(SIDE_PADDING_WIDTH + 1) + pinsRow);
  }
  output.push(`${" ".repeat(SIDE_PADDING_WIDTH)}\u250C${"\u2500".repeat(innerWidth)}\u2510`);
  for (let i = 0; i < bodyHeight; i++) {
    const currentLeftPinNumber = i < lp ? i + 1 : 0;
    const currentRightPinNumber = i < rp ? lp + bp + (rp - 1 - i) + 1 : 0;
    const leftPinLabel = currentLeftPinNumber > 0 ? currentLeftPinNumber.toString() : "";
    const rightPinLabel = currentRightPinNumber > 0 ? currentRightPinNumber.toString() : "";
    let leftDecorator = "";
    if (currentLeftPinNumber > 0) {
      const label = getPinConnectionLabel(
        boxId,
        currentLeftPinNumber,
        connections
      );
      if (label) {
        leftDecorator = `${label} \u2500\u2500 `;
      }
    }
    let rightDecorator = "";
    if (currentRightPinNumber > 0) {
      const label = getPinConnectionLabel(
        boxId,
        currentRightPinNumber,
        connections
      );
      if (label) {
        rightDecorator = ` \u2500\u2500 ${label}`;
      }
    }
    let lineContent = "";
    if (i === Math.floor((bodyHeight - 1) / 2)) {
      const paddingLeft = Math.floor((innerWidth - displayBoxId.length) / 2);
      const paddingRight = innerWidth - displayBoxId.length - paddingLeft;
      lineContent = " ".repeat(paddingLeft) + displayBoxId + " ".repeat(paddingRight);
    } else {
      lineContent = " ".repeat(innerWidth);
    }
    const leftPinDisplay = leftPinLabel.padStart(2);
    const rightPinDisplay = rightPinLabel.padEnd(2);
    const leftPart = `${leftDecorator}${leftPinDisplay}`;
    const rightPart = `${rightPinDisplay}${rightDecorator}`;
    const paddedLeftFull = leftPart.padStart(SIDE_PADDING_WIDTH);
    const paddedRightFull = rightPart.padEnd(SIDE_PADDING_WIDTH);
    output.push(`${paddedLeftFull}\u2502${lineContent}\u2502${paddedRightFull}`);
  }
  output.push(`${" ".repeat(SIDE_PADDING_WIDTH)}\u2514${"\u2500".repeat(innerWidth)}\u2518`);
  if (bp > 0) {
    let labelsRow = "";
    let pinsRow = "";
    let connectorsRow = "";
    const baseCellWidth = Math.floor(innerWidth / bp);
    const remainderCells = innerWidth % bp;
    const cellWidths = Array(bp).fill(baseCellWidth);
    for (let i = 0; i < remainderCells; i++) {
      cellWidths[i % bp]++;
    }
    for (let i = 0; i < bp; i++) {
      const currentBottomPinNumber = lp + i + 1;
      const pinStr = currentBottomPinNumber.toString();
      const connLabel = getPinConnectionLabel(boxId, currentBottomPinNumber, connections) ?? "";
      const cellWidth = cellWidths[i];
      labelsRow += formatCell(connLabel, cellWidth);
      pinsRow += formatCell(pinStr, cellWidth);
      connectorsRow += formatCell("\u2502", cellWidth);
    }
    output.push(" ".repeat(SIDE_PADDING_WIDTH + 1) + pinsRow);
    output.push(" ".repeat(SIDE_PADDING_WIDTH + 1) + connectorsRow);
    output.push(" ".repeat(SIDE_PADDING_WIDTH + 1) + labelsRow);
  }
  return output;
};
var getReadableNetlist = (netlist) => {
  const lines = [];
  lines.push("Boxes:");
  if (netlist.boxes.length === 0) {
    lines.push("  (none)");
  } else {
    for (const box of netlist.boxes) {
      lines.push("\n");
      const boxArtLines = drawBoxAscii(box, netlist.connections);
      for (const artLine of boxArtLines) {
        lines.push(`  ${artLine}`);
      }
    }
  }
  lines.push("");
  const complexConnections = netlist.connections.filter(
    (conn) => conn.connectedPorts.length > 2
  );
  lines.push("Complex Connections (more than 2 points):");
  if (complexConnections.length === 0) {
    lines.push("  (none)");
  } else {
    for (let i = 0; i < complexConnections.length; i++) {
      const connection = complexConnections[i];
      lines.push(`  - complex connection[${i}]:`);
      for (const port of connection.connectedPorts) {
        if ("boxId" in port) {
          lines.push(`    - ${port.boxId}.${port.pinNumber}`);
        } else if ("netId" in port) {
          lines.push(`    - ${port.netId}`);
        }
      }
    }
  }
  return lines.join("\n");
};

// lib/adapt/detectPassiveOrientation.ts
function detectPassiveOrientation(chip) {
  if (!chip.isPassive) {
    throw new Error(`Chip ${chip.chipId} is not a passive component`);
  }
  if (chip.leftPinCount > 0 || chip.rightPinCount > 0) {
    return "horizontal";
  } else {
    return "vertical";
  }
}

// lib/matching/computeSimilarityDistanceFromIssues.ts
function computeSimilarityDistanceFromIssues(issues) {
  return issues.length;
}

// lib/builder/circuit-types.ts
var SIDES_CCW = ["left", "bottom", "right", "top"];

// lib/builder/getPinSideIndex.ts
var getPinSideIndex = (pinNumber, chipDimensions) => {
  let currentSideIndex = 0;
  let currentIndexOnSide = 0;
  for (let i = 0; i < pinNumber && currentSideIndex < 4; ) {
    const currentSide = SIDES_CCW[currentSideIndex];
    const currentSideDimensions = chipDimensions[`${currentSide}PinCount`];
    if (currentSideDimensions === void 0 || currentSideDimensions === 0) {
      currentSideIndex++;
      continue;
    }
    if (currentIndexOnSide >= currentSideDimensions) {
      currentSideIndex++;
      currentIndexOnSide = 0;
      continue;
    }
    if (i + 1 === pinNumber) {
      const result = {
        side: currentSide,
        indexOnSide: currentIndexOnSide
      };
      if (currentSide === "left") {
        result.indexFromTop = currentIndexOnSide;
      } else if (currentSide === "right") {
        result.indexFromTop = chipDimensions.rightPinCount - currentIndexOnSide - 1;
      }
      if (currentSide === "bottom") {
        result.indexFromLeft = currentIndexOnSide;
      } else if (currentSide === "top") {
        result.indexFromLeft = chipDimensions.topPinCount - currentIndexOnSide - 1;
      }
      return result;
    }
    currentIndexOnSide++;
    i++;
  }
  throw new Error(
    `Pin number out of bounds: ${pinNumber} with dimensions left=${chipDimensions.leftPinCount}, right=${chipDimensions.rightPinCount}, top=${chipDimensions.topPinCount}, bottom=${chipDimensions.bottomPinCount}`
  );
};

// lib/utils/SimplePathfinder.ts
var CELL_SIZE = 0.5;
var DIRECTION_CHANGE_PENALTY = 0.3;
var SimplePathfinder = class {
  obstacles = [];
  addObstacle(obstacle) {
    this.obstacles.push(obstacle);
  }
  clearObstacles() {
    this.obstacles = [];
  }
  findPath(start, end) {
    const startGrid = this.worldToGrid(start);
    const endGrid = this.worldToGrid(end);
    const openSet = /* @__PURE__ */ new Set();
    const closedSet = /* @__PURE__ */ new Set();
    const nodeMap = /* @__PURE__ */ new Map();
    const startNode = {
      point: startGrid,
      gCost: 0,
      hCost: this.getHeuristic(startGrid, endGrid),
      fCost: 0,
      parent: null,
      direction: null
    };
    startNode.fCost = startNode.gCost + startNode.hCost;
    const startKey = this.pointToKey(startGrid);
    openSet.add(startKey);
    nodeMap.set(startKey, startNode);
    let iterations = 0;
    const maxIterations = 200;
    const maxDistance = Math.min(
      this.getHeuristic(startGrid, endGrid) * 2,
      10 / CELL_SIZE
    );
    while (openSet.size > 0 && iterations < maxIterations) {
      iterations++;
      let currentKey = Array.from(openSet)[0];
      let currentNode = nodeMap.get(currentKey);
      for (const key of openSet) {
        const node = nodeMap.get(key);
        if (node.fCost < currentNode.fCost || node.fCost === currentNode.fCost && node.hCost < currentNode.hCost) {
          currentKey = key;
          currentNode = node;
        }
      }
      openSet.delete(currentKey);
      closedSet.add(currentKey);
      if (currentNode.point.x === endGrid.x && currentNode.point.y === endGrid.y) {
        return this.reconstructPath(currentNode);
      }
      if (currentNode.gCost > maxDistance) {
        continue;
      }
      const neighbors = this.getNeighbors(currentNode.point);
      for (const neighborPoint of neighbors) {
        const neighborKey = this.pointToKey(neighborPoint);
        if (closedSet.has(neighborKey) || this.isObstacle(neighborPoint)) {
          continue;
        }
        const direction = this.getDirection(currentNode.point, neighborPoint);
        let movementCost = 1;
        if (currentNode.direction && currentNode.direction !== direction) {
          movementCost += DIRECTION_CHANGE_PENALTY;
        }
        const newGCost = currentNode.gCost + movementCost;
        if (!openSet.has(neighborKey)) {
          const neighborNode = {
            point: neighborPoint,
            gCost: newGCost,
            hCost: this.getHeuristic(neighborPoint, endGrid),
            fCost: 0,
            parent: currentNode,
            direction
          };
          neighborNode.fCost = neighborNode.gCost + neighborNode.hCost;
          openSet.add(neighborKey);
          nodeMap.set(neighborKey, neighborNode);
        } else {
          const existingNode = nodeMap.get(neighborKey);
          if (newGCost < existingNode.gCost) {
            existingNode.gCost = newGCost;
            existingNode.fCost = existingNode.gCost + existingNode.hCost;
            existingNode.parent = currentNode;
            existingNode.direction = direction;
          }
        }
      }
    }
    if (iterations >= maxIterations) {
      console.warn(`Pathfinding exceeded max iterations (${maxIterations})`);
    }
    return [];
  }
  worldToGrid(point) {
    return {
      x: Math.round(point.x / CELL_SIZE),
      y: Math.round(point.y / CELL_SIZE)
    };
  }
  gridToWorld(point) {
    return {
      x: point.x * CELL_SIZE,
      y: point.y * CELL_SIZE
    };
  }
  pointToKey(point) {
    return `${point.x},${point.y}`;
  }
  getHeuristic(a, b) {
    return Math.abs(a.x - b.x) + Math.abs(a.y - b.y);
  }
  getNeighbors(point) {
    return [
      { x: point.x, y: point.y + 1 },
      // up
      { x: point.x, y: point.y - 1 },
      // down
      { x: point.x - 1, y: point.y },
      // left
      { x: point.x + 1, y: point.y }
      // right
    ];
  }
  getDirection(from, to) {
    if (to.y > from.y) return "up";
    if (to.y < from.y) return "down";
    if (to.x < from.x) return "left";
    return "right";
  }
  isObstacle(point) {
    const worldPoint = this.gridToWorld(point);
    return this.obstacles.some(
      (obstacle) => worldPoint.x >= obstacle.minX && worldPoint.x <= obstacle.maxX && worldPoint.y >= obstacle.minY && worldPoint.y <= obstacle.maxY
    );
  }
  reconstructPath(endNode) {
    if (endNode.gCost * CELL_SIZE > 10) {
      return [];
    }
    const path = [];
    let current = endNode;
    while (current) {
      path.unshift(this.gridToWorld(current.point));
      current = current.parent;
    }
    return path;
  }
};

// lib/utils/pathfindingHelpers.ts
function isPathClear(from, to, circuit2, excludeChipId) {
  const steps = 10;
  for (let i = 1; i < steps; i++) {
    const t = i / steps;
    const checkX = from.x + (to.x - from.x) * t;
    const checkY = from.y + (to.y - from.y) * t;
    if (isPointInObstacle(checkX, checkY, circuit2, excludeChipId)) {
      return false;
    }
  }
  return true;
}
function isPointInObstacle(x, y, circuit2, excludeChipId) {
  for (const chip of circuit2.chips) {
    if (chip.chipId === excludeChipId) {
      continue;
    }
    const width = chip.getWidth();
    const height = chip.getHeight();
    const margin = 0.1;
    if (x >= chip.x - width / 2 - margin && x <= chip.x + width / 2 + margin && y >= chip.y - height / 2 - margin && y <= chip.y + height / 2 + margin) {
      return true;
    }
  }
  return false;
}
function findClearWaypoint(fromX, fromY, targetX, targetY, circuit2, excludeChipId) {
  let maxObstacleY = -Infinity;
  let minObstacleY = Infinity;
  for (const chip of circuit2.chips) {
    if (chip.chipId === excludeChipId) continue;
    const width = chip.getWidth();
    const height = chip.getHeight();
    const margin2 = 0.1;
    const obstacleLeft = chip.x - width / 2 - margin2;
    const obstacleRight = chip.x + width / 2 + margin2;
    const obstacleTop = chip.y + height / 2 + margin2;
    const obstacleBottom = chip.y - height / 2 - margin2;
    const pathLeft = Math.min(fromX, targetX);
    const pathRight = Math.max(fromX, targetX);
    if (obstacleRight > pathLeft && obstacleLeft < pathRight) {
      maxObstacleY = Math.max(maxObstacleY, obstacleTop);
      minObstacleY = Math.min(minObstacleY, obstacleBottom);
    }
  }
  if (maxObstacleY !== -Infinity) {
    const routeAboveY = maxObstacleY + 0.5;
    if (!isPointInObstacle(fromX, routeAboveY, circuit2, excludeChipId) && !isPointInObstacle(targetX, routeAboveY, circuit2, excludeChipId)) {
      return { x: fromX, y: routeAboveY };
    }
    const routeBelowY = minObstacleY - 0.5;
    if (!isPointInObstacle(fromX, routeBelowY, circuit2, excludeChipId) && !isPointInObstacle(targetX, routeBelowY, circuit2, excludeChipId)) {
      return { x: fromX, y: routeBelowY };
    }
  }
  const midPoint1 = { x: targetX, y: fromY };
  if (!isPointInObstacle(midPoint1.x, midPoint1.y, circuit2, excludeChipId)) {
    return midPoint1;
  }
  const midPoint2 = { x: fromX, y: targetY };
  if (!isPointInObstacle(midPoint2.x, midPoint2.y, circuit2, excludeChipId)) {
    return midPoint2;
  }
  const deltaX = targetX - fromX;
  const deltaY = targetY - fromY;
  let margin = 1;
  while (margin < 4) {
    const waypointX = fromX + (deltaX > 0 ? margin : -margin);
    const waypointY = fromY + (deltaY > 0 ? margin : -margin);
    if (!isPointInObstacle(waypointX, waypointY, circuit2, excludeChipId)) {
      return { x: waypointX, y: waypointY };
    }
    margin += 0.5;
  }
  return { x: fromX, y: fromY };
}

// lib/builder/PinBuilder.ts
var PinBuilder = class {
  constructor(chip, pinNumber) {
    this.chip = chip;
    this.pinNumber = pinNumber;
  }
  /* location (absolute coords inside circuit grid) */
  x = 0;
  y = 0;
  pathId = null;
  lastConnected = null;
  lastCreatedLine = null;
  lastDx = 0;
  lastDy = 0;
  fromJunctionId = null;
  get circuit() {
    return this.chip["circuit"];
  }
  get lastLineEnd() {
    if (this.lastCreatedLine) {
      return { x: this.lastCreatedLine.end.x, y: this.lastCreatedLine.end.y };
    }
    if (this.fromJunctionId) {
      const junction = this.circuit.connectionPoints.find(
        (c) => c.junctionId === this.fromJunctionId
      );
      if (!junction) {
        throw new Error(`Junction ${this.fromJunctionId} not found`);
      }
      return {
        x: junction.x,
        y: junction.y
      };
    }
    return {
      x: this.x,
      y: this.y
    };
  }
  line(dx, dy) {
    if (!this.pathId) {
      this.pathId = this.circuit.addPath().pathId;
    }
    const start = { ...this.lastLineEnd, ref: this.ref };
    const end = { x: start.x + dx, y: start.y + dy, ref: this.ref };
    if (this.fromJunctionId) {
      start.fromJunctionId = this.fromJunctionId;
      end.fromJunctionId = this.fromJunctionId;
    }
    const line = { start, end, pathId: this.pathId };
    this.circuit.lines.push(line);
    this.lastDx = dx;
    this.lastDy = dy;
    this.lastCreatedLine = line;
    return this;
  }
  lineAt(targetX, targetY) {
    const deltaX = targetX - this.lastLineEnd.x;
    const deltaY = targetY - this.lastLineEnd.y;
    if (deltaX === 0 && deltaY === 0) {
      return this;
    }
    if (deltaX === 0 || deltaY === 0) {
      return this.line(deltaX, deltaY);
    }
    let firstDirection;
    if (this.lastCreatedLine === null) {
      const pinDirection = this.getPinDirection();
      if (pinDirection === "horizontal") {
        firstDirection = "x";
      } else {
        firstDirection = "y";
      }
    } else {
      if (this.lastDx !== 0) {
        firstDirection = "y";
      } else {
        firstDirection = "x";
      }
    }
    if (firstDirection === "x") {
      return this.line(deltaX, 0).line(0, deltaY);
    } else {
      return this.line(0, deltaY).line(deltaX, 0);
    }
  }
  pathTo(targetX, targetY) {
    const currentPos = this.lastLineEnd;
    const targetPos = { x: targetX, y: targetY };
    if (currentPos.x === targetPos.x && currentPos.y === targetPos.y) {
      return this;
    }
    if (isPathClear(currentPos, targetPos, this.circuit, this.chip.chipId)) {
      return this.lineAt(targetX, targetY);
    }
    const pathfinder = new SimplePathfinder();
    for (const chip of this.circuit.chips) {
      if (chip.chipId === this.chip.chipId) {
        continue;
      }
      const width = chip.getWidth();
      const height = chip.getHeight();
      const margin = 0.1;
      const obstacle = {
        minX: chip.x - width / 2 - margin,
        maxX: chip.x + width / 2 + margin,
        minY: chip.y - height / 2 - margin,
        maxY: chip.y + height / 2 + margin
      };
      pathfinder.addObstacle(obstacle);
    }
    const distance = Math.abs(targetX - this.x) + Math.abs(targetY - this.y);
    if (distance < 10) {
      const path = pathfinder.findPath(currentPos, targetPos);
      if (path.length > 0) {
        for (let i = 1; i < path.length; i++) {
          const point = path[i];
          const deltaX = point.x - this.lastLineEnd.x;
          const deltaY = point.y - this.lastLineEnd.y;
          this.line(deltaX, deltaY);
        }
        return this;
      }
    }
    const waypoint = findClearWaypoint(
      this.lastLineEnd.x,
      this.lastLineEnd.y,
      targetX,
      targetY,
      this.circuit,
      this.chip.chipId
    );
    return this.lineAt(waypoint.x, waypoint.y).lineAt(targetX, targetY);
  }
  getPinDirection() {
    const side = this.side;
    return side === "left" || side === "right" ? "horizontal" : "vertical";
  }
  get side() {
    const { side } = getPinSideIndex(this.pinNumber, this.chip);
    return side;
  }
  get ref() {
    return {
      boxId: this.chip.chipId,
      pinNumber: this.pinNumber
    };
  }
  passive(name) {
    const entryDirection = this.lastDx === 0 ? "vertical" : "horizontal";
    const passive = this.circuit.passive(name);
    if (entryDirection === "horizontal") {
      passive.leftpins(1).rightpins(1);
    } else {
      passive.bottompins(1).toppins(1);
    }
    const halfWidth = passive.getWidth() / 2;
    const halfHeight = passive.getHeight() / 2;
    const centerX = this.lastLineEnd.x + Math.sign(this.lastDx) * (Math.abs(this.lastDx) > 0 ? halfWidth : 0);
    const centerY = this.lastLineEnd.y + Math.sign(this.lastDy) * (Math.abs(this.lastDy) > 0 ? halfHeight : 0);
    passive.at(centerX, centerY);
    const entrySide = this.lastDx > 0 ? "left" : this.lastDx < 0 ? "right" : this.lastDy > 0 ? "bottom" : "top";
    const [entryPin, exitPin] = entrySide === "left" || entrySide === "bottom" ? [passive.pin(1), passive.pin(2)] : [passive.pin(2), passive.pin(1)];
    this.lastCreatedLine.end.ref = entryPin.ref;
    this.lastCreatedLine.end.fromJunctionId = void 0;
    return exitPin;
  }
  label(text) {
    const netId = text ?? this.circuit.generateAutoLabel();
    const netLabel = this.circuit.addNetLabel({
      netId,
      x: this.lastLineEnd.x,
      y: this.lastLineEnd.y,
      anchorSide: this.lastDx > 0 ? "left" : this.lastDx < 0 ? "right" : this.lastDy > 0 ? "bottom" : "top",
      fromRef: this.ref
    });
    if (!this.lastCreatedLine) {
      this.line(0, 0);
    }
    this.lastCreatedLine.end.ref = {
      netId,
      netLabelId: netLabel.netLabelId
    };
    this.lastCreatedLine.end.fromJunctionId = void 0;
  }
  connect() {
    this.circuit.addJunction({
      pinRef: this.ref,
      x: this.lastLineEnd.x,
      y: this.lastLineEnd.y
    });
    return this;
  }
  intersect() {
    const junction = this.circuit.addJunction({
      pinRef: this.ref,
      x: this.lastLineEnd.x,
      y: this.lastLineEnd.y,
      showAsIntersection: true
    });
    this.lastCreatedLine.end.fromJunctionId = junction.junctionId;
    return this;
  }
  intersectsAt(targetX, targetY) {
    this.lineAt(targetX, targetY);
    return this.intersect();
  }
  connectToMark(markName) {
    const mark = this.circuit.getMark(markName);
    const markState = mark.state;
    this.lineAt(markState.x, markState.y);
    return this.connect();
  }
  intersectAtMark(markName) {
    const mark = this.circuit.getMark(markName);
    const markState = mark.state;
    this.lineAt(markState.x, markState.y);
    return this.intersect();
  }
  mark(name) {
    this.chip.addMark(name, this);
    return this.chip.fromMark(name);
  }
  // Methods for mark/fromMark state management
  getMarkableState() {
    return {
      x: this.lastLineEnd.x,
      y: this.lastLineEnd.y,
      lastConnected: this.lastConnected,
      lastDx: this.lastDx,
      lastDy: this.lastDy
    };
  }
  applyMarkableState(state) {
    this.lastConnected = state.lastConnected;
    this.lastDx = state.lastDx;
    this.lastDy = state.lastDy;
    this.pathId = this.circuit.addPath().pathId;
    this.lastCreatedLine = null;
  }
  serialize() {
    return {
      x: this.x,
      y: this.y,
      pinNumber: this.pinNumber
    };
  }
};

// lib/builder/ChipBuilder.ts
var ChipBuilder = class {
  constructor(circuit2, chipId, isPassive = false) {
    this.circuit = circuit2;
    this.chipId = chipId;
    this.isPassive = isPassive;
  }
  x = 0;
  y = 0;
  leftPins = [];
  rightPins = [];
  topPins = [];
  bottomPins = [];
  leftPinCount = 0;
  rightPinCount = 0;
  topPinCount = 0;
  bottomPinCount = 0;
  pinMap = {};
  marks = {};
  pinMargins = {};
  at(x, y) {
    this.x = x;
    this.y = y;
    return this;
  }
  makePin({
    side,
    indexOnSide,
    ccwPinNumber
  }) {
    const pb = new PinBuilder(this, ccwPinNumber);
    this.pinMap[`${side}${indexOnSide}`] = pb;
    return pb;
  }
  leftpins(count) {
    if (this.pinPositionsAreSet) {
      throw new Error("Pin positions are already set, cannot add new pins");
    }
    this.leftPinCount = count;
    for (let i = 0; i < count; ++i) {
      const ccwPinNumber = i + 1;
      const pb = this.makePin({
        side: "left",
        indexOnSide: i,
        ccwPinNumber
      });
      this.leftPins.push(pb);
    }
    return this;
  }
  rightpins(count) {
    if (this.pinPositionsAreSet) {
      throw new Error("Pin positions are already set, cannot add new pins");
    }
    this.rightPinCount = count;
    for (let i = 0; i < count; ++i) {
      const ccwPinNumber = this.leftPinCount + this.bottomPinCount + i + 1;
      const pb = this.makePin({
        side: "right",
        indexOnSide: i,
        ccwPinNumber
      });
      this.rightPins.push(pb);
    }
    return this;
  }
  toppins(count) {
    if (this.pinPositionsAreSet) {
      throw new Error("Pin positions are already set, cannot add new pins");
    }
    this.topPinCount = count;
    for (let i = 0; i < count; ++i) {
      const ccwPinNumber = this.leftPinCount + this.bottomPinCount + this.rightPinCount + i + 1;
      const pb = this.makePin({
        side: "top",
        indexOnSide: i,
        ccwPinNumber
      });
      this.topPins.push(pb);
    }
    return this;
  }
  bottompins(count) {
    if (this.pinPositionsAreSet) {
      throw new Error("Pin positions are already set, cannot add new pins");
    }
    this.bottomPinCount = count;
    for (let i = 0; i < count; ++i) {
      const ccwPinNumber = this.leftPinCount + i + 1;
      const pb = this.makePin({
        side: "bottom",
        indexOnSide: i,
        ccwPinNumber
      });
      this.bottomPins.push(pb);
    }
    return this;
  }
  getWidth() {
    if (this.isPassive) {
      const isHorizontal = this.leftPinCount > 0 || this.rightPinCount > 0;
      return isHorizontal ? this.circuit.defaultPassiveWidth : this.circuit.defaultPassiveHeight;
    }
    const sideCount = [
      this.leftPinCount > 0 ? 1 : 0,
      this.rightPinCount > 0 ? 1 : 0,
      this.topPinCount > 0 ? 1 : 0,
      this.bottomPinCount > 0 ? 1 : 0
    ].reduce((sum, count) => sum + count, 0);
    if (sideCount === 1) {
      return this.circuit.defaultSingleSidedChipWidth;
    }
    const hasLeftRightPins = this.leftPinCount > 0 && this.rightPinCount > 0;
    if (hasLeftRightPins && this.topPinCount === 0 && this.bottomPinCount === 0) {
      return this.circuit.defaultLeftRightChipWidth;
    }
    return this.circuit.defaultChipWidth;
  }
  getHeight() {
    if (this.isPassive) {
      const isHorizontal = this.leftPinCount > 0 || this.rightPinCount > 0;
      return isHorizontal ? this.circuit.defaultPassiveHeight : this.circuit.defaultPassiveWidth;
    }
    return Math.max(this.leftPinCount, this.rightPinCount) * this.circuit.defaultPinSpacing + this.circuit.defaultPinSpacing * 2;
  }
  getCenter() {
    if (this.isPassive) {
      return {
        x: this.x,
        y: this.y
      };
    }
    return {
      x: this.x + this.getWidth() / 2,
      y: this.y + this.getHeight() / 2
    };
  }
  get totalPinCount() {
    return this.leftPinCount + this.rightPinCount + this.topPinCount + this.bottomPinCount;
  }
  setPinPositions() {
    for (let pn = 1; pn <= this.totalPinCount; pn++) {
      const pb = this._getPin(pn);
      const pinLocation = this.getPinLocation(pn);
      pb.x = pinLocation.x;
      pb.y = pinLocation.y;
    }
    this.pinPositionsAreSet = true;
  }
  pinPositionsAreSet = false;
  _getPin(pinNumber) {
    let n = pinNumber;
    if (n <= this.leftPins.length) return this.leftPins[n - 1];
    n -= this.leftPins.length;
    if (n <= this.bottomPins.length) return this.bottomPins[n - 1];
    n -= this.bottomPins.length;
    if (n <= this.rightPins.length) return this.rightPins[n - 1];
    n -= this.rightPins.length;
    if (n <= this.topPins.length) return this.topPins[n - 1];
    throw new Error(`Pin number ${pinNumber} not found`);
  }
  pin(pinNumber) {
    if (!this.pinPositionsAreSet) {
      this.setPinPositions();
    }
    const pb = this._getPin(pinNumber);
    pb.fromJunctionId = null;
    return pb;
  }
  getPinLocation(pinNumber) {
    const { side, indexFromTop, indexFromLeft } = getPinSideIndex(
      pinNumber,
      this
    );
    if (this.isPassive) {
      const dx = (this.leftPinCount > 0 ? this.getWidth() / 2 : 0) * (pinNumber === 1 ? 1 : -1);
      const dy = (this.bottomPinCount > 0 ? this.getHeight() / 2 : 0) * (pinNumber === 2 ? 1 : -1);
      return { x: this.x + dx, y: this.y + dy };
    }
    let pinX;
    let pinY;
    const spacing = this.circuit.defaultPinSpacing;
    const defaultMargin = 0.2;
    if (side === "left" || side === "right") {
      pinX = this.x + (side === "left" ? 0 : this.getWidth());
      let totalSpacing = indexFromTop * spacing;
      for (let i = 0; i <= indexFromTop; i++) {
        const currentPinNumber = this.getPinNumberFromSideIndex(side, i);
        const currentMargin = this.pinMargins[currentPinNumber];
        if (currentMargin?.marginTop && currentMargin.marginTop > defaultMargin) {
          totalSpacing += currentMargin.marginTop - defaultMargin;
        }
      }
      pinY = this.y + this.getHeight() - totalSpacing - this.circuit.defaultPinSpacing * 2;
    } else {
      let totalSpacing = indexFromLeft * spacing;
      for (let i = 0; i <= indexFromLeft; i++) {
        const currentPinNumber = this.getPinNumberFromSideIndex(side, i);
        const currentMargin = this.pinMargins[currentPinNumber];
        if (currentMargin?.marginLeft && currentMargin.marginLeft > defaultMargin) {
          totalSpacing += currentMargin.marginLeft - defaultMargin;
        }
      }
      pinX = this.x + totalSpacing;
      pinY = this.y + (side === "bottom" ? 0 : this.getHeight());
    }
    return { x: pinX, y: pinY };
  }
  addMark(name, pinBuilder) {
    this.marks[name] = { pinBuilder, state: pinBuilder.getMarkableState() };
  }
  fromMark(name) {
    if (!this.marks[name]) {
      throw new Error(`Mark "${name}" not found`);
    }
    const { pinBuilder, state } = this.marks[name];
    const junction = this.circuit.addJunction({
      x: state.x,
      y: state.y,
      pinRef: this.marks[name].pinBuilder.ref
    });
    pinBuilder.applyMarkableState(state);
    pinBuilder.fromJunctionId = junction.junctionId;
    return pinBuilder;
  }
  getPinNumberFromSideIndex(side, indexOnSide) {
    let pinNumber = 1;
    if (side === "bottom" || side === "right" || side === "top") {
      pinNumber += this.leftPinCount;
    }
    if (side === "right" || side === "top") {
      pinNumber += this.bottomPinCount;
    }
    if (side === "top") {
      pinNumber += this.rightPinCount;
    }
    pinNumber += indexOnSide;
    return pinNumber;
  }
  serialize() {
    return {
      x: this.x,
      y: this.y,
      leftPinCount: this.leftPinCount,
      rightPinCount: this.rightPinCount,
      topPinCount: this.topPinCount,
      bottomPinCount: this.bottomPinCount,
      leftPins: this.leftPins.map((p) => p.serialize()),
      rightPins: this.rightPins.map((p) => p.serialize()),
      topPins: this.topPins.map((p) => p.serialize()),
      bottomPins: this.bottomPins.map((p) => p.serialize()),
      marks: Object.fromEntries(
        Object.entries(this.marks).map(([name, { pinBuilder, state }]) => [
          name,
          { pinBuilder: pinBuilder.serialize(), state }
        ])
      )
    };
  }
};

// lib/builder/flipCircuit.ts
var flipXCircuit = (circuit2) => {
  const xs = [];
  for (const chip of circuit2.chips) {
    xs.push(chip.x);
    xs.push(chip.x + 4);
  }
  for (const line of circuit2.lines) {
    xs.push(line.start.x, line.end.x);
  }
  for (const label of circuit2.netLabels) {
    xs.push(label.x);
  }
  for (const cp of circuit2.connectionPoints) {
    xs.push(cp.x);
  }
  if (xs.length === 0) return circuit2;
  const minX = Math.min(...xs);
  const maxX = Math.max(...xs);
  const mid = minX + maxX;
  for (const chip of circuit2.chips) {
    chip.x = mid - (chip.x + 4);
    const oldLeftPins = chip.leftPins;
    const oldRightPins = chip.rightPins;
    chip.leftPins = oldRightPins.slice();
    chip.rightPins = oldLeftPins.slice().reverse();
    const tmpCount = chip.leftPinCount;
    chip.leftPinCount = chip.rightPinCount;
    chip.rightPinCount = tmpCount;
  }
  for (const line of circuit2.lines) {
    line.start.x = mid - line.start.x;
    line.end.x = mid - line.end.x;
  }
  for (const label of circuit2.netLabels) {
    label.x = mid - label.x;
  }
  for (const cp of circuit2.connectionPoints) {
    cp.x = mid - cp.x;
  }
  return circuit2;
};

// lib/builder/Grid.ts
var EDGE_MASKS = {
  left: 1,
  right: 2,
  up: 4,
  down: 8
};
function glyph(mask) {
  switch (mask) {
    case 0:
      return " ";
    case EDGE_MASKS.left:
    case EDGE_MASKS.right:
      return "\u2500";
    case EDGE_MASKS.up:
    case EDGE_MASKS.down:
      return "\u2502";
    case EDGE_MASKS.left | EDGE_MASKS.right:
      return "\u2500";
    case EDGE_MASKS.up | EDGE_MASKS.down:
      return "\u2502";
    case EDGE_MASKS.left | EDGE_MASKS.up:
      return "\u2518";
    case EDGE_MASKS.left | EDGE_MASKS.down:
      return "\u2510";
    case EDGE_MASKS.right | EDGE_MASKS.up:
      return "\u2514";
    case EDGE_MASKS.right | EDGE_MASKS.down:
      return "\u250C";
    case EDGE_MASKS.left | EDGE_MASKS.right | EDGE_MASKS.up:
      return "\u2534";
    case EDGE_MASKS.left | EDGE_MASKS.right | EDGE_MASKS.down:
      return "\u252C";
    case EDGE_MASKS.left | EDGE_MASKS.up | EDGE_MASKS.down:
      return "\u2524";
    case EDGE_MASKS.right | EDGE_MASKS.up | EDGE_MASKS.down:
      return "\u251C";
    case EDGE_MASKS.left | EDGE_MASKS.right | EDGE_MASKS.up | EDGE_MASKS.down:
      return "\u253C";
    default:
      return " ";
  }
}
var Grid = class {
  traces = /* @__PURE__ */ new Map();
  // key "x,y" → Edge mask
  overlay = /* @__PURE__ */ new Map();
  // key "x,y" → literal char
  gridScaleX;
  gridScaleY;
  showAxisLabels;
  constructor(options = {}) {
    this.gridScaleX = options.gridScaleX ?? options.gridScale ?? 1;
    this.gridScaleY = options.gridScaleY ?? options.gridScale ?? 1;
    this.showAxisLabels = options.showAxisLabels ?? false;
  }
  addEdge(x, y, edge) {
    const scaledX = Math.round(x * this.gridScaleX);
    const scaledY = Math.round(y * this.gridScaleY);
    const key = `${scaledX},${scaledY}`;
    const maskValue = EDGE_MASKS[edge];
    this.traces.set(key, (this.traces.get(key) ?? 0) | maskValue);
  }
  putOverlay(x, y, ch) {
    if (ch.length > 1) {
      throw new Error("putOverlay only supports single characters");
    }
    const scaledX = Math.round(x * this.gridScaleX);
    const scaledY = Math.round(y * this.gridScaleY);
    this.overlay.set(`${scaledX},${scaledY}`, ch);
  }
  *coords() {
    const seen = /* @__PURE__ */ new Set();
    for (const key of this.traces.keys()) seen.add(key);
    for (const key of this.overlay.keys()) seen.add(key);
    for (const key of seen) {
      const [xs, ys] = key.split(",");
      yield [Number(xs), Number(ys)];
    }
  }
  toString() {
    if (this.traces.size === 0 && this.overlay.size === 0) return "";
    let minX = Infinity;
    let maxX = -Infinity;
    let minY = Infinity;
    let maxY = -Infinity;
    for (const [x, y] of this.coords()) {
      if (x < minX) minX = x;
      if (x > maxX) maxX = x;
      if (y < minY) minY = y;
      if (y > maxY) maxY = y;
    }
    const rows = [];
    if (this.showAxisLabels) {
      const labelInterval = Math.max(1, Math.round(5 * this.gridScaleX));
      let xAxisRow = "     ";
      for (let x = minX; x <= maxX; x++) {
        if (x % labelInterval === 0) {
          const displayX = this.gridScaleX !== 1 ? (x / this.gridScaleX).toFixed(1).slice(-4) : x;
          const xStr = displayX.toString();
          xAxisRow += xStr;
          for (let i = 1; i < labelInterval && x + i <= maxX; i++) {
            xAxisRow += " ";
          }
          x += labelInterval - 1;
        } else {
          xAxisRow += " ";
        }
      }
      rows.push(xAxisRow);
    }
    for (let y = maxY; y >= minY; y--) {
      let row = "";
      if (this.showAxisLabels) {
        const displayY = (y / this.gridScaleY).toFixed(1).slice(-4);
        const yLabel = displayY.toString().padStart(4, " ");
        row = `${yLabel} `;
      }
      for (let x = minX; x <= maxX; x++) {
        const key = `${x},${y}`;
        const over = this.overlay.get(key);
        const trace = this.traces.get(key) ?? 0;
        row += over ?? glyph(trace);
      }
      rows.push(row.replace(/ +$/g, ""));
    }
    return rows.join("\n");
  }
};

// lib/builder/getGridFromCircuit.ts
var getGridFromCircuit = (circuit2, opts = {}) => {
  opts.chipLabels ??= true;
  opts.showAxisLabels ??= false;
  opts.gridScaleX ??= 1;
  opts.gridScaleY ??= 1;
  const gridScaleX = opts.gridScaleX;
  const gridScaleY = opts.gridScaleY;
  const cellWidth = 1 / gridScaleX;
  const cellHeight = 1 / gridScaleY;
  const g = new Grid({
    showAxisLabels: opts.showAxisLabels,
    gridScaleX,
    gridScaleY
  });
  const passives = [];
  for (const chip of circuit2.chips) {
    if (chip.isPassive) {
      passives.push(chip);
      continue;
    }
    const chipWidth = chip.getWidth();
    const chipHeight = chip.getHeight();
    const chipRowHeight = Math.round(chipHeight * opts.gridScaleY);
    if (opts.chipLabels && chip.topPinCount === 0) {
      const labelY = chip.y + chip.getHeight();
      const labelText = chip.chipId;
      for (let x = chip.x, i = 0; i < labelText.length; i++, x += cellWidth) {
        g.putOverlay(x, labelY, labelText[i]);
      }
    }
    const chipGridX = Math.round(chip.x * opts.gridScaleX);
    const chipGridY = Math.round(chip.y * opts.gridScaleY);
    for (let r = 0; r < chipRowHeight; ++r) {
      let mid0 = " ";
      let mid1 = " ";
      let mid2 = " ";
      const isBottomBorder = r === 0;
      const isTopBorder = r === chipRowHeight - 1;
      const midWidth = chipWidth * opts.gridScaleX;
      if (isBottomBorder) {
        mid0 = "\u2514";
        mid1 = "\u2500".repeat(midWidth);
        mid2 = "\u2518";
      } else if (isTopBorder) {
        mid0 = "\u250C";
        mid1 = "\u2500".repeat(midWidth);
        mid2 = "\u2510";
      } else {
        const currentGridY = chipGridY + r;
        let leftPinData = void 0;
        let rightPinData = void 0;
        for (const pin of chip.leftPins) {
          const pinLoc = chip.getPinLocation(pin.pinNumber);
          const pinGridY = Math.round(pinLoc.y * opts.gridScaleY);
          if (pinGridY === currentGridY) {
            leftPinData = pin;
            break;
          }
        }
        for (const pin of chip.rightPins) {
          const pinLoc = chip.getPinLocation(pin.pinNumber);
          const pinGridY = Math.round(pinLoc.y * opts.gridScaleY);
          if (pinGridY === currentGridY) {
            rightPinData = pin;
            break;
          }
        }
        mid0 = leftPinData ? "\u2524" : "\u2502";
        mid2 = rightPinData ? "\u251C" : "\u2502";
        const lpStr = leftPinData ? String(leftPinData.pinNumber) : null;
        const rpStr = rightPinData ? String(rightPinData.pinNumber) : null;
        if (lpStr && rpStr) {
          const spacesNeeded = midWidth - lpStr.length - rpStr.length;
          mid1 = lpStr + " ".repeat(Math.max(1, spacesNeeded)) + rpStr;
        } else if (lpStr) {
          mid1 = lpStr + " ".repeat(Math.max(0, midWidth - lpStr.length));
        } else if (rpStr) {
          mid1 = " ".repeat(Math.max(0, midWidth - rpStr.length)) + rpStr;
        } else {
          mid1 = " ".repeat(Math.max(0, midWidth));
        }
      }
      const rowStr = mid0 + (mid1.length === chipWidth - 2 ? mid1 : mid1.padEnd(chipWidth - 2, " ")) + // Ensure mid1 is correct width
      mid2;
      for (let col = 0; col < rowStr.length; ++col) {
        const gridX = (chipGridX + col) / opts.gridScaleX;
        const gridY = (chipGridY + r) / opts.gridScaleY;
        g.putOverlay(gridX, gridY, rowStr[col]);
      }
    }
  }
  for (const label of circuit2.netLabels) {
    if (label.netId.length > 0) {
      const abbreviatedChar = label.netId[0];
      g.putOverlay(label.x, label.y, abbreviatedChar);
    }
  }
  for (const line of circuit2.lines) {
    if (line.start.x === line.end.x) {
      const x = line.start.x;
      const y_start_coord = line.start.y;
      const y_end_coord = line.end.y;
      const y_min = Math.min(y_start_coord, y_end_coord);
      const y_max = Math.max(y_start_coord, y_end_coord);
      if (y_min === y_max) continue;
      g.addEdge(x, y_start_coord, y_start_coord < y_end_coord ? "up" : "down");
      g.addEdge(x, y_end_coord, y_start_coord < y_end_coord ? "down" : "up");
      const gridY_min = Math.round(y_min * opts.gridScaleY);
      const gridY_max = Math.round(y_max * opts.gridScaleY);
      for (let gridY = gridY_min + 1; gridY < gridY_max; gridY++) {
        const y = gridY / opts.gridScaleY;
        g.addEdge(x, y, "up");
        g.addEdge(x, y, "down");
      }
    } else if (line.start.y === line.end.y) {
      const y = line.start.y;
      const x_start_coord = line.start.x;
      const x_end_coord = line.end.x;
      const x_min = Math.min(x_start_coord, x_end_coord);
      const x_max = Math.max(x_start_coord, x_end_coord);
      if (x_min === x_max) continue;
      g.addEdge(
        x_start_coord,
        y,
        x_start_coord < x_end_coord ? "right" : "left"
      );
      g.addEdge(x_end_coord, y, x_start_coord < x_end_coord ? "left" : "right");
      const gridX_min = Math.round(x_min * opts.gridScaleX);
      const gridX_max = Math.round(x_max * opts.gridScaleX);
      for (let gridX = gridX_min + 1; gridX < gridX_max; gridX++) {
        const x = gridX / opts.gridScaleX;
        g.addEdge(x, y, "left");
        g.addEdge(x, y, "right");
      }
    }
  }
  for (const cp of circuit2.connectionPoints) {
    if (cp.showAsIntersection) {
      g.putOverlay(cp.x, cp.y, "\u25CF");
    }
  }
  for (const chip of passives) {
    const isHorizontal = chip.leftPinCount > 0 || chip.rightPinCount > 0;
    if (isHorizontal) {
      const startX = chip.x - chip.getWidth() / 2;
      const totalCharsPossible = chip.getWidth() / (1 / opts.gridScaleX);
      for (let i = 0, charCount = 0; i < chip.getWidth(); i += 1 / opts.gridScaleX, charCount++) {
        if (totalCharsPossible <= 3) {
          if (chip.chipId[charCount]) {
            g.putOverlay(startX + i, chip.y, chip.chipId[charCount]);
          }
        } else if (i === 0) {
          g.putOverlay(startX + i, chip.y, "[");
        } else if (i >= chip.getWidth() - 1 / opts.gridScaleX) {
          g.putOverlay(startX + i, chip.y, "]");
        } else if (chip.chipId[charCount - 1]) {
          g.putOverlay(startX + i, chip.y, chip.chipId[charCount - 1]);
        }
      }
    } else {
      g.putOverlay(chip.x, chip.y - chip.getHeight() / 2, "\u252C");
      g.putOverlay(chip.x, chip.y, chip.chipId[0]);
      if (chip.chipId[1]) {
        g.putOverlay(chip.x + 1 / opts.gridScaleX, chip.y, chip.chipId[1]);
      }
      g.putOverlay(chip.x, chip.y + chip.getHeight() / 2, "\u2534");
    }
  }
  return g;
};

// lib/builder/isSamePortRef.ts
var isSamePortRef = (ref1, ref2) => {
  if ("boxId" in ref1 && "boxId" in ref2) {
    return ref1.boxId === ref2.boxId && ref1.pinNumber === ref2.pinNumber;
  }
  if ("netId" in ref1 && "netId" in ref2) {
    return ref1.netId === ref2.netId;
  }
  if ("lineId" in ref1 && "lineId" in ref2) {
    return ref1.lineId === ref2.lineId;
  }
  return false;
};

// lib/builder/refkey.ts
var getRefKey = (ref) => "boxId" in ref ? `box[${ref.boxId}].${ref.pinNumber}` : "junctionId" in ref ? `junction[${ref.junctionId}]` : `netlabel[${ref.netId},${ref.netLabelId}]`;
var parseRefKey = (refKey) => {
  let match = refKey.match(/^box\[([^\]]+)\]\.(\d+)$/);
  if (match) {
    return { boxId: match[1], pinNumber: parseInt(match[2]) };
  }
  match = refKey.match(/^junction\[([^\]]+)\]$/);
  if (match) {
    return { junctionId: match[1] };
  }
  match = refKey.match(/^netlabel\[([^\]]+),([^\]]+)\]$/);
  if (match) {
    return { netId: match[1], netLabelId: match[2] };
  }
  throw new Error(`Invalid ref key: ${refKey}`);
};

// lib/builder/CircuitBuilder/getCircuitLayoutJson.ts
var getCircuitLayoutJson = (circuitBuilder) => {
  const boxes3 = [];
  const netLabels3 = [];
  const paths3 = [];
  const junctions3 = [];
  for (const chip of circuitBuilder.chips) {
    if (!chip.pinPositionsAreSet) {
      chip.setPinPositions();
    }
    const pins = [];
    const allPins = [
      ...chip.leftPins,
      ...chip.bottomPins,
      ...chip.rightPins,
      ...chip.topPins
    ];
    for (const pin of allPins) {
      const pinLocation = pin.x !== void 0 && pin.y !== void 0 ? { x: pin.x, y: pin.y } : chip.getPinLocation(pin.pinNumber);
      pins.push({
        pinNumber: pin.pinNumber,
        x: pinLocation.x,
        y: pinLocation.y
      });
    }
    const center = chip.getCenter();
    boxes3.push({
      boxId: chip.chipId,
      leftPinCount: chip.leftPinCount,
      rightPinCount: chip.rightPinCount,
      topPinCount: chip.topPinCount,
      bottomPinCount: chip.bottomPinCount,
      centerX: center.x,
      centerY: center.y,
      pins
    });
  }
  for (const label of circuitBuilder.netLabels) {
    netLabels3.push({
      netLabelId: label.netLabelId,
      netId: label.netId,
      x: label.x,
      y: label.y,
      anchorPosition: label.anchorSide
    });
  }
  for (const path of circuitBuilder.paths) {
    const lines = circuitBuilder.lines.filter((l) => l.pathId === path.pathId);
    if (lines.length === 0) continue;
    const refs = new Set(
      lines.flatMap((l) => [
        getRefKey(
          l.start.fromJunctionId ? { junctionId: l.start.fromJunctionId } : l.start.ref
        ),
        getRefKey(
          l.end.fromJunctionId ? { junctionId: l.end.fromJunctionId } : l.end.ref
        )
      ])
    );
    let arRefs = Array.from(refs);
    if (arRefs.length === 3 && arRefs.some((r) => r.startsWith("junction["))) {
      arRefs = arRefs.filter((r) => !r.startsWith("junction["));
    }
    if (arRefs.length > 2) {
      throw new Error(
        `Path composed of "${Array.from(refs).join(",")}" has more than 2 references (use a junction instead of connecting multiple points to the same pin)`
      );
    }
    if (arRefs.length === 1) continue;
    let [fromStr, toStr] = arRefs;
    if (getRefKey(lines[0].start.ref) === toStr) {
      ;
      [fromStr, toStr] = [toStr, fromStr];
    }
    paths3.push({
      points: lines.flatMap((l) => [
        {
          x: l.start.x,
          y: l.start.y
        },
        {
          x: l.end.x,
          y: l.end.y
        }
      ]),
      from: parseRefKey(fromStr),
      to: parseRefKey(toStr)
    });
  }
  for (const cp of circuitBuilder.connectionPoints) {
    junctions3.push({
      junctionId: cp.junctionId,
      x: cp.x,
      y: cp.y
    });
  }
  return {
    boxes: boxes3,
    netLabels: netLabels3,
    paths: paths3,
    junctions: junctions3
  };
};

// lib/builder/CircuitBuilder/CircuitBuilder.ts
var alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
var CircuitBuilder = class _CircuitBuilder {
  chips = [];
  netLabels = [];
  lines = [];
  paths = [];
  connectionPoints = [];
  defaultChipWidth = 2;
  defaultSingleSidedChipWidth = 2;
  /** Width for chips with pins on both left and right sides */
  defaultLeftRightChipWidth = 2.8;
  defaultPinSpacing = 0.2;
  defaultPassiveWidth = 1;
  defaultPassiveHeight = 0.2;
  autoLabelCounter = 1;
  name;
  constructor(opts = {}) {
    this.name = opts.name ?? "Circuit";
  }
  /* ------------------------------------------------------------------ *
   * Deep-clone without JSON.stringify (avoids cyclic-structure error)  *
   * ------------------------------------------------------------------ */
  clone() {
    const clone = new _CircuitBuilder({
      name: this.name
    });
    clone.autoLabelCounter = this.autoLabelCounter;
    clone.defaultChipWidth = this.defaultChipWidth;
    clone.defaultSingleSidedChipWidth = this.defaultSingleSidedChipWidth;
    clone.defaultLeftRightChipWidth = this.defaultLeftRightChipWidth;
    clone.defaultPinSpacing = this.defaultPinSpacing;
    clone.defaultPassiveWidth = this.defaultPassiveWidth;
    clone.defaultPassiveHeight = this.defaultPassiveHeight;
    for (const chip of this.chips) {
      const c = new ChipBuilder(clone, chip.chipId, chip.isPassive);
      c.x = chip.x;
      c.y = chip.y;
      c.leftPinCount = chip.leftPinCount;
      c.rightPinCount = chip.rightPinCount;
      c.topPinCount = chip.topPinCount;
      c.bottomPinCount = chip.bottomPinCount;
      c.pinPositionsAreSet = chip.pinPositionsAreSet;
      const mkPins = (count, first, originalPins) => Array.from({ length: count }, (_, i) => {
        const pb = new PinBuilder(c, first + i);
        const originalPin = originalPins[i];
        if (originalPin && typeof originalPin.x === "number") {
          pb.x = originalPin.x;
        }
        if (originalPin && typeof originalPin.y === "number") {
          pb.y = originalPin.y;
        }
        return pb;
      });
      c.leftPins = mkPins(c.leftPinCount, 1, chip.leftPins);
      c.bottomPins = mkPins(
        c.bottomPinCount,
        c.leftPinCount + 1,
        chip.bottomPins
      );
      c.rightPins = mkPins(
        c.rightPinCount,
        c.leftPinCount + c.bottomPinCount + 1,
        chip.rightPins
      );
      c.topPins = mkPins(
        c.topPinCount,
        c.leftPinCount + c.bottomPinCount + c.rightPinCount + 1,
        chip.topPins
      );
      clone.chips.push(c);
    }
    clone.lines = structuredClone(this.lines);
    clone.paths = structuredClone(this.paths);
    clone.netLabels = structuredClone(this.netLabels);
    clone.connectionPoints = structuredClone(this.connectionPoints);
    return clone;
  }
  chip(id) {
    id ??= `U${this.chips.length + 1}`;
    const c = new ChipBuilder(this, id);
    this.chips.push(c);
    return c;
  }
  passive(name) {
    const id = name ?? `R${this.chips.length + 1}`;
    const c = new ChipBuilder(this, id, true);
    this.chips.push(c);
    return c;
  }
  _pathCounter = 1;
  addPath() {
    const path = {
      pathId: `PATH${this._pathCounter++}`
    };
    this.paths.push(path);
    return path;
  }
  _netLabelCounter = 1;
  addNetLabel(params) {
    const netLabel = {
      netLabelId: `NL${this._netLabelCounter++}`,
      ...params
    };
    this.netLabels.push(netLabel);
    return netLabel;
  }
  _junctionCounter = 1;
  addJunction({
    x,
    y,
    pinRef,
    showAsIntersection = false
  }) {
    for (const cp of this.connectionPoints) {
      if (cp.x === x && cp.y === y) {
        return cp;
      }
    }
    const junction = {
      junctionId: `XX${this._junctionCounter++}`,
      x,
      y,
      pinRef,
      showAsIntersection
    };
    this.connectionPoints.push(junction);
    return junction;
  }
  toString() {
    return getGridFromCircuit(this, {
      chipLabels: true,
      showAxisLabels: true,
      gridScaleX: 2,
      gridScaleY: 5
    }).toString();
  }
  getNetlist() {
    const nb = new NetlistBuilder();
    for (const chip of this.chips) {
      nb.addBox({
        boxId: chip.chipId,
        leftPinCount: chip.leftPinCount || 0,
        rightPinCount: chip.rightPinCount || 0,
        topPinCount: chip.topPinCount || 0,
        bottomPinCount: chip.bottomPinCount || 0
      });
    }
    for (const label of this.netLabels) {
      const upper = label.netId.toUpperCase();
      const isGround = upper === "GND" || upper === "AGND";
      const isPositivePower = /^V/i.test(label.netId);
      const net = { netId: label.netId };
      if (isGround) net.isGround = true;
      if (isPositivePower) net.isPositivePower = true;
      nb.addNet(net);
      nb.connect(label.fromRef, {
        netId: label.netId,
        netLabelId: label.netLabelId
      });
    }
    for (const line of this.lines) {
      if (!isSamePortRef(line.start.ref, line.end.ref)) {
        nb.connect(line.start.ref, line.end.ref);
      }
    }
    const addToCoordMap = (map, key, ref) => {
      const arr = map.get(key) ?? [];
      arr.push(ref);
      map.set(key, arr);
    };
    const portsByCoord = /* @__PURE__ */ new Map();
    for (const cp of this.connectionPoints) {
      addToCoordMap(portsByCoord, `${cp.x},${cp.y}`, cp.pinRef);
    }
    const coordsWithCP = /* @__PURE__ */ new Set();
    for (const cp of this.connectionPoints) {
      coordsWithCP.add(`${cp.x},${cp.y}`);
    }
    for (const line of this.lines) {
      addToCoordMap(
        portsByCoord,
        `${line.start.x},${line.start.y}`,
        line.start.ref
      );
      addToCoordMap(portsByCoord, `${line.end.x},${line.end.y}`, line.end.ref);
    }
    for (const [key, refs] of portsByCoord.entries()) {
      if (!coordsWithCP.has(key)) continue;
      for (let i = 0; i < refs.length; ++i) {
        for (let j = i + 1; j < refs.length; ++j) {
          nb.connect(refs[i], refs[j]);
        }
      }
    }
    const isCoordOnSegment = (x, y, line) => {
      if (line.start.x === line.end.x) {
        if (x !== line.start.x) return false;
        const yMin = Math.min(line.start.y, line.end.y);
        const yMax = Math.max(line.start.y, line.end.y);
        return y >= yMin && y <= yMax;
      } else if (line.start.y === line.end.y) {
        if (y !== line.start.y) return false;
        const xMin = Math.min(line.start.x, line.end.x);
        const xMax = Math.max(line.start.x, line.end.x);
        return x >= xMin && x <= xMax;
      }
      return false;
    };
    for (const cp of this.connectionPoints) {
      for (const line of this.lines) {
        if (isCoordOnSegment(cp.x, cp.y, line)) {
          nb.connect(cp.pinRef, line.start.ref);
        }
      }
    }
    return nb.getNetlist();
  }
  getReadableNetlist() {
    return getReadableNetlist(this.getNetlist());
  }
  flipX() {
    return flipXCircuit(this);
  }
  generateAutoLabel() {
    return alphabet[this.autoLabelCounter++ - 1] ?? `L${this.autoLabelCounter - alphabet.length}`;
  }
  getGrid() {
    return getGridFromCircuit(this);
  }
  getMark(name) {
    for (const chip of this.chips) {
      const mark = chip.marks?.[name];
      if (mark) {
        return mark;
      }
    }
    throw new Error(`Mark "${name}" not found in circuit`);
  }
  getLayoutJson() {
    return getCircuitLayoutJson(this);
  }
  serialize() {
    return {
      chips: this.chips.map((c) => c.serialize()),
      netLabels: this.netLabels,
      lines: this.lines,
      paths: this.paths,
      connectionPoints: this.connectionPoints
    };
  }
};

// lib/builder/circuit.ts
function circuit(opts = {}) {
  return new CircuitBuilder({
    name: opts.name
  });
}

// lib/matching/matched-box-issue-finders/findAllSideHasWrongPinCount.ts
function findAllSideHasWrongPinCount(params) {
  const candidateBox = params.candidateNetlist.boxes[params.candidateBoxIndex];
  const targetBox = params.targetNetlist.boxes[params.targetBoxIndex];
  const issues = [];
  for (const side of SIDES_CCW) {
    const candidatePinCount = candidateBox[`${side}PinCount`] ?? 0;
    const targetPinCount = targetBox[`${side}PinCount`] ?? 0;
    if (candidatePinCount !== targetPinCount) {
      issues.push({
        type: "matched_box_side_has_wrong_pin_count",
        candidateBoxIndex: params.candidateBoxIndex,
        targetBoxIndex: params.targetBoxIndex
      });
    }
  }
  return issues;
}

// lib/netlist/convertNormalizedNetlistToInputNetlist.ts
var convertNormalizedNetlistToInputNetlist = (normalizedNetlist) => {
  const boxes3 = normalizedNetlist.boxes.map((b) => ({
    boxId: `box${b.boxIndex}`,
    leftPinCount: b.leftPinCount,
    rightPinCount: b.rightPinCount,
    topPinCount: b.topPinCount,
    bottomPinCount: b.bottomPinCount
  }));
  const nets = normalizedNetlist.nets.map((n) => ({
    netId: `net${n.netIndex}`,
    isGround: n.isGround,
    isPositivePower: n.isPositivePower
  }));
  const connections = normalizedNetlist.connections.map((c) => ({
    connectedPorts: c.connectedPorts.map((p) => {
      if ("boxIndex" in p) {
        return {
          boxId: `box${p.boxIndex}`,
          pinNumber: p.pinNumber
        };
      }
      return {
        netId: `net${p.netIndex}`
      };
    })
  }));
  return {
    boxes: boxes3,
    nets,
    connections
  };
};

// lib/scoring/buildEncounterMapFromNetlist.ts
var buildEncounterMapFromNetlist = (netlist) => {
  const pinsOfBox = (boxId) => {
    const pins = /* @__PURE__ */ new Set();
    for (const c of netlist.connections) {
      for (const p of c.connectedPorts) {
        if ("boxId" in p && p.boxId === boxId) pins.add(p.pinNumber);
      }
    }
    return Array.from(pins).sort((a, b) => a - b);
  };
  const connsByPin = /* @__PURE__ */ new Map();
  for (const conn of netlist.connections) {
    for (const p of conn.connectedPorts) {
      if ("boxId" in p) {
        const key = `${p.boxId}|${p.pinNumber}`;
        if (!connsByPin.has(key)) connsByPin.set(key, []);
        connsByPin.get(key).push(conn);
      }
    }
  }
  let rootBoxId = "";
  let maxPinCount = -1;
  for (const b of netlist.boxes) {
    const count = (b.leftPinCount ?? 0) + (b.rightPinCount ?? 0) + (b.topPinCount ?? 0) + (b.bottomPinCount ?? 0);
    if (count > maxPinCount || count === maxPinCount && b.boxId < rootBoxId) {
      rootBoxId = b.boxId;
      maxPinCount = count;
    }
  }
  const searchIter = { [rootBoxId]: 0 };
  const visitedBoxes = /* @__PURE__ */ new Set([rootBoxId]);
  const visitedNets = /* @__PURE__ */ new Set();
  const processedPinKeys = /* @__PURE__ */ new Set();
  let iter = 1;
  const stack = [];
  const pushPinsOf = (boxId) => {
    const pins = pinsOfBox(boxId).slice().reverse();
    for (const pin of pins) {
      stack.push({ boxId, pinNumber: pin });
    }
  };
  pushPinsOf(rootBoxId);
  while (stack.length) {
    const { boxId, pinNumber } = stack.pop();
    const pinKey = `${boxId}|${pinNumber}`;
    if (processedPinKeys.has(pinKey)) continue;
    processedPinKeys.add(pinKey);
    const neighbouringBoxes = [];
    const encounteredNetsThisPin = /* @__PURE__ */ new Set();
    const pinConns = connsByPin.get(pinKey) ?? [];
    for (const conn of pinConns) {
      for (const p of conn.connectedPorts) {
        if ("boxId" in p) {
          if (p.boxId !== boxId) {
            neighbouringBoxes.push([p.boxId, p.pinNumber]);
          }
        } else if ("netId" in p) {
          encounteredNetsThisPin.add(p.netId);
        }
      }
    }
    const sortedNewNets = Array.from(encounteredNetsThisPin).sort();
    for (const netId of sortedNewNets) {
      if (!visitedNets.has(netId)) {
        searchIter[netId] = iter++;
        visitedNets.add(netId);
      }
    }
    const smallestPin = {};
    for (const [nbrId, nbrPin] of neighbouringBoxes) {
      smallestPin[nbrId] = smallestPin[nbrId] === void 0 ? nbrPin : Math.min(smallestPin[nbrId], nbrPin);
    }
    for (const [nbrId] of Object.entries(smallestPin).sort((a, b) => {
      if (a[1] !== b[1]) return a[1] - b[1];
      const getConnectedPinsString = (boxId2) => {
        const connectedPins = /* @__PURE__ */ new Set();
        for (const conn of netlist.connections) {
          const thisBoxPort = conn.connectedPorts.find(
            (port) => "boxId" in port && port.boxId === boxId2
          );
          if (thisBoxPort && "pinNumber" in thisBoxPort) {
            for (const otherPort of conn.connectedPorts) {
              if (otherPort !== thisBoxPort && "boxId" in otherPort && "pinNumber" in otherPort) {
                connectedPins.add(otherPort.pinNumber);
              }
            }
          }
        }
        return Array.from(connectedPins).sort((a2, b2) => a2 - b2).join(",");
      };
      const pinsStringA = getConnectedPinsString(a[0]);
      const pinsStringB = getConnectedPinsString(b[0]);
      return pinsStringA.localeCompare(pinsStringB);
    })) {
      if (!visitedBoxes.has(nbrId)) {
        searchIter[nbrId] = iter++;
        visitedBoxes.add(nbrId);
        pushPinsOf(nbrId);
      }
    }
  }
  return searchIter;
};

// lib/scoring/normalizeNetlist.ts
var normalizeNetlist = (netlist) => {
  const transform = {
    boxIdToBoxIndex: {},
    netIdToNetIndex: {},
    boxIndexToBoxId: {},
    netIndexToNetId: {}
  };
  const encounterMap = buildEncounterMapFromNetlist(netlist);
  const finalSortedBoxIds = netlist.boxes.map((b) => b.boxId).sort((a, b) => {
    const ai = encounterMap[a] ?? Number.MAX_SAFE_INTEGER;
    const bi = encounterMap[b] ?? Number.MAX_SAFE_INTEGER;
    return ai !== bi ? ai - bi : a.localeCompare(b);
  });
  finalSortedBoxIds.forEach((id, idx) => {
    transform.boxIdToBoxIndex[id] = idx;
    transform.boxIndexToBoxId[idx] = id;
  });
  const normalizedBoxes = finalSortedBoxIds.map(
    (id) => {
      const box = netlist.boxes.find((b) => b.boxId === id);
      return {
        boxIndex: transform.boxIdToBoxIndex[id],
        leftPinCount: box.leftPinCount,
        rightPinCount: box.rightPinCount,
        topPinCount: box.topPinCount,
        bottomPinCount: box.bottomPinCount
      };
    }
  );
  const finalSortedNetIds = netlist.nets.map((n) => n.netId).sort((a, b) => encounterMap[a] - encounterMap[b]);
  finalSortedNetIds.forEach((nid, idx) => {
    transform.netIdToNetIndex[nid] = idx;
    transform.netIndexToNetId[idx] = nid;
  });
  const normalizedNets = finalSortedNetIds.map(
    (nid) => {
      const original = netlist.nets.find((n) => n.netId === nid);
      return {
        netIndex: transform.netIdToNetIndex[nid],
        isGround: original.isGround,
        isPositivePower: original.isPositivePower
      };
    }
  );
  const normalizedConnections = netlist.connections.map((c) => {
    const connectedPorts = c.connectedPorts.map((p) => {
      if ("boxId" in p) {
        return {
          boxIndex: transform.boxIdToBoxIndex[p.boxId],
          pinNumber: p.pinNumber
        };
      }
      return { netIndex: transform.netIdToNetIndex[p.netId] };
    }).sort((a, b) => {
      const aIsBox = "boxIndex" in a;
      const bIsBox = "boxIndex" in b;
      if (aIsBox && !bIsBox) return -1;
      if (!aIsBox && bIsBox) return 1;
      if (aIsBox && bIsBox) {
        if (a.boxIndex !== b.boxIndex) return a.boxIndex - b.boxIndex;
        return a.pinNumber - b.pinNumber;
      }
      return a.netIndex - b.netIndex;
    });
    return { connectedPorts };
  });
  normalizedConnections.sort((a, b) => {
    const sig = (x) => x.connectedPorts.map(
      (p) => "boxIndex" in p ? `b${p.boxIndex}p${p.pinNumber}` : `n${p.netIndex}`
    ).join(",");
    return sig(a).localeCompare(sig(b));
  });
  return {
    normalizedNetlist: {
      boxes: normalizedBoxes,
      nets: normalizedNets,
      connections: normalizedConnections
    },
    transform
  };
};

// lib/adapt/getPinSubsetNetlist.ts
function getPinSubsetNetlist(params) {
  const { netlist, chipId, pinNumber } = params;
  const pinBoxId = `${chipId}.pin${pinNumber}`;
  const newBoxes = [
    {
      boxId: pinBoxId,
      leftPinCount: 0,
      rightPinCount: 1,
      // This single pin will be pinNumber 1
      topPinCount: 0,
      bottomPinCount: 0
    }
  ];
  const newNets = [];
  const newConnections = [];
  const processedBoxIds = /* @__PURE__ */ new Set([pinBoxId]);
  const processedNetIds = /* @__PURE__ */ new Set();
  for (const connection of netlist.connections) {
    const isTargetPinInConnection = connection.connectedPorts.some(
      (p) => "boxId" in p && p.boxId === chipId && p.pinNumber === pinNumber
    );
    if (isTargetPinInConnection) {
      const subsetConnectionPorts = [
        { boxId: pinBoxId, pinNumber: 1 }
      ];
      for (const port of connection.connectedPorts) {
        if ("boxId" in port) {
          if (port.boxId === chipId && port.pinNumber === pinNumber) {
            continue;
          }
          subsetConnectionPorts.push({
            boxId: port.boxId,
            pinNumber: port.pinNumber
          });
          if (!processedBoxIds.has(port.boxId)) {
            const originalBox = netlist.boxes.find(
              (b) => b.boxId === port.boxId
            );
            if (originalBox) {
              newBoxes.push(originalBox);
            }
            processedBoxIds.add(port.boxId);
          }
        } else if ("netId" in port) {
          subsetConnectionPorts.push({
            netId: port.netId
          });
          if (!processedNetIds.has(port.netId)) {
            newNets.push({ netId: port.netId });
            processedNetIds.add(port.netId);
          }
        }
      }
      if (subsetConnectionPorts.length > 1) {
        newConnections.push({ connectedPorts: subsetConnectionPorts });
      }
    }
  }
  return {
    boxes: newBoxes,
    nets: newNets,
    connections: newConnections
  };
}

// lib/adapt/getPinShapeSignature.ts
var getBoxShapeSignature = (params) => {
  return [
    params.leftPinCount > 0 ? `L${params.leftPinCount}` : "",
    params.bottomPinCount > 0 ? `B${params.bottomPinCount}` : "",
    params.rightPinCount > 0 ? `R${params.rightPinCount}` : "",
    params.topPinCount > 0 ? `T${params.topPinCount}` : ""
  ].join("");
};
var getBoxCountPinSignature = (params) => {
  const { netlist, chipId, pinNumber } = params;
  const connectedBoxes = /* @__PURE__ */ new Set();
  for (const connection of netlist.connections) {
    const hasThisPin = connection.connectedPorts.some(
      (port) => "boxId" in port && port.boxId === chipId && port.pinNumber === pinNumber
    );
    if (hasThisPin) {
      for (const port of connection.connectedPorts) {
        if ("boxId" in port && port.boxId !== chipId) {
          connectedBoxes.add(port.boxId);
        }
      }
    }
  }
  return `box_count_${connectedBoxes.size}`;
};
var getPinShapeSignature = (params) => {
  let pinShapeNetlist;
  if ("pinShapeNetlist" in params) {
    pinShapeNetlist = params.pinShapeNetlist;
  } else {
    const { netlist, chipId, pinNumber } = params;
    pinShapeNetlist = getPinSubsetNetlist({
      chipId,
      pinNumber,
      netlist
    });
  }
  const normNetlist = normalizeNetlist(pinShapeNetlist);
  return `${normNetlist.normalizedNetlist.boxes.map((b) => getBoxShapeSignature(b)).join(",")}`;
};

// lib/matching/matched-box-issue-finders/findAllMatchedBoxMissingPinShapeOnSide.ts
function findAllMatchedBoxMissingPinShapeOnSide(params) {
  const candidateInputNetlist = convertNormalizedNetlistToInputNetlist(
    params.candidateNetlist
  );
  const targetInputNetlist = convertNormalizedNetlistToInputNetlist(
    params.targetNetlist
  );
  const candidatePinShapes = [];
  const candidateBox = candidateInputNetlist.boxes[params.candidateBoxIndex];
  const targetBox = targetInputNetlist.boxes[params.targetBoxIndex];
  const candidatePinCount = candidateBox.leftPinCount + candidateBox.rightPinCount + candidateBox.topPinCount + candidateBox.bottomPinCount;
  const isCandidatePassive = candidatePinCount === 2 && Math.max(
    candidateBox.leftPinCount,
    candidateBox.rightPinCount,
    candidateBox.topPinCount,
    candidateBox.bottomPinCount
  ) === 1;
  for (let i = 0; i < candidatePinCount; i++) {
    const pinNumber = i + 1;
    const pinShapeNetlist = getPinSubsetNetlist({
      netlist: candidateInputNetlist,
      chipId: candidateBox.boxId,
      pinNumber
    });
    candidatePinShapes.push({
      side: getPinSideIndex(pinNumber, candidateBox).side,
      signature: getPinShapeSignature({
        pinShapeNetlist
      })
    });
  }
  const unusedCandidatePinShapes = [...candidatePinShapes];
  const issues = [];
  const targetPinCount = targetBox.leftPinCount + targetBox.rightPinCount + targetBox.topPinCount + targetBox.bottomPinCount;
  const isTargetPassive = targetPinCount === 2 && Math.max(
    targetBox.leftPinCount,
    targetBox.rightPinCount,
    targetBox.topPinCount,
    targetBox.bottomPinCount
  ) === 1;
  for (let i = 0; i < targetPinCount; i++) {
    const targetPinNumber = i + 1;
    const targetPinShapeNetlist = getPinSubsetNetlist({
      netlist: targetInputNetlist,
      chipId: targetBox.boxId,
      pinNumber: targetPinNumber
    });
    if (targetPinShapeNetlist.connections.length === 0) {
      continue;
    }
    const targetPin = {
      signature: getPinShapeSignature({
        pinShapeNetlist: targetPinShapeNetlist
      }),
      side: getPinSideIndex(targetPinNumber, targetBox).side
    };
    const bothArePassives = isTargetPassive && isCandidatePassive;
    const matchingUnusedCandidatePinIndex = unusedCandidatePinShapes.findIndex(
      (candidatePin) => candidatePin.signature === targetPin.signature && (candidatePin.side === targetPin.side || bothArePassives)
    );
    if (matchingUnusedCandidatePinIndex !== -1) {
      unusedCandidatePinShapes.splice(matchingUnusedCandidatePinIndex, 1);
      continue;
    }
    issues.push({
      type: "matched_box_missing_pin_shape_on_side",
      candidateBoxIndex: params.candidateBoxIndex,
      targetBoxIndex: params.targetBoxIndex,
      targetPinNumber,
      targetPinShapeSignature: targetPin.signature,
      // @ts-ignore
      candidateShapeSignatures: unusedCandidatePinShapes.map(
        (candidatePin) => candidatePin.signature
      ),
      side: targetPin.side
    });
  }
  return issues;
}

// lib/matching/matched-box-issue-finders/findAllMatchedBoxMissingPinShapeBoxCountOnSide.ts
function findAllMatchedBoxMissingPinShapeBoxCountOnSide(params) {
  const { candidateNetlist, targetNetlist, candidateBoxIndex, targetBoxIndex } = params;
  const issues = [];
  const candidateInputNetlist = convertNormalizedNetlistToInputNetlist(candidateNetlist);
  const targetInputNetlist = convertNormalizedNetlistToInputNetlist(targetNetlist);
  const candidateBox = candidateInputNetlist.boxes[candidateBoxIndex];
  const targetBox = targetInputNetlist.boxes[targetBoxIndex];
  if (!candidateBox || !targetBox) return issues;
  const candidateBoxCountShapes = [];
  const candidatePinCount = candidateBox.leftPinCount + candidateBox.rightPinCount + candidateBox.topPinCount + candidateBox.bottomPinCount;
  for (let i = 0; i < candidatePinCount; i++) {
    const pinNumber = i + 1;
    const boxCountSignature = getBoxCountPinSignature({
      netlist: candidateInputNetlist,
      chipId: candidateBox.boxId,
      pinNumber
    });
    candidateBoxCountShapes.push({
      side: getPinSideIndex(pinNumber, candidateBox).side,
      signature: boxCountSignature
    });
  }
  const unusedCandidateBoxCountShapes = [...candidateBoxCountShapes];
  const totalTargetPinCount = targetBox.leftPinCount + targetBox.rightPinCount + targetBox.topPinCount + targetBox.bottomPinCount;
  const isSymmetricComponent = candidatePinCount === 2 && totalTargetPinCount === 2 && Math.max(
    candidateBox.leftPinCount,
    candidateBox.rightPinCount,
    candidateBox.topPinCount,
    candidateBox.bottomPinCount
  ) === 1 && Math.max(
    targetBox.leftPinCount,
    targetBox.rightPinCount,
    targetBox.topPinCount,
    targetBox.bottomPinCount
  ) === 1;
  if (isSymmetricComponent) {
    const candidateSignatures = candidateBoxCountShapes.map((shape) => shape.signature).filter((sig) => sig !== "box_count_0").sort();
    const targetSignatures = [];
    for (let i = 0; i < totalTargetPinCount; i++) {
      const targetPinNumber = i + 1;
      const targetBoxCountSignature = getBoxCountPinSignature({
        netlist: targetInputNetlist,
        chipId: targetBox.boxId,
        pinNumber: targetPinNumber
      });
      if (targetBoxCountSignature !== "box_count_0") {
        targetSignatures.push(targetBoxCountSignature);
      }
    }
    targetSignatures.sort();
    if (candidateSignatures.length > 0 && targetSignatures.length > 0) {
      if (candidateSignatures.join(",") !== targetSignatures.join(",")) {
        issues.push({
          type: "matched_box_missing_pin_shape_box_count_on_side",
          candidateBoxIndex,
          targetBoxIndex,
          side: "left",
          // Arbitrary side for symmetric components
          targetPinNumber: -1,
          // Not applicable for symmetric matching
          targetBoxCountSignature: targetSignatures.join(","),
          candidateBoxCountSignatures: candidateSignatures
        });
      }
    }
  } else {
    for (let i = 0; i < totalTargetPinCount; i++) {
      const targetPinNumber = i + 1;
      const targetBoxCountSignature = getBoxCountPinSignature({
        netlist: targetInputNetlist,
        chipId: targetBox.boxId,
        pinNumber: targetPinNumber
      });
      if (targetBoxCountSignature === "box_count_0") {
        continue;
      }
      const targetPin = {
        signature: targetBoxCountSignature,
        side: getPinSideIndex(targetPinNumber, targetBox).side
      };
      const matchingUnusedCandidateIndex = unusedCandidateBoxCountShapes.findIndex(
        (candidatePin) => candidatePin.signature === targetPin.signature && candidatePin.side === targetPin.side
      );
      if (matchingUnusedCandidateIndex === -1) {
        const candidateBoxCountSignatures = candidateBoxCountShapes.filter((shape) => shape.side === targetPin.side).map((shape) => shape.signature);
        issues.push({
          type: "matched_box_missing_pin_shape_box_count_on_side",
          candidateBoxIndex,
          targetBoxIndex,
          side: targetPin.side,
          targetPinNumber,
          targetBoxCountSignature,
          candidateBoxCountSignatures
        });
      } else {
        unusedCandidateBoxCountShapes.splice(matchingUnusedCandidateIndex, 1);
      }
    }
  }
  return issues;
}

// lib/matching/getIssuesForMatchedBoxes.ts
var MATCHED_BOX_ISSUE_FINDERS = [
  findAllSideHasWrongPinCount,
  findAllMatchedBoxMissingPinShapeOnSide,
  findAllMatchedBoxMissingPinShapeBoxCountOnSide
  // findAllMissingConnectionBetweenBoxes,
  // findAllMatchedBoxPinShapeInWrongPosition,
];
function getIssuesForMatchedBoxes(params) {
  const issues = [];
  for (const finder of MATCHED_BOX_ISSUE_FINDERS) {
    issues.push(...finder(params));
  }
  return issues;
}

// lib/matching/getNetlistVariationWithPassiveRotation.ts
function isPassiveBox(box) {
  const totalPins = box.leftPinCount + box.rightPinCount + box.topPinCount + box.bottomPinCount;
  if (totalPins !== 2) return false;
  const hasHorizontalPins = box.leftPinCount > 0 && box.rightPinCount > 0;
  const hasVerticalPins = box.topPinCount > 0 && box.bottomPinCount > 0;
  return hasHorizontalPins || hasVerticalPins;
}
function rotatePassiveBox(box) {
  return {
    ...box,
    leftPinCount: box.topPinCount,
    rightPinCount: box.bottomPinCount,
    topPinCount: box.leftPinCount,
    bottomPinCount: box.rightPinCount
  };
}
function flipPassiveBox(box) {
  return {
    ...box,
    leftPinCount: box.rightPinCount,
    rightPinCount: box.leftPinCount,
    topPinCount: box.bottomPinCount,
    bottomPinCount: box.topPinCount
  };
}
function getNetlistVariationWithPassiveRotation(params) {
  const { targetNetlist, candidateNetlist, targetBoxIndex, candidateBoxIndex } = params;
  const targetBox = targetNetlist.boxes[targetBoxIndex];
  const candidateBox = candidateNetlist.boxes[candidateBoxIndex];
  if (!targetBox || !candidateBox) {
    return [{ netlist: targetNetlist, rotation: 0 }];
  }
  if (!isPassiveBox(targetBox) || !isPassiveBox(candidateBox)) {
    return [{ netlist: targetNetlist, rotation: 0 }];
  }
  const variations = [];
  let rotatedBox = { ...targetBox };
  let rotationDegrees = 0;
  for (let i = 0; i < 4; i++) {
    if (rotatedBox.leftPinCount === candidateBox.leftPinCount && rotatedBox.rightPinCount === candidateBox.rightPinCount && rotatedBox.topPinCount === candidateBox.topPinCount && rotatedBox.bottomPinCount === candidateBox.bottomPinCount) {
      break;
    }
    rotatedBox = rotatePassiveBox(rotatedBox);
    rotationDegrees = (rotationDegrees + 90) % 360;
  }
  const variation1 = {
    ...targetNetlist,
    boxes: targetNetlist.boxes.map(
      (box, index) => index === targetBoxIndex ? rotatedBox : box
    )
  };
  variations.push({ netlist: variation1, rotation: rotationDegrees });
  const flippedBox = flipPassiveBox(rotatedBox);
  const variation2 = {
    ...targetNetlist,
    boxes: targetNetlist.boxes.map(
      (box, index) => index === targetBoxIndex ? flippedBox : box
    )
  };
  const flippedRotation = (rotationDegrees + 180) % 360;
  variations.push({ netlist: variation2, rotation: flippedRotation });
  return variations;
}

// lib/matching/getMatchedBoxes.ts
function getMatchedBoxes(params) {
  const {
    candidateNetlist,
    targetNetlist,
    candidateNormalizationTransform,
    targetNormalizationTransform
  } = params;
  const matchedBoxes = [];
  const usedCandidateBoxes = /* @__PURE__ */ new Set();
  for (let targetBoxIndex = 0; targetBoxIndex < targetNetlist.boxes.length; targetBoxIndex++) {
    const pairingResult = /* @__PURE__ */ new Map();
    for (let candidateBoxIndex = 0; candidateBoxIndex < candidateNetlist.boxes.length; candidateBoxIndex++) {
      if (usedCandidateBoxes.has(candidateBoxIndex)) {
        continue;
      }
      const targetNetlistVariations = getNetlistVariationWithPassiveRotation({
        targetNetlist,
        candidateNetlist,
        targetBoxIndex,
        candidateBoxIndex
      });
      let bestVariationIssues = [];
      let bestVariationScore = Infinity;
      let bestRotation = 0;
      for (const {
        netlist: variationNetlist,
        rotation
      } of targetNetlistVariations) {
        const issues = getIssuesForMatchedBoxes({
          candidateNetlist,
          targetNetlist: variationNetlist,
          candidateBoxIndex,
          targetBoxIndex,
          alreadyMatchedBoxes: matchedBoxes
        });
        const score = computeSimilarityDistanceFromIssues(issues);
        if (score < bestVariationScore) {
          bestVariationScore = score;
          bestVariationIssues = issues;
          bestRotation = rotation;
        }
      }
      pairingResult.set(
        { targetBoxIndex, candidateBoxIndex },
        {
          issues: bestVariationIssues,
          similarityDistance: bestVariationScore,
          rotation: bestRotation
        }
      );
    }
    let bestPairing = null;
    let bestScore = Infinity;
    for (const [
      pairing,
      { similarityDistance: score }
    ] of pairingResult.entries()) {
      if (score < bestScore) {
        bestScore = score;
        bestPairing = pairing;
      }
    }
    if (bestPairing) {
      const { candidateBoxIndex } = bestPairing;
      const {
        issues,
        similarityDistance: score,
        rotation
      } = pairingResult.get(bestPairing);
      usedCandidateBoxes.add(candidateBoxIndex);
      matchedBoxes.push({
        targetBoxIndex,
        candidateBoxIndex,
        issues,
        score,
        targetBoxRotationCcw: rotation
      });
    }
  }
  if (candidateNormalizationTransform && targetNormalizationTransform) {
    for (const matchedBox of matchedBoxes) {
      matchedBox._targetBoxId = targetNormalizationTransform.boxIndexToBoxId[matchedBox.targetBoxIndex];
      matchedBox._candidateBoxId = candidateNormalizationTransform.boxIndexToBoxId[matchedBox.candidateBoxIndex];
    }
  }
  return matchedBoxes;
}

// lib/adapt/transformTargetForPassiveCompatibility.ts
function transformTargetForPassiveCompatibility(template, target) {
  const transformedTarget = {
    boxes: target.boxes.map((box) => ({ ...box })),
    nets: target.nets?.map((net) => ({ ...net })) || [],
    connections: target.connections.map((conn) => ({
      ...conn,
      connectedPorts: [...conn.connectedPorts]
    }))
  };
  const currentNetlist = template.getNetlist();
  const normalizedTemplateResult = normalizeNetlist(currentNetlist);
  const normalizedTargetResult = normalizeNetlist(target);
  const normalizedTemplate = normalizedTemplateResult.normalizedNetlist;
  const normalizedTarget = normalizedTargetResult.normalizedNetlist;
  const matchedBoxes = getMatchedBoxes({
    candidateNetlist: normalizedTemplate,
    targetNetlist: normalizedTarget
  });
  const templatePassives = template.chips.filter((chip) => chip.isPassive);
  for (const templatePassive of templatePassives) {
    const templateBoxIndex = normalizedTemplateResult.transform.boxIdToBoxIndex[templatePassive.chipId];
    if (templateBoxIndex === void 0) continue;
    const match = matchedBoxes.find(
      (m) => m.candidateBoxIndex === templateBoxIndex
    );
    if (!match) continue;
    const targetBoxId = Object.entries(
      normalizedTargetResult.transform.boxIdToBoxIndex
    ).find(([_, boxIndex]) => boxIndex === match.targetBoxIndex)?.[0];
    if (!targetBoxId) continue;
    const targetBox = transformedTarget.boxes.find(
      (box) => box.boxId === targetBoxId
    );
    if (!targetBox) continue;
    try {
      const templateOrientation = detectPassiveOrientation(templatePassive);
      if (templateOrientation === "vertical") {
        if (targetBox.leftPinCount > 0 || targetBox.rightPinCount > 0) {
          const totalPins = targetBox.leftPinCount + targetBox.rightPinCount;
          targetBox.leftPinCount = 0;
          targetBox.rightPinCount = 0;
          targetBox.bottomPinCount = Math.ceil(totalPins / 2);
          targetBox.topPinCount = Math.floor(totalPins / 2);
        }
      } else {
        if (targetBox.bottomPinCount > 0 || targetBox.topPinCount > 0) {
          const totalPins = targetBox.bottomPinCount + targetBox.topPinCount;
          targetBox.bottomPinCount = 0;
          targetBox.topPinCount = 0;
          targetBox.leftPinCount = Math.ceil(totalPins / 2);
          targetBox.rightPinCount = Math.floor(totalPins / 2);
        }
      }
    } catch (error) {
      continue;
    }
  }
  return transformedTarget;
}

// lib/utils/getUnitVecFromSide.ts
function getUnitVecFromSide(side) {
  return side === "left" ? { dx: -1, dy: 0 } : side === "right" ? { dx: 1, dy: 0 } : side === "top" ? { dx: 0, dy: 1 } : { dx: 0, dy: -1 };
}

// lib/adapt/applyEditOperation/applyAddLabelToPin.ts
function applyAddLabelToPin(C, op) {
  const { chipId, pinNumber, netName } = op;
  const chip = C.chips.find((c) => c.chipId === chipId);
  if (!chip) return;
  if (pinNumber < 1 || pinNumber > chip.totalPinCount) return;
  const pin = chip.pin(pinNumber);
  if (!pin || typeof pin.line !== "function") return;
  const { side } = getPinSideIndex(pinNumber, chip);
  const { dx, dy } = getUnitVecFromSide(side);
  pin.line(dx * 2, dy * 2);
  const labelText = netName || C.generateAutoLabel();
  pin.label(labelText);
}

// lib/adapt/applyEditOperation/applyClearPin.ts
function applyClearPin(C, op) {
  const { chipId, pinNumber } = op;
  const match = (ref) => "boxId" in ref && ref.boxId === chipId && ref.pinNumber === pinNumber;
  C.lines = C.lines.filter((l) => !match(l.start.ref) && !match(l.end.ref));
  C.connectionPoints = C.connectionPoints.filter((cp) => !match(cp.pinRef));
  C.netLabels = C.netLabels.filter((nl) => !match(nl.fromRef));
}

// lib/adapt/applyEditOperation/applyAddPassiveToPin.ts
function applyAddPassiveToPin(C, op) {
  const { chipId, pinNumber } = op;
  const chip = C.chips.find((ch) => ch.chipId === chipId);
  if (!chip) return;
  const pin = chip.pin(pinNumber);
  if (pin.lastDx === 0 && pin.lastDy === 0 && !pin.lastCreatedLine) {
    const unitVec = getUnitVecFromSide(pin.side);
    pin.line(unitVec.dx * 2, unitVec.dy * 2);
  }
  pin.passive();
}

// lib/adapt/applyEditOperation/applyAddPassiveWithLabelToPin.ts
function applyAddPassiveWithLabelToPin(C, op) {
  const { chipId, pinNumber, labelNetId } = op;
  const chip = C.chips.find((ch) => ch.chipId === chipId);
  if (!chip) return;
  const pin = chip.pin(pinNumber);
  if (pin.lastDx === 0 && pin.lastDy === 0 && !pin.lastCreatedLine) {
    const unitVec = getUnitVecFromSide(pin.side);
    pin.line(unitVec.dx * 2, unitVec.dy * 2);
  }
  const passivePin = pin.passive();
  passivePin.label(labelNetId);
}

// lib/adapt/applyEditOperation/applyRemoveChip.ts
function applyRemoveChip(C, op) {
  const { chipId } = op;
  C.chips = C.chips.filter((c) => c.chipId !== chipId);
  const refBelongs = (ref) => "boxId" in ref && ref.boxId === chipId;
  const linesToChip = C.lines.filter(
    (l) => refBelongs(l.start.ref) || refBelongs(l.end.ref)
  );
  C.lines = C.lines.filter(
    (l) => !(refBelongs(l.start.ref) && refBelongs(l.end.ref))
  );
  for (const line of linesToChip) {
    if (refBelongs(line.start.ref) && refBelongs(line.end.ref)) {
      continue;
    }
    const chipEnd = refBelongs(line.start.ref) ? line.start : line.end;
    const otherEnd = refBelongs(line.start.ref) ? line.end : line.start;
    const isAtIntersection = isCoordinateAtIntersection(
      C,
      otherEnd.x,
      otherEnd.y,
      line
    );
    if (isAtIntersection) {
      C.lines = C.lines.filter((l) => l !== line);
    } else {
      C.lines = C.lines.filter((l) => l !== line);
      removeLineSegmentsUntilIntersection(
        C,
        otherEnd.x,
        otherEnd.y,
        otherEnd.ref,
        chipEnd.ref
      );
    }
  }
  C.connectionPoints = C.connectionPoints.filter((cp) => !refBelongs(cp.pinRef));
  C.netLabels = C.netLabels.filter((nl) => !refBelongs(nl.fromRef));
}
function isCoordinateAtIntersection(C, x, y, excludeLine) {
  let connectionCount = 0;
  for (const line of C.lines) {
    if (line === excludeLine) continue;
    if (line.start.x === x && line.start.y === y || line.end.x === x && line.end.y === y) {
      connectionCount++;
    }
  }
  for (const cp of C.connectionPoints) {
    if (cp.x === x && cp.y === y) {
      connectionCount++;
      break;
    }
  }
  return connectionCount >= 2;
}
function removeLineSegmentsUntilIntersection(C, x, y, currentRef, removedChipRef) {
  const continuingLines = C.lines.filter((line) => {
    const startsHere = line.start.x === x && line.start.y === y && !isSamePortRef(line.start.ref, removedChipRef);
    const endsHere = line.end.x === x && line.end.y === y && !isSamePortRef(line.end.ref, removedChipRef);
    return startsHere || endsHere;
  });
  for (const line of continuingLines) {
    const nextPoint = line.start.x === x && line.start.y === y ? line.end : line.start;
    const isNextIntersection = isCoordinateAtIntersection(
      C,
      nextPoint.x,
      nextPoint.y,
      line
    );
    if (isNextIntersection) {
      return;
    } else {
      C.lines = C.lines.filter((l) => l !== line);
      removeLineSegmentsUntilIntersection(
        C,
        nextPoint.x,
        nextPoint.y,
        nextPoint.ref,
        removedChipRef
      );
    }
  }
}

// lib/adapt/applyEditOperation/applyRemovePinFromSide.ts
var patchRefs = (circuit2, chipIdToPatch, map) => {
  const remap = (ref) => {
    if ("boxId" in ref && ref.boxId === chipIdToPatch && map.has(ref.pinNumber)) {
      return { ...ref, pinNumber: map.get(ref.pinNumber) };
    }
    return ref;
  };
  for (const l of circuit2.lines) {
    l.start.ref = remap(l.start.ref);
    l.end.ref = remap(l.end.ref);
  }
  for (const cp of circuit2.connectionPoints) cp.pinRef = remap(cp.pinRef);
  for (const nl of circuit2.netLabels) nl.fromRef = remap(nl.fromRef);
};
function applyRemovePinFromSide(C, op) {
  const { chipId, side, pinNumber: pinNumberToRemove } = op;
  const chip = C.chips.find((c) => c.chipId === chipId);
  if (!chip) return;
  const totalOldPins = chip.totalPinCount;
  if (pinNumberToRemove < 1 || pinNumberToRemove > totalOldPins)
    throw new Error(
      `Invalid pin number: ${pinNumberToRemove} for chip ${chip.chipId} with dimensions ${chip.leftPinCount}x${chip.bottomPinCount}x${chip.rightPinCount}x${chip.topPinCount}`
    );
  if (!chip.pinPositionsAreSet) {
    chip.setPinPositions();
  }
  const oldPos = /* @__PURE__ */ new Map();
  for (let pn = 1; pn <= totalOldPins; ++pn) {
    oldPos.set(pn, chip.getPinLocation(pn));
  }
  const matchRemovedPin = (ref) => "boxId" in ref && ref.boxId === chipId && ref.pinNumber === pinNumberToRemove;
  C.lines = C.lines.filter(
    (l) => !matchRemovedPin(l.start.ref) && !matchRemovedPin(l.end.ref)
  );
  C.connectionPoints = C.connectionPoints.filter(
    (cp) => !matchRemovedPin(cp.pinRef)
  );
  C.netLabels = C.netLabels.filter((nl) => !matchRemovedPin(nl.fromRef));
  let sideArr;
  let pinCountProp;
  switch (side) {
    case "left":
      sideArr = chip.leftPins;
      pinCountProp = "leftPinCount";
      break;
    case "right":
      sideArr = chip.rightPins;
      pinCountProp = "rightPinCount";
      break;
    case "top":
      sideArr = chip.topPins;
      pinCountProp = "topPinCount";
      break;
    case "bottom":
      sideArr = chip.bottomPins;
      pinCountProp = "bottomPinCount";
      break;
    default:
      return;
  }
  const indexInSideArray = sideArr.findIndex(
    (pb) => pb.pinNumber === pinNumberToRemove
  );
  if (indexInSideArray === -1) {
    throw new Error(
      `Pin number ${pinNumberToRemove} not found on side ${side} of chip ${chip.chipId}`
    );
  }
  sideArr.splice(indexInSideArray, 1);
  chip[pinCountProp]--;
  const renumberMap = /* @__PURE__ */ new Map();
  for (let oldPn = 1; oldPn <= totalOldPins; ++oldPn) {
    if (oldPn === pinNumberToRemove) continue;
    if (oldPn < pinNumberToRemove) {
      renumberMap.set(oldPn, oldPn);
    } else {
      renumberMap.set(oldPn, oldPn - 1);
    }
  }
  const allRemainingPbs = [
    ...chip.leftPins,
    ...chip.bottomPins,
    ...chip.rightPins,
    ...chip.topPins
  ];
  for (const pb of allRemainingPbs) {
    const oldPbPinNumber = pb.pinNumber;
    const newPbPinNumber = renumberMap.get(oldPbPinNumber);
    if (newPbPinNumber !== void 0) {
      ;
      pb.pinNumber = newPbPinNumber;
    }
  }
  const { side: removedPinSide, indexOnSide: removedIndexOnSide } = getPinSideIndex(pinNumberToRemove, {
    leftPinCount: chip.leftPinCount + (side === "left" ? 1 : 0),
    rightPinCount: chip.rightPinCount + (side === "right" ? 1 : 0),
    topPinCount: chip.topPinCount + (side === "top" ? 1 : 0),
    bottomPinCount: chip.bottomPinCount + (side === "bottom" ? 1 : 0)
  });
  const newPinMargins = {};
  for (const [oldPn, newPn] of renumberMap.entries()) {
    if (chip.pinMargins[oldPn]) {
      newPinMargins[newPn] = { ...chip.pinMargins[oldPn] };
    }
  }
  for (const [oldPn, newPn] of renumberMap.entries()) {
    const oldSideInfo = getPinSideIndex(oldPn, {
      leftPinCount: chip.leftPinCount + (side === "left" ? 1 : 0),
      rightPinCount: chip.rightPinCount + (side === "right" ? 1 : 0),
      topPinCount: chip.topPinCount + (side === "top" ? 1 : 0),
      bottomPinCount: chip.bottomPinCount + (side === "bottom" ? 1 : 0)
    });
    if (oldSideInfo.side === removedPinSide && oldSideInfo.indexOnSide > removedIndexOnSide) {
      const existingMargin = newPinMargins[newPn] || {
        marginTop: 0.2,
        marginLeft: 0.2
      };
      if (side === "left" || side === "right") {
        newPinMargins[newPn] = {
          ...existingMargin,
          marginTop: existingMargin.marginTop + 0.2
        };
      } else {
        newPinMargins[newPn] = {
          ...existingMargin,
          marginLeft: existingMargin.marginLeft + 0.2
        };
      }
    }
  }
  chip.pinMargins = newPinMargins;
  const finalEffectiveRenumberMap = /* @__PURE__ */ new Map();
  for (const [oldPn, newPn] of renumberMap.entries()) {
    if (oldPn !== newPn) {
      finalEffectiveRenumberMap.set(oldPn, newPn);
    }
  }
  if (finalEffectiveRenumberMap.size > 0) {
    patchRefs(C, chip.chipId, finalEffectiveRenumberMap);
  }
  chip.pinPositionsAreSet = false;
  chip.setPinPositions();
  const deltaByNewPin = /* @__PURE__ */ new Map();
  for (let oldPn = 1; oldPn <= totalOldPins; ++oldPn) {
    if (oldPn === pinNumberToRemove) continue;
    const newPn = renumberMap.get(oldPn);
    const posBefore = oldPos.get(oldPn);
    const posAfter = chip.getPinLocation(newPn);
    const dx = posAfter.x - posBefore.x;
    const dy = posAfter.y - posBefore.y;
    if (dx !== 0 || dy !== 0) {
      deltaByNewPin.set(newPn, { dx, dy });
    }
  }
  if (deltaByNewPin.size > 0) {
    const shiftForRef = (ref) => "boxId" in ref && ref.boxId === chipId && deltaByNewPin.has(ref.pinNumber) ? deltaByNewPin.get(ref.pinNumber) : null;
    for (const l of C.lines) {
      const dStart = shiftForRef(l.start.ref);
      const dEnd = shiftForRef(l.end.ref);
      const d = dStart ?? dEnd;
      if (d) {
        if (dStart) {
          l.start.x += dStart.dx;
          l.start.y += dStart.dy;
        }
        if (dEnd) {
          l.end.x += dEnd.dx;
          l.end.y += dEnd.dy;
        }
      }
    }
    for (const cp of C.connectionPoints) {
      const d = shiftForRef(cp.pinRef);
      if (d) {
        cp.x += d.dx;
        cp.y += d.dy;
      }
    }
    for (const nl of C.netLabels) {
      const d = shiftForRef(nl.fromRef);
      if (d) {
        nl.x += d.dx;
        nl.y += d.dy;
      }
    }
  }
}

// lib/adapt/applyEditOperation/applyAddPinToSide.ts
var patchRefs2 = (C, chipId, map) => {
  const remap = (ref) => "boxId" in ref && ref.boxId === chipId && map.has(ref.pinNumber) ? { ...ref, pinNumber: map.get(ref.pinNumber) } : ref;
  for (const l of C.lines) {
    l.start.ref = remap(l.start.ref);
    l.end.ref = remap(l.end.ref);
  }
  for (const cp of C.connectionPoints) cp.pinRef = remap(cp.pinRef);
  for (const nl of C.netLabels) nl.fromRef = remap(nl.fromRef);
};
function applyAddPinToSide(C, op) {
  const { chipId, side, betweenPinNumbers } = op;
  const chip = C.chips.find((c) => c.chipId === chipId);
  if (!chip) return;
  const totalOldPins = chip.totalPinCount;
  const oldPos = /* @__PURE__ */ new Map();
  for (let pn = 1; pn <= totalOldPins; ++pn) {
    oldPos.set(pn, chip.getPinLocation(pn));
  }
  const afterPin = Math.min(...betweenPinNumbers);
  const sideArr = side === "left" ? chip.leftPins : side === "right" ? chip.rightPins : side === "top" ? chip.topPins : chip.bottomPins;
  const insertIdx = sideArr.findIndex((pb) => pb.pinNumber === afterPin) + 1;
  if (afterPin !== 0 && insertIdx === 0) return;
  chip[`${side}PinCount`] += 1;
  const newPinNumber = afterPin + 1;
  const newPB = new PinBuilder(chip, newPinNumber);
  sideArr.splice(insertIdx, 0, newPB);
  const map = /* @__PURE__ */ new Map();
  const totalOldPinsBefore = chip.totalPinCount - 1;
  for (let oldPn = 1; oldPn <= totalOldPinsBefore; ++oldPn) {
    if (oldPn > afterPin) map.set(oldPn, oldPn + 1);
  }
  const newPinSet = /* @__PURE__ */ new Set([newPB]);
  const renumberArr = (arr) => arr.forEach((pb) => {
    if (newPinSet.has(pb)) return;
    if (map.has(pb.pinNumber)) pb.pinNumber = map.get(pb.pinNumber);
  });
  renumberArr(chip.leftPins);
  renumberArr(chip.rightPins);
  renumberArr(chip.topPins);
  renumberArr(chip.bottomPins);
  patchRefs2(C, chipId, map);
  chip.pinPositionsAreSet = false;
  chip.setPinPositions();
  const deltaByPin = /* @__PURE__ */ new Map();
  for (let oldPn = 1; oldPn <= totalOldPins; ++oldPn) {
    const before = oldPos.get(oldPn);
    const newPn = map.get(oldPn) ?? oldPn;
    const after = chip.getPinLocation(newPn);
    const dx = after.x - before.x;
    const dy = after.y - before.y;
    if (dx || dy) deltaByPin.set(newPn, { dx, dy });
  }
  const shiftForRef = (ref) => "boxId" in ref && ref.boxId === chipId && deltaByPin.has(ref.pinNumber) ? deltaByPin.get(ref.pinNumber) : null;
  for (const l of C.lines) {
    const d = shiftForRef(l.start.ref) ?? shiftForRef(l.end.ref);
    if (d) {
      l.start.x += d.dx;
      l.start.y += d.dy;
      l.end.x += d.dx;
      l.end.y += d.dy;
    }
  }
  for (const cp of C.connectionPoints) {
    const d = shiftForRef(cp.pinRef);
    if (d) {
      cp.x += d.dx;
      cp.y += d.dy;
    }
  }
  for (const nl of C.netLabels) {
    const d = shiftForRef(nl.fromRef);
    if (d) {
      nl.x += d.dx;
      nl.y += d.dy;
    }
  }
}

// lib/adapt/applyEditOperation/applyChangePassiveOrientation.ts
function applyChangePassiveOrientation(C, op) {
  const chip = C.chips.find((c) => c.chipId === op.chipId);
  if (!chip) {
    throw new Error(`Chip ${op.chipId} not found`);
  }
  if (!chip.isPassive) {
    throw new Error(`Chip ${op.chipId} is not a passive component`);
  }
  if (chip.totalPinCount !== 2) {
    throw new Error(
      `Passive orientation change only supports 2-pin passives, got ${chip.totalPinCount} pins`
    );
  }
  const currentOrientation = chip.leftPinCount > 0 || chip.rightPinCount > 0 ? "horizontal" : "vertical";
  if (currentOrientation === op.toOrientation) {
    return;
  }
  if (op.toOrientation === "horizontal") {
    chip.leftPinCount = 1;
    chip.rightPinCount = 1;
    chip.bottomPinCount = 0;
    chip.topPinCount = 0;
    chip.leftPins = [chip.bottomPins[0] || chip.topPins[0]];
    chip.rightPins = [chip.topPins[0] || chip.bottomPins[0]];
    chip.bottomPins = [];
    chip.topPins = [];
  } else {
    chip.bottomPinCount = 1;
    chip.topPinCount = 1;
    chip.leftPinCount = 0;
    chip.rightPinCount = 0;
    chip.bottomPins = [chip.leftPins[0] || chip.rightPins[0]];
    chip.topPins = [chip.rightPins[0] || chip.leftPins[0]];
    chip.leftPins = [];
    chip.rightPins = [];
  }
}

// lib/adapt/applyEditOperation/applyDrawLineBetweenPins.ts
function applyDrawLineBetweenPins(circuitBuilder, operation) {
  const { fromChipId, fromPinNumber, toChipId, toPinNumber, netName } = operation;
  const fromChip = circuitBuilder.chips.find(
    (chip) => chip.chipId === fromChipId
  );
  const toChip = circuitBuilder.chips.find((chip) => chip.chipId === toChipId);
  if (!fromChip) {
    throw new Error(`Could not find from chip with id: ${fromChipId}`);
  }
  if (!toChip) {
    throw new Error(`Could not find to chip with id: ${toChipId}`);
  }
  const fromPin = fromChip.pin(fromPinNumber);
  const toPin = toChip.pin(toPinNumber);
  if (!fromPin) {
    throw new Error(`Could not find pin ${fromPinNumber} on chip ${fromChipId}`);
  }
  if (!toPin) {
    throw new Error(`Could not find pin ${toPinNumber} on chip ${toChipId}`);
  }
  const toPinPos = toChip.getPinLocation(toPinNumber);
  const markName = netName || `connection_${fromChipId}_${fromPinNumber}_to_${toChipId}_${toPinNumber}`;
  fromPin.pathTo(toPinPos.x, toPinPos.y).mark(markName);
  toPin.connectToMark(markName);
}

// lib/adapt/applyEditOperation/index.ts
function applyEditOperation(C, op) {
  switch (op.type) {
    case "add_label_to_pin":
      applyAddLabelToPin(C, op);
      break;
    case "add_passive_to_pin":
      applyAddPassiveToPin(C, op);
      break;
    case "add_passive_with_label_to_pin":
      applyAddPassiveWithLabelToPin(C, op);
      break;
    case "clear_pin":
      applyClearPin(C, op);
      break;
    case "add_pin_to_side":
      applyAddPinToSide(C, op);
      break;
    case "remove_pin_from_side":
      applyRemovePinFromSide(C, op);
      break;
    case "remove_chip":
      applyRemoveChip(C, op);
      break;
    case "change_passive_orientation":
      applyChangePassiveOrientation(C, op);
      break;
    case "draw_line_between_pins":
      applyDrawLineBetweenPins(C, op);
      break;
  }
}

// lib/adapt/adaptation-operations/removeUnmatchedChips.ts
function removeUnmatchedChips(params) {
  const appliedOperations = [];
  const { template, target } = params;
  const currentNetlist = template.getNetlist();
  const normalizedTemplateResult = normalizeNetlist(currentNetlist);
  const normalizedTargetResult = normalizeNetlist(target);
  const normalizedTemplate = normalizedTemplateResult.normalizedNetlist;
  const normalizedTarget = normalizedTargetResult.normalizedNetlist;
  const matchedBoxes = getMatchedBoxes({
    candidateNetlist: normalizedTemplate,
    targetNetlist: normalizedTarget
  }).map((match) => ({
    ...match,
    candidateChipId: Object.entries(
      normalizedTemplateResult.transform.boxIdToBoxIndex
    ).find(([_, boxIndex]) => boxIndex === match.candidateBoxIndex)?.[0],
    targetChipId: Object.entries(
      normalizedTargetResult.transform.boxIdToBoxIndex
    ).find(([_, boxIndex]) => boxIndex === match.targetBoxIndex)?.[0]
  }));
  for (const chip of template.chips) {
    const wasMatched = matchedBoxes.some(
      (match) => match.candidateChipId === chip.chipId
    );
    if (wasMatched) continue;
    const op = {
      type: "remove_chip",
      chipId: chip.chipId
    };
    applyEditOperation(template, op);
    appliedOperations.push(op);
    break;
  }
  return { appliedOperations, matchedBoxes };
}

// lib/adapt/adaptation-operations/fixMatchedBoxPinCounts.ts
function fixMatchedBoxPinCounts(params) {
  const { template, target, matchedBoxes } = params;
  const appliedOperations = [];
  const targetBoxes = target.boxes;
  for (const { candidateChipId, targetChipId } of matchedBoxes) {
    const chip = template.chips.find((c) => c.chipId === candidateChipId);
    const targetBox = targetBoxes.find((b) => b.boxId === targetChipId);
    if (!targetBox || !chip) continue;
    if (chip.isPassive) continue;
    for (const side of SIDES_CCW) {
      const targetSideCount = targetBox[`${side}PinCount`];
      if (chip[`${side}PinCount`] < targetSideCount) {
        let afterPin;
        if (side === "left") {
          afterPin = 0;
        } else if (side === "bottom") {
          afterPin = chip.leftPinCount + chip.bottomPinCount;
        } else if (side === "right") {
          afterPin = chip.leftPinCount + chip.bottomPinCount + chip.rightPinCount;
        } else {
          afterPin = chip.totalPinCount;
        }
        const op = {
          type: "add_pin_to_side",
          chipId: chip.chipId,
          side,
          betweenPinNumbers: [afterPin, afterPin + 1]
        };
        applyEditOperation(template, op);
        appliedOperations.push(op);
        return { appliedOperations };
      }
      if (chip[`${side}PinCount`] > targetSideCount) {
        const bestPinToRemove = findBestPinToRemove({
          template,
          target,
          chipId: chip.chipId,
          side
        });
        const op = {
          type: "remove_pin_from_side",
          chipId: chip.chipId,
          side,
          pinNumber: bestPinToRemove
        };
        applyEditOperation(template, op);
        appliedOperations.push(op);
        return { appliedOperations };
      }
    }
  }
  return { appliedOperations };
}
function findBestPinToRemove(params) {
  const { template, target, chipId, side } = params;
  const chip = template.chips.find((c) => c.chipId === chipId);
  if (!chip) throw new Error(`Chip ${chipId} not found`);
  const sidePinsMap = {
    left: chip.leftPins,
    right: chip.rightPins,
    top: chip.topPins,
    bottom: chip.bottomPins
  };
  const sidePins = sidePinsMap[side];
  if (sidePins.length === 0) {
    throw new Error(`No pins found on side ${side} of chip ${chipId}`);
  }
  let bestPinNumber = sidePins[sidePins.length - 1].pinNumber;
  let bestDistance = Number.POSITIVE_INFINITY;
  for (const pin of sidePins) {
    try {
      const testTemplate = template.clone();
      const testOp = {
        type: "remove_pin_from_side",
        chipId,
        side,
        pinNumber: pin.pinNumber
      };
      applyEditOperation(testTemplate, testOp);
      const distance = computeSimilarityDistanceAfterRemoval(
        testTemplate,
        target
      );
      if (distance < bestDistance) {
        bestDistance = distance;
        bestPinNumber = pin.pinNumber;
      }
    } catch (error) {
      continue;
    }
  }
  return bestPinNumber;
}
function computeSimilarityDistanceAfterRemoval(template, target) {
  try {
    const normalizedTemplate = normalizeNetlist(template.getNetlist());
    const normalizedTarget = normalizeNetlist(target);
    const matchedBoxes = getMatchedBoxes({
      candidateNetlist: normalizedTemplate.normalizedNetlist,
      targetNetlist: normalizedTarget.normalizedNetlist
    });
    const allIssues = matchedBoxes.flatMap((match) => match.issues || []);
    return computeSimilarityDistanceFromIssues(allIssues);
  } catch (error) {
    return Number.POSITIVE_INFINITY;
  }
}

// lib/adapt/adaptation-operations/fixMatchedBoxPinShapes.ts
function fixMatchedBoxPinShapes(params) {
  const { template, target, matchedBoxes } = params;
  const appliedOperations = [];
  for (const { candidateChipId, targetChipId } of matchedBoxes) {
    const chip = template.chips.find((c) => c.chipId === candidateChipId);
    const targetBox = target.boxes.find((b) => b.boxId === targetChipId);
    if (!targetBox || !chip) continue;
    const sides = ["left", "right", "top", "bottom"];
    for (const side of sides) {
      const templatePinCount = chip[`${side}PinCount`];
      const targetPinCount = targetBox[`${side}PinCount`] || 0;
      if (templatePinCount > targetPinCount) {
        const excessPins = templatePinCount - targetPinCount;
        const bestRemovalOps = findBestPinRemovalStrategy({
          template,
          chipId: candidateChipId,
          side,
          pinsToRemove: excessPins
        });
        if (bestRemovalOps.length > 0) {
          const op = bestRemovalOps[0];
          applyEditOperation(template, op);
          appliedOperations.push(op);
          return { appliedOperations };
        }
      }
    }
  }
  return { appliedOperations };
}
function findBestPinRemovalStrategy(params) {
  const { template, chipId, side, pinsToRemove } = params;
  const chip = template.chips.find((c) => c.chipId === chipId);
  if (!chip) return [];
  const sidePinsMap = {
    left: chip.leftPins,
    right: chip.rightPins,
    top: chip.topPins,
    bottom: chip.bottomPins
  };
  const sidePins = sidePinsMap[side];
  if (sidePins.length <= pinsToRemove) {
    return sidePins.map((pin) => ({
      type: "remove_pin_from_side",
      chipId,
      side,
      pinNumber: pin.pinNumber
    }));
  }
  const highestPin = sidePins[sidePins.length - 1];
  return [
    {
      type: "remove_pin_from_side",
      chipId,
      side,
      pinNumber: highestPin.pinNumber
    }
  ];
}

// lib/adapt/adaptation-operations/drawMissingConnections.ts
function getPossiblePinNumbers(chip, pin) {
  if (!chip?.isPassive) return [pin];
  if (chip.totalPinCount === 2) {
    return pin === 1 ? [1, 2] : pin === 2 ? [2, 1] : [pin];
  }
  return [pin];
}
function drawMissingConnections(params) {
  const appliedOperations = [];
  const { template, target, matchedBoxes } = params;
  const targetConnections = target.connections || [];
  for (const targetConnection of targetConnections) {
    const boxPorts = targetConnection.connectedPorts.filter(
      (port) => "boxId" in port
    );
    if (boxPorts.length !== 2) {
      continue;
    }
    const [fromPort, toPort] = boxPorts;
    if (!fromPort || !toPort) {
      continue;
    }
    const fromBoxMatch = matchedBoxes.find(
      (match) => target.boxes?.[match.targetBoxIndex]?.boxId === fromPort.boxId
    );
    const toBoxMatch = matchedBoxes.find(
      (match) => target.boxes?.[match.targetBoxIndex]?.boxId === toPort.boxId
    );
    if (!fromBoxMatch?.candidateChipId || !toBoxMatch?.candidateChipId) {
      continue;
    }
    const templateFromChipId = fromBoxMatch.candidateChipId;
    const templateToChipId = toBoxMatch.candidateChipId;
    const templateNetlist = template.getNetlist();
    const templateConnections = templateNetlist.connections || [];
    const fromChip = template.chips.find((c) => c.chipId === templateFromChipId);
    const toChip = template.chips.find((c) => c.chipId === templateToChipId);
    const possibleFromPins = getPossiblePinNumbers(fromChip, fromPort.pinNumber);
    const possibleToPins = getPossiblePinNumbers(toChip, toPort.pinNumber);
    const connectionExists = templateConnections.some((templateConnection) => {
      const templateBoxPorts = templateConnection.connectedPorts.filter(
        (port) => "boxId" in port
      );
      for (const pf of possibleFromPins) {
        for (const pt of possibleToPins) {
          const hasFromChipPin = templateBoxPorts.some(
            (port) => port.boxId === templateFromChipId && port.pinNumber === pf
          );
          const hasToChipPin = templateBoxPorts.some(
            (port) => port.boxId === templateToChipId && port.pinNumber === pt
          );
          if (hasFromChipPin && hasToChipPin) {
            return true;
          }
        }
      }
      return false;
    });
    if (!connectionExists) {
      const op = {
        type: "draw_line_between_pins",
        fromChipId: templateFromChipId,
        fromPinNumber: fromPort.pinNumber,
        toChipId: templateToChipId,
        toPinNumber: toPort.pinNumber
      };
      try {
        applyEditOperation(template, op);
        appliedOperations.push(op);
        break;
      } catch (error) {
        console.warn(`Failed to apply draw line operation:`, error);
      }
    }
  }
  return { appliedOperations };
}

// lib/solvers/AdaptTemplateToNetlistSolver.ts
var AdaptTemplateToNetlistSolver = class extends BaseSolver {
  inputTemplate;
  targetNetlist;
  transformedTarget = null;
  outputAdaptedTemplate = null;
  outputAppliedOperations = [];
  phase = "transform-target";
  matchedBoxes = [];
  stepCount = 0;
  maxSteps = 100;
  constructor(opts) {
    super();
    this.inputTemplate = opts.inputTemplate;
    this.targetNetlist = opts.targetNetlist;
  }
  getConstructorParams() {
    return {
      inputTemplate: this.inputTemplate,
      targetNetlist: this.targetNetlist
    };
  }
  getStatsSummary() {
    return `Phase: ${this.phase}, ${this.outputAppliedOperations.length} operations applied`;
  }
  _step() {
    this.stepCount++;
    if (this.stepCount > this.maxSteps) {
      console.warn(
        `AdaptTemplateToNetlistSolver exceeded max steps (${this.maxSteps}), stopping`
      );
      this.solved = true;
      return;
    }
    if (!this.outputAdaptedTemplate) {
      this.outputAdaptedTemplate = this.inputTemplate.clone();
    }
    switch (this.phase) {
      case "transform-target":
        this.transformedTarget = transformTargetForPassiveCompatibility(
          this.outputAdaptedTemplate,
          this.targetNetlist
        );
        this.phase = "remove-unmatched-chips-1";
        break;
      case "remove-unmatched-chips-1": {
        const removal1Result = removeUnmatchedChips({
          template: this.outputAdaptedTemplate,
          target: this.transformedTarget
        });
        this.matchedBoxes = removal1Result.matchedBoxes;
        if (removal1Result.appliedOperations.length > 0) {
          const operation = removal1Result.appliedOperations[0];
          this.outputAppliedOperations.push(operation);
        } else {
          this.phase = "fix-matched-box-pin-counts";
        }
        break;
      }
      case "fix-matched-box-pin-counts": {
        const pinCountsRemovalResult = removeUnmatchedChips({
          template: this.outputAdaptedTemplate,
          target: this.transformedTarget
        });
        const fixPinCountsResult = fixMatchedBoxPinCounts({
          template: this.outputAdaptedTemplate,
          target: this.transformedTarget,
          matchedBoxes: pinCountsRemovalResult.matchedBoxes
        });
        if (fixPinCountsResult.appliedOperations.length > 0) {
          const operation = fixPinCountsResult.appliedOperations[0];
          this.outputAppliedOperations.push(operation);
        } else {
          this.phase = "fix-matched-box-pin-shapes";
        }
        break;
      }
      case "fix-matched-box-pin-shapes": {
        const currentRemovalResult = removeUnmatchedChips({
          template: this.outputAdaptedTemplate,
          target: this.transformedTarget
        });
        const fixPinShapesResult = fixMatchedBoxPinShapes({
          template: this.outputAdaptedTemplate,
          target: this.transformedTarget,
          matchedBoxes: currentRemovalResult.matchedBoxes
        });
        if (fixPinShapesResult.appliedOperations.length > 0) {
          const operation = fixPinShapesResult.appliedOperations[0];
          this.outputAppliedOperations.push(operation);
        } else {
          this.phase = "remove-unmatched-chips-2";
        }
        break;
      }
      case "remove-unmatched-chips-2": {
        const removal2Result = removeUnmatchedChips({
          template: this.outputAdaptedTemplate,
          target: this.transformedTarget
        });
        if (removal2Result.appliedOperations.length > 0) {
          const operation = removal2Result.appliedOperations[0];
          this.outputAppliedOperations.push(operation);
        } else {
          this.phase = "draw-missing-connections";
        }
        break;
      }
      case "draw-missing-connections": {
        const currentRemovalResult = removeUnmatchedChips({
          template: this.outputAdaptedTemplate,
          target: this.transformedTarget
        });
        const drawConnectionsResult = drawMissingConnections({
          template: this.outputAdaptedTemplate,
          target: this.transformedTarget,
          matchedBoxes: currentRemovalResult.matchedBoxes
        });
        if (drawConnectionsResult.appliedOperations.length > 0) {
          const operation = drawConnectionsResult.appliedOperations[0];
          this.outputAppliedOperations.push(operation);
        } else {
          this.phase = "complete";
        }
        break;
      }
      case "complete":
        this.stats = {
          operationCount: this.outputAppliedOperations.length,
          templateBoxCount: this.outputAdaptedTemplate.getNetlist().boxes?.length || 0,
          targetBoxCount: this.targetNetlist.boxes?.length || 0
        };
        this.solved = true;
        break;
    }
  }
  visualize() {
    return [
      {
        title: "inputTemplate",
        ascii: this.inputTemplate.toString()
      },
      {
        title: "targetNetlist",
        ascii: getReadableNetlist(this.targetNetlist)
      },
      {
        title: "adaptedTemplate",
        ascii: this.outputAdaptedTemplate?.toString() || "No adapted template"
      },
      {
        title: "appliedOperations",
        table: this.outputAppliedOperations.map((op, index) => ({
          operation_index: index,
          type: op.type,
          details: op
        }))
      },
      {
        title: "inputTemplateReadableNetlist",
        ascii: this.inputTemplate.getReadableNetlist()
      },
      {
        title: "adaptedTemplateReadableNetlist",
        ascii: this.outputAdaptedTemplate?.getReadableNetlist() || "No adapted template"
      }
    ];
  }
};

// lib/solvers/AdaptPhaseSolver.ts
var AdaptPhaseSolver = class extends BaseSolver {
  matchedTemplates;
  adaptationSolvers = [];
  currentAdaptationIndex = 0;
  outputAdaptedTemplates = [];
  constructor(opts) {
    super();
    this.matchedTemplates = opts.matchedTemplates;
    this.adaptationSolvers = this.matchedTemplates.map(
      (match) => new AdaptTemplateToNetlistSolver({
        inputTemplate: match.template,
        targetNetlist: match.netlist
      })
    );
    this.setActiveSubSolver(
      this.adaptationSolvers[this.currentAdaptationIndex]
    );
  }
  getConstructorParams() {
    return {
      matchedTemplates: this.matchedTemplates
    };
  }
  computeProgress() {
    if (this.adaptationSolvers.length === 0) return 1;
    return this.currentAdaptationIndex / this.adaptationSolvers.length;
  }
  _step() {
    if (this.currentAdaptationIndex < this.adaptationSolvers.length) {
      const currentSolver = this.adaptationSolvers[this.currentAdaptationIndex];
      if (!currentSolver.solved && !currentSolver.failed) {
        currentSolver.step();
        return;
      }
      this.clearActiveSubSolver();
      if (currentSolver.solved && currentSolver.outputAdaptedTemplate) {
        this.outputAdaptedTemplates.push({
          template: currentSolver.outputAdaptedTemplate,
          netlist: this.matchedTemplates[this.currentAdaptationIndex].netlist,
          appliedOperations: currentSolver.outputAppliedOperations
        });
      }
      this.currentAdaptationIndex++;
      this.setActiveSubSolver(
        this.adaptationSolvers[this.currentAdaptationIndex]
      );
      return;
    }
    this.solved = true;
  }
};

// templates/template1.ts
var template1_default = () => {
  const C = circuit({
    name: "Template 1"
  });
  const U1 = C.chip().leftpins(2).rightpins(2);
  U1.pin(1).line(-8, 0).line(0, -2).passive().line(0, -2).label();
  U1.pin(2).line(-3, 0).line(0, -2).label();
  U1.pin(3).line(4, 0).label();
  U1.pin(4).line(4, 0).label();
  return C;
};

// templates/template2.ts
var template2_default = () => {
  const C = circuit({
    name: "Template 2"
  });
  const J1 = C.chip("J1").rightpins(7);
  J1.pin(7).line(2, 0).line(0, 1).label("VUSB");
  J1.pin(6).line(3, 0).line(0, 0.4).line(2, 0).passive("R9").line(1, 0).label("P");
  J1.pin(5).line(5, 0).passive("R0").line(1, 0).label("M");
  J1.pin(4).line(5, 0).line(0, -0.6).passive("R2").line(0, -1).label("GND");
  J1.pin(3).line(3, 0).line(0, -0.4).passive("R1").line(0, -1).label("GND");
  J1.pin(2).line(1, 0).line(0, -2.2).label("GND");
  J1.pin(1).line(1, 0).intersect();
  return C;
};

// templates/template3.ts
var template3_default = () => {
  const C = circuit({
    name: "Template 3"
  });
  const U1 = C.chip().rightpins(3);
  U1.pin(3).line(4, 0).mark("m0").line(3, 0).mark("m1").line(0, 1).label();
  U1.fromMark("m1").line(0, -2).passive().line(0, -3).label();
  U1.pin(2).line(2, 0).line(0, -4).line(2, 0).line(0, 1.2).passive().line(0, 2).intersectAtMark("m0");
  U1.pin(1).line(1, 0).line(0, -3).label();
  return C;
};

// templates/template4.ts
var template4_default = () => {
  const C = circuit({
    name: "Template 4"
  });
  const U1 = C.chip().rightpins(3);
  U1.pin(3).line(4, 0).mark("m1").line(0, 2).label();
  U1.fromMark("m1").line(0, -2).passive().line(0, -2).label();
  U1.pin(2).line(2, 0).label();
  U1.pin(1).line(1, 0).line(0, -2).label();
  return C;
};

// templates/template5.ts
var template5_default = () => {
  const C = circuit({
    name: "Template 5"
  });
  const U1 = C.chip().leftpins(2).rightpins(2).at(0, 0);
  const U2 = C.chip().leftpins(1).rightpins(1).at(10, 0.2);
  U1.pin(4).line(3, 0).mark("bus");
  U2.pin(1).connectToMark("bus");
  return C;
};

// templates/template6.ts
var template6_default = () => {
  const C = circuit({
    name: "Template 6"
  });
  const U2 = C.chip("U2").leftpins(3).rightpins(3).at(0, 0);
  U2.pin(1).line(-1.9, 0).mark("vin1").line(-1, 0).mark("vin2").line(0, 0.8).label();
  U2.fromMark("vin2").line(0, -0.4).passive("C1").line(0, -1).label("GND");
  U2.fromMark("vin1").line(0, -0.4).passive("R3").line(0, -0.4).mark("en1").line(-0.2, 0).label();
  U2.pin(2).line(-1, 0).intersectAtMark("en1");
  U2.pin(3).line(-0.5, 0).line(0, -2).label("GND");
  U2.pin(6).line(1, 0).mark("VOUT").line(0, -0.4).passive("C2").line(0, -1).label("GND");
  U2.fromMark("VOUT").line(0, 0.8).label();
  return C;
};

// templates/template7.ts
var template7_default = () => {
  const C = circuit({
    name: "Template 7"
  });
  const U1 = C.chip("U1").leftpins(3).rightpins(3).at(0, 0);
  const J2 = C.chip("J2").leftpins(2).at(9, 0.2);
  U1.pin(1).line(-2, 0).mark("VUSB1").line(-1, 0).mark("VUSB2").line(0, 0.2).label("VUSB");
  U1.fromMark("VUSB2").line(0, -0.4).passive("C3").line(0, -0.2).label("GND");
  U1.fromMark("VUSB1").line(0, -0.2).passive("D4").line(0, -0.2).mark("belowD4");
  U1.pin(3).line(-1, 0).line(0, -0.2).passive("R5").line(0, -0.2).connectToMark("belowD4");
  U1.pin(4).line(1, 0).line(0, -1.2).line(1, 0).mark("GND1").line(1, 0).mark("GND2").line(2, 0).mark("aboveGND").line(0, -0.2).label("GND");
  U1.pin(5).line(2, 0).line(0, -0.2).passive("R6").connectToMark("GND1");
  U1.pin(6).line(2, 0).mark("belowVBat").line(1, 0).mark("aboveC4");
  U1.fromMark("belowVBat").line(0, 0.2).label("VBAT");
  J2.pin(1).connectToMark("aboveC4");
  U1.fromMark("aboveGND").line(0, 0.8).mark("aboveGND2");
  U1.fromMark("aboveC4").line(0, -0.4).passive("C4").connectToMark("GND2");
  J2.pin(2).connectToMark("aboveGND2");
  return C;
};

// templates/template8.ts
var template8_default = () => {
  const C = circuit({
    name: "Template 8"
  });
  const U1 = C.chip("U1").leftpins(4).at(0, 0);
  U1.pin(1).line(-2, 0).label("SCL");
  U1.pin(2).line(-2, 0).label("SDA");
  U1.pin(3).line(-1, 0).line(0, 0.8).label("V3_3");
  U1.pin(4).line(-1, 0).line(0, -0.4).label("GND");
  return C;
};

// templates/template9.ts
var template9_default = () => {
  const C = circuit({
    name: "Template 9"
  });
  const U3 = C.chip("U3").leftpins(6).rightpins(6);
  U3.pin(1).line(-1, 0).mark("aboveC2").line(0, -1e-3).passive("C20").line(0, -1e-3).mark("GND1").line(0, -0.2).label("GND");
  U3.fromMark("aboveC2").line(0, 0.2).label("V3_3");
  U3.pin(6).intersectAtMark("GND1");
  U3.pin(7).line(2, 0).line(0, 0.2).mark("rightOf7").line(0, 2).label("V3_3");
  U3.pin(8).intersectAtMark("rightOf7");
  U3.pin(9).line(3, 0).label();
  U3.pin(10).line(3, 0).label();
  U3.pin(11).line(3, 0).label();
  U3.pin(12).line(1, 0).mark("rightOfNCS").line(2, 0).label();
  U3.fromMark("rightOfNCS").line(0, 0.2).passive("R11").line(0, 0.2).label("V3_3");
  return C;
};

// templates/index.ts
var TEMPLATE_FN_MAP = {
  template1: template1_default,
  template2: template2_default,
  template3: template3_default,
  template4: template4_default,
  template5: template5_default,
  template6: template6_default,
  template7: template7_default,
  template8: template8_default,
  template9: template9_default
};
var TEMPLATE_FNS = Object.values(TEMPLATE_FN_MAP);

// lib/matching/matching-utils/rotateInputBox.ts
function rotateInputBox(box, degrees) {
  switch (degrees) {
    case 0:
      return box;
    case 90:
      return {
        ...box,
        leftPinCount: box.bottomPinCount,
        rightPinCount: box.topPinCount,
        topPinCount: box.leftPinCount,
        bottomPinCount: box.rightPinCount
      };
    case 180:
      return {
        ...box,
        leftPinCount: box.rightPinCount,
        rightPinCount: box.leftPinCount,
        topPinCount: box.bottomPinCount,
        bottomPinCount: box.topPinCount
      };
    case 270:
      return {
        ...box,
        leftPinCount: box.topPinCount,
        rightPinCount: box.bottomPinCount,
        topPinCount: box.rightPinCount,
        bottomPinCount: box.leftPinCount
      };
    default:
      return box;
  }
}

// lib/matching/matching-utils/applyMatchedBoxRotationsToInputNetlist.ts
function getPinNumberAfterRotation(pinNumber, originalBox, rotationDegrees) {
  if (rotationDegrees === 0) return pinNumber;
  const { side, indexOnSide } = getPinSideIndex(pinNumber, originalBox);
  const rotatedBox = rotateInputBox(originalBox, rotationDegrees);
  let newSide;
  switch (rotationDegrees) {
    case 90:
      switch (side) {
        case "left":
          newSide = "top";
          break;
        case "bottom":
          newSide = "left";
          break;
        case "right":
          newSide = "bottom";
          break;
        case "top":
          newSide = "right";
          break;
        default:
          newSide = side;
      }
      break;
    case 180:
      switch (side) {
        case "left":
          newSide = "right";
          break;
        case "right":
          newSide = "left";
          break;
        case "top":
          newSide = "bottom";
          break;
        case "bottom":
          newSide = "top";
          break;
        default:
          newSide = side;
      }
      break;
    case 270:
      switch (side) {
        case "left":
          newSide = "bottom";
          break;
        case "bottom":
          newSide = "right";
          break;
        case "right":
          newSide = "top";
          break;
        case "top":
          newSide = "left";
          break;
        default:
          newSide = side;
      }
      break;
    default:
      newSide = side;
  }
  let newIndexOnSide = indexOnSide;
  const originalSidePinCount = originalBox[`${side}PinCount`];
  if (rotationDegrees === 180) {
    newIndexOnSide = originalSidePinCount - 1 - indexOnSide;
  } else if (rotationDegrees === 90) {
    if (side === "left" || side === "right") {
      newIndexOnSide = originalSidePinCount - 1 - indexOnSide;
    }
  } else if (rotationDegrees === 270) {
    if (side === "left" || side === "right") {
      newIndexOnSide = originalSidePinCount - 1 - indexOnSide;
    }
  }
  let currentPinNumber = 1;
  const sides = ["left", "bottom", "right", "top"];
  for (const checkSide of sides) {
    const sidePinCount = rotatedBox[`${checkSide}PinCount`];
    if (!sidePinCount) continue;
    if (checkSide === newSide) {
      return currentPinNumber + newIndexOnSide;
    }
    currentPinNumber += sidePinCount;
  }
  throw new Error(
    `Could not map pin ${pinNumber} after ${rotationDegrees}\xB0 rotation`
  );
}
function applyMatchedBoxRotationsToInputNetlist(params) {
  const { inputNetlist, matchedBoxes } = params;
  const rotationMap = /* @__PURE__ */ new Map();
  for (const matchedBox of matchedBoxes) {
    rotationMap.set(matchedBox.targetBoxIndex, matchedBox.targetBoxRotationCcw);
  }
  const rotatedBoxes = inputNetlist.boxes.map((box, index) => {
    const rotation = rotationMap.get(index);
    if (rotation) {
      return rotateInputBox(box, rotation);
    }
    return box;
  });
  const updatedConnections = inputNetlist.connections.map(
    (connection) => {
      const updatedPorts = connection.connectedPorts.map((port) => {
        if ("boxId" in port) {
          const boxIndex = inputNetlist.boxes.findIndex(
            (box) => box.boxId === port.boxId
          );
          if (boxIndex !== -1) {
            const rotation = rotationMap.get(boxIndex);
            if (rotation) {
              const originalBox = inputNetlist.boxes[boxIndex];
              const newPinNumber = getPinNumberAfterRotation(
                port.pinNumber,
                originalBox,
                rotation
              );
              return { ...port, pinNumber: newPinNumber };
            }
          }
        }
        return port;
      });
      return { ...connection, connectedPorts: updatedPorts };
    }
  );
  return {
    ...inputNetlist,
    boxes: rotatedBoxes,
    connections: updatedConnections
  };
}

// lib/matching/matching-utils/getAsciiForNetlistBox.ts
function getAsciiForNetlistBox(boxIndex, netlist, transform, maxWidth = 45) {
  if (!transform) return [`Box ${boxIndex} (no transform)`];
  const boxId = Object.keys(transform.boxIdToBoxIndex).find(
    (id) => transform.boxIdToBoxIndex[id] === boxIndex
  );
  if (!boxId) return [`Box ${boxIndex} (not found)`];
  const box = netlist.boxes.find((b) => b.boxId === boxId);
  if (!box) return [`Box ${boxId} (not found)`];
  const output = [];
  const { leftPinCount, rightPinCount, topPinCount, bottomPinCount } = box;
  const BOX_INNER_WIDTH = Math.min(maxWidth - 4, 16);
  const SIDE_PADDING_WIDTH = 2;
  const bodyHeight = Math.max(leftPinCount, rightPinCount, 1);
  let displayBoxId = boxId;
  if (boxId.length > BOX_INNER_WIDTH - 2) {
    displayBoxId = `${boxId.substring(0, BOX_INNER_WIDTH - 3)}\u2026`;
  }
  if (topPinCount > 0) {
    let pinsRow = "";
    for (let i = 0; i < topPinCount; i++) {
      const pinNum = leftPinCount + bottomPinCount + rightPinCount + i + 1;
      pinsRow += pinNum.toString().padStart(2);
    }
    const pinsRowTrimmed = pinsRow.substring(0, BOX_INNER_WIDTH);
    const centerPadding = Math.floor(
      (BOX_INNER_WIDTH - pinsRowTrimmed.length) / 2
    );
    const centeredPinsRow = " ".repeat(centerPadding) + pinsRowTrimmed;
    output.push(`${" ".repeat(SIDE_PADDING_WIDTH + 1)}${centeredPinsRow}`);
  }
  output.push(
    `${" ".repeat(SIDE_PADDING_WIDTH)}\u250C${"\u2500".repeat(BOX_INNER_WIDTH)}\u2510`
  );
  for (let i = 0; i < bodyHeight; i++) {
    const leftPin = i < leftPinCount ? (i + 1).toString() : "";
    const rightPin = i < rightPinCount ? (leftPinCount + bottomPinCount + (rightPinCount - 1 - i) + 1).toString() : "";
    let lineContent = "";
    if (i === Math.floor((bodyHeight - 1) / 2)) {
      const paddingLeft = Math.floor(
        (BOX_INNER_WIDTH - displayBoxId.length) / 2
      );
      const paddingRight = BOX_INNER_WIDTH - displayBoxId.length - paddingLeft;
      lineContent = " ".repeat(paddingLeft) + displayBoxId + " ".repeat(paddingRight);
    } else {
      lineContent = " ".repeat(BOX_INNER_WIDTH);
    }
    output.push(
      `${leftPin.padStart(SIDE_PADDING_WIDTH)}\u2502${lineContent}\u2502${rightPin.padEnd(SIDE_PADDING_WIDTH)}`
    );
  }
  output.push(
    `${" ".repeat(SIDE_PADDING_WIDTH)}\u2514${"\u2500".repeat(BOX_INNER_WIDTH)}\u2518`
  );
  if (bottomPinCount > 0) {
    let pinsRow = "";
    for (let i = 0; i < bottomPinCount; i++) {
      const pinNum = leftPinCount + i + 1;
      pinsRow += pinNum.toString().padStart(2);
    }
    const pinsRowTrimmed = pinsRow.substring(0, BOX_INNER_WIDTH);
    const centerPadding = Math.floor(
      (BOX_INNER_WIDTH - pinsRowTrimmed.length) / 2
    );
    const centeredPinsRow = " ".repeat(centerPadding) + pinsRowTrimmed;
    output.push(`${" ".repeat(SIDE_PADDING_WIDTH + 1)}${centeredPinsRow}`);
  }
  return output;
}

// lib/matching/netlist-issue-finders/findAllNoBoxMatchingPinCounts.ts
function findAllNoBoxMatchingPinCounts(params) {
  const { candidateNetlist, targetNetlist } = params;
  const issues = [];
  const candidateShapeCounts = /* @__PURE__ */ new Map();
  for (let i = 0; i < candidateNetlist.boxes.length; i++) {
    const box = candidateNetlist.boxes[i];
    const shape = getBoxShapeSignature({
      leftPinCount: box.leftPinCount,
      bottomPinCount: box.bottomPinCount,
      rightPinCount: box.rightPinCount,
      topPinCount: box.topPinCount
    });
    if (!candidateShapeCounts.has(shape)) {
      candidateShapeCounts.set(shape, []);
    }
    candidateShapeCounts.get(shape).push(i);
  }
  for (let targetBoxIndex = 0; targetBoxIndex < targetNetlist.boxes.length; targetBoxIndex++) {
    const targetBox = targetNetlist.boxes[targetBoxIndex];
    const targetShape = getBoxShapeSignature({
      leftPinCount: targetBox.leftPinCount,
      bottomPinCount: targetBox.bottomPinCount,
      rightPinCount: targetBox.rightPinCount,
      topPinCount: targetBox.topPinCount
    });
    const candidateBoxesWithShape = candidateShapeCounts.get(targetShape) || [];
    if (candidateBoxesWithShape.length === 0) {
      issues.push({
        type: "no_box_matching_pin_counts",
        candidateBoxIndex: -1,
        // No matching candidate box
        targetBoxIndex
      });
    }
  }
  return issues;
}

// lib/matching/getMatchingIssues.ts
function getMatchingIssues(params) {
  const { candidateNetlist, targetNetlist } = params;
  const noBoxMatchingPinCounts = findAllNoBoxMatchingPinCounts({
    candidateNetlist,
    targetNetlist
  });
  const matchedBoxes = getMatchedBoxes({
    candidateNetlist,
    targetNetlist
  });
  return [
    ...noBoxMatchingPinCounts,
    ...matchedBoxes.flatMap((matchedBox) => matchedBox.issues)
  ];
}

// lib/matching/matching-utils/getAllPinShapeSignatures.ts
var getAllPinShapeSignatures = (inputNetlist) => {
  const pinShapeSignatures = [];
  for (const box of inputNetlist.boxes) {
    const totalPinCount = box.leftPinCount + box.rightPinCount + box.topPinCount + box.bottomPinCount;
    for (let pinNumber = 1; pinNumber <= totalPinCount; pinNumber++) {
      const pinShapeSignature = getPinShapeSignature({
        netlist: inputNetlist,
        chipId: box.boxId,
        pinNumber
      });
      pinShapeSignatures.push({
        boxId: box.boxId,
        pinNumber,
        pinShapeSignature
      });
    }
  }
  return pinShapeSignatures;
};

// lib/matching/matching-utils/getPairwisePinShapeSignatures.ts
var getPairwisePinShapeSignatures = ({
  targetNetlist,
  candidateNetlist,
  matchedBoxes,
  targetTransform,
  candidateTransform
}) => {
  const targetSignatures = getAllPinShapeSignatures(targetNetlist);
  const candidateSignatures = getAllPinShapeSignatures(candidateNetlist);
  const pairwiseSignatures = [];
  for (const match of matchedBoxes) {
    const targetBoxId = Object.keys(targetTransform.boxIdToBoxIndex).find(
      (id) => targetTransform.boxIdToBoxIndex[id] === match.targetBoxIndex
    );
    const candidateBoxId = Object.keys(candidateTransform.boxIdToBoxIndex).find(
      (id) => candidateTransform.boxIdToBoxIndex[id] === match.candidateBoxIndex
    );
    if (!targetBoxId || !candidateBoxId) continue;
    const targetBoxSignatures = targetSignatures.filter(
      (sig) => sig.boxId === targetBoxId
    );
    const candidateBoxSignatures = candidateSignatures.filter(
      (sig) => sig.boxId === candidateBoxId
    );
    const allPinNumbers = /* @__PURE__ */ new Set([
      ...targetBoxSignatures.map((sig) => sig.pinNumber),
      ...candidateBoxSignatures.map((sig) => sig.pinNumber)
    ]);
    for (const pinNumber of allPinNumbers) {
      const targetSig = targetBoxSignatures.find(
        (sig) => sig.pinNumber === pinNumber
      );
      const candidateSig = candidateBoxSignatures.find(
        (sig) => sig.pinNumber === pinNumber
      );
      pairwiseSignatures.push({
        targetBoxIdPinNumber: targetSig ? `${targetBoxId}.${pinNumber}` : "",
        candidateBoxIdPinNumber: candidateSig ? `${candidateBoxId}.${pinNumber}` : "",
        targetPinShapeSignature: targetSig?.pinShapeSignature || "",
        candidatePinShapeSignature: candidateSig?.pinShapeSignature || ""
      });
    }
  }
  return pairwiseSignatures;
};

// lib/solvers/ScoreNetlistTemplatePairSolver.ts
var ScoreNetlistTemplatePairSolver = class extends BaseSolver {
  inputNetlist;
  template;
  inputNetlistWithRotations = null;
  outputIssues = [];
  outputSimilarityDistance = Infinity;
  candidateTransform = null;
  targetTransform = null;
  matchedBoxes = [];
  constructor(opts) {
    super();
    this.inputNetlist = opts.inputNetlist;
    this.template = opts.template;
  }
  getConstructorParams() {
    return {
      inputNetlist: this.inputNetlist,
      template: this.template
    };
  }
  getStatsSummary() {
    return `${this.stats.similarityDistance.toFixed(1)} SD \u30FB ${this.stats.issueCount} issues \u30FB ${this.template.name}`;
  }
  _step() {
    const templateNetlist = this.template.getNetlist();
    const candidateResult = normalizeNetlist(templateNetlist);
    const initialTargetResult = normalizeNetlist(
      structuredClone(this.inputNetlist)
    );
    const candidateNetlist = candidateResult.normalizedNetlist;
    const initialTargetNetlist = initialTargetResult.normalizedNetlist;
    this.matchedBoxes = getMatchedBoxes({
      candidateNetlist,
      targetNetlist: initialTargetNetlist
    });
    for (const matchedBox of this.matchedBoxes) {
      matchedBox._targetBoxId = initialTargetResult.transform.boxIndexToBoxId[matchedBox.targetBoxIndex];
      matchedBox._candidateBoxId = candidateResult.transform.boxIndexToBoxId[matchedBox.candidateBoxIndex];
    }
    const inputNetlistWithRotations = applyMatchedBoxRotationsToInputNetlist({
      inputNetlist: structuredClone(this.inputNetlist),
      matchedBoxes: this.matchedBoxes
    });
    this.inputNetlistWithRotations = inputNetlistWithRotations;
    const finalTargetResult = normalizeNetlist(inputNetlistWithRotations);
    const finalTargetNetlist = finalTargetResult.normalizedNetlist;
    this.candidateTransform = candidateResult.transform;
    this.targetTransform = finalTargetResult.transform;
    this.outputIssues = getMatchingIssues({
      candidateNetlist,
      targetNetlist: finalTargetNetlist
    });
    this.outputSimilarityDistance = computeSimilarityDistanceFromIssues(
      this.outputIssues
    );
    this.stats = {
      similarityDistance: this.outputSimilarityDistance,
      issueCount: this.outputIssues.length,
      templateBoxCount: candidateNetlist.boxes?.length || 0,
      templateConnectionCount: candidateNetlist.connections?.length || 0,
      matchedBoxCount: this.matchedBoxes.length
    };
    this.solved = true;
  }
  getBoxNameFromIndex(boxIndex, isTemplate) {
    const transform = isTemplate ? this.candidateTransform : this.targetTransform;
    if (!transform) return boxIndex.toString();
    const boxId = Object.keys(transform.boxIdToBoxIndex).find(
      (id) => transform.boxIdToBoxIndex[id] === boxIndex
    );
    return boxId ? `${boxIndex} (${boxId})` : boxIndex.toString();
  }
  getAsciiForNetlistBoxHelper(boxIndex, isTemplate, maxWidth = 45) {
    const netlist = isTemplate ? this.template.getNetlist() : this.inputNetlistWithRotations;
    const transform = isTemplate ? this.candidateTransform : this.targetTransform;
    if (!transform) return [`Box ${boxIndex} (no transform)`];
    return getAsciiForNetlistBox(boxIndex, netlist, transform, maxWidth);
  }
  generateMatchedBoxesVisualization() {
    if (this.matchedBoxes.length === 0) {
      return "No matched boxes found";
    }
    const output = [];
    for (const match of this.matchedBoxes) {
      const targetBoxAscii = this.getAsciiForNetlistBoxHelper(
        match.targetBoxIndex,
        false,
        48
      );
      const candidateBoxAscii = this.getAsciiForNetlistBoxHelper(
        match.candidateBoxIndex,
        true,
        48
      );
      const maxHeight = Math.max(
        targetBoxAscii.length,
        candidateBoxAscii.length
      );
      while (targetBoxAscii.length < maxHeight) {
        targetBoxAscii.push(" ".repeat(48));
      }
      while (candidateBoxAscii.length < maxHeight) {
        candidateBoxAscii.push(" ".repeat(48));
      }
      const targetHeader = `Target ${this.getBoxNameFromIndex(match.targetBoxIndex, false)}`.padEnd(
        48
      );
      const candidateHeader = `Template ${this.getBoxNameFromIndex(match.candidateBoxIndex, true)}`.padEnd(
        48
      );
      output.push(`${targetHeader}  \u2192  ${candidateHeader}`);
      output.push(`${"\u2500".repeat(48)}  \u2192  ${"\u2500".repeat(48)}`);
      for (let i = 0; i < maxHeight; i++) {
        const leftLine = targetBoxAscii[i] || "";
        const rightLine = candidateBoxAscii[i] || "";
        const arrow = i === Math.floor(maxHeight / 2) ? " \u2192 " : "   ";
        output.push(`${leftLine.padEnd(48)}${arrow}${rightLine.padEnd(48)}`);
      }
      output.push("");
    }
    return output.join("\n");
  }
  visualize() {
    return [
      {
        title: "inputTemplate",
        ascii: this.template.toString(),
        table: this.outputIssues.map((issue, index) => ({
          issue_index: index,
          type: issue.type,
          target_box: "targetBoxIndex" in issue ? this.getBoxNameFromIndex(issue.targetBoxIndex, false) : "N/A",
          candidate_box: "candidateBoxIndex" in issue ? this.getBoxNameFromIndex(issue.candidateBoxIndex, true) : "N/A",
          details: issue
        }))
      },
      {
        title: "pairwisePinShapeSignatures",
        table: getPairwisePinShapeSignatures({
          targetNetlist: this.inputNetlistWithRotations,
          candidateNetlist: this.template.getNetlist(),
          matchedBoxes: this.matchedBoxes,
          targetTransform: this.targetTransform,
          candidateTransform: this.candidateTransform
        })
      },
      {
        title: "matchedBoxes",
        ascii: this.generateMatchedBoxesVisualization(),
        table: this.matchedBoxes.map((match) => ({
          target_box: this.getBoxNameFromIndex(match.targetBoxIndex, false),
          candidate_box: this.getBoxNameFromIndex(
            match.candidateBoxIndex,
            true
          ),
          rotation: match.targetBoxRotationCcw,
          issueCount: match.issues.length,
          details: match
        }))
      },
      {
        title: "inputTemplateReadableNetlist",
        ascii: this.template.getReadableNetlist()
      },
      {
        title: "inputTargetReadableNetlist",
        ascii: getReadableNetlist(this.inputNetlist)
      },
      this.inputNetlistWithRotations && {
        title: "targetReadableNetlistWithRotations",
        ascii: getReadableNetlist(this.inputNetlistWithRotations)
      }
      // {
      //   title: "pinShapeSignatures",
      //   table: [
      //     ...getAllPinShapeSignatures(this.inputNetlistWithRotations!).map(
      //       (a) => ({
      //         netlist: "target",
      //         ...a,
      //       }),
      //     ),
      //     ...getAllPinShapeSignatures(this.template.getNetlist()).map((a) => ({
      //       netlist: "template",
      //       ...a,
      //     })),
      //   ],
      // },
    ].filter(Boolean);
  }
};

// lib/solvers/MatchNetlistToTemplateSolver.ts
var MatchNetlistToTemplateSolver = class extends BaseSolver {
  inputNetlist;
  templates;
  scoringSolvers = [];
  currentScoringIndex = 0;
  outputBestMatchTemplate = null;
  templateMatchResults = [];
  constructor(opts) {
    super();
    this.inputNetlist = opts.inputNetlist;
    this.templates = opts.templateFns?.map((fn) => fn()) || TEMPLATE_FNS.map((fn) => fn());
    this.scoringSolvers = this.templates.map(
      (template) => new ScoreNetlistTemplatePairSolver({
        inputNetlist: this.inputNetlist,
        template
      })
    );
  }
  getConstructorParams() {
    return {
      inputNetlist: this.inputNetlist
    };
  }
  computeProgress() {
    if (this.scoringSolvers.length === 0) return 1;
    return this.currentScoringIndex / this.scoringSolvers.length;
  }
  _step() {
    if (this.currentScoringIndex < this.scoringSolvers.length) {
      const currentSolver = this.scoringSolvers[this.currentScoringIndex];
      if (!currentSolver.solved && !currentSolver.failed) {
        this.setActiveSubSolver(currentSolver);
        currentSolver.step();
        return;
      }
      this.clearActiveSubSolver();
      this.currentScoringIndex++;
      return;
    }
    this.templateMatchResults = this.scoringSolvers.map((solver) => ({
      template: solver.template,
      issues: solver.outputIssues,
      similarityDistance: solver.outputSimilarityDistance
    }));
    if (this.templateMatchResults.length === 0) {
      this.outputBestMatchTemplate = null;
      this.solved = true;
      return;
    }
    let bestMatch = this.templateMatchResults[0];
    for (let i = 1; i < this.templateMatchResults.length; i++) {
      if (this.templateMatchResults[i].similarityDistance < bestMatch.similarityDistance) {
        bestMatch = this.templateMatchResults[i];
      }
    }
    if (bestMatch.similarityDistance === Infinity) {
      this.outputBestMatchTemplate = null;
    } else {
      this.outputBestMatchTemplate = bestMatch.template;
    }
    this.solved = true;
  }
  visualize() {
    return [
      {
        title: "inputNetlist",
        ascii: getReadableNetlist(this.inputNetlist)
      },
      {
        title: "bestMatchTemplate",
        ascii: this.outputBestMatchTemplate?.toString() || "No suitable match found"
      },
      {
        title: "templateScores",
        table: this.templateMatchResults.map((result, index) => ({
          template_index: index,
          template_name: result.template.name || `Template ${index}`,
          similarity_distance: result.similarityDistance,
          issue_count: result.issues.length,
          is_best_match: result.template === this.outputBestMatchTemplate
        }))
      }
    ];
  }
};

// lib/solvers/MatchPhaseSolver.ts
var MatchPhaseSolver = class extends BaseSolver {
  inputNetlists;
  currentInputNetlistIndex = 0;
  templateFns;
  outputMatchedTemplates = [];
  get activeSubSolver() {
    return this._activeSubSolver;
  }
  constructor(opts) {
    super();
    this.inputNetlists = opts.inputNetlists;
    this.templateFns = opts.templateFns;
  }
  _step() {
    if (this.activeSubSolver) {
      this.activeSubSolver.step();
      if (this.activeSubSolver.solved) {
        this.outputMatchedTemplates.push({
          template: this.activeSubSolver.outputBestMatchTemplate,
          netlist: this.inputNetlists[this.currentInputNetlistIndex]
        });
        this.currentInputNetlistIndex++;
        this.clearActiveSubSolver();
        return;
      } else {
        return;
      }
    }
    if (this.currentInputNetlistIndex >= this.inputNetlists.length) {
      this.solved = true;
      return;
    }
    this.setActiveSubSolver(
      new MatchNetlistToTemplateSolver({
        inputNetlist: this.inputNetlists[this.currentInputNetlistIndex],
        templateFns: this.templateFns
      })
    );
  }
};

// lib/solvers/RenameMatchedTemplateBoxIdsSolver.ts
var RenameMatchedTemplateBoxIdsSolver = class extends BaseSolver {
  matchedTemplates;
  outputRenamedTemplates = [];
  constructor(opts) {
    super();
    this.matchedTemplates = opts.matchedTemplates;
  }
  getConstructorParams() {
    return { matchedTemplates: this.matchedTemplates };
  }
  /** Compute mapping from candidate chip ids to target ids */
  getChipIdMap(template, target) {
    const templateResult = normalizeNetlist(template.getNetlist());
    const targetResult = normalizeNetlist(target);
    const matched = getMatchedBoxes({
      candidateNetlist: templateResult.normalizedNetlist,
      targetNetlist: targetResult.normalizedNetlist
    });
    const map = {};
    for (const m of matched) {
      const candidateId = Object.entries(
        templateResult.transform.boxIdToBoxIndex
      ).find(([, idx]) => idx === m.candidateBoxIndex)?.[0];
      const targetId = Object.entries(
        targetResult.transform.boxIdToBoxIndex
      ).find(([, idx]) => idx === m.targetBoxIndex)?.[0];
      if (candidateId && targetId) {
        map[candidateId] = targetId;
      }
    }
    return map;
  }
  cloneAndRename(template, idMap) {
    const clone = template.clone();
    for (const chip of clone.chips) {
      const newId = idMap[chip.chipId];
      if (newId) {
        ;
        chip.chipId = newId;
      }
    }
    const remapRef = (ref) => {
      if (ref && "boxId" in ref && idMap[ref.boxId]) {
        ref.boxId = idMap[ref.boxId];
      }
    };
    for (const line of clone.lines) {
      remapRef(line.start.ref);
      remapRef(line.end.ref);
    }
    for (const nl of clone.netLabels) {
      remapRef(nl.fromRef);
    }
    for (const cp of clone.connectionPoints) {
      remapRef(cp.pinRef);
    }
    return clone;
  }
  _step() {
    for (const match of this.matchedTemplates) {
      const idMap = this.getChipIdMap(match.template, match.netlist);
      const cloned = this.cloneAndRename(match.template, idMap);
      this.outputRenamedTemplates.push({
        template: cloned,
        netlist: match.netlist
      });
    }
    this.solved = true;
  }
};

// lib/solvers/SchematicLayoutPipelineSolver.ts
function definePipelineStep(solverName, solverClass, getConstructorParams, opts = {}) {
  return {
    solverName,
    solverClass,
    getConstructorParams,
    onSolved: opts.onSolved
  };
}
var SchematicLayoutPipelineSolver = class extends BaseSolver {
  inputNetlist;
  templateFnsOverride;
  matchPhaseSolver;
  renameMatchedTemplateBoxIdsSolver;
  adaptPhaseSolver;
  startTimeOfPhase = {};
  endTimeOfPhase = {};
  timeSpentOnPhase = {};
  pipelineDef = [
    // TODO partition
    definePipelineStep("matchPhaseSolver", MatchPhaseSolver, () => [
      {
        inputNetlists: [this.inputNetlist],
        templateFns: this.templateFnsOverride
      }
    ]),
    definePipelineStep(
      "renameMatchedTemplateBoxIdsSolver",
      RenameMatchedTemplateBoxIdsSolver,
      () => [
        {
          matchedTemplates: this.matchPhaseSolver?.outputMatchedTemplates
        }
      ]
    ),
    definePipelineStep("adaptPhaseSolver", AdaptPhaseSolver, () => [
      {
        matchedTemplates: this.renameMatchedTemplateBoxIdsSolver?.outputRenamedTemplates
      }
    ])
    // TODO refine
    // TODO stitch
  ];
  constructor(opts) {
    super();
    this.inputNetlist = opts.inputNetlist;
    this.templateFnsOverride = opts.templateFns;
  }
  currentPipelineStepIndex = 0;
  _step() {
    const pipelineStepDef = this.pipelineDef[this.currentPipelineStepIndex];
    if (!pipelineStepDef) {
      this.solved = true;
      return;
    }
    if (this.activeSubSolver) {
      this.activeSubSolver.step();
      if (this.activeSubSolver.solved) {
        this.endTimeOfPhase[pipelineStepDef.solverName] = performance.now();
        this.timeSpentOnPhase[pipelineStepDef.solverName] = this.endTimeOfPhase[pipelineStepDef.solverName] - this.startTimeOfPhase[pipelineStepDef.solverName];
        pipelineStepDef.onSolved?.(this);
        this.clearActiveSubSolver();
        this.currentPipelineStepIndex++;
        return;
      }
      if (this.activeSubSolver.failed) {
        this.error = this.activeSubSolver?.error;
        this.failed = true;
        this.clearActiveSubSolver();
        return;
      }
      return;
    }
    const constructorParams = pipelineStepDef.getConstructorParams(this);
    this.setActiveSubSolver(
      // @ts-ignore
      new pipelineStepDef.solverClass(...constructorParams)
    );
    this[pipelineStepDef.solverName] = this.activeSubSolver;
    this.timeSpentOnPhase[pipelineStepDef.solverName] = 0;
    this.startTimeOfPhase[pipelineStepDef.solverName] = performance.now();
  }
  getLayout() {
    if (!this.adaptPhaseSolver?.outputAdaptedTemplates?.[0]) {
      throw new Error(
        "No adapted template available. Make sure the pipeline has completed successfully."
      );
    }
    return this.adaptPhaseSolver.outputAdaptedTemplates[0].template.getLayoutJson();
  }
};

// lib/circuit-json/applyCircuitLayoutToCircuitJson.ts
import { cju } from "@tscircuit/circuit-json-util";

// lib/utils/groupBy.ts
function groupBy(collection, iteratee) {
  const result = {};
  const isKey = (val) => typeof val === "string" || typeof val === "number" || typeof val === "symbol";
  for (const item of collection) {
    const rawKey = isKey(iteratee) ? item[iteratee] : iteratee(item);
    const key = String(rawKey);
    if (!Object.prototype.hasOwnProperty.call(result, key)) {
      result[key] = [];
    }
    result[key].push(item);
  }
  return result;
}

// lib/circuit-json/applyCircuitLayoutToCircuitJson.ts
import { getFullConnectivityMapFromCircuitJson } from "circuit-json-to-connectivity-map";
var applyCircuitLayoutToCircuitJson = (circuitJson, circuitJsonNetlist, layout) => {
  let cj = structuredClone(circuitJson);
  const connMap = getFullConnectivityMapFromCircuitJson(circuitJson);
  const layoutNetlist = layout.getNetlist();
  const layoutNorm = normalizeNetlist(layoutNetlist);
  const cjNorm = normalizeNetlist(circuitJsonNetlist);
  const matchedBoxes = getMatchedBoxes({
    candidateNetlist: layoutNorm.normalizedNetlist,
    targetNetlist: cjNorm.normalizedNetlist,
    candidateNormalizationTransform: layoutNorm.transform,
    targetNormalizationTransform: cjNorm.transform
  });
  const layoutBoxIndexToBoxId = /* @__PURE__ */ new Map();
  for (const matchedBox of matchedBoxes) {
    layoutBoxIndexToBoxId.set(
      matchedBox.candidateBoxIndex,
      matchedBox._candidateBoxId
    );
  }
  for (const schematicComponent of cju(cj).schematic_component.list()) {
    const sourceComponent = cju(cj).source_component.get(
      schematicComponent.source_component_id
    );
    const schematicPorts = cju(cj).schematic_port.list({
      schematic_component_id: schematicComponent.schematic_component_id
    });
    const boxIndex = cjNorm.transform.boxIdToBoxIndex[sourceComponent.name];
    const layoutBoxId = layoutBoxIndexToBoxId.get(boxIndex);
    if (!layoutBoxId) {
      console.log(`${sourceComponent.name} was not laid out`);
      continue;
    }
    const layoutChip = layout.chips.find((c) => c.chipId === layoutBoxId);
    if (!layoutChip) {
      throw new Error(
        `Layout chip "${layoutBoxId}" not found in layout.chips:${JSON.stringify(layout.chips.map((c) => c.chipId))}`
      );
    }
    let cjChipWidth = layoutChip.getWidth() - 0.8;
    let cjChipHeight = layoutChip.getHeight();
    if (layoutChip.isPassive) {
      cjChipWidth = 1;
      cjChipHeight = 1;
    }
    schematicComponent.center = layoutChip.getCenter();
    schematicComponent.size = {
      width: cjChipWidth,
      height: cjChipHeight
    };
    for (const schematicPort of schematicPorts) {
      const { true_ccw_index, pin_number } = schematicPort;
      const pn = true_ccw_index !== void 0 ? true_ccw_index + 1 : pin_number;
      try {
        const { x: layoutX, y: layoutY } = layoutChip.getPinLocation(pn);
        schematicPort.center = {
          x: layoutX,
          y: layoutY
        };
      } catch (e) {
        console.error(
          `Error getting pin location for ${sourceComponent.name} pin ${pin_number}:`,
          e
        );
      }
    }
    if (layoutChip.isPassive && schematicComponent.symbol_name) {
      const pin1Port = schematicPorts.find(
        (p) => p.pin_number === 1 || p.true_ccw_index === 0
      );
      const pin2Port = schematicPorts.find(
        (p) => p.pin_number === 2 || p.true_ccw_index === 1
      );
      if (pin1Port?.center && pin2Port?.center) {
        const dx = pin2Port.center.x - pin1Port.center.x;
        const dy = pin2Port.center.y - pin1Port.center.y;
        let newOrientation;
        if (Math.abs(dy) > Math.abs(dx)) {
          newOrientation = dy > 0 ? "down" : "up";
        } else {
          newOrientation = dx > 0 ? "right" : "left";
        }
        if (schematicComponent.symbol_name.includes("boxresistor")) {
          schematicComponent.symbol_name = `boxresistor_${newOrientation}`;
        } else if (schematicComponent.symbol_name.includes("capacitor_polarized")) {
          schematicComponent.symbol_name = `capacitor_polarized_${newOrientation}`;
        } else if (schematicComponent.symbol_name.includes("capacitor")) {
          schematicComponent.symbol_name = `capacitor_${newOrientation}`;
        }
      }
    }
  }
  cj = cj.filter((elm) => elm.type !== "schematic_net_label");
  const newSchematicNetLabels = [];
  for (const layoutLabel of layout.netLabels) {
    const fromRef = layoutLabel.fromRef;
    if (!("boxId" in fromRef)) {
      throw new Error("boxId not found in fromRef for label");
    }
    const matchedBox = matchedBoxes.find(
      (mb) => mb._candidateBoxId === fromRef.boxId
    );
    if (!matchedBox) {
      throw new Error(
        `${fromRef.boxId} was not laid out for net label ${layoutLabel.netLabelId}/${layoutLabel.netId}`
      );
    }
    const cjChipId = matchedBox._targetBoxId;
    const source_component = cju(cj).source_component.getWhere({
      name: cjChipId
    });
    if (!source_component) continue;
    const source_port = cju(cj).source_port.getWhere({
      source_component_id: source_component.source_component_id,
      pin_number: fromRef.pinNumber
    });
    if (!source_port) continue;
    const source_net = cju(cj).source_net.getWhere({
      subcircuit_connectivity_map_key: source_port.subcircuit_connectivity_map_key
    });
    if (!source_net) continue;
    const newLabel = {
      type: "schematic_net_label",
      schematic_net_label_id: layoutLabel.netLabelId,
      source_net_id: source_net.source_net_id,
      text: source_net.name,
      center: { x: layoutLabel.x, y: layoutLabel.y },
      anchor_position: { x: layoutLabel.x, y: layoutLabel.y },
      // Typically same as center for labels
      anchor_side: layoutLabel.anchorSide
    };
    newSchematicNetLabels.push(newLabel);
  }
  if (newSchematicNetLabels.length > 0) {
    cj.push(...newSchematicNetLabels);
  }
  const linesByPath = groupBy(layout.lines, (ln) => ln.pathId);
  const newSchematicTraces = [];
  for (const [pathId, segments] of Object.entries(linesByPath)) {
    const edges = segments.map((seg) => ({
      from: {
        x: seg.start.x,
        y: seg.start.y,
        layer: "top",
        // or seg.layer if you later add it
        route_type: "wire",
        width: 0.1
      },
      to: {
        x: seg.end.x,
        y: seg.end.y,
        layer: "top",
        route_type: "wire",
        width: 0.1
      }
    }));
    newSchematicTraces.push({
      type: "schematic_trace",
      schematic_trace_id: `sch_trace_${pathId}`,
      // ⇢ unique per path
      source_trace_id: `source_trace_${pathId}`,
      // ⇢ no collisions
      edges,
      junctions: []
    });
  }
  cj = cj.filter((c) => c.type !== "schematic_trace");
  cj.push(...newSchematicTraces);
  cj = cj.filter((c) => c.type !== "schematic_text");
  return cj;
};

// lib/circuit-json/convertCircuitJsonToInputNetlist.ts
import { getFullConnectivityMapFromCircuitJson as getFullConnectivityMapFromCircuitJson2 } from "circuit-json-to-connectivity-map";
import { cju as cju2, getElementById } from "@tscircuit/circuit-json-util";
var directionToSide = (direction) => {
  switch (direction) {
    case "left":
      return "left";
    case "right":
      return "right";
    case "up":
      return "top";
    case "down":
      return "bottom";
  }
};
var convertCircuitJsonToInputNetlist = (circuitJson) => {
  const connMap = getFullConnectivityMapFromCircuitJson2(circuitJson);
  const items = Array.isArray(circuitJson) ? circuitJson : [];
  const cjBoxes = cju2(circuitJson).source_component.list().map((source_component) => ({
    source_component,
    schematic_component: cju2(circuitJson).schematic_component.getWhere({
      source_component_id: source_component.source_component_id
    }),
    source_ports: cju2(circuitJson).source_port.list().filter(
      (source_port) => source_port.source_component_id === source_component.source_component_id
    ).map((source_port) => {
      const connectivity_net_id = connMap.getNetConnectedToId(
        source_port.source_port_id
      );
      const schematic_port = cju2(circuitJson).schematic_port.getWhere({
        source_port_id: source_port.source_port_id
      });
      const pin_number = schematic_port?.true_ccw_index != null ? schematic_port.true_ccw_index + 1 : source_port.pin_number;
      return {
        source_port,
        schematic_port: cju2(circuitJson).schematic_port.getWhere({
          source_port_id: source_port.source_port_id
        }),
        pin_number,
        connectivity_net_id
      };
    }).filter(({ schematic_port }) => Boolean(schematic_port))
  }));
  const boxes3 = [];
  const connections = [];
  for (const {
    source_component,
    schematic_component,
    source_ports
  } of cjBoxes) {
    const box = {
      boxId: source_component.name,
      leftPinCount: 0,
      rightPinCount: 0,
      topPinCount: 0,
      bottomPinCount: 0
    };
    for (const { source_port, schematic_port, pin_number } of source_ports) {
      const side = directionToSide(schematic_port.facing_direction);
      box[`${side}PinCount`]++;
      const connectivityNetId = connMap.getNetConnectedToId(
        source_port.source_port_id
      );
      if (!connectivityNetId) continue;
      let connection = connections.find(
        (c) => c._connectivityNetId === connectivityNetId
      );
      if (!connection) {
        connection = {
          _connectivityNetId: connectivityNetId,
          connectedPorts: []
        };
        connections.push(connection);
      }
      connection.connectedPorts.push({
        boxId: source_component.name,
        pinNumber: schematic_port?.true_ccw_index != null ? schematic_port.true_ccw_index + 1 : pin_number
      });
    }
    boxes3.push(box);
  }
  const nets = [];
  const netIds = /* @__PURE__ */ new Set();
  for (const connection of connections) {
    let netId = connection._connectivityNetId;
    const elementsConnectedToNet = connMap.getIdsConnectedToNet(netId).map((id) => getElementById(circuitJson, id));
    for (const element of elementsConnectedToNet) {
      if (element?.type === "source_net") {
        netId = element.name;
        break;
      }
    }
    const upper = netId.toUpperCase();
    const isGround = upper === "GND" || upper === "AGND";
    const isPositivePower = /^V/i.test(netId);
    if (connection.connectedPorts.length < 2 && netId === connection._connectivityNetId) {
      continue;
    }
    connection.connectedPorts.push({
      netId
    });
    if (!netIds.has(netId)) {
      const net = { netId };
      if (isGround) net.isGround = true;
      if (isPositivePower) net.isPositivePower = true;
      nets.push(net);
      netIds.add(netId);
    }
  }
  const sourceNets = items.filter((item) => item.type === "source_net");
  for (const sourceNet of sourceNets) {
    if (!netIds.has(sourceNet.name)) {
      const net = { netId: sourceNet.name };
      const upper = sourceNet.name.toUpperCase();
      if (upper === "GND" || upper === "AGND") net.isGround = true;
      if (/^V/i.test(sourceNet.name)) net.isPositivePower = true;
      nets.push(net);
      netIds.add(sourceNet.name);
    }
  }
  return {
    boxes: boxes3,
    connections,
    nets
  };
};

// lib/circuit-json/reorderChipPinsToCcw.ts
var reorderChipPinsToCcw = (circuitJson) => {
  const newCircuitJson = JSON.parse(JSON.stringify(circuitJson));
  const schematicComponents = newCircuitJson.filter(
    (item) => item.type === "schematic_component" && item.port_arrangement
  );
  for (const component of schematicComponents) {
    const ports = newCircuitJson.filter(
      (item) => item.type === "schematic_port" && item.schematic_component_id === component.schematic_component_id && item.true_ccw_index !== void 0
    );
    if (ports.length === 0) continue;
    ports.sort((a, b) => a.true_ccw_index - b.true_ccw_index);
    const pinMapping = {};
    ports.forEach((port, index) => {
      pinMapping[port.pin_number] = index + 1;
    });
    for (const port of ports) {
      const newPinNumber = pinMapping[port.pin_number];
      port.pin_number = newPinNumber;
    }
    for (const port of ports) {
      const sourcePort = newCircuitJson.find(
        (item) => item.type === "source_port" && item.source_port_id === port.source_port_id
      );
      if (sourcePort) {
        sourcePort.pin_number = port.pin_number;
      }
    }
    if (component.port_arrangement) {
      const updateSidePins = (side) => {
        if (component.port_arrangement[side]?.pins) {
          component.port_arrangement[side].pins = component.port_arrangement[side].pins.map((oldPin) => pinMapping[oldPin] || oldPin);
        }
      };
      updateSidePins("left_side");
      updateSidePins("right_side");
      updateSidePins("top_side");
      updateSidePins("bottom_side");
    }
    if (component.port_labels) {
      const newPortLabels = {};
      for (const [pinKey, label] of Object.entries(component.port_labels)) {
        const oldPinNumber = parseInt(pinKey.replace("pin", ""));
        const newPinNumber = pinMapping[oldPinNumber];
        if (newPinNumber !== void 0) {
          newPortLabels[`pin${newPinNumber}`] = label;
        } else {
          newPortLabels[pinKey] = label;
        }
      }
      component.port_labels = newPortLabels;
    }
    if (component.pin_styles) {
      const newPinStyles = {};
      for (const [pinKey, style] of Object.entries(component.pin_styles)) {
        const oldPinNumber = parseInt(pinKey.replace("pin", ""));
        const newPinNumber = pinMapping[oldPinNumber];
        if (newPinNumber !== void 0) {
          newPinStyles[`pin${newPinNumber}`] = style;
        } else {
          newPinStyles[pinKey] = style;
        }
      }
      component.pin_styles = newPinStyles;
    }
  }
  return newCircuitJson;
};

// corpus/corpus2025-05-03-abcd1234.json
var corpus2025_05_03_abcd1234_exports = {};
__export(corpus2025_05_03_abcd1234_exports, {
  boxes: () => boxes,
  default: () => corpus2025_05_03_abcd1234_default,
  junctions: () => junctions,
  netLabels: () => netLabels,
  paths: () => paths
});
var boxes = [
  {
    boxId: "U1",
    leftPinCount: 2,
    rightPinCount: 2,
    topPinCount: 0,
    bottomPinCount: 0,
    centerX: 1.5999999999999999,
    centerY: 0.9000000000000001,
    pins: [
      {
        pinNumber: 1,
        x: 0.2,
        y: 1
      },
      {
        pinNumber: 4,
        x: 3,
        y: 1
      },
      {
        pinNumber: 2,
        x: 0.2,
        y: 0.8
      },
      {
        pinNumber: 3,
        x: 3,
        y: 0.8
      }
    ]
  },
  {
    boxId: "P1",
    leftPinCount: 0,
    rightPinCount: 0,
    topPinCount: 1,
    bottomPinCount: 1,
    centerX: -1.2000000000000002,
    centerY: -0.30000000000000004,
    pins: [
      {
        pinNumber: 2,
        x: -1.2000000000000002,
        y: 0.19999999999999996
      },
      {
        pinNumber: 1,
        x: -1.2000000000000002,
        y: -0.8
      }
    ]
  }
];
var netLabels = [
  {
    netId: "NET1",
    netLabelId: "netlabel-eaa8b88f-f9f9-452b-bbf6-c9318eb72225",
    anchorPosition: "top",
    x: -1.2000000000000002,
    y: -1.2000000000000002
  },
  {
    netId: "NET2",
    netLabelId: "netlabel-1e260b94-3c7d-45f9-93fd-65f547ad4c1b",
    anchorPosition: "left",
    x: 3.8000000000000003,
    y: 1
  }
];
var paths = [
  {
    points: [
      {
        x: -1.2000000000000002,
        y: 0.19999999999999996
      },
      {
        x: -1.2000000000000002,
        y: 1
      },
      {
        x: 0.2,
        y: 1
      }
    ],
    from: {
      boxId: "P1",
      pinNumber: 2
    },
    to: {
      boxId: "U1",
      pinNumber: 1
    }
  },
  {
    points: [
      {
        x: -1.2000000000000002,
        y: -0.8
      },
      {
        x: -1.2000000000000002,
        y: -1.2000000000000002
      }
    ],
    from: {
      boxId: "P1",
      pinNumber: 1
    },
    to: {
      netLabelId: "netlabel-eaa8b88f-f9f9-452b-bbf6-c9318eb72225"
    }
  },
  {
    points: [
      {
        x: 3,
        y: 1
      },
      {
        x: 3.8000000000000003,
        y: 1
      }
    ],
    from: {
      boxId: "U1",
      pinNumber: 4
    },
    to: {
      netLabelId: "netlabel-1e260b94-3c7d-45f9-93fd-65f547ad4c1b"
    }
  }
];
var junctions = [];
var corpus2025_05_03_abcd1234_default = {
  boxes,
  netLabels,
  paths,
  junctions
};

// corpus/corpus2025-05-04-efgh5678.json
var corpus2025_05_04_efgh5678_exports = {};
__export(corpus2025_05_04_efgh5678_exports, {
  boxes: () => boxes2,
  default: () => corpus2025_05_04_efgh5678_default,
  junctions: () => junctions2,
  netLabels: () => netLabels2,
  paths: () => paths2
});
var boxes2 = [
  {
    boxId: "P1",
    leftPinCount: 0,
    rightPinCount: 0,
    topPinCount: 1,
    bottomPinCount: 1,
    centerX: -2.2,
    centerY: 2.5,
    pins: [
      {
        pinNumber: 2,
        x: -2.2,
        y: 3
      },
      {
        pinNumber: 1,
        x: -2.2,
        y: 2
      }
    ]
  },
  {
    boxId: "P2",
    leftPinCount: 0,
    rightPinCount: 0,
    topPinCount: 1,
    bottomPinCount: 1,
    centerX: -2.2,
    centerY: 0.9,
    pins: [
      {
        pinNumber: 2,
        x: -2.2,
        y: 1.4
      },
      {
        pinNumber: 1,
        x: -2.2,
        y: 0.4
      }
    ]
  }
];
var netLabels2 = [
  {
    netId: "VCC",
    netLabelId: "netlabel-01c053d8-da6c-406f-9cb7-28d8beb15b3b",
    anchorPosition: "bottom",
    x: -2.2,
    y: 3.6
  },
  {
    netId: "GND",
    netLabelId: "netlabel-fc5a627d-b12d-430c-8a74-e9a72efb07ad",
    anchorPosition: "top",
    x: -2.2,
    y: -0.2
  }
];
var paths2 = [
  {
    points: [
      {
        x: -2.2,
        y: 3
      },
      {
        x: -2.2,
        y: 3.6
      }
    ],
    from: {
      boxId: "P1",
      pinNumber: 2
    },
    to: {
      netLabelId: "netlabel-01c053d8-da6c-406f-9cb7-28d8beb15b3b"
    }
  },
  {
    points: [
      {
        x: -2.2,
        y: 2
      },
      {
        x: -2.2,
        y: 1.4
      }
    ],
    from: {
      boxId: "P1",
      pinNumber: 1
    },
    to: {
      boxId: "P2",
      pinNumber: 2
    }
  },
  {
    points: [
      {
        x: -2.2,
        y: 0.4
      },
      {
        x: -2.2,
        y: -0.2
      }
    ],
    from: {
      boxId: "P2",
      pinNumber: 1
    },
    to: {
      netLabelId: "netlabel-fc5a627d-b12d-430c-8a74-e9a72efb07ad"
    }
  }
];
var junctions2 = [];
var corpus2025_05_04_efgh5678_default = {
  boxes: boxes2,
  netLabels: netLabels2,
  paths: paths2,
  junctions: junctions2
};

// lib/corpus-vfs.ts
var corpus_vfs_default = {
  "corpus2025-05-03-abcd1234.json": corpus2025_05_03_abcd1234_exports,
  "corpus2025-05-04-efgh5678.json": corpus2025_05_04_efgh5678_exports
};

// lib/utils/circuitBuilderFromLayoutJson.ts
function circuitBuilderFromLayoutJson(layout) {
  const C = circuit({ name: "corpus" });
  const chipMap = {};
  for (const box of layout.boxes) {
    const totalPins = box.leftPinCount + box.rightPinCount + box.topPinCount + box.bottomPinCount;
    const isPassive = totalPins === 2;
    const chip = isPassive ? C.passive(box.boxId) : C.chip(box.boxId);
    chipMap[box.boxId] = chip;
    if (box.leftPinCount) chip.leftpins(box.leftPinCount);
    if (box.bottomPinCount) chip.bottompins(box.bottomPinCount);
    if (box.rightPinCount) chip.rightpins(box.rightPinCount);
    if (box.topPinCount) chip.toppins(box.topPinCount);
    if (isPassive) {
      chip.at(box.centerX, box.centerY);
    } else {
      chip.at(
        box.centerX - chip.getWidth() / 2,
        box.centerY - chip.getHeight() / 2
      );
    }
    for (const pin of box.pins) {
      const pb = chip.pin(pin.pinNumber);
      pb.x = pin.x;
      pb.y = pin.y;
    }
    chip.pinPositionsAreSet = true;
  }
  const labelRefMap = {};
  const netLabelIdToNetId = {};
  for (const nl of layout.netLabels) {
    netLabelIdToNetId[nl.netLabelId] = nl.netId;
  }
  for (const path of layout.paths) {
    const fromRef = path.from;
    const toRef = path.to;
    if ("netLabelId" in fromRef) {
      fromRef.netId ??= netLabelIdToNetId[fromRef.netLabelId];
    }
    if ("netLabelId" in toRef) {
      toRef.netId ??= netLabelIdToNetId[toRef.netLabelId];
    }
    if ("netLabelId" in path.to) {
      labelRefMap[path.to.netLabelId] = fromRef;
    }
    if ("netLabelId" in path.from) {
      labelRefMap[path.from.netLabelId] = toRef;
    }
  }
  for (const nl of layout.netLabels) {
    C.addNetLabel({
      netId: nl.netId,
      x: nl.x,
      y: nl.y,
      anchorSide: nl.anchorPosition,
      fromRef: labelRefMap[nl.netLabelId]
    });
  }
  for (const path of layout.paths) {
    const points = path.points;
    if (points.length < 2) continue;
    const fromRef = path.from;
    const toRef = path.to;
    if ("netLabelId" in fromRef) {
      fromRef.netId ??= netLabelIdToNetId[fromRef.netLabelId];
    }
    if ("netLabelId" in toRef) {
      toRef.netId ??= netLabelIdToNetId[toRef.netLabelId];
    }
    const fromIsPin = "boxId" in path.from && "pinNumber" in path.from;
    const toIsPin = "boxId" in path.to && "pinNumber" in path.to;
    let pb = null;
    let segPoints = points;
    let finalRef = null;
    let chip;
    if (fromIsPin) {
      chip = chipMap[path.from.boxId];
      pb = chip.pin(path.from.pinNumber);
      finalRef = toRef;
    } else if (toIsPin) {
      chip = chipMap[path.to.boxId];
      pb = chip.pin(path.to.pinNumber);
      segPoints = [...points].reverse();
      finalRef = fromRef;
    } else {
      throw new Error("Unimplemented handling of non-pin paths");
    }
    if (pb) {
      for (let i = 1; i < segPoints.length; i++) {
        const p = segPoints[i];
        pb.lineAt(p.x, p.y);
      }
      if (finalRef) {
        pb.lastCreatedLine.end.ref = finalRef;
      }
    } else {
      throw new Error("Unimplemented handling of non-pin paths");
    }
  }
  return C;
}

// lib/corpus.ts
var layouts = corpus_vfs_default;
var CORPUS_TEMPLATE_FNS = Object.values(
  layouts
).map((layout) => () => circuitBuilderFromLayoutJson(layout));
export {
  CORPUS_TEMPLATE_FNS,
  RenameMatchedTemplateBoxIdsSolver,
  SchematicLayoutPipelineSolver,
  applyCircuitLayoutToCircuitJson,
  circuitBuilderFromLayoutJson,
  convertCircuitJsonToInputNetlist,
  getRefKey,
  parseRefKey,
  reorderChipPinsToCcw
};
