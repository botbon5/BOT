{"version":3,"sources":["../src/lib/mutate-soup-for-scene.ts","../src/lib/convert-soup-to-scene.ts","../src/lib/get-ccw-position.ts","../src/lib/scene.ts","../src/lib/algorithms/sub-algorithms/getConnectionMap.ts","../src/lib/algorithms/sub-algorithms/centerSides.ts","../src/lib/algorithms/sub-algorithms/findBoxWithMostPorts.ts","../src/lib/algorithms/sub-algorithms/slideBoxesConnectedToSameNet.ts","../src/lib/algorithms/sub-algorithms/removeAscendingBoxIndexGaps.ts","../src/lib/algorithms/sub-algorithms/addBoxesForNetsRewriteNetsToSpecificAliases.ts","../src/lib/algorithms/auto-rotate-two-port-boxes.ts","../src/lib/algorithms/ascending-central-lr-bug-1.ts"],"sourcesContent":["import { AnyCircuitElement, SchematicComponent } from \"circuit-json\"\nimport { Scene } from \"./scene\"\nimport { transformSchematicElement } from \"@tscircuit/soup-util\"\nimport { translate } from \"transformation-matrix\"\n\nexport const convertSceneToSoup = (\n  og_soup: AnyCircuitElement[],\n  scene: Scene\n): AnyCircuitElement[] => {\n  return mutateSoupForScene(JSON.parse(JSON.stringify(og_soup)), scene)\n}\n\nexport const mutateSoupForScene = (\n  og_soup: AnyCircuitElement[],\n  scene: Scene\n): AnyCircuitElement[] => {\n  const soup: AnyCircuitElement[] = og_soup\n\n  // Modify the soup to reflect the modifications made in the scene\n  for (const box of scene.boxes) {\n    // each box reflects a schematic_component\n    const schematic_component: SchematicComponent = soup.find(\n      (e) =>\n        e.type === \"schematic_component\" &&\n        e.schematic_component_id === box.box_id\n    ) as any\n\n    // Update the position of the box\n    // TODO handle box rotations\n    const mat = translate(\n      box.x - schematic_component.center.x,\n      box.y - schematic_component.center.y\n    )\n    for (const elm of soup) {\n      if ((elm as any).schematic_component_id === box.box_id) {\n        transformSchematicElement(elm as any, mat)\n      }\n    }\n\n    // TODO handle adding netaliases\n  }\n\n  return soup\n}\n","import type {\n  AnyCircuitElement,\n  SchematicComponent,\n  SchematicPort,\n  SchematicTrace,\n  SourcePort,\n  SourceTrace\n} from \"circuit-json\"\nimport { Scene } from \"./scene\"\nimport { Box, Connection, Port } from \"./types\"\n\n/*\nexport type Connection = {\n  from: string\n  to: string\n}\nexport type Port = {\n  port_id: string\n  // relative x\n  rx: number\n  // relative y\n  ry: number\n}\nexport type Box = {\n  box_id: string\n  x: number\n  y: number\n  ports: Array<Port>\n}\nexport type Net = {\n  net_id: string\n  is_power?: boolean\n  is_ground?: boolean\n}\n\n*/\n\n/**\n * Convert tscircuit soup to a scene\n */\nexport const convertSoupToScene = (soup: AnyCircuitElement[]): Scene => {\n  const boxes: Scene[\"boxes\"] = []\n  const connections: Scene[\"connections\"] = []\n  const nets: Scene[\"nets\"] = []\n\n  const soup_elm_map = {\n    schematic_component: soup.filter(\n      (e) => e.type === \"schematic_component\"\n    ) as SchematicComponent[],\n    schematic_port: soup.filter(\n      (e) => e.type === \"schematic_port\"\n    ) as SchematicPort[],\n    source_port: (soup as any[]).filter(\n      (e) => e.type === \"source_port\"\n    ) as SourcePort[],\n    schematic_trace: (soup as any[]).filter(\n      (e) => e.type === \"schematic_trace\"\n    ) as SchematicTrace[],\n    source_trace: (soup as any[]).filter(\n      (e) => e.type === \"source_trace\"\n    ) as SourceTrace[],\n  }\n\n  // iterate over soup, convert schematic_box to a scene box\n  for (const schematic_component of soup_elm_map.schematic_component) {\n    const ports: Port[] = []\n    const box_id = schematic_component.schematic_component_id\n\n    // go through each port attached to the schematic box\n    for (const sch_port of soup_elm_map.schematic_port) {\n      if (\n        sch_port.schematic_component_id ===\n        schematic_component.schematic_component_id\n      ) {\n        ports.push({\n          port_id: `${box_id}.${sch_port.schematic_port_id}`,\n          rx: sch_port.center.x - schematic_component.center.x,\n          ry: sch_port.center.y - schematic_component.center.y,\n        })\n      }\n    }\n\n    const box: Box = {\n      box_id,\n      x: schematic_component.center.x,\n      y: schematic_component.center.y,\n      ports,\n    }\n    boxes.push(box)\n  }\n\n  for (const source_trace of soup_elm_map.source_trace) {\n    const [sp_A, sp_B] = source_trace.connected_source_port_ids\n\n    const schp_A = soup_elm_map.schematic_port.find(\n      (sch_port) => sch_port.source_port_id === sp_A\n    )\n    const schp_B = soup_elm_map.schematic_port.find(\n      (sch_port) => sch_port.source_port_id === sp_B\n    )\n\n    if (!schp_A || !schp_B) {\n      continue\n    }\n\n    const schcomp_A = soup_elm_map.schematic_component.find(\n      (sch_comp) =>\n        sch_comp.schematic_component_id === schp_A.schematic_component_id\n    )\n    const schcomp_B = soup_elm_map.schematic_component.find(\n      (sch_comp) =>\n        sch_comp.schematic_component_id === schp_B.schematic_component_id\n    )\n\n    if (!schcomp_A || !schcomp_B) {\n      continue\n    }\n\n    const connection: Connection = {\n      from: `${schcomp_A.schematic_component_id}.${schp_A.schematic_port_id}`,\n      to: `${schcomp_B.schematic_component_id}.${schp_B.schematic_port_id}`,\n    }\n\n    connections.push(connection)\n  }\n\n  return {\n    boxes,\n    connections,\n    nets,\n  }\n}\n","export const getCcwPosition = (\n  index: number,\n  opts: {\n    left_side_size: number\n    right_size_size: number\n    centered_around?: { x: number; y: number }\n    pitch?: number\n    space_between_sides?: number\n  }\n) => {\n  opts.centered_around ??= { x: 0, y: 0 }\n  opts.pitch ??= 1\n  opts.space_between_sides ??= 5\n\n  const { left_side_size, right_size_size } = opts\n\n  const height = (Math.max(left_side_size, right_size_size) - 1) * opts.pitch\n\n  if (index < left_side_size) {\n    return {\n      x: opts.centered_around.x - opts.space_between_sides / 2,\n      y: opts.centered_around.y + height / 2 - index * opts.pitch,\n    }\n  } else {\n    const rindex = index - left_side_size\n\n    return {\n      x: opts.centered_around.x + opts.space_between_sides / 2,\n      y: opts.centered_around.y - height / 2 + rindex * opts.pitch,\n    }\n  }\n}\n","import { getCcwPosition } from \"./get-ccw-position\"\nimport { Box, Connection, Net } from \"./types\"\n/**\n * Build a scene with a chained builder\n *\n * scene()\n *  .addCcwBox(\"A\", { x: 0, y: 0, leftPorts: 3, rightPorts: 2 })\n *  .addLRBox(\"B\", { x: 0, y: 0 })\n *  .connect(\"A.1\", \"B.left\")\n *  .build()\n */\nexport const scene = () => new SceneBuilder()\n\nexport type Scene = {\n  nets: Array<Net>\n  boxes: Array<Box>\n  connections: Array<Connection>\n}\n\nclass SceneBuilder {\n  boxes: Array<Box>\n  connections: Array<Connection>\n  nets: Array<Net>\n\n  constructor() {\n    this.boxes = []\n    this.connections = []\n    this.nets = []\n  }\n\n  addNet(net_id: string, opts: { is_power?: boolean; is_ground?: boolean }) {\n    this.nets.push({ net_id, ...opts })\n    return this\n  }\n\n  addCcwBox(\n    box_id: string,\n    opts: { x: number; y: number; leftPorts: number; rightPorts: number },\n  ) {\n    const box: Box = {\n      box_id,\n      x: opts.x,\n      y: opts.y,\n      ports: [],\n    }\n\n    for (let i = 0; i < opts.leftPorts + opts.rightPorts; i++) {\n      const ccwPos = getCcwPosition(i, {\n        left_side_size: opts.leftPorts,\n        right_size_size: opts.rightPorts,\n        centered_around: { x: 0, y: 0 },\n        pitch: 0.5,\n        space_between_sides: 1,\n      })\n\n      box.ports.push({\n        port_id: `${box_id}.${i + 1}`,\n        rx: ccwPos.x,\n        ry: ccwPos.y,\n      })\n    }\n\n    this.boxes.push(box)\n    return this\n  }\n\n  addLrBox(box_id: string, opts: { x: number; y: number }) {\n    this.boxes.push({\n      box_id,\n      x: opts.x,\n      y: opts.y,\n      ports: [\n        {\n          port_id: `${box_id}.left`,\n          rx: -0.3,\n          ry: 0,\n        },\n        {\n          port_id: `${box_id}.right`,\n          rx: 0.3,\n          ry: 0,\n        },\n      ],\n    })\n    return this\n  }\n\n  addTbBox(box_id: string, opts: { x: number; y: number }) {\n    this.boxes.push({\n      box_id,\n      x: opts.x,\n      y: opts.y,\n      ports: [\n        {\n          port_id: `${box_id}.top`,\n          rx: 0,\n          ry: 0.3,\n        },\n        {\n          port_id: `${box_id}.bottom`,\n          rx: 0,\n          ry: -0.3,\n        },\n      ],\n    })\n    return this\n  }\n\n  addTBox(box_id: string, opts: { x: number; y: number }) {\n    this.boxes.push({\n      box_id,\n      x: opts.x,\n      y: opts.y,\n      ports: [\n        {\n          port_id: `${box_id}.top`,\n          rx: 0,\n          ry: 0.1,\n        },\n      ],\n    })\n    return this\n  }\n\n  addBBox(box_id: string, opts: { x: number; y: number }) {\n    this.boxes.push({\n      box_id,\n      x: opts.x,\n      y: opts.y,\n      ports: [\n        {\n          port_id: `${box_id}.bottom`,\n          rx: 0,\n          ry: -0.1,\n        },\n      ],\n    })\n    return this\n  }\n\n  connect(from: string, to: string) {\n    this.connections.push({ from, to })\n    return this\n  }\n\n  build() {\n    return {\n      boxes: this.boxes,\n      connections: this.connections,\n      nets: this.nets,\n    }\n  }\n}\n","import { Scene } from \"../../scene\"\n\nexport function getConnectionMap(scene: Scene) {\n  return scene.connections.reduce(\n    (acc, conn) => {\n      acc[conn.from] = conn.to\n      acc[conn.to] = conn.from\n      return acc\n    },\n    {} as Record<string, string>\n  )\n}\n","import { BoxWithAscendingIndex } from \"../ascending-central-lr-bug-1\"\n\n/**\n * Looks at the ascending indexes on each side, then centers the boxes\n */\nexport function centerSides(\n  new_boxes: BoxWithAscendingIndex[],\n  center_box: { box_id: string }\n) {\n  for (const side of [\"left\", \"right\"]) {\n    const side_boxes = new_boxes.filter((b) => b.side === side)\n    const side_boxes_ascending_indices = side_boxes\n      .map((b) => b.ascending_box_index)\n      .filter((b) => !isNaN(b))\n    const max_ascending_index = Math.max(...side_boxes_ascending_indices)\n\n    for (const box of side_boxes) {\n      if (box.box_id === center_box.box_id) continue\n      box.y -= (max_ascending_index / 2) * 1.25\n    }\n  }\n}\n","import { Box } from \"../../types\"\n\nexport const findBoxWithMostPorts = (boxes: Array<Box>) => {\n  let max = boxes[0]\n  for (const box of boxes) {\n    if (box.ports.length > max.ports.length) {\n      max = box\n    }\n  }\n  return max\n}\n","import { Scene } from \"../../scene\"\nimport { BoxWithAscendingIndex } from \"../ascending-central-lr-bug-1\"\n\n/**\n * Slide boxes connected to the same net, bringing them into alignment.\n */\nexport function slideBoxesConnectedToSameNet(\n  new_boxes: BoxWithAscendingIndex[],\n  connMap: Record<string, string>,\n  netSet: Set<string>,\n  scene: Scene\n) {\n  for (const side of [\"left\", \"right\"]) {\n    const sorted_side_boxes = new_boxes\n      .filter((b) => b.side === side)\n      .sort((a, b) => a.ascending_box_index - b.ascending_box_index)\n\n    for (let i = 0; i < sorted_side_boxes.length - 1; i++) {\n      const [A, B] = [sorted_side_boxes[i], sorted_side_boxes[i + 1]]\n      if (A.ports.length === 2 && B.ports.length === 2) {\n        const [A1, A2] = A.ports\n        const [B1, B2] = B.ports\n        const [A1_conn, A2_conn] = [A1, A2].map((p) => connMap[p.port_id])\n        const [B1_conn, B2_conn] = [B1, B2].map((p) => connMap[p.port_id])\n\n        // Find if A & B are connected to the same NET on one side\n        let shared_net_id: string | null = null\n        if (\n          (A1_conn === B1_conn || A1_conn === B2_conn) &&\n          netSet.has(A1_conn)\n        ) {\n          shared_net_id = A1_conn\n        } else if (\n          (A2_conn === B1_conn || A2_conn === B2_conn) &&\n          netSet.has(A2_conn)\n        ) {\n          shared_net_id = A2_conn\n        }\n\n        if (!shared_net_id) continue\n        const shared_net = scene.nets.find((n) => n.net_id === shared_net_id)!\n\n        if (!shared_net.is_ground && !shared_net.is_power) continue\n\n        if (shared_net.is_ground) {\n          // all greater than i move down by 1\n          sorted_side_boxes.slice(i + 1).forEach((b) => {\n            b.ascending_box_index -= 1\n            b.y -= 1\n          })\n        }\n\n        if (shared_net.is_power) {\n          // all greater than i down by 1\n          sorted_side_boxes.slice(i + 1).forEach((b) => {\n            b.ascending_box_index -= 1\n            b.y -= 1\n          })\n        }\n\n        // Shared net\n        // TODO rotate component if the shared side isn't in the same direction\n        // Is the shared net\n      }\n    }\n  }\n}\n","import { BoxWithAscendingIndex } from \"../ascending-central-lr-bug-1\"\n\nexport function removeAscendingBoxIndexGaps(\n  highest_ascending_box_index: number,\n  new_boxes: BoxWithAscendingIndex[]\n) {\n  for (let i = 0; i < highest_ascending_box_index; i++) {\n    let boxes_with_index = 0\n    for (const box of new_boxes) {\n      if (box.ascending_box_index === i) {\n        boxes_with_index += 1\n      }\n    }\n    if (boxes_with_index === 0) {\n      highest_ascending_box_index -= 1\n      for (const box of new_boxes) {\n        if (box.ascending_box_index > i) {\n          box.ascending_box_index -= 1\n        }\n      }\n    }\n  }\n  return highest_ascending_box_index\n}\n","import { Connection } from \"../../types\"\nimport { Scene } from \"../../scene\"\nimport { BoxWithAscendingIndex } from \"../ascending-central-lr-bug-1\"\n\n/**\n * This algorithm rewrites nets to placed net aliases, creating net alias\n * symbols (boxes) on the schematic then connecting the traces to them.\n *\n * The algorithm works by going through each \"ascending index\" on each side,\n * so each row 0, 1, 2, 3 etc. on the left and right sides. It then looks for\n * all the boxes on that row and checks if they have any common nets (where\n * each box shares a net). It will then create a net alias box that represents\n * the shared net, and net alias boxes for any other nets above the element.\n *\n * So sometimes there's a \"common net\" where we make 1 net alias for e.g. 4 boxes,\n * but sometimes we have to create a net alias for each box because they don't\n * all share the same net.\n */\nexport function addBoxesForNetsRewriteNetsToPlacedAliases(\n  new_boxes: BoxWithAscendingIndex[],\n  scene: Scene,\n  netSet: Set<string>,\n  new_conns: Connection[]\n) {\n  const highest_ascending_box_index = Math.max(\n    ...new_boxes.map((b) => b.ascending_box_index).filter((b) => !isNaN(b))\n  )\n  for (const side of [\"left\", \"right\"] as const) {\n    for (let i = 0; i <= highest_ascending_box_index; i++) {\n      const boxes_on_same_index = new_boxes\n        .filter((b) => b.side === side)\n        .filter((b) => b.ascending_box_index === i)\n      if (boxes_on_same_index.length === 0) continue\n\n      /**\n       * Connections on each box e.g.\n       * [\n       *  [A.1, GND, A.2, PWR],\n       *  [B.1, GND, B.2, U1.4],\n       * ]\n       */\n      const connections_on_index: string[][] = boxes_on_same_index.map((b) =>\n        scene.connections\n          .filter(\n            (c) =>\n              c.from.startsWith(b.box_id + \".\") ||\n              c.to.startsWith(b.box_id + \".\")\n          )\n          .map((c) => (c.from.startsWith(b.box_id + \".\") ? c.to : c.from))\n      )\n\n      /**\n       * Net connections for each box (or maybe just is_power or is_ground)\n       * [\n       *   [GND, PWR],\n       *   [GND],\n       * ]\n       */\n      const net_connections = connections_on_index.map((clist) =>\n        clist.filter((c) => netSet.has(c))\n      )\n\n      /**\n       * Common nets between all boxes on this ascending index\n       * [GND]\n       */\n      const common_net_ids = net_connections.reduce((acc, nets) => {\n        return acc.filter((n) => nets.includes(n))\n      }, net_connections[0])\n      const common_nets = common_net_ids.map(\n        (n) => scene.nets.find((net) => net.net_id === n)!\n      )\n\n      const minOrMaxFunc = side === \"left\" ? Math.max : Math.min\n\n      const x = minOrMaxFunc(...boxes_on_same_index.map((b) => b.x))\n\n      for (const common_net of common_nets) {\n        const y = i + (common_net?.is_ground ? -1 : 1)\n        const box_id = `${common_net?.net_id}_${side === \"left\" ? \"L\" : \"R\"}_${i}`\n        const port_id = common_net?.is_ground\n          ? `${box_id}.top`\n          : `${box_id}.bottom`\n        const net_box: BoxWithAscendingIndex = {\n          box_id,\n          x,\n          y,\n          side,\n          ascending_port_index: 0,\n          ascending_box_index: i,\n          width: 0,\n          ports: [\n            {\n              port_id,\n              rx: 0,\n              ry: common_net?.is_ground ? 0.1 : -0.1,\n            },\n          ],\n        }\n        new_boxes.push(net_box)\n\n        // Replace the $NET connection with a \"$box_id.top\" connection\n        for (const box of boxes_on_same_index) {\n          const box_conns = new_conns.filter(\n            (c) =>\n              c.from.startsWith(box.box_id + \".\") ||\n              c.to.startsWith(box.box_id + \".\")\n          )\n          for (const conn of box_conns) {\n            if (conn.from === common_net.net_id) {\n              conn.from = port_id\n            }\n            if (conn.to === common_net.net_id) {\n              conn.to = port_id\n            }\n          }\n        }\n      }\n\n      // Some of the boxes may still not have a box representing their net, so\n      // let's add those\n      for (let bi = 0; bi < boxes_on_same_index.length; bi++) {\n        const box = boxes_on_same_index[bi]\n        const hanging_net_connections_for_box = net_connections[bi].filter(\n          (c) => !common_net_ids.includes(c)\n        )\n\n        // introduce a box and connection directly above the port/box\n        for (const hanging_net_id of hanging_net_connections_for_box) {\n          const net = scene.nets.find((n) => n.net_id === hanging_net_id)!\n          const box_id = `${hanging_net_id}_${box.ascending_box_index}_${side === \"left\" ? \"L\" : \"R\"}_${bi}`\n          const port_id = `${box_id}.${net.is_ground ? \"top\" : \"bottom\"}`\n\n          const net_box: BoxWithAscendingIndex = {\n            x: box.x,\n            y: box.y + (net.is_ground ? -1 : 1),\n            side,\n            ascending_port_index: 0,\n            ascending_box_index: box.ascending_box_index,\n            box_id,\n            ports: [\n              {\n                port_id,\n                rx: 0,\n                ry: net.is_ground ? 0.1 : -0.1,\n              },\n            ],\n          }\n          new_boxes.push(net_box)\n\n          const conn = new_conns.find(\n            (c) =>\n              (c.from === hanging_net_id && c.to.startsWith(box.box_id)) ||\n              (c.to === hanging_net_id && c.from.startsWith(box.box_id))\n          )!\n          if (conn.from === hanging_net_id) conn.from = port_id\n          if (conn.to === hanging_net_id) conn.to = port_id\n        }\n      }\n    }\n  }\n  return highest_ascending_box_index\n}\n","import { Scene } from \"../scene\"\nimport { Box, Port } from \"../types\"\nimport { applyToPoint, rotate } from \"transformation-matrix\"\n\ntype ExtendedPort = Port & {\n  x: number\n  y: number\n  connected_port: { x: number; y: number }\n  connected_ports: Array<{ x: number; y: number }>\n}\n\ntype ExtendedBox = Box & {\n  applied_rotation_deg: 0 | 90 | 180 | 270\n  natural_offset_sum_deg: number\n  ports: ExtendedPort[]\n}\n\nconst rotateBox = (box: Box, angle: 0 | 90 | 180 | 270) => {\n  const mat = rotate(angle * (Math.PI / 180))\n  box.ports.forEach((port) => {\n    const np = applyToPoint(mat, { x: port.rx, y: port.ry })\n    port.rx = np.x\n    port.ry = np.y\n  })\n}\n\nconst normalizeVec = (vec: { x: number; y: number }) => {\n  const mag = Math.sqrt(vec.x ** 2 + vec.y ** 2)\n  return { x: vec.x / mag, y: vec.y / mag }\n}\n\nconst getAllPossibleBoxRotations = (box: Box) => {\n  const rotations = [0, 90, 180, 270] as const\n  return rotations.map((rotation) => {\n    const newBox = { ...box, ports: box.ports.map((p) => ({ ...p })) }\n    rotateBox(newBox, rotation)\n    // @ts-expect-error\n    newBox.applied_rotation_deg = rotation\n    return newBox\n  })\n}\n\n// Examine the direction that each box's port is being pulled in\nexport const autoRotateTwoPortBoxes = (scene: Scene) => {\n  // sort boxes by y position ascending- start from the bottom and work up\n  const boxes = scene.boxes.sort((a, b) => a.y - b.y)\n\n  for (const box of boxes) {\n    if (box.ports.length === 2) {\n      // Each port has it's position relative to the box, and the port it\n      // connects to.\n      const ports: ExtendedPort[] = box.ports\n        .map((port) => {\n          const connected_port_ids = scene.connections\n            .filter((c) => c.from === port.port_id || c.to === port.port_id)\n            .map((c) => (c.from === port.port_id ? c.to : c.from))\n\n          if (connected_port_ids.length === 0) return null\n          const connected_port_boxes = boxes.filter((b) =>\n            connected_port_ids.some((id) => id.startsWith(b.box_id + \".\"))\n          )!\n          const connected_ports = connected_port_boxes\n            .flatMap((cpb) => cpb.ports)\n            ?.filter((p) => connected_port_ids.includes(p.port_id)) as Array<\n            Port & { x: number; y: number }\n          >\n\n          for (const connected_port of connected_ports) {\n            const connected_port_box = connected_port_boxes.find(\n              (b) => b.box_id === connected_port.port_id.split(\".\")[0]\n            )!\n            connected_port.x = connected_port_box.x + connected_port.rx\n            connected_port.y = connected_port_box.y + connected_port.ry\n          }\n\n          return {\n            ...port,\n            connected_port: connected_ports[0],\n            connected_ports,\n          } as any\n        })\n        .filter(Boolean)\n\n      // No ports with connections\n      if (ports.length === 0) {\n        continue\n      }\n\n      // get the pull vector of each port for each rotation\n      const possible_box_rotations: ExtendedBox[] = getAllPossibleBoxRotations({\n        ...box,\n        ports,\n      }) as any\n\n      for (const box of possible_box_rotations) {\n        box.natural_offset_sum_deg = 0\n        for (const port of box.ports) {\n          for (const connected_port of port.connected_ports) {\n            const pull_vector = normalizeVec({\n              x: connected_port.x - (box.x + port.rx),\n              y: connected_port.y - (box.y + port.ry),\n            })\n            const natural_vector = normalizeVec({\n              x: port.rx,\n              y: port.ry,\n            })\n            const dist = Math.sqrt(\n              (pull_vector.x - natural_vector.x) ** 2 +\n                (pull_vector.y - natural_vector.y) ** 2\n            )\n            // calculate the angle between the pull vector and the natural vector\n            const dot =\n              pull_vector.x * natural_vector.x +\n              pull_vector.y * natural_vector.y\n            const det =\n              pull_vector.x * natural_vector.y -\n              pull_vector.y * natural_vector.x\n            const angle = Math.atan2(det, dot) * (180 / Math.PI)\n            box.natural_offset_sum_deg += Math.abs(angle) / dist\n          }\n        }\n      }\n\n      // find the rotation with the smallest sum of angles\n      const best_rotation = possible_box_rotations.reduce((a, b) =>\n        a.natural_offset_sum_deg < b.natural_offset_sum_deg ? a : b\n      )\n\n      rotateBox(box, best_rotation.applied_rotation_deg)\n    }\n  }\n\n  return scene\n}\n","import { Box, Connection, Port } from \"../types\"\nimport { getConnectionMap } from \"./sub-algorithms/getConnectionMap\"\nimport { centerSides } from \"./sub-algorithms/centerSides\"\nimport { findBoxWithMostPorts } from \"./sub-algorithms/findBoxWithMostPorts\"\nimport { slideBoxesConnectedToSameNet } from \"./sub-algorithms/slideBoxesConnectedToSameNet\"\nimport { LayoutAlgorithm } from \"./type\"\nimport { removeAscendingBoxIndexGaps } from \"./sub-algorithms/removeAscendingBoxIndexGaps\"\nimport { addBoxesForNetsRewriteNetsToPlacedAliases as addBoxesForNetsRewriteNetsToPlacedAliases } from \"./sub-algorithms/addBoxesForNetsRewriteNetsToSpecificAliases\"\nimport { autoRotateTwoPortBoxes } from \"./auto-rotate-two-port-boxes\"\n\nexport type BoxWithAscendingIndex = Box & {\n  side: \"left\" | \"right\"\n  /**\n   * How high from the bottom w.r.t. port connections\n   */\n  ascending_port_index: number\n  /**\n   * How high from the bottom this box should be ordered\n   */\n  ascending_box_index: number\n\n  width: number\n}\n\nexport const ascendingCentralLrBug1: LayoutAlgorithm = (scene) => {\n  const netSet = new Set(scene.nets.map((n) => n.net_id))\n  // Map port_id to whatever port it connects to\n  const connMap = getConnectionMap(scene)\n\n  const new_boxes: BoxWithAscendingIndex[] = JSON.parse(\n    JSON.stringify(scene.boxes)\n  )\n  const new_conns: Connection[] = JSON.parse(JSON.stringify(scene.connections))\n\n  // TODO remove reset in prod\n  for (const box of new_boxes) {\n    box.x = 0\n    box.y = 0\n    let smallest_port_rx = 0,\n      largest_port_rx = 0\n    for (const port of box.ports) {\n      if (port.rx < smallest_port_rx) {\n        smallest_port_rx = port.rx\n      } else if (port.rx > largest_port_rx) {\n        largest_port_rx = port.rx\n      }\n    }\n    box.width = largest_port_rx - smallest_port_rx\n  }\n\n  // 1. Identify central box\n  const center_box: Omit<Box, \"ports\"> & {\n    ports: Array<\n      Port & { side: \"left\" | \"right\"; ascending_port_index: number }\n    >\n    width: number\n  } = findBoxWithMostPorts(new_boxes) as any\n\n  for (const port of center_box.ports) {\n    if (port.rx > 0) {\n      port.side = \"right\"\n    } else if (port.rx < 0) {\n      port.side = \"left\"\n    }\n  }\n\n  // 2. Find the side each box is on\n  for (const box of new_boxes) {\n    if (box.box_id === center_box.box_id) continue\n\n    const ports_box_is_connected_to = center_box.ports.filter((p) =>\n      new_conns.some(\n        (c) =>\n          (c.from.startsWith(box.box_id) && c.to === p.port_id) ||\n          (c.to.startsWith(box.box_id) && c.from === p.port_id)\n      )\n    )\n\n    if (ports_box_is_connected_to.length === 0) {\n      box.side = \"left\"\n      continue\n    }\n\n    // If the box shares ports majority on the left side, then box.side = \"left\"\n    // else it's on right\n    let left_count = 0\n    let right_count = 0\n\n    for (const port of ports_box_is_connected_to) {\n      if (port.rx > 0) {\n        right_count += 1\n      } else if (port.rx < 0) {\n        left_count += 1\n      }\n    }\n\n    if (left_count >= right_count) {\n      box.side = \"left\"\n    } else {\n      box.side = \"right\"\n    }\n  }\n\n  // 2. Get the ascending indices of the boxes\n  // for (const box of new_boxes) {\n  //   // TODO only use ports on same side as box\n  //   const relevant_side_ports = box.ports\n  // }\n\n  for (const side of [\"left\", \"right\"]) {\n    const side_ports = center_box.ports.filter((p) => p.side === side)\n    side_ports.sort((a, b) => a.ry - b.ry)\n    for (const port of side_ports) {\n      port.ascending_port_index = side_ports.indexOf(port)\n    }\n  }\n\n  for (const box of new_boxes) {\n    if (box.box_id === center_box.box_id) continue\n    const box_connections = scene.connections\n      .filter(\n        (connection) =>\n          connection.from.startsWith(box.box_id + \".\") ||\n          connection.to.startsWith(box.box_id + \".\")\n      )\n      .map((connection) =>\n        connection.from.startsWith(box.box_id + \".\")\n          ? connection.to\n          : connection.from\n      )\n    const ports_box_is_connected_to = center_box.ports.filter((p) =>\n      box_connections.includes(p.port_id)\n    )\n\n    if (ports_box_is_connected_to.length === 0) {\n      continue\n    }\n\n    box.ascending_port_index = Math.min(\n      ...ports_box_is_connected_to.map((p: any) => p.ascending_port_index)\n    )\n    box.ascending_box_index = box.ascending_port_index\n  }\n\n  let highest_ascending_box_index = Math.max(\n    0,\n    ...new_boxes.map((b) => b.ascending_box_index).filter((bi) => !isNaN(bi))\n  )\n\n  for (const box of new_boxes) {\n    if (box.box_id === center_box.box_id) continue\n    if (box.ascending_box_index === undefined) {\n      highest_ascending_box_index += 1\n      box.ascending_box_index = highest_ascending_box_index\n    }\n  }\n\n  // Remove box_index \"gaps\", e.g. if no boxes have index 1, then every index >1\n  // should be decremented by 1\n  // TODO: this is an N^2 algorithm, easily can be made N\n  for (const side of [\"left\", \"right\"]) {\n    removeAscendingBoxIndexGaps(\n      highest_ascending_box_index,\n      new_boxes.filter((b) => b.side === side)\n    )\n  }\n\n  for (const side of [\"left\", \"right\"]) {\n    let travel_x = center_box.width * 0.75 * (side === \"left\" ? -1 : 1)\n    for (let i = 0; i <= highest_ascending_box_index; i++) {\n      const boxes_on_same_index = new_boxes.filter(\n        (b) => b.side === side && b.ascending_box_index === i\n      )\n      const widest_box_width = Math.max(\n        ...boxes_on_same_index.map((b) => b.width)\n      )\n      const dist_to_last_col =\n        Math.max(0.5, widest_box_width) * (side === \"left\" ? -1 : 1)\n      travel_x += dist_to_last_col\n      for (const box of boxes_on_same_index) {\n        if (box.box_id === center_box.box_id) continue\n        box.y = box.ascending_box_index * 1.25\n        box.x = travel_x\n      }\n      travel_x += dist_to_last_col / 2\n    }\n  }\n\n  slideBoxesConnectedToSameNet(new_boxes, connMap, netSet, scene)\n\n  // Add boxes representing the net, anything with the same ascending_box_index\n  // can share the same net box\n  addBoxesForNetsRewriteNetsToPlacedAliases(new_boxes, scene, netSet, new_conns)\n\n  centerSides(new_boxes, center_box)\n\n  const new_scene = {\n    ...scene,\n    connections: new_conns,\n    boxes: new_boxes,\n  }\n\n  autoRotateTwoPortBoxes(new_scene)\n\n  return new_scene\n  // return alignTbBoxesWithNetConnection(new_scene)\n}\n"],"mappings":"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","names":["scene","scene","scene","scene","scene","box","scene"]}