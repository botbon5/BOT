var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};

// src/lib/mutate-soup-for-scene.ts
import { transformSchematicElement } from "@tscircuit/soup-util";
import { translate } from "transformation-matrix";
var convertSceneToSoup = (og_soup, scene2) => {
  return mutateSoupForScene(JSON.parse(JSON.stringify(og_soup)), scene2);
};
var mutateSoupForScene = (og_soup, scene2) => {
  const soup = og_soup;
  for (const box of scene2.boxes) {
    const schematic_component = soup.find(
      (e) => e.type === "schematic_component" && e.schematic_component_id === box.box_id
    );
    const mat = translate(
      box.x - schematic_component.center.x,
      box.y - schematic_component.center.y
    );
    for (const elm of soup) {
      if (elm.schematic_component_id === box.box_id) {
        transformSchematicElement(elm, mat);
      }
    }
  }
  return soup;
};

// src/lib/convert-soup-to-scene.ts
var convertSoupToScene = (soup) => {
  const boxes = [];
  const connections = [];
  const nets = [];
  const soup_elm_map = {
    schematic_component: soup.filter(
      (e) => e.type === "schematic_component"
    ),
    schematic_port: soup.filter(
      (e) => e.type === "schematic_port"
    ),
    source_port: soup.filter(
      (e) => e.type === "source_port"
    ),
    schematic_trace: soup.filter(
      (e) => e.type === "schematic_trace"
    ),
    source_trace: soup.filter(
      (e) => e.type === "source_trace"
    )
  };
  for (const schematic_component of soup_elm_map.schematic_component) {
    const ports = [];
    const box_id = schematic_component.schematic_component_id;
    for (const sch_port of soup_elm_map.schematic_port) {
      if (sch_port.schematic_component_id === schematic_component.schematic_component_id) {
        ports.push({
          port_id: `${box_id}.${sch_port.schematic_port_id}`,
          rx: sch_port.center.x - schematic_component.center.x,
          ry: sch_port.center.y - schematic_component.center.y
        });
      }
    }
    const box = {
      box_id,
      x: schematic_component.center.x,
      y: schematic_component.center.y,
      ports
    };
    boxes.push(box);
  }
  for (const source_trace of soup_elm_map.source_trace) {
    const [sp_A, sp_B] = source_trace.connected_source_port_ids;
    const schp_A = soup_elm_map.schematic_port.find(
      (sch_port) => sch_port.source_port_id === sp_A
    );
    const schp_B = soup_elm_map.schematic_port.find(
      (sch_port) => sch_port.source_port_id === sp_B
    );
    if (!schp_A || !schp_B) {
      continue;
    }
    const schcomp_A = soup_elm_map.schematic_component.find(
      (sch_comp) => sch_comp.schematic_component_id === schp_A.schematic_component_id
    );
    const schcomp_B = soup_elm_map.schematic_component.find(
      (sch_comp) => sch_comp.schematic_component_id === schp_B.schematic_component_id
    );
    if (!schcomp_A || !schcomp_B) {
      continue;
    }
    const connection = {
      from: `${schcomp_A.schematic_component_id}.${schp_A.schematic_port_id}`,
      to: `${schcomp_B.schematic_component_id}.${schp_B.schematic_port_id}`
    };
    connections.push(connection);
  }
  return {
    boxes,
    connections,
    nets
  };
};

// src/lib/get-ccw-position.ts
var getCcwPosition = (index, opts) => {
  opts.centered_around ?? (opts.centered_around = { x: 0, y: 0 });
  opts.pitch ?? (opts.pitch = 1);
  opts.space_between_sides ?? (opts.space_between_sides = 5);
  const { left_side_size, right_size_size } = opts;
  const height = (Math.max(left_side_size, right_size_size) - 1) * opts.pitch;
  if (index < left_side_size) {
    return {
      x: opts.centered_around.x - opts.space_between_sides / 2,
      y: opts.centered_around.y + height / 2 - index * opts.pitch
    };
  } else {
    const rindex = index - left_side_size;
    return {
      x: opts.centered_around.x + opts.space_between_sides / 2,
      y: opts.centered_around.y - height / 2 + rindex * opts.pitch
    };
  }
};

// src/lib/scene.ts
var scene = () => new SceneBuilder();
var SceneBuilder = class {
  constructor() {
    __publicField(this, "boxes");
    __publicField(this, "connections");
    __publicField(this, "nets");
    this.boxes = [];
    this.connections = [];
    this.nets = [];
  }
  addNet(net_id, opts) {
    this.nets.push({ net_id, ...opts });
    return this;
  }
  addCcwBox(box_id, opts) {
    const box = {
      box_id,
      x: opts.x,
      y: opts.y,
      ports: []
    };
    for (let i = 0; i < opts.leftPorts + opts.rightPorts; i++) {
      const ccwPos = getCcwPosition(i, {
        left_side_size: opts.leftPorts,
        right_size_size: opts.rightPorts,
        centered_around: { x: 0, y: 0 },
        pitch: 0.5,
        space_between_sides: 1
      });
      box.ports.push({
        port_id: `${box_id}.${i + 1}`,
        rx: ccwPos.x,
        ry: ccwPos.y
      });
    }
    this.boxes.push(box);
    return this;
  }
  addLrBox(box_id, opts) {
    this.boxes.push({
      box_id,
      x: opts.x,
      y: opts.y,
      ports: [
        {
          port_id: `${box_id}.left`,
          rx: -0.3,
          ry: 0
        },
        {
          port_id: `${box_id}.right`,
          rx: 0.3,
          ry: 0
        }
      ]
    });
    return this;
  }
  addTbBox(box_id, opts) {
    this.boxes.push({
      box_id,
      x: opts.x,
      y: opts.y,
      ports: [
        {
          port_id: `${box_id}.top`,
          rx: 0,
          ry: 0.3
        },
        {
          port_id: `${box_id}.bottom`,
          rx: 0,
          ry: -0.3
        }
      ]
    });
    return this;
  }
  addTBox(box_id, opts) {
    this.boxes.push({
      box_id,
      x: opts.x,
      y: opts.y,
      ports: [
        {
          port_id: `${box_id}.top`,
          rx: 0,
          ry: 0.1
        }
      ]
    });
    return this;
  }
  addBBox(box_id, opts) {
    this.boxes.push({
      box_id,
      x: opts.x,
      y: opts.y,
      ports: [
        {
          port_id: `${box_id}.bottom`,
          rx: 0,
          ry: -0.1
        }
      ]
    });
    return this;
  }
  connect(from, to) {
    this.connections.push({ from, to });
    return this;
  }
  build() {
    return {
      boxes: this.boxes,
      connections: this.connections,
      nets: this.nets
    };
  }
};

// src/lib/algorithms/sub-algorithms/getConnectionMap.ts
function getConnectionMap(scene2) {
  return scene2.connections.reduce(
    (acc, conn) => {
      acc[conn.from] = conn.to;
      acc[conn.to] = conn.from;
      return acc;
    },
    {}
  );
}

// src/lib/algorithms/sub-algorithms/centerSides.ts
function centerSides(new_boxes, center_box) {
  for (const side of ["left", "right"]) {
    const side_boxes = new_boxes.filter((b) => b.side === side);
    const side_boxes_ascending_indices = side_boxes.map((b) => b.ascending_box_index).filter((b) => !isNaN(b));
    const max_ascending_index = Math.max(...side_boxes_ascending_indices);
    for (const box of side_boxes) {
      if (box.box_id === center_box.box_id)
        continue;
      box.y -= max_ascending_index / 2 * 1.25;
    }
  }
}

// src/lib/algorithms/sub-algorithms/findBoxWithMostPorts.ts
var findBoxWithMostPorts = (boxes) => {
  let max = boxes[0];
  for (const box of boxes) {
    if (box.ports.length > max.ports.length) {
      max = box;
    }
  }
  return max;
};

// src/lib/algorithms/sub-algorithms/slideBoxesConnectedToSameNet.ts
function slideBoxesConnectedToSameNet(new_boxes, connMap, netSet, scene2) {
  for (const side of ["left", "right"]) {
    const sorted_side_boxes = new_boxes.filter((b) => b.side === side).sort((a, b) => a.ascending_box_index - b.ascending_box_index);
    for (let i = 0; i < sorted_side_boxes.length - 1; i++) {
      const [A, B] = [sorted_side_boxes[i], sorted_side_boxes[i + 1]];
      if (A.ports.length === 2 && B.ports.length === 2) {
        const [A1, A2] = A.ports;
        const [B1, B2] = B.ports;
        const [A1_conn, A2_conn] = [A1, A2].map((p) => connMap[p.port_id]);
        const [B1_conn, B2_conn] = [B1, B2].map((p) => connMap[p.port_id]);
        let shared_net_id = null;
        if ((A1_conn === B1_conn || A1_conn === B2_conn) && netSet.has(A1_conn)) {
          shared_net_id = A1_conn;
        } else if ((A2_conn === B1_conn || A2_conn === B2_conn) && netSet.has(A2_conn)) {
          shared_net_id = A2_conn;
        }
        if (!shared_net_id)
          continue;
        const shared_net = scene2.nets.find((n) => n.net_id === shared_net_id);
        if (!shared_net.is_ground && !shared_net.is_power)
          continue;
        if (shared_net.is_ground) {
          sorted_side_boxes.slice(i + 1).forEach((b) => {
            b.ascending_box_index -= 1;
            b.y -= 1;
          });
        }
        if (shared_net.is_power) {
          sorted_side_boxes.slice(i + 1).forEach((b) => {
            b.ascending_box_index -= 1;
            b.y -= 1;
          });
        }
      }
    }
  }
}

// src/lib/algorithms/sub-algorithms/removeAscendingBoxIndexGaps.ts
function removeAscendingBoxIndexGaps(highest_ascending_box_index, new_boxes) {
  for (let i = 0; i < highest_ascending_box_index; i++) {
    let boxes_with_index = 0;
    for (const box of new_boxes) {
      if (box.ascending_box_index === i) {
        boxes_with_index += 1;
      }
    }
    if (boxes_with_index === 0) {
      highest_ascending_box_index -= 1;
      for (const box of new_boxes) {
        if (box.ascending_box_index > i) {
          box.ascending_box_index -= 1;
        }
      }
    }
  }
  return highest_ascending_box_index;
}

// src/lib/algorithms/sub-algorithms/addBoxesForNetsRewriteNetsToSpecificAliases.ts
function addBoxesForNetsRewriteNetsToPlacedAliases(new_boxes, scene2, netSet, new_conns) {
  const highest_ascending_box_index = Math.max(
    ...new_boxes.map((b) => b.ascending_box_index).filter((b) => !isNaN(b))
  );
  for (const side of ["left", "right"]) {
    for (let i = 0; i <= highest_ascending_box_index; i++) {
      const boxes_on_same_index = new_boxes.filter((b) => b.side === side).filter((b) => b.ascending_box_index === i);
      if (boxes_on_same_index.length === 0)
        continue;
      const connections_on_index = boxes_on_same_index.map(
        (b) => scene2.connections.filter(
          (c) => c.from.startsWith(b.box_id + ".") || c.to.startsWith(b.box_id + ".")
        ).map((c) => c.from.startsWith(b.box_id + ".") ? c.to : c.from)
      );
      const net_connections = connections_on_index.map(
        (clist) => clist.filter((c) => netSet.has(c))
      );
      const common_net_ids = net_connections.reduce((acc, nets) => {
        return acc.filter((n) => nets.includes(n));
      }, net_connections[0]);
      const common_nets = common_net_ids.map(
        (n) => scene2.nets.find((net) => net.net_id === n)
      );
      const minOrMaxFunc = side === "left" ? Math.max : Math.min;
      const x = minOrMaxFunc(...boxes_on_same_index.map((b) => b.x));
      for (const common_net of common_nets) {
        const y = i + (common_net?.is_ground ? -1 : 1);
        const box_id = `${common_net?.net_id}_${side === "left" ? "L" : "R"}_${i}`;
        const port_id = common_net?.is_ground ? `${box_id}.top` : `${box_id}.bottom`;
        const net_box = {
          box_id,
          x,
          y,
          side,
          ascending_port_index: 0,
          ascending_box_index: i,
          width: 0,
          ports: [
            {
              port_id,
              rx: 0,
              ry: common_net?.is_ground ? 0.1 : -0.1
            }
          ]
        };
        new_boxes.push(net_box);
        for (const box of boxes_on_same_index) {
          const box_conns = new_conns.filter(
            (c) => c.from.startsWith(box.box_id + ".") || c.to.startsWith(box.box_id + ".")
          );
          for (const conn of box_conns) {
            if (conn.from === common_net.net_id) {
              conn.from = port_id;
            }
            if (conn.to === common_net.net_id) {
              conn.to = port_id;
            }
          }
        }
      }
      for (let bi = 0; bi < boxes_on_same_index.length; bi++) {
        const box = boxes_on_same_index[bi];
        const hanging_net_connections_for_box = net_connections[bi].filter(
          (c) => !common_net_ids.includes(c)
        );
        for (const hanging_net_id of hanging_net_connections_for_box) {
          const net = scene2.nets.find((n) => n.net_id === hanging_net_id);
          const box_id = `${hanging_net_id}_${box.ascending_box_index}_${side === "left" ? "L" : "R"}_${bi}`;
          const port_id = `${box_id}.${net.is_ground ? "top" : "bottom"}`;
          const net_box = {
            x: box.x,
            y: box.y + (net.is_ground ? -1 : 1),
            side,
            ascending_port_index: 0,
            ascending_box_index: box.ascending_box_index,
            box_id,
            ports: [
              {
                port_id,
                rx: 0,
                ry: net.is_ground ? 0.1 : -0.1
              }
            ]
          };
          new_boxes.push(net_box);
          const conn = new_conns.find(
            (c) => c.from === hanging_net_id && c.to.startsWith(box.box_id) || c.to === hanging_net_id && c.from.startsWith(box.box_id)
          );
          if (conn.from === hanging_net_id)
            conn.from = port_id;
          if (conn.to === hanging_net_id)
            conn.to = port_id;
        }
      }
    }
  }
  return highest_ascending_box_index;
}

// src/lib/algorithms/auto-rotate-two-port-boxes.ts
import { applyToPoint, rotate } from "transformation-matrix";
var rotateBox = (box, angle) => {
  const mat = rotate(angle * (Math.PI / 180));
  box.ports.forEach((port) => {
    const np = applyToPoint(mat, { x: port.rx, y: port.ry });
    port.rx = np.x;
    port.ry = np.y;
  });
};
var normalizeVec = (vec) => {
  const mag = Math.sqrt(vec.x ** 2 + vec.y ** 2);
  return { x: vec.x / mag, y: vec.y / mag };
};
var getAllPossibleBoxRotations = (box) => {
  const rotations = [0, 90, 180, 270];
  return rotations.map((rotation) => {
    const newBox = { ...box, ports: box.ports.map((p) => ({ ...p })) };
    rotateBox(newBox, rotation);
    newBox.applied_rotation_deg = rotation;
    return newBox;
  });
};
var autoRotateTwoPortBoxes = (scene2) => {
  const boxes = scene2.boxes.sort((a, b) => a.y - b.y);
  for (const box of boxes) {
    if (box.ports.length === 2) {
      const ports = box.ports.map((port) => {
        const connected_port_ids = scene2.connections.filter((c) => c.from === port.port_id || c.to === port.port_id).map((c) => c.from === port.port_id ? c.to : c.from);
        if (connected_port_ids.length === 0)
          return null;
        const connected_port_boxes = boxes.filter(
          (b) => connected_port_ids.some((id) => id.startsWith(b.box_id + "."))
        );
        const connected_ports = connected_port_boxes.flatMap((cpb) => cpb.ports)?.filter((p) => connected_port_ids.includes(p.port_id));
        for (const connected_port of connected_ports) {
          const connected_port_box = connected_port_boxes.find(
            (b) => b.box_id === connected_port.port_id.split(".")[0]
          );
          connected_port.x = connected_port_box.x + connected_port.rx;
          connected_port.y = connected_port_box.y + connected_port.ry;
        }
        return {
          ...port,
          connected_port: connected_ports[0],
          connected_ports
        };
      }).filter(Boolean);
      if (ports.length === 0) {
        continue;
      }
      const possible_box_rotations = getAllPossibleBoxRotations({
        ...box,
        ports
      });
      for (const box2 of possible_box_rotations) {
        box2.natural_offset_sum_deg = 0;
        for (const port of box2.ports) {
          for (const connected_port of port.connected_ports) {
            const pull_vector = normalizeVec({
              x: connected_port.x - (box2.x + port.rx),
              y: connected_port.y - (box2.y + port.ry)
            });
            const natural_vector = normalizeVec({
              x: port.rx,
              y: port.ry
            });
            const dist = Math.sqrt(
              (pull_vector.x - natural_vector.x) ** 2 + (pull_vector.y - natural_vector.y) ** 2
            );
            const dot = pull_vector.x * natural_vector.x + pull_vector.y * natural_vector.y;
            const det = pull_vector.x * natural_vector.y - pull_vector.y * natural_vector.x;
            const angle = Math.atan2(det, dot) * (180 / Math.PI);
            box2.natural_offset_sum_deg += Math.abs(angle) / dist;
          }
        }
      }
      const best_rotation = possible_box_rotations.reduce(
        (a, b) => a.natural_offset_sum_deg < b.natural_offset_sum_deg ? a : b
      );
      rotateBox(box, best_rotation.applied_rotation_deg);
    }
  }
  return scene2;
};

// src/lib/algorithms/ascending-central-lr-bug-1.ts
var ascendingCentralLrBug1 = (scene2) => {
  const netSet = new Set(scene2.nets.map((n) => n.net_id));
  const connMap = getConnectionMap(scene2);
  const new_boxes = JSON.parse(
    JSON.stringify(scene2.boxes)
  );
  const new_conns = JSON.parse(JSON.stringify(scene2.connections));
  for (const box of new_boxes) {
    box.x = 0;
    box.y = 0;
    let smallest_port_rx = 0, largest_port_rx = 0;
    for (const port of box.ports) {
      if (port.rx < smallest_port_rx) {
        smallest_port_rx = port.rx;
      } else if (port.rx > largest_port_rx) {
        largest_port_rx = port.rx;
      }
    }
    box.width = largest_port_rx - smallest_port_rx;
  }
  const center_box = findBoxWithMostPorts(new_boxes);
  for (const port of center_box.ports) {
    if (port.rx > 0) {
      port.side = "right";
    } else if (port.rx < 0) {
      port.side = "left";
    }
  }
  for (const box of new_boxes) {
    if (box.box_id === center_box.box_id)
      continue;
    const ports_box_is_connected_to = center_box.ports.filter(
      (p) => new_conns.some(
        (c) => c.from.startsWith(box.box_id) && c.to === p.port_id || c.to.startsWith(box.box_id) && c.from === p.port_id
      )
    );
    if (ports_box_is_connected_to.length === 0) {
      box.side = "left";
      continue;
    }
    let left_count = 0;
    let right_count = 0;
    for (const port of ports_box_is_connected_to) {
      if (port.rx > 0) {
        right_count += 1;
      } else if (port.rx < 0) {
        left_count += 1;
      }
    }
    if (left_count >= right_count) {
      box.side = "left";
    } else {
      box.side = "right";
    }
  }
  for (const side of ["left", "right"]) {
    const side_ports = center_box.ports.filter((p) => p.side === side);
    side_ports.sort((a, b) => a.ry - b.ry);
    for (const port of side_ports) {
      port.ascending_port_index = side_ports.indexOf(port);
    }
  }
  for (const box of new_boxes) {
    if (box.box_id === center_box.box_id)
      continue;
    const box_connections = scene2.connections.filter(
      (connection) => connection.from.startsWith(box.box_id + ".") || connection.to.startsWith(box.box_id + ".")
    ).map(
      (connection) => connection.from.startsWith(box.box_id + ".") ? connection.to : connection.from
    );
    const ports_box_is_connected_to = center_box.ports.filter(
      (p) => box_connections.includes(p.port_id)
    );
    if (ports_box_is_connected_to.length === 0) {
      continue;
    }
    box.ascending_port_index = Math.min(
      ...ports_box_is_connected_to.map((p) => p.ascending_port_index)
    );
    box.ascending_box_index = box.ascending_port_index;
  }
  let highest_ascending_box_index = Math.max(
    0,
    ...new_boxes.map((b) => b.ascending_box_index).filter((bi) => !isNaN(bi))
  );
  for (const box of new_boxes) {
    if (box.box_id === center_box.box_id)
      continue;
    if (box.ascending_box_index === void 0) {
      highest_ascending_box_index += 1;
      box.ascending_box_index = highest_ascending_box_index;
    }
  }
  for (const side of ["left", "right"]) {
    removeAscendingBoxIndexGaps(
      highest_ascending_box_index,
      new_boxes.filter((b) => b.side === side)
    );
  }
  for (const side of ["left", "right"]) {
    let travel_x = center_box.width * 0.75 * (side === "left" ? -1 : 1);
    for (let i = 0; i <= highest_ascending_box_index; i++) {
      const boxes_on_same_index = new_boxes.filter(
        (b) => b.side === side && b.ascending_box_index === i
      );
      const widest_box_width = Math.max(
        ...boxes_on_same_index.map((b) => b.width)
      );
      const dist_to_last_col = Math.max(0.5, widest_box_width) * (side === "left" ? -1 : 1);
      travel_x += dist_to_last_col;
      for (const box of boxes_on_same_index) {
        if (box.box_id === center_box.box_id)
          continue;
        box.y = box.ascending_box_index * 1.25;
        box.x = travel_x;
      }
      travel_x += dist_to_last_col / 2;
    }
  }
  slideBoxesConnectedToSameNet(new_boxes, connMap, netSet, scene2);
  addBoxesForNetsRewriteNetsToPlacedAliases(new_boxes, scene2, netSet, new_conns);
  centerSides(new_boxes, center_box);
  const new_scene = {
    ...scene2,
    connections: new_conns,
    boxes: new_boxes
  };
  autoRotateTwoPortBoxes(new_scene);
  return new_scene;
};
export {
  ascendingCentralLrBug1,
  autoRotateTwoPortBoxes,
  convertSceneToSoup,
  convertSoupToScene,
  mutateSoupForScene,
  scene
};
//# sourceMappingURL=index.js.map