// webworker/execution-context.ts
import { RootCircuit } from "@tscircuit/core";
import * as tscircuitCore from "@tscircuit/core";
import * as React from "react";
import * as jscadFiber from "jscad-fiber";
import * as tscircuitMathUtils from "@tscircuit/math-utils";

// node_modules/@tscircuit/parts-engine/lib/jlc-parts-engine.ts
var cache = /* @__PURE__ */ new Map();
var getJlcPartsCached = async (name, params) => {
  const paramString = new URLSearchParams({
    ...params,
    json: "true"
  }).toString();
  if (cache.has(paramString)) {
    return cache.get(paramString);
  }
  const response = await fetch(
    `https://jlcsearch.tscircuit.com/${name}/list?${paramString}`
  );
  const responseJson = await response.json();
  cache.set(paramString, responseJson);
  return responseJson;
};
var jlcPartsEngine = {
  findPart: async ({
    sourceComponent,
    footprinterString
  }) => {
    if (sourceComponent.type === "source_component" && sourceComponent.ftype === "simple_resistor") {
      const { resistors } = await getJlcPartsCached("resistors", {
        resistance: sourceComponent.display_resistance ?? sourceComponent.resistance,
        package: footprinterString
      });
      return {
        jlcpcb: (resistors ?? []).map((r) => `C${r.lcsc}`).slice(0, 3)
      };
    } else if (sourceComponent.type === "source_component" && sourceComponent.ftype === "simple_capacitor") {
      if (footprinterString?.includes("cap")) {
        footprinterString = footprinterString.replace("cap", "");
      }
      const { capacitors } = await getJlcPartsCached("capacitors", {
        capacitance: sourceComponent.display_capacitance ?? sourceComponent.capacitance,
        package: footprinterString
      });
      return {
        jlcpcb: (capacitors ?? []).map((c) => `C${c.lcsc}`).slice(0, 3)
      };
    } else if (sourceComponent.type === "source_component" && sourceComponent.ftype === "simple_pin_header") {
      let pitch;
      if (footprinterString?.includes("_p")) {
        pitch = Number(footprinterString.split("_p")[1]);
      }
      const { headers } = await getJlcPartsCached(
        "headers",
        pitch ? {
          pitch,
          num_pins: sourceComponent.pin_count,
          gender: sourceComponent.gender
        } : {
          num_pins: sourceComponent.pin_count,
          gender: sourceComponent.gender
        }
      );
      return {
        jlcpcb: (headers ?? []).map((h) => `C${h.lcsc}`).slice(0, 3)
      };
    } else if (sourceComponent.type === "source_component" && sourceComponent.ftype === "simple_potentiometer") {
      const { potentiometers } = await getJlcPartsCached("potentiometers", {
        resistance: sourceComponent.max_resistance,
        package: footprinterString
      });
      return {
        jlcpcb: (potentiometers ?? []).map((p) => `C${p.lcsc}`).slice(0, 3)
      };
    } else if (sourceComponent.type === "source_component" && sourceComponent.ftype === "simple_diode") {
      const { diodes } = await getJlcPartsCached("diodes", {
        package: footprinterString
      });
      return {
        jlcpcb: (diodes ?? []).map((d) => `C${d.lcsc}`).slice(0, 3)
      };
    } else if (sourceComponent.type === "source_component" && sourceComponent.ftype === "simple_chip") {
      const { chips } = await getJlcPartsCached("chips", {
        package: footprinterString
      });
      return {
        jlcpcb: (chips ?? []).map((c) => `C${c.lcsc}`).slice(0, 3)
      };
    } else if (sourceComponent.type === "source_component" && sourceComponent.ftype === "simple_transistor") {
      const { transistors } = await getJlcPartsCached("transistors", {
        package: footprinterString,
        transistor_type: sourceComponent.transistor_type
      });
      return {
        jlcpcb: (transistors ?? []).map((t) => `C${t.lcsc}`).slice(0, 3)
      };
    } else if (sourceComponent.type === "source_component" && sourceComponent.ftype === "simple_power_source") {
      const { power_sources } = await getJlcPartsCached("power_sources", {
        voltage: sourceComponent.voltage,
        package: footprinterString
      });
      return {
        jlcpcb: (power_sources ?? []).map((p) => `C${p.lcsc}`).slice(0, 3)
      };
    } else if (sourceComponent.type === "source_component" && sourceComponent.ftype === "simple_inductor") {
      const { inductors } = await getJlcPartsCached("inductors", {
        inductance: sourceComponent.inductance,
        package: footprinterString
      });
      return {
        jlcpcb: (inductors ?? []).map((i) => `C${i.lcsc}`).slice(0, 3)
      };
    } else if (sourceComponent.type === "source_component" && sourceComponent.ftype === "simple_crystal") {
      const { crystals } = await getJlcPartsCached("crystals", {
        frequency: sourceComponent.frequency,
        load_capacitance: sourceComponent.load_capacitance,
        package: footprinterString
      });
      return {
        jlcpcb: (crystals ?? []).map((c) => `C${c.lcsc}`).slice(0, 3)
      };
    } else if (sourceComponent.type === "source_component" && sourceComponent.ftype === "simple_mosfet") {
      const { mosfets } = await getJlcPartsCached("mosfets", {
        package: footprinterString,
        mosfet_mode: sourceComponent.mosfet_mode,
        channel_type: sourceComponent.channel_type
      });
      return {
        jlcpcb: (mosfets ?? []).map((m) => `C${m.lcsc}`).slice(0, 3)
      };
    } else if (sourceComponent.type === "source_component" && sourceComponent.ftype === "simple_resonator") {
      const { resonators } = await getJlcPartsCached("resonators", {
        frequency: sourceComponent.frequency,
        package: footprinterString
      });
      return {
        jlcpcb: (resonators ?? []).map((r) => `C${r.lcsc}`).slice(0, 3)
      };
    } else if (sourceComponent.type === "source_component" && sourceComponent.ftype === "simple_switch") {
      const { switches } = await getJlcPartsCached("switches", {
        switch_type: sourceComponent.type,
        package: footprinterString
      });
      return {
        jlcpcb: (switches ?? []).map((s) => `C${s.lcsc}`).slice(0, 3)
      };
    } else if (sourceComponent.type === "source_component" && sourceComponent.ftype === "simple_led") {
      const { leds } = await getJlcPartsCached("leds", {
        package: footprinterString
      });
      return {
        jlcpcb: (leds ?? []).map((l) => `C${l.lcsc}`).slice(0, 3)
      };
    } else if (sourceComponent.type === "source_component" && sourceComponent.ftype === "simple_fuse") {
      const { fuses } = await getJlcPartsCached("fuses", {
        package: footprinterString
      });
      return {
        jlcpcb: (fuses ?? []).map((l) => `C${l.lcsc}`).slice(0, 3)
      };
    }
    return {};
  }
};

// lib/getPlatformConfig.ts
var getPlatformConfig = () => ({
  partsEngine: jlcPartsEngine
});

// webworker/execution-context.ts
import Debug from "debug";
var debug = Debug("tsci:eval:execution-context");
function createExecutionContext(webWorkerConfiguration, opts = {}) {
  globalThis.React = React;
  const circuit = new RootCircuit({
    platform: opts.platform || getPlatformConfig()
  });
  if (opts.name) {
    circuit.name = opts.name;
  }
  return {
    fsMap: {},
    entrypoint: "",
    preSuppliedImports: {
      "@tscircuit/core": tscircuitCore,
      tscircuit: tscircuitCore,
      "@tscircuit/math-utils": tscircuitMathUtils,
      react: React,
      "jscad-fiber": jscadFiber,
      // This is usually used as a type import, we can remove the shim when we
      // ignore type imports in getImportsFromCode
      "@tscircuit/props": {}
    },
    circuit,
    ...webWorkerConfiguration
  };
}

// lib/runner/normalizeFsMap.ts
function normalizeFilePath(filePath) {
  let normFilePath = filePath;
  normFilePath = normFilePath.replace(/\\/g, "/");
  normFilePath = normFilePath.trim();
  if (normFilePath.startsWith("./")) {
    normFilePath = normFilePath.slice(2);
  }
  if (normFilePath.startsWith("/")) {
    normFilePath = normFilePath.slice(1);
  }
  return normFilePath;
}
function normalizeFsMap(fsMap) {
  const normalizedFsMap = {};
  for (const [fsPath, fileContent] of Object.entries(fsMap)) {
    normalizedFsMap[normalizeFilePath(fsPath)] = fileContent;
  }
  return normalizedFsMap;
}

// lib/runner/CircuitRunner.ts
import "react";

// lib/utils/dirname.ts
function dirname(path) {
  if (!path) return ".";
  const normalizedPath = path.replace(/\\/g, "/");
  const cleanPath = normalizedPath.replace(/\/+$/, "");
  if (cleanPath.indexOf("/") === -1) return ".";
  return cleanPath.substring(0, cleanPath.lastIndexOf("/")) || "/";
}

// lib/runner/resolveFilePath.ts
function resolveRelativePath(importPath, cwd) {
  if (importPath.startsWith("../")) {
    const parentDir = dirname(cwd);
    return resolveRelativePath(importPath.slice(3), parentDir);
  }
  if (importPath.startsWith("./")) {
    return resolveRelativePath(importPath.slice(2), cwd);
  }
  if (importPath.startsWith("/")) {
    return importPath.slice(1);
  }
  return `${cwd}/${importPath}`;
}
var resolveFilePath = (unknownFilePath, fsMapOrAllFilePaths, cwd) => {
  const resolvedPath = cwd ? resolveRelativePath(unknownFilePath, cwd) : unknownFilePath;
  const filePaths = new Set(
    Array.isArray(fsMapOrAllFilePaths) ? fsMapOrAllFilePaths : Object.keys(fsMapOrAllFilePaths)
  );
  if (filePaths.has(resolvedPath)) {
    return resolvedPath;
  }
  const normalizedFilePathMap = /* @__PURE__ */ new Map();
  for (const filePath of filePaths) {
    normalizedFilePathMap.set(normalizeFilePath(filePath), filePath);
  }
  const normalizedResolvedPath = normalizeFilePath(resolvedPath);
  if (normalizedFilePathMap.has(normalizedResolvedPath)) {
    return normalizedFilePathMap.get(normalizedResolvedPath);
  }
  const extension = ["tsx", "ts", "json", "js", "jsx"];
  for (const ext of extension) {
    const possibleFilePath = `${normalizedResolvedPath}.${ext}`;
    if (normalizedFilePathMap.has(possibleFilePath)) {
      return normalizedFilePathMap.get(possibleFilePath);
    }
  }
  if (!unknownFilePath.startsWith("./") && !unknownFilePath.startsWith("../")) {
    const normalizedUnknownFilePath = normalizeFilePath(unknownFilePath);
    if (normalizedFilePathMap.has(normalizedUnknownFilePath)) {
      return normalizedFilePathMap.get(normalizedUnknownFilePath);
    }
    for (const ext of extension) {
      const possibleFilePath = `${normalizedUnknownFilePath}.${ext}`;
      if (normalizedFilePathMap.has(possibleFilePath)) {
        return normalizedFilePathMap.get(possibleFilePath);
      }
    }
  }
  return null;
};
var resolveFilePathOrThrow = (unknownFilePath, fsMapOrAllFilePaths) => {
  const resolvedFilePath = resolveFilePath(unknownFilePath, fsMapOrAllFilePaths);
  if (!resolvedFilePath) {
    throw new Error(
      `File not found "${unknownFilePath}", available paths:

${Object.keys(fsMapOrAllFilePaths).join(", ")}`
    );
  }
  return resolvedFilePath;
};

// webworker/eval-compiled-js.ts
function evalCompiledJs(compiledCode, preSuppliedImports, cwd) {
  ;
  globalThis.__tscircuit_require = (name) => {
    const resolvedFilePath = resolveFilePath(name, preSuppliedImports, cwd);
    const hasResolvedFilePath = resolvedFilePath && preSuppliedImports[resolvedFilePath];
    if (!preSuppliedImports[name] && !hasResolvedFilePath) {
      throw new Error(`Import "${name}" not found ${cwd ? `in "${cwd}"` : ""}`);
    }
    const mod = preSuppliedImports[name] || preSuppliedImports[resolvedFilePath];
    return new Proxy(mod, {
      get(target, prop) {
        if (!(prop in target)) {
          if (prop === "default") {
            if (target.default !== void 0) {
              return target.default;
            }
            if (target.__esModule) {
              return void 0;
            }
            if (typeof target === "function" || typeof target === "object") {
              return target;
            }
            return void 0;
          }
          if (prop === "__esModule") {
            return true;
          }
          throw new Error(
            `Component "${String(prop)}" is not exported by "${name}"`
          );
        }
        return target[prop];
      }
    });
  };
  const functionBody = `
  var exports = {};
  var require = globalThis.__tscircuit_require;
  var module = { exports };
  var circuit = globalThis.__tscircuit_circuit;
  ${compiledCode};
  return module;`.trim();
  return Function(functionBody).call(globalThis);
}

// webworker/import-eval-path.ts
import "@babel/standalone";

// webworker/import-local-file.ts
import * as Babel from "@babel/standalone";

// lib/utils/get-imports-from-code.ts
var getImportsFromCode = (code) => {
  const importRegex = /^\s*import\s+(?:(?:[\w\s]+,\s*)?(?:\*\s+as\s+[\w\s]+|\{[\s\w,]+\}|\w+)\s+from\s+)?['"](.+?)['"]/gm;
  const imports = [];
  let match;
  while ((match = importRegex.exec(code)) !== null) {
    imports.push(match[1]);
  }
  const reExportRegex = /^\s*export\s+(?:\*|(?:\{[\s\w,]+\}))\s+from\s+['"](.+?)['"]/gm;
  let reExportMatch;
  while ((reExportMatch = reExportRegex.exec(code)) !== null) {
    imports.push(reExportMatch[1]);
  }
  return imports;
};

// webworker/import-local-file.ts
import Debug2 from "debug";
var debug2 = Debug2("tsci:eval:import-local-file");
var importLocalFile = async (importName, ctx, depth = 0) => {
  debug2("importLocalFile called with:", {
    importName
  });
  const { fsMap, preSuppliedImports } = ctx;
  const fsPath = resolveFilePathOrThrow(importName, fsMap);
  debug2("fsPath:", fsPath);
  if (!ctx.fsMap[fsPath]) {
    debug2("fsPath not found in fsMap:", fsPath);
    throw new Error(`File "${fsPath}" not found`);
  }
  const fileContent = fsMap[fsPath];
  debug2("fileContent:", fileContent?.slice(0, 100));
  if (fsPath.endsWith(".json")) {
    const jsonData = JSON.parse(fileContent);
    preSuppliedImports[fsPath] = {
      __esModule: true,
      default: jsonData
    };
  } else if (fsPath.endsWith(".tsx") || fsPath.endsWith(".ts")) {
    const importNames = getImportsFromCode(fileContent);
    for (const importName2 of importNames) {
      if (!preSuppliedImports[importName2]) {
        await importEvalPath(importName2, ctx, depth + 1, {
          cwd: dirname(fsPath)
        });
      }
    }
    const result = Babel.transform(fileContent, {
      presets: ["react", "typescript"],
      plugins: ["transform-modules-commonjs"],
      filename: "virtual.tsx"
    });
    if (!result || !result.code) {
      throw new Error("Failed to transform code");
    }
    try {
      debug2("evalCompiledJs called with:", {
        code: result.code?.slice(0, 100),
        dirname: dirname(fsPath)
      });
      const importRunResult = evalCompiledJs(
        result.code,
        preSuppliedImports,
        dirname(fsPath)
      );
      debug2("importRunResult:", {
        fsPath,
        importRunResult
      });
      preSuppliedImports[fsPath] = importRunResult.exports;
    } catch (error) {
      throw new Error(
        `Eval compiled js error for "${importName}": ${error.message}`
      );
    }
  } else if (fsPath.endsWith(".js")) {
    const result = Babel.transform(fileContent, {
      presets: ["env"],
      plugins: ["transform-modules-commonjs"],
      filename: fsPath
    });
    if (!result || !result.code) {
      throw new Error("Failed to transform JS code");
    }
    preSuppliedImports[fsPath] = evalCompiledJs(
      result.code,
      preSuppliedImports,
      dirname(fsPath)
    ).exports;
  } else {
    throw new Error(
      `Unsupported file extension "${fsPath.split(".").pop()}" for "${fsPath}"`
    );
  }
};

// webworker/import-snippet.ts
import "@babel/standalone";
async function importSnippet(importName, ctx, depth = 0) {
  const { preSuppliedImports } = ctx;
  const fullSnippetName = importName.replace("@tsci/", "").replace(".", "/");
  const { cjs, error } = await fetch(`${ctx.cjsRegistryUrl}/${fullSnippetName}`).then(async (res) => ({ cjs: await res.text(), error: null })).catch((e) => ({ error: e, cjs: null }));
  if (error) {
    console.error("Error fetching import", importName, error);
    return;
  }
  try {
    preSuppliedImports[importName] = evalCompiledJs(
      cjs,
      preSuppliedImports
    ).exports;
  } catch (e) {
    console.error("Error importing snippet", e);
  }
}

// lib/utils/resolve-node-module.ts
function createContext(modulePath, fsMap, basePath) {
  return {
    fsMap,
    extensions: [".js", ".jsx", ".ts", ".tsx", ".json"],
    basePath,
    modulePath
  };
}
function findPackageJson(nodeModulesPath, ctx) {
  const packageJsonPath = `${nodeModulesPath}/package.json`;
  if (!ctx.fsMap[packageJsonPath]) return null;
  try {
    return JSON.parse(ctx.fsMap[packageJsonPath]);
  } catch {
    return null;
  }
}
function tryResolveWithExtensions(path, ctx) {
  if (ctx.fsMap[path]) return path;
  for (const ext of ctx.extensions) {
    const pathWithExt = path.replace(/\.js$|\.jsx$/, "") + ext;
    if (ctx.fsMap[pathWithExt]) return pathWithExt;
  }
  return null;
}
function resolveExportPath(nodeModulesPath, exportPath, ctx) {
  const fullExportPath = `${nodeModulesPath}/${exportPath.replace(/^\.\//, "")}`;
  return tryResolveWithExtensions(fullExportPath, ctx);
}
function resolvePackageExports(nodeModulesPath, packageJson, remainingPath, ctx) {
  if (!packageJson.exports) return null;
  const defaultExport = packageJson.exports["."];
  if (remainingPath === "" && defaultExport) {
    if (typeof defaultExport === "string") {
      const resolved = resolveExportPath(nodeModulesPath, defaultExport, ctx);
      if (resolved) return resolved;
    }
  }
  const subpathExport = remainingPath ? packageJson.exports[`./${remainingPath}`] : null;
  if (subpathExport && typeof subpathExport === "string") {
    const resolved = resolveExportPath(nodeModulesPath, subpathExport, ctx);
    if (resolved) return resolved;
  }
  const importExport = packageJson.exports["import"];
  if (remainingPath === "" && importExport && typeof importExport === "string") {
    const resolved = resolveExportPath(nodeModulesPath, importExport, ctx);
    if (resolved) return resolved;
  }
  return null;
}
function resolvePackageEntryPoint(nodeModulesPath, packageJson, ctx) {
  const entryPoint = packageJson.module || packageJson.main || "index.js";
  const fullPath = `${nodeModulesPath}/${entryPoint}`;
  return tryResolveWithExtensions(fullPath, ctx);
}
function resolveRemainingPath(nodeModulesPath, remainingPath, ctx) {
  if (!remainingPath) {
    for (const ext of ctx.extensions) {
      const indexPath = `${nodeModulesPath}/index${ext}`;
      if (ctx.fsMap[indexPath]) return indexPath;
    }
    return null;
  }
  const fullPath = `${nodeModulesPath}/${remainingPath}`;
  const directMatch = tryResolveWithExtensions(fullPath, ctx);
  if (directMatch) return directMatch;
  for (const ext of ctx.extensions) {
    const indexPath = `${fullPath}/index${ext}`;
    if (ctx.fsMap[indexPath]) return indexPath;
  }
  return null;
}
function resolveNodeModuleInPath(searchPath, ctx) {
  const moduleParts = ctx.modulePath.split("/");
  const scope = moduleParts[0].startsWith("@") ? moduleParts.slice(0, 2).join("/") : moduleParts[0];
  const remainingPath = moduleParts.slice(scope.includes("/") ? 2 : 1).join("/");
  const nodeModulesPath = `${searchPath == "." ? "" : `${searchPath}/`}node_modules/${scope}`;
  const packageJson = findPackageJson(nodeModulesPath, ctx);
  if (packageJson) {
    const exportsResolution = resolvePackageExports(
      nodeModulesPath,
      packageJson,
      remainingPath,
      ctx
    );
    if (exportsResolution) return exportsResolution;
    const entryPointResolution = resolvePackageEntryPoint(
      nodeModulesPath,
      packageJson,
      ctx
    );
    if (entryPointResolution) return entryPointResolution;
  }
  const remainingPathResolution = resolveRemainingPath(
    nodeModulesPath,
    remainingPath,
    ctx
  );
  if (remainingPathResolution) return remainingPathResolution;
  const parentPath = dirname(searchPath);
  if (parentPath && parentPath !== searchPath) {
    return resolveNodeModuleInPath(parentPath, ctx);
  }
  return null;
}
function resolveNodeModule(modulePath, fsMap, basePath) {
  const ctx = createContext(modulePath, fsMap, basePath);
  return resolveNodeModuleInPath(ctx.basePath, ctx);
}

// webworker/import-node-module.ts
var importNodeModule = async (importName, ctx, depth = 0) => {
  const { preSuppliedImports } = ctx;
  if (preSuppliedImports[importName]) {
    return;
  }
  const resolvedNodeModulePath = resolveNodeModule(importName, ctx.fsMap, "");
  if (!resolvedNodeModulePath) {
    throw new Error(`Node module "${importName}" not found`);
  }
  await importLocalFile(resolvedNodeModulePath, ctx, depth);
  preSuppliedImports[importName] = preSuppliedImports[resolvedNodeModulePath];
  const unprefixedPath = resolvedNodeModulePath.replace(/^node_modules\//, "");
  preSuppliedImports[unprefixedPath] = preSuppliedImports[resolvedNodeModulePath];
  if (resolvedNodeModulePath.endsWith("/index.tsx") || resolvedNodeModulePath.endsWith("/index.ts") || resolvedNodeModulePath.endsWith("/index.js")) {
    const dirPath = resolvedNodeModulePath.replace(/\/index\.(tsx?|js)$/, "");
    const unprefixedDirPath = dirPath.replace(/^node_modules\//, "");
    preSuppliedImports[unprefixedDirPath] = preSuppliedImports[resolvedNodeModulePath];
    if (unprefixedDirPath.startsWith("@")) {
      const scopeParts = unprefixedDirPath.split("/");
      if (scopeParts.length >= 2) {
        const scopedName = `${scopeParts[0]}/${scopeParts[1]}`;
        preSuppliedImports[scopedName] = preSuppliedImports[resolvedNodeModulePath];
      }
    }
  }
};

// webworker/import-eval-path.ts
import Debug3 from "debug";
var debug3 = Debug3("tsci:eval:import-eval-path");
async function importEvalPath(importName, ctx, depth = 0, opts = {}) {
  debug3("importEvalPath called with:", {
    importName,
    depth,
    opts
  });
  debug3(`${"  ".repeat(depth)}\u27A1\uFE0F`, importName);
  const { preSuppliedImports } = ctx;
  if (preSuppliedImports[importName]) return;
  if (importName.startsWith("./") && preSuppliedImports[importName.slice(2)])
    return;
  if (depth > 5) {
    console.log("Max depth for imports reached");
    return;
  }
  const resolvedLocalImportPath = resolveFilePath(
    importName,
    ctx.fsMap,
    opts.cwd
  );
  if (resolvedLocalImportPath) {
    return importLocalFile(resolvedLocalImportPath, ctx, depth);
  }
  const resolvedNodeModulePath = resolveNodeModule(
    importName,
    ctx.fsMap,
    opts.cwd || ""
  );
  if (resolvedNodeModulePath) {
    return importNodeModule(importName, ctx, depth);
  }
  if (importName.startsWith("@tsci/")) {
    return importSnippet(importName, ctx, depth);
  }
  throw new Error(
    `Unresolved import "${importName}" ${opts.cwd ? `from directory "${opts.cwd}"` : ""}`
  );
}

// lib/runner/setupDefaultEntrypointIfNeeded.ts
import Debug4 from "debug";
var debug4 = Debug4("tsci:eval:setupDefaultEntrypointIfNeeded");
var setupDefaultEntrypointIfNeeded = (opts) => {
  if (!opts.entrypoint && !opts.mainComponentPath) {
    if ("index.tsx" in opts.fsMap) {
      opts.mainComponentPath = "index.tsx";
    } else if ("index.ts" in opts.fsMap) {
      opts.mainComponentPath = "index.ts";
    } else if (Object.keys(opts.fsMap).filter((k) => k.endsWith(".tsx")).length === 1) {
      opts.mainComponentPath = Object.keys(opts.fsMap)[0];
    } else if ("tscircuit.config.json" in opts.fsMap) {
      const configContent = opts.fsMap["tscircuit.config.json"];
      try {
        const config = JSON.parse(configContent);
        if (config.mainEntrypoint) {
          opts.entrypoint = config.mainEntrypoint;
        }
      } catch (e) {
        console.warn("Failed to parse tscircuit.config.json:", e);
      }
    } else {
      throw new Error(
        "Either entrypoint or mainComponentPath must be provided (no index file, could not infer entrypoint)"
      );
    }
  }
  if (!opts.entrypoint && opts.mainComponentPath) {
    opts.entrypoint = "entrypoint.tsx";
    const mainComponentCode = opts.fsMap[resolveFilePathOrThrow(opts.mainComponentPath, opts.fsMap)];
    if (!mainComponentCode) {
      throw new Error(
        `Main component path "${opts.mainComponentPath}" not found in fsMap. Available paths: ${Object.keys(opts.fsMap).join(", ")}`
      );
    }
    const hasExplicitBoard = mainComponentCode.includes("<board");
    const hasTsciImport = mainComponentCode.includes("@tsci/") || mainComponentCode.includes('from "@tsci');
    const shouldWrapInBoard = !hasExplicitBoard && !hasTsciImport;
    opts.fsMap[opts.entrypoint] = `
     import * as UserComponents from "./${opts.mainComponentPath}";
          
      ${opts.mainComponentName ? `
        const ComponentToRender = UserComponents["${opts.mainComponentName}"]
        ` : `const ComponentToRender = Object.entries(UserComponents)
        .filter(([name]) => !name.startsWith("use"))
        .map(([_, component]) => component)[0] || (() => null);`}

           ${debug4.enabled ? `
     console.log({ UserComponents })
     console.log("ComponentToRender " + ComponentToRender.toString(),  { ComponentToRender })
     ` : ""}

      circuit.add(
        ${shouldWrapInBoard ? `
          <board>
            <ComponentToRender name="U1" ${opts.mainComponentProps ? `{...${JSON.stringify(opts.mainComponentProps, null, 2)}}` : ""} />
          </board>
        ` : `
          <ComponentToRender ${opts.mainComponentProps ? `{...${JSON.stringify(opts.mainComponentProps, null, 2)}}` : ""} />
        `}
      );
`;
  }
  if (!opts.name && opts.mainComponentName) {
    opts.name = opts.mainComponentName;
  }
};

// lib/runner/CircuitRunner.ts
import Debug5 from "debug";
var debug5 = Debug5("tsci:eval:CircuitRunner");
var CircuitRunner = class {
  constructor(configuration = {}) {
    this._executionContext = null;
    this._circuitRunnerConfiguration = {
      snippetsApiBaseUrl: "https://registry-api.tscircuit.com",
      cjsRegistryUrl: "https://cjs.tscircuit.com",
      verbose: false
    };
    this._eventListeners = {};
    Object.assign(this._circuitRunnerConfiguration, configuration);
  }
  async version() {
    return "0.0.0";
  }
  async executeWithFsMap(ogOpts) {
    const opts = { ...ogOpts };
    if (this._circuitRunnerConfiguration.verbose) {
      Debug5.enable("tsci:eval:*");
    }
    debug5("executeWithFsMap called with:", {
      entrypoint: opts.entrypoint,
      fsMapKeys: Object.keys(opts.fsMap),
      name: opts.name
    });
    setupDefaultEntrypointIfNeeded(opts);
    debug5("entrypoint after setupDefaultEntrypointIfNeeded:", {
      entrypoint: opts.entrypoint
    });
    this._executionContext = createExecutionContext(
      this._circuitRunnerConfiguration,
      {
        name: opts.name,
        platform: this._circuitRunnerConfiguration.platform
      }
    );
    this._bindEventListeners(this._executionContext.circuit);
    this._executionContext.fsMap = normalizeFsMap(opts.fsMap);
    if (!this._executionContext.fsMap[opts.entrypoint]) {
      throw new Error(`Entrypoint "${opts.entrypoint}" not found`);
    }
    ;
    globalThis.__tscircuit_circuit = this._executionContext.circuit;
    const entrypoint = opts.entrypoint.startsWith("./") ? opts.entrypoint : `./${opts.entrypoint}`;
    debug5("final entrypoint:", entrypoint);
    await importEvalPath(entrypoint, this._executionContext);
  }
  async execute(code, opts = {}) {
    if (this._circuitRunnerConfiguration.verbose) {
      console.log(
        "[CircuitRunner] execute called with code length:",
        code.length
      );
    }
    this._executionContext = createExecutionContext(
      this._circuitRunnerConfiguration,
      {
        ...opts,
        platform: this._circuitRunnerConfiguration.platform
      }
    );
    this._bindEventListeners(this._executionContext.circuit);
    this._executionContext.fsMap["entrypoint.tsx"] = code;
    globalThis.__tscircuit_circuit = this._executionContext.circuit;
    await importEvalPath("./entrypoint.tsx", this._executionContext);
  }
  on(event, callback) {
    var _a;
    (_a = this._eventListeners)[event] ?? (_a[event] = []);
    this._eventListeners[event].push(callback);
    this._executionContext?.circuit.on(event, callback);
  }
  async renderUntilSettled() {
    if (!this._executionContext) {
      throw new Error("No circuit has been created");
    }
    await this._executionContext.circuit.renderUntilSettled();
  }
  async getCircuitJson() {
    if (!this._executionContext) {
      throw new Error("No circuit has been created");
    }
    return this._executionContext.circuit.getCircuitJson();
  }
  clearEventListeners() {
    if (this._executionContext?.circuit) {
      for (const event in this._eventListeners) {
        for (const listener of this._eventListeners[event]) {
          const circuit = this._executionContext.circuit;
          circuit.removeListener?.(event, listener);
        }
      }
    }
    for (const event in this._eventListeners) {
      delete this._eventListeners[event];
    }
  }
  async kill() {
    this._executionContext = null;
  }
  async setSnippetsApiBaseUrl(baseUrl) {
    this._circuitRunnerConfiguration.snippetsApiBaseUrl = baseUrl;
  }
  async setPlatformConfig(platform) {
    this._circuitRunnerConfiguration.platform = platform;
  }
  _bindEventListeners(circuit) {
    for (const event in this._eventListeners) {
      for (const listener of this._eventListeners[event]) {
        circuit.on(event, listener);
      }
    }
  }
};

// lib/runner/runTscircuitCode.ts
async function runTscircuitCode(filesystemOrCodeString, opts) {
  if (typeof filesystemOrCodeString === "string" && !filesystemOrCodeString.includes("export")) {
    throw new Error(
      `The "export" keyword wasn't found in your provided code. You need to export a component in your code, e.g.

export default () => (
  <resistor name="R1" resistance="1k" />
)`
    );
  }
  const filesystem = typeof filesystemOrCodeString === "string" ? { "user-code.tsx": filesystemOrCodeString } : filesystemOrCodeString;
  const circuitRunner = new CircuitRunner();
  await circuitRunner.executeWithFsMap({
    fsMap: filesystem,
    ...opts
  });
  await circuitRunner.renderUntilSettled();
  return await circuitRunner.getCircuitJson();
}

// lib/runner/runTscircuitModule.ts
var runTscircuitModule = async (module, opts = {}) => {
  if (!module.startsWith("@")) {
    module = `@tsci/${module.replace(/\//, ".")}`;
  }
  const circuitJson = await runTscircuitCode(
    {
      // TODO handle exports that are not the default export by scanning
      // otherExports for components
      "user-code.tsx": `
    import Module, * as otherExports from "${module}";

    let exportName = "${opts.exportName ?? ""}"

    if ((!Module || typeof Module !== "function") && !Boolean(exportName)) {
      exportName = Object.keys(otherExports).filter(key => key[0] === key[0].toUpperCase() && typeof otherExports[key] === "function")[0]
    }

    const defaultExport = exportName ? otherExports[exportName] : Module

    if (!defaultExport) {
      throw new Error(\`No export found for module "\${module}" (tried "\${exportName ?? "default"}")\`)
    }

    export default defaultExport;
    `
    },
    {
      mainComponentProps: opts.props
    }
  );
  return circuitJson;
};

// lib/worker.ts
import * as Comlink from "comlink";
var createCircuitWebWorker = async (configuration) => {
  const existingWorker = globalThis.TSCIRCUIT_GLOBAL_CIRCUIT_WORKER;
  if (existingWorker && typeof existingWorker.kill === "function") {
    if (configuration.verbose) {
      console.log("[Worker] Killing previous global worker instance...");
    }
    try {
      await existingWorker.kill();
    } catch (e) {
      if (configuration.verbose) {
        console.warn(
          "[Worker] Error killing previous global worker instance:",
          e
        );
      }
      if (globalThis.TSCIRCUIT_GLOBAL_CIRCUIT_WORKER === existingWorker) {
        globalThis.TSCIRCUIT_GLOBAL_CIRCUIT_WORKER = void 0;
      }
    }
  }
  if (configuration.verbose) {
    console.log(
      "[Worker] Creating circuit web worker with config:",
      configuration
    );
  }
  let workerBlobUrl = configuration.webWorkerBlobUrl ?? configuration.webWorkerUrl;
  if (!workerBlobUrl) {
    const cdnUrl = `https://cdn.jsdelivr.net/npm/@tscircuit/eval@${configuration.evalVersion ?? "latest"}/dist/webworker/entrypoint.js`;
    const workerBlob = await fetch(cdnUrl).then((res) => res.blob());
    workerBlobUrl = URL.createObjectURL(workerBlob);
  }
  const rawWorker = new Worker(workerBlobUrl, { type: "module" });
  let workerInitError;
  rawWorker.addEventListener("error", (event) => {
    console.error("[Worker] Error in worker", event);
    workerInitError = event;
  });
  rawWorker.addEventListener("unhandledrejection", (event) => {
    console.error("[Worker] Unhandled rejection in worker", event);
  });
  rawWorker.addEventListener("messageerror", (event) => {
    console.error("[Worker] Message error in worker", event);
  });
  const earlyMessageHandler = (event) => {
    console.log("[Worker] Message in worker", event);
  };
  rawWorker.addEventListener("message", earlyMessageHandler);
  if (workerInitError) {
    throw workerInitError;
  }
  const comlinkWorker = Comlink.wrap(rawWorker);
  rawWorker.removeEventListener("message", earlyMessageHandler);
  if (configuration.snippetsApiBaseUrl) {
    await comlinkWorker.setSnippetsApiBaseUrl(configuration.snippetsApiBaseUrl);
  }
  if (configuration.platform) {
    await comlinkWorker.setPlatformConfig(configuration.platform);
  }
  let isTerminated = false;
  const wrapper = {
    clearEventListeners: comlinkWorker.clearEventListeners.bind(comlinkWorker),
    version: comlinkWorker.version.bind(comlinkWorker),
    execute: async (...args) => {
      if (isTerminated) {
        throw new Error("CircuitWebWorker was terminated, can't execute");
      }
      return comlinkWorker.execute.bind(comlinkWorker)(...args);
    },
    executeWithFsMap: async (...args) => {
      if (isTerminated) {
        throw new Error(
          "CircuitWebWorker was terminated, can't executeWithFsMap"
        );
      }
      return comlinkWorker.executeWithFsMap.bind(comlinkWorker)(...args);
    },
    renderUntilSettled: comlinkWorker.renderUntilSettled.bind(comlinkWorker),
    getCircuitJson: comlinkWorker.getCircuitJson.bind(comlinkWorker),
    on: (event, callback) => {
      const proxiedCallback = Comlink.proxy(callback);
      comlinkWorker.on(event, proxiedCallback);
    },
    kill: async () => {
      comlinkWorker[Comlink.releaseProxy]();
      rawWorker.terminate();
      isTerminated = true;
      if (globalThis.TSCIRCUIT_GLOBAL_CIRCUIT_WORKER === wrapper) {
        globalThis.TSCIRCUIT_GLOBAL_CIRCUIT_WORKER = void 0;
      }
    }
  };
  globalThis.TSCIRCUIT_GLOBAL_CIRCUIT_WORKER = wrapper;
  return wrapper;
};

// lib/getPossibleEntrypointComponentPaths.ts
var getPossibleEntrypointComponentPaths = (fsMap) => {
  const normalizedFsMap = {};
  for (const [path, content] of Object.entries(fsMap)) {
    normalizedFsMap[normalizeFilePath(path)] = content;
  }
  const possible = /* @__PURE__ */ new Set();
  if ("tscircuit.config.json" in normalizedFsMap) {
    try {
      const config = JSON.parse(normalizedFsMap["tscircuit.config.json"]);
      if (typeof config.mainEntrypoint === "string") {
        possible.add(normalizeFilePath(config.mainEntrypoint));
      }
    } catch {
    }
  }
  if (normalizedFsMap["index.tsx"]) possible.add("index.tsx");
  if (normalizedFsMap["index.ts"]) possible.add("index.ts");
  const circuitFiles = Object.keys(normalizedFsMap).filter(
    (k) => k.endsWith(".circuit.tsx")
  );
  for (const file of circuitFiles) {
    possible.add(file);
  }
  const tsxFiles = Object.keys(normalizedFsMap).filter(
    (k) => k.endsWith(".tsx")
  );
  if (tsxFiles.length === 1) {
    possible.add(tsxFiles[0]);
  }
  return Array.from(possible);
};
export {
  CircuitRunner,
  createCircuitWebWorker,
  getImportsFromCode,
  getPossibleEntrypointComponentPaths,
  runTscircuitCode,
  runTscircuitModule
};
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsiLi4vLi4vd2Vid29ya2VyL2V4ZWN1dGlvbi1jb250ZXh0LnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AdHNjaXJjdWl0L3BhcnRzLWVuZ2luZS9saWIvamxjLXBhcnRzLWVuZ2luZS50cyIsICIuLi8uLi9saWIvZ2V0UGxhdGZvcm1Db25maWcudHMiLCAiLi4vLi4vbGliL3J1bm5lci9ub3JtYWxpemVGc01hcC50cyIsICIuLi8uLi9saWIvcnVubmVyL0NpcmN1aXRSdW5uZXIudHMiLCAiLi4vLi4vbGliL3V0aWxzL2Rpcm5hbWUudHMiLCAiLi4vLi4vbGliL3J1bm5lci9yZXNvbHZlRmlsZVBhdGgudHMiLCAiLi4vLi4vd2Vid29ya2VyL2V2YWwtY29tcGlsZWQtanMudHMiLCAiLi4vLi4vd2Vid29ya2VyL2ltcG9ydC1ldmFsLXBhdGgudHMiLCAiLi4vLi4vd2Vid29ya2VyL2ltcG9ydC1sb2NhbC1maWxlLnRzIiwgIi4uLy4uL2xpYi91dGlscy9nZXQtaW1wb3J0cy1mcm9tLWNvZGUudHMiLCAiLi4vLi4vd2Vid29ya2VyL2ltcG9ydC1zbmlwcGV0LnRzIiwgIi4uLy4uL2xpYi91dGlscy9yZXNvbHZlLW5vZGUtbW9kdWxlLnRzIiwgIi4uLy4uL3dlYndvcmtlci9pbXBvcnQtbm9kZS1tb2R1bGUudHMiLCAiLi4vLi4vbGliL3J1bm5lci9zZXR1cERlZmF1bHRFbnRyeXBvaW50SWZOZWVkZWQudHMiLCAiLi4vLi4vbGliL3J1bm5lci9ydW5Uc2NpcmN1aXRDb2RlLnRzIiwgIi4uLy4uL2xpYi9ydW5uZXIvcnVuVHNjaXJjdWl0TW9kdWxlLnRzIiwgIi4uLy4uL2xpYi93b3JrZXIudHMiLCAiLi4vLi4vbGliL2dldFBvc3NpYmxlRW50cnlwb2ludENvbXBvbmVudFBhdGhzLnRzIl0sCiAgInNvdXJjZXNDb250ZW50IjogWyJpbXBvcnQgeyBSb290Q2lyY3VpdCB9IGZyb20gXCJAdHNjaXJjdWl0L2NvcmVcIlxuaW1wb3J0IHR5cGUgeyBXZWJXb3JrZXJDb25maWd1cmF0aW9uIH0gZnJvbSBcImxpYi9zaGFyZWQvdHlwZXNcIlxuaW1wb3J0ICogYXMgdHNjaXJjdWl0Q29yZSBmcm9tIFwiQHRzY2lyY3VpdC9jb3JlXCJcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gXCJyZWFjdFwiXG5pbXBvcnQgKiBhcyBqc2NhZEZpYmVyIGZyb20gXCJqc2NhZC1maWJlclwiXG5pbXBvcnQgKiBhcyB0c2NpcmN1aXRNYXRoVXRpbHMgZnJvbSBcIkB0c2NpcmN1aXQvbWF0aC11dGlsc1wiXG5pbXBvcnQgdHlwZSB7IFBsYXRmb3JtQ29uZmlnIH0gZnJvbSBcIkB0c2NpcmN1aXQvcHJvcHNcIlxuaW1wb3J0IHsgZ2V0UGxhdGZvcm1Db25maWcgfSBmcm9tIFwibGliL2dldFBsYXRmb3JtQ29uZmlnXCJcbmltcG9ydCBEZWJ1ZyBmcm9tIFwiZGVidWdcIlxuXG5jb25zdCBkZWJ1ZyA9IERlYnVnKFwidHNjaTpldmFsOmV4ZWN1dGlvbi1jb250ZXh0XCIpXG5cbmV4cG9ydCBpbnRlcmZhY2UgRXhlY3V0aW9uQ29udGV4dCBleHRlbmRzIFdlYldvcmtlckNvbmZpZ3VyYXRpb24ge1xuICBmc01hcDogUmVjb3JkPHN0cmluZywgc3RyaW5nPlxuICBlbnRyeXBvaW50OiBzdHJpbmdcbiAgcHJlU3VwcGxpZWRJbXBvcnRzOiBSZWNvcmQ8c3RyaW5nLCBhbnk+XG4gIGNpcmN1aXQ6IFJvb3RDaXJjdWl0XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVFeGVjdXRpb25Db250ZXh0KFxuICB3ZWJXb3JrZXJDb25maWd1cmF0aW9uOiBXZWJXb3JrZXJDb25maWd1cmF0aW9uLFxuICBvcHRzOiB7XG4gICAgbmFtZT86IHN0cmluZ1xuICAgIHBsYXRmb3JtPzogUGxhdGZvcm1Db25maWdcbiAgfSA9IHt9LFxuKTogRXhlY3V0aW9uQ29udGV4dCB7XG4gIGdsb2JhbFRoaXMuUmVhY3QgPSBSZWFjdFxuXG4gIGNvbnN0IGNpcmN1aXQgPSBuZXcgUm9vdENpcmN1aXQoe1xuICAgIHBsYXRmb3JtOiBvcHRzLnBsYXRmb3JtIHx8IGdldFBsYXRmb3JtQ29uZmlnKCksXG4gIH0pXG5cbiAgaWYgKG9wdHMubmFtZSkge1xuICAgIGNpcmN1aXQubmFtZSA9IG9wdHMubmFtZVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBmc01hcDoge30sXG4gICAgZW50cnlwb2ludDogXCJcIixcbiAgICBwcmVTdXBwbGllZEltcG9ydHM6IHtcbiAgICAgIFwiQHRzY2lyY3VpdC9jb3JlXCI6IHRzY2lyY3VpdENvcmUsXG4gICAgICB0c2NpcmN1aXQ6IHRzY2lyY3VpdENvcmUsXG4gICAgICBcIkB0c2NpcmN1aXQvbWF0aC11dGlsc1wiOiB0c2NpcmN1aXRNYXRoVXRpbHMsXG4gICAgICByZWFjdDogUmVhY3QsXG4gICAgICBcImpzY2FkLWZpYmVyXCI6IGpzY2FkRmliZXIsXG5cbiAgICAgIC8vIFRoaXMgaXMgdXN1YWxseSB1c2VkIGFzIGEgdHlwZSBpbXBvcnQsIHdlIGNhbiByZW1vdmUgdGhlIHNoaW0gd2hlbiB3ZVxuICAgICAgLy8gaWdub3JlIHR5cGUgaW1wb3J0cyBpbiBnZXRJbXBvcnRzRnJvbUNvZGVcbiAgICAgIFwiQHRzY2lyY3VpdC9wcm9wc1wiOiB7fSxcbiAgICB9LFxuICAgIGNpcmN1aXQsXG4gICAgLi4ud2ViV29ya2VyQ29uZmlndXJhdGlvbixcbiAgfVxufVxuIiwgImltcG9ydCB0eXBlIHsgUGFydHNFbmdpbmUsIFN1cHBsaWVyUGFydE51bWJlcnMgfSBmcm9tIFwiQHRzY2lyY3VpdC9wcm9wc1wiXG5cbmNvbnN0IGNhY2hlID0gbmV3IE1hcDxzdHJpbmcsIGFueT4oKVxuXG5jb25zdCBnZXRKbGNQYXJ0c0NhY2hlZCA9IGFzeW5jIChuYW1lOiBhbnksIHBhcmFtczogYW55KSA9PiB7XG4gIGNvbnN0IHBhcmFtU3RyaW5nID0gbmV3IFVSTFNlYXJjaFBhcmFtcyh7XG4gICAgLi4ucGFyYW1zLFxuICAgIGpzb246IFwidHJ1ZVwiLFxuICB9KS50b1N0cmluZygpXG4gIGlmIChjYWNoZS5oYXMocGFyYW1TdHJpbmcpKSB7XG4gICAgcmV0dXJuIGNhY2hlLmdldChwYXJhbVN0cmluZylcbiAgfVxuICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKFxuICAgIGBodHRwczovL2psY3NlYXJjaC50c2NpcmN1aXQuY29tLyR7bmFtZX0vbGlzdD8ke3BhcmFtU3RyaW5nfWAsXG4gIClcbiAgY29uc3QgcmVzcG9uc2VKc29uID0gYXdhaXQgcmVzcG9uc2UuanNvbigpXG4gIGNhY2hlLnNldChwYXJhbVN0cmluZywgcmVzcG9uc2VKc29uKVxuICByZXR1cm4gcmVzcG9uc2VKc29uXG59XG5cbmV4cG9ydCBjb25zdCBqbGNQYXJ0c0VuZ2luZTogUGFydHNFbmdpbmUgPSB7XG4gIGZpbmRQYXJ0OiBhc3luYyAoe1xuICAgIHNvdXJjZUNvbXBvbmVudCxcbiAgICBmb290cHJpbnRlclN0cmluZyxcbiAgfSk6IFByb21pc2U8U3VwcGxpZXJQYXJ0TnVtYmVycz4gPT4ge1xuICAgIGlmIChcbiAgICAgIHNvdXJjZUNvbXBvbmVudC50eXBlID09PSBcInNvdXJjZV9jb21wb25lbnRcIiAmJlxuICAgICAgc291cmNlQ29tcG9uZW50LmZ0eXBlID09PSBcInNpbXBsZV9yZXNpc3RvclwiXG4gICAgKSB7XG4gICAgICBjb25zdCB7IHJlc2lzdG9ycyB9ID0gYXdhaXQgZ2V0SmxjUGFydHNDYWNoZWQoXCJyZXNpc3RvcnNcIiwge1xuICAgICAgICByZXNpc3RhbmNlOlxuICAgICAgICAgIHNvdXJjZUNvbXBvbmVudC5kaXNwbGF5X3Jlc2lzdGFuY2UgPz8gc291cmNlQ29tcG9uZW50LnJlc2lzdGFuY2UsXG4gICAgICAgIHBhY2thZ2U6IGZvb3RwcmludGVyU3RyaW5nLFxuICAgICAgfSlcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgamxjcGNiOiAocmVzaXN0b3JzID8/IFtdKS5tYXAoKHI6IGFueSkgPT4gYEMke3IubGNzY31gKS5zbGljZSgwLCAzKSxcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKFxuICAgICAgc291cmNlQ29tcG9uZW50LnR5cGUgPT09IFwic291cmNlX2NvbXBvbmVudFwiICYmXG4gICAgICBzb3VyY2VDb21wb25lbnQuZnR5cGUgPT09IFwic2ltcGxlX2NhcGFjaXRvclwiXG4gICAgKSB7XG4gICAgICBpZiAoZm9vdHByaW50ZXJTdHJpbmc/LmluY2x1ZGVzKFwiY2FwXCIpKSB7XG4gICAgICAgIGZvb3RwcmludGVyU3RyaW5nID0gZm9vdHByaW50ZXJTdHJpbmcucmVwbGFjZShcImNhcFwiLCBcIlwiKVxuICAgICAgfVxuICAgICAgY29uc3QgeyBjYXBhY2l0b3JzIH0gPSBhd2FpdCBnZXRKbGNQYXJ0c0NhY2hlZChcImNhcGFjaXRvcnNcIiwge1xuICAgICAgICBjYXBhY2l0YW5jZTpcbiAgICAgICAgICBzb3VyY2VDb21wb25lbnQuZGlzcGxheV9jYXBhY2l0YW5jZSA/PyBzb3VyY2VDb21wb25lbnQuY2FwYWNpdGFuY2UsXG4gICAgICAgIHBhY2thZ2U6IGZvb3RwcmludGVyU3RyaW5nLFxuICAgICAgfSlcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgamxjcGNiOiAoY2FwYWNpdG9ycyA/PyBbXSkubWFwKChjOiBhbnkpID0+IGBDJHtjLmxjc2N9YCkuc2xpY2UoMCwgMyksXG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChcbiAgICAgIHNvdXJjZUNvbXBvbmVudC50eXBlID09PSBcInNvdXJjZV9jb21wb25lbnRcIiAmJlxuICAgICAgc291cmNlQ29tcG9uZW50LmZ0eXBlID09PSBcInNpbXBsZV9waW5faGVhZGVyXCJcbiAgICApIHtcbiAgICAgIGxldCBwaXRjaDogbnVtYmVyIHwgdW5kZWZpbmVkXG4gICAgICBpZiAoZm9vdHByaW50ZXJTdHJpbmc/LmluY2x1ZGVzKFwiX3BcIikpIHtcbiAgICAgICAgcGl0Y2ggPSBOdW1iZXIoZm9vdHByaW50ZXJTdHJpbmcuc3BsaXQoXCJfcFwiKVsxXSlcbiAgICAgIH1cbiAgICAgIGNvbnN0IHsgaGVhZGVycyB9ID0gYXdhaXQgZ2V0SmxjUGFydHNDYWNoZWQoXG4gICAgICAgIFwiaGVhZGVyc1wiLFxuICAgICAgICBwaXRjaFxuICAgICAgICAgID8ge1xuICAgICAgICAgICAgICBwaXRjaDogcGl0Y2gsXG4gICAgICAgICAgICAgIG51bV9waW5zOiBzb3VyY2VDb21wb25lbnQucGluX2NvdW50LFxuICAgICAgICAgICAgICBnZW5kZXI6IHNvdXJjZUNvbXBvbmVudC5nZW5kZXIsXG4gICAgICAgICAgICB9XG4gICAgICAgICAgOiB7XG4gICAgICAgICAgICAgIG51bV9waW5zOiBzb3VyY2VDb21wb25lbnQucGluX2NvdW50LFxuICAgICAgICAgICAgICBnZW5kZXI6IHNvdXJjZUNvbXBvbmVudC5nZW5kZXIsXG4gICAgICAgICAgICB9LFxuICAgICAgKVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgamxjcGNiOiAoaGVhZGVycyA/PyBbXSkubWFwKChoOiBhbnkpID0+IGBDJHtoLmxjc2N9YCkuc2xpY2UoMCwgMyksXG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChcbiAgICAgIHNvdXJjZUNvbXBvbmVudC50eXBlID09PSBcInNvdXJjZV9jb21wb25lbnRcIiAmJlxuICAgICAgc291cmNlQ29tcG9uZW50LmZ0eXBlID09PSBcInNpbXBsZV9wb3RlbnRpb21ldGVyXCJcbiAgICApIHtcbiAgICAgIGNvbnN0IHsgcG90ZW50aW9tZXRlcnMgfSA9IGF3YWl0IGdldEpsY1BhcnRzQ2FjaGVkKFwicG90ZW50aW9tZXRlcnNcIiwge1xuICAgICAgICByZXNpc3RhbmNlOiBzb3VyY2VDb21wb25lbnQubWF4X3Jlc2lzdGFuY2UsXG4gICAgICAgIHBhY2thZ2U6IGZvb3RwcmludGVyU3RyaW5nLFxuICAgICAgfSlcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGpsY3BjYjogKHBvdGVudGlvbWV0ZXJzID8/IFtdKVxuICAgICAgICAgIC5tYXAoKHA6IGFueSkgPT4gYEMke3AubGNzY31gKVxuICAgICAgICAgIC5zbGljZSgwLCAzKSxcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKFxuICAgICAgc291cmNlQ29tcG9uZW50LnR5cGUgPT09IFwic291cmNlX2NvbXBvbmVudFwiICYmXG4gICAgICBzb3VyY2VDb21wb25lbnQuZnR5cGUgPT09IFwic2ltcGxlX2Rpb2RlXCJcbiAgICApIHtcbiAgICAgIGNvbnN0IHsgZGlvZGVzIH0gPSBhd2FpdCBnZXRKbGNQYXJ0c0NhY2hlZChcImRpb2Rlc1wiLCB7XG4gICAgICAgIHBhY2thZ2U6IGZvb3RwcmludGVyU3RyaW5nLFxuICAgICAgfSlcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGpsY3BjYjogKGRpb2RlcyA/PyBbXSkubWFwKChkOiBhbnkpID0+IGBDJHtkLmxjc2N9YCkuc2xpY2UoMCwgMyksXG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChcbiAgICAgIHNvdXJjZUNvbXBvbmVudC50eXBlID09PSBcInNvdXJjZV9jb21wb25lbnRcIiAmJlxuICAgICAgc291cmNlQ29tcG9uZW50LmZ0eXBlID09PSBcInNpbXBsZV9jaGlwXCJcbiAgICApIHtcbiAgICAgIGNvbnN0IHsgY2hpcHMgfSA9IGF3YWl0IGdldEpsY1BhcnRzQ2FjaGVkKFwiY2hpcHNcIiwge1xuICAgICAgICBwYWNrYWdlOiBmb290cHJpbnRlclN0cmluZyxcbiAgICAgIH0pXG4gICAgICByZXR1cm4ge1xuICAgICAgICBqbGNwY2I6IChjaGlwcyA/PyBbXSkubWFwKChjOiBhbnkpID0+IGBDJHtjLmxjc2N9YCkuc2xpY2UoMCwgMyksXG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChcbiAgICAgIHNvdXJjZUNvbXBvbmVudC50eXBlID09PSBcInNvdXJjZV9jb21wb25lbnRcIiAmJlxuICAgICAgc291cmNlQ29tcG9uZW50LmZ0eXBlID09PSBcInNpbXBsZV90cmFuc2lzdG9yXCJcbiAgICApIHtcbiAgICAgIGNvbnN0IHsgdHJhbnNpc3RvcnMgfSA9IGF3YWl0IGdldEpsY1BhcnRzQ2FjaGVkKFwidHJhbnNpc3RvcnNcIiwge1xuICAgICAgICBwYWNrYWdlOiBmb290cHJpbnRlclN0cmluZyxcbiAgICAgICAgdHJhbnNpc3Rvcl90eXBlOiBzb3VyY2VDb21wb25lbnQudHJhbnNpc3Rvcl90eXBlLFxuICAgICAgfSlcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGpsY3BjYjogKHRyYW5zaXN0b3JzID8/IFtdKS5tYXAoKHQ6IGFueSkgPT4gYEMke3QubGNzY31gKS5zbGljZSgwLCAzKSxcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKFxuICAgICAgc291cmNlQ29tcG9uZW50LnR5cGUgPT09IFwic291cmNlX2NvbXBvbmVudFwiICYmXG4gICAgICBzb3VyY2VDb21wb25lbnQuZnR5cGUgPT09IFwic2ltcGxlX3Bvd2VyX3NvdXJjZVwiXG4gICAgKSB7XG4gICAgICBjb25zdCB7IHBvd2VyX3NvdXJjZXMgfSA9IGF3YWl0IGdldEpsY1BhcnRzQ2FjaGVkKFwicG93ZXJfc291cmNlc1wiLCB7XG4gICAgICAgIHZvbHRhZ2U6IHNvdXJjZUNvbXBvbmVudC52b2x0YWdlLFxuICAgICAgICBwYWNrYWdlOiBmb290cHJpbnRlclN0cmluZyxcbiAgICAgIH0pXG4gICAgICByZXR1cm4ge1xuICAgICAgICBqbGNwY2I6IChwb3dlcl9zb3VyY2VzID8/IFtdKS5tYXAoKHA6IGFueSkgPT4gYEMke3AubGNzY31gKS5zbGljZSgwLCAzKSxcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKFxuICAgICAgc291cmNlQ29tcG9uZW50LnR5cGUgPT09IFwic291cmNlX2NvbXBvbmVudFwiICYmXG4gICAgICBzb3VyY2VDb21wb25lbnQuZnR5cGUgPT09IFwic2ltcGxlX2luZHVjdG9yXCJcbiAgICApIHtcbiAgICAgIGNvbnN0IHsgaW5kdWN0b3JzIH0gPSBhd2FpdCBnZXRKbGNQYXJ0c0NhY2hlZChcImluZHVjdG9yc1wiLCB7XG4gICAgICAgIGluZHVjdGFuY2U6IHNvdXJjZUNvbXBvbmVudC5pbmR1Y3RhbmNlLFxuICAgICAgICBwYWNrYWdlOiBmb290cHJpbnRlclN0cmluZyxcbiAgICAgIH0pXG4gICAgICByZXR1cm4ge1xuICAgICAgICBqbGNwY2I6IChpbmR1Y3RvcnMgPz8gW10pLm1hcCgoaTogYW55KSA9PiBgQyR7aS5sY3NjfWApLnNsaWNlKDAsIDMpLFxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoXG4gICAgICBzb3VyY2VDb21wb25lbnQudHlwZSA9PT0gXCJzb3VyY2VfY29tcG9uZW50XCIgJiZcbiAgICAgIHNvdXJjZUNvbXBvbmVudC5mdHlwZSA9PT0gXCJzaW1wbGVfY3J5c3RhbFwiXG4gICAgKSB7XG4gICAgICBjb25zdCB7IGNyeXN0YWxzIH0gPSBhd2FpdCBnZXRKbGNQYXJ0c0NhY2hlZChcImNyeXN0YWxzXCIsIHtcbiAgICAgICAgZnJlcXVlbmN5OiBzb3VyY2VDb21wb25lbnQuZnJlcXVlbmN5LFxuICAgICAgICBsb2FkX2NhcGFjaXRhbmNlOiBzb3VyY2VDb21wb25lbnQubG9hZF9jYXBhY2l0YW5jZSxcbiAgICAgICAgcGFja2FnZTogZm9vdHByaW50ZXJTdHJpbmcsXG4gICAgICB9KVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgamxjcGNiOiAoY3J5c3RhbHMgPz8gW10pLm1hcCgoYzogYW55KSA9PiBgQyR7Yy5sY3NjfWApLnNsaWNlKDAsIDMpLFxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoXG4gICAgICBzb3VyY2VDb21wb25lbnQudHlwZSA9PT0gXCJzb3VyY2VfY29tcG9uZW50XCIgJiZcbiAgICAgIHNvdXJjZUNvbXBvbmVudC5mdHlwZSA9PT0gXCJzaW1wbGVfbW9zZmV0XCJcbiAgICApIHtcbiAgICAgIGNvbnN0IHsgbW9zZmV0cyB9ID0gYXdhaXQgZ2V0SmxjUGFydHNDYWNoZWQoXCJtb3NmZXRzXCIsIHtcbiAgICAgICAgcGFja2FnZTogZm9vdHByaW50ZXJTdHJpbmcsXG4gICAgICAgIG1vc2ZldF9tb2RlOiBzb3VyY2VDb21wb25lbnQubW9zZmV0X21vZGUsXG4gICAgICAgIGNoYW5uZWxfdHlwZTogc291cmNlQ29tcG9uZW50LmNoYW5uZWxfdHlwZSxcbiAgICAgIH0pXG4gICAgICByZXR1cm4ge1xuICAgICAgICBqbGNwY2I6IChtb3NmZXRzID8/IFtdKS5tYXAoKG06IGFueSkgPT4gYEMke20ubGNzY31gKS5zbGljZSgwLCAzKSxcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKFxuICAgICAgc291cmNlQ29tcG9uZW50LnR5cGUgPT09IFwic291cmNlX2NvbXBvbmVudFwiICYmXG4gICAgICBzb3VyY2VDb21wb25lbnQuZnR5cGUgPT09IFwic2ltcGxlX3Jlc29uYXRvclwiXG4gICAgKSB7XG4gICAgICBjb25zdCB7IHJlc29uYXRvcnMgfSA9IGF3YWl0IGdldEpsY1BhcnRzQ2FjaGVkKFwicmVzb25hdG9yc1wiLCB7XG4gICAgICAgIGZyZXF1ZW5jeTogc291cmNlQ29tcG9uZW50LmZyZXF1ZW5jeSxcbiAgICAgICAgcGFja2FnZTogZm9vdHByaW50ZXJTdHJpbmcsXG4gICAgICB9KVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgamxjcGNiOiAocmVzb25hdG9ycyA/PyBbXSkubWFwKChyOiBhbnkpID0+IGBDJHtyLmxjc2N9YCkuc2xpY2UoMCwgMyksXG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChcbiAgICAgIHNvdXJjZUNvbXBvbmVudC50eXBlID09PSBcInNvdXJjZV9jb21wb25lbnRcIiAmJlxuICAgICAgc291cmNlQ29tcG9uZW50LmZ0eXBlID09PSBcInNpbXBsZV9zd2l0Y2hcIlxuICAgICkge1xuICAgICAgY29uc3QgeyBzd2l0Y2hlcyB9ID0gYXdhaXQgZ2V0SmxjUGFydHNDYWNoZWQoXCJzd2l0Y2hlc1wiLCB7XG4gICAgICAgIHN3aXRjaF90eXBlOiBzb3VyY2VDb21wb25lbnQudHlwZSxcbiAgICAgICAgcGFja2FnZTogZm9vdHByaW50ZXJTdHJpbmcsXG4gICAgICB9KVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgamxjcGNiOiAoc3dpdGNoZXMgPz8gW10pLm1hcCgoczogYW55KSA9PiBgQyR7cy5sY3NjfWApLnNsaWNlKDAsIDMpLFxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoXG4gICAgICBzb3VyY2VDb21wb25lbnQudHlwZSA9PT0gXCJzb3VyY2VfY29tcG9uZW50XCIgJiZcbiAgICAgIHNvdXJjZUNvbXBvbmVudC5mdHlwZSA9PT0gXCJzaW1wbGVfbGVkXCJcbiAgICApIHtcbiAgICAgIGNvbnN0IHsgbGVkcyB9ID0gYXdhaXQgZ2V0SmxjUGFydHNDYWNoZWQoXCJsZWRzXCIsIHtcbiAgICAgICAgcGFja2FnZTogZm9vdHByaW50ZXJTdHJpbmcsXG4gICAgICB9KVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgamxjcGNiOiAobGVkcyA/PyBbXSkubWFwKChsOiBhbnkpID0+IGBDJHtsLmxjc2N9YCkuc2xpY2UoMCwgMyksXG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChcbiAgICAgIHNvdXJjZUNvbXBvbmVudC50eXBlID09PSBcInNvdXJjZV9jb21wb25lbnRcIiAmJlxuICAgICAgc291cmNlQ29tcG9uZW50LmZ0eXBlID09PSBcInNpbXBsZV9mdXNlXCJcbiAgICApIHtcbiAgICAgIGNvbnN0IHsgZnVzZXMgfSA9IGF3YWl0IGdldEpsY1BhcnRzQ2FjaGVkKFwiZnVzZXNcIiwge1xuICAgICAgICBwYWNrYWdlOiBmb290cHJpbnRlclN0cmluZyxcbiAgICAgIH0pXG4gICAgICByZXR1cm4ge1xuICAgICAgICBqbGNwY2I6IChmdXNlcyA/PyBbXSkubWFwKChsOiBhbnkpID0+IGBDJHtsLmxjc2N9YCkuc2xpY2UoMCwgMyksXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7fVxuICB9LFxufVxuIiwgImltcG9ydCB0eXBlIHsgUGxhdGZvcm1Db25maWcgfSBmcm9tIFwiQHRzY2lyY3VpdC9wcm9wc1wiXG5pbXBvcnQgeyBqbGNQYXJ0c0VuZ2luZSB9IGZyb20gXCJAdHNjaXJjdWl0L3BhcnRzLWVuZ2luZVwiXG5cbmV4cG9ydCBjb25zdCBnZXRQbGF0Zm9ybUNvbmZpZyA9ICgpOiBQbGF0Zm9ybUNvbmZpZyA9PiAoe1xuICBwYXJ0c0VuZ2luZTogamxjUGFydHNFbmdpbmUsXG59KVxuIiwgImV4cG9ydCBmdW5jdGlvbiBub3JtYWxpemVGaWxlUGF0aChmaWxlUGF0aDogc3RyaW5nKSB7XG4gIGxldCBub3JtRmlsZVBhdGggPSBmaWxlUGF0aFxuICBub3JtRmlsZVBhdGggPSBub3JtRmlsZVBhdGgucmVwbGFjZSgvXFxcXC9nLCBcIi9cIilcbiAgbm9ybUZpbGVQYXRoID0gbm9ybUZpbGVQYXRoLnRyaW0oKVxuICBpZiAobm9ybUZpbGVQYXRoLnN0YXJ0c1dpdGgoXCIuL1wiKSkge1xuICAgIG5vcm1GaWxlUGF0aCA9IG5vcm1GaWxlUGF0aC5zbGljZSgyKVxuICB9XG4gIGlmIChub3JtRmlsZVBhdGguc3RhcnRzV2l0aChcIi9cIikpIHtcbiAgICBub3JtRmlsZVBhdGggPSBub3JtRmlsZVBhdGguc2xpY2UoMSlcbiAgfVxuICByZXR1cm4gbm9ybUZpbGVQYXRoXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBub3JtYWxpemVGc01hcChmc01hcDogUmVjb3JkPHN0cmluZywgc3RyaW5nPikge1xuICBjb25zdCBub3JtYWxpemVkRnNNYXA6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4gPSB7fVxuICBmb3IgKGNvbnN0IFtmc1BhdGgsIGZpbGVDb250ZW50XSBvZiBPYmplY3QuZW50cmllcyhmc01hcCkpIHtcbiAgICBub3JtYWxpemVkRnNNYXBbbm9ybWFsaXplRmlsZVBhdGgoZnNQYXRoKV0gPSBmaWxlQ29udGVudFxuICB9XG4gIHJldHVybiBub3JtYWxpemVkRnNNYXBcbn1cbiIsICJpbXBvcnQgdHlwZSB7IEFueUNpcmN1aXRFbGVtZW50IH0gZnJvbSBcImNpcmN1aXQtanNvblwiXG5pbXBvcnQgdHlwZSB7XG4gIENpcmN1aXRSdW5uZXJBcGksXG4gIENpcmN1aXRSdW5uZXJDb25maWd1cmF0aW9uLFxufSBmcm9tIFwibGliL3NoYXJlZC90eXBlc1wiXG5pbXBvcnQgdHlwZSB7IFBsYXRmb3JtQ29uZmlnIH0gZnJvbSBcIkB0c2NpcmN1aXQvcHJvcHNcIlxuaW1wb3J0IHsgY3JlYXRlRXhlY3V0aW9uQ29udGV4dCB9IGZyb20gXCIuLi8uLi93ZWJ3b3JrZXIvZXhlY3V0aW9uLWNvbnRleHRcIlxuaW1wb3J0IHsgbm9ybWFsaXplRnNNYXAgfSBmcm9tIFwiLi9ub3JtYWxpemVGc01hcFwiXG5pbXBvcnQgdHlwZSB7IFJvb3RDaXJjdWl0IH0gZnJvbSBcIkB0c2NpcmN1aXQvY29yZVwiXG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tIFwicmVhY3RcIlxuaW1wb3J0IHsgaW1wb3J0RXZhbFBhdGggfSBmcm9tIFwid2Vid29ya2VyL2ltcG9ydC1ldmFsLXBhdGhcIlxuaW1wb3J0IHsgc2V0dXBEZWZhdWx0RW50cnlwb2ludElmTmVlZGVkIH0gZnJvbSBcIi4vc2V0dXBEZWZhdWx0RW50cnlwb2ludElmTmVlZGVkXCJcbmltcG9ydCBEZWJ1ZyBmcm9tIFwiZGVidWdcIlxuXG5jb25zdCBkZWJ1ZyA9IERlYnVnKFwidHNjaTpldmFsOkNpcmN1aXRSdW5uZXJcIilcblxuZXhwb3J0IGNsYXNzIENpcmN1aXRSdW5uZXIgaW1wbGVtZW50cyBDaXJjdWl0UnVubmVyQXBpIHtcbiAgX2V4ZWN1dGlvbkNvbnRleHQ6IFJldHVyblR5cGU8dHlwZW9mIGNyZWF0ZUV4ZWN1dGlvbkNvbnRleHQ+IHwgbnVsbCA9IG51bGxcbiAgX2NpcmN1aXRSdW5uZXJDb25maWd1cmF0aW9uOiBDaXJjdWl0UnVubmVyQ29uZmlndXJhdGlvbiA9IHtcbiAgICBzbmlwcGV0c0FwaUJhc2VVcmw6IFwiaHR0cHM6Ly9yZWdpc3RyeS1hcGkudHNjaXJjdWl0LmNvbVwiLFxuICAgIGNqc1JlZ2lzdHJ5VXJsOiBcImh0dHBzOi8vY2pzLnRzY2lyY3VpdC5jb21cIixcbiAgICB2ZXJib3NlOiBmYWxzZSxcbiAgfVxuICBfZXZlbnRMaXN0ZW5lcnM6IFJlY29yZDxzdHJpbmcsICgoLi4uYXJnczogYW55W10pID0+IHZvaWQpW10+ID0ge31cblxuICBjb25zdHJ1Y3Rvcihjb25maWd1cmF0aW9uOiBQYXJ0aWFsPENpcmN1aXRSdW5uZXJDb25maWd1cmF0aW9uPiA9IHt9KSB7XG4gICAgT2JqZWN0LmFzc2lnbih0aGlzLl9jaXJjdWl0UnVubmVyQ29uZmlndXJhdGlvbiwgY29uZmlndXJhdGlvbilcbiAgfVxuXG4gIGFzeW5jIHZlcnNpb24oKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgICByZXR1cm4gXCIwLjAuMFwiXG4gIH1cblxuICBhc3luYyBleGVjdXRlV2l0aEZzTWFwKG9nT3B0czoge1xuICAgIGVudHJ5cG9pbnQ/OiBzdHJpbmdcbiAgICBtYWluQ29tcG9uZW50UGF0aD86IHN0cmluZ1xuICAgIG1haW5Db21wb25lbnROYW1lPzogc3RyaW5nXG4gICAgZnNNYXA6IFJlY29yZDxzdHJpbmcsIHN0cmluZz5cbiAgICBuYW1lPzogc3RyaW5nXG4gICAgbWFpbkNvbXBvbmVudFByb3BzPzogUmVjb3JkPHN0cmluZywgYW55PlxuICB9KTogUHJvbWlzZTx2b2lkPiB7XG4gICAgY29uc3Qgb3B0cyA9IHsgLi4ub2dPcHRzIH1cblxuICAgIGlmICh0aGlzLl9jaXJjdWl0UnVubmVyQ29uZmlndXJhdGlvbi52ZXJib3NlKSB7XG4gICAgICBEZWJ1Zy5lbmFibGUoXCJ0c2NpOmV2YWw6KlwiKVxuICAgIH1cblxuICAgIGRlYnVnKFwiZXhlY3V0ZVdpdGhGc01hcCBjYWxsZWQgd2l0aDpcIiwge1xuICAgICAgZW50cnlwb2ludDogb3B0cy5lbnRyeXBvaW50LFxuICAgICAgZnNNYXBLZXlzOiBPYmplY3Qua2V5cyhvcHRzLmZzTWFwKSxcbiAgICAgIG5hbWU6IG9wdHMubmFtZSxcbiAgICB9KVxuXG4gICAgc2V0dXBEZWZhdWx0RW50cnlwb2ludElmTmVlZGVkKG9wdHMpXG5cbiAgICBkZWJ1ZyhcImVudHJ5cG9pbnQgYWZ0ZXIgc2V0dXBEZWZhdWx0RW50cnlwb2ludElmTmVlZGVkOlwiLCB7XG4gICAgICBlbnRyeXBvaW50OiBvcHRzLmVudHJ5cG9pbnQsXG4gICAgfSlcblxuICAgIHRoaXMuX2V4ZWN1dGlvbkNvbnRleHQgPSBjcmVhdGVFeGVjdXRpb25Db250ZXh0KFxuICAgICAgdGhpcy5fY2lyY3VpdFJ1bm5lckNvbmZpZ3VyYXRpb24sXG4gICAgICB7XG4gICAgICAgIG5hbWU6IG9wdHMubmFtZSxcbiAgICAgICAgcGxhdGZvcm06IHRoaXMuX2NpcmN1aXRSdW5uZXJDb25maWd1cmF0aW9uLnBsYXRmb3JtLFxuICAgICAgfSxcbiAgICApXG4gICAgdGhpcy5fYmluZEV2ZW50TGlzdGVuZXJzKHRoaXMuX2V4ZWN1dGlvbkNvbnRleHQuY2lyY3VpdClcblxuICAgIHRoaXMuX2V4ZWN1dGlvbkNvbnRleHQuZnNNYXAgPSBub3JtYWxpemVGc01hcChvcHRzLmZzTWFwKVxuICAgIGlmICghdGhpcy5fZXhlY3V0aW9uQ29udGV4dC5mc01hcFtvcHRzLmVudHJ5cG9pbnQhXSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBFbnRyeXBvaW50IFwiJHtvcHRzLmVudHJ5cG9pbnR9XCIgbm90IGZvdW5kYClcbiAgICB9XG4gICAgOyhnbG9iYWxUaGlzIGFzIGFueSkuX190c2NpcmN1aXRfY2lyY3VpdCA9IHRoaXMuX2V4ZWN1dGlvbkNvbnRleHQuY2lyY3VpdFxuXG4gICAgY29uc3QgZW50cnlwb2ludCA9IG9wdHMuZW50cnlwb2ludCEuc3RhcnRzV2l0aChcIi4vXCIpXG4gICAgICA/IG9wdHMuZW50cnlwb2ludFxuICAgICAgOiBgLi8ke29wdHMuZW50cnlwb2ludH1gXG5cbiAgICBkZWJ1ZyhcImZpbmFsIGVudHJ5cG9pbnQ6XCIsIGVudHJ5cG9pbnQpXG4gICAgYXdhaXQgaW1wb3J0RXZhbFBhdGgoZW50cnlwb2ludCEsIHRoaXMuX2V4ZWN1dGlvbkNvbnRleHQpXG4gIH1cblxuICBhc3luYyBleGVjdXRlKGNvZGU6IHN0cmluZywgb3B0czogeyBuYW1lPzogc3RyaW5nIH0gPSB7fSkge1xuICAgIGlmICh0aGlzLl9jaXJjdWl0UnVubmVyQ29uZmlndXJhdGlvbi52ZXJib3NlKSB7XG4gICAgICBjb25zb2xlLmxvZyhcbiAgICAgICAgXCJbQ2lyY3VpdFJ1bm5lcl0gZXhlY3V0ZSBjYWxsZWQgd2l0aCBjb2RlIGxlbmd0aDpcIixcbiAgICAgICAgY29kZS5sZW5ndGgsXG4gICAgICApXG4gICAgfVxuXG4gICAgdGhpcy5fZXhlY3V0aW9uQ29udGV4dCA9IGNyZWF0ZUV4ZWN1dGlvbkNvbnRleHQoXG4gICAgICB0aGlzLl9jaXJjdWl0UnVubmVyQ29uZmlndXJhdGlvbixcbiAgICAgIHtcbiAgICAgICAgLi4ub3B0cyxcbiAgICAgICAgcGxhdGZvcm06IHRoaXMuX2NpcmN1aXRSdW5uZXJDb25maWd1cmF0aW9uLnBsYXRmb3JtLFxuICAgICAgfSxcbiAgICApXG4gICAgdGhpcy5fYmluZEV2ZW50TGlzdGVuZXJzKHRoaXMuX2V4ZWN1dGlvbkNvbnRleHQuY2lyY3VpdClcbiAgICB0aGlzLl9leGVjdXRpb25Db250ZXh0LmZzTWFwW1wiZW50cnlwb2ludC50c3hcIl0gPSBjb2RlXG4gICAgOyhnbG9iYWxUaGlzIGFzIGFueSkuX190c2NpcmN1aXRfY2lyY3VpdCA9IHRoaXMuX2V4ZWN1dGlvbkNvbnRleHQuY2lyY3VpdFxuXG4gICAgYXdhaXQgaW1wb3J0RXZhbFBhdGgoXCIuL2VudHJ5cG9pbnQudHN4XCIsIHRoaXMuX2V4ZWN1dGlvbkNvbnRleHQpXG4gIH1cblxuICBvbihldmVudDogc3RyaW5nLCBjYWxsYmFjazogKC4uLmFyZ3M6IGFueVtdKSA9PiB2b2lkKSB7XG4gICAgdGhpcy5fZXZlbnRMaXN0ZW5lcnNbZXZlbnRdID8/PSBbXVxuICAgIHRoaXMuX2V2ZW50TGlzdGVuZXJzW2V2ZW50XS5wdXNoKGNhbGxiYWNrKVxuICAgIHRoaXMuX2V4ZWN1dGlvbkNvbnRleHQ/LmNpcmN1aXQub24oZXZlbnQgYXMgYW55LCBjYWxsYmFjaylcbiAgfVxuXG4gIGFzeW5jIHJlbmRlclVudGlsU2V0dGxlZCgpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBpZiAoIXRoaXMuX2V4ZWN1dGlvbkNvbnRleHQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIGNpcmN1aXQgaGFzIGJlZW4gY3JlYXRlZFwiKVxuICAgIH1cbiAgICBhd2FpdCB0aGlzLl9leGVjdXRpb25Db250ZXh0LmNpcmN1aXQucmVuZGVyVW50aWxTZXR0bGVkKClcbiAgfVxuXG4gIGFzeW5jIGdldENpcmN1aXRKc29uKCk6IFByb21pc2U8QW55Q2lyY3VpdEVsZW1lbnRbXT4ge1xuICAgIGlmICghdGhpcy5fZXhlY3V0aW9uQ29udGV4dCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gY2lyY3VpdCBoYXMgYmVlbiBjcmVhdGVkXCIpXG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9leGVjdXRpb25Db250ZXh0LmNpcmN1aXQuZ2V0Q2lyY3VpdEpzb24oKVxuICB9XG5cbiAgY2xlYXJFdmVudExpc3RlbmVycygpIHtcbiAgICBpZiAodGhpcy5fZXhlY3V0aW9uQ29udGV4dD8uY2lyY3VpdCkge1xuICAgICAgZm9yIChjb25zdCBldmVudCBpbiB0aGlzLl9ldmVudExpc3RlbmVycykge1xuICAgICAgICBmb3IgKGNvbnN0IGxpc3RlbmVyIG9mIHRoaXMuX2V2ZW50TGlzdGVuZXJzW2V2ZW50XSkge1xuICAgICAgICAgIGNvbnN0IGNpcmN1aXQgPSB0aGlzLl9leGVjdXRpb25Db250ZXh0LmNpcmN1aXQgYXMgdW5rbm93biBhcyB7XG4gICAgICAgICAgICAvLyBiaW9tZS1pZ25vcmUgbGludC9jb21wbGV4aXR5L25vQmFubmVkVHlwZXM6IDxleHBsYW5hdGlvbj5cbiAgICAgICAgICAgIHJlbW92ZUxpc3RlbmVyPzogKGV2ZW50OiBzdHJpbmcsIGxpc3RlbmVyOiBGdW5jdGlvbikgPT4gdm9pZFxuICAgICAgICAgIH1cbiAgICAgICAgICBjaXJjdWl0LnJlbW92ZUxpc3RlbmVyPy4oZXZlbnQsIGxpc3RlbmVyKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgZm9yIChjb25zdCBldmVudCBpbiB0aGlzLl9ldmVudExpc3RlbmVycykge1xuICAgICAgZGVsZXRlIHRoaXMuX2V2ZW50TGlzdGVuZXJzW2V2ZW50XVxuICAgIH1cbiAgfVxuXG4gIGFzeW5jIGtpbGwoKSB7XG4gICAgLy8gQ2xlYW51cCByZXNvdXJjZXNcbiAgICB0aGlzLl9leGVjdXRpb25Db250ZXh0ID0gbnVsbFxuICB9XG5cbiAgYXN5bmMgc2V0U25pcHBldHNBcGlCYXNlVXJsKGJhc2VVcmw6IHN0cmluZykge1xuICAgIHRoaXMuX2NpcmN1aXRSdW5uZXJDb25maWd1cmF0aW9uLnNuaXBwZXRzQXBpQmFzZVVybCA9IGJhc2VVcmxcbiAgfVxuXG4gIGFzeW5jIHNldFBsYXRmb3JtQ29uZmlnKHBsYXRmb3JtOiBQbGF0Zm9ybUNvbmZpZykge1xuICAgIHRoaXMuX2NpcmN1aXRSdW5uZXJDb25maWd1cmF0aW9uLnBsYXRmb3JtID0gcGxhdGZvcm1cbiAgfVxuXG4gIHByaXZhdGUgX2JpbmRFdmVudExpc3RlbmVycyhjaXJjdWl0OiBSb290Q2lyY3VpdCkge1xuICAgIGZvciAoY29uc3QgZXZlbnQgaW4gdGhpcy5fZXZlbnRMaXN0ZW5lcnMpIHtcbiAgICAgIGZvciAoY29uc3QgbGlzdGVuZXIgb2YgdGhpcy5fZXZlbnRMaXN0ZW5lcnNbZXZlbnRdKSB7XG4gICAgICAgIGNpcmN1aXQub24oZXZlbnQgYXMgYW55LCBsaXN0ZW5lciBhcyBhbnkpXG4gICAgICB9XG4gICAgfVxuICB9XG59XG4iLCAiLyoqXG4gKiBSZXR1cm5zIHRoZSBkaXJlY3RvcnkgbmFtZSBvZiBhIHBhdGgsIHNpbWlsYXIgdG8gTm9kZS5qcyBwYXRoLmRpcm5hbWVcbiAqIFdvcmtzIG9uIGJvdGggVW5peCBhbmQgV2luZG93cyBwYXRoc1xuICogQHBhcmFtIHBhdGggVGhlIHBhdGggdG8gZXh0cmFjdCB0aGUgZGlyZWN0b3J5IGZyb21cbiAqIEByZXR1cm5zIFRoZSBkaXJlY3RvcnkgcGFydCBvZiB0aGUgcGF0aFxuICovXG5leHBvcnQgZnVuY3Rpb24gZGlybmFtZShwYXRoOiBzdHJpbmcpOiBzdHJpbmcge1xuICBpZiAoIXBhdGgpIHJldHVybiBcIi5cIlxuXG4gIC8vIE5vcm1hbGl6ZSBwYXRoIHNlcGFyYXRvcnMgdG8gZm9yd2FyZCBzbGFzaGVzXG4gIGNvbnN0IG5vcm1hbGl6ZWRQYXRoID0gcGF0aC5yZXBsYWNlKC9cXFxcL2csIFwiL1wiKVxuXG4gIC8vIFJlbW92ZSB0cmFpbGluZyBzbGFzaGVzXG4gIGNvbnN0IGNsZWFuUGF0aCA9IG5vcm1hbGl6ZWRQYXRoLnJlcGxhY2UoL1xcLyskLywgXCJcIilcblxuICAvLyBJZiB0aGVyZSBhcmUgbm8gc2xhc2hlcywgcmV0dXJuIFwiLlwiXG4gIGlmIChjbGVhblBhdGguaW5kZXhPZihcIi9cIikgPT09IC0xKSByZXR1cm4gXCIuXCJcblxuICAvLyBSZXR1cm4gZXZlcnl0aGluZyB1cCB0byB0aGUgbGFzdCBzbGFzaFxuICByZXR1cm4gY2xlYW5QYXRoLnN1YnN0cmluZygwLCBjbGVhblBhdGgubGFzdEluZGV4T2YoXCIvXCIpKSB8fCBcIi9cIlxufVxuIiwgImltcG9ydCB7IG5vcm1hbGl6ZUZpbGVQYXRoIH0gZnJvbSBcIi4vbm9ybWFsaXplRnNNYXBcIlxuaW1wb3J0IHsgZGlybmFtZSB9IGZyb20gXCJsaWIvdXRpbHMvZGlybmFtZVwiXG5cbmZ1bmN0aW9uIHJlc29sdmVSZWxhdGl2ZVBhdGgoaW1wb3J0UGF0aDogc3RyaW5nLCBjd2Q6IHN0cmluZyk6IHN0cmluZyB7XG4gIC8vIEhhbmRsZSBwYXJlbnQgZGlyZWN0b3J5IG5hdmlnYXRpb25cbiAgaWYgKGltcG9ydFBhdGguc3RhcnRzV2l0aChcIi4uL1wiKSkge1xuICAgIGNvbnN0IHBhcmVudERpciA9IGRpcm5hbWUoY3dkKVxuICAgIHJldHVybiByZXNvbHZlUmVsYXRpdmVQYXRoKGltcG9ydFBhdGguc2xpY2UoMyksIHBhcmVudERpcilcbiAgfVxuICAvLyBIYW5kbGUgY3VycmVudCBkaXJlY3RvcnlcbiAgaWYgKGltcG9ydFBhdGguc3RhcnRzV2l0aChcIi4vXCIpKSB7XG4gICAgcmV0dXJuIHJlc29sdmVSZWxhdGl2ZVBhdGgoaW1wb3J0UGF0aC5zbGljZSgyKSwgY3dkKVxuICB9XG4gIC8vIEhhbmRsZSBhYnNvbHV0ZSBwYXRoXG4gIGlmIChpbXBvcnRQYXRoLnN0YXJ0c1dpdGgoXCIvXCIpKSB7XG4gICAgcmV0dXJuIGltcG9ydFBhdGguc2xpY2UoMSlcbiAgfVxuICAvLyBIYW5kbGUgcmVsYXRpdmUgcGF0aFxuICByZXR1cm4gYCR7Y3dkfS8ke2ltcG9ydFBhdGh9YFxufVxuXG5leHBvcnQgY29uc3QgcmVzb2x2ZUZpbGVQYXRoID0gKFxuICB1bmtub3duRmlsZVBhdGg6IHN0cmluZyxcbiAgZnNNYXBPckFsbEZpbGVQYXRoczogUmVjb3JkPHN0cmluZywgc3RyaW5nPiB8IHN0cmluZ1tdLFxuICBjd2Q/OiBzdHJpbmcsXG4pID0+IHtcbiAgLy8gSGFuZGxlIHBhcmVudCBkaXJlY3RvcnkgbmF2aWdhdGlvbiBwcm9wZXJseVxuICBjb25zdCByZXNvbHZlZFBhdGggPSBjd2RcbiAgICA/IHJlc29sdmVSZWxhdGl2ZVBhdGgodW5rbm93bkZpbGVQYXRoLCBjd2QpXG4gICAgOiB1bmtub3duRmlsZVBhdGhcblxuICBjb25zdCBmaWxlUGF0aHMgPSBuZXcgU2V0KFxuICAgIEFycmF5LmlzQXJyYXkoZnNNYXBPckFsbEZpbGVQYXRocylcbiAgICAgID8gZnNNYXBPckFsbEZpbGVQYXRoc1xuICAgICAgOiBPYmplY3Qua2V5cyhmc01hcE9yQWxsRmlsZVBhdGhzKSxcbiAgKVxuXG4gIGlmIChmaWxlUGF0aHMuaGFzKHJlc29sdmVkUGF0aCkpIHtcbiAgICByZXR1cm4gcmVzb2x2ZWRQYXRoXG4gIH1cblxuICBjb25zdCBub3JtYWxpemVkRmlsZVBhdGhNYXAgPSBuZXcgTWFwPHN0cmluZywgc3RyaW5nPigpXG4gIGZvciAoY29uc3QgZmlsZVBhdGggb2YgZmlsZVBhdGhzKSB7XG4gICAgbm9ybWFsaXplZEZpbGVQYXRoTWFwLnNldChub3JtYWxpemVGaWxlUGF0aChmaWxlUGF0aCksIGZpbGVQYXRoKVxuICB9XG5cbiAgY29uc3Qgbm9ybWFsaXplZFJlc29sdmVkUGF0aCA9IG5vcm1hbGl6ZUZpbGVQYXRoKHJlc29sdmVkUGF0aClcblxuICBpZiAobm9ybWFsaXplZEZpbGVQYXRoTWFwLmhhcyhub3JtYWxpemVkUmVzb2x2ZWRQYXRoKSkge1xuICAgIHJldHVybiBub3JtYWxpemVkRmlsZVBhdGhNYXAuZ2V0KG5vcm1hbGl6ZWRSZXNvbHZlZFBhdGgpIVxuICB9XG5cbiAgLy8gU2VhcmNoIGZvciBmaWxlIHdpdGggYSBzZXQgb2YgZGlmZmVyZW50IGV4dGVuc2lvbnNcbiAgY29uc3QgZXh0ZW5zaW9uID0gW1widHN4XCIsIFwidHNcIiwgXCJqc29uXCIsIFwianNcIiwgXCJqc3hcIl1cbiAgZm9yIChjb25zdCBleHQgb2YgZXh0ZW5zaW9uKSB7XG4gICAgY29uc3QgcG9zc2libGVGaWxlUGF0aCA9IGAke25vcm1hbGl6ZWRSZXNvbHZlZFBhdGh9LiR7ZXh0fWBcbiAgICBpZiAobm9ybWFsaXplZEZpbGVQYXRoTWFwLmhhcyhwb3NzaWJsZUZpbGVQYXRoKSkge1xuICAgICAgcmV0dXJuIG5vcm1hbGl6ZWRGaWxlUGF0aE1hcC5nZXQocG9zc2libGVGaWxlUGF0aCkhXG4gICAgfVxuICB9XG5cbiAgLy8gQ2hlY2sgaWYgaXQncyBhbiBhYnNvbHV0ZSBpbXBvcnRcbiAgaWYgKCF1bmtub3duRmlsZVBhdGguc3RhcnRzV2l0aChcIi4vXCIpICYmICF1bmtub3duRmlsZVBhdGguc3RhcnRzV2l0aChcIi4uL1wiKSkge1xuICAgIGNvbnN0IG5vcm1hbGl6ZWRVbmtub3duRmlsZVBhdGggPSBub3JtYWxpemVGaWxlUGF0aCh1bmtub3duRmlsZVBhdGgpXG4gICAgaWYgKG5vcm1hbGl6ZWRGaWxlUGF0aE1hcC5oYXMobm9ybWFsaXplZFVua25vd25GaWxlUGF0aCkpIHtcbiAgICAgIHJldHVybiBub3JtYWxpemVkRmlsZVBhdGhNYXAuZ2V0KG5vcm1hbGl6ZWRVbmtub3duRmlsZVBhdGgpIVxuICAgIH1cbiAgICBmb3IgKGNvbnN0IGV4dCBvZiBleHRlbnNpb24pIHtcbiAgICAgIGNvbnN0IHBvc3NpYmxlRmlsZVBhdGggPSBgJHtub3JtYWxpemVkVW5rbm93bkZpbGVQYXRofS4ke2V4dH1gXG4gICAgICBpZiAobm9ybWFsaXplZEZpbGVQYXRoTWFwLmhhcyhwb3NzaWJsZUZpbGVQYXRoKSkge1xuICAgICAgICByZXR1cm4gbm9ybWFsaXplZEZpbGVQYXRoTWFwLmdldChwb3NzaWJsZUZpbGVQYXRoKSFcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbnVsbFxufVxuXG5leHBvcnQgY29uc3QgcmVzb2x2ZUZpbGVQYXRoT3JUaHJvdyA9IChcbiAgdW5rbm93bkZpbGVQYXRoOiBzdHJpbmcsXG4gIGZzTWFwT3JBbGxGaWxlUGF0aHM6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4gfCBzdHJpbmdbXSxcbikgPT4ge1xuICBjb25zdCByZXNvbHZlZEZpbGVQYXRoID0gcmVzb2x2ZUZpbGVQYXRoKHVua25vd25GaWxlUGF0aCwgZnNNYXBPckFsbEZpbGVQYXRocylcbiAgaWYgKCFyZXNvbHZlZEZpbGVQYXRoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYEZpbGUgbm90IGZvdW5kIFwiJHt1bmtub3duRmlsZVBhdGh9XCIsIGF2YWlsYWJsZSBwYXRoczpcXG5cXG4ke09iamVjdC5rZXlzKGZzTWFwT3JBbGxGaWxlUGF0aHMpLmpvaW4oXCIsIFwiKX1gLFxuICAgIClcbiAgfVxuICByZXR1cm4gcmVzb2x2ZWRGaWxlUGF0aFxufVxuIiwgImltcG9ydCB7IHJlc29sdmVGaWxlUGF0aCB9IGZyb20gXCJsaWIvcnVubmVyL3Jlc29sdmVGaWxlUGF0aFwiXG5cbmV4cG9ydCBmdW5jdGlvbiBldmFsQ29tcGlsZWRKcyhcbiAgY29tcGlsZWRDb2RlOiBzdHJpbmcsXG4gIHByZVN1cHBsaWVkSW1wb3J0czogUmVjb3JkPHN0cmluZywgYW55PixcbiAgY3dkPzogc3RyaW5nLFxuKSB7XG4gIDsoZ2xvYmFsVGhpcyBhcyBhbnkpLl9fdHNjaXJjdWl0X3JlcXVpcmUgPSAobmFtZTogc3RyaW5nKSA9PiB7XG4gICAgY29uc3QgcmVzb2x2ZWRGaWxlUGF0aCA9IHJlc29sdmVGaWxlUGF0aChuYW1lLCBwcmVTdXBwbGllZEltcG9ydHMsIGN3ZClcblxuICAgIGNvbnN0IGhhc1Jlc29sdmVkRmlsZVBhdGggPVxuICAgICAgcmVzb2x2ZWRGaWxlUGF0aCAmJiBwcmVTdXBwbGllZEltcG9ydHNbcmVzb2x2ZWRGaWxlUGF0aF1cblxuICAgIGlmICghcHJlU3VwcGxpZWRJbXBvcnRzW25hbWVdICYmICFoYXNSZXNvbHZlZEZpbGVQYXRoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEltcG9ydCBcIiR7bmFtZX1cIiBub3QgZm91bmQgJHtjd2QgPyBgaW4gXCIke2N3ZH1cImAgOiBcIlwifWApXG4gICAgfVxuXG4gICAgY29uc3QgbW9kID1cbiAgICAgIHByZVN1cHBsaWVkSW1wb3J0c1tuYW1lXSB8fCBwcmVTdXBwbGllZEltcG9ydHNbcmVzb2x2ZWRGaWxlUGF0aCFdXG4gICAgcmV0dXJuIG5ldyBQcm94eShtb2QsIHtcbiAgICAgIGdldCh0YXJnZXQsIHByb3ApIHtcbiAgICAgICAgaWYgKCEocHJvcCBpbiB0YXJnZXQpKSB7XG4gICAgICAgICAgaWYgKHByb3AgPT09IFwiZGVmYXVsdFwiKSB7XG4gICAgICAgICAgICBpZiAodGFyZ2V0LmRlZmF1bHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICByZXR1cm4gdGFyZ2V0LmRlZmF1bHRcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRhcmdldC5fX2VzTW9kdWxlKSB7XG4gICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWRcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHR5cGVvZiB0YXJnZXQgPT09IFwiZnVuY3Rpb25cIiB8fCB0eXBlb2YgdGFyZ2V0ID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICAgIHJldHVybiB0YXJnZXRcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZFxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChwcm9wID09PSBcIl9fZXNNb2R1bGVcIikge1xuICAgICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICBgQ29tcG9uZW50IFwiJHtTdHJpbmcocHJvcCl9XCIgaXMgbm90IGV4cG9ydGVkIGJ5IFwiJHtuYW1lfVwiYCxcbiAgICAgICAgICApXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGFyZ2V0W3Byb3AgYXMga2V5b2YgdHlwZW9mIHRhcmdldF1cbiAgICAgIH0sXG4gICAgfSlcbiAgfVxuXG4gIGNvbnN0IGZ1bmN0aW9uQm9keSA9IGBcbiAgdmFyIGV4cG9ydHMgPSB7fTtcbiAgdmFyIHJlcXVpcmUgPSBnbG9iYWxUaGlzLl9fdHNjaXJjdWl0X3JlcXVpcmU7XG4gIHZhciBtb2R1bGUgPSB7IGV4cG9ydHMgfTtcbiAgdmFyIGNpcmN1aXQgPSBnbG9iYWxUaGlzLl9fdHNjaXJjdWl0X2NpcmN1aXQ7XG4gICR7Y29tcGlsZWRDb2RlfTtcbiAgcmV0dXJuIG1vZHVsZTtgLnRyaW0oKVxuICByZXR1cm4gRnVuY3Rpb24oZnVuY3Rpb25Cb2R5KS5jYWxsKGdsb2JhbFRoaXMpXG59XG4iLCAiaW1wb3J0IHsgZXZhbENvbXBpbGVkSnMgfSBmcm9tIFwiLi9ldmFsLWNvbXBpbGVkLWpzXCJcbmltcG9ydCB0eXBlIHsgRXhlY3V0aW9uQ29udGV4dCB9IGZyb20gXCIuL2V4ZWN1dGlvbi1jb250ZXh0XCJcbmltcG9ydCAqIGFzIEJhYmVsIGZyb20gXCJAYmFiZWwvc3RhbmRhbG9uZVwiXG5pbXBvcnQgeyBpbXBvcnRMb2NhbEZpbGUgfSBmcm9tIFwiLi9pbXBvcnQtbG9jYWwtZmlsZVwiXG5pbXBvcnQgeyBpbXBvcnRTbmlwcGV0IH0gZnJvbSBcIi4vaW1wb3J0LXNuaXBwZXRcIlxuaW1wb3J0IHsgcmVzb2x2ZUZpbGVQYXRoIH0gZnJvbSBcImxpYi9ydW5uZXIvcmVzb2x2ZUZpbGVQYXRoXCJcbmltcG9ydCB7IHJlc29sdmVOb2RlTW9kdWxlIH0gZnJvbSBcImxpYi91dGlscy9yZXNvbHZlLW5vZGUtbW9kdWxlXCJcbmltcG9ydCB7IGltcG9ydE5vZGVNb2R1bGUgfSBmcm9tIFwiLi9pbXBvcnQtbm9kZS1tb2R1bGVcIlxuaW1wb3J0IERlYnVnIGZyb20gXCJkZWJ1Z1wiXG5cbmNvbnN0IGRlYnVnID0gRGVidWcoXCJ0c2NpOmV2YWw6aW1wb3J0LWV2YWwtcGF0aFwiKVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gaW1wb3J0RXZhbFBhdGgoXG4gIGltcG9ydE5hbWU6IHN0cmluZyxcbiAgY3R4OiBFeGVjdXRpb25Db250ZXh0LFxuICBkZXB0aCA9IDAsXG4gIG9wdHM6IHtcbiAgICBjd2Q/OiBzdHJpbmdcbiAgfSA9IHt9LFxuKSB7XG4gIGRlYnVnKFwiaW1wb3J0RXZhbFBhdGggY2FsbGVkIHdpdGg6XCIsIHtcbiAgICBpbXBvcnROYW1lLFxuICAgIGRlcHRoLFxuICAgIG9wdHMsXG4gIH0pXG5cbiAgZGVidWcoYCR7XCIgIFwiLnJlcGVhdChkZXB0aCl9XHUyN0ExXHVGRTBGYCwgaW1wb3J0TmFtZSlcbiAgY29uc3QgeyBwcmVTdXBwbGllZEltcG9ydHMgfSA9IGN0eFxuXG4gIGlmIChwcmVTdXBwbGllZEltcG9ydHNbaW1wb3J0TmFtZV0pIHJldHVyblxuICBpZiAoaW1wb3J0TmFtZS5zdGFydHNXaXRoKFwiLi9cIikgJiYgcHJlU3VwcGxpZWRJbXBvcnRzW2ltcG9ydE5hbWUuc2xpY2UoMildKVxuICAgIHJldHVyblxuXG4gIGlmIChkZXB0aCA+IDUpIHtcbiAgICBjb25zb2xlLmxvZyhcIk1heCBkZXB0aCBmb3IgaW1wb3J0cyByZWFjaGVkXCIpXG4gICAgcmV0dXJuXG4gIH1cblxuICBjb25zdCByZXNvbHZlZExvY2FsSW1wb3J0UGF0aCA9IHJlc29sdmVGaWxlUGF0aChcbiAgICBpbXBvcnROYW1lLFxuICAgIGN0eC5mc01hcCxcbiAgICBvcHRzLmN3ZCxcbiAgKVxuICBpZiAocmVzb2x2ZWRMb2NhbEltcG9ydFBhdGgpIHtcbiAgICByZXR1cm4gaW1wb3J0TG9jYWxGaWxlKHJlc29sdmVkTG9jYWxJbXBvcnRQYXRoLCBjdHgsIGRlcHRoKVxuICB9XG5cbiAgLy8gVHJ5IHRvIHJlc29sdmUgZnJvbSBub2RlX21vZHVsZXNcbiAgY29uc3QgcmVzb2x2ZWROb2RlTW9kdWxlUGF0aCA9IHJlc29sdmVOb2RlTW9kdWxlKFxuICAgIGltcG9ydE5hbWUsXG4gICAgY3R4LmZzTWFwLFxuICAgIG9wdHMuY3dkIHx8IFwiXCIsXG4gIClcbiAgaWYgKHJlc29sdmVkTm9kZU1vZHVsZVBhdGgpIHtcbiAgICByZXR1cm4gaW1wb3J0Tm9kZU1vZHVsZShpbXBvcnROYW1lLCBjdHgsIGRlcHRoKVxuICB9XG5cbiAgaWYgKGltcG9ydE5hbWUuc3RhcnRzV2l0aChcIkB0c2NpL1wiKSkge1xuICAgIHJldHVybiBpbXBvcnRTbmlwcGV0KGltcG9ydE5hbWUsIGN0eCwgZGVwdGgpXG4gIH1cblxuICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgYFVucmVzb2x2ZWQgaW1wb3J0IFwiJHtpbXBvcnROYW1lfVwiICR7b3B0cy5jd2QgPyBgZnJvbSBkaXJlY3RvcnkgXCIke29wdHMuY3dkfVwiYCA6IFwiXCJ9YCxcbiAgKVxufVxuIiwgImltcG9ydCAqIGFzIEJhYmVsIGZyb20gXCJAYmFiZWwvc3RhbmRhbG9uZVwiXG5pbXBvcnQgeyByZXNvbHZlRmlsZVBhdGhPclRocm93IH0gZnJvbSBcImxpYi9ydW5uZXIvcmVzb2x2ZUZpbGVQYXRoXCJcbmltcG9ydCB7IGRpcm5hbWUgfSBmcm9tIFwibGliL3V0aWxzL2Rpcm5hbWVcIlxuaW1wb3J0IHsgZ2V0SW1wb3J0c0Zyb21Db2RlIH0gZnJvbSBcImxpYi91dGlscy9nZXQtaW1wb3J0cy1mcm9tLWNvZGVcIlxuaW1wb3J0IHsgZXZhbENvbXBpbGVkSnMgfSBmcm9tIFwiLi9ldmFsLWNvbXBpbGVkLWpzXCJcbmltcG9ydCB0eXBlIHsgRXhlY3V0aW9uQ29udGV4dCB9IGZyb20gXCIuL2V4ZWN1dGlvbi1jb250ZXh0XCJcbmltcG9ydCB7IGltcG9ydEV2YWxQYXRoIH0gZnJvbSBcIi4vaW1wb3J0LWV2YWwtcGF0aFwiXG5pbXBvcnQgRGVidWcgZnJvbSBcImRlYnVnXCJcblxuY29uc3QgZGVidWcgPSBEZWJ1ZyhcInRzY2k6ZXZhbDppbXBvcnQtbG9jYWwtZmlsZVwiKVxuXG5leHBvcnQgY29uc3QgaW1wb3J0TG9jYWxGaWxlID0gYXN5bmMgKFxuICBpbXBvcnROYW1lOiBzdHJpbmcsXG4gIGN0eDogRXhlY3V0aW9uQ29udGV4dCxcbiAgZGVwdGggPSAwLFxuKSA9PiB7XG4gIGRlYnVnKFwiaW1wb3J0TG9jYWxGaWxlIGNhbGxlZCB3aXRoOlwiLCB7XG4gICAgaW1wb3J0TmFtZSxcbiAgfSlcblxuICBjb25zdCB7IGZzTWFwLCBwcmVTdXBwbGllZEltcG9ydHMgfSA9IGN0eFxuXG4gIGNvbnN0IGZzUGF0aCA9IHJlc29sdmVGaWxlUGF0aE9yVGhyb3coaW1wb3J0TmFtZSwgZnNNYXApXG4gIGRlYnVnKFwiZnNQYXRoOlwiLCBmc1BhdGgpXG4gIGlmICghY3R4LmZzTWFwW2ZzUGF0aF0pIHtcbiAgICBkZWJ1ZyhcImZzUGF0aCBub3QgZm91bmQgaW4gZnNNYXA6XCIsIGZzUGF0aClcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEZpbGUgXCIke2ZzUGF0aH1cIiBub3QgZm91bmRgKVxuICB9XG4gIGNvbnN0IGZpbGVDb250ZW50ID0gZnNNYXBbZnNQYXRoXVxuICBkZWJ1ZyhcImZpbGVDb250ZW50OlwiLCBmaWxlQ29udGVudD8uc2xpY2UoMCwgMTAwKSlcbiAgaWYgKGZzUGF0aC5lbmRzV2l0aChcIi5qc29uXCIpKSB7XG4gICAgY29uc3QganNvbkRhdGEgPSBKU09OLnBhcnNlKGZpbGVDb250ZW50KVxuICAgIHByZVN1cHBsaWVkSW1wb3J0c1tmc1BhdGhdID0ge1xuICAgICAgX19lc01vZHVsZTogdHJ1ZSxcbiAgICAgIGRlZmF1bHQ6IGpzb25EYXRhLFxuICAgIH1cbiAgfSBlbHNlIGlmIChmc1BhdGguZW5kc1dpdGgoXCIudHN4XCIpIHx8IGZzUGF0aC5lbmRzV2l0aChcIi50c1wiKSkge1xuICAgIGNvbnN0IGltcG9ydE5hbWVzID0gZ2V0SW1wb3J0c0Zyb21Db2RlKGZpbGVDb250ZW50KVxuXG4gICAgZm9yIChjb25zdCBpbXBvcnROYW1lIG9mIGltcG9ydE5hbWVzKSB7XG4gICAgICBpZiAoIXByZVN1cHBsaWVkSW1wb3J0c1tpbXBvcnROYW1lXSkge1xuICAgICAgICBhd2FpdCBpbXBvcnRFdmFsUGF0aChpbXBvcnROYW1lLCBjdHgsIGRlcHRoICsgMSwge1xuICAgICAgICAgIGN3ZDogZGlybmFtZShmc1BhdGgpLFxuICAgICAgICB9KVxuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IHJlc3VsdCA9IEJhYmVsLnRyYW5zZm9ybShmaWxlQ29udGVudCwge1xuICAgICAgcHJlc2V0czogW1wicmVhY3RcIiwgXCJ0eXBlc2NyaXB0XCJdLFxuICAgICAgcGx1Z2luczogW1widHJhbnNmb3JtLW1vZHVsZXMtY29tbW9uanNcIl0sXG4gICAgICBmaWxlbmFtZTogXCJ2aXJ0dWFsLnRzeFwiLFxuICAgIH0pXG5cbiAgICBpZiAoIXJlc3VsdCB8fCAhcmVzdWx0LmNvZGUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkZhaWxlZCB0byB0cmFuc2Zvcm0gY29kZVwiKVxuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICBkZWJ1ZyhcImV2YWxDb21waWxlZEpzIGNhbGxlZCB3aXRoOlwiLCB7XG4gICAgICAgIGNvZGU6IHJlc3VsdC5jb2RlPy5zbGljZSgwLCAxMDApLFxuICAgICAgICBkaXJuYW1lOiBkaXJuYW1lKGZzUGF0aCksXG4gICAgICB9KVxuICAgICAgY29uc3QgaW1wb3J0UnVuUmVzdWx0ID0gZXZhbENvbXBpbGVkSnMoXG4gICAgICAgIHJlc3VsdC5jb2RlLFxuICAgICAgICBwcmVTdXBwbGllZEltcG9ydHMsXG4gICAgICAgIGRpcm5hbWUoZnNQYXRoKSxcbiAgICAgIClcbiAgICAgIGRlYnVnKFwiaW1wb3J0UnVuUmVzdWx0OlwiLCB7XG4gICAgICAgIGZzUGF0aCxcbiAgICAgICAgaW1wb3J0UnVuUmVzdWx0LFxuICAgICAgfSlcbiAgICAgIHByZVN1cHBsaWVkSW1wb3J0c1tmc1BhdGhdID0gaW1wb3J0UnVuUmVzdWx0LmV4cG9ydHNcbiAgICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBFdmFsIGNvbXBpbGVkIGpzIGVycm9yIGZvciBcIiR7aW1wb3J0TmFtZX1cIjogJHtlcnJvci5tZXNzYWdlfWAsXG4gICAgICApXG4gICAgfVxuICB9IGVsc2UgaWYgKGZzUGF0aC5lbmRzV2l0aChcIi5qc1wiKSkge1xuICAgIC8vIEZvciAuanMgZmlsZXMsIGVzcGVjaWFsbHkgZnJvbSBub2RlX21vZHVsZXMsIHdlIG5lZWQgdG8gdHJhbnNmb3JtIHRoZW1cbiAgICBjb25zdCByZXN1bHQgPSBCYWJlbC50cmFuc2Zvcm0oZmlsZUNvbnRlbnQsIHtcbiAgICAgIHByZXNldHM6IFtcImVudlwiXSxcbiAgICAgIHBsdWdpbnM6IFtcInRyYW5zZm9ybS1tb2R1bGVzLWNvbW1vbmpzXCJdLFxuICAgICAgZmlsZW5hbWU6IGZzUGF0aCxcbiAgICB9KVxuXG4gICAgaWYgKCFyZXN1bHQgfHwgIXJlc3VsdC5jb2RlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJGYWlsZWQgdG8gdHJhbnNmb3JtIEpTIGNvZGVcIilcbiAgICB9XG5cbiAgICBwcmVTdXBwbGllZEltcG9ydHNbZnNQYXRoXSA9IGV2YWxDb21waWxlZEpzKFxuICAgICAgcmVzdWx0LmNvZGUsXG4gICAgICBwcmVTdXBwbGllZEltcG9ydHMsXG4gICAgICBkaXJuYW1lKGZzUGF0aCksXG4gICAgKS5leHBvcnRzXG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYFVuc3VwcG9ydGVkIGZpbGUgZXh0ZW5zaW9uIFwiJHtmc1BhdGguc3BsaXQoXCIuXCIpLnBvcCgpfVwiIGZvciBcIiR7ZnNQYXRofVwiYCxcbiAgICApXG4gIH1cbn1cbiIsICJleHBvcnQgY29uc3QgZ2V0SW1wb3J0c0Zyb21Db2RlID0gKGNvZGU6IHN0cmluZyk6IHN0cmluZ1tdID0+IHtcbiAgLy8gTWF0Y2ggYmFzaWMgaW1wb3J0IHBhdHRlcm5zIGluY2x1ZGluZyBjb21iaW5lZCBkZWZhdWx0IGFuZCBuYW1lc3BhY2UgaW1wb3J0c1xuICBjb25zdCBpbXBvcnRSZWdleCA9XG4gICAgL15cXHMqaW1wb3J0XFxzKyg/Oig/OltcXHdcXHNdKyxcXHMqKT8oPzpcXCpcXHMrYXNcXHMrW1xcd1xcc10rfFxce1tcXHNcXHcsXStcXH18XFx3KylcXHMrZnJvbVxccyspP1snXCJdKC4rPylbJ1wiXS9nbVxuICBjb25zdCBpbXBvcnRzOiBzdHJpbmdbXSA9IFtdXG4gIGxldCBtYXRjaDogUmVnRXhwRXhlY0FycmF5IHwgbnVsbFxuXG4gIC8vIGJpb21lLWlnbm9yZSBsaW50L3N1c3BpY2lvdXMvbm9Bc3NpZ25JbkV4cHJlc3Npb25zOiA8ZXhwbGFuYXRpb24+XG4gIHdoaWxlICgobWF0Y2ggPSBpbXBvcnRSZWdleC5leGVjKGNvZGUpKSAhPT0gbnVsbCkge1xuICAgIGltcG9ydHMucHVzaChtYXRjaFsxXSlcbiAgfVxuXG4gIC8vIE1hdGNoIHJlLWV4cG9ydHNcbiAgY29uc3QgcmVFeHBvcnRSZWdleCA9XG4gICAgL15cXHMqZXhwb3J0XFxzKyg/OlxcKnwoPzpcXHtbXFxzXFx3LF0rXFx9KSlcXHMrZnJvbVxccytbJ1wiXSguKz8pWydcIl0vZ21cbiAgbGV0IHJlRXhwb3J0TWF0Y2g6IFJlZ0V4cEV4ZWNBcnJheSB8IG51bGxcbiAgLy8gYmlvbWUtaWdub3JlIGxpbnQvc3VzcGljaW91cy9ub0Fzc2lnbkluRXhwcmVzc2lvbnM6IDxleHBsYW5hdGlvbj5cbiAgd2hpbGUgKChyZUV4cG9ydE1hdGNoID0gcmVFeHBvcnRSZWdleC5leGVjKGNvZGUpKSAhPT0gbnVsbCkge1xuICAgIGltcG9ydHMucHVzaChyZUV4cG9ydE1hdGNoWzFdKVxuICB9XG5cbiAgcmV0dXJuIGltcG9ydHNcbn1cbiIsICJpbXBvcnQgeyBldmFsQ29tcGlsZWRKcyB9IGZyb20gXCIuL2V2YWwtY29tcGlsZWQtanNcIlxuaW1wb3J0IHR5cGUgeyBFeGVjdXRpb25Db250ZXh0IH0gZnJvbSBcIi4vZXhlY3V0aW9uLWNvbnRleHRcIlxuaW1wb3J0ICogYXMgQmFiZWwgZnJvbSBcIkBiYWJlbC9zdGFuZGFsb25lXCJcbmltcG9ydCB7IGltcG9ydExvY2FsRmlsZSB9IGZyb20gXCIuL2ltcG9ydC1sb2NhbC1maWxlXCJcbmltcG9ydCB7IGltcG9ydEV2YWxQYXRoIH0gZnJvbSBcIi4vaW1wb3J0LWV2YWwtcGF0aFwiXG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBpbXBvcnRTbmlwcGV0KFxuICBpbXBvcnROYW1lOiBzdHJpbmcsXG4gIGN0eDogRXhlY3V0aW9uQ29udGV4dCxcbiAgZGVwdGggPSAwLFxuKSB7XG4gIGNvbnN0IHsgcHJlU3VwcGxpZWRJbXBvcnRzIH0gPSBjdHhcbiAgY29uc3QgZnVsbFNuaXBwZXROYW1lID0gaW1wb3J0TmFtZS5yZXBsYWNlKFwiQHRzY2kvXCIsIFwiXCIpLnJlcGxhY2UoXCIuXCIsIFwiL1wiKVxuXG4gIGNvbnN0IHsgY2pzLCBlcnJvciB9ID0gYXdhaXQgZmV0Y2goYCR7Y3R4LmNqc1JlZ2lzdHJ5VXJsfS8ke2Z1bGxTbmlwcGV0TmFtZX1gKVxuICAgIC50aGVuKGFzeW5jIChyZXMpID0+ICh7IGNqczogYXdhaXQgcmVzLnRleHQoKSwgZXJyb3I6IG51bGwgfSkpXG4gICAgLmNhdGNoKChlKSA9PiAoeyBlcnJvcjogZSwgY2pzOiBudWxsIH0pKVxuXG4gIGlmIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBmZXRjaGluZyBpbXBvcnRcIiwgaW1wb3J0TmFtZSwgZXJyb3IpXG4gICAgcmV0dXJuXG4gIH1cblxuICB0cnkge1xuICAgIHByZVN1cHBsaWVkSW1wb3J0c1tpbXBvcnROYW1lXSA9IGV2YWxDb21waWxlZEpzKFxuICAgICAgY2pzISxcbiAgICAgIHByZVN1cHBsaWVkSW1wb3J0cyxcbiAgICApLmV4cG9ydHNcbiAgfSBjYXRjaCAoZSkge1xuICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBpbXBvcnRpbmcgc25pcHBldFwiLCBlKVxuICB9XG59XG4iLCAiaW1wb3J0IHsgZGlybmFtZSB9IGZyb20gXCIuL2Rpcm5hbWVcIlxuXG5pbnRlcmZhY2UgUGFja2FnZUpzb24ge1xuICBtYWluPzogc3RyaW5nXG4gIG1vZHVsZT86IHN0cmluZ1xuICBleHBvcnRzPzogUmVjb3JkPHN0cmluZywgc3RyaW5nIHwgUmVjb3JkPHN0cmluZywgc3RyaW5nPj5cbn1cblxuaW50ZXJmYWNlIE5vZGVSZXNvbHV0aW9uQ29udGV4dCB7XG4gIGZzTWFwOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+XG4gIGV4dGVuc2lvbnM6IHN0cmluZ1tdXG4gIGJhc2VQYXRoOiBzdHJpbmdcbiAgbW9kdWxlUGF0aDogc3RyaW5nXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUNvbnRleHQoXG4gIG1vZHVsZVBhdGg6IHN0cmluZyxcbiAgZnNNYXA6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4sXG4gIGJhc2VQYXRoOiBzdHJpbmcsXG4pOiBOb2RlUmVzb2x1dGlvbkNvbnRleHQge1xuICByZXR1cm4ge1xuICAgIGZzTWFwLFxuICAgIGV4dGVuc2lvbnM6IFtcIi5qc1wiLCBcIi5qc3hcIiwgXCIudHNcIiwgXCIudHN4XCIsIFwiLmpzb25cIl0sXG4gICAgYmFzZVBhdGgsXG4gICAgbW9kdWxlUGF0aCxcbiAgfVxufVxuXG5mdW5jdGlvbiBmaW5kUGFja2FnZUpzb24obm9kZU1vZHVsZXNQYXRoOiBzdHJpbmcsIGN0eDogTm9kZVJlc29sdXRpb25Db250ZXh0KSB7XG4gIGNvbnN0IHBhY2thZ2VKc29uUGF0aCA9IGAke25vZGVNb2R1bGVzUGF0aH0vcGFja2FnZS5qc29uYFxuICBpZiAoIWN0eC5mc01hcFtwYWNrYWdlSnNvblBhdGhdKSByZXR1cm4gbnVsbFxuICB0cnkge1xuICAgIHJldHVybiBKU09OLnBhcnNlKGN0eC5mc01hcFtwYWNrYWdlSnNvblBhdGhdKSBhcyBQYWNrYWdlSnNvblxuICB9IGNhdGNoIHtcbiAgICByZXR1cm4gbnVsbFxuICB9XG59XG5cbmZ1bmN0aW9uIHRyeVJlc29sdmVXaXRoRXh0ZW5zaW9ucyhcbiAgcGF0aDogc3RyaW5nLFxuICBjdHg6IE5vZGVSZXNvbHV0aW9uQ29udGV4dCxcbik6IHN0cmluZyB8IG51bGwge1xuICBpZiAoY3R4LmZzTWFwW3BhdGhdKSByZXR1cm4gcGF0aFxuXG4gIGZvciAoY29uc3QgZXh0IG9mIGN0eC5leHRlbnNpb25zKSB7XG4gICAgY29uc3QgcGF0aFdpdGhFeHQgPSBwYXRoLnJlcGxhY2UoL1xcLmpzJHxcXC5qc3gkLywgXCJcIikgKyBleHRcbiAgICBpZiAoY3R4LmZzTWFwW3BhdGhXaXRoRXh0XSkgcmV0dXJuIHBhdGhXaXRoRXh0XG4gIH1cbiAgcmV0dXJuIG51bGxcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZUV4cG9ydFBhdGgoXG4gIG5vZGVNb2R1bGVzUGF0aDogc3RyaW5nLFxuICBleHBvcnRQYXRoOiBzdHJpbmcsXG4gIGN0eDogTm9kZVJlc29sdXRpb25Db250ZXh0LFxuKTogc3RyaW5nIHwgbnVsbCB7XG4gIGNvbnN0IGZ1bGxFeHBvcnRQYXRoID0gYCR7bm9kZU1vZHVsZXNQYXRofS8ke2V4cG9ydFBhdGgucmVwbGFjZSgvXlxcLlxcLy8sIFwiXCIpfWBcbiAgcmV0dXJuIHRyeVJlc29sdmVXaXRoRXh0ZW5zaW9ucyhmdWxsRXhwb3J0UGF0aCwgY3R4KVxufVxuXG5mdW5jdGlvbiByZXNvbHZlUGFja2FnZUV4cG9ydHMoXG4gIG5vZGVNb2R1bGVzUGF0aDogc3RyaW5nLFxuICBwYWNrYWdlSnNvbjogUGFja2FnZUpzb24sXG4gIHJlbWFpbmluZ1BhdGg6IHN0cmluZyxcbiAgY3R4OiBOb2RlUmVzb2x1dGlvbkNvbnRleHQsXG4pOiBzdHJpbmcgfCBudWxsIHtcbiAgaWYgKCFwYWNrYWdlSnNvbi5leHBvcnRzKSByZXR1cm4gbnVsbFxuXG4gIC8vIEhhbmRsZSBkZWZhdWx0IGV4cG9ydCBjb25kaXRpb25cbiAgY29uc3QgZGVmYXVsdEV4cG9ydCA9IHBhY2thZ2VKc29uLmV4cG9ydHNbXCIuXCJdXG4gIGlmIChyZW1haW5pbmdQYXRoID09PSBcIlwiICYmIGRlZmF1bHRFeHBvcnQpIHtcbiAgICBpZiAodHlwZW9mIGRlZmF1bHRFeHBvcnQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIGNvbnN0IHJlc29sdmVkID0gcmVzb2x2ZUV4cG9ydFBhdGgobm9kZU1vZHVsZXNQYXRoLCBkZWZhdWx0RXhwb3J0LCBjdHgpXG4gICAgICBpZiAocmVzb2x2ZWQpIHJldHVybiByZXNvbHZlZFxuICAgIH1cbiAgfVxuXG4gIC8vIEhhbmRsZSBzdWJwYXRoIGV4cG9ydHNcbiAgY29uc3Qgc3VicGF0aEV4cG9ydCA9IHJlbWFpbmluZ1BhdGhcbiAgICA/IHBhY2thZ2VKc29uLmV4cG9ydHNbYC4vJHtyZW1haW5pbmdQYXRofWBdXG4gICAgOiBudWxsXG4gIGlmIChzdWJwYXRoRXhwb3J0ICYmIHR5cGVvZiBzdWJwYXRoRXhwb3J0ID09PSBcInN0cmluZ1wiKSB7XG4gICAgY29uc3QgcmVzb2x2ZWQgPSByZXNvbHZlRXhwb3J0UGF0aChub2RlTW9kdWxlc1BhdGgsIHN1YnBhdGhFeHBvcnQsIGN0eClcbiAgICBpZiAocmVzb2x2ZWQpIHJldHVybiByZXNvbHZlZFxuICB9XG5cbiAgLy8gSGFuZGxlIGNvbmRpdGlvbmFsIGV4cG9ydHNcbiAgY29uc3QgaW1wb3J0RXhwb3J0ID0gcGFja2FnZUpzb24uZXhwb3J0c1tcImltcG9ydFwiXVxuICBpZiAoXG4gICAgcmVtYWluaW5nUGF0aCA9PT0gXCJcIiAmJlxuICAgIGltcG9ydEV4cG9ydCAmJlxuICAgIHR5cGVvZiBpbXBvcnRFeHBvcnQgPT09IFwic3RyaW5nXCJcbiAgKSB7XG4gICAgY29uc3QgcmVzb2x2ZWQgPSByZXNvbHZlRXhwb3J0UGF0aChub2RlTW9kdWxlc1BhdGgsIGltcG9ydEV4cG9ydCwgY3R4KVxuICAgIGlmIChyZXNvbHZlZCkgcmV0dXJuIHJlc29sdmVkXG4gIH1cblxuICByZXR1cm4gbnVsbFxufVxuXG5mdW5jdGlvbiByZXNvbHZlUGFja2FnZUVudHJ5UG9pbnQoXG4gIG5vZGVNb2R1bGVzUGF0aDogc3RyaW5nLFxuICBwYWNrYWdlSnNvbjogUGFja2FnZUpzb24sXG4gIGN0eDogTm9kZVJlc29sdXRpb25Db250ZXh0LFxuKTogc3RyaW5nIHwgbnVsbCB7XG4gIGNvbnN0IGVudHJ5UG9pbnQgPSBwYWNrYWdlSnNvbi5tb2R1bGUgfHwgcGFja2FnZUpzb24ubWFpbiB8fCBcImluZGV4LmpzXCJcbiAgY29uc3QgZnVsbFBhdGggPSBgJHtub2RlTW9kdWxlc1BhdGh9LyR7ZW50cnlQb2ludH1gXG4gIHJldHVybiB0cnlSZXNvbHZlV2l0aEV4dGVuc2lvbnMoZnVsbFBhdGgsIGN0eClcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZVJlbWFpbmluZ1BhdGgoXG4gIG5vZGVNb2R1bGVzUGF0aDogc3RyaW5nLFxuICByZW1haW5pbmdQYXRoOiBzdHJpbmcsXG4gIGN0eDogTm9kZVJlc29sdXRpb25Db250ZXh0LFxuKTogc3RyaW5nIHwgbnVsbCB7XG4gIGlmICghcmVtYWluaW5nUGF0aCkge1xuICAgIC8vIFRyeSBpbmRleCBmaWxlcyBpbiB0aGUgbW9kdWxlIHJvb3RcbiAgICBmb3IgKGNvbnN0IGV4dCBvZiBjdHguZXh0ZW5zaW9ucykge1xuICAgICAgY29uc3QgaW5kZXhQYXRoID0gYCR7bm9kZU1vZHVsZXNQYXRofS9pbmRleCR7ZXh0fWBcbiAgICAgIGlmIChjdHguZnNNYXBbaW5kZXhQYXRoXSkgcmV0dXJuIGluZGV4UGF0aFxuICAgIH1cbiAgICByZXR1cm4gbnVsbFxuICB9XG5cbiAgY29uc3QgZnVsbFBhdGggPSBgJHtub2RlTW9kdWxlc1BhdGh9LyR7cmVtYWluaW5nUGF0aH1gXG4gIGNvbnN0IGRpcmVjdE1hdGNoID0gdHJ5UmVzb2x2ZVdpdGhFeHRlbnNpb25zKGZ1bGxQYXRoLCBjdHgpXG4gIGlmIChkaXJlY3RNYXRjaCkgcmV0dXJuIGRpcmVjdE1hdGNoXG5cbiAgLy8gVHJ5IGluZGV4IGZpbGVzXG4gIGZvciAoY29uc3QgZXh0IG9mIGN0eC5leHRlbnNpb25zKSB7XG4gICAgY29uc3QgaW5kZXhQYXRoID0gYCR7ZnVsbFBhdGh9L2luZGV4JHtleHR9YFxuICAgIGlmIChjdHguZnNNYXBbaW5kZXhQYXRoXSkgcmV0dXJuIGluZGV4UGF0aFxuICB9XG4gIHJldHVybiBudWxsXG59XG5cbmZ1bmN0aW9uIHJlc29sdmVOb2RlTW9kdWxlSW5QYXRoKFxuICBzZWFyY2hQYXRoOiBzdHJpbmcsXG4gIGN0eDogTm9kZVJlc29sdXRpb25Db250ZXh0LFxuKTogc3RyaW5nIHwgbnVsbCB7XG4gIGNvbnN0IG1vZHVsZVBhcnRzID0gY3R4Lm1vZHVsZVBhdGguc3BsaXQoXCIvXCIpXG4gIGNvbnN0IHNjb3BlID0gbW9kdWxlUGFydHNbMF0uc3RhcnRzV2l0aChcIkBcIilcbiAgICA/IG1vZHVsZVBhcnRzLnNsaWNlKDAsIDIpLmpvaW4oXCIvXCIpXG4gICAgOiBtb2R1bGVQYXJ0c1swXVxuICBjb25zdCByZW1haW5pbmdQYXRoID0gbW9kdWxlUGFydHMuc2xpY2Uoc2NvcGUuaW5jbHVkZXMoXCIvXCIpID8gMiA6IDEpLmpvaW4oXCIvXCIpXG4gIGNvbnN0IG5vZGVNb2R1bGVzUGF0aCA9IGAke3NlYXJjaFBhdGggPT0gXCIuXCIgPyBcIlwiIDogYCR7c2VhcmNoUGF0aH0vYH1ub2RlX21vZHVsZXMvJHtzY29wZX1gXG5cbiAgLy8gVHJ5IHRvIGZpbmQgcGFja2FnZS5qc29uXG4gIGNvbnN0IHBhY2thZ2VKc29uID0gZmluZFBhY2thZ2VKc29uKG5vZGVNb2R1bGVzUGF0aCwgY3R4KVxuICBpZiAocGFja2FnZUpzb24pIHtcbiAgICAvLyBUcnkgcmVzb2x2aW5nIHRocm91Z2ggZXhwb3J0cyBmaWVsZFxuICAgIGNvbnN0IGV4cG9ydHNSZXNvbHV0aW9uID0gcmVzb2x2ZVBhY2thZ2VFeHBvcnRzKFxuICAgICAgbm9kZU1vZHVsZXNQYXRoLFxuICAgICAgcGFja2FnZUpzb24sXG4gICAgICByZW1haW5pbmdQYXRoLFxuICAgICAgY3R4LFxuICAgIClcbiAgICBpZiAoZXhwb3J0c1Jlc29sdXRpb24pIHJldHVybiBleHBvcnRzUmVzb2x1dGlvblxuXG4gICAgLy8gVHJ5IHJlc29sdmluZyB0aHJvdWdoIG1haW4vbW9kdWxlIGZpZWxkc1xuICAgIGNvbnN0IGVudHJ5UG9pbnRSZXNvbHV0aW9uID0gcmVzb2x2ZVBhY2thZ2VFbnRyeVBvaW50KFxuICAgICAgbm9kZU1vZHVsZXNQYXRoLFxuICAgICAgcGFja2FnZUpzb24sXG4gICAgICBjdHgsXG4gICAgKVxuICAgIGlmIChlbnRyeVBvaW50UmVzb2x1dGlvbikgcmV0dXJuIGVudHJ5UG9pbnRSZXNvbHV0aW9uXG4gIH1cblxuICAvLyBUcnkgcmVzb2x2aW5nIHJlbWFpbmluZyBwYXRoXG4gIGNvbnN0IHJlbWFpbmluZ1BhdGhSZXNvbHV0aW9uID0gcmVzb2x2ZVJlbWFpbmluZ1BhdGgoXG4gICAgbm9kZU1vZHVsZXNQYXRoLFxuICAgIHJlbWFpbmluZ1BhdGgsXG4gICAgY3R4LFxuICApXG4gIGlmIChyZW1haW5pbmdQYXRoUmVzb2x1dGlvbikgcmV0dXJuIHJlbWFpbmluZ1BhdGhSZXNvbHV0aW9uXG5cbiAgLy8gSWYgbm90IGZvdW5kIGFuZCB3ZSBoYXZlIGEgcGFyZW50IGRpcmVjdG9yeSwgdHJ5IHRoZXJlXG4gIGNvbnN0IHBhcmVudFBhdGggPSBkaXJuYW1lKHNlYXJjaFBhdGgpXG4gIGlmIChwYXJlbnRQYXRoICYmIHBhcmVudFBhdGggIT09IHNlYXJjaFBhdGgpIHtcbiAgICByZXR1cm4gcmVzb2x2ZU5vZGVNb2R1bGVJblBhdGgocGFyZW50UGF0aCwgY3R4KVxuICB9XG5cbiAgcmV0dXJuIG51bGxcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJlc29sdmVOb2RlTW9kdWxlKFxuICBtb2R1bGVQYXRoOiBzdHJpbmcsXG4gIGZzTWFwOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+LFxuICBiYXNlUGF0aDogc3RyaW5nLFxuKTogc3RyaW5nIHwgbnVsbCB7XG4gIGNvbnN0IGN0eCA9IGNyZWF0ZUNvbnRleHQobW9kdWxlUGF0aCwgZnNNYXAsIGJhc2VQYXRoKVxuICByZXR1cm4gcmVzb2x2ZU5vZGVNb2R1bGVJblBhdGgoY3R4LmJhc2VQYXRoLCBjdHgpXG59XG4iLCAiaW1wb3J0IHsgcmVzb2x2ZU5vZGVNb2R1bGUgfSBmcm9tIFwibGliL3V0aWxzL3Jlc29sdmUtbm9kZS1tb2R1bGVcIlxuaW1wb3J0IHR5cGUgeyBFeGVjdXRpb25Db250ZXh0IH0gZnJvbSBcIi4vZXhlY3V0aW9uLWNvbnRleHRcIlxuaW1wb3J0IHsgaW1wb3J0TG9jYWxGaWxlIH0gZnJvbSBcIi4vaW1wb3J0LWxvY2FsLWZpbGVcIlxuXG5leHBvcnQgY29uc3QgaW1wb3J0Tm9kZU1vZHVsZSA9IGFzeW5jIChcbiAgaW1wb3J0TmFtZTogc3RyaW5nLFxuICBjdHg6IEV4ZWN1dGlvbkNvbnRleHQsXG4gIGRlcHRoID0gMCxcbikgPT4ge1xuICBjb25zdCB7IHByZVN1cHBsaWVkSW1wb3J0cyB9ID0gY3R4XG5cbiAgaWYgKHByZVN1cHBsaWVkSW1wb3J0c1tpbXBvcnROYW1lXSkge1xuICAgIHJldHVyblxuICB9XG5cbiAgY29uc3QgcmVzb2x2ZWROb2RlTW9kdWxlUGF0aCA9IHJlc29sdmVOb2RlTW9kdWxlKGltcG9ydE5hbWUsIGN0eC5mc01hcCwgXCJcIilcblxuICBpZiAoIXJlc29sdmVkTm9kZU1vZHVsZVBhdGgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYE5vZGUgbW9kdWxlIFwiJHtpbXBvcnROYW1lfVwiIG5vdCBmb3VuZGApXG4gIH1cblxuICAvLyBVc2UgaW1wb3J0TG9jYWxGaWxlIHRvIGhhbmRsZSB0aGUgbm9kZSBtb2R1bGVcbiAgYXdhaXQgaW1wb3J0TG9jYWxGaWxlKHJlc29sdmVkTm9kZU1vZHVsZVBhdGgsIGN0eCwgZGVwdGgpXG5cbiAgLy8gTWFwIHRoZSBvcmlnaW5hbCBpbXBvcnQgbmFtZSB0byB0aGUgcmVzb2x2ZWQgbW9kdWxlJ3MgZXhwb3J0c1xuICBwcmVTdXBwbGllZEltcG9ydHNbaW1wb3J0TmFtZV0gPSBwcmVTdXBwbGllZEltcG9ydHNbcmVzb2x2ZWROb2RlTW9kdWxlUGF0aF1cblxuICAvLyBNYXAgd2l0aG91dCBub2RlX21vZHVsZXMgcHJlZml4IGZvciBkaXJlY3QgaW1wb3J0c1xuICBjb25zdCB1bnByZWZpeGVkUGF0aCA9IHJlc29sdmVkTm9kZU1vZHVsZVBhdGgucmVwbGFjZSgvXm5vZGVfbW9kdWxlc1xcLy8sIFwiXCIpXG4gIHByZVN1cHBsaWVkSW1wb3J0c1t1bnByZWZpeGVkUGF0aF0gPVxuICAgIHByZVN1cHBsaWVkSW1wb3J0c1tyZXNvbHZlZE5vZGVNb2R1bGVQYXRoXVxuXG4gIC8vIEhhbmRsZSBpbmRleCBmaWxlcyBzcGVjaWFsbHlcbiAgaWYgKFxuICAgIHJlc29sdmVkTm9kZU1vZHVsZVBhdGguZW5kc1dpdGgoXCIvaW5kZXgudHN4XCIpIHx8XG4gICAgcmVzb2x2ZWROb2RlTW9kdWxlUGF0aC5lbmRzV2l0aChcIi9pbmRleC50c1wiKSB8fFxuICAgIHJlc29sdmVkTm9kZU1vZHVsZVBhdGguZW5kc1dpdGgoXCIvaW5kZXguanNcIilcbiAgKSB7XG4gICAgY29uc3QgZGlyUGF0aCA9IHJlc29sdmVkTm9kZU1vZHVsZVBhdGgucmVwbGFjZSgvXFwvaW5kZXhcXC4odHN4P3xqcykkLywgXCJcIilcbiAgICBjb25zdCB1bnByZWZpeGVkRGlyUGF0aCA9IGRpclBhdGgucmVwbGFjZSgvXm5vZGVfbW9kdWxlc1xcLy8sIFwiXCIpXG4gICAgcHJlU3VwcGxpZWRJbXBvcnRzW3VucHJlZml4ZWREaXJQYXRoXSA9XG4gICAgICBwcmVTdXBwbGllZEltcG9ydHNbcmVzb2x2ZWROb2RlTW9kdWxlUGF0aF1cblxuICAgIC8vIEhhbmRsZSBzY29wZWQgcGFja2FnZXNcbiAgICBpZiAodW5wcmVmaXhlZERpclBhdGguc3RhcnRzV2l0aChcIkBcIikpIHtcbiAgICAgIGNvbnN0IHNjb3BlUGFydHMgPSB1bnByZWZpeGVkRGlyUGF0aC5zcGxpdChcIi9cIilcbiAgICAgIGlmIChzY29wZVBhcnRzLmxlbmd0aCA+PSAyKSB7XG4gICAgICAgIGNvbnN0IHNjb3BlZE5hbWUgPSBgJHtzY29wZVBhcnRzWzBdfS8ke3Njb3BlUGFydHNbMV19YFxuICAgICAgICBwcmVTdXBwbGllZEltcG9ydHNbc2NvcGVkTmFtZV0gPVxuICAgICAgICAgIHByZVN1cHBsaWVkSW1wb3J0c1tyZXNvbHZlZE5vZGVNb2R1bGVQYXRoXVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuIiwgImltcG9ydCB7IHJlc29sdmVGaWxlUGF0aE9yVGhyb3cgfSBmcm9tIFwiLi9yZXNvbHZlRmlsZVBhdGhcIlxuaW1wb3J0IERlYnVnIGZyb20gXCJkZWJ1Z1wiXG5cbmNvbnN0IGRlYnVnID0gRGVidWcoXCJ0c2NpOmV2YWw6c2V0dXBEZWZhdWx0RW50cnlwb2ludElmTmVlZGVkXCIpXG5cbmV4cG9ydCBjb25zdCBzZXR1cERlZmF1bHRFbnRyeXBvaW50SWZOZWVkZWQgPSAob3B0czoge1xuICBlbnRyeXBvaW50Pzogc3RyaW5nXG4gIGZzTWFwOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+XG4gIG1haW5Db21wb25lbnRQYXRoPzogc3RyaW5nXG4gIG1haW5Db21wb25lbnROYW1lPzogc3RyaW5nXG4gIG5hbWU/OiBzdHJpbmdcbiAgbWFpbkNvbXBvbmVudFByb3BzPzogUmVjb3JkPHN0cmluZywgYW55PlxufSkgPT4ge1xuICBpZiAoIW9wdHMuZW50cnlwb2ludCAmJiAhb3B0cy5tYWluQ29tcG9uZW50UGF0aCkge1xuICAgIGlmIChcImluZGV4LnRzeFwiIGluIG9wdHMuZnNNYXApIHtcbiAgICAgIG9wdHMubWFpbkNvbXBvbmVudFBhdGggPSBcImluZGV4LnRzeFwiXG4gICAgfSBlbHNlIGlmIChcImluZGV4LnRzXCIgaW4gb3B0cy5mc01hcCkge1xuICAgICAgb3B0cy5tYWluQ29tcG9uZW50UGF0aCA9IFwiaW5kZXgudHNcIlxuICAgIH0gZWxzZSBpZiAoXG4gICAgICBPYmplY3Qua2V5cyhvcHRzLmZzTWFwKS5maWx0ZXIoKGspID0+IGsuZW5kc1dpdGgoXCIudHN4XCIpKS5sZW5ndGggPT09IDFcbiAgICApIHtcbiAgICAgIG9wdHMubWFpbkNvbXBvbmVudFBhdGggPSBPYmplY3Qua2V5cyhvcHRzLmZzTWFwKVswXVxuICAgIH0gZWxzZSBpZiAoXCJ0c2NpcmN1aXQuY29uZmlnLmpzb25cIiBpbiBvcHRzLmZzTWFwKSB7XG4gICAgICBjb25zdCBjb25maWdDb250ZW50ID0gb3B0cy5mc01hcFtcInRzY2lyY3VpdC5jb25maWcuanNvblwiXVxuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgY29uZmlnID0gSlNPTi5wYXJzZShjb25maWdDb250ZW50KVxuICAgICAgICBpZiAoY29uZmlnLm1haW5FbnRyeXBvaW50KSB7XG4gICAgICAgICAgb3B0cy5lbnRyeXBvaW50ID0gY29uZmlnLm1haW5FbnRyeXBvaW50XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY29uc29sZS53YXJuKFwiRmFpbGVkIHRvIHBhcnNlIHRzY2lyY3VpdC5jb25maWcuanNvbjpcIiwgZSlcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBcIkVpdGhlciBlbnRyeXBvaW50IG9yIG1haW5Db21wb25lbnRQYXRoIG11c3QgYmUgcHJvdmlkZWQgKG5vIGluZGV4IGZpbGUsIGNvdWxkIG5vdCBpbmZlciBlbnRyeXBvaW50KVwiLFxuICAgICAgKVxuICAgIH1cbiAgfVxuXG4gIGlmICghb3B0cy5lbnRyeXBvaW50ICYmIG9wdHMubWFpbkNvbXBvbmVudFBhdGgpIHtcbiAgICBvcHRzLmVudHJ5cG9pbnQgPSBcImVudHJ5cG9pbnQudHN4XCJcbiAgICBjb25zdCBtYWluQ29tcG9uZW50Q29kZSA9XG4gICAgICBvcHRzLmZzTWFwW3Jlc29sdmVGaWxlUGF0aE9yVGhyb3cob3B0cy5tYWluQ29tcG9uZW50UGF0aCwgb3B0cy5mc01hcCldXG4gICAgaWYgKCFtYWluQ29tcG9uZW50Q29kZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgTWFpbiBjb21wb25lbnQgcGF0aCBcIiR7b3B0cy5tYWluQ29tcG9uZW50UGF0aH1cIiBub3QgZm91bmQgaW4gZnNNYXAuIEF2YWlsYWJsZSBwYXRoczogJHtPYmplY3Qua2V5cyhvcHRzLmZzTWFwKS5qb2luKFwiLCBcIil9YCxcbiAgICAgIClcbiAgICB9XG5cbiAgICBjb25zdCBoYXNFeHBsaWNpdEJvYXJkID0gbWFpbkNvbXBvbmVudENvZGUuaW5jbHVkZXMoXCI8Ym9hcmRcIilcbiAgICBjb25zdCBoYXNUc2NpSW1wb3J0ID1cbiAgICAgIG1haW5Db21wb25lbnRDb2RlLmluY2x1ZGVzKFwiQHRzY2kvXCIpIHx8XG4gICAgICBtYWluQ29tcG9uZW50Q29kZS5pbmNsdWRlcygnZnJvbSBcIkB0c2NpJylcbiAgICBjb25zdCBzaG91bGRXcmFwSW5Cb2FyZCA9ICFoYXNFeHBsaWNpdEJvYXJkICYmICFoYXNUc2NpSW1wb3J0XG5cbiAgICBvcHRzLmZzTWFwW29wdHMuZW50cnlwb2ludF0gPSBgXG4gICAgIGltcG9ydCAqIGFzIFVzZXJDb21wb25lbnRzIGZyb20gXCIuLyR7b3B0cy5tYWluQ29tcG9uZW50UGF0aH1cIjtcbiAgICAgICAgICBcbiAgICAgICR7XG4gICAgICAgIG9wdHMubWFpbkNvbXBvbmVudE5hbWVcbiAgICAgICAgICA/IGBcbiAgICAgICAgY29uc3QgQ29tcG9uZW50VG9SZW5kZXIgPSBVc2VyQ29tcG9uZW50c1tcIiR7b3B0cy5tYWluQ29tcG9uZW50TmFtZX1cIl1cbiAgICAgICAgYFxuICAgICAgICAgIDogYGNvbnN0IENvbXBvbmVudFRvUmVuZGVyID0gT2JqZWN0LmVudHJpZXMoVXNlckNvbXBvbmVudHMpXG4gICAgICAgIC5maWx0ZXIoKFtuYW1lXSkgPT4gIW5hbWUuc3RhcnRzV2l0aChcInVzZVwiKSlcbiAgICAgICAgLm1hcCgoW18sIGNvbXBvbmVudF0pID0+IGNvbXBvbmVudClbMF0gfHwgKCgpID0+IG51bGwpO2BcbiAgICAgIH1cblxuICAgICAgICAgICAke1xuICAgICAgICAgICAgIGRlYnVnLmVuYWJsZWRcbiAgICAgICAgICAgICAgID8gYFxuICAgICBjb25zb2xlLmxvZyh7IFVzZXJDb21wb25lbnRzIH0pXG4gICAgIGNvbnNvbGUubG9nKFwiQ29tcG9uZW50VG9SZW5kZXIgXCIgKyBDb21wb25lbnRUb1JlbmRlci50b1N0cmluZygpLCAgeyBDb21wb25lbnRUb1JlbmRlciB9KVxuICAgICBgXG4gICAgICAgICAgICAgICA6IFwiXCJcbiAgICAgICAgICAgfVxuXG4gICAgICBjaXJjdWl0LmFkZChcbiAgICAgICAgJHtcbiAgICAgICAgICBzaG91bGRXcmFwSW5Cb2FyZFxuICAgICAgICAgICAgPyBgXG4gICAgICAgICAgPGJvYXJkPlxuICAgICAgICAgICAgPENvbXBvbmVudFRvUmVuZGVyIG5hbWU9XCJVMVwiICR7b3B0cy5tYWluQ29tcG9uZW50UHJvcHMgPyBgey4uLiR7SlNPTi5zdHJpbmdpZnkob3B0cy5tYWluQ29tcG9uZW50UHJvcHMsIG51bGwsIDIpfX1gIDogXCJcIn0gLz5cbiAgICAgICAgICA8L2JvYXJkPlxuICAgICAgICBgXG4gICAgICAgICAgICA6IGBcbiAgICAgICAgICA8Q29tcG9uZW50VG9SZW5kZXIgJHtvcHRzLm1haW5Db21wb25lbnRQcm9wcyA/IGB7Li4uJHtKU09OLnN0cmluZ2lmeShvcHRzLm1haW5Db21wb25lbnRQcm9wcywgbnVsbCwgMil9fWAgOiBcIlwifSAvPlxuICAgICAgICBgXG4gICAgICAgIH1cbiAgICAgICk7XG5gXG4gIH1cblxuICBpZiAoIW9wdHMubmFtZSAmJiBvcHRzLm1haW5Db21wb25lbnROYW1lKSB7XG4gICAgb3B0cy5uYW1lID0gb3B0cy5tYWluQ29tcG9uZW50TmFtZVxuICB9XG59XG4iLCAiaW1wb3J0IHsgQ2lyY3VpdFJ1bm5lciB9IGZyb20gXCIuL0NpcmN1aXRSdW5uZXJcIlxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcnVuVHNjaXJjdWl0Q29kZShcbiAgZmlsZXN5c3RlbU9yQ29kZVN0cmluZzogUmVjb3JkPHN0cmluZywgc3RyaW5nPiB8IHN0cmluZyxcbiAgb3B0cz86IE9taXQ8UGFyYW1ldGVyczxDaXJjdWl0UnVubmVyW1wiZXhlY3V0ZVdpdGhGc01hcFwiXT5bMF0sIFwiZnNNYXBcIj4sXG4pIHtcbiAgaWYgKFxuICAgIHR5cGVvZiBmaWxlc3lzdGVtT3JDb2RlU3RyaW5nID09PSBcInN0cmluZ1wiICYmXG4gICAgIWZpbGVzeXN0ZW1PckNvZGVTdHJpbmcuaW5jbHVkZXMoXCJleHBvcnRcIilcbiAgKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYFRoZSBcImV4cG9ydFwiIGtleXdvcmQgd2Fzbid0IGZvdW5kIGluIHlvdXIgcHJvdmlkZWQgY29kZS4gWW91IG5lZWQgdG8gZXhwb3J0IGEgY29tcG9uZW50IGluIHlvdXIgY29kZSwgZS5nLlxcblxcbmV4cG9ydCBkZWZhdWx0ICgpID0+IChcXG4gIDxyZXNpc3RvciBuYW1lPVwiUjFcIiByZXNpc3RhbmNlPVwiMWtcIiAvPlxcbilgLFxuICAgIClcbiAgfVxuICBjb25zdCBmaWxlc3lzdGVtID1cbiAgICB0eXBlb2YgZmlsZXN5c3RlbU9yQ29kZVN0cmluZyA9PT0gXCJzdHJpbmdcIlxuICAgICAgPyB7IFwidXNlci1jb2RlLnRzeFwiOiBmaWxlc3lzdGVtT3JDb2RlU3RyaW5nIH1cbiAgICAgIDogZmlsZXN5c3RlbU9yQ29kZVN0cmluZ1xuXG4gIGNvbnN0IGNpcmN1aXRSdW5uZXIgPSBuZXcgQ2lyY3VpdFJ1bm5lcigpXG5cbiAgYXdhaXQgY2lyY3VpdFJ1bm5lci5leGVjdXRlV2l0aEZzTWFwKHtcbiAgICBmc01hcDogZmlsZXN5c3RlbSxcbiAgICAuLi5vcHRzLFxuICB9KVxuXG4gIGF3YWl0IGNpcmN1aXRSdW5uZXIucmVuZGVyVW50aWxTZXR0bGVkKClcblxuICByZXR1cm4gYXdhaXQgY2lyY3VpdFJ1bm5lci5nZXRDaXJjdWl0SnNvbigpXG59XG4iLCAiaW1wb3J0IHsgcnVuVHNjaXJjdWl0Q29kZSB9IGZyb20gXCIuL3J1blRzY2lyY3VpdENvZGVcIlxuXG5leHBvcnQgY29uc3QgcnVuVHNjaXJjdWl0TW9kdWxlID0gYXN5bmMgKFxuICBtb2R1bGU6IHN0cmluZyxcbiAgb3B0czogeyBwcm9wcz86IFJlY29yZDxzdHJpbmcsIGFueT47IGV4cG9ydE5hbWU/OiBzdHJpbmcgfSA9IHt9LFxuKSA9PiB7XG4gIGlmICghbW9kdWxlLnN0YXJ0c1dpdGgoXCJAXCIpKSB7XG4gICAgbW9kdWxlID0gYEB0c2NpLyR7bW9kdWxlLnJlcGxhY2UoL1xcLy8sIFwiLlwiKX1gXG4gIH1cbiAgY29uc3QgY2lyY3VpdEpzb24gPSBhd2FpdCBydW5Uc2NpcmN1aXRDb2RlKFxuICAgIHtcbiAgICAgIC8vIFRPRE8gaGFuZGxlIGV4cG9ydHMgdGhhdCBhcmUgbm90IHRoZSBkZWZhdWx0IGV4cG9ydCBieSBzY2FubmluZ1xuICAgICAgLy8gb3RoZXJFeHBvcnRzIGZvciBjb21wb25lbnRzXG4gICAgICBcInVzZXItY29kZS50c3hcIjogYFxuICAgIGltcG9ydCBNb2R1bGUsICogYXMgb3RoZXJFeHBvcnRzIGZyb20gXCIke21vZHVsZX1cIjtcblxuICAgIGxldCBleHBvcnROYW1lID0gXCIke29wdHMuZXhwb3J0TmFtZSA/PyBcIlwifVwiXG5cbiAgICBpZiAoKCFNb2R1bGUgfHwgdHlwZW9mIE1vZHVsZSAhPT0gXCJmdW5jdGlvblwiKSAmJiAhQm9vbGVhbihleHBvcnROYW1lKSkge1xuICAgICAgZXhwb3J0TmFtZSA9IE9iamVjdC5rZXlzKG90aGVyRXhwb3J0cykuZmlsdGVyKGtleSA9PiBrZXlbMF0gPT09IGtleVswXS50b1VwcGVyQ2FzZSgpICYmIHR5cGVvZiBvdGhlckV4cG9ydHNba2V5XSA9PT0gXCJmdW5jdGlvblwiKVswXVxuICAgIH1cblxuICAgIGNvbnN0IGRlZmF1bHRFeHBvcnQgPSBleHBvcnROYW1lID8gb3RoZXJFeHBvcnRzW2V4cG9ydE5hbWVdIDogTW9kdWxlXG5cbiAgICBpZiAoIWRlZmF1bHRFeHBvcnQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcXGBObyBleHBvcnQgZm91bmQgZm9yIG1vZHVsZSBcIlxcJHttb2R1bGV9XCIgKHRyaWVkIFwiXFwke2V4cG9ydE5hbWUgPz8gXCJkZWZhdWx0XCJ9XCIpXFxgKVxuICAgIH1cblxuICAgIGV4cG9ydCBkZWZhdWx0IGRlZmF1bHRFeHBvcnQ7XG4gICAgYCxcbiAgICB9LFxuICAgIHtcbiAgICAgIG1haW5Db21wb25lbnRQcm9wczogb3B0cy5wcm9wcyxcbiAgICB9LFxuICApXG4gIHJldHVybiBjaXJjdWl0SnNvblxufVxuIiwgImltcG9ydCAqIGFzIENvbWxpbmsgZnJvbSBcImNvbWxpbmtcIlxuZXhwb3J0ICogZnJvbSBcIi4vdXRpbHMvaW5kZXhcIlxuaW1wb3J0IHR5cGUge1xuICBJbnRlcm5hbFdlYldvcmtlckFwaSxcbiAgV2ViV29ya2VyQ29uZmlndXJhdGlvbixcbiAgQ2lyY3VpdFdlYldvcmtlcixcbn0gZnJvbSBcIi4vc2hhcmVkL3R5cGVzXCJcbmltcG9ydCB0eXBlIHsgUm9vdENpcmN1aXRFdmVudE5hbWUgfSBmcm9tIFwiQHRzY2lyY3VpdC9jb3JlXCJcblxuZXhwb3J0IHR5cGUgeyBDaXJjdWl0V2ViV29ya2VyLCBXZWJXb3JrZXJDb25maWd1cmF0aW9uIH1cblxuZGVjbGFyZSBnbG9iYWwge1xuICBpbnRlcmZhY2UgV2luZG93IHtcbiAgICBUU0NJUkNVSVRfR0xPQkFMX0NJUkNVSVRfV09SS0VSOiBDaXJjdWl0V2ViV29ya2VyIHwgdW5kZWZpbmVkXG4gIH1cbiAgdmFyIFRTQ0lSQ1VJVF9HTE9CQUxfQ0lSQ1VJVF9XT1JLRVI6IENpcmN1aXRXZWJXb3JrZXIgfCB1bmRlZmluZWRcbn1cblxuZXhwb3J0IGNvbnN0IGNyZWF0ZUNpcmN1aXRXZWJXb3JrZXIgPSBhc3luYyAoXG4gIGNvbmZpZ3VyYXRpb246IFBhcnRpYWw8V2ViV29ya2VyQ29uZmlndXJhdGlvbj4sXG4pOiBQcm9taXNlPENpcmN1aXRXZWJXb3JrZXI+ID0+IHtcbiAgLy8gS2lsbCBleGlzdGluZyBnbG9iYWwgd29ya2VyIGluc3RhbmNlIGlmIHByZXNlbnRcbiAgY29uc3QgZXhpc3RpbmdXb3JrZXIgPSBnbG9iYWxUaGlzLlRTQ0lSQ1VJVF9HTE9CQUxfQ0lSQ1VJVF9XT1JLRVJcbiAgaWYgKGV4aXN0aW5nV29ya2VyICYmIHR5cGVvZiBleGlzdGluZ1dvcmtlci5raWxsID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICBpZiAoY29uZmlndXJhdGlvbi52ZXJib3NlKSB7XG4gICAgICBjb25zb2xlLmxvZyhcIltXb3JrZXJdIEtpbGxpbmcgcHJldmlvdXMgZ2xvYmFsIHdvcmtlciBpbnN0YW5jZS4uLlwiKVxuICAgIH1cbiAgICB0cnkge1xuICAgICAgYXdhaXQgZXhpc3RpbmdXb3JrZXIua2lsbCgpXG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgaWYgKGNvbmZpZ3VyYXRpb24udmVyYm9zZSkge1xuICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgXCJbV29ya2VyXSBFcnJvciBraWxsaW5nIHByZXZpb3VzIGdsb2JhbCB3b3JrZXIgaW5zdGFuY2U6XCIsXG4gICAgICAgICAgZSxcbiAgICAgICAgKVxuICAgICAgfVxuICAgICAgLy8gRW5zdXJlIHRoZSBrZXkgaXMgY2xlYXJlZCBldmVuIGlmIGtpbGwgdGhyb3dzIGFuIGVycm9yXG4gICAgICBpZiAoZ2xvYmFsVGhpcy5UU0NJUkNVSVRfR0xPQkFMX0NJUkNVSVRfV09SS0VSID09PSBleGlzdGluZ1dvcmtlcikge1xuICAgICAgICBnbG9iYWxUaGlzLlRTQ0lSQ1VJVF9HTE9CQUxfQ0lSQ1VJVF9XT1JLRVIgPSB1bmRlZmluZWRcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAoY29uZmlndXJhdGlvbi52ZXJib3NlKSB7XG4gICAgY29uc29sZS5sb2coXG4gICAgICBcIltXb3JrZXJdIENyZWF0aW5nIGNpcmN1aXQgd2ViIHdvcmtlciB3aXRoIGNvbmZpZzpcIixcbiAgICAgIGNvbmZpZ3VyYXRpb24sXG4gICAgKVxuICB9XG5cbiAgbGV0IHdvcmtlckJsb2JVcmwgPVxuICAgIGNvbmZpZ3VyYXRpb24ud2ViV29ya2VyQmxvYlVybCA/PyBjb25maWd1cmF0aW9uLndlYldvcmtlclVybFxuXG4gIGlmICghd29ya2VyQmxvYlVybCkge1xuICAgIGNvbnN0IGNkblVybCA9IGBodHRwczovL2Nkbi5qc2RlbGl2ci5uZXQvbnBtL0B0c2NpcmN1aXQvZXZhbEAke2NvbmZpZ3VyYXRpb24uZXZhbFZlcnNpb24gPz8gXCJsYXRlc3RcIn0vZGlzdC93ZWJ3b3JrZXIvZW50cnlwb2ludC5qc2BcblxuICAgIGNvbnN0IHdvcmtlckJsb2IgPSBhd2FpdCBmZXRjaChjZG5VcmwpLnRoZW4oKHJlcykgPT4gcmVzLmJsb2IoKSlcbiAgICB3b3JrZXJCbG9iVXJsID0gVVJMLmNyZWF0ZU9iamVjdFVSTCh3b3JrZXJCbG9iKVxuICB9XG5cbiAgY29uc3QgcmF3V29ya2VyID0gbmV3IFdvcmtlcih3b3JrZXJCbG9iVXJsLCB7IHR5cGU6IFwibW9kdWxlXCIgfSlcbiAgbGV0IHdvcmtlckluaXRFcnJvcjogYW55XG4gIHJhd1dvcmtlci5hZGRFdmVudExpc3RlbmVyKFwiZXJyb3JcIiwgKGV2ZW50KSA9PiB7XG4gICAgY29uc29sZS5lcnJvcihcIltXb3JrZXJdIEVycm9yIGluIHdvcmtlclwiLCBldmVudClcbiAgICB3b3JrZXJJbml0RXJyb3IgPSBldmVudFxuICB9KVxuICByYXdXb3JrZXIuYWRkRXZlbnRMaXN0ZW5lcihcInVuaGFuZGxlZHJlamVjdGlvblwiLCAoZXZlbnQpID0+IHtcbiAgICBjb25zb2xlLmVycm9yKFwiW1dvcmtlcl0gVW5oYW5kbGVkIHJlamVjdGlvbiBpbiB3b3JrZXJcIiwgZXZlbnQpXG4gIH0pXG4gIHJhd1dvcmtlci5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZWVycm9yXCIsIChldmVudCkgPT4ge1xuICAgIGNvbnNvbGUuZXJyb3IoXCJbV29ya2VyXSBNZXNzYWdlIGVycm9yIGluIHdvcmtlclwiLCBldmVudClcbiAgfSlcbiAgY29uc3QgZWFybHlNZXNzYWdlSGFuZGxlciA9IChldmVudDogTWVzc2FnZUV2ZW50KSA9PiB7XG4gICAgY29uc29sZS5sb2coXCJbV29ya2VyXSBNZXNzYWdlIGluIHdvcmtlclwiLCBldmVudClcbiAgfVxuICByYXdXb3JrZXIuYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgZWFybHlNZXNzYWdlSGFuZGxlcilcblxuICBpZiAod29ya2VySW5pdEVycm9yKSB7XG4gICAgdGhyb3cgd29ya2VySW5pdEVycm9yXG4gIH1cblxuICBjb25zdCBjb21saW5rV29ya2VyID0gQ29tbGluay53cmFwPEludGVybmFsV2ViV29ya2VyQXBpPihyYXdXb3JrZXIpXG5cbiAgcmF3V29ya2VyLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIGVhcmx5TWVzc2FnZUhhbmRsZXIpXG5cbiAgaWYgKGNvbmZpZ3VyYXRpb24uc25pcHBldHNBcGlCYXNlVXJsKSB7XG4gICAgYXdhaXQgY29tbGlua1dvcmtlci5zZXRTbmlwcGV0c0FwaUJhc2VVcmwoY29uZmlndXJhdGlvbi5zbmlwcGV0c0FwaUJhc2VVcmwpXG4gIH1cbiAgaWYgKGNvbmZpZ3VyYXRpb24ucGxhdGZvcm0pIHtcbiAgICBhd2FpdCBjb21saW5rV29ya2VyLnNldFBsYXRmb3JtQ29uZmlnKGNvbmZpZ3VyYXRpb24ucGxhdGZvcm0pXG4gIH1cblxuICBsZXQgaXNUZXJtaW5hdGVkID0gZmFsc2VcblxuICAvLyBDcmVhdGUgYSB3cmFwcGVyIHRoYXQgaGFuZGxlcyBldmVudHMgZGlyZWN0bHkgdGhyb3VnaCBjaXJjdWl0IGluc3RhbmNlXG4gIGNvbnN0IHdyYXBwZXI6IENpcmN1aXRXZWJXb3JrZXIgPSB7XG4gICAgY2xlYXJFdmVudExpc3RlbmVyczogY29tbGlua1dvcmtlci5jbGVhckV2ZW50TGlzdGVuZXJzLmJpbmQoY29tbGlua1dvcmtlciksXG4gICAgdmVyc2lvbjogY29tbGlua1dvcmtlci52ZXJzaW9uLmJpbmQoY29tbGlua1dvcmtlciksXG4gICAgZXhlY3V0ZTogYXN5bmMgKC4uLmFyZ3MpID0+IHtcbiAgICAgIGlmIChpc1Rlcm1pbmF0ZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2lyY3VpdFdlYldvcmtlciB3YXMgdGVybWluYXRlZCwgY2FuJ3QgZXhlY3V0ZVwiKVxuICAgICAgfVxuICAgICAgcmV0dXJuIGNvbWxpbmtXb3JrZXIuZXhlY3V0ZS5iaW5kKGNvbWxpbmtXb3JrZXIpKC4uLmFyZ3MpXG4gICAgfSxcbiAgICBleGVjdXRlV2l0aEZzTWFwOiBhc3luYyAoLi4uYXJncykgPT4ge1xuICAgICAgaWYgKGlzVGVybWluYXRlZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgXCJDaXJjdWl0V2ViV29ya2VyIHdhcyB0ZXJtaW5hdGVkLCBjYW4ndCBleGVjdXRlV2l0aEZzTWFwXCIsXG4gICAgICAgIClcbiAgICAgIH1cbiAgICAgIHJldHVybiBjb21saW5rV29ya2VyLmV4ZWN1dGVXaXRoRnNNYXAuYmluZChjb21saW5rV29ya2VyKSguLi5hcmdzKVxuICAgIH0sXG4gICAgcmVuZGVyVW50aWxTZXR0bGVkOiBjb21saW5rV29ya2VyLnJlbmRlclVudGlsU2V0dGxlZC5iaW5kKGNvbWxpbmtXb3JrZXIpLFxuICAgIGdldENpcmN1aXRKc29uOiBjb21saW5rV29ya2VyLmdldENpcmN1aXRKc29uLmJpbmQoY29tbGlua1dvcmtlciksXG4gICAgb246IChldmVudDogc3RyaW5nLCBjYWxsYmFjazogKC4uLmFyZ3M6IGFueVtdKSA9PiB2b2lkKSA9PiB7XG4gICAgICBjb25zdCBwcm94aWVkQ2FsbGJhY2sgPSBDb21saW5rLnByb3h5KGNhbGxiYWNrKVxuICAgICAgY29tbGlua1dvcmtlci5vbihldmVudCBhcyBSb290Q2lyY3VpdEV2ZW50TmFtZSwgcHJveGllZENhbGxiYWNrKVxuICAgIH0sXG4gICAga2lsbDogYXN5bmMgKCkgPT4ge1xuICAgICAgY29tbGlua1dvcmtlcltDb21saW5rLnJlbGVhc2VQcm94eV0oKVxuICAgICAgcmF3V29ya2VyLnRlcm1pbmF0ZSgpXG4gICAgICBpc1Rlcm1pbmF0ZWQgPSB0cnVlXG4gICAgICBpZiAoZ2xvYmFsVGhpcy5UU0NJUkNVSVRfR0xPQkFMX0NJUkNVSVRfV09SS0VSID09PSB3cmFwcGVyKSB7XG4gICAgICAgIGdsb2JhbFRoaXMuVFNDSVJDVUlUX0dMT0JBTF9DSVJDVUlUX1dPUktFUiA9IHVuZGVmaW5lZFxuICAgICAgfVxuICAgIH0sXG4gIH1cbiAgZ2xvYmFsVGhpcy5UU0NJUkNVSVRfR0xPQkFMX0NJUkNVSVRfV09SS0VSID0gd3JhcHBlclxuICByZXR1cm4gd3JhcHBlclxufVxuIiwgImltcG9ydCB7IG5vcm1hbGl6ZUZpbGVQYXRoIH0gZnJvbSBcIi4vcnVubmVyL25vcm1hbGl6ZUZzTWFwXCJcblxuZXhwb3J0IGNvbnN0IGdldFBvc3NpYmxlRW50cnlwb2ludENvbXBvbmVudFBhdGhzID0gKFxuICBmc01hcDogUmVjb3JkPHN0cmluZywgc3RyaW5nPixcbik6IHN0cmluZ1tdID0+IHtcbiAgY29uc3Qgbm9ybWFsaXplZEZzTWFwOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+ID0ge31cbiAgZm9yIChjb25zdCBbcGF0aCwgY29udGVudF0gb2YgT2JqZWN0LmVudHJpZXMoZnNNYXApKSB7XG4gICAgbm9ybWFsaXplZEZzTWFwW25vcm1hbGl6ZUZpbGVQYXRoKHBhdGgpXSA9IGNvbnRlbnRcbiAgfVxuXG4gIGNvbnN0IHBvc3NpYmxlID0gbmV3IFNldDxzdHJpbmc+KClcblxuICBpZiAoXCJ0c2NpcmN1aXQuY29uZmlnLmpzb25cIiBpbiBub3JtYWxpemVkRnNNYXApIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgY29uZmlnID0gSlNPTi5wYXJzZShub3JtYWxpemVkRnNNYXBbXCJ0c2NpcmN1aXQuY29uZmlnLmpzb25cIl0pXG4gICAgICBpZiAodHlwZW9mIGNvbmZpZy5tYWluRW50cnlwb2ludCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBwb3NzaWJsZS5hZGQobm9ybWFsaXplRmlsZVBhdGgoY29uZmlnLm1haW5FbnRyeXBvaW50KSlcbiAgICAgIH1cbiAgICB9IGNhdGNoIHtcbiAgICAgIC8qIGlnbm9yZSAqL1xuICAgIH1cbiAgfVxuXG4gIGlmIChub3JtYWxpemVkRnNNYXBbXCJpbmRleC50c3hcIl0pIHBvc3NpYmxlLmFkZChcImluZGV4LnRzeFwiKVxuICBpZiAobm9ybWFsaXplZEZzTWFwW1wiaW5kZXgudHNcIl0pIHBvc3NpYmxlLmFkZChcImluZGV4LnRzXCIpXG5cbiAgY29uc3QgY2lyY3VpdEZpbGVzID0gT2JqZWN0LmtleXMobm9ybWFsaXplZEZzTWFwKS5maWx0ZXIoKGspID0+XG4gICAgay5lbmRzV2l0aChcIi5jaXJjdWl0LnRzeFwiKSxcbiAgKVxuICBmb3IgKGNvbnN0IGZpbGUgb2YgY2lyY3VpdEZpbGVzKSB7XG4gICAgcG9zc2libGUuYWRkKGZpbGUpXG4gIH1cblxuICBjb25zdCB0c3hGaWxlcyA9IE9iamVjdC5rZXlzKG5vcm1hbGl6ZWRGc01hcCkuZmlsdGVyKChrKSA9PlxuICAgIGsuZW5kc1dpdGgoXCIudHN4XCIpLFxuICApXG4gIGlmICh0c3hGaWxlcy5sZW5ndGggPT09IDEpIHtcbiAgICBwb3NzaWJsZS5hZGQodHN4RmlsZXNbMF0pXG4gIH1cblxuICByZXR1cm4gQXJyYXkuZnJvbShwb3NzaWJsZSlcbn1cbiJdLAogICJtYXBwaW5ncyI6ICI7QUFBQSxTQUFTLG1CQUFtQjtBQUU1QixZQUFZLG1CQUFtQjtBQUMvQixZQUFZLFdBQVc7QUFDdkIsWUFBWSxnQkFBZ0I7QUFDNUIsWUFBWSx3QkFBd0I7OztBQ0hwQyxJQUFNLFFBQVEsb0JBQUksSUFBaUI7QUFFbkMsSUFBTSxvQkFBb0IsT0FBTyxNQUFXLFdBQWdCO0FBQzFELFFBQU0sY0FBYyxJQUFJLGdCQUFnQjtBQUFBLElBQ3RDLEdBQUc7QUFBQSxJQUNILE1BQU07QUFBQSxFQUNSLENBQUMsRUFBRSxTQUFTO0FBQ1osTUFBSSxNQUFNLElBQUksV0FBVyxHQUFHO0FBQzFCLFdBQU8sTUFBTSxJQUFJLFdBQVc7QUFBQSxFQUM5QjtBQUNBLFFBQU0sV0FBVyxNQUFNO0FBQUEsSUFDckIsbUNBQW1DLElBQUksU0FBUyxXQUFXO0FBQUEsRUFDN0Q7QUFDQSxRQUFNLGVBQWUsTUFBTSxTQUFTLEtBQUs7QUFDekMsUUFBTSxJQUFJLGFBQWEsWUFBWTtBQUNuQyxTQUFPO0FBQ1Q7QUFFTyxJQUFNLGlCQUE4QjtBQUFBLEVBQ3pDLFVBQVUsT0FBTztBQUFBLElBQ2Y7QUFBQSxJQUNBO0FBQUEsRUFDRixNQUFvQztBQUNsQyxRQUNFLGdCQUFnQixTQUFTLHNCQUN6QixnQkFBZ0IsVUFBVSxtQkFDMUI7QUFDQSxZQUFNLEVBQUUsVUFBVSxJQUFJLE1BQU0sa0JBQWtCLGFBQWE7QUFBQSxRQUN6RCxZQUNFLGdCQUFnQixzQkFBc0IsZ0JBQWdCO0FBQUEsUUFDeEQsU0FBUztBQUFBLE1BQ1gsQ0FBQztBQUVELGFBQU87QUFBQSxRQUNMLFNBQVMsYUFBYSxDQUFDLEdBQUcsSUFBSSxDQUFDLE1BQVcsSUFBSSxFQUFFLElBQUksRUFBRSxFQUFFLE1BQU0sR0FBRyxDQUFDO0FBQUEsTUFDcEU7QUFBQSxJQUNGLFdBQ0UsZ0JBQWdCLFNBQVMsc0JBQ3pCLGdC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QUFRO0FBQzlDLG9CQUFjLEdBQUcsT0FBK0IsZUFBZTtBQUFBLElBQ2pFO0FBQUEsSUFDQSxNQUFNLFlBQVk7QUFDaEIsb0JBQXNCLG9CQUFZLEVBQUU7QUFDcEMsZ0JBQVUsVUFBVTtBQUNwQixxQkFBZTtBQUNmLFVBQUksV0FBVyxvQ0FBb0MsU0FBUztBQUMxRCxtQkFBVyxrQ0FBa0M7QUFBQSxNQUMvQztBQUFBLElBQ0Y7QUFBQSxFQUNGO0FBQ0EsYUFBVyxrQ0FBa0M7QUFDN0MsU0FBTztBQUNUOzs7QUMvSE8sSUFBTSxzQ0FBc0MsQ0FDakQsVUFDYTtBQUNiLFFBQU0sa0JBQTBDLENBQUM7QUFDakQsYUFBVyxDQUFDLE1BQU0sT0FBTyxLQUFLLE9BQU8sUUFBUSxLQUFLLEdBQUc7QUFDbkQsb0JBQWdCLGtCQUFrQixJQUFJLENBQUMsSUFBSTtBQUFBLEVBQzdDO0FBRUEsUUFBTSxXQUFXLG9CQUFJLElBQVk7QUFFakMsTUFBSSwyQkFBMkIsaUJBQWlCO0FBQzlDLFFBQUk7QUFDRixZQUFNLFNBQVMsS0FBSyxNQUFNLGdCQUFnQix1QkFBdUIsQ0FBQztBQUNsRSxVQUFJLE9BQU8sT0FBTyxtQkFBbUIsVUFBVTtBQUM3QyxpQkFBUyxJQUFJLGtCQUFrQixPQUFPLGNBQWMsQ0FBQztBQUFBLE1BQ3ZEO0FBQUEsSUFDRixRQUFRO0FBQUEsSUFFUjtBQUFBLEVBQ0Y7QUFFQSxNQUFJLGdCQUFnQixXQUFXLEVBQUcsVUFBUyxJQUFJLFdBQVc7QUFDMUQsTUFBSSxnQkFBZ0IsVUFBVSxFQUFHLFVBQVMsSUFBSSxVQUFVO0FBRXhELFFBQU0sZUFBZSxPQUFPLEtBQUssZUFBZSxFQUFFO0FBQUEsSUFBTyxDQUFDLE1BQ3hELEVBQUUsU0FBUyxjQUFjO0FBQUEsRUFDM0I7QUFDQSxhQUFXLFFBQVEsY0FBYztBQUMvQixhQUFTLElBQUksSUFBSTtBQUFBLEVBQ25CO0FBRUEsUUFBTSxXQUFXLE9BQU8sS0FBSyxlQUFlLEVBQUU7QUFBQSxJQUFPLENBQUMsTUFDcEQsRUFBRSxTQUFTLE1BQU07QUFBQSxFQUNuQjtBQUNBLE1BQUksU0FBUyxXQUFXLEdBQUc7QUFDekIsYUFBUyxJQUFJLFNBQVMsQ0FBQyxDQUFDO0FBQUEsRUFDMUI7QUFFQSxTQUFPLE1BQU0sS0FBSyxRQUFRO0FBQzVCOyIsCiAgIm5hbWVzIjogWyJEZWJ1ZyIsICJkZWJ1ZyIsICJpbXBvcnROYW1lIiwgIkRlYnVnIiwgImRlYnVnIiwgIkRlYnVnIiwgImRlYnVnIiwgIkRlYnVnIiwgImRlYnVnIl0KfQo=