// webworker/execution-context.ts
import { RootCircuit } from "@tscircuit/core";
import * as tscircuitCore from "@tscircuit/core";
import * as React from "react";
import * as jscadFiber from "jscad-fiber";
import * as tscircuitMathUtils from "@tscircuit/math-utils";

// node_modules/@tscircuit/parts-engine/lib/jlc-parts-engine.ts
var cache = /* @__PURE__ */ new Map();
var getJlcPartsCached = async (name, params) => {
  const paramString = new URLSearchParams({
    ...params,
    json: "true"
  }).toString();
  if (cache.has(paramString)) {
    return cache.get(paramString);
  }
  const response = await fetch(
    `https://jlcsearch.tscircuit.com/${name}/list?${paramString}`
  );
  const responseJson = await response.json();
  cache.set(paramString, responseJson);
  return responseJson;
};
var jlcPartsEngine = {
  findPart: async ({
    sourceComponent,
    footprinterString
  }) => {
    if (sourceComponent.type === "source_component" && sourceComponent.ftype === "simple_resistor") {
      const { resistors } = await getJlcPartsCached("resistors", {
        resistance: sourceComponent.display_resistance ?? sourceComponent.resistance,
        package: footprinterString
      });
      return {
        jlcpcb: (resistors ?? []).map((r) => `C${r.lcsc}`).slice(0, 3)
      };
    } else if (sourceComponent.type === "source_component" && sourceComponent.ftype === "simple_capacitor") {
      if (footprinterString?.includes("cap")) {
        footprinterString = footprinterString.replace("cap", "");
      }
      const { capacitors } = await getJlcPartsCached("capacitors", {
        capacitance: sourceComponent.display_capacitance ?? sourceComponent.capacitance,
        package: footprinterString
      });
      return {
        jlcpcb: (capacitors ?? []).map((c) => `C${c.lcsc}`).slice(0, 3)
      };
    } else if (sourceComponent.type === "source_component" && sourceComponent.ftype === "simple_pin_header") {
      let pitch;
      if (footprinterString?.includes("_p")) {
        pitch = Number(footprinterString.split("_p")[1]);
      }
      const { headers } = await getJlcPartsCached(
        "headers",
        pitch ? {
          pitch,
          num_pins: sourceComponent.pin_count,
          gender: sourceComponent.gender
        } : {
          num_pins: sourceComponent.pin_count,
          gender: sourceComponent.gender
        }
      );
      return {
        jlcpcb: (headers ?? []).map((h) => `C${h.lcsc}`).slice(0, 3)
      };
    } else if (sourceComponent.type === "source_component" && sourceComponent.ftype === "simple_potentiometer") {
      const { potentiometers } = await getJlcPartsCached("potentiometers", {
        resistance: sourceComponent.max_resistance,
        package: footprinterString
      });
      return {
        jlcpcb: (potentiometers ?? []).map((p) => `C${p.lcsc}`).slice(0, 3)
      };
    } else if (sourceComponent.type === "source_component" && sourceComponent.ftype === "simple_diode") {
      const { diodes } = await getJlcPartsCached("diodes", {
        package: footprinterString
      });
      return {
        jlcpcb: (diodes ?? []).map((d) => `C${d.lcsc}`).slice(0, 3)
      };
    } else if (sourceComponent.type === "source_component" && sourceComponent.ftype === "simple_chip") {
      const { chips } = await getJlcPartsCached("chips", {
        package: footprinterString
      });
      return {
        jlcpcb: (chips ?? []).map((c) => `C${c.lcsc}`).slice(0, 3)
      };
    } else if (sourceComponent.type === "source_component" && sourceComponent.ftype === "simple_transistor") {
      const { transistors } = await getJlcPartsCached("transistors", {
        package: footprinterString,
        transistor_type: sourceComponent.transistor_type
      });
      return {
        jlcpcb: (transistors ?? []).map((t) => `C${t.lcsc}`).slice(0, 3)
      };
    } else if (sourceComponent.type === "source_component" && sourceComponent.ftype === "simple_power_source") {
      const { power_sources } = await getJlcPartsCached("power_sources", {
        voltage: sourceComponent.voltage,
        package: footprinterString
      });
      return {
        jlcpcb: (power_sources ?? []).map((p) => `C${p.lcsc}`).slice(0, 3)
      };
    } else if (sourceComponent.type === "source_component" && sourceComponent.ftype === "simple_inductor") {
      const { inductors } = await getJlcPartsCached("inductors", {
        inductance: sourceComponent.inductance,
        package: footprinterString
      });
      return {
        jlcpcb: (inductors ?? []).map((i) => `C${i.lcsc}`).slice(0, 3)
      };
    } else if (sourceComponent.type === "source_component" && sourceComponent.ftype === "simple_crystal") {
      const { crystals } = await getJlcPartsCached("crystals", {
        frequency: sourceComponent.frequency,
        load_capacitance: sourceComponent.load_capacitance,
        package: footprinterString
      });
      return {
        jlcpcb: (crystals ?? []).map((c) => `C${c.lcsc}`).slice(0, 3)
      };
    } else if (sourceComponent.type === "source_component" && sourceComponent.ftype === "simple_mosfet") {
      const { mosfets } = await getJlcPartsCached("mosfets", {
        package: footprinterString,
        mosfet_mode: sourceComponent.mosfet_mode,
        channel_type: sourceComponent.channel_type
      });
      return {
        jlcpcb: (mosfets ?? []).map((m) => `C${m.lcsc}`).slice(0, 3)
      };
    } else if (sourceComponent.type === "source_component" && sourceComponent.ftype === "simple_resonator") {
      const { resonators } = await getJlcPartsCached("resonators", {
        frequency: sourceComponent.frequency,
        package: footprinterString
      });
      return {
        jlcpcb: (resonators ?? []).map((r) => `C${r.lcsc}`).slice(0, 3)
      };
    } else if (sourceComponent.type === "source_component" && sourceComponent.ftype === "simple_switch") {
      const { switches } = await getJlcPartsCached("switches", {
        switch_type: sourceComponent.type,
        package: footprinterString
      });
      return {
        jlcpcb: (switches ?? []).map((s) => `C${s.lcsc}`).slice(0, 3)
      };
    } else if (sourceComponent.type === "source_component" && sourceComponent.ftype === "simple_led") {
      const { leds } = await getJlcPartsCached("leds", {
        package: footprinterString
      });
      return {
        jlcpcb: (leds ?? []).map((l) => `C${l.lcsc}`).slice(0, 3)
      };
    } else if (sourceComponent.type === "source_component" && sourceComponent.ftype === "simple_fuse") {
      const { fuses } = await getJlcPartsCached("fuses", {
        package: footprinterString
      });
      return {
        jlcpcb: (fuses ?? []).map((l) => `C${l.lcsc}`).slice(0, 3)
      };
    }
    return {};
  }
};

// lib/getPlatformConfig.ts
var getPlatformConfig = () => ({
  partsEngine: jlcPartsEngine
});

// webworker/execution-context.ts
import Debug from "debug";
var debug = Debug("tsci:eval:execution-context");
function createExecutionContext(webWorkerConfiguration, opts = {}) {
  globalThis.React = React;
  const circuit = new RootCircuit({
    platform: opts.platform || getPlatformConfig()
  });
  if (opts.name) {
    circuit.name = opts.name;
  }
  return {
    fsMap: {},
    entrypoint: "",
    preSuppliedImports: {
      "@tscircuit/core": tscircuitCore,
      tscircuit: tscircuitCore,
      "@tscircuit/math-utils": tscircuitMathUtils,
      react: React,
      "jscad-fiber": jscadFiber,
      // This is usually used as a type import, we can remove the shim when we
      // ignore type imports in getImportsFromCode
      "@tscircuit/props": {}
    },
    circuit,
    ...webWorkerConfiguration
  };
}

// lib/runner/normalizeFsMap.ts
function normalizeFilePath(filePath) {
  let normFilePath = filePath;
  normFilePath = normFilePath.replace(/\\/g, "/");
  normFilePath = normFilePath.trim();
  if (normFilePath.startsWith("./")) {
    normFilePath = normFilePath.slice(2);
  }
  if (normFilePath.startsWith("/")) {
    normFilePath = normFilePath.slice(1);
  }
  return normFilePath;
}
function normalizeFsMap(fsMap) {
  const normalizedFsMap = {};
  for (const [fsPath, fileContent] of Object.entries(fsMap)) {
    normalizedFsMap[normalizeFilePath(fsPath)] = fileContent;
  }
  return normalizedFsMap;
}

// lib/runner/CircuitRunner.ts
import "react";

// lib/utils/dirname.ts
function dirname(path) {
  if (!path) return ".";
  const normalizedPath = path.replace(/\\/g, "/");
  const cleanPath = normalizedPath.replace(/\/+$/, "");
  if (cleanPath.indexOf("/") === -1) return ".";
  return cleanPath.substring(0, cleanPath.lastIndexOf("/")) || "/";
}

// lib/runner/resolveFilePath.ts
function resolveRelativePath(importPath, cwd) {
  if (importPath.startsWith("../")) {
    const parentDir = dirname(cwd);
    return resolveRelativePath(importPath.slice(3), parentDir);
  }
  if (importPath.startsWith("./")) {
    return resolveRelativePath(importPath.slice(2), cwd);
  }
  if (importPath.startsWith("/")) {
    return importPath.slice(1);
  }
  return `${cwd}/${importPath}`;
}
var resolveFilePath = (unknownFilePath, fsMapOrAllFilePaths, cwd) => {
  const resolvedPath = cwd ? resolveRelativePath(unknownFilePath, cwd) : unknownFilePath;
  const filePaths = new Set(
    Array.isArray(fsMapOrAllFilePaths) ? fsMapOrAllFilePaths : Object.keys(fsMapOrAllFilePaths)
  );
  if (filePaths.has(resolvedPath)) {
    return resolvedPath;
  }
  const normalizedFilePathMap = /* @__PURE__ */ new Map();
  for (const filePath of filePaths) {
    normalizedFilePathMap.set(normalizeFilePath(filePath), filePath);
  }
  const normalizedResolvedPath = normalizeFilePath(resolvedPath);
  if (normalizedFilePathMap.has(normalizedResolvedPath)) {
    return normalizedFilePathMap.get(normalizedResolvedPath);
  }
  const extension = ["tsx", "ts", "json", "js", "jsx"];
  for (const ext of extension) {
    const possibleFilePath = `${normalizedResolvedPath}.${ext}`;
    if (normalizedFilePathMap.has(possibleFilePath)) {
      return normalizedFilePathMap.get(possibleFilePath);
    }
  }
  if (!unknownFilePath.startsWith("./") && !unknownFilePath.startsWith("../")) {
    const normalizedUnknownFilePath = normalizeFilePath(unknownFilePath);
    if (normalizedFilePathMap.has(normalizedUnknownFilePath)) {
      return normalizedFilePathMap.get(normalizedUnknownFilePath);
    }
    for (const ext of extension) {
      const possibleFilePath = `${normalizedUnknownFilePath}.${ext}`;
      if (normalizedFilePathMap.has(possibleFilePath)) {
        return normalizedFilePathMap.get(possibleFilePath);
      }
    }
  }
  return null;
};
var resolveFilePathOrThrow = (unknownFilePath, fsMapOrAllFilePaths) => {
  const resolvedFilePath = resolveFilePath(unknownFilePath, fsMapOrAllFilePaths);
  if (!resolvedFilePath) {
    throw new Error(
      `File not found "${unknownFilePath}", available paths:

${Object.keys(fsMapOrAllFilePaths).join(", ")}`
    );
  }
  return resolvedFilePath;
};

// webworker/eval-compiled-js.ts
function evalCompiledJs(compiledCode, preSuppliedImports, cwd) {
  ;
  globalThis.__tscircuit_require = (name) => {
    const resolvedFilePath = resolveFilePath(name, preSuppliedImports, cwd);
    const hasResolvedFilePath = resolvedFilePath && preSuppliedImports[resolvedFilePath];
    if (!preSuppliedImports[name] && !hasResolvedFilePath) {
      throw new Error(`Import "${name}" not found ${cwd ? `in "${cwd}"` : ""}`);
    }
    const mod = preSuppliedImports[name] || preSuppliedImports[resolvedFilePath];
    return new Proxy(mod, {
      get(target, prop) {
        if (!(prop in target)) {
          if (prop === "default") {
            if (target.default !== void 0) {
              return target.default;
            }
            if (target.__esModule) {
              return void 0;
            }
            if (typeof target === "function" || typeof target === "object") {
              return target;
            }
            return void 0;
          }
          if (prop === "__esModule") {
            return true;
          }
          throw new Error(
            `Component "${String(prop)}" is not exported by "${name}"`
          );
        }
        return target[prop];
      }
    });
  };
  const functionBody = `
  var exports = {};
  var require = globalThis.__tscircuit_require;
  var module = { exports };
  var circuit = globalThis.__tscircuit_circuit;
  ${compiledCode};
  return module;`.trim();
  return Function(functionBody).call(globalThis);
}

// webworker/import-eval-path.ts
import "@babel/standalone";

// webworker/import-local-file.ts
import * as Babel from "@babel/standalone";

// lib/utils/get-imports-from-code.ts
var getImportsFromCode = (code) => {
  const importRegex = /^\s*import\s+(?:(?:[\w\s]+,\s*)?(?:\*\s+as\s+[\w\s]+|\{[\s\w,]+\}|\w+)\s+from\s+)?['"](.+?)['"]/gm;
  const imports = [];
  let match;
  while ((match = importRegex.exec(code)) !== null) {
    imports.push(match[1]);
  }
  const reExportRegex = /^\s*export\s+(?:\*|(?:\{[\s\w,]+\}))\s+from\s+['"](.+?)['"]/gm;
  let reExportMatch;
  while ((reExportMatch = reExportRegex.exec(code)) !== null) {
    imports.push(reExportMatch[1]);
  }
  return imports;
};

// webworker/import-local-file.ts
import Debug2 from "debug";
var debug2 = Debug2("tsci:eval:import-local-file");
var importLocalFile = async (importName, ctx, depth = 0) => {
  debug2("importLocalFile called with:", {
    importName
  });
  const { fsMap, preSuppliedImports } = ctx;
  const fsPath = resolveFilePathOrThrow(importName, fsMap);
  debug2("fsPath:", fsPath);
  if (!ctx.fsMap[fsPath]) {
    debug2("fsPath not found in fsMap:", fsPath);
    throw new Error(`File "${fsPath}" not found`);
  }
  const fileContent = fsMap[fsPath];
  debug2("fileContent:", fileContent?.slice(0, 100));
  if (fsPath.endsWith(".json")) {
    const jsonData = JSON.parse(fileContent);
    preSuppliedImports[fsPath] = {
      __esModule: true,
      default: jsonData
    };
  } else if (fsPath.endsWith(".tsx") || fsPath.endsWith(".ts")) {
    const importNames = getImportsFromCode(fileContent);
    for (const importName2 of importNames) {
      if (!preSuppliedImports[importName2]) {
        await importEvalPath(importName2, ctx, depth + 1, {
          cwd: dirname(fsPath)
        });
      }
    }
    const result = Babel.transform(fileContent, {
      presets: ["react", "typescript"],
      plugins: ["transform-modules-commonjs"],
      filename: "virtual.tsx"
    });
    if (!result || !result.code) {
      throw new Error("Failed to transform code");
    }
    try {
      debug2("evalCompiledJs called with:", {
        code: result.code?.slice(0, 100),
        dirname: dirname(fsPath)
      });
      const importRunResult = evalCompiledJs(
        result.code,
        preSuppliedImports,
        dirname(fsPath)
      );
      debug2("importRunResult:", {
        fsPath,
        importRunResult
      });
      preSuppliedImports[fsPath] = importRunResult.exports;
    } catch (error) {
      throw new Error(
        `Eval compiled js error for "${importName}": ${error.message}`
      );
    }
  } else if (fsPath.endsWith(".js")) {
    const result = Babel.transform(fileContent, {
      presets: ["env"],
      plugins: ["transform-modules-commonjs"],
      filename: fsPath
    });
    if (!result || !result.code) {
      throw new Error("Failed to transform JS code");
    }
    preSuppliedImports[fsPath] = evalCompiledJs(
      result.code,
      preSuppliedImports,
      dirname(fsPath)
    ).exports;
  } else {
    throw new Error(
      `Unsupported file extension "${fsPath.split(".").pop()}" for "${fsPath}"`
    );
  }
};

// webworker/import-snippet.ts
import "@babel/standalone";
async function importSnippet(importName, ctx, depth = 0) {
  const { preSuppliedImports } = ctx;
  const fullSnippetName = importName.replace("@tsci/", "").replace(".", "/");
  const { cjs, error } = await fetch(`${ctx.cjsRegistryUrl}/${fullSnippetName}`).then(async (res) => ({ cjs: await res.text(), error: null })).catch((e) => ({ error: e, cjs: null }));
  if (error) {
    console.error("Error fetching import", importName, error);
    return;
  }
  try {
    preSuppliedImports[importName] = evalCompiledJs(
      cjs,
      preSuppliedImports
    ).exports;
  } catch (e) {
    console.error("Error importing snippet", e);
  }
}

// lib/utils/resolve-node-module.ts
function createContext(modulePath, fsMap, basePath) {
  return {
    fsMap,
    extensions: [".js", ".jsx", ".ts", ".tsx", ".json"],
    basePath,
    modulePath
  };
}
function findPackageJson(nodeModulesPath, ctx) {
  const packageJsonPath = `${nodeModulesPath}/package.json`;
  if (!ctx.fsMap[packageJsonPath]) return null;
  try {
    return JSON.parse(ctx.fsMap[packageJsonPath]);
  } catch {
    return null;
  }
}
function tryResolveWithExtensions(path, ctx) {
  if (ctx.fsMap[path]) return path;
  for (const ext of ctx.extensions) {
    const pathWithExt = path.replace(/\.js$|\.jsx$/, "") + ext;
    if (ctx.fsMap[pathWithExt]) return pathWithExt;
  }
  return null;
}
function resolveExportPath(nodeModulesPath, exportPath, ctx) {
  const fullExportPath = `${nodeModulesPath}/${exportPath.replace(/^\.\//, "")}`;
  return tryResolveWithExtensions(fullExportPath, ctx);
}
function resolvePackageExports(nodeModulesPath, packageJson, remainingPath, ctx) {
  if (!packageJson.exports) return null;
  const defaultExport = packageJson.exports["."];
  if (remainingPath === "" && defaultExport) {
    if (typeof defaultExport === "string") {
      const resolved = resolveExportPath(nodeModulesPath, defaultExport, ctx);
      if (resolved) return resolved;
    }
  }
  const subpathExport = remainingPath ? packageJson.exports[`./${remainingPath}`] : null;
  if (subpathExport && typeof subpathExport === "string") {
    const resolved = resolveExportPath(nodeModulesPath, subpathExport, ctx);
    if (resolved) return resolved;
  }
  const importExport = packageJson.exports["import"];
  if (remainingPath === "" && importExport && typeof importExport === "string") {
    const resolved = resolveExportPath(nodeModulesPath, importExport, ctx);
    if (resolved) return resolved;
  }
  return null;
}
function resolvePackageEntryPoint(nodeModulesPath, packageJson, ctx) {
  const entryPoint = packageJson.module || packageJson.main || "index.js";
  const fullPath = `${nodeModulesPath}/${entryPoint}`;
  return tryResolveWithExtensions(fullPath, ctx);
}
function resolveRemainingPath(nodeModulesPath, remainingPath, ctx) {
  if (!remainingPath) {
    for (const ext of ctx.extensions) {
      const indexPath = `${nodeModulesPath}/index${ext}`;
      if (ctx.fsMap[indexPath]) return indexPath;
    }
    return null;
  }
  const fullPath = `${nodeModulesPath}/${remainingPath}`;
  const directMatch = tryResolveWithExtensions(fullPath, ctx);
  if (directMatch) return directMatch;
  for (const ext of ctx.extensions) {
    const indexPath = `${fullPath}/index${ext}`;
    if (ctx.fsMap[indexPath]) return indexPath;
  }
  return null;
}
function resolveNodeModuleInPath(searchPath, ctx) {
  const moduleParts = ctx.modulePath.split("/");
  const scope = moduleParts[0].startsWith("@") ? moduleParts.slice(0, 2).join("/") : moduleParts[0];
  const remainingPath = moduleParts.slice(scope.includes("/") ? 2 : 1).join("/");
  const nodeModulesPath = `${searchPath == "." ? "" : `${searchPath}/`}node_modules/${scope}`;
  const packageJson = findPackageJson(nodeModulesPath, ctx);
  if (packageJson) {
    const exportsResolution = resolvePackageExports(
      nodeModulesPath,
      packageJson,
      remainingPath,
      ctx
    );
    if (exportsResolution) return exportsResolution;
    const entryPointResolution = resolvePackageEntryPoint(
      nodeModulesPath,
      packageJson,
      ctx
    );
    if (entryPointResolution) return entryPointResolution;
  }
  const remainingPathResolution = resolveRemainingPath(
    nodeModulesPath,
    remainingPath,
    ctx
  );
  if (remainingPathResolution) return remainingPathResolution;
  const parentPath = dirname(searchPath);
  if (parentPath && parentPath !== searchPath) {
    return resolveNodeModuleInPath(parentPath, ctx);
  }
  return null;
}
function resolveNodeModule(modulePath, fsMap, basePath) {
  const ctx = createContext(modulePath, fsMap, basePath);
  return resolveNodeModuleInPath(ctx.basePath, ctx);
}

// webworker/import-node-module.ts
var importNodeModule = async (importName, ctx, depth = 0) => {
  const { preSuppliedImports } = ctx;
  if (preSuppliedImports[importName]) {
    return;
  }
  const resolvedNodeModulePath = resolveNodeModule(importName, ctx.fsMap, "");
  if (!resolvedNodeModulePath) {
    throw new Error(`Node module "${importName}" not found`);
  }
  await importLocalFile(resolvedNodeModulePath, ctx, depth);
  preSuppliedImports[importName] = preSuppliedImports[resolvedNodeModulePath];
  const unprefixedPath = resolvedNodeModulePath.replace(/^node_modules\//, "");
  preSuppliedImports[unprefixedPath] = preSuppliedImports[resolvedNodeModulePath];
  if (resolvedNodeModulePath.endsWith("/index.tsx") || resolvedNodeModulePath.endsWith("/index.ts") || resolvedNodeModulePath.endsWith("/index.js")) {
    const dirPath = resolvedNodeModulePath.replace(/\/index\.(tsx?|js)$/, "");
    const unprefixedDirPath = dirPath.replace(/^node_modules\//, "");
    preSuppliedImports[unprefixedDirPath] = preSuppliedImports[resolvedNodeModulePath];
    if (unprefixedDirPath.startsWith("@")) {
      const scopeParts = unprefixedDirPath.split("/");
      if (scopeParts.length >= 2) {
        const scopedName = `${scopeParts[0]}/${scopeParts[1]}`;
        preSuppliedImports[scopedName] = preSuppliedImports[resolvedNodeModulePath];
      }
    }
  }
};

// webworker/import-eval-path.ts
import Debug3 from "debug";
var debug3 = Debug3("tsci:eval:import-eval-path");
async function importEvalPath(importName, ctx, depth = 0, opts = {}) {
  debug3("importEvalPath called with:", {
    importName,
    depth,
    opts
  });
  debug3(`${"  ".repeat(depth)}\u27A1\uFE0F`, importName);
  const { preSuppliedImports } = ctx;
  if (preSuppliedImports[importName]) return;
  if (importName.startsWith("./") && preSuppliedImports[importName.slice(2)])
    return;
  if (depth > 5) {
    console.log("Max depth for imports reached");
    return;
  }
  const resolvedLocalImportPath = resolveFilePath(
    importName,
    ctx.fsMap,
    opts.cwd
  );
  if (resolvedLocalImportPath) {
    return importLocalFile(resolvedLocalImportPath, ctx, depth);
  }
  const resolvedNodeModulePath = resolveNodeModule(
    importName,
    ctx.fsMap,
    opts.cwd || ""
  );
  if (resolvedNodeModulePath) {
    return importNodeModule(importName, ctx, depth);
  }
  if (importName.startsWith("@tsci/")) {
    return importSnippet(importName, ctx, depth);
  }
  throw new Error(
    `Unresolved import "${importName}" ${opts.cwd ? `from directory "${opts.cwd}"` : ""}`
  );
}

// lib/runner/setupDefaultEntrypointIfNeeded.ts
import Debug4 from "debug";
var debug4 = Debug4("tsci:eval:setupDefaultEntrypointIfNeeded");
var setupDefaultEntrypointIfNeeded = (opts) => {
  if (!opts.entrypoint && !opts.mainComponentPath) {
    if ("index.tsx" in opts.fsMap) {
      opts.mainComponentPath = "index.tsx";
    } else if ("index.ts" in opts.fsMap) {
      opts.mainComponentPath = "index.ts";
    } else if (Object.keys(opts.fsMap).filter((k) => k.endsWith(".tsx")).length === 1) {
      opts.mainComponentPath = Object.keys(opts.fsMap)[0];
    } else if ("tscircuit.config.json" in opts.fsMap) {
      const configContent = opts.fsMap["tscircuit.config.json"];
      try {
        const config = JSON.parse(configContent);
        if (config.mainEntrypoint) {
          opts.entrypoint = config.mainEntrypoint;
        }
      } catch (e) {
        console.warn("Failed to parse tscircuit.config.json:", e);
      }
    } else {
      throw new Error(
        "Either entrypoint or mainComponentPath must be provided (no index file, could not infer entrypoint)"
      );
    }
  }
  if (!opts.entrypoint && opts.mainComponentPath) {
    opts.entrypoint = "entrypoint.tsx";
    const mainComponentCode = opts.fsMap[resolveFilePathOrThrow(opts.mainComponentPath, opts.fsMap)];
    if (!mainComponentCode) {
      throw new Error(
        `Main component path "${opts.mainComponentPath}" not found in fsMap. Available paths: ${Object.keys(opts.fsMap).join(", ")}`
      );
    }
    const hasExplicitBoard = mainComponentCode.includes("<board");
    const hasTsciImport = mainComponentCode.includes("@tsci/") || mainComponentCode.includes('from "@tsci');
    const shouldWrapInBoard = !hasExplicitBoard && !hasTsciImport;
    opts.fsMap[opts.entrypoint] = `
     import * as UserComponents from "./${opts.mainComponentPath}";
          
      ${opts.mainComponentName ? `
        const ComponentToRender = UserComponents["${opts.mainComponentName}"]
        ` : `const ComponentToRender = Object.entries(UserComponents)
        .filter(([name]) => !name.startsWith("use"))
        .map(([_, component]) => component)[0] || (() => null);`}

           ${debug4.enabled ? `
     console.log({ UserComponents })
     console.log("ComponentToRender " + ComponentToRender.toString(),  { ComponentToRender })
     ` : ""}

      circuit.add(
        ${shouldWrapInBoard ? `
          <board>
            <ComponentToRender name="U1" ${opts.mainComponentProps ? `{...${JSON.stringify(opts.mainComponentProps, null, 2)}}` : ""} />
          </board>
        ` : `
          <ComponentToRender ${opts.mainComponentProps ? `{...${JSON.stringify(opts.mainComponentProps, null, 2)}}` : ""} />
        `}
      );
`;
  }
  if (!opts.name && opts.mainComponentName) {
    opts.name = opts.mainComponentName;
  }
};

// lib/runner/CircuitRunner.ts
import Debug5 from "debug";
var debug5 = Debug5("tsci:eval:CircuitRunner");
var CircuitRunner = class {
  constructor(configuration = {}) {
    this._executionContext = null;
    this._circuitRunnerConfiguration = {
      snippetsApiBaseUrl: "https://registry-api.tscircuit.com",
      cjsRegistryUrl: "https://cjs.tscircuit.com",
      verbose: false
    };
    this._eventListeners = {};
    Object.assign(this._circuitRunnerConfiguration, configuration);
  }
  async version() {
    return "0.0.0";
  }
  async executeWithFsMap(ogOpts) {
    const opts = { ...ogOpts };
    if (this._circuitRunnerConfiguration.verbose) {
      Debug5.enable("tsci:eval:*");
    }
    debug5("executeWithFsMap called with:", {
      entrypoint: opts.entrypoint,
      fsMapKeys: Object.keys(opts.fsMap),
      name: opts.name
    });
    setupDefaultEntrypointIfNeeded(opts);
    debug5("entrypoint after setupDefaultEntrypointIfNeeded:", {
      entrypoint: opts.entrypoint
    });
    this._executionContext = createExecutionContext(
      this._circuitRunnerConfiguration,
      {
        name: opts.name,
        platform: this._circuitRunnerConfiguration.platform
      }
    );
    this._bindEventListeners(this._executionContext.circuit);
    this._executionContext.fsMap = normalizeFsMap(opts.fsMap);
    if (!this._executionContext.fsMap[opts.entrypoint]) {
      throw new Error(`Entrypoint "${opts.entrypoint}" not found`);
    }
    ;
    globalThis.__tscircuit_circuit = this._executionContext.circuit;
    const entrypoint = opts.entrypoint.startsWith("./") ? opts.entrypoint : `./${opts.entrypoint}`;
    debug5("final entrypoint:", entrypoint);
    await importEvalPath(entrypoint, this._executionContext);
  }
  async execute(code, opts = {}) {
    if (this._circuitRunnerConfiguration.verbose) {
      console.log(
        "[CircuitRunner] execute called with code length:",
        code.length
      );
    }
    this._executionContext = createExecutionContext(
      this._circuitRunnerConfiguration,
      {
        ...opts,
        platform: this._circuitRunnerConfiguration.platform
      }
    );
    this._bindEventListeners(this._executionContext.circuit);
    this._executionContext.fsMap["entrypoint.tsx"] = code;
    globalThis.__tscircuit_circuit = this._executionContext.circuit;
    await importEvalPath("./entrypoint.tsx", this._executionContext);
  }
  on(event, callback) {
    var _a;
    (_a = this._eventListeners)[event] ?? (_a[event] = []);
    this._eventListeners[event].push(callback);
    this._executionContext?.circuit.on(event, callback);
  }
  async renderUntilSettled() {
    if (!this._executionContext) {
      throw new Error("No circuit has been created");
    }
    await this._executionContext.circuit.renderUntilSettled();
  }
  async getCircuitJson() {
    if (!this._executionContext) {
      throw new Error("No circuit has been created");
    }
    return this._executionContext.circuit.getCircuitJson();
  }
  clearEventListeners() {
    if (this._executionContext?.circuit) {
      for (const event in this._eventListeners) {
        for (const listener of this._eventListeners[event]) {
          const circuit = this._executionContext.circuit;
          circuit.removeListener?.(event, listener);
        }
      }
    }
    for (const event in this._eventListeners) {
      delete this._eventListeners[event];
    }
  }
  async kill() {
    this._executionContext = null;
  }
  async setSnippetsApiBaseUrl(baseUrl) {
    this._circuitRunnerConfiguration.snippetsApiBaseUrl = baseUrl;
  }
  async setPlatformConfig(platform) {
    this._circuitRunnerConfiguration.platform = platform;
  }
  _bindEventListeners(circuit) {
    for (const event in this._eventListeners) {
      for (const listener of this._eventListeners[event]) {
        circuit.on(event, listener);
      }
    }
  }
};

// lib/runner/runTscircuitCode.ts
async function runTscircuitCode(filesystemOrCodeString, opts) {
  if (typeof filesystemOrCodeString === "string" && !filesystemOrCodeString.includes("export")) {
    throw new Error(
      `The "export" keyword wasn't found in your provided code. You need to export a component in your code, e.g.

export default () => (
  <resistor name="R1" resistance="1k" />
)`
    );
  }
  const filesystem = typeof filesystemOrCodeString === "string" ? { "user-code.tsx": filesystemOrCodeString } : filesystemOrCodeString;
  const circuitRunner = new CircuitRunner();
  await circuitRunner.executeWithFsMap({
    fsMap: filesystem,
    ...opts
  });
  await circuitRunner.renderUntilSettled();
  return await circuitRunner.getCircuitJson();
}

// lib/runner/runTscircuitModule.ts
var runTscircuitModule = async (module, opts = {}) => {
  if (!module.startsWith("@")) {
    module = `@tsci/${module.replace(/\//, ".")}`;
  }
  const circuitJson = await runTscircuitCode(
    {
      // TODO handle exports that are not the default export by scanning
      // otherExports for components
      "user-code.tsx": `
    import Module, * as otherExports from "${module}";

    let exportName = "${opts.exportName ?? ""}"

    if ((!Module || typeof Module !== "function") && !Boolean(exportName)) {
      exportName = Object.keys(otherExports).filter(key => key[0] === key[0].toUpperCase() && typeof otherExports[key] === "function")[0]
    }

    const defaultExport = exportName ? otherExports[exportName] : Module

    if (!defaultExport) {
      throw new Error(\`No export found for module "\${module}" (tried "\${exportName ?? "default"}")\`)
    }

    export default defaultExport;
    `
    },
    {
      mainComponentProps: opts.props
    }
  );
  return circuitJson;
};
export {
  CircuitRunner,
  runTscircuitCode,
  runTscircuitModule
};
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsiLi4vLi4vd2Vid29ya2VyL2V4ZWN1dGlvbi1jb250ZXh0LnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AdHNjaXJjdWl0L3BhcnRzLWVuZ2luZS9saWIvamxjLXBhcnRzLWVuZ2luZS50cyIsICIuLi8uLi9saWIvZ2V0UGxhdGZvcm1Db25maWcudHMiLCAiLi4vLi4vbGliL3J1bm5lci9ub3JtYWxpemVGc01hcC50cyIsICIuLi8uLi9saWIvcnVubmVyL0NpcmN1aXRSdW5uZXIudHMiLCAiLi4vLi4vbGliL3V0aWxzL2Rpcm5hbWUudHMiLCAiLi4vLi4vbGliL3J1bm5lci9yZXNvbHZlRmlsZVBhdGgudHMiLCAiLi4vLi4vd2Vid29ya2VyL2V2YWwtY29tcGlsZWQtanMudHMiLCAiLi4vLi4vd2Vid29ya2VyL2ltcG9ydC1ldmFsLXBhdGgudHMiLCAiLi4vLi4vd2Vid29ya2VyL2ltcG9ydC1sb2NhbC1maWxlLnRzIiwgIi4uLy4uL2xpYi91dGlscy9nZXQtaW1wb3J0cy1mcm9tLWNvZGUudHMiLCAiLi4vLi4vd2Vid29ya2VyL2ltcG9ydC1zbmlwcGV0LnRzIiwgIi4uLy4uL2xpYi91dGlscy9yZXNvbHZlLW5vZGUtbW9kdWxlLnRzIiwgIi4uLy4uL3dlYndvcmtlci9pbXBvcnQtbm9kZS1tb2R1bGUudHMiLCAiLi4vLi4vbGliL3J1bm5lci9zZXR1cERlZmF1bHRFbnRyeXBvaW50SWZOZWVkZWQudHMiLCAiLi4vLi4vbGliL3J1bm5lci9ydW5Uc2NpcmN1aXRDb2RlLnRzIiwgIi4uLy4uL2xpYi9ydW5uZXIvcnVuVHNjaXJjdWl0TW9kdWxlLnRzIl0sCiAgInNvdXJjZXNDb250ZW50IjogWyJpbXBvcnQgeyBSb290Q2lyY3VpdCB9IGZyb20gXCJAdHNjaXJjdWl0L2NvcmVcIlxuaW1wb3J0IHR5cGUgeyBXZWJXb3JrZXJDb25maWd1cmF0aW9uIH0gZnJvbSBcImxpYi9zaGFyZWQvdHlwZXNcIlxuaW1wb3J0ICogYXMgdHNjaXJjdWl0Q29yZSBmcm9tIFwiQHRzY2lyY3VpdC9jb3JlXCJcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gXCJyZWFjdFwiXG5pbXBvcnQgKiBhcyBqc2NhZEZpYmVyIGZyb20gXCJqc2NhZC1maWJlclwiXG5pbXBvcnQgKiBhcyB0c2NpcmN1aXRNYXRoVXRpbHMgZnJvbSBcIkB0c2NpcmN1aXQvbWF0aC11dGlsc1wiXG5pbXBvcnQgdHlwZSB7IFBsYXRmb3JtQ29uZmlnIH0gZnJvbSBcIkB0c2NpcmN1aXQvcHJvcHNcIlxuaW1wb3J0IHsgZ2V0UGxhdGZvcm1Db25maWcgfSBmcm9tIFwibGliL2dldFBsYXRmb3JtQ29uZmlnXCJcbmltcG9ydCBEZWJ1ZyBmcm9tIFwiZGVidWdcIlxuXG5jb25zdCBkZWJ1ZyA9IERlYnVnKFwidHNjaTpldmFsOmV4ZWN1dGlvbi1jb250ZXh0XCIpXG5cbmV4cG9ydCBpbnRlcmZhY2UgRXhlY3V0aW9uQ29udGV4dCBleHRlbmRzIFdlYldvcmtlckNvbmZpZ3VyYXRpb24ge1xuICBmc01hcDogUmVjb3JkPHN0cmluZywgc3RyaW5nPlxuICBlbnRyeXBvaW50OiBzdHJpbmdcbiAgcHJlU3VwcGxpZWRJbXBvcnRzOiBSZWNvcmQ8c3RyaW5nLCBhbnk+XG4gIGNpcmN1aXQ6IFJvb3RDaXJjdWl0XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVFeGVjdXRpb25Db250ZXh0KFxuICB3ZWJXb3JrZXJDb25maWd1cmF0aW9uOiBXZWJXb3JrZXJDb25maWd1cmF0aW9uLFxuICBvcHRzOiB7XG4gICAgbmFtZT86IHN0cmluZ1xuICAgIHBsYXRmb3JtPzogUGxhdGZvcm1Db25maWdcbiAgfSA9IHt9LFxuKTogRXhlY3V0aW9uQ29udGV4dCB7XG4gIGdsb2JhbFRoaXMuUmVhY3QgPSBSZWFjdFxuXG4gIGNvbnN0IGNpcmN1aXQgPSBuZXcgUm9vdENpcmN1aXQoe1xuICAgIHBsYXRmb3JtOiBvcHRzLnBsYXRmb3JtIHx8IGdldFBsYXRmb3JtQ29uZmlnKCksXG4gIH0pXG5cbiAgaWYgKG9wdHMubmFtZSkge1xuICAgIGNpcmN1aXQubmFtZSA9IG9wdHMubmFtZVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBmc01hcDoge30sXG4gICAgZW50cnlwb2ludDogXCJcIixcbiAgICBwcmVTdXBwbGllZEltcG9ydHM6IHtcbiAgICAgIFwiQHRzY2lyY3VpdC9jb3JlXCI6IHRzY2lyY3VpdENvcmUsXG4gICAgICB0c2NpcmN1aXQ6IHRzY2lyY3VpdENvcmUsXG4gICAgICBcIkB0c2NpcmN1aXQvbWF0aC11dGlsc1wiOiB0c2NpcmN1aXRNYXRoVXRpbHMsXG4gICAgICByZWFjdDogUmVhY3QsXG4gICAgICBcImpzY2FkLWZpYmVyXCI6IGpzY2FkRmliZXIsXG5cbiAgICAgIC8vIFRoaXMgaXMgdXN1YWxseSB1c2VkIGFzIGEgdHlwZSBpbXBvcnQsIHdlIGNhbiByZW1vdmUgdGhlIHNoaW0gd2hlbiB3ZVxuICAgICAgLy8gaWdub3JlIHR5cGUgaW1wb3J0cyBpbiBnZXRJbXBvcnRzRnJvbUNvZGVcbiAgICAgIFwiQHRzY2lyY3VpdC9wcm9wc1wiOiB7fSxcbiAgICB9LFxuICAgIGNpcmN1aXQsXG4gICAgLi4ud2ViV29ya2VyQ29uZmlndXJhdGlvbixcbiAgfVxufVxuIiwgImltcG9ydCB0eXBlIHsgUGFydHNFbmdpbmUsIFN1cHBsaWVyUGFydE51bWJlcnMgfSBmcm9tIFwiQHRzY2lyY3VpdC9wcm9wc1wiXG5cbmNvbnN0IGNhY2hlID0gbmV3IE1hcDxzdHJpbmcsIGFueT4oKVxuXG5jb25zdCBnZXRKbGNQYXJ0c0NhY2hlZCA9IGFzeW5jIChuYW1lOiBhbnksIHBhcmFtczogYW55KSA9PiB7XG4gIGNvbnN0IHBhcmFtU3RyaW5nID0gbmV3IFVSTFNlYXJjaFBhcmFtcyh7XG4gICAgLi4ucGFyYW1zLFxuICAgIGpzb246IFwidHJ1ZVwiLFxuICB9KS50b1N0cmluZygpXG4gIGlmIChjYWNoZS5oYXMocGFyYW1TdHJpbmcpKSB7XG4gICAgcmV0dXJuIGNhY2hlLmdldChwYXJhbVN0cmluZylcbiAgfVxuICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKFxuICAgIGBodHRwczovL2psY3NlYXJjaC50c2NpcmN1aXQuY29tLyR7bmFtZX0vbGlzdD8ke3BhcmFtU3RyaW5nfWAsXG4gIClcbiAgY29uc3QgcmVzcG9uc2VKc29uID0gYXdhaXQgcmVzcG9uc2UuanNvbigpXG4gIGNhY2hlLnNldChwYXJhbVN0cmluZywgcmVzcG9uc2VKc29uKVxuICByZXR1cm4gcmVzcG9uc2VKc29uXG59XG5cbmV4cG9ydCBjb25zdCBqbGNQYXJ0c0VuZ2luZTogUGFydHNFbmdpbmUgPSB7XG4gIGZpbmRQYXJ0OiBhc3luYyAoe1xuICAgIHNvdXJjZUNvbXBvbmVudCxcbiAgICBmb290cHJpbnRlclN0cmluZyxcbiAgfSk6IFByb21pc2U8U3VwcGxpZXJQYXJ0TnVtYmVycz4gPT4ge1xuICAgIGlmIChcbiAgICAgIHNvdXJjZUNvbXBvbmVudC50eXBlID09PSBcInNvdXJjZV9jb21wb25lbnRcIiAmJlxuICAgICAgc291cmNlQ29tcG9uZW50LmZ0eXBlID09PSBcInNpbXBsZV9yZXNpc3RvclwiXG4gICAgKSB7XG4gICAgICBjb25zdCB7IHJlc2lzdG9ycyB9ID0gYXdhaXQgZ2V0SmxjUGFydHNDYWNoZWQoXCJyZXNpc3RvcnNcIiwge1xuICAgICAgICByZXNpc3RhbmNlOlxuICAgICAgICAgIHNvdXJjZUNvbXBvbmVudC5kaXNwbGF5X3Jlc2lzdGFuY2UgPz8gc291cmNlQ29tcG9uZW50LnJlc2lzdGFuY2UsXG4gICAgICAgIHBhY2thZ2U6IGZvb3RwcmludGVyU3RyaW5nLFxuICAgICAgfSlcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgamxjcGNiOiAocmVzaXN0b3JzID8/IFtdKS5tYXAoKHI6IGFueSkgPT4gYEMke3IubGNzY31gKS5zbGljZSgwLCAzKSxcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKFxuICAgICAgc291cmNlQ29tcG9uZW50LnR5cGUgPT09IFwic291cmNlX2NvbXBvbmVudFwiICYmXG4gICAgICBzb3VyY2VDb21wb25lbnQuZnR5cGUgPT09IFwic2ltcGxlX2NhcGFjaXRvclwiXG4gICAgKSB7XG4gICAgICBpZiAoZm9vdHByaW50ZXJTdHJpbmc/LmluY2x1ZGVzKFwiY2FwXCIpKSB7XG4gICAgICAgIGZvb3RwcmludGVyU3RyaW5nID0gZm9vdHByaW50ZXJTdHJpbmcucmVwbGFjZShcImNhcFwiLCBcIlwiKVxuICAgICAgfVxuICAgICAgY29uc3QgeyBjYXBhY2l0b3JzIH0gPSBhd2FpdCBnZXRKbGNQYXJ0c0NhY2hlZChcImNhcGFjaXRvcnNcIiwge1xuICAgICAgICBjYXBhY2l0YW5jZTpcbiAgICAgICAgICBzb3VyY2VDb21wb25lbnQuZGlzcGxheV9jYXBhY2l0YW5jZSA/PyBzb3VyY2VDb21wb25lbnQuY2FwYWNpdGFuY2UsXG4gICAgICAgIHBhY2thZ2U6IGZvb3RwcmludGVyU3RyaW5nLFxuICAgICAgfSlcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgamxjcGNiOiAoY2FwYWNpdG9ycyA/PyBbXSkubWFwKChjOiBhbnkpID0+IGBDJHtjLmxjc2N9YCkuc2xpY2UoMCwgMyksXG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChcbiAgICAgIHNvdXJjZUNvbXBvbmVudC50eXBlID09PSBcInNvdXJjZV9jb21wb25lbnRcIiAmJlxuICAgICAgc291cmNlQ29tcG9uZW50LmZ0eXBlID09PSBcInNpbXBsZV9waW5faGVhZGVyXCJcbiAgICApIHtcbiAgICAgIGxldCBwaXRjaDogbnVtYmVyIHwgdW5kZWZpbmVkXG4gICAgICBpZiAoZm9vdHByaW50ZXJTdHJpbmc/LmluY2x1ZGVzKFwiX3BcIikpIHtcbiAgICAgICAgcGl0Y2ggPSBOdW1iZXIoZm9vdHByaW50ZXJTdHJpbmcuc3BsaXQoXCJfcFwiKVsxXSlcbiAgICAgIH1cbiAgICAgIGNvbnN0IHsgaGVhZGVycyB9ID0gYXdhaXQgZ2V0SmxjUGFydHNDYWNoZWQoXG4gICAgICAgIFwiaGVhZGVyc1wiLFxuICAgICAgICBwaXRjaFxuICAgICAgICAgID8ge1xuICAgICAgICAgICAgICBwaXRjaDogcGl0Y2gsXG4gICAgICAgICAgICAgIG51bV9waW5zOiBzb3VyY2VDb21wb25lbnQucGluX2NvdW50LFxuICAgICAgICAgICAgICBnZW5kZXI6IHNvdXJjZUNvbXBvbmVudC5nZW5kZXIsXG4gICAgICAgICAgICB9XG4gICAgICAgICAgOiB7XG4gICAgICAgICAgICAgIG51bV9waW5zOiBzb3VyY2VDb21wb25lbnQucGluX2NvdW50LFxuICAgICAgICAgICAgICBnZW5kZXI6IHNvdXJjZUNvbXBvbmVudC5nZW5kZXIsXG4gICAgICAgICAgICB9LFxuICAgICAgKVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgamxjcGNiOiAoaGVhZGVycyA/PyBbXSkubWFwKChoOiBhbnkpID0+IGBDJHtoLmxjc2N9YCkuc2xpY2UoMCwgMyksXG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChcbiAgICAgIHNvdXJjZUNvbXBvbmVudC50eXBlID09PSBcInNvdXJjZV9jb21wb25lbnRcIiAmJlxuICAgICAgc291cmNlQ29tcG9uZW50LmZ0eXBlID09PSBcInNpbXBsZV9wb3RlbnRpb21ldGVyXCJcbiAgICApIHtcbiAgICAgIGNvbnN0IHsgcG90ZW50aW9tZXRlcnMgfSA9IGF3YWl0IGdldEpsY1BhcnRzQ2FjaGVkKFwicG90ZW50aW9tZXRlcnNcIiwge1xuICAgICAgICByZXNpc3RhbmNlOiBzb3VyY2VDb21wb25lbnQubWF4X3Jlc2lzdGFuY2UsXG4gICAgICAgIHBhY2thZ2U6IGZvb3RwcmludGVyU3RyaW5nLFxuICAgICAgfSlcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGpsY3BjYjogKHBvdGVudGlvbWV0ZXJzID8/IFtdKVxuICAgICAgICAgIC5tYXAoKHA6IGFueSkgPT4gYEMke3AubGNzY31gKVxuICAgICAgICAgIC5zbGljZSgwLCAzKSxcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKFxuICAgICAgc291cmNlQ29tcG9uZW50LnR5cGUgPT09IFwic291cmNlX2NvbXBvbmVudFwiICYmXG4gICAgICBzb3VyY2VDb21wb25lbnQuZnR5cGUgPT09IFwic2ltcGxlX2Rpb2RlXCJcbiAgICApIHtcbiAgICAgIGNvbnN0IHsgZGlvZGVzIH0gPSBhd2FpdCBnZXRKbGNQYXJ0c0NhY2hlZChcImRpb2Rlc1wiLCB7XG4gICAgICAgIHBhY2thZ2U6IGZvb3RwcmludGVyU3RyaW5nLFxuICAgICAgfSlcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGpsY3BjYjogKGRpb2RlcyA/PyBbXSkubWFwKChkOiBhbnkpID0+IGBDJHtkLmxjc2N9YCkuc2xpY2UoMCwgMyksXG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChcbiAgICAgIHNvdXJjZUNvbXBvbmVudC50eXBlID09PSBcInNvdXJjZV9jb21wb25lbnRcIiAmJlxuICAgICAgc291cmNlQ29tcG9uZW50LmZ0eXBlID09PSBcInNpbXBsZV9jaGlwXCJcbiAgICApIHtcbiAgICAgIGNvbnN0IHsgY2hpcHMgfSA9IGF3YWl0IGdldEpsY1BhcnRzQ2FjaGVkKFwiY2hpcHNcIiwge1xuICAgICAgICBwYWNrYWdlOiBmb290cHJpbnRlclN0cmluZyxcbiAgICAgIH0pXG4gICAgICByZXR1cm4ge1xuICAgICAgICBqbGNwY2I6IChjaGlwcyA/PyBbXSkubWFwKChjOiBhbnkpID0+IGBDJHtjLmxjc2N9YCkuc2xpY2UoMCwgMyksXG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChcbiAgICAgIHNvdXJjZUNvbXBvbmVudC50eXBlID09PSBcInNvdXJjZV9jb21wb25lbnRcIiAmJlxuICAgICAgc291cmNlQ29tcG9uZW50LmZ0eXBlID09PSBcInNpbXBsZV90cmFuc2lzdG9yXCJcbiAgICApIHtcbiAgICAgIGNvbnN0IHsgdHJhbnNpc3RvcnMgfSA9IGF3YWl0IGdldEpsY1BhcnRzQ2FjaGVkKFwidHJhbnNpc3RvcnNcIiwge1xuICAgICAgICBwYWNrYWdlOiBmb290cHJpbnRlclN0cmluZyxcbiAgICAgICAgdHJhbnNpc3Rvcl90eXBlOiBzb3VyY2VDb21wb25lbnQudHJhbnNpc3Rvcl90eXBlLFxuICAgICAgfSlcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGpsY3BjYjogKHRyYW5zaXN0b3JzID8/IFtdKS5tYXAoKHQ6IGFueSkgPT4gYEMke3QubGNzY31gKS5zbGljZSgwLCAzKSxcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKFxuICAgICAgc291cmNlQ29tcG9uZW50LnR5cGUgPT09IFwic291cmNlX2NvbXBvbmVudFwiICYmXG4gICAgICBzb3VyY2VDb21wb25lbnQuZnR5cGUgPT09IFwic2ltcGxlX3Bvd2VyX3NvdXJjZVwiXG4gICAgKSB7XG4gICAgICBjb25zdCB7IHBvd2VyX3NvdXJjZXMgfSA9IGF3YWl0IGdldEpsY1BhcnRzQ2FjaGVkKFwicG93ZXJfc291cmNlc1wiLCB7XG4gICAgICAgIHZvbHRhZ2U6IHNvdXJjZUNvbXBvbmVudC52b2x0YWdlLFxuICAgICAgICBwYWNrYWdlOiBmb290cHJpbnRlclN0cmluZyxcbiAgICAgIH0pXG4gICAgICByZXR1cm4ge1xuICAgICAgICBqbGNwY2I6IChwb3dlcl9zb3VyY2VzID8/IFtdKS5tYXAoKHA6IGFueSkgPT4gYEMke3AubGNzY31gKS5zbGljZSgwLCAzKSxcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKFxuICAgICAgc291cmNlQ29tcG9uZW50LnR5cGUgPT09IFwic291cmNlX2NvbXBvbmVudFwiICYmXG4gICAgICBzb3VyY2VDb21wb25lbnQuZnR5cGUgPT09IFwic2ltcGxlX2luZHVjdG9yXCJcbiAgICApIHtcbiAgICAgIGNvbnN0IHsgaW5kdWN0b3JzIH0gPSBhd2FpdCBnZXRKbGNQYXJ0c0NhY2hlZChcImluZHVjdG9yc1wiLCB7XG4gICAgICAgIGluZHVjdGFuY2U6IHNvdXJjZUNvbXBvbmVudC5pbmR1Y3RhbmNlLFxuICAgICAgICBwYWNrYWdlOiBmb290cHJpbnRlclN0cmluZyxcbiAgICAgIH0pXG4gICAgICByZXR1cm4ge1xuICAgICAgICBqbGNwY2I6IChpbmR1Y3RvcnMgPz8gW10pLm1hcCgoaTogYW55KSA9PiBgQyR7aS5sY3NjfWApLnNsaWNlKDAsIDMpLFxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoXG4gICAgICBzb3VyY2VDb21wb25lbnQudHlwZSA9PT0gXCJzb3VyY2VfY29tcG9uZW50XCIgJiZcbiAgICAgIHNvdXJjZUNvbXBvbmVudC5mdHlwZSA9PT0gXCJzaW1wbGVfY3J5c3RhbFwiXG4gICAgKSB7XG4gICAgICBjb25zdCB7IGNyeXN0YWxzIH0gPSBhd2FpdCBnZXRKbGNQYXJ0c0NhY2hlZChcImNyeXN0YWxzXCIsIHtcbiAgICAgICAgZnJlcXVlbmN5OiBzb3VyY2VDb21wb25lbnQuZnJlcXVlbmN5LFxuICAgICAgICBsb2FkX2NhcGFjaXRhbmNlOiBzb3VyY2VDb21wb25lbnQubG9hZF9jYXBhY2l0YW5jZSxcbiAgICAgICAgcGFja2FnZTogZm9vdHByaW50ZXJTdHJpbmcsXG4gICAgICB9KVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgamxjcGNiOiAoY3J5c3RhbHMgPz8gW10pLm1hcCgoYzogYW55KSA9PiBgQyR7Yy5sY3NjfWApLnNsaWNlKDAsIDMpLFxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoXG4gICAgICBzb3VyY2VDb21wb25lbnQudHlwZSA9PT0gXCJzb3VyY2VfY29tcG9uZW50XCIgJiZcbiAgICAgIHNvdXJjZUNvbXBvbmVudC5mdHlwZSA9PT0gXCJzaW1wbGVfbW9zZmV0XCJcbiAgICApIHtcbiAgICAgIGNvbnN0IHsgbW9zZmV0cyB9ID0gYXdhaXQgZ2V0SmxjUGFydHNDYWNoZWQoXCJtb3NmZXRzXCIsIHtcbiAgICAgICAgcGFja2FnZTogZm9vdHByaW50ZXJTdHJpbmcsXG4gICAgICAgIG1vc2ZldF9tb2RlOiBzb3VyY2VDb21wb25lbnQubW9zZmV0X21vZGUsXG4gICAgICAgIGNoYW5uZWxfdHlwZTogc291cmNlQ29tcG9uZW50LmNoYW5uZWxfdHlwZSxcbiAgICAgIH0pXG4gICAgICByZXR1cm4ge1xuICAgICAgICBqbGNwY2I6IChtb3NmZXRzID8/IFtdKS5tYXAoKG06IGFueSkgPT4gYEMke20ubGNzY31gKS5zbGljZSgwLCAzKSxcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKFxuICAgICAgc291cmNlQ29tcG9uZW50LnR5cGUgPT09IFwic291cmNlX2NvbXBvbmVudFwiICYmXG4gICAgICBzb3VyY2VDb21wb25lbnQuZnR5cGUgPT09IFwic2ltcGxlX3Jlc29uYXRvclwiXG4gICAgKSB7XG4gICAgICBjb25zdCB7IHJlc29uYXRvcnMgfSA9IGF3YWl0IGdldEpsY1BhcnRzQ2FjaGVkKFwicmVzb25hdG9yc1wiLCB7XG4gICAgICAgIGZyZXF1ZW5jeTogc291cmNlQ29tcG9uZW50LmZyZXF1ZW5jeSxcbiAgICAgICAgcGFja2FnZTogZm9vdHByaW50ZXJTdHJpbmcsXG4gICAgICB9KVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgamxjcGNiOiAocmVzb25hdG9ycyA/PyBbXSkubWFwKChyOiBhbnkpID0+IGBDJHtyLmxjc2N9YCkuc2xpY2UoMCwgMyksXG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChcbiAgICAgIHNvdXJjZUNvbXBvbmVudC50eXBlID09PSBcInNvdXJjZV9jb21wb25lbnRcIiAmJlxuICAgICAgc291cmNlQ29tcG9uZW50LmZ0eXBlID09PSBcInNpbXBsZV9zd2l0Y2hcIlxuICAgICkge1xuICAgICAgY29uc3QgeyBzd2l0Y2hlcyB9ID0gYXdhaXQgZ2V0SmxjUGFydHNDYWNoZWQoXCJzd2l0Y2hlc1wiLCB7XG4gICAgICAgIHN3aXRjaF90eXBlOiBzb3VyY2VDb21wb25lbnQudHlwZSxcbiAgICAgICAgcGFja2FnZTogZm9vdHByaW50ZXJTdHJpbmcsXG4gICAgICB9KVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgamxjcGNiOiAoc3dpdGNoZXMgPz8gW10pLm1hcCgoczogYW55KSA9PiBgQyR7cy5sY3NjfWApLnNsaWNlKDAsIDMpLFxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoXG4gICAgICBzb3VyY2VDb21wb25lbnQudHlwZSA9PT0gXCJzb3VyY2VfY29tcG9uZW50XCIgJiZcbiAgICAgIHNvdXJjZUNvbXBvbmVudC5mdHlwZSA9PT0gXCJzaW1wbGVfbGVkXCJcbiAgICApIHtcbiAgICAgIGNvbnN0IHsgbGVkcyB9ID0gYXdhaXQgZ2V0SmxjUGFydHNDYWNoZWQoXCJsZWRzXCIsIHtcbiAgICAgICAgcGFja2FnZTogZm9vdHByaW50ZXJTdHJpbmcsXG4gICAgICB9KVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgamxjcGNiOiAobGVkcyA/PyBbXSkubWFwKChsOiBhbnkpID0+IGBDJHtsLmxjc2N9YCkuc2xpY2UoMCwgMyksXG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChcbiAgICAgIHNvdXJjZUNvbXBvbmVudC50eXBlID09PSBcInNvdXJjZV9jb21wb25lbnRcIiAmJlxuICAgICAgc291cmNlQ29tcG9uZW50LmZ0eXBlID09PSBcInNpbXBsZV9mdXNlXCJcbiAgICApIHtcbiAgICAgIGNvbnN0IHsgZnVzZXMgfSA9IGF3YWl0IGdldEpsY1BhcnRzQ2FjaGVkKFwiZnVzZXNcIiwge1xuICAgICAgICBwYWNrYWdlOiBmb290cHJpbnRlclN0cmluZyxcbiAgICAgIH0pXG4gICAgICByZXR1cm4ge1xuICAgICAgICBqbGNwY2I6IChmdXNlcyA/PyBbXSkubWFwKChsOiBhbnkpID0+IGBDJHtsLmxjc2N9YCkuc2xpY2UoMCwgMyksXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7fVxuICB9LFxufVxuIiwgImltcG9ydCB0eXBlIHsgUGxhdGZvcm1Db25maWcgfSBmcm9tIFwiQHRzY2lyY3VpdC9wcm9wc1wiXG5pbXBvcnQgeyBqbGNQYXJ0c0VuZ2luZSB9IGZyb20gXCJAdHNjaXJjdWl0L3BhcnRzLWVuZ2luZVwiXG5cbmV4cG9ydCBjb25zdCBnZXRQbGF0Zm9ybUNvbmZpZyA9ICgpOiBQbGF0Zm9ybUNvbmZpZyA9PiAoe1xuICBwYXJ0c0VuZ2luZTogamxjUGFydHNFbmdpbmUsXG59KVxuIiwgImV4cG9ydCBmdW5jdGlvbiBub3JtYWxpemVGaWxlUGF0aChmaWxlUGF0aDogc3RyaW5nKSB7XG4gIGxldCBub3JtRmlsZVBhdGggPSBmaWxlUGF0aFxuICBub3JtRmlsZVBhdGggPSBub3JtRmlsZVBhdGgucmVwbGFjZSgvXFxcXC9nLCBcIi9cIilcbiAgbm9ybUZpbGVQYXRoID0gbm9ybUZpbGVQYXRoLnRyaW0oKVxuICBpZiAobm9ybUZpbGVQYXRoLnN0YXJ0c1dpdGgoXCIuL1wiKSkge1xuICAgIG5vcm1GaWxlUGF0aCA9IG5vcm1GaWxlUGF0aC5zbGljZSgyKVxuICB9XG4gIGlmIChub3JtRmlsZVBhdGguc3RhcnRzV2l0aChcIi9cIikpIHtcbiAgICBub3JtRmlsZVBhdGggPSBub3JtRmlsZVBhdGguc2xpY2UoMSlcbiAgfVxuICByZXR1cm4gbm9ybUZpbGVQYXRoXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBub3JtYWxpemVGc01hcChmc01hcDogUmVjb3JkPHN0cmluZywgc3RyaW5nPikge1xuICBjb25zdCBub3JtYWxpemVkRnNNYXA6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4gPSB7fVxuICBmb3IgKGNvbnN0IFtmc1BhdGgsIGZpbGVDb250ZW50XSBvZiBPYmplY3QuZW50cmllcyhmc01hcCkpIHtcbiAgICBub3JtYWxpemVkRnNNYXBbbm9ybWFsaXplRmlsZVBhdGgoZnNQYXRoKV0gPSBmaWxlQ29udGVudFxuICB9XG4gIHJldHVybiBub3JtYWxpemVkRnNNYXBcbn1cbiIsICJpbXBvcnQgdHlwZSB7IEFueUNpcmN1aXRFbGVtZW50IH0gZnJvbSBcImNpcmN1aXQtanNvblwiXG5pbXBvcnQgdHlwZSB7XG4gIENpcmN1aXRSdW5uZXJBcGksXG4gIENpcmN1aXRSdW5uZXJDb25maWd1cmF0aW9uLFxufSBmcm9tIFwibGliL3NoYXJlZC90eXBlc1wiXG5pbXBvcnQgdHlwZSB7IFBsYXRmb3JtQ29uZmlnIH0gZnJvbSBcIkB0c2NpcmN1aXQvcHJvcHNcIlxuaW1wb3J0IHsgY3JlYXRlRXhlY3V0aW9uQ29udGV4dCB9IGZyb20gXCIuLi8uLi93ZWJ3b3JrZXIvZXhlY3V0aW9uLWNvbnRleHRcIlxuaW1wb3J0IHsgbm9ybWFsaXplRnNNYXAgfSBmcm9tIFwiLi9ub3JtYWxpemVGc01hcFwiXG5pbXBvcnQgdHlwZSB7IFJvb3RDaXJjdWl0IH0gZnJvbSBcIkB0c2NpcmN1aXQvY29yZVwiXG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tIFwicmVhY3RcIlxuaW1wb3J0IHsgaW1wb3J0RXZhbFBhdGggfSBmcm9tIFwid2Vid29ya2VyL2ltcG9ydC1ldmFsLXBhdGhcIlxuaW1wb3J0IHsgc2V0dXBEZWZhdWx0RW50cnlwb2ludElmTmVlZGVkIH0gZnJvbSBcIi4vc2V0dXBEZWZhdWx0RW50cnlwb2ludElmTmVlZGVkXCJcbmltcG9ydCBEZWJ1ZyBmcm9tIFwiZGVidWdcIlxuXG5jb25zdCBkZWJ1ZyA9IERlYnVnKFwidHNjaTpldmFsOkNpcmN1aXRSdW5uZXJcIilcblxuZXhwb3J0IGNsYXNzIENpcmN1aXRSdW5uZXIgaW1wbGVtZW50cyBDaXJjdWl0UnVubmVyQXBpIHtcbiAgX2V4ZWN1dGlvbkNvbnRleHQ6IFJldHVyblR5cGU8dHlwZW9mIGNyZWF0ZUV4ZWN1dGlvbkNvbnRleHQ+IHwgbnVsbCA9IG51bGxcbiAgX2NpcmN1aXRSdW5uZXJDb25maWd1cmF0aW9uOiBDaXJjdWl0UnVubmVyQ29uZmlndXJhdGlvbiA9IHtcbiAgICBzbmlwcGV0c0FwaUJhc2VVcmw6IFwiaHR0cHM6Ly9yZWdpc3RyeS1hcGkudHNjaXJjdWl0LmNvbVwiLFxuICAgIGNqc1JlZ2lzdHJ5VXJsOiBcImh0dHBzOi8vY2pzLnRzY2lyY3VpdC5jb21cIixcbiAgICB2ZXJib3NlOiBmYWxzZSxcbiAgfVxuICBfZXZlbnRMaXN0ZW5lcnM6IFJlY29yZDxzdHJpbmcsICgoLi4uYXJnczogYW55W10pID0+IHZvaWQpW10+ID0ge31cblxuICBjb25zdHJ1Y3Rvcihjb25maWd1cmF0aW9uOiBQYXJ0aWFsPENpcmN1aXRSdW5uZXJDb25maWd1cmF0aW9uPiA9IHt9KSB7XG4gICAgT2JqZWN0LmFzc2lnbih0aGlzLl9jaXJjdWl0UnVubmVyQ29uZmlndXJhdGlvbiwgY29uZmlndXJhdGlvbilcbiAgfVxuXG4gIGFzeW5jIHZlcnNpb24oKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgICByZXR1cm4gXCIwLjAuMFwiXG4gIH1cblxuICBhc3luYyBleGVjdXRlV2l0aEZzTWFwKG9nT3B0czoge1xuICAgIGVudHJ5cG9pbnQ/OiBzdHJpbmdcbiAgICBtYWluQ29tcG9uZW50UGF0aD86IHN0cmluZ1xuICAgIG1haW5Db21wb25lbnROYW1lPzogc3RyaW5nXG4gICAgZnNNYXA6IFJlY29yZDxzdHJpbmcsIHN0cmluZz5cbiAgICBuYW1lPzogc3RyaW5nXG4gICAgbWFpbkNvbXBvbmVudFByb3BzPzogUmVjb3JkPHN0cmluZywgYW55PlxuICB9KTogUHJvbWlzZTx2b2lkPiB7XG4gICAgY29uc3Qgb3B0cyA9IHsgLi4ub2dPcHRzIH1cblxuICAgIGlmICh0aGlzLl9jaXJjdWl0UnVubmVyQ29uZmlndXJhdGlvbi52ZXJib3NlKSB7XG4gICAgICBEZWJ1Zy5lbmFibGUoXCJ0c2NpOmV2YWw6KlwiKVxuICAgIH1cblxuICAgIGRlYnVnKFwiZXhlY3V0ZVdpdGhGc01hcCBjYWxsZWQgd2l0aDpcIiwge1xuICAgICAgZW50cnlwb2ludDogb3B0cy5lbnRyeXBvaW50LFxuICAgICAgZnNNYXBLZXlzOiBPYmplY3Qua2V5cyhvcHRzLmZzTWFwKSxcbiAgICAgIG5hbWU6IG9wdHMubmFtZSxcbiAgICB9KVxuXG4gICAgc2V0dXBEZWZhdWx0RW50cnlwb2ludElmTmVlZGVkKG9wdHMpXG5cbiAgICBkZWJ1ZyhcImVudHJ5cG9pbnQgYWZ0ZXIgc2V0dXBEZWZhdWx0RW50cnlwb2ludElmTmVlZGVkOlwiLCB7XG4gICAgICBlbnRyeXBvaW50OiBvcHRzLmVudHJ5cG9pbnQsXG4gICAgfSlcblxuICAgIHRoaXMuX2V4ZWN1dGlvbkNvbnRleHQgPSBjcmVhdGVFeGVjdXRpb25Db250ZXh0KFxuICAgICAgdGhpcy5fY2lyY3VpdFJ1bm5lckNvbmZpZ3VyYXRpb24sXG4gICAgICB7XG4gICAgICAgIG5hbWU6IG9wdHMubmFtZSxcbiAgICAgICAgcGxhdGZvcm06IHRoaXMuX2NpcmN1aXRSdW5uZXJDb25maWd1cmF0aW9uLnBsYXRmb3JtLFxuICAgICAgfSxcbiAgICApXG4gICAgdGhpcy5fYmluZEV2ZW50TGlzdGVuZXJzKHRoaXMuX2V4ZWN1dGlvbkNvbnRleHQuY2lyY3VpdClcblxuICAgIHRoaXMuX2V4ZWN1dGlvbkNvbnRleHQuZnNNYXAgPSBub3JtYWxpemVGc01hcChvcHRzLmZzTWFwKVxuICAgIGlmICghdGhpcy5fZXhlY3V0aW9uQ29udGV4dC5mc01hcFtvcHRzLmVudHJ5cG9pbnQhXSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBFbnRyeXBvaW50IFwiJHtvcHRzLmVudHJ5cG9pbnR9XCIgbm90IGZvdW5kYClcbiAgICB9XG4gICAgOyhnbG9iYWxUaGlzIGFzIGFueSkuX190c2NpcmN1aXRfY2lyY3VpdCA9IHRoaXMuX2V4ZWN1dGlvbkNvbnRleHQuY2lyY3VpdFxuXG4gICAgY29uc3QgZW50cnlwb2ludCA9IG9wdHMuZW50cnlwb2ludCEuc3RhcnRzV2l0aChcIi4vXCIpXG4gICAgICA/IG9wdHMuZW50cnlwb2ludFxuICAgICAgOiBgLi8ke29wdHMuZW50cnlwb2ludH1gXG5cbiAgICBkZWJ1ZyhcImZpbmFsIGVudHJ5cG9pbnQ6XCIsIGVudHJ5cG9pbnQpXG4gICAgYXdhaXQgaW1wb3J0RXZhbFBhdGgoZW50cnlwb2ludCEsIHRoaXMuX2V4ZWN1dGlvbkNvbnRleHQpXG4gIH1cblxuICBhc3luYyBleGVjdXRlKGNvZGU6IHN0cmluZywgb3B0czogeyBuYW1lPzogc3RyaW5nIH0gPSB7fSkge1xuICAgIGlmICh0aGlzLl9jaXJjdWl0UnVubmVyQ29uZmlndXJhdGlvbi52ZXJib3NlKSB7XG4gICAgICBjb25zb2xlLmxvZyhcbiAgICAgICAgXCJbQ2lyY3VpdFJ1bm5lcl0gZXhlY3V0ZSBjYWxsZWQgd2l0aCBjb2RlIGxlbmd0aDpcIixcbiAgICAgICAgY29kZS5sZW5ndGgsXG4gICAgICApXG4gICAgfVxuXG4gICAgdGhpcy5fZXhlY3V0aW9uQ29udGV4dCA9IGNyZWF0ZUV4ZWN1dGlvbkNvbnRleHQoXG4gICAgICB0aGlzLl9jaXJjdWl0UnVubmVyQ29uZmlndXJhdGlvbixcbiAgICAgIHtcbiAgICAgICAgLi4ub3B0cyxcbiAgICAgICAgcGxhdGZvcm06IHRoaXMuX2NpcmN1aXRSdW5uZXJDb25maWd1cmF0aW9uLnBsYXRmb3JtLFxuICAgICAgfSxcbiAgICApXG4gICAgdGhpcy5fYmluZEV2ZW50TGlzdGVuZXJzKHRoaXMuX2V4ZWN1dGlvbkNvbnRleHQuY2lyY3VpdClcbiAgICB0aGlzLl9leGVjdXRpb25Db250ZXh0LmZzTWFwW1wiZW50cnlwb2ludC50c3hcIl0gPSBjb2RlXG4gICAgOyhnbG9iYWxUaGlzIGFzIGFueSkuX190c2NpcmN1aXRfY2lyY3VpdCA9IHRoaXMuX2V4ZWN1dGlvbkNvbnRleHQuY2lyY3VpdFxuXG4gICAgYXdhaXQgaW1wb3J0RXZhbFBhdGgoXCIuL2VudHJ5cG9pbnQudHN4XCIsIHRoaXMuX2V4ZWN1dGlvbkNvbnRleHQpXG4gIH1cblxuICBvbihldmVudDogc3RyaW5nLCBjYWxsYmFjazogKC4uLmFyZ3M6IGFueVtdKSA9PiB2b2lkKSB7XG4gICAgdGhpcy5fZXZlbnRMaXN0ZW5lcnNbZXZlbnRdID8/PSBbXVxuICAgIHRoaXMuX2V2ZW50TGlzdGVuZXJzW2V2ZW50XS5wdXNoKGNhbGxiYWNrKVxuICAgIHRoaXMuX2V4ZWN1dGlvbkNvbnRleHQ/LmNpcmN1aXQub24oZXZlbnQgYXMgYW55LCBjYWxsYmFjaylcbiAgfVxuXG4gIGFzeW5jIHJlbmRlclVudGlsU2V0dGxlZCgpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBpZiAoIXRoaXMuX2V4ZWN1dGlvbkNvbnRleHQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIGNpcmN1aXQgaGFzIGJlZW4gY3JlYXRlZFwiKVxuICAgIH1cbiAgICBhd2FpdCB0aGlzLl9leGVjdXRpb25Db250ZXh0LmNpcmN1aXQucmVuZGVyVW50aWxTZXR0bGVkKClcbiAgfVxuXG4gIGFzeW5jIGdldENpcmN1aXRKc29uKCk6IFByb21pc2U8QW55Q2lyY3VpdEVsZW1lbnRbXT4ge1xuICAgIGlmICghdGhpcy5fZXhlY3V0aW9uQ29udGV4dCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gY2lyY3VpdCBoYXMgYmVlbiBjcmVhdGVkXCIpXG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9leGVjdXRpb25Db250ZXh0LmNpcmN1aXQuZ2V0Q2lyY3VpdEpzb24oKVxuICB9XG5cbiAgY2xlYXJFdmVudExpc3RlbmVycygpIHtcbiAgICBpZiAodGhpcy5fZXhlY3V0aW9uQ29udGV4dD8uY2lyY3VpdCkge1xuICAgICAgZm9yIChjb25zdCBldmVudCBpbiB0aGlzLl9ldmVudExpc3RlbmVycykge1xuICAgICAgICBmb3IgKGNvbnN0IGxpc3RlbmVyIG9mIHRoaXMuX2V2ZW50TGlzdGVuZXJzW2V2ZW50XSkge1xuICAgICAgICAgIGNvbnN0IGNpcmN1aXQgPSB0aGlzLl9leGVjdXRpb25Db250ZXh0LmNpcmN1aXQgYXMgdW5rbm93biBhcyB7XG4gICAgICAgICAgICAvLyBiaW9tZS1pZ25vcmUgbGludC9jb21wbGV4aXR5L25vQmFubmVkVHlwZXM6IDxleHBsYW5hdGlvbj5cbiAgICAgICAgICAgIHJlbW92ZUxpc3RlbmVyPzogKGV2ZW50OiBzdHJpbmcsIGxpc3RlbmVyOiBGdW5jdGlvbikgPT4gdm9pZFxuICAgICAgICAgIH1cbiAgICAgICAgICBjaXJjdWl0LnJlbW92ZUxpc3RlbmVyPy4oZXZlbnQsIGxpc3RlbmVyKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgZm9yIChjb25zdCBldmVudCBpbiB0aGlzLl9ldmVudExpc3RlbmVycykge1xuICAgICAgZGVsZXRlIHRoaXMuX2V2ZW50TGlzdGVuZXJzW2V2ZW50XVxuICAgIH1cbiAgfVxuXG4gIGFzeW5jIGtpbGwoKSB7XG4gICAgLy8gQ2xlYW51cCByZXNvdXJjZXNcbiAgICB0aGlzLl9leGVjdXRpb25Db250ZXh0ID0gbnVsbFxuICB9XG5cbiAgYXN5bmMgc2V0U25pcHBldHNBcGlCYXNlVXJsKGJhc2VVcmw6IHN0cmluZykge1xuICAgIHRoaXMuX2NpcmN1aXRSdW5uZXJDb25maWd1cmF0aW9uLnNuaXBwZXRzQXBpQmFzZVVybCA9IGJhc2VVcmxcbiAgfVxuXG4gIGFzeW5jIHNldFBsYXRmb3JtQ29uZmlnKHBsYXRmb3JtOiBQbGF0Zm9ybUNvbmZpZykge1xuICAgIHRoaXMuX2NpcmN1aXRSdW5uZXJDb25maWd1cmF0aW9uLnBsYXRmb3JtID0gcGxhdGZvcm1cbiAgfVxuXG4gIHByaXZhdGUgX2JpbmRFdmVudExpc3RlbmVycyhjaXJjdWl0OiBSb290Q2lyY3VpdCkge1xuICAgIGZvciAoY29uc3QgZXZlbnQgaW4gdGhpcy5fZXZlbnRMaXN0ZW5lcnMpIHtcbiAgICAgIGZvciAoY29uc3QgbGlzdGVuZXIgb2YgdGhpcy5fZXZlbnRMaXN0ZW5lcnNbZXZlbnRdKSB7XG4gICAgICAgIGNpcmN1aXQub24oZXZlbnQgYXMgYW55LCBsaXN0ZW5lciBhcyBhbnkpXG4gICAgICB9XG4gICAgfVxuICB9XG59XG4iLCAiLyoqXG4gKiBSZXR1cm5zIHRoZSBkaXJlY3RvcnkgbmFtZSBvZiBhIHBhdGgsIHNpbWlsYXIgdG8gTm9kZS5qcyBwYXRoLmRpcm5hbWVcbiAqIFdvcmtzIG9uIGJvdGggVW5peCBhbmQgV2luZG93cyBwYXRoc1xuICogQHBhcmFtIHBhdGggVGhlIHBhdGggdG8gZXh0cmFjdCB0aGUgZGlyZWN0b3J5IGZyb21cbiAqIEByZXR1cm5zIFRoZSBkaXJlY3RvcnkgcGFydCBvZiB0aGUgcGF0aFxuICovXG5leHBvcnQgZnVuY3Rpb24gZGlybmFtZShwYXRoOiBzdHJpbmcpOiBzdHJpbmcge1xuICBpZiAoIXBhdGgpIHJldHVybiBcIi5cIlxuXG4gIC8vIE5vcm1hbGl6ZSBwYXRoIHNlcGFyYXRvcnMgdG8gZm9yd2FyZCBzbGFzaGVzXG4gIGNvbnN0IG5vcm1hbGl6ZWRQYXRoID0gcGF0aC5yZXBsYWNlKC9cXFxcL2csIFwiL1wiKVxuXG4gIC8vIFJlbW92ZSB0cmFpbGluZyBzbGFzaGVzXG4gIGNvbnN0IGNsZWFuUGF0aCA9IG5vcm1hbGl6ZWRQYXRoLnJlcGxhY2UoL1xcLyskLywgXCJcIilcblxuICAvLyBJZiB0aGVyZSBhcmUgbm8gc2xhc2hlcywgcmV0dXJuIFwiLlwiXG4gIGlmIChjbGVhblBhdGguaW5kZXhPZihcIi9cIikgPT09IC0xKSByZXR1cm4gXCIuXCJcblxuICAvLyBSZXR1cm4gZXZlcnl0aGluZyB1cCB0byB0aGUgbGFzdCBzbGFzaFxuICByZXR1cm4gY2xlYW5QYXRoLnN1YnN0cmluZygwLCBjbGVhblBhdGgubGFzdEluZGV4T2YoXCIvXCIpKSB8fCBcIi9cIlxufVxuIiwgImltcG9ydCB7IG5vcm1hbGl6ZUZpbGVQYXRoIH0gZnJvbSBcIi4vbm9ybWFsaXplRnNNYXBcIlxuaW1wb3J0IHsgZGlybmFtZSB9IGZyb20gXCJsaWIvdXRpbHMvZGlybmFtZVwiXG5cbmZ1bmN0aW9uIHJlc29sdmVSZWxhdGl2ZVBhdGgoaW1wb3J0UGF0aDogc3RyaW5nLCBjd2Q6IHN0cmluZyk6IHN0cmluZyB7XG4gIC8vIEhhbmRsZSBwYXJlbnQgZGlyZWN0b3J5IG5hdmlnYXRpb25cbiAgaWYgKGltcG9ydFBhdGguc3RhcnRzV2l0aChcIi4uL1wiKSkge1xuICAgIGNvbnN0IHBhcmVudERpciA9IGRpcm5hbWUoY3dkKVxuICAgIHJldHVybiByZXNvbHZlUmVsYXRpdmVQYXRoKGltcG9ydFBhdGguc2xpY2UoMyksIHBhcmVudERpcilcbiAgfVxuICAvLyBIYW5kbGUgY3VycmVudCBkaXJlY3RvcnlcbiAgaWYgKGltcG9ydFBhdGguc3RhcnRzV2l0aChcIi4vXCIpKSB7XG4gICAgcmV0dXJuIHJlc29sdmVSZWxhdGl2ZVBhdGgoaW1wb3J0UGF0aC5zbGljZSgyKSwgY3dkKVxuICB9XG4gIC8vIEhhbmRsZSBhYnNvbHV0ZSBwYXRoXG4gIGlmIChpbXBvcnRQYXRoLnN0YXJ0c1dpdGgoXCIvXCIpKSB7XG4gICAgcmV0dXJuIGltcG9ydFBhdGguc2xpY2UoMSlcbiAgfVxuICAvLyBIYW5kbGUgcmVsYXRpdmUgcGF0aFxuICByZXR1cm4gYCR7Y3dkfS8ke2ltcG9ydFBhdGh9YFxufVxuXG5leHBvcnQgY29uc3QgcmVzb2x2ZUZpbGVQYXRoID0gKFxuICB1bmtub3duRmlsZVBhdGg6IHN0cmluZyxcbiAgZnNNYXBPckFsbEZpbGVQYXRoczogUmVjb3JkPHN0cmluZywgc3RyaW5nPiB8IHN0cmluZ1tdLFxuICBjd2Q/OiBzdHJpbmcsXG4pID0+IHtcbiAgLy8gSGFuZGxlIHBhcmVudCBkaXJlY3RvcnkgbmF2aWdhdGlvbiBwcm9wZXJseVxuICBjb25zdCByZXNvbHZlZFBhdGggPSBjd2RcbiAgICA/IHJlc29sdmVSZWxhdGl2ZVBhdGgodW5rbm93bkZpbGVQYXRoLCBjd2QpXG4gICAgOiB1bmtub3duRmlsZVBhdGhcblxuICBjb25zdCBmaWxlUGF0aHMgPSBuZXcgU2V0KFxuICAgIEFycmF5LmlzQXJyYXkoZnNNYXBPckFsbEZpbGVQYXRocylcbiAgICAgID8gZnNNYXBPckFsbEZpbGVQYXRoc1xuICAgICAgOiBPYmplY3Qua2V5cyhmc01hcE9yQWxsRmlsZVBhdGhzKSxcbiAgKVxuXG4gIGlmIChmaWxlUGF0aHMuaGFzKHJlc29sdmVkUGF0aCkpIHtcbiAgICByZXR1cm4gcmVzb2x2ZWRQYXRoXG4gIH1cblxuICBjb25zdCBub3JtYWxpemVkRmlsZVBhdGhNYXAgPSBuZXcgTWFwPHN0cmluZywgc3RyaW5nPigpXG4gIGZvciAoY29uc3QgZmlsZVBhdGggb2YgZmlsZVBhdGhzKSB7XG4gICAgbm9ybWFsaXplZEZpbGVQYXRoTWFwLnNldChub3JtYWxpemVGaWxlUGF0aChmaWxlUGF0aCksIGZpbGVQYXRoKVxuICB9XG5cbiAgY29uc3Qgbm9ybWFsaXplZFJlc29sdmVkUGF0aCA9IG5vcm1hbGl6ZUZpbGVQYXRoKHJlc29sdmVkUGF0aClcblxuICBpZiAobm9ybWFsaXplZEZpbGVQYXRoTWFwLmhhcyhub3JtYWxpemVkUmVzb2x2ZWRQYXRoKSkge1xuICAgIHJldHVybiBub3JtYWxpemVkRmlsZVBhdGhNYXAuZ2V0KG5vcm1hbGl6ZWRSZXNvbHZlZFBhdGgpIVxuICB9XG5cbiAgLy8gU2VhcmNoIGZvciBmaWxlIHdpdGggYSBzZXQgb2YgZGlmZmVyZW50IGV4dGVuc2lvbnNcbiAgY29uc3QgZXh0ZW5zaW9uID0gW1widHN4XCIsIFwidHNcIiwgXCJqc29uXCIsIFwianNcIiwgXCJqc3hcIl1cbiAgZm9yIChjb25zdCBleHQgb2YgZXh0ZW5zaW9uKSB7XG4gICAgY29uc3QgcG9zc2libGVGaWxlUGF0aCA9IGAke25vcm1hbGl6ZWRSZXNvbHZlZFBhdGh9LiR7ZXh0fWBcbiAgICBpZiAobm9ybWFsaXplZEZpbGVQYXRoTWFwLmhhcyhwb3NzaWJsZUZpbGVQYXRoKSkge1xuICAgICAgcmV0dXJuIG5vcm1hbGl6ZWRGaWxlUGF0aE1hcC5nZXQocG9zc2libGVGaWxlUGF0aCkhXG4gICAgfVxuICB9XG5cbiAgLy8gQ2hlY2sgaWYgaXQncyBhbiBhYnNvbHV0ZSBpbXBvcnRcbiAgaWYgKCF1bmtub3duRmlsZVBhdGguc3RhcnRzV2l0aChcIi4vXCIpICYmICF1bmtub3duRmlsZVBhdGguc3RhcnRzV2l0aChcIi4uL1wiKSkge1xuICAgIGNvbnN0IG5vcm1hbGl6ZWRVbmtub3duRmlsZVBhdGggPSBub3JtYWxpemVGaWxlUGF0aCh1bmtub3duRmlsZVBhdGgpXG4gICAgaWYgKG5vcm1hbGl6ZWRGaWxlUGF0aE1hcC5oYXMobm9ybWFsaXplZFVua25vd25GaWxlUGF0aCkpIHtcbiAgICAgIHJldHVybiBub3JtYWxpemVkRmlsZVBhdGhNYXAuZ2V0KG5vcm1hbGl6ZWRVbmtub3duRmlsZVBhdGgpIVxuICAgIH1cbiAgICBmb3IgKGNvbnN0IGV4dCBvZiBleHRlbnNpb24pIHtcbiAgICAgIGNvbnN0IHBvc3NpYmxlRmlsZVBhdGggPSBgJHtub3JtYWxpemVkVW5rbm93bkZpbGVQYXRofS4ke2V4dH1gXG4gICAgICBpZiAobm9ybWFsaXplZEZpbGVQYXRoTWFwLmhhcyhwb3NzaWJsZUZpbGVQYXRoKSkge1xuICAgICAgICByZXR1cm4gbm9ybWFsaXplZEZpbGVQYXRoTWFwLmdldChwb3NzaWJsZUZpbGVQYXRoKSFcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbnVsbFxufVxuXG5leHBvcnQgY29uc3QgcmVzb2x2ZUZpbGVQYXRoT3JUaHJvdyA9IChcbiAgdW5rbm93bkZpbGVQYXRoOiBzdHJpbmcsXG4gIGZzTWFwT3JBbGxGaWxlUGF0aHM6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4gfCBzdHJpbmdbXSxcbikgPT4ge1xuICBjb25zdCByZXNvbHZlZEZpbGVQYXRoID0gcmVzb2x2ZUZpbGVQYXRoKHVua25vd25GaWxlUGF0aCwgZnNNYXBPckFsbEZpbGVQYXRocylcbiAgaWYgKCFyZXNvbHZlZEZpbGVQYXRoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYEZpbGUgbm90IGZvdW5kIFwiJHt1bmtub3duRmlsZVBhdGh9XCIsIGF2YWlsYWJsZSBwYXRoczpcXG5cXG4ke09iamVjdC5rZXlzKGZzTWFwT3JBbGxGaWxlUGF0aHMpLmpvaW4oXCIsIFwiKX1gLFxuICAgIClcbiAgfVxuICByZXR1cm4gcmVzb2x2ZWRGaWxlUGF0aFxufVxuIiwgImltcG9ydCB7IHJlc29sdmVGaWxlUGF0aCB9IGZyb20gXCJsaWIvcnVubmVyL3Jlc29sdmVGaWxlUGF0aFwiXG5cbmV4cG9ydCBmdW5jdGlvbiBldmFsQ29tcGlsZWRKcyhcbiAgY29tcGlsZWRDb2RlOiBzdHJpbmcsXG4gIHByZVN1cHBsaWVkSW1wb3J0czogUmVjb3JkPHN0cmluZywgYW55PixcbiAgY3dkPzogc3RyaW5nLFxuKSB7XG4gIDsoZ2xvYmFsVGhpcyBhcyBhbnkpLl9fdHNjaXJjdWl0X3JlcXVpcmUgPSAobmFtZTogc3RyaW5nKSA9PiB7XG4gICAgY29uc3QgcmVzb2x2ZWRGaWxlUGF0aCA9IHJlc29sdmVGaWxlUGF0aChuYW1lLCBwcmVTdXBwbGllZEltcG9ydHMsIGN3ZClcblxuICAgIGNvbnN0IGhhc1Jlc29sdmVkRmlsZVBhdGggPVxuICAgICAgcmVzb2x2ZWRGaWxlUGF0aCAmJiBwcmVTdXBwbGllZEltcG9ydHNbcmVzb2x2ZWRGaWxlUGF0aF1cblxuICAgIGlmICghcHJlU3VwcGxpZWRJbXBvcnRzW25hbWVdICYmICFoYXNSZXNvbHZlZEZpbGVQYXRoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEltcG9ydCBcIiR7bmFtZX1cIiBub3QgZm91bmQgJHtjd2QgPyBgaW4gXCIke2N3ZH1cImAgOiBcIlwifWApXG4gICAgfVxuXG4gICAgY29uc3QgbW9kID1cbiAgICAgIHByZVN1cHBsaWVkSW1wb3J0c1tuYW1lXSB8fCBwcmVTdXBwbGllZEltcG9ydHNbcmVzb2x2ZWRGaWxlUGF0aCFdXG4gICAgcmV0dXJuIG5ldyBQcm94eShtb2QsIHtcbiAgICAgIGdldCh0YXJnZXQsIHByb3ApIHtcbiAgICAgICAgaWYgKCEocHJvcCBpbiB0YXJnZXQpKSB7XG4gICAgICAgICAgaWYgKHByb3AgPT09IFwiZGVmYXVsdFwiKSB7XG4gICAgICAgICAgICBpZiAodGFyZ2V0LmRlZmF1bHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICByZXR1cm4gdGFyZ2V0LmRlZmF1bHRcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRhcmdldC5fX2VzTW9kdWxlKSB7XG4gICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWRcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHR5cGVvZiB0YXJnZXQgPT09IFwiZnVuY3Rpb25cIiB8fCB0eXBlb2YgdGFyZ2V0ID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICAgIHJldHVybiB0YXJnZXRcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZFxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChwcm9wID09PSBcIl9fZXNNb2R1bGVcIikge1xuICAgICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICBgQ29tcG9uZW50IFwiJHtTdHJpbmcocHJvcCl9XCIgaXMgbm90IGV4cG9ydGVkIGJ5IFwiJHtuYW1lfVwiYCxcbiAgICAgICAgICApXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGFyZ2V0W3Byb3AgYXMga2V5b2YgdHlwZW9mIHRhcmdldF1cbiAgICAgIH0sXG4gICAgfSlcbiAgfVxuXG4gIGNvbnN0IGZ1bmN0aW9uQm9keSA9IGBcbiAgdmFyIGV4cG9ydHMgPSB7fTtcbiAgdmFyIHJlcXVpcmUgPSBnbG9iYWxUaGlzLl9fdHNjaXJjdWl0X3JlcXVpcmU7XG4gIHZhciBtb2R1bGUgPSB7IGV4cG9ydHMgfTtcbiAgdmFyIGNpcmN1aXQgPSBnbG9iYWxUaGlzLl9fdHNjaXJjdWl0X2NpcmN1aXQ7XG4gICR7Y29tcGlsZWRDb2RlfTtcbiAgcmV0dXJuIG1vZHVsZTtgLnRyaW0oKVxuICByZXR1cm4gRnVuY3Rpb24oZnVuY3Rpb25Cb2R5KS5jYWxsKGdsb2JhbFRoaXMpXG59XG4iLCAiaW1wb3J0IHsgZXZhbENvbXBpbGVkSnMgfSBmcm9tIFwiLi9ldmFsLWNvbXBpbGVkLWpzXCJcbmltcG9ydCB0eXBlIHsgRXhlY3V0aW9uQ29udGV4dCB9IGZyb20gXCIuL2V4ZWN1dGlvbi1jb250ZXh0XCJcbmltcG9ydCAqIGFzIEJhYmVsIGZyb20gXCJAYmFiZWwvc3RhbmRhbG9uZVwiXG5pbXBvcnQgeyBpbXBvcnRMb2NhbEZpbGUgfSBmcm9tIFwiLi9pbXBvcnQtbG9jYWwtZmlsZVwiXG5pbXBvcnQgeyBpbXBvcnRTbmlwcGV0IH0gZnJvbSBcIi4vaW1wb3J0LXNuaXBwZXRcIlxuaW1wb3J0IHsgcmVzb2x2ZUZpbGVQYXRoIH0gZnJvbSBcImxpYi9ydW5uZXIvcmVzb2x2ZUZpbGVQYXRoXCJcbmltcG9ydCB7IHJlc29sdmVOb2RlTW9kdWxlIH0gZnJvbSBcImxpYi91dGlscy9yZXNvbHZlLW5vZGUtbW9kdWxlXCJcbmltcG9ydCB7IGltcG9ydE5vZGVNb2R1bGUgfSBmcm9tIFwiLi9pbXBvcnQtbm9kZS1tb2R1bGVcIlxuaW1wb3J0IERlYnVnIGZyb20gXCJkZWJ1Z1wiXG5cbmNvbnN0IGRlYnVnID0gRGVidWcoXCJ0c2NpOmV2YWw6aW1wb3J0LWV2YWwtcGF0aFwiKVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gaW1wb3J0RXZhbFBhdGgoXG4gIGltcG9ydE5hbWU6IHN0cmluZyxcbiAgY3R4OiBFeGVjdXRpb25Db250ZXh0LFxuICBkZXB0aCA9IDAsXG4gIG9wdHM6IHtcbiAgICBjd2Q/OiBzdHJpbmdcbiAgfSA9IHt9LFxuKSB7XG4gIGRlYnVnKFwiaW1wb3J0RXZhbFBhdGggY2FsbGVkIHdpdGg6XCIsIHtcbiAgICBpbXBvcnROYW1lLFxuICAgIGRlcHRoLFxuICAgIG9wdHMsXG4gIH0pXG5cbiAgZGVidWcoYCR7XCIgIFwiLnJlcGVhdChkZXB0aCl9XHUyN0ExXHVGRTBGYCwgaW1wb3J0TmFtZSlcbiAgY29uc3QgeyBwcmVTdXBwbGllZEltcG9ydHMgfSA9IGN0eFxuXG4gIGlmIChwcmVTdXBwbGllZEltcG9ydHNbaW1wb3J0TmFtZV0pIHJldHVyblxuICBpZiAoaW1wb3J0TmFtZS5zdGFydHNXaXRoKFwiLi9cIikgJiYgcHJlU3VwcGxpZWRJbXBvcnRzW2ltcG9ydE5hbWUuc2xpY2UoMildKVxuICAgIHJldHVyblxuXG4gIGlmIChkZXB0aCA+IDUpIHtcbiAgICBjb25zb2xlLmxvZyhcIk1heCBkZXB0aCBmb3IgaW1wb3J0cyByZWFjaGVkXCIpXG4gICAgcmV0dXJuXG4gIH1cblxuICBjb25zdCByZXNvbHZlZExvY2FsSW1wb3J0UGF0aCA9IHJlc29sdmVGaWxlUGF0aChcbiAgICBpbXBvcnROYW1lLFxuICAgIGN0eC5mc01hcCxcbiAgICBvcHRzLmN3ZCxcbiAgKVxuICBpZiAocmVzb2x2ZWRMb2NhbEltcG9ydFBhdGgpIHtcbiAgICByZXR1cm4gaW1wb3J0TG9jYWxGaWxlKHJlc29sdmVkTG9jYWxJbXBvcnRQYXRoLCBjdHgsIGRlcHRoKVxuICB9XG5cbiAgLy8gVHJ5IHRvIHJlc29sdmUgZnJvbSBub2RlX21vZHVsZXNcbiAgY29uc3QgcmVzb2x2ZWROb2RlTW9kdWxlUGF0aCA9IHJlc29sdmVOb2RlTW9kdWxlKFxuICAgIGltcG9ydE5hbWUsXG4gICAgY3R4LmZzTWFwLFxuICAgIG9wdHMuY3dkIHx8IFwiXCIsXG4gIClcbiAgaWYgKHJlc29sdmVkTm9kZU1vZHVsZVBhdGgpIHtcbiAgICByZXR1cm4gaW1wb3J0Tm9kZU1vZHVsZShpbXBvcnROYW1lLCBjdHgsIGRlcHRoKVxuICB9XG5cbiAgaWYgKGltcG9ydE5hbWUuc3RhcnRzV2l0aChcIkB0c2NpL1wiKSkge1xuICAgIHJldHVybiBpbXBvcnRTbmlwcGV0KGltcG9ydE5hbWUsIGN0eCwgZGVwdGgpXG4gIH1cblxuICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgYFVucmVzb2x2ZWQgaW1wb3J0IFwiJHtpbXBvcnROYW1lfVwiICR7b3B0cy5jd2QgPyBgZnJvbSBkaXJlY3RvcnkgXCIke29wdHMuY3dkfVwiYCA6IFwiXCJ9YCxcbiAgKVxufVxuIiwgImltcG9ydCAqIGFzIEJhYmVsIGZyb20gXCJAYmFiZWwvc3RhbmRhbG9uZVwiXG5pbXBvcnQgeyByZXNvbHZlRmlsZVBhdGhPclRocm93IH0gZnJvbSBcImxpYi9ydW5uZXIvcmVzb2x2ZUZpbGVQYXRoXCJcbmltcG9ydCB7IGRpcm5hbWUgfSBmcm9tIFwibGliL3V0aWxzL2Rpcm5hbWVcIlxuaW1wb3J0IHsgZ2V0SW1wb3J0c0Zyb21Db2RlIH0gZnJvbSBcImxpYi91dGlscy9nZXQtaW1wb3J0cy1mcm9tLWNvZGVcIlxuaW1wb3J0IHsgZXZhbENvbXBpbGVkSnMgfSBmcm9tIFwiLi9ldmFsLWNvbXBpbGVkLWpzXCJcbmltcG9ydCB0eXBlIHsgRXhlY3V0aW9uQ29udGV4dCB9IGZyb20gXCIuL2V4ZWN1dGlvbi1jb250ZXh0XCJcbmltcG9ydCB7IGltcG9ydEV2YWxQYXRoIH0gZnJvbSBcIi4vaW1wb3J0LWV2YWwtcGF0aFwiXG5pbXBvcnQgRGVidWcgZnJvbSBcImRlYnVnXCJcblxuY29uc3QgZGVidWcgPSBEZWJ1ZyhcInRzY2k6ZXZhbDppbXBvcnQtbG9jYWwtZmlsZVwiKVxuXG5leHBvcnQgY29uc3QgaW1wb3J0TG9jYWxGaWxlID0gYXN5bmMgKFxuICBpbXBvcnROYW1lOiBzdHJpbmcsXG4gIGN0eDogRXhlY3V0aW9uQ29udGV4dCxcbiAgZGVwdGggPSAwLFxuKSA9PiB7XG4gIGRlYnVnKFwiaW1wb3J0TG9jYWxGaWxlIGNhbGxlZCB3aXRoOlwiLCB7XG4gICAgaW1wb3J0TmFtZSxcbiAgfSlcblxuICBjb25zdCB7IGZzTWFwLCBwcmVTdXBwbGllZEltcG9ydHMgfSA9IGN0eFxuXG4gIGNvbnN0IGZzUGF0aCA9IHJlc29sdmVGaWxlUGF0aE9yVGhyb3coaW1wb3J0TmFtZSwgZnNNYXApXG4gIGRlYnVnKFwiZnNQYXRoOlwiLCBmc1BhdGgpXG4gIGlmICghY3R4LmZzTWFwW2ZzUGF0aF0pIHtcbiAgICBkZWJ1ZyhcImZzUGF0aCBub3QgZm91bmQgaW4gZnNNYXA6XCIsIGZzUGF0aClcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEZpbGUgXCIke2ZzUGF0aH1cIiBub3QgZm91bmRgKVxuICB9XG4gIGNvbnN0IGZpbGVDb250ZW50ID0gZnNNYXBbZnNQYXRoXVxuICBkZWJ1ZyhcImZpbGVDb250ZW50OlwiLCBmaWxlQ29udGVudD8uc2xpY2UoMCwgMTAwKSlcbiAgaWYgKGZzUGF0aC5lbmRzV2l0aChcIi5qc29uXCIpKSB7XG4gICAgY29uc3QganNvbkRhdGEgPSBKU09OLnBhcnNlKGZpbGVDb250ZW50KVxuICAgIHByZVN1cHBsaWVkSW1wb3J0c1tmc1BhdGhdID0ge1xuICAgICAgX19lc01vZHVsZTogdHJ1ZSxcbiAgICAgIGRlZmF1bHQ6IGpzb25EYXRhLFxuICAgIH1cbiAgfSBlbHNlIGlmIChmc1BhdGguZW5kc1dpdGgoXCIudHN4XCIpIHx8IGZzUGF0aC5lbmRzV2l0aChcIi50c1wiKSkge1xuICAgIGNvbnN0IGltcG9ydE5hbWVzID0gZ2V0SW1wb3J0c0Zyb21Db2RlKGZpbGVDb250ZW50KVxuXG4gICAgZm9yIChjb25zdCBpbXBvcnROYW1lIG9mIGltcG9ydE5hbWVzKSB7XG4gICAgICBpZiAoIXByZVN1cHBsaWVkSW1wb3J0c1tpbXBvcnROYW1lXSkge1xuICAgICAgICBhd2FpdCBpbXBvcnRFdmFsUGF0aChpbXBvcnROYW1lLCBjdHgsIGRlcHRoICsgMSwge1xuICAgICAgICAgIGN3ZDogZGlybmFtZShmc1BhdGgpLFxuICAgICAgICB9KVxuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IHJlc3VsdCA9IEJhYmVsLnRyYW5zZm9ybShmaWxlQ29udGVudCwge1xuICAgICAgcHJlc2V0czogW1wicmVhY3RcIiwgXCJ0eXBlc2NyaXB0XCJdLFxuICAgICAgcGx1Z2luczogW1widHJhbnNmb3JtLW1vZHVsZXMtY29tbW9uanNcIl0sXG4gICAgICBmaWxlbmFtZTogXCJ2aXJ0dWFsLnRzeFwiLFxuICAgIH0pXG5cbiAgICBpZiAoIXJlc3VsdCB8fCAhcmVzdWx0LmNvZGUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkZhaWxlZCB0byB0cmFuc2Zvcm0gY29kZVwiKVxuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICBkZWJ1ZyhcImV2YWxDb21waWxlZEpzIGNhbGxlZCB3aXRoOlwiLCB7XG4gICAgICAgIGNvZGU6IHJlc3VsdC5jb2RlPy5zbGljZSgwLCAxMDApLFxuICAgICAgICBkaXJuYW1lOiBkaXJuYW1lKGZzUGF0aCksXG4gICAgICB9KVxuICAgICAgY29uc3QgaW1wb3J0UnVuUmVzdWx0ID0gZXZhbENvbXBpbGVkSnMoXG4gICAgICAgIHJlc3VsdC5jb2RlLFxuICAgICAgICBwcmVTdXBwbGllZEltcG9ydHMsXG4gICAgICAgIGRpcm5hbWUoZnNQYXRoKSxcbiAgICAgIClcbiAgICAgIGRlYnVnKFwiaW1wb3J0UnVuUmVzdWx0OlwiLCB7XG4gICAgICAgIGZzUGF0aCxcbiAgICAgICAgaW1wb3J0UnVuUmVzdWx0LFxuICAgICAgfSlcbiAgICAgIHByZVN1cHBsaWVkSW1wb3J0c1tmc1BhdGhdID0gaW1wb3J0UnVuUmVzdWx0LmV4cG9ydHNcbiAgICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBFdmFsIGNvbXBpbGVkIGpzIGVycm9yIGZvciBcIiR7aW1wb3J0TmFtZX1cIjogJHtlcnJvci5tZXNzYWdlfWAsXG4gICAgICApXG4gICAgfVxuICB9IGVsc2UgaWYgKGZzUGF0aC5lbmRzV2l0aChcIi5qc1wiKSkge1xuICAgIC8vIEZvciAuanMgZmlsZXMsIGVzcGVjaWFsbHkgZnJvbSBub2RlX21vZHVsZXMsIHdlIG5lZWQgdG8gdHJhbnNmb3JtIHRoZW1cbiAgICBjb25zdCByZXN1bHQgPSBCYWJlbC50cmFuc2Zvcm0oZmlsZUNvbnRlbnQsIHtcbiAgICAgIHByZXNldHM6IFtcImVudlwiXSxcbiAgICAgIHBsdWdpbnM6IFtcInRyYW5zZm9ybS1tb2R1bGVzLWNvbW1vbmpzXCJdLFxuICAgICAgZmlsZW5hbWU6IGZzUGF0aCxcbiAgICB9KVxuXG4gICAgaWYgKCFyZXN1bHQgfHwgIXJlc3VsdC5jb2RlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJGYWlsZWQgdG8gdHJhbnNmb3JtIEpTIGNvZGVcIilcbiAgICB9XG5cbiAgICBwcmVTdXBwbGllZEltcG9ydHNbZnNQYXRoXSA9IGV2YWxDb21waWxlZEpzKFxuICAgICAgcmVzdWx0LmNvZGUsXG4gICAgICBwcmVTdXBwbGllZEltcG9ydHMsXG4gICAgICBkaXJuYW1lKGZzUGF0aCksXG4gICAgKS5leHBvcnRzXG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYFVuc3VwcG9ydGVkIGZpbGUgZXh0ZW5zaW9uIFwiJHtmc1BhdGguc3BsaXQoXCIuXCIpLnBvcCgpfVwiIGZvciBcIiR7ZnNQYXRofVwiYCxcbiAgICApXG4gIH1cbn1cbiIsICJleHBvcnQgY29uc3QgZ2V0SW1wb3J0c0Zyb21Db2RlID0gKGNvZGU6IHN0cmluZyk6IHN0cmluZ1tdID0+IHtcbiAgLy8gTWF0Y2ggYmFzaWMgaW1wb3J0IHBhdHRlcm5zIGluY2x1ZGluZyBjb21iaW5lZCBkZWZhdWx0IGFuZCBuYW1lc3BhY2UgaW1wb3J0c1xuICBjb25zdCBpbXBvcnRSZWdleCA9XG4gICAgL15cXHMqaW1wb3J0XFxzKyg/Oig/OltcXHdcXHNdKyxcXHMqKT8oPzpcXCpcXHMrYXNcXHMrW1xcd1xcc10rfFxce1tcXHNcXHcsXStcXH18XFx3KylcXHMrZnJvbVxccyspP1snXCJdKC4rPylbJ1wiXS9nbVxuICBjb25zdCBpbXBvcnRzOiBzdHJpbmdbXSA9IFtdXG4gIGxldCBtYXRjaDogUmVnRXhwRXhlY0FycmF5IHwgbnVsbFxuXG4gIC8vIGJpb21lLWlnbm9yZSBsaW50L3N1c3BpY2lvdXMvbm9Bc3NpZ25JbkV4cHJlc3Npb25zOiA8ZXhwbGFuYXRpb24+XG4gIHdoaWxlICgobWF0Y2ggPSBpbXBvcnRSZWdleC5leGVjKGNvZGUpKSAhPT0gbnVsbCkge1xuICAgIGltcG9ydHMucHVzaChtYXRjaFsxXSlcbiAgfVxuXG4gIC8vIE1hdGNoIHJlLWV4cG9ydHNcbiAgY29uc3QgcmVFeHBvcnRSZWdleCA9XG4gICAgL15cXHMqZXhwb3J0XFxzKyg/OlxcKnwoPzpcXHtbXFxzXFx3LF0rXFx9KSlcXHMrZnJvbVxccytbJ1wiXSguKz8pWydcIl0vZ21cbiAgbGV0IHJlRXhwb3J0TWF0Y2g6IFJlZ0V4cEV4ZWNBcnJheSB8IG51bGxcbiAgLy8gYmlvbWUtaWdub3JlIGxpbnQvc3VzcGljaW91cy9ub0Fzc2lnbkluRXhwcmVzc2lvbnM6IDxleHBsYW5hdGlvbj5cbiAgd2hpbGUgKChyZUV4cG9ydE1hdGNoID0gcmVFeHBvcnRSZWdleC5leGVjKGNvZGUpKSAhPT0gbnVsbCkge1xuICAgIGltcG9ydHMucHVzaChyZUV4cG9ydE1hdGNoWzFdKVxuICB9XG5cbiAgcmV0dXJuIGltcG9ydHNcbn1cbiIsICJpbXBvcnQgeyBldmFsQ29tcGlsZWRKcyB9IGZyb20gXCIuL2V2YWwtY29tcGlsZWQtanNcIlxuaW1wb3J0IHR5cGUgeyBFeGVjdXRpb25Db250ZXh0IH0gZnJvbSBcIi4vZXhlY3V0aW9uLWNvbnRleHRcIlxuaW1wb3J0ICogYXMgQmFiZWwgZnJvbSBcIkBiYWJlbC9zdGFuZGFsb25lXCJcbmltcG9ydCB7IGltcG9ydExvY2FsRmlsZSB9IGZyb20gXCIuL2ltcG9ydC1sb2NhbC1maWxlXCJcbmltcG9ydCB7IGltcG9ydEV2YWxQYXRoIH0gZnJvbSBcIi4vaW1wb3J0LWV2YWwtcGF0aFwiXG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBpbXBvcnRTbmlwcGV0KFxuICBpbXBvcnROYW1lOiBzdHJpbmcsXG4gIGN0eDogRXhlY3V0aW9uQ29udGV4dCxcbiAgZGVwdGggPSAwLFxuKSB7XG4gIGNvbnN0IHsgcHJlU3VwcGxpZWRJbXBvcnRzIH0gPSBjdHhcbiAgY29uc3QgZnVsbFNuaXBwZXROYW1lID0gaW1wb3J0TmFtZS5yZXBsYWNlKFwiQHRzY2kvXCIsIFwiXCIpLnJlcGxhY2UoXCIuXCIsIFwiL1wiKVxuXG4gIGNvbnN0IHsgY2pzLCBlcnJvciB9ID0gYXdhaXQgZmV0Y2goYCR7Y3R4LmNqc1JlZ2lzdHJ5VXJsfS8ke2Z1bGxTbmlwcGV0TmFtZX1gKVxuICAgIC50aGVuKGFzeW5jIChyZXMpID0+ICh7IGNqczogYXdhaXQgcmVzLnRleHQoKSwgZXJyb3I6IG51bGwgfSkpXG4gICAgLmNhdGNoKChlKSA9PiAoeyBlcnJvcjogZSwgY2pzOiBudWxsIH0pKVxuXG4gIGlmIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBmZXRjaGluZyBpbXBvcnRcIiwgaW1wb3J0TmFtZSwgZXJyb3IpXG4gICAgcmV0dXJuXG4gIH1cblxuICB0cnkge1xuICAgIHByZVN1cHBsaWVkSW1wb3J0c1tpbXBvcnROYW1lXSA9IGV2YWxDb21waWxlZEpzKFxuICAgICAgY2pzISxcbiAgICAgIHByZVN1cHBsaWVkSW1wb3J0cyxcbiAgICApLmV4cG9ydHNcbiAgfSBjYXRjaCAoZSkge1xuICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBpbXBvcnRpbmcgc25pcHBldFwiLCBlKVxuICB9XG59XG4iLCAiaW1wb3J0IHsgZGlybmFtZSB9IGZyb20gXCIuL2Rpcm5hbWVcIlxuXG5pbnRlcmZhY2UgUGFja2FnZUpzb24ge1xuICBtYWluPzogc3RyaW5nXG4gIG1vZHVsZT86IHN0cmluZ1xuICBleHBvcnRzPzogUmVjb3JkPHN0cmluZywgc3RyaW5nIHwgUmVjb3JkPHN0cmluZywgc3RyaW5nPj5cbn1cblxuaW50ZXJmYWNlIE5vZGVSZXNvbHV0aW9uQ29udGV4dCB7XG4gIGZzTWFwOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+XG4gIGV4dGVuc2lvbnM6IHN0cmluZ1tdXG4gIGJhc2VQYXRoOiBzdHJpbmdcbiAgbW9kdWxlUGF0aDogc3RyaW5nXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUNvbnRleHQoXG4gIG1vZHVsZVBhdGg6IHN0cmluZyxcbiAgZnNNYXA6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4sXG4gIGJhc2VQYXRoOiBzdHJpbmcsXG4pOiBOb2RlUmVzb2x1dGlvbkNvbnRleHQge1xuICByZXR1cm4ge1xuICAgIGZzTWFwLFxuICAgIGV4dGVuc2lvbnM6IFtcIi5qc1wiLCBcIi5qc3hcIiwgXCIudHNcIiwgXCIudHN4XCIsIFwiLmpzb25cIl0sXG4gICAgYmFzZVBhdGgsXG4gICAgbW9kdWxlUGF0aCxcbiAgfVxufVxuXG5mdW5jdGlvbiBmaW5kUGFja2FnZUpzb24obm9kZU1vZHVsZXNQYXRoOiBzdHJpbmcsIGN0eDogTm9kZVJlc29sdXRpb25Db250ZXh0KSB7XG4gIGNvbnN0IHBhY2thZ2VKc29uUGF0aCA9IGAke25vZGVNb2R1bGVzUGF0aH0vcGFja2FnZS5qc29uYFxuICBpZiAoIWN0eC5mc01hcFtwYWNrYWdlSnNvblBhdGhdKSByZXR1cm4gbnVsbFxuICB0cnkge1xuICAgIHJldHVybiBKU09OLnBhcnNlKGN0eC5mc01hcFtwYWNrYWdlSnNvblBhdGhdKSBhcyBQYWNrYWdlSnNvblxuICB9IGNhdGNoIHtcbiAgICByZXR1cm4gbnVsbFxuICB9XG59XG5cbmZ1bmN0aW9uIHRyeVJlc29sdmVXaXRoRXh0ZW5zaW9ucyhcbiAgcGF0aDogc3RyaW5nLFxuICBjdHg6IE5vZGVSZXNvbHV0aW9uQ29udGV4dCxcbik6IHN0cmluZyB8IG51bGwge1xuICBpZiAoY3R4LmZzTWFwW3BhdGhdKSByZXR1cm4gcGF0aFxuXG4gIGZvciAoY29uc3QgZXh0IG9mIGN0eC5leHRlbnNpb25zKSB7XG4gICAgY29uc3QgcGF0aFdpdGhFeHQgPSBwYXRoLnJlcGxhY2UoL1xcLmpzJHxcXC5qc3gkLywgXCJcIikgKyBleHRcbiAgICBpZiAoY3R4LmZzTWFwW3BhdGhXaXRoRXh0XSkgcmV0dXJuIHBhdGhXaXRoRXh0XG4gIH1cbiAgcmV0dXJuIG51bGxcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZUV4cG9ydFBhdGgoXG4gIG5vZGVNb2R1bGVzUGF0aDogc3RyaW5nLFxuICBleHBvcnRQYXRoOiBzdHJpbmcsXG4gIGN0eDogTm9kZVJlc29sdXRpb25Db250ZXh0LFxuKTogc3RyaW5nIHwgbnVsbCB7XG4gIGNvbnN0IGZ1bGxFeHBvcnRQYXRoID0gYCR7bm9kZU1vZHVsZXNQYXRofS8ke2V4cG9ydFBhdGgucmVwbGFjZSgvXlxcLlxcLy8sIFwiXCIpfWBcbiAgcmV0dXJuIHRyeVJlc29sdmVXaXRoRXh0ZW5zaW9ucyhmdWxsRXhwb3J0UGF0aCwgY3R4KVxufVxuXG5mdW5jdGlvbiByZXNvbHZlUGFja2FnZUV4cG9ydHMoXG4gIG5vZGVNb2R1bGVzUGF0aDogc3RyaW5nLFxuICBwYWNrYWdlSnNvbjogUGFja2FnZUpzb24sXG4gIHJlbWFpbmluZ1BhdGg6IHN0cmluZyxcbiAgY3R4OiBOb2RlUmVzb2x1dGlvbkNvbnRleHQsXG4pOiBzdHJpbmcgfCBudWxsIHtcbiAgaWYgKCFwYWNrYWdlSnNvbi5leHBvcnRzKSByZXR1cm4gbnVsbFxuXG4gIC8vIEhhbmRsZSBkZWZhdWx0IGV4cG9ydCBjb25kaXRpb25cbiAgY29uc3QgZGVmYXVsdEV4cG9ydCA9IHBhY2thZ2VKc29uLmV4cG9ydHNbXCIuXCJdXG4gIGlmIChyZW1haW5pbmdQYXRoID09PSBcIlwiICYmIGRlZmF1bHRFeHBvcnQpIHtcbiAgICBpZiAodHlwZW9mIGRlZmF1bHRFeHBvcnQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIGNvbnN0IHJlc29sdmVkID0gcmVzb2x2ZUV4cG9ydFBhdGgobm9kZU1vZHVsZXNQYXRoLCBkZWZhdWx0RXhwb3J0LCBjdHgpXG4gICAgICBpZiAocmVzb2x2ZWQpIHJldHVybiByZXNvbHZlZFxuICAgIH1cbiAgfVxuXG4gIC8vIEhhbmRsZSBzdWJwYXRoIGV4cG9ydHNcbiAgY29uc3Qgc3VicGF0aEV4cG9ydCA9IHJlbWFpbmluZ1BhdGhcbiAgICA/IHBhY2thZ2VKc29uLmV4cG9ydHNbYC4vJHtyZW1haW5pbmdQYXRofWBdXG4gICAgOiBudWxsXG4gIGlmIChzdWJwYXRoRXhwb3J0ICYmIHR5cGVvZiBzdWJwYXRoRXhwb3J0ID09PSBcInN0cmluZ1wiKSB7XG4gICAgY29uc3QgcmVzb2x2ZWQgPSByZXNvbHZlRXhwb3J0UGF0aChub2RlTW9kdWxlc1BhdGgsIHN1YnBhdGhFeHBvcnQsIGN0eClcbiAgICBpZiAocmVzb2x2ZWQpIHJldHVybiByZXNvbHZlZFxuICB9XG5cbiAgLy8gSGFuZGxlIGNvbmRpdGlvbmFsIGV4cG9ydHNcbiAgY29uc3QgaW1wb3J0RXhwb3J0ID0gcGFja2FnZUpzb24uZXhwb3J0c1tcImltcG9ydFwiXVxuICBpZiAoXG4gICAgcmVtYWluaW5nUGF0aCA9PT0gXCJcIiAmJlxuICAgIGltcG9ydEV4cG9ydCAmJlxuICAgIHR5cGVvZiBpbXBvcnRFeHBvcnQgPT09IFwic3RyaW5nXCJcbiAgKSB7XG4gICAgY29uc3QgcmVzb2x2ZWQgPSByZXNvbHZlRXhwb3J0UGF0aChub2RlTW9kdWxlc1BhdGgsIGltcG9ydEV4cG9ydCwgY3R4KVxuICAgIGlmIChyZXNvbHZlZCkgcmV0dXJuIHJlc29sdmVkXG4gIH1cblxuICByZXR1cm4gbnVsbFxufVxuXG5mdW5jdGlvbiByZXNvbHZlUGFja2FnZUVudHJ5UG9pbnQoXG4gIG5vZGVNb2R1bGVzUGF0aDogc3RyaW5nLFxuICBwYWNrYWdlSnNvbjogUGFja2FnZUpzb24sXG4gIGN0eDogTm9kZVJlc29sdXRpb25Db250ZXh0LFxuKTogc3RyaW5nIHwgbnVsbCB7XG4gIGNvbnN0IGVudHJ5UG9pbnQgPSBwYWNrYWdlSnNvbi5tb2R1bGUgfHwgcGFja2FnZUpzb24ubWFpbiB8fCBcImluZGV4LmpzXCJcbiAgY29uc3QgZnVsbFBhdGggPSBgJHtub2RlTW9kdWxlc1BhdGh9LyR7ZW50cnlQb2ludH1gXG4gIHJldHVybiB0cnlSZXNvbHZlV2l0aEV4dGVuc2lvbnMoZnVsbFBhdGgsIGN0eClcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZVJlbWFpbmluZ1BhdGgoXG4gIG5vZGVNb2R1bGVzUGF0aDogc3RyaW5nLFxuICByZW1haW5pbmdQYXRoOiBzdHJpbmcsXG4gIGN0eDogTm9kZVJlc29sdXRpb25Db250ZXh0LFxuKTogc3RyaW5nIHwgbnVsbCB7XG4gIGlmICghcmVtYWluaW5nUGF0aCkge1xuICAgIC8vIFRyeSBpbmRleCBmaWxlcyBpbiB0aGUgbW9kdWxlIHJvb3RcbiAgICBmb3IgKGNvbnN0IGV4dCBvZiBjdHguZXh0ZW5zaW9ucykge1xuICAgICAgY29uc3QgaW5kZXhQYXRoID0gYCR7bm9kZU1vZHVsZXNQYXRofS9pbmRleCR7ZXh0fWBcbiAgICAgIGlmIChjdHguZnNNYXBbaW5kZXhQYXRoXSkgcmV0dXJuIGluZGV4UGF0aFxuICAgIH1cbiAgICByZXR1cm4gbnVsbFxuICB9XG5cbiAgY29uc3QgZnVsbFBhdGggPSBgJHtub2RlTW9kdWxlc1BhdGh9LyR7cmVtYWluaW5nUGF0aH1gXG4gIGNvbnN0IGRpcmVjdE1hdGNoID0gdHJ5UmVzb2x2ZVdpdGhFeHRlbnNpb25zKGZ1bGxQYXRoLCBjdHgpXG4gIGlmIChkaXJlY3RNYXRjaCkgcmV0dXJuIGRpcmVjdE1hdGNoXG5cbiAgLy8gVHJ5IGluZGV4IGZpbGVzXG4gIGZvciAoY29uc3QgZXh0IG9mIGN0eC5leHRlbnNpb25zKSB7XG4gICAgY29uc3QgaW5kZXhQYXRoID0gYCR7ZnVsbFBhdGh9L2luZGV4JHtleHR9YFxuICAgIGlmIChjdHguZnNNYXBbaW5kZXhQYXRoXSkgcmV0dXJuIGluZGV4UGF0aFxuICB9XG4gIHJldHVybiBudWxsXG59XG5cbmZ1bmN0aW9uIHJlc29sdmVOb2RlTW9kdWxlSW5QYXRoKFxuICBzZWFyY2hQYXRoOiBzdHJpbmcsXG4gIGN0eDogTm9kZVJlc29sdXRpb25Db250ZXh0LFxuKTogc3RyaW5nIHwgbnVsbCB7XG4gIGNvbnN0IG1vZHVsZVBhcnRzID0gY3R4Lm1vZHVsZVBhdGguc3BsaXQoXCIvXCIpXG4gIGNvbnN0IHNjb3BlID0gbW9kdWxlUGFydHNbMF0uc3RhcnRzV2l0aChcIkBcIilcbiAgICA/IG1vZHVsZVBhcnRzLnNsaWNlKDAsIDIpLmpvaW4oXCIvXCIpXG4gICAgOiBtb2R1bGVQYXJ0c1swXVxuICBjb25zdCByZW1haW5pbmdQYXRoID0gbW9kdWxlUGFydHMuc2xpY2Uoc2NvcGUuaW5jbHVkZXMoXCIvXCIpID8gMiA6IDEpLmpvaW4oXCIvXCIpXG4gIGNvbnN0IG5vZGVNb2R1bGVzUGF0aCA9IGAke3NlYXJjaFBhdGggPT0gXCIuXCIgPyBcIlwiIDogYCR7c2VhcmNoUGF0aH0vYH1ub2RlX21vZHVsZXMvJHtzY29wZX1gXG5cbiAgLy8gVHJ5IHRvIGZpbmQgcGFja2FnZS5qc29uXG4gIGNvbnN0IHBhY2thZ2VKc29uID0gZmluZFBhY2thZ2VKc29uKG5vZGVNb2R1bGVzUGF0aCwgY3R4KVxuICBpZiAocGFja2FnZUpzb24pIHtcbiAgICAvLyBUcnkgcmVzb2x2aW5nIHRocm91Z2ggZXhwb3J0cyBmaWVsZFxuICAgIGNvbnN0IGV4cG9ydHNSZXNvbHV0aW9uID0gcmVzb2x2ZVBhY2thZ2VFeHBvcnRzKFxuICAgICAgbm9kZU1vZHVsZXNQYXRoLFxuICAgICAgcGFja2FnZUpzb24sXG4gICAgICByZW1haW5pbmdQYXRoLFxuICAgICAgY3R4LFxuICAgIClcbiAgICBpZiAoZXhwb3J0c1Jlc29sdXRpb24pIHJldHVybiBleHBvcnRzUmVzb2x1dGlvblxuXG4gICAgLy8gVHJ5IHJlc29sdmluZyB0aHJvdWdoIG1haW4vbW9kdWxlIGZpZWxkc1xuICAgIGNvbnN0IGVudHJ5UG9pbnRSZXNvbHV0aW9uID0gcmVzb2x2ZVBhY2thZ2VFbnRyeVBvaW50KFxuICAgICAgbm9kZU1vZHVsZXNQYXRoLFxuICAgICAgcGFja2FnZUpzb24sXG4gICAgICBjdHgsXG4gICAgKVxuICAgIGlmIChlbnRyeVBvaW50UmVzb2x1dGlvbikgcmV0dXJuIGVudHJ5UG9pbnRSZXNvbHV0aW9uXG4gIH1cblxuICAvLyBUcnkgcmVzb2x2aW5nIHJlbWFpbmluZyBwYXRoXG4gIGNvbnN0IHJlbWFpbmluZ1BhdGhSZXNvbHV0aW9uID0gcmVzb2x2ZVJlbWFpbmluZ1BhdGgoXG4gICAgbm9kZU1vZHVsZXNQYXRoLFxuICAgIHJlbWFpbmluZ1BhdGgsXG4gICAgY3R4LFxuICApXG4gIGlmIChyZW1haW5pbmdQYXRoUmVzb2x1dGlvbikgcmV0dXJuIHJlbWFpbmluZ1BhdGhSZXNvbHV0aW9uXG5cbiAgLy8gSWYgbm90IGZvdW5kIGFuZCB3ZSBoYXZlIGEgcGFyZW50IGRpcmVjdG9yeSwgdHJ5IHRoZXJlXG4gIGNvbnN0IHBhcmVudFBhdGggPSBkaXJuYW1lKHNlYXJjaFBhdGgpXG4gIGlmIChwYXJlbnRQYXRoICYmIHBhcmVudFBhdGggIT09IHNlYXJjaFBhdGgpIHtcbiAgICByZXR1cm4gcmVzb2x2ZU5vZGVNb2R1bGVJblBhdGgocGFyZW50UGF0aCwgY3R4KVxuICB9XG5cbiAgcmV0dXJuIG51bGxcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJlc29sdmVOb2RlTW9kdWxlKFxuICBtb2R1bGVQYXRoOiBzdHJpbmcsXG4gIGZzTWFwOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+LFxuICBiYXNlUGF0aDogc3RyaW5nLFxuKTogc3RyaW5nIHwgbnVsbCB7XG4gIGNvbnN0IGN0eCA9IGNyZWF0ZUNvbnRleHQobW9kdWxlUGF0aCwgZnNNYXAsIGJhc2VQYXRoKVxuICByZXR1cm4gcmVzb2x2ZU5vZGVNb2R1bGVJblBhdGgoY3R4LmJhc2VQYXRoLCBjdHgpXG59XG4iLCAiaW1wb3J0IHsgcmVzb2x2ZU5vZGVNb2R1bGUgfSBmcm9tIFwibGliL3V0aWxzL3Jlc29sdmUtbm9kZS1tb2R1bGVcIlxuaW1wb3J0IHR5cGUgeyBFeGVjdXRpb25Db250ZXh0IH0gZnJvbSBcIi4vZXhlY3V0aW9uLWNvbnRleHRcIlxuaW1wb3J0IHsgaW1wb3J0TG9jYWxGaWxlIH0gZnJvbSBcIi4vaW1wb3J0LWxvY2FsLWZpbGVcIlxuXG5leHBvcnQgY29uc3QgaW1wb3J0Tm9kZU1vZHVsZSA9IGFzeW5jIChcbiAgaW1wb3J0TmFtZTogc3RyaW5nLFxuICBjdHg6IEV4ZWN1dGlvbkNvbnRleHQsXG4gIGRlcHRoID0gMCxcbikgPT4ge1xuICBjb25zdCB7IHByZVN1cHBsaWVkSW1wb3J0cyB9ID0gY3R4XG5cbiAgaWYgKHByZVN1cHBsaWVkSW1wb3J0c1tpbXBvcnROYW1lXSkge1xuICAgIHJldHVyblxuICB9XG5cbiAgY29uc3QgcmVzb2x2ZWROb2RlTW9kdWxlUGF0aCA9IHJlc29sdmVOb2RlTW9kdWxlKGltcG9ydE5hbWUsIGN0eC5mc01hcCwgXCJcIilcblxuICBpZiAoIXJlc29sdmVkTm9kZU1vZHVsZVBhdGgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYE5vZGUgbW9kdWxlIFwiJHtpbXBvcnROYW1lfVwiIG5vdCBmb3VuZGApXG4gIH1cblxuICAvLyBVc2UgaW1wb3J0TG9jYWxGaWxlIHRvIGhhbmRsZSB0aGUgbm9kZSBtb2R1bGVcbiAgYXdhaXQgaW1wb3J0TG9jYWxGaWxlKHJlc29sdmVkTm9kZU1vZHVsZVBhdGgsIGN0eCwgZGVwdGgpXG5cbiAgLy8gTWFwIHRoZSBvcmlnaW5hbCBpbXBvcnQgbmFtZSB0byB0aGUgcmVzb2x2ZWQgbW9kdWxlJ3MgZXhwb3J0c1xuICBwcmVTdXBwbGllZEltcG9ydHNbaW1wb3J0TmFtZV0gPSBwcmVTdXBwbGllZEltcG9ydHNbcmVzb2x2ZWROb2RlTW9kdWxlUGF0aF1cblxuICAvLyBNYXAgd2l0aG91dCBub2RlX21vZHVsZXMgcHJlZml4IGZvciBkaXJlY3QgaW1wb3J0c1xuICBjb25zdCB1bnByZWZpeGVkUGF0aCA9IHJlc29sdmVkTm9kZU1vZHVsZVBhdGgucmVwbGFjZSgvXm5vZGVfbW9kdWxlc1xcLy8sIFwiXCIpXG4gIHByZVN1cHBsaWVkSW1wb3J0c1t1bnByZWZpeGVkUGF0aF0gPVxuICAgIHByZVN1cHBsaWVkSW1wb3J0c1tyZXNvbHZlZE5vZGVNb2R1bGVQYXRoXVxuXG4gIC8vIEhhbmRsZSBpbmRleCBmaWxlcyBzcGVjaWFsbHlcbiAgaWYgKFxuICAgIHJlc29sdmVkTm9kZU1vZHVsZVBhdGguZW5kc1dpdGgoXCIvaW5kZXgudHN4XCIpIHx8XG4gICAgcmVzb2x2ZWROb2RlTW9kdWxlUGF0aC5lbmRzV2l0aChcIi9pbmRleC50c1wiKSB8fFxuICAgIHJlc29sdmVkTm9kZU1vZHVsZVBhdGguZW5kc1dpdGgoXCIvaW5kZXguanNcIilcbiAgKSB7XG4gICAgY29uc3QgZGlyUGF0aCA9IHJlc29sdmVkTm9kZU1vZHVsZVBhdGgucmVwbGFjZSgvXFwvaW5kZXhcXC4odHN4P3xqcykkLywgXCJcIilcbiAgICBjb25zdCB1bnByZWZpeGVkRGlyUGF0aCA9IGRpclBhdGgucmVwbGFjZSgvXm5vZGVfbW9kdWxlc1xcLy8sIFwiXCIpXG4gICAgcHJlU3VwcGxpZWRJbXBvcnRzW3VucHJlZml4ZWREaXJQYXRoXSA9XG4gICAgICBwcmVTdXBwbGllZEltcG9ydHNbcmVzb2x2ZWROb2RlTW9kdWxlUGF0aF1cblxuICAgIC8vIEhhbmRsZSBzY29wZWQgcGFja2FnZXNcbiAgICBpZiAodW5wcmVmaXhlZERpclBhdGguc3RhcnRzV2l0aChcIkBcIikpIHtcbiAgICAgIGNvbnN0IHNjb3BlUGFydHMgPSB1bnByZWZpeGVkRGlyUGF0aC5zcGxpdChcIi9cIilcbiAgICAgIGlmIChzY29wZVBhcnRzLmxlbmd0aCA+PSAyKSB7XG4gICAgICAgIGNvbnN0IHNjb3BlZE5hbWUgPSBgJHtzY29wZVBhcnRzWzBdfS8ke3Njb3BlUGFydHNbMV19YFxuICAgICAgICBwcmVTdXBwbGllZEltcG9ydHNbc2NvcGVkTmFtZV0gPVxuICAgICAgICAgIHByZVN1cHBsaWVkSW1wb3J0c1tyZXNvbHZlZE5vZGVNb2R1bGVQYXRoXVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuIiwgImltcG9ydCB7IHJlc29sdmVGaWxlUGF0aE9yVGhyb3cgfSBmcm9tIFwiLi9yZXNvbHZlRmlsZVBhdGhcIlxuaW1wb3J0IERlYnVnIGZyb20gXCJkZWJ1Z1wiXG5cbmNvbnN0IGRlYnVnID0gRGVidWcoXCJ0c2NpOmV2YWw6c2V0dXBEZWZhdWx0RW50cnlwb2ludElmTmVlZGVkXCIpXG5cbmV4cG9ydCBjb25zdCBzZXR1cERlZmF1bHRFbnRyeXBvaW50SWZOZWVkZWQgPSAob3B0czoge1xuICBlbnRyeXBvaW50Pzogc3RyaW5nXG4gIGZzTWFwOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+XG4gIG1haW5Db21wb25lbnRQYXRoPzogc3RyaW5nXG4gIG1haW5Db21wb25lbnROYW1lPzogc3RyaW5nXG4gIG5hbWU/OiBzdHJpbmdcbiAgbWFpbkNvbXBvbmVudFByb3BzPzogUmVjb3JkPHN0cmluZywgYW55PlxufSkgPT4ge1xuICBpZiAoIW9wdHMuZW50cnlwb2ludCAmJiAhb3B0cy5tYWluQ29tcG9uZW50UGF0aCkge1xuICAgIGlmIChcImluZGV4LnRzeFwiIGluIG9wdHMuZnNNYXApIHtcbiAgICAgIG9wdHMubWFpbkNvbXBvbmVudFBhdGggPSBcImluZGV4LnRzeFwiXG4gICAgfSBlbHNlIGlmIChcImluZGV4LnRzXCIgaW4gb3B0cy5mc01hcCkge1xuICAgICAgb3B0cy5tYWluQ29tcG9uZW50UGF0aCA9IFwiaW5kZXgudHNcIlxuICAgIH0gZWxzZSBpZiAoXG4gICAgICBPYmplY3Qua2V5cyhvcHRzLmZzTWFwKS5maWx0ZXIoKGspID0+IGsuZW5kc1dpdGgoXCIudHN4XCIpKS5sZW5ndGggPT09IDFcbiAgICApIHtcbiAgICAgIG9wdHMubWFpbkNvbXBvbmVudFBhdGggPSBPYmplY3Qua2V5cyhvcHRzLmZzTWFwKVswXVxuICAgIH0gZWxzZSBpZiAoXCJ0c2NpcmN1aXQuY29uZmlnLmpzb25cIiBpbiBvcHRzLmZzTWFwKSB7XG4gICAgICBjb25zdCBjb25maWdDb250ZW50ID0gb3B0cy5mc01hcFtcInRzY2lyY3VpdC5jb25maWcuanNvblwiXVxuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgY29uZmlnID0gSlNPTi5wYXJzZShjb25maWdDb250ZW50KVxuICAgICAgICBpZiAoY29uZmlnLm1haW5FbnRyeXBvaW50KSB7XG4gICAgICAgICAgb3B0cy5lbnRyeXBvaW50ID0gY29uZmlnLm1haW5FbnRyeXBvaW50XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY29uc29sZS53YXJuKFwiRmFpbGVkIHRvIHBhcnNlIHRzY2lyY3VpdC5jb25maWcuanNvbjpcIiwgZSlcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBcIkVpdGhlciBlbnRyeXBvaW50IG9yIG1haW5Db21wb25lbnRQYXRoIG11c3QgYmUgcHJvdmlkZWQgKG5vIGluZGV4IGZpbGUsIGNvdWxkIG5vdCBpbmZlciBlbnRyeXBvaW50KVwiLFxuICAgICAgKVxuICAgIH1cbiAgfVxuXG4gIGlmICghb3B0cy5lbnRyeXBvaW50ICYmIG9wdHMubWFpbkNvbXBvbmVudFBhdGgpIHtcbiAgICBvcHRzLmVudHJ5cG9pbnQgPSBcImVudHJ5cG9pbnQudHN4XCJcbiAgICBjb25zdCBtYWluQ29tcG9uZW50Q29kZSA9XG4gICAgICBvcHRzLmZzTWFwW3Jlc29sdmVGaWxlUGF0aE9yVGhyb3cob3B0cy5tYWluQ29tcG9uZW50UGF0aCwgb3B0cy5mc01hcCldXG4gICAgaWYgKCFtYWluQ29tcG9uZW50Q29kZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgTWFpbiBjb21wb25lbnQgcGF0aCBcIiR7b3B0cy5tYWluQ29tcG9uZW50UGF0aH1cIiBub3QgZm91bmQgaW4gZnNNYXAuIEF2YWlsYWJsZSBwYXRoczogJHtPYmplY3Qua2V5cyhvcHRzLmZzTWFwKS5qb2luKFwiLCBcIil9YCxcbiAgICAgIClcbiAgICB9XG5cbiAgICBjb25zdCBoYXNFeHBsaWNpdEJvYXJkID0gbWFpbkNvbXBvbmVudENvZGUuaW5jbHVkZXMoXCI8Ym9hcmRcIilcbiAgICBjb25zdCBoYXNUc2NpSW1wb3J0ID1cbiAgICAgIG1haW5Db21wb25lbnRDb2RlLmluY2x1ZGVzKFwiQHRzY2kvXCIpIHx8XG4gICAgICBtYWluQ29tcG9uZW50Q29kZS5pbmNsdWRlcygnZnJvbSBcIkB0c2NpJylcbiAgICBjb25zdCBzaG91bGRXcmFwSW5Cb2FyZCA9ICFoYXNFeHBsaWNpdEJvYXJkICYmICFoYXNUc2NpSW1wb3J0XG5cbiAgICBvcHRzLmZzTWFwW29wdHMuZW50cnlwb2ludF0gPSBgXG4gICAgIGltcG9ydCAqIGFzIFVzZXJDb21wb25lbnRzIGZyb20gXCIuLyR7b3B0cy5tYWluQ29tcG9uZW50UGF0aH1cIjtcbiAgICAgICAgICBcbiAgICAgICR7XG4gICAgICAgIG9wdHMubWFpbkNvbXBvbmVudE5hbWVcbiAgICAgICAgICA/IGBcbiAgICAgICAgY29uc3QgQ29tcG9uZW50VG9SZW5kZXIgPSBVc2VyQ29tcG9uZW50c1tcIiR7b3B0cy5tYWluQ29tcG9uZW50TmFtZX1cIl1cbiAgICAgICAgYFxuICAgICAgICAgIDogYGNvbnN0IENvbXBvbmVudFRvUmVuZGVyID0gT2JqZWN0LmVudHJpZXMoVXNlckNvbXBvbmVudHMpXG4gICAgICAgIC5maWx0ZXIoKFtuYW1lXSkgPT4gIW5hbWUuc3RhcnRzV2l0aChcInVzZVwiKSlcbiAgICAgICAgLm1hcCgoW18sIGNvbXBvbmVudF0pID0+IGNvbXBvbmVudClbMF0gfHwgKCgpID0+IG51bGwpO2BcbiAgICAgIH1cblxuICAgICAgICAgICAke1xuICAgICAgICAgICAgIGRlYnVnLmVuYWJsZWRcbiAgICAgICAgICAgICAgID8gYFxuICAgICBjb25zb2xlLmxvZyh7IFVzZXJDb21wb25lbnRzIH0pXG4gICAgIGNvbnNvbGUubG9nKFwiQ29tcG9uZW50VG9SZW5kZXIgXCIgKyBDb21wb25lbnRUb1JlbmRlci50b1N0cmluZygpLCAgeyBDb21wb25lbnRUb1JlbmRlciB9KVxuICAgICBgXG4gICAgICAgICAgICAgICA6IFwiXCJcbiAgICAgICAgICAgfVxuXG4gICAgICBjaXJjdWl0LmFkZChcbiAgICAgICAgJHtcbiAgICAgICAgICBzaG91bGRXcmFwSW5Cb2FyZFxuICAgICAgICAgICAgPyBgXG4gICAgICAgICAgPGJvYXJkPlxuICAgICAgICAgICAgPENvbXBvbmVudFRvUmVuZGVyIG5hbWU9XCJVMVwiICR7b3B0cy5tYWluQ29tcG9uZW50UHJvcHMgPyBgey4uLiR7SlNPTi5zdHJpbmdpZnkob3B0cy5tYWluQ29tcG9uZW50UHJvcHMsIG51bGwsIDIpfX1gIDogXCJcIn0gLz5cbiAgICAgICAgICA8L2JvYXJkPlxuICAgICAgICBgXG4gICAgICAgICAgICA6IGBcbiAgICAgICAgICA8Q29tcG9uZW50VG9SZW5kZXIgJHtvcHRzLm1haW5Db21wb25lbnRQcm9wcyA/IGB7Li4uJHtKU09OLnN0cmluZ2lmeShvcHRzLm1haW5Db21wb25lbnRQcm9wcywgbnVsbCwgMil9fWAgOiBcIlwifSAvPlxuICAgICAgICBgXG4gICAgICAgIH1cbiAgICAgICk7XG5gXG4gIH1cblxuICBpZiAoIW9wdHMubmFtZSAmJiBvcHRzLm1haW5Db21wb25lbnROYW1lKSB7XG4gICAgb3B0cy5uYW1lID0gb3B0cy5tYWluQ29tcG9uZW50TmFtZVxuICB9XG59XG4iLCAiaW1wb3J0IHsgQ2lyY3VpdFJ1bm5lciB9IGZyb20gXCIuL0NpcmN1aXRSdW5uZXJcIlxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcnVuVHNjaXJjdWl0Q29kZShcbiAgZmlsZXN5c3RlbU9yQ29kZVN0cmluZzogUmVjb3JkPHN0cmluZywgc3RyaW5nPiB8IHN0cmluZyxcbiAgb3B0cz86IE9taXQ8UGFyYW1ldGVyczxDaXJjdWl0UnVubmVyW1wiZXhlY3V0ZVdpdGhGc01hcFwiXT5bMF0sIFwiZnNNYXBcIj4sXG4pIHtcbiAgaWYgKFxuICAgIHR5cGVvZiBmaWxlc3lzdGVtT3JDb2RlU3RyaW5nID09PSBcInN0cmluZ1wiICYmXG4gICAgIWZpbGVzeXN0ZW1PckNvZGVTdHJpbmcuaW5jbHVkZXMoXCJleHBvcnRcIilcbiAgKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYFRoZSBcImV4cG9ydFwiIGtleXdvcmQgd2Fzbid0IGZvdW5kIGluIHlvdXIgcHJvdmlkZWQgY29kZS4gWW91IG5lZWQgdG8gZXhwb3J0IGEgY29tcG9uZW50IGluIHlvdXIgY29kZSwgZS5nLlxcblxcbmV4cG9ydCBkZWZhdWx0ICgpID0+IChcXG4gIDxyZXNpc3RvciBuYW1lPVwiUjFcIiByZXNpc3RhbmNlPVwiMWtcIiAvPlxcbilgLFxuICAgIClcbiAgfVxuICBjb25zdCBmaWxlc3lzdGVtID1cbiAgICB0eXBlb2YgZmlsZXN5c3RlbU9yQ29kZVN0cmluZyA9PT0gXCJzdHJpbmdcIlxuICAgICAgPyB7IFwidXNlci1jb2RlLnRzeFwiOiBmaWxlc3lzdGVtT3JDb2RlU3RyaW5nIH1cbiAgICAgIDogZmlsZXN5c3RlbU9yQ29kZVN0cmluZ1xuXG4gIGNvbnN0IGNpcmN1aXRSdW5uZXIgPSBuZXcgQ2lyY3VpdFJ1bm5lcigpXG5cbiAgYXdhaXQgY2lyY3VpdFJ1bm5lci5leGVjdXRlV2l0aEZzTWFwKHtcbiAgICBmc01hcDogZmlsZXN5c3RlbSxcbiAgICAuLi5vcHRzLFxuICB9KVxuXG4gIGF3YWl0IGNpcmN1aXRSdW5uZXIucmVuZGVyVW50aWxTZXR0bGVkKClcblxuICByZXR1cm4gYXdhaXQgY2lyY3VpdFJ1bm5lci5nZXRDaXJjdWl0SnNvbigpXG59XG4iLCAiaW1wb3J0IHsgcnVuVHNjaXJjdWl0Q29kZSB9IGZyb20gXCIuL3J1blRzY2lyY3VpdENvZGVcIlxuXG5leHBvcnQgY29uc3QgcnVuVHNjaXJjdWl0TW9kdWxlID0gYXN5bmMgKFxuICBtb2R1bGU6IHN0cmluZyxcbiAgb3B0czogeyBwcm9wcz86IFJlY29yZDxzdHJpbmcsIGFueT47IGV4cG9ydE5hbWU/OiBzdHJpbmcgfSA9IHt9LFxuKSA9PiB7XG4gIGlmICghbW9kdWxlLnN0YXJ0c1dpdGgoXCJAXCIpKSB7XG4gICAgbW9kdWxlID0gYEB0c2NpLyR7bW9kdWxlLnJlcGxhY2UoL1xcLy8sIFwiLlwiKX1gXG4gIH1cbiAgY29uc3QgY2lyY3VpdEpzb24gPSBhd2FpdCBydW5Uc2NpcmN1aXRDb2RlKFxuICAgIHtcbiAgICAgIC8vIFRPRE8gaGFuZGxlIGV4cG9ydHMgdGhhdCBhcmUgbm90IHRoZSBkZWZhdWx0IGV4cG9ydCBieSBzY2FubmluZ1xuICAgICAgLy8gb3RoZXJFeHBvcnRzIGZvciBjb21wb25lbnRzXG4gICAgICBcInVzZXItY29kZS50c3hcIjogYFxuICAgIGltcG9ydCBNb2R1bGUsICogYXMgb3RoZXJFeHBvcnRzIGZyb20gXCIke21vZHVsZX1cIjtcblxuICAgIGxldCBleHBvcnROYW1lID0gXCIke29wdHMuZXhwb3J0TmFtZSA/PyBcIlwifVwiXG5cbiAgICBpZiAoKCFNb2R1bGUgfHwgdHlwZW9mIE1vZHVsZSAhPT0gXCJmdW5jdGlvblwiKSAmJiAhQm9vbGVhbihleHBvcnROYW1lKSkge1xuICAgICAgZXhwb3J0TmFtZSA9IE9iamVjdC5rZXlzKG90aGVyRXhwb3J0cykuZmlsdGVyKGtleSA9PiBrZXlbMF0gPT09IGtleVswXS50b1VwcGVyQ2FzZSgpICYmIHR5cGVvZiBvdGhlckV4cG9ydHNba2V5XSA9PT0gXCJmdW5jdGlvblwiKVswXVxuICAgIH1cblxuICAgIGNvbnN0IGRlZmF1bHRFeHBvcnQgPSBleHBvcnROYW1lID8gb3RoZXJFeHBvcnRzW2V4cG9ydE5hbWVdIDogTW9kdWxlXG5cbiAgICBpZiAoIWRlZmF1bHRFeHBvcnQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcXGBObyBleHBvcnQgZm91bmQgZm9yIG1vZHVsZSBcIlxcJHttb2R1bGV9XCIgKHRyaWVkIFwiXFwke2V4cG9ydE5hbWUgPz8gXCJkZWZhdWx0XCJ9XCIpXFxgKVxuICAgIH1cblxuICAgIGV4cG9ydCBkZWZhdWx0IGRlZmF1bHRFeHBvcnQ7XG4gICAgYCxcbiAgICB9LFxuICAgIHtcbiAgICAgIG1haW5Db21wb25lbnRQcm9wczogb3B0cy5wcm9wcyxcbiAgICB9LFxuICApXG4gIHJldHVybiBjaXJjdWl0SnNvblxufVxuIl0sCiAgIm1hcHBpbmdzIjogIjtBQUFBLFNBQVMsbUJBQW1CO0FBRTVCLFlBQVksbUJBQW1CO0FBQy9CLFlBQVksV0FBVztBQUN2QixZQUFZLGdCQUFnQjtBQUM1QixZQUFZLHdCQUF3Qjs7O0FDSHBDLElBQU0sUUFBUSxvQkFBSSxJQUFpQjtBQUVuQyxJQUFNLG9CQUFvQixPQUFPLE1BQVcsV0FBZ0I7QUFDMUQsUUFBTSxjQUFjLElBQUksZ0JBQWdCO0FBQUEsSUFDdEMsR0FBRztBQUFBLElBQ0gsTUFBTTtBQUFBLEVBQ1IsQ0FBQyxFQUFFLFNBQVM7QUFDWixNQUFJLE1BQU0sSUFBSSxXQUFXLEdBQUc7QUFDMUIsV0FBTyxNQUFNLElBQUksV0FBVztBQUFBLEVBQzlCO0FBQ0EsUUFBTSxXQUFXLE1BQU07QUFBQSxJQUNyQixtQ0FBbUMsSUFBSSxTQUFTLFdBQVc7QUFBQSxFQUM3RDtBQUNBLFFB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Q0FBQztBQUVELFFBQU0sY0FBYyxtQkFBbUI7QUFFdkMsU0FBTyxNQUFNLGNBQWMsZUFBZTtBQUM1Qzs7O0FDM0JPLElBQU0scUJBQXFCLE9BQ2hDLFFBQ0EsT0FBNkQsQ0FBQyxNQUMzRDtBQUNILE1BQUksQ0FBQyxPQUFPLFdBQVcsR0FBRyxHQUFHO0FBQzNCLGFBQVMsU0FBUyxPQUFPLFFBQVEsTUFBTSxHQUFHLENBQUM7QUFBQSxFQUM3QztBQUNBLFFBQU0sY0FBYyxNQUFNO0FBQUEsSUFDeEI7QUFBQTtBQUFBO0FBQUEsTUFHRSxpQkFBaUI7QUFBQSw2Q0FDc0IsTUFBTTtBQUFBO0FBQUEsd0JBRTNCLEtBQUssY0FBYyxFQUFFO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxJQWN6QztBQUFBLElBQ0E7QUFBQSxNQUNFLG9CQUFvQixLQUFLO0FBQUEsSUFDM0I7QUFBQSxFQUNGO0FBQ0EsU0FBTztBQUNUOyIsCiAgIm5hbWVzIjogWyJEZWJ1ZyIsICJkZWJ1ZyIsICJpbXBvcnROYW1lIiwgIkRlYnVnIiwgImRlYnVnIiwgIkRlYnVnIiwgImRlYnVnIiwgIkRlYnVnIiwgImRlYnVnIl0KfQo=