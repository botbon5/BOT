// lib/worker.ts
import * as Comlink from "comlink";

// lib/utils/get-imports-from-code.ts
var getImportsFromCode = (code) => {
  const importRegex = /^\s*import\s+(?:(?:[\w\s]+,\s*)?(?:\*\s+as\s+[\w\s]+|\{[\s\w,]+\}|\w+)\s+from\s+)?['"](.+?)['"]/gm;
  const imports = [];
  let match;
  while ((match = importRegex.exec(code)) !== null) {
    imports.push(match[1]);
  }
  const reExportRegex = /^\s*export\s+(?:\*|(?:\{[\s\w,]+\}))\s+from\s+['"](.+?)['"]/gm;
  let reExportMatch;
  while ((reExportMatch = reExportRegex.exec(code)) !== null) {
    imports.push(reExportMatch[1]);
  }
  return imports;
};

// lib/worker.ts
var createCircuitWebWorker = async (configuration) => {
  const existingWorker = globalThis.TSCIRCUIT_GLOBAL_CIRCUIT_WORKER;
  if (existingWorker && typeof existingWorker.kill === "function") {
    if (configuration.verbose) {
      console.log("[Worker] Killing previous global worker instance...");
    }
    try {
      await existingWorker.kill();
    } catch (e) {
      if (configuration.verbose) {
        console.warn(
          "[Worker] Error killing previous global worker instance:",
          e
        );
      }
      if (globalThis.TSCIRCUIT_GLOBAL_CIRCUIT_WORKER === existingWorker) {
        globalThis.TSCIRCUIT_GLOBAL_CIRCUIT_WORKER = void 0;
      }
    }
  }
  if (configuration.verbose) {
    console.log(
      "[Worker] Creating circuit web worker with config:",
      configuration
    );
  }
  let workerBlobUrl = configuration.webWorkerBlobUrl ?? configuration.webWorkerUrl;
  if (!workerBlobUrl) {
    const cdnUrl = `https://cdn.jsdelivr.net/npm/@tscircuit/eval@${configuration.evalVersion ?? "latest"}/dist/webworker/entrypoint.js`;
    const workerBlob = await fetch(cdnUrl).then((res) => res.blob());
    workerBlobUrl = URL.createObjectURL(workerBlob);
  }
  const rawWorker = new Worker(workerBlobUrl, { type: "module" });
  let workerInitError;
  rawWorker.addEventListener("error", (event) => {
    console.error("[Worker] Error in worker", event);
    workerInitError = event;
  });
  rawWorker.addEventListener("unhandledrejection", (event) => {
    console.error("[Worker] Unhandled rejection in worker", event);
  });
  rawWorker.addEventListener("messageerror", (event) => {
    console.error("[Worker] Message error in worker", event);
  });
  const earlyMessageHandler = (event) => {
    console.log("[Worker] Message in worker", event);
  };
  rawWorker.addEventListener("message", earlyMessageHandler);
  if (workerInitError) {
    throw workerInitError;
  }
  const comlinkWorker = Comlink.wrap(rawWorker);
  rawWorker.removeEventListener("message", earlyMessageHandler);
  if (configuration.snippetsApiBaseUrl) {
    await comlinkWorker.setSnippetsApiBaseUrl(configuration.snippetsApiBaseUrl);
  }
  if (configuration.platform) {
    await comlinkWorker.setPlatformConfig(configuration.platform);
  }
  let isTerminated = false;
  const wrapper = {
    clearEventListeners: comlinkWorker.clearEventListeners.bind(comlinkWorker),
    version: comlinkWorker.version.bind(comlinkWorker),
    execute: async (...args) => {
      if (isTerminated) {
        throw new Error("CircuitWebWorker was terminated, can't execute");
      }
      return comlinkWorker.execute.bind(comlinkWorker)(...args);
    },
    executeWithFsMap: async (...args) => {
      if (isTerminated) {
        throw new Error(
          "CircuitWebWorker was terminated, can't executeWithFsMap"
        );
      }
      return comlinkWorker.executeWithFsMap.bind(comlinkWorker)(...args);
    },
    renderUntilSettled: comlinkWorker.renderUntilSettled.bind(comlinkWorker),
    getCircuitJson: comlinkWorker.getCircuitJson.bind(comlinkWorker),
    on: (event, callback) => {
      const proxiedCallback = Comlink.proxy(callback);
      comlinkWorker.on(event, proxiedCallback);
    },
    kill: async () => {
      comlinkWorker[Comlink.releaseProxy]();
      rawWorker.terminate();
      isTerminated = true;
      if (globalThis.TSCIRCUIT_GLOBAL_CIRCUIT_WORKER === wrapper) {
        globalThis.TSCIRCUIT_GLOBAL_CIRCUIT_WORKER = void 0;
      }
    }
  };
  globalThis.TSCIRCUIT_GLOBAL_CIRCUIT_WORKER = wrapper;
  return wrapper;
};
export {
  createCircuitWebWorker,
  getImportsFromCode
};
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsiLi4vbGliL3dvcmtlci50cyIsICIuLi9saWIvdXRpbHMvZ2V0LWltcG9ydHMtZnJvbS1jb2RlLnRzIl0sCiAgInNvdXJjZXNDb250ZW50IjogWyJpbXBvcnQgKiBhcyBDb21saW5rIGZyb20gXCJjb21saW5rXCJcbmV4cG9ydCAqIGZyb20gXCIuL3V0aWxzL2luZGV4XCJcbmltcG9ydCB0eXBlIHtcbiAgSW50ZXJuYWxXZWJXb3JrZXJBcGksXG4gIFdlYldvcmtlckNvbmZpZ3VyYXRpb24sXG4gIENpcmN1aXRXZWJXb3JrZXIsXG59IGZyb20gXCIuL3NoYXJlZC90eXBlc1wiXG5pbXBvcnQgdHlwZSB7IFJvb3RDaXJjdWl0RXZlbnROYW1lIH0gZnJvbSBcIkB0c2NpcmN1aXQvY29yZVwiXG5cbmV4cG9ydCB0eXBlIHsgQ2lyY3VpdFdlYldvcmtlciwgV2ViV29ya2VyQ29uZmlndXJhdGlvbiB9XG5cbmRlY2xhcmUgZ2xvYmFsIHtcbiAgaW50ZXJmYWNlIFdpbmRvdyB7XG4gICAgVFNDSVJDVUlUX0dMT0JBTF9DSVJDVUlUX1dPUktFUjogQ2lyY3VpdFdlYldvcmtlciB8IHVuZGVmaW5lZFxuICB9XG4gIHZhciBUU0NJUkNVSVRfR0xPQkFMX0NJUkNVSVRfV09SS0VSOiBDaXJjdWl0V2ViV29ya2VyIHwgdW5kZWZpbmVkXG59XG5cbmV4cG9ydCBjb25zdCBjcmVhdGVDaXJjdWl0V2ViV29ya2VyID0gYXN5bmMgKFxuICBjb25maWd1cmF0aW9uOiBQYXJ0aWFsPFdlYldvcmtlckNvbmZpZ3VyYXRpb24+LFxuKTogUHJvbWlzZTxDaXJjdWl0V2ViV29ya2VyPiA9PiB7XG4gIC8vIEtpbGwgZXhpc3RpbmcgZ2xvYmFsIHdvcmtlciBpbnN0YW5jZSBpZiBwcmVzZW50XG4gIGNvbnN0IGV4aXN0aW5nV29ya2VyID0gZ2xvYmFsVGhpcy5UU0NJUkNVSVRfR0xPQkFMX0NJUkNVSVRfV09SS0VSXG4gIGlmIChleGlzdGluZ1dvcmtlciAmJiB0eXBlb2YgZXhpc3RpbmdXb3JrZXIua2lsbCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgaWYgKGNvbmZpZ3VyYXRpb24udmVyYm9zZSkge1xuICAgICAgY29uc29sZS5sb2coXCJbV29ya2VyXSBLaWxsaW5nIHByZXZpb3VzIGdsb2JhbCB3b3JrZXIgaW5zdGFuY2UuLi5cIilcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IGV4aXN0aW5nV29ya2VyLmtpbGwoKVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGlmIChjb25maWd1cmF0aW9uLnZlcmJvc2UpIHtcbiAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgIFwiW1dvcmtlcl0gRXJyb3Iga2lsbGluZyBwcmV2aW91cyBnbG9iYWwgd29ya2VyIGluc3RhbmNlOlwiLFxuICAgICAgICAgIGUsXG4gICAgICAgIClcbiAgICAgIH1cbiAgICAgIC8vIEVuc3VyZSB0aGUga2V5IGlzIGNsZWFyZWQgZXZlbiBpZiBraWxsIHRocm93cyBhbiBlcnJvclxuICAgICAgaWYgKGdsb2JhbFRoaXMuVFNDSVJDVUlUX0dMT0JBTF9DSVJDVUlUX1dPUktFUiA9PT0gZXhpc3RpbmdXb3JrZXIpIHtcbiAgICAgICAgZ2xvYmFsVGhpcy5UU0NJUkNVSVRfR0xPQkFMX0NJUkNVSVRfV09SS0VSID0gdW5kZWZpbmVkXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKGNvbmZpZ3VyYXRpb24udmVyYm9zZSkge1xuICAgIGNvbnNvbGUubG9nKFxuICAgICAgXCJbV29ya2VyXSBDcmVhdGluZyBjaXJjdWl0IHdlYiB3b3JrZXIgd2l0aCBjb25maWc6XCIsXG4gICAgICBjb25maWd1cmF0aW9uLFxuICAgIClcbiAgfVxuXG4gIGxldCB3b3JrZXJCbG9iVXJsID1cbiAgICBjb25maWd1cmF0aW9uLndlYldvcmtlckJsb2JVcmwgPz8gY29uZmlndXJhdGlvbi53ZWJXb3JrZXJVcmxcblxuICBpZiAoIXdvcmtlckJsb2JVcmwpIHtcbiAgICBjb25zdCBjZG5VcmwgPSBgaHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L25wbS9AdHNjaXJjdWl0L2V2YWxAJHtjb25maWd1cmF0aW9uLmV2YWxWZXJzaW9uID8/IFwibGF0ZXN0XCJ9L2Rpc3Qvd2Vid29ya2VyL2VudHJ5cG9pbnQuanNgXG5cbiAgICBjb25zdCB3b3JrZXJCbG9iID0gYXdhaXQgZmV0Y2goY2RuVXJsKS50aGVuKChyZXMpID0+IHJlcy5ibG9iKCkpXG4gICAgd29ya2VyQmxvYlVybCA9IFVSTC5jcmVhdGVPYmplY3RVUkwod29ya2VyQmxvYilcbiAgfVxuXG4gIGNvbnN0IHJhd1dvcmtlciA9IG5ldyBXb3JrZXIod29ya2VyQmxvYlVybCwgeyB0eXBlOiBcIm1vZHVsZVwiIH0pXG4gIGxldCB3b3JrZXJJbml0RXJyb3I6IGFueVxuICByYXdXb3JrZXIuYWRkRXZlbnRMaXN0ZW5lcihcImVycm9yXCIsIChldmVudCkgPT4ge1xuICAgIGNvbnNvbGUuZXJyb3IoXCJbV29ya2VyXSBFcnJvciBpbiB3b3JrZXJcIiwgZXZlbnQpXG4gICAgd29ya2VySW5pdEVycm9yID0gZXZlbnRcbiAgfSlcbiAgcmF3V29ya2VyLmFkZEV2ZW50TGlzdGVuZXIoXCJ1bmhhbmRsZWRyZWplY3Rpb25cIiwgKGV2ZW50KSA9PiB7XG4gICAgY29uc29sZS5lcnJvcihcIltXb3JrZXJdIFVuaGFuZGxlZCByZWplY3Rpb24gaW4gd29ya2VyXCIsIGV2ZW50KVxuICB9KVxuICByYXdXb3JrZXIuYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VlcnJvclwiLCAoZXZlbnQpID0+IHtcbiAgICBjb25zb2xlLmVycm9yKFwiW1dvcmtlcl0gTWVzc2FnZSBlcnJvciBpbiB3b3JrZXJcIiwgZXZlbnQpXG4gIH0pXG4gIGNvbnN0IGVhcmx5TWVzc2FnZUhhbmRsZXIgPSAoZXZlbnQ6IE1lc3NhZ2VFdmVudCkgPT4ge1xuICAgIGNvbnNvbGUubG9nKFwiW1dvcmtlcl0gTWVzc2FnZSBpbiB3b3JrZXJcIiwgZXZlbnQpXG4gIH1cbiAgcmF3V29ya2VyLmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIGVhcmx5TWVzc2FnZUhhbmRsZXIpXG5cbiAgaWYgKHdvcmtlckluaXRFcnJvcikge1xuICAgIHRocm93IHdvcmtlckluaXRFcnJvclxuICB9XG5cbiAgY29uc3QgY29tbGlua1dvcmtlciA9IENvbWxpbmsud3JhcDxJbnRlcm5hbFdlYldvcmtlckFwaT4ocmF3V29ya2VyKVxuXG4gIHJhd1dvcmtlci5yZW1vdmVFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCBlYXJseU1lc3NhZ2VIYW5kbGVyKVxuXG4gIGlmIChjb25maWd1cmF0aW9uLnNuaXBwZXRzQXBpQmFzZVVybCkge1xuICAgIGF3YWl0IGNvbWxpbmtXb3JrZXIuc2V0U25pcHBldHNBcGlCYXNlVXJsKGNvbmZpZ3VyYXRpb24uc25pcHBldHNBcGlCYXNlVXJsKVxuICB9XG4gIGlmIChjb25maWd1cmF0aW9uLnBsYXRmb3JtKSB7XG4gICAgYXdhaXQgY29tbGlua1dvcmtlci5zZXRQbGF0Zm9ybUNvbmZpZyhjb25maWd1cmF0aW9uLnBsYXRmb3JtKVxuICB9XG5cbiAgbGV0IGlzVGVybWluYXRlZCA9IGZhbHNlXG5cbiAgLy8gQ3JlYXRlIGEgd3JhcHBlciB0aGF0IGhhbmRsZXMgZXZlbnRzIGRpcmVjdGx5IHRocm91Z2ggY2lyY3VpdCBpbnN0YW5jZVxuICBjb25zdCB3cmFwcGVyOiBDaXJjdWl0V2ViV29ya2VyID0ge1xuICAgIGNsZWFyRXZlbnRMaXN0ZW5lcnM6IGNvbWxpbmtXb3JrZXIuY2xlYXJFdmVudExpc3RlbmVycy5iaW5kKGNvbWxpbmtXb3JrZXIpLFxuICAgIHZlcnNpb246IGNvbWxpbmtXb3JrZXIudmVyc2lvbi5iaW5kKGNvbWxpbmtXb3JrZXIpLFxuICAgIGV4ZWN1dGU6IGFzeW5jICguLi5hcmdzKSA9PiB7XG4gICAgICBpZiAoaXNUZXJtaW5hdGVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNpcmN1aXRXZWJXb3JrZXIgd2FzIHRlcm1pbmF0ZWQsIGNhbid0IGV4ZWN1dGVcIilcbiAgICAgIH1cbiAgICAgIHJldHVybiBjb21saW5rV29ya2VyLmV4ZWN1dGUuYmluZChjb21saW5rV29ya2VyKSguLi5hcmdzKVxuICAgIH0sXG4gICAgZXhlY3V0ZVdpdGhGc01hcDogYXN5bmMgKC4uLmFyZ3MpID0+IHtcbiAgICAgIGlmIChpc1Rlcm1pbmF0ZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIFwiQ2lyY3VpdFdlYldvcmtlciB3YXMgdGVybWluYXRlZCwgY2FuJ3QgZXhlY3V0ZVdpdGhGc01hcFwiLFxuICAgICAgICApXG4gICAgICB9XG4gICAgICByZXR1cm4gY29tbGlua1dvcmtlci5leGVjdXRlV2l0aEZzTWFwLmJpbmQoY29tbGlua1dvcmtlcikoLi4uYXJncylcbiAgICB9LFxuICAgIHJlbmRlclVudGlsU2V0dGxlZDogY29tbGlua1dvcmtlci5yZW5kZXJVbnRpbFNldHRsZWQuYmluZChjb21saW5rV29ya2VyKSxcbiAgICBnZXRDaXJjdWl0SnNvbjogY29tbGlua1dvcmtlci5nZXRDaXJjdWl0SnNvbi5iaW5kKGNvbWxpbmtXb3JrZXIpLFxuICAgIG9uOiAoZXZlbnQ6IHN0cmluZywgY2FsbGJhY2s6ICguLi5hcmdzOiBhbnlbXSkgPT4gdm9pZCkgPT4ge1xuICAgICAgY29uc3QgcHJveGllZENhbGxiYWNrID0gQ29tbGluay5wcm94eShjYWxsYmFjaylcbiAgICAgIGNvbWxpbmtXb3JrZXIub24oZXZlbnQgYXMgUm9vdENpcmN1aXRFdmVudE5hbWUsIHByb3hpZWRDYWxsYmFjaylcbiAgICB9LFxuICAgIGtpbGw6IGFzeW5jICgpID0+IHtcbiAgICAgIGNvbWxpbmtXb3JrZXJbQ29tbGluay5yZWxlYXNlUHJveHldKClcbiAgICAgIHJhd1dvcmtlci50ZXJtaW5hdGUoKVxuICAgICAgaXNUZXJtaW5hdGVkID0gdHJ1ZVxuICAgICAgaWYgKGdsb2JhbFRoaXMuVFNDSVJDVUlUX0dMT0JBTF9DSVJDVUlUX1dPUktFUiA9PT0gd3JhcHBlcikge1xuICAgICAgICBnbG9iYWxUaGlzLlRTQ0lSQ1VJVF9HTE9CQUxfQ0lSQ1VJVF9XT1JLRVIgPSB1bmRlZmluZWRcbiAgICAgIH1cbiAgICB9LFxuICB9XG4gIGdsb2JhbFRoaXMuVFNDSVJDVUlUX0dMT0JBTF9DSVJDVUlUX1dPUktFUiA9IHdyYXBwZXJcbiAgcmV0dXJuIHdyYXBwZXJcbn1cbiIsICJleHBvcnQgY29uc3QgZ2V0SW1wb3J0c0Zyb21Db2RlID0gKGNvZGU6IHN0cmluZyk6IHN0cmluZ1tdID0+IHtcbiAgLy8gTWF0Y2ggYmFzaWMgaW1wb3J0IHBhdHRlcm5zIGluY2x1ZGluZyBjb21iaW5lZCBkZWZhdWx0IGFuZCBuYW1lc3BhY2UgaW1wb3J0c1xuICBjb25zdCBpbXBvcnRSZWdleCA9XG4gICAgL15cXHMqaW1wb3J0XFxzKyg/Oig/OltcXHdcXHNdKyxcXHMqKT8oPzpcXCpcXHMrYXNcXHMrW1xcd1xcc10rfFxce1tcXHNcXHcsXStcXH18XFx3KylcXHMrZnJvbVxccyspP1snXCJdKC4rPylbJ1wiXS9nbVxuICBjb25zdCBpbXBvcnRzOiBzdHJpbmdbXSA9IFtdXG4gIGxldCBtYXRjaDogUmVnRXhwRXhlY0FycmF5IHwgbnVsbFxuXG4gIC8vIGJpb21lLWlnbm9yZSBsaW50L3N1c3BpY2lvdXMvbm9Bc3NpZ25JbkV4cHJlc3Npb25zOiA8ZXhwbGFuYXRpb24+XG4gIHdoaWxlICgobWF0Y2ggPSBpbXBvcnRSZWdleC5leGVjKGNvZGUpKSAhPT0gbnVsbCkge1xuICAgIGltcG9ydHMucHVzaChtYXRjaFsxXSlcbiAgfVxuXG4gIC8vIE1hdGNoIHJlLWV4cG9ydHNcbiAgY29uc3QgcmVFeHBvcnRSZWdleCA9XG4gICAgL15cXHMqZXhwb3J0XFxzKyg/OlxcKnwoPzpcXHtbXFxzXFx3LF0rXFx9KSlcXHMrZnJvbVxccytbJ1wiXSguKz8pWydcIl0vZ21cbiAgbGV0IHJlRXhwb3J0TWF0Y2g6IFJlZ0V4cEV4ZWNBcnJheSB8IG51bGxcbiAgLy8gYmlvbWUtaWdub3JlIGxpbnQvc3VzcGljaW91cy9ub0Fzc2lnbkluRXhwcmVzc2lvbnM6IDxleHBsYW5hdGlvbj5cbiAgd2hpbGUgKChyZUV4cG9ydE1hdGNoID0gcmVFeHBvcnRSZWdleC5leGVjKGNvZGUpKSAhPT0gbnVsbCkge1xuICAgIGltcG9ydHMucHVzaChyZUV4cG9ydE1hdGNoWzFdKVxuICB9XG5cbiAgcmV0dXJuIGltcG9ydHNcbn1cbiJdLAogICJtYXBwaW5ncyI6ICI7QUFBQSxZQUFZLGFBQWE7OztBQ0FsQixJQUFNLHFCQUFxQixDQUFDLFNBQTJCO0FBRTVELFFBQU0sY0FDSjtBQUNGLFFBQU0sVUFBb0IsQ0FBQztBQUMzQixNQUFJO0FBR0osVUFBUSxRQUFRLFlBQVksS0FBSyxJQUFJLE9BQU8sTUFBTTtBQUNoRCxZQUFRLEtBQUssTUFBTSxDQUFDLENBQUM7QUFBQSxFQUN2QjtBQUdBLFFBQU0sZ0JBQ0o7QUFDRixNQUFJO0FBRUosVUFBUSxnQkFBZ0IsY0FBYyxLQUFLLElBQUksT0FBTyxNQUFNO0FBQzFELFlBQVEsS0FBSyxjQUFjLENBQUMsQ0FBQztBQUFBLEVBQy9CO0FBRUEsU0FBTztBQUNUOzs7QURKTyxJQUFNLHlCQUF5QixPQUNwQyxrQkFDOEI7QUFFOUIsUUFBTSxpQkFBaUIsV0FBVztBQUNsQyxNQUFJLGtCQUFrQixPQUFPLGVBQWUsU0FBUyxZQUFZO0FBQy9ELFFBQUksY0FBYyxTQUFTO0FBQ3pCLGNBQVEsSUFBSSxxREFBcUQ7QUFBQSxJQUNuRTtBQUNBLFFBQUk7QUFDRixZQUFNLGVBQWUsS0FBSztBQUFBLElBQzVCLFNBQVMsR0FBRztBQUNWLFVBQUksY0FBYyxTQUFTO0FBQ3pCLGdCQUFRO0FBQUEsVUFDTjtBQUFBLFVBQ0E7QUFBQSxRQUNGO0FBQUEsTUFDRjtBQUVBLFVBQUksV0FBVyxvQ0FBb0MsZ0JBQWdCO0FBQ2pFLG1CQUFXLGtDQUFrQztBQUFBLE1BQy9DO0FBQUEsSUFDRjtBQUFBLEVBQ0Y7QUFFQSxNQUFJLGNBQWMsU0FBUztBQUN6QixZQUFRO0FBQUEsTUFDTjtBQUFBLE1B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