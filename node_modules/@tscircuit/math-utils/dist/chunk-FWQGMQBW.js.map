{"version":3,"sources":["../src/segment-distance.ts"],"sourcesContent":["import type { Point } from \"./common\"\nimport {\n  distance,\n  doSegmentsIntersect,\n  pointToSegmentDistance,\n} from \"./line-intersections\"\nimport { clamp } from \"./nearest-box\"\n\n/**\n * Returns the minimum distance between two line segments.\n */\nexport function segmentToSegmentMinDistance(\n  a: Point,\n  b: Point,\n  u: Point,\n  v: Point,\n): number {\n  // Handle degenerate cases: segments of zero length\n  if (a.x === b.x && a.y === b.y) {\n    return pointToSegmentDistance(a, u, v)\n  }\n  if (u.x === v.x && u.y === v.y) {\n    return pointToSegmentDistance(u, a, b)\n  }\n\n  // Check if segments intersect\n  if (doSegmentsIntersect(a, b, u, v)) {\n    return 0\n  }\n\n  // Compute the minimum distance between the segments\n  const distances = [\n    pointToSegmentDistance(a, u, v),\n    pointToSegmentDistance(b, u, v),\n    pointToSegmentDistance(u, a, b),\n    pointToSegmentDistance(v, a, b),\n  ]\n\n  return Math.min(...distances)\n}\n\n/**\n * Returns the minimum distance from a line segment to a bounding box.\n */\nexport function segmentToBoundsMinDistance(\n  a: Point,\n  b: Point,\n  bounds: { minX: number; minY: number; maxX: number; maxY: number },\n): number {\n  // Check if segment intersects with the bounds\n  // Create the four edges of the bounds\n  const topLeft = { x: bounds.minX, y: bounds.minY }\n  const topRight = { x: bounds.maxX, y: bounds.minY }\n  const bottomLeft = { x: bounds.minX, y: bounds.maxY }\n  const bottomRight = { x: bounds.maxX, y: bounds.maxY }\n\n  // Check if segment intersects with any of the bounds edges\n  if (\n    doSegmentsIntersect(a, b, topLeft, topRight) ||\n    doSegmentsIntersect(a, b, topRight, bottomRight) ||\n    doSegmentsIntersect(a, b, bottomRight, bottomLeft) ||\n    doSegmentsIntersect(a, b, bottomLeft, topLeft)\n  ) {\n    return 0\n  }\n\n  // Check if segment is entirely inside the bounds\n  if (\n    a.x >= bounds.minX &&\n    a.x <= bounds.maxX &&\n    a.y >= bounds.minY &&\n    a.y <= bounds.maxY &&\n    b.x >= bounds.minX &&\n    b.x <= bounds.maxX &&\n    b.y >= bounds.minY &&\n    b.y <= bounds.maxY\n  ) {\n    return 0\n  }\n\n  // If not intersecting, calculate the minimum distance\n  const distances = [\n    pointToSegmentDistance(topLeft, a, b),\n    pointToSegmentDistance(topRight, a, b),\n    pointToSegmentDistance(bottomLeft, a, b),\n    pointToSegmentDistance(bottomRight, a, b),\n  ]\n\n  // If one of the segment endpoints is inside the bounds, we need to consider its distance to the bounds as 0\n  if (\n    a.x >= bounds.minX &&\n    a.x <= bounds.maxX &&\n    a.y >= bounds.minY &&\n    a.y <= bounds.maxY\n  ) {\n    return 0\n  }\n\n  if (\n    b.x >= bounds.minX &&\n    b.x <= bounds.maxX &&\n    b.y >= bounds.minY &&\n    b.y <= bounds.maxY\n  ) {\n    return 0\n  }\n\n  // Calculate distances from segment endpoints to bounds if outside\n  if (\n    a.x < bounds.minX ||\n    a.x > bounds.maxX ||\n    a.y < bounds.minY ||\n    a.y > bounds.maxY\n  ) {\n    const closestX = clamp(a.x, bounds.minX, bounds.maxX)\n    const closestY = clamp(a.y, bounds.minY, bounds.maxY)\n    distances.push(distance(a, { x: closestX, y: closestY }))\n  }\n\n  if (\n    b.x < bounds.minX ||\n    b.x > bounds.maxX ||\n    b.y < bounds.minY ||\n    b.y > bounds.maxY\n  ) {\n    const closestX = clamp(b.x, bounds.minX, bounds.maxX)\n    const closestY = clamp(b.y, bounds.minY, bounds.maxY)\n    distances.push(distance(b, { x: closestX, y: closestY }))\n  }\n\n  return Math.min(...distances)\n}\n\n/**\n * Returns the minimum distance from a line segment to a box.\n */\nexport function segmentToBoxMinDistance(\n  a: Point,\n  b: Point,\n  box: { center: Point; width: number; height: number },\n): number {\n  const halfWidth = box.width / 2\n  const halfHeight = box.height / 2\n  const bounds = {\n    minX: box.center.x - halfWidth,\n    maxX: box.center.x + halfWidth,\n    minY: box.center.y - halfHeight,\n    maxY: box.center.y + halfHeight,\n  }\n\n  return segmentToBoundsMinDistance(a, b, bounds)\n}\n\n/**\n * Returns the minimum distance from a line segment to a circle.\n */\nexport function segmentToCircleMinDistance(\n  a: Point,\n  b: Point,\n  circle: { x: number; y: number; radius: number },\n): number {\n  // Calculate the distance from the circle center to the line segment\n  const circleCenter = { x: circle.x, y: circle.y }\n\n  // Handle degenerate case: segment of zero length (point to circle)\n  if (a.x === b.x && a.y === b.y) {\n    return Math.max(0, distance(a, circleCenter) - circle.radius)\n  }\n\n  // Vector from a to b\n  const ab = { x: b.x - a.x, y: b.y - a.y }\n  // Vector from a to circle center\n  const ac = { x: circleCenter.x - a.x, y: circleCenter.y - a.y }\n\n  // Length of segment ab squared\n  const abLengthSq = ab.x * ab.x + ab.y * ab.y\n\n  // Calculate projection of ac onto ab, normalized by the length of ab\n  const t = Math.max(0, Math.min(1, (ab.x * ac.x + ab.y * ac.y) / abLengthSq))\n\n  // Find the closest point on the segment to the circle center\n  const closestPoint = {\n    x: a.x + t * ab.x,\n    y: a.y + t * ab.y,\n  }\n\n  // Calculate distance from closest point to circle center\n  const distToCenter = distance(closestPoint, circleCenter)\n\n  // Return the distance to the circle (subtract radius from distance to center)\n  return Math.max(0, distToCenter - circle.radius)\n}\n\nexport function pointToSegmentClosestPoint(\n  p: Point,\n  a: Point,\n  b: Point,\n): Point {\n  const dx_ab = b.x - a.x\n  const dy_ab = b.y - a.y\n  const l2 = dx_ab * dx_ab + dy_ab * dy_ab\n\n  if (l2 === 0) return { x: a.x, y: a.y } // Segment is a point\n\n  // Project p onto the line defined by a, b\n  // t = [(p - a) . (b - a)] / |b - a|^2\n  let t = ((p.x - a.x) * dx_ab + (p.y - a.y) * dy_ab) / l2\n\n  // Clamp t to the range [0, 1] to stay on the segment\n  t = Math.max(0, Math.min(1, t))\n\n  // Calculate the projection point\n  const closestPoint = {\n    x: a.x + t * dx_ab,\n    y: a.y + t * dy_ab,\n  }\n\n  return closestPoint\n}\n"],"mappings":"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","names":[]}