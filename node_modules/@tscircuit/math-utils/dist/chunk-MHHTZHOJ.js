// src/nearest-box.ts
function getBoundingBox(box) {
  const halfWidth = box.width / 2;
  const halfHeight = box.height / 2;
  return {
    minX: box.center.x - halfWidth,
    maxX: box.center.x + halfWidth,
    minY: box.center.y - halfHeight,
    maxY: box.center.y + halfHeight
  };
}
function computeDistanceBetweenBoxes(boxA, boxB) {
  const a = getBoundingBox(boxA);
  const b = getBoundingBox(boxB);
  const dx = Math.max(a.minX - b.maxX, b.minX - a.maxX, 0);
  const dy = Math.max(a.minY - b.maxY, b.minY - a.maxY, 0);
  const pointA = { x: 0, y: 0 };
  const pointB = { x: 0, y: 0 };
  if (dx === 0 && dy === 0) {
    return { distance: 0, pointA: boxA.center, pointB: boxB.center };
  }
  pointA.x = clamp(boxA.center.x, b.minX, b.maxX);
  pointA.y = clamp(boxA.center.y, b.minY, b.maxY);
  pointB.x = clamp(boxB.center.x, a.minX, a.maxX);
  pointB.y = clamp(boxB.center.y, a.minY, a.maxY);
  const distance = Math.hypot(pointA.x - pointB.x, pointA.y - pointB.y);
  return { distance, pointA, pointB };
}
function clamp(value, min, max) {
  return Math.max(min, Math.min(max, value));
}
function findNearestPointsBetweenBoxSets(boxSetA, boxSetB) {
  let minDistance = Number.POSITIVE_INFINITY;
  let nearestPointA = { x: 0, y: 0 };
  let nearestPointB = { x: 0, y: 0 };
  for (const boxA of boxSetA) {
    for (const boxB of boxSetB) {
      const { distance, pointA, pointB } = computeDistanceBetweenBoxes(
        boxA,
        boxB
      );
      if (distance < minDistance) {
        minDistance = distance;
        nearestPointA = pointA;
        nearestPointB = pointB;
      }
    }
  }
  return {
    pointA: nearestPointA,
    pointB: nearestPointB,
    distance: minDistance
  };
}

export {
  getBoundingBox,
  computeDistanceBetweenBoxes,
  clamp,
  findNearestPointsBetweenBoxSets
};
//# sourceMappingURL=chunk-MHHTZHOJ.js.map