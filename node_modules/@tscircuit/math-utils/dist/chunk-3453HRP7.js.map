{"version":3,"sources":["../src/line-intersections.ts"],"sourcesContent":["import type { Point } from \"./common\"\n\n/**\n * Returns true if the two lines intersect.\n */\nexport function doesLineIntersectLine(\n  [a1, a2]: [Point, Point],\n  [b1, b2]: [Point, Point],\n  {\n    lineThickness = 0,\n  }: {\n    lineThickness?: number\n  } = {},\n): boolean {\n  if (lineThickness === 0) {\n    return doSegmentsIntersect(a1, a2, b1, b2)\n  }\n  const minDist = segmentsDistance(a1, a2, b1, b2)\n  return minDist <= lineThickness\n}\n\n/**\n * Returns true if the two segments intersect.\n */\nexport function doSegmentsIntersect(\n  p1: Point,\n  q1: Point,\n  p2: Point,\n  q2: Point,\n): boolean {\n  const o1 = orientation(p1, q1, p2)\n  const o2 = orientation(p1, q1, q2)\n  const o3 = orientation(p2, q2, p1)\n  const o4 = orientation(p2, q2, q1)\n\n  // General case\n  if (o1 !== o2 && o3 !== o4) {\n    return true\n  }\n\n  // Special Cases\n  if (o1 === 0 && onSegment(p1, p2, q1)) return true\n  if (o2 === 0 && onSegment(p1, q2, q1)) return true\n  if (o3 === 0 && onSegment(p2, p1, q2)) return true\n  if (o4 === 0 && onSegment(p2, q1, q2)) return true\n\n  return false\n}\n\n/**\n * Returns 0 if the points are colinear, 1 if they are clockwise, and 2 if they are counterclockwise.\n */\nexport function orientation(p: Point, q: Point, r: Point): number {\n  const val = (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y)\n  if (val === 0) return 0 // colinear\n  return val > 0 ? 1 : 2 // clock or counterclock wise\n}\n\n/**\n * Returns true if q is on the segment p->r.\n */\nexport function onSegment(p: Point, q: Point, r: Point): boolean {\n  return (\n    q.x <= Math.max(p.x, r.x) &&\n    q.x >= Math.min(p.x, r.x) &&\n    q.y <= Math.max(p.y, r.y) &&\n    q.y >= Math.min(p.y, r.y)\n  )\n}\n\n/**\n * Returns the minimum distance between two segments.\n */\nfunction segmentsDistance(a1: Point, a2: Point, b1: Point, b2: Point): number {\n  // Handle degenerate cases: segments of zero length\n  if (a1.x === a2.x && a1.y === a2.y) {\n    return pointToSegmentDistance(a1, b1, b2)\n  }\n  if (b1.x === b2.x && b1.y === b2.y) {\n    return pointToSegmentDistance(b1, a1, a2)\n  }\n\n  // Check if segments intersect\n  if (doSegmentsIntersect(a1, a2, b1, b2)) {\n    return 0\n  }\n\n  // Compute the minimum distance between the segments\n  const distances = [\n    pointToSegmentDistance(a1, b1, b2),\n    pointToSegmentDistance(a2, b1, b2),\n    pointToSegmentDistance(b1, a1, a2),\n    pointToSegmentDistance(b2, a1, a2),\n  ]\n\n  return Math.min(...distances)\n}\n\n/**\n * Returns the minimum distance between a point and a segment.\n */\nexport function pointToSegmentDistance(p: Point, v: Point, w: Point): number {\n  const l2 = (w.x - v.x) ** 2 + (w.y - v.y) ** 2\n  if (l2 === 0) return distance(p, v)\n\n  let t = ((p.x - v.x) * (w.x - v.x) + (p.y - v.y) * (w.y - v.y)) / l2\n  t = Math.max(0, Math.min(1, t))\n\n  const projection = {\n    x: v.x + t * (w.x - v.x),\n    y: v.y + t * (w.y - v.y),\n  }\n\n  return distance(p, projection)\n}\n\n/**\n * Returns the distance between two points.\n */\nexport function distance(p1: Point, p2: Point): number {\n  const dx = p1.x - p2.x\n  const dy = p1.y - p2.y\n  return Math.sqrt(dx * dx + dy * dy)\n}\n\n/**\n * Calculates the intersection point of two line segments.\n * Returns the intersection point {x, y} if the segments intersect, otherwise returns null.\n */\nexport function getSegmentIntersection(\n  a: Point,\n  b: Point,\n  u: Point,\n  v: Point,\n): Point | null {\n  const dx1 = b.x - a.x\n  const dy1 = b.y - a.y\n  const dx2 = v.x - u.x\n  const dy2 = v.y - u.y\n  const dx3 = a.x - u.x\n  const dy3 = a.y - u.y\n\n  const denominator = dx1 * dy2 - dy1 * dx2\n\n  // Check if lines are parallel or collinear\n  if (Math.abs(denominator) < 1e-10) {\n    // Lines are parallel or collinear\n    // We could add checks for collinear overlapping segments if needed,\n    // but for now, we return null as a single intersection point doesn't exist.\n    // The doSegmentsIntersect function handles collinearity checks if only a boolean is needed.\n    return null\n  }\n\n  // Correct formula for t (parameter for segment ab)\n  // t = (dy3 * dx2 - dx3 * dy2) / denominator\n  // The formula previously used was -(dy3 * dx2 - dx3 * dy2) / denominator\n  const t = (dy3 * dx2 - dx3 * dy2) / denominator\n  // Correct formula for s (parameter for segment uv)\n  // s = (dx1 * dy3 - dy1 * dx3) / denominator\n  // The formula previously used was incorrect.\n  const s = (dx1 * dy3 - dy1 * dx3) / denominator\n\n  // Check if the intersection point lies within both segments\n  // Use a small epsilon for floating point comparisons near 0 and 1\n  const epsilon = 1e-9\n  if (t >= -epsilon && t <= 1 + epsilon && s >= -epsilon && s <= 1 + epsilon) {\n    const intersectionX = a.x + t * dx1\n    const intersectionY = a.y + t * dy1\n    return { x: intersectionX, y: intersectionY }\n  }\n\n  // Segments do not intersect within their bounds\n  return null\n}\n"],"mappings":"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","names":[]}