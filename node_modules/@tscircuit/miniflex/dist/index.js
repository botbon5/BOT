// lib/minimal-flexbox.ts
var defaultStyle = {
  flexGrow: 0,
  flexShrink: 1,
  flexBasis: 0,
  alignSelf: "auto",
  width: void 0,
  height: void 0
};
var FlexNode = class {
  id;
  /** Computed layout values */
  size = { width: 0, height: 0 };
  position = { x: 0, y: 0 };
  /** Incoming flex style (grow / shrink / basis / alignSelf) */
  style;
  constructor(style = {}) {
    this.style = { ...defaultStyle, ...style };
    this.id = style.id;
  }
};
var FlexElement = class extends FlexNode {
  build() {
  }
};
var FlexBox = class _FlexBox extends FlexNode {
  children = [];
  // Containerâ€‘level layout options (with sensible defaults)
  direction = "row";
  columnGap = 0;
  rowGap = 0;
  justifyContent = "flex-start";
  alignItems = "stretch";
  constructor(width, height, opts = {}) {
    super({});
    this.size.width = width;
    this.size.height = height;
    this.id = opts.id;
    Object.assign(this, opts);
  }
  addChild(arg1, arg2) {
    if (arg1 instanceof _FlexBox) {
      const box = arg1;
      if (arg2) box.style = { ...defaultStyle, ...arg2 };
      this.children.push(box);
      return box;
    }
    const elem = new FlexElement(arg1);
    this.children.push(elem);
    return elem;
  }
  // --------------- Layout algorithm ------------------------
  build() {
    const horizontal = this.direction.startsWith("row");
    const mainProp = horizontal ? "width" : "height";
    const crossProp = horizontal ? "height" : "width";
    const mainGap = horizontal ? this.columnGap : this.rowGap;
    const crossGap = horizontal ? this.rowGap : this.columnGap;
    const gapTotal = mainGap * Math.max(0, this.children.length - 1);
    const containerMain = this.size[mainProp];
    const containerCross = this.size[crossProp];
    let totalBasis = 0;
    let totalGrow = 0;
    let totalShrink = 0;
    for (const child of this.children) {
      totalBasis += child.style.flexBasis;
      totalGrow += child.style.flexGrow;
      totalShrink += child.style.flexShrink;
    }
    const freeSpace = containerMain - totalBasis - gapTotal;
    for (const child of this.children) {
      let main = child.style.flexBasis;
      if (freeSpace > 0 && totalGrow > 0) {
        main += freeSpace * child.style.flexGrow / totalGrow;
      } else if (freeSpace < 0 && totalShrink > 0) {
        main += freeSpace * child.style.flexShrink / totalShrink;
        if (main < 0) main = 0;
      }
      child.size[mainProp] = main;
      const alignSelf = child.style.alignSelf !== "auto" ? child.style.alignSelf : this.alignItems;
      const explicitCrossSize = horizontal ? child.style.height : child.style.width;
      if (explicitCrossSize !== void 0) {
        child.size[crossProp] = explicitCrossSize;
      } else if (alignSelf === "stretch") {
        child.size[crossProp] = containerCross;
      } else {
      }
    }
    const occupied = this.children.reduce((sum, c) => sum + c.size[mainProp], 0) + gapTotal;
    const remaining = containerMain - occupied;
    let leading = 0;
    let between = mainGap;
    const n = this.children.length;
    switch (this.justifyContent) {
      case "flex-start":
        break;
      // defaults are fine
      case "flex-end":
        leading = remaining;
        break;
      case "center":
        leading = remaining / 2;
        break;
      case "space-between":
        between = n > 1 ? mainGap + remaining / (n - 1) : 0;
        break;
      case "space-around":
        between = mainGap + remaining / n;
        leading = between / 2;
        break;
      case "space-evenly":
        between = mainGap + remaining / (n + 1);
        leading = between;
        break;
    }
    const ordered = this.direction.endsWith("reverse") ? [...this.children].reverse() : this.children;
    let cursor = leading;
    for (const child of ordered) {
      if (horizontal) {
        child.position.x = this.direction === "row" ? cursor : containerMain - cursor - child.size.width;
        child.position.y = computeCross(
          child,
          crossProp,
          containerCross,
          this.alignItems
        );
      } else {
        child.position.y = this.direction === "column" ? cursor : containerMain - cursor - child.size.height;
        child.position.x = computeCross(
          child,
          crossProp,
          containerCross,
          this.alignItems
        );
      }
      cursor += child.size[mainProp] + between;
    }
    for (const child of this.children) {
      if (child instanceof _FlexBox) {
        child.build();
      }
    }
    function computeCross(child, prop, containerCross2, alignItems) {
      const alignSelf = child.style.alignSelf !== "auto" ? child.style.alignSelf : alignItems;
      switch (alignSelf) {
        case "flex-start":
          return 0;
        case "flex-end":
          return containerCross2 - child.size[prop];
        case "center":
          return (containerCross2 - child.size[prop]) / 2;
        case "stretch":
        default:
          return 0;
      }
    }
  }
};
var RootFlexBox = class extends FlexBox {
  constructor(width, height, opts = {}) {
    super(width, height, opts);
  }
  getLayout() {
    this.build();
    const layoutMap = {};
    this._collectLayout(this, layoutMap);
    return layoutMap;
  }
  _collectLayout(box, map, counterRef = { counter: 0 }) {
    for (const child of box.children) {
      const id = child.id ?? `_$$${counterRef.counter++}`;
      map[id] = { position: child.position, size: child.size };
      if (child instanceof FlexBox) {
        this._collectLayout(child, map, counterRef);
      }
    }
  }
};

// lib/flexBoxLayout.ts
function _getFlexBoxOptions(item) {
  const opts = { id: item.id };
  opts.direction = item.direction ?? "row";
  opts.columnGap = item.columnGap ?? 0;
  opts.rowGap = item.rowGap ?? 0;
  opts.justifyContent = item.justifyContent ?? "flex-start";
  opts.alignItems = item.alignItems ?? "stretch";
  return opts;
}
function _populateFlexBoxRecursive(flexContainer, items) {
  if (!items) {
    return;
  }
  for (const item of items) {
    if (item.children && item.children.length > 0) {
      const nestedBoxOptions = _getFlexBoxOptions(item);
      const initialWidth = item.width ?? 0;
      const initialHeight = item.height ?? 0;
      const nestedFlexBox = new FlexBox(
        initialWidth,
        initialHeight,
        nestedBoxOptions
      );
      flexContainer.addChild(nestedFlexBox, item);
      _populateFlexBoxRecursive(nestedFlexBox, item.children);
    } else {
      flexContainer.addChild(item);
    }
  }
}
var flexBoxLayout = (parent) => {
  const rootWidth = parent.width ?? 0;
  const rootHeight = parent.height ?? 0;
  const rootOpts = _getFlexBoxOptions(parent);
  const root = new RootFlexBox(rootWidth, rootHeight, rootOpts);
  _populateFlexBoxRecursive(root, parent.children);
  return root.getLayout();
};
export {
  FlexBox,
  FlexElement,
  RootFlexBox,
  flexBoxLayout
};
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsiLi4vbGliL21pbmltYWwtZmxleGJveC50cyIsICIuLi9saWIvZmxleEJveExheW91dC50cyJdLAogICJzb3VyY2VzQ29udGVudCI6IFsiLy8gbWluaW1hbC1mbGV4Ym94LnRzIFx1MjAxM1x1MDBBMHNpbmdsZVx1MjAxMWZpbGUgZmxleGJveCBlbmdpbmUgd2l0aCBkaXJlY3Rpb24sIGdhcCwgbmVzdGluZyAmIGFsaWdubWVudFxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gUHVibGljIEFQSSBzdW1tYXJ5XG4vLyAgIFx1MjAyMiBuZXcgUm9vdEZsZXhCb3god2lkdGgsIGhlaWdodCwgb3B0aW9ucz8pXG4vLyAgICAgICBvcHRpb25zID0geyBkaXJlY3Rpb24sIGNvbHVtbkdhcCwgcm93R2FwLCBqdXN0aWZ5Q29udGVudCwgYWxpZ25JdGVtcyB9XG4vLyAgIFx1MjAyMiByb290LmFkZENoaWxkKHN0eWxlPykgICAgICAgICAgICAgICAgIC8vIGFkZCBsZWFmIGVsZW1lbnRcbi8vICAgXHUyMDIyIHJvb3QuYWRkQ2hpbGQoY2hpbGRCb3gsIHN0eWxlPykgICAgICAgLy8gbmVzdCBhbm90aGVyIGZsZXggY29udGFpbmVyXG4vLyAgIFx1MjAyMiByb290LmJ1aWxkKCkgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNvbXB1dGUgdGhlIGxheW91dFxuLy8gICBcdTIwMjIgRXZlcnkgZWxlbWVudCAobGVhZiBvciBjb250YWluZXIpIGV4cG9zZXMgYC5wb3NpdGlvbmAgJiBgLnNpemVgXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmltcG9ydCB0eXBlIHtcbiAgRmxleFN0eWxlLFxuICBTaXplLFxuICBQb3NpdGlvbixcbiAgRGlyZWN0aW9uLFxuICBKdXN0aWZ5LFxuICBBbGlnbixcbiAgRmxleEJveE9wdGlvbnMsXG59IGZyb20gXCIuL3R5cGVzXCJcblxuY29uc3QgZGVmYXVsdFN0eWxlOiBGbGV4U3R5bGUgPSB7XG4gIGZsZXhHcm93OiAwLFxuICBmbGV4U2hyaW5rOiAxLFxuICBmbGV4QmFzaXM6IDAsXG4gIGFsaWduU2VsZjogXCJhdXRvXCIsXG4gIHdpZHRoOiB1bmRlZmluZWQsXG4gIGhlaWdodDogdW5kZWZpbmVkLFxufVxuXG4vLyAtLS0gQ29yZSBub2RlIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbmFic3RyYWN0IGNsYXNzIEZsZXhOb2RlIHtcbiAgaWQ/OiBzdHJpbmdcbiAgLyoqIENvbXB1dGVkIGxheW91dCB2YWx1ZXMgKi9cbiAgcHVibGljIHJlYWRvbmx5IHNpemU6IFNpemUgPSB7IHdpZHRoOiAwLCBoZWlnaHQ6IDAgfVxuICBwdWJsaWMgcmVhZG9ubHkgcG9zaXRpb246IFBvc2l0aW9uID0geyB4OiAwLCB5OiAwIH1cbiAgLyoqIEluY29taW5nIGZsZXggc3R5bGUgKGdyb3cgLyBzaHJpbmsgLyBiYXNpcyAvIGFsaWduU2VsZikgKi9cbiAgcHVibGljIHN0eWxlOiBGbGV4U3R5bGVcblxuICBjb25zdHJ1Y3RvcihzdHlsZTogUGFydGlhbDxGbGV4U3R5bGU+ID0ge30pIHtcbiAgICB0aGlzLnN0eWxlID0geyAuLi5kZWZhdWx0U3R5bGUsIC4uLnN0eWxlIH1cbiAgICB0aGlzLmlkID0gc3R5bGUuaWRcbiAgfVxuXG4gIC8qKiBSZWN1cnNpdmVseSBsYXkgb3V0IHRoZSBzdWJ0cmVlLiAqL1xuICBhYnN0cmFjdCBidWlsZCgpOiB2b2lkXG59XG5cbi8vIC0tLSBMZWFmIGVsZW1lbnQgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuZXhwb3J0IGNsYXNzIEZsZXhFbGVtZW50IGV4dGVuZHMgRmxleE5vZGUge1xuICBidWlsZCgpOiB2b2lkIHtcbiAgICAvKiBub3RoaW5nIHRvIHJlY3Vyc2UgaW50byAqL1xuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBGbGV4Qm94IGV4dGVuZHMgRmxleE5vZGUge1xuICBwdWJsaWMgcmVhZG9ubHkgY2hpbGRyZW46IEZsZXhOb2RlW10gPSBbXVxuXG4gIC8vIENvbnRhaW5lclx1MjAxMWxldmVsIGxheW91dCBvcHRpb25zICh3aXRoIHNlbnNpYmxlIGRlZmF1bHRzKVxuICBwdWJsaWMgZGlyZWN0aW9uOiBEaXJlY3Rpb24gPSBcInJvd1wiXG4gIHB1YmxpYyBjb2x1bW5HYXAgPSAwXG4gIHB1YmxpYyByb3dHYXAgPSAwXG4gIHB1YmxpYyBqdXN0aWZ5Q29udGVudDogSnVzdGlmeSA9IFwiZmxleC1zdGFydFwiXG4gIHB1YmxpYyBhbGlnbkl0ZW1zOiBBbGlnbiA9IFwic3RyZXRjaFwiXG5cbiAgY29uc3RydWN0b3Iod2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXIsIG9wdHM6IEZsZXhCb3hPcHRpb25zID0ge30pIHtcbiAgICBzdXBlcih7fSlcbiAgICAvLyBUaGUgY29udGFpbmVyXHUyMDE5cyBvd24gYm94IHNpemUgKHJvb3Qgc2V0cyB0aGlzIGV4cGxpY2l0bHk7IG5lc3RlZCBib3hlc1xuICAgIC8vIHJlY2VpdmUgdGhlaXIgc2l6ZSBmcm9tIHRoZSBwYXJlbnQgZHVyaW5nIGxheW91dCkuXG4gICAgdGhpcy5zaXplLndpZHRoID0gd2lkdGhcbiAgICB0aGlzLnNpemUuaGVpZ2h0ID0gaGVpZ2h0XG4gICAgdGhpcy5pZCA9IG9wdHMuaWRcbiAgICBPYmplY3QuYXNzaWduKHRoaXMsIG9wdHMpXG4gIH1cblxuICAvLyAtLS0tLS0tLS0tLS0tLS0gQnVpbGRpbmcgdGhlIHRyZWUgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgLyoqXG4gICAqIGFkZENoaWxkKHN0eWxlPykgXHUyMTkyIEZsZXhFbGVtZW50ICAgICAgICAobGVhZilcbiAgICogYWRkQ2hpbGQoY2hpbGRCb3gsIHN0eWxlPykgXHUyMTkyIEZsZXhCb3ggIChuZXN0IGFub3RoZXIgY29udGFpbmVyKVxuICAgKi9cbiAgYWRkQ2hpbGQoc3R5bGU6IFBhcnRpYWw8RmxleFN0eWxlPik6IEZsZXhFbGVtZW50XG4gIGFkZENoaWxkKGJveDogRmxleEJveCwgc3R5bGU/OiBQYXJ0aWFsPEZsZXhTdHlsZT4pOiBGbGV4Qm94XG4gIGFkZENoaWxkKGFyZzE6IGFueSwgYXJnMj86IGFueSk6IGFueSB7XG4gICAgaWYgKGFyZzEgaW5zdGFuY2VvZiBGbGV4Qm94KSB7XG4gICAgICBjb25zdCBib3ggPSBhcmcxIGFzIEZsZXhCb3hcbiAgICAgIGlmIChhcmcyKSBib3guc3R5bGUgPSB7IC4uLmRlZmF1bHRTdHlsZSwgLi4uYXJnMiB9XG4gICAgICB0aGlzLmNoaWxkcmVuLnB1c2goYm94KVxuICAgICAgcmV0dXJuIGJveFxuICAgIH1cbiAgICBjb25zdCBlbGVtID0gbmV3IEZsZXhFbGVtZW50KGFyZzEgYXMgUGFydGlhbDxGbGV4U3R5bGU+KVxuICAgIHRoaXMuY2hpbGRyZW4ucHVzaChlbGVtKVxuICAgIHJldHVybiBlbGVtXG4gIH1cblxuICAvLyAtLS0tLS0tLS0tLS0tLS0gTGF5b3V0IGFsZ29yaXRobSAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgYnVpbGQoKTogdm9pZCB7XG4gICAgLy8gMS4gSWRlbnRpZnkgYXhlcyAmIGdhcHNcbiAgICBjb25zdCBob3Jpem9udGFsID0gdGhpcy5kaXJlY3Rpb24uc3RhcnRzV2l0aChcInJvd1wiKVxuICAgIGNvbnN0IG1haW5Qcm9wOiBrZXlvZiBTaXplID0gaG9yaXpvbnRhbCA/IFwid2lkdGhcIiA6IFwiaGVpZ2h0XCJcbiAgICBjb25zdCBjcm9zc1Byb3A6IGtleW9mIFNpemUgPSBob3Jpem9udGFsID8gXCJoZWlnaHRcIiA6IFwid2lkdGhcIlxuICAgIGNvbnN0IG1haW5HYXAgPSBob3Jpem9udGFsID8gdGhpcy5jb2x1bW5HYXAgOiB0aGlzLnJvd0dhcFxuICAgIGNvbnN0IGNyb3NzR2FwID0gaG9yaXpvbnRhbCA/IHRoaXMucm93R2FwIDogdGhpcy5jb2x1bW5HYXAgLy8gbWF5IGJlIHVudXNlZCAoc2luZ2xlIGxpbmUpXG5cbiAgICAvLyAyLiBHYXRoZXIgZmxleCBzdGF0aXN0aWNzXG4gICAgY29uc3QgZ2FwVG90YWwgPSBtYWluR2FwICogTWF0aC5tYXgoMCwgdGhpcy5jaGlsZHJlbi5sZW5ndGggLSAxKVxuICAgIGNvbnN0IGNvbnRhaW5lck1haW4gPSB0aGlzLnNpemVbbWFpblByb3BdXG4gICAgY29uc3QgY29udGFpbmVyQ3Jvc3MgPSB0aGlzLnNpemVbY3Jvc3NQcm9wXVxuXG4gICAgbGV0IHRvdGFsQmFzaXMgPSAwXG4gICAgbGV0IHRvdGFsR3JvdyA9IDBcbiAgICBsZXQgdG90YWxTaHJpbmsgPSAwXG5cbiAgICBmb3IgKGNvbnN0IGNoaWxkIG9mIHRoaXMuY2hpbGRyZW4pIHtcbiAgICAgIHRvdGFsQmFzaXMgKz0gY2hpbGQuc3R5bGUuZmxleEJhc2lzXG4gICAgICB0b3RhbEdyb3cgKz0gY2hpbGQuc3R5bGUuZmxleEdyb3dcbiAgICAgIHRvdGFsU2hyaW5rICs9IGNoaWxkLnN0eWxlLmZsZXhTaHJpbmtcbiAgICB9XG5cbiAgICBjb25zdCBmcmVlU3BhY2UgPSBjb250YWluZXJNYWluIC0gdG90YWxCYXNpcyAtIGdhcFRvdGFsXG5cbiAgICAvLyAzLiBSZXNvbHZlIG1haW5cdTIwMTFheGlzIHNpemVzIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICBmb3IgKGNvbnN0IGNoaWxkIG9mIHRoaXMuY2hpbGRyZW4pIHtcbiAgICAgIGxldCBtYWluID0gY2hpbGQuc3R5bGUuZmxleEJhc2lzXG5cbiAgICAgIGlmIChmcmVlU3BhY2UgPiAwICYmIHRvdGFsR3JvdyA+IDApIHtcbiAgICAgICAgbWFpbiArPSAoZnJlZVNwYWNlICogY2hpbGQuc3R5bGUuZmxleEdyb3cpIC8gdG90YWxHcm93XG4gICAgICB9IGVsc2UgaWYgKGZyZWVTcGFjZSA8IDAgJiYgdG90YWxTaHJpbmsgPiAwKSB7XG4gICAgICAgIG1haW4gKz0gKGZyZWVTcGFjZSAqIGNoaWxkLnN0eWxlLmZsZXhTaHJpbmspIC8gdG90YWxTaHJpbmtcbiAgICAgICAgaWYgKG1haW4gPCAwKSBtYWluID0gMFxuICAgICAgfVxuXG4gICAgICBjaGlsZC5zaXplW21haW5Qcm9wXSA9IG1haW5cblxuICAgICAgLy8gQ3Jvc3NcdTIwMTFheGlzIHNpemUgKGFsaWduSXRlbXMgLyBhbGlnblNlbGYpXG4gICAgICBjb25zdCBhbGlnblNlbGYgPVxuICAgICAgICBjaGlsZC5zdHlsZS5hbGlnblNlbGYgIT09IFwiYXV0b1wiXG4gICAgICAgICAgPyAoY2hpbGQuc3R5bGUuYWxpZ25TZWxmIGFzIEFsaWduKVxuICAgICAgICAgIDogdGhpcy5hbGlnbkl0ZW1zXG5cbiAgICAgIGNvbnN0IGV4cGxpY2l0Q3Jvc3NTaXplID0gaG9yaXpvbnRhbFxuICAgICAgICA/IGNoaWxkLnN0eWxlLmhlaWdodFxuICAgICAgICA6IGNoaWxkLnN0eWxlLndpZHRoXG5cbiAgICAgIGlmIChleHBsaWNpdENyb3NzU2l6ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNoaWxkLnNpemVbY3Jvc3NQcm9wXSA9IGV4cGxpY2l0Q3Jvc3NTaXplXG4gICAgICB9IGVsc2UgaWYgKGFsaWduU2VsZiA9PT0gXCJzdHJldGNoXCIpIHtcbiAgICAgICAgY2hpbGQuc2l6ZVtjcm9zc1Byb3BdID0gY29udGFpbmVyQ3Jvc3NcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEl0ZW0gaXMgbm90IHN0cmV0Y2hlZCBhbmQgaGFzIG5vIGV4cGxpY2l0IGNyb3NzIHNpemUuXG4gICAgICAgIC8vIEl0cyBjcm9zcyBzaXplIGlzIG5vdCBjaGFuZ2VkIGJ5IGFsaWdubWVudDsgaXQgcmVtYWlucyBpdHMgY3VycmVudCB2YWx1ZVxuICAgICAgICAvLyAoZS5nLiwgMCBmb3IgYSBGbGV4RWxlbWVudCwgb3IgdGhlIGRlZmluZWQgc2l6ZSBmb3IgYSBuZXN0ZWQgRmxleEJveCkuXG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gNC4gSnVzdGlmeSBjb250ZW50IChtYWluXHUyMDExYXhpcyBwb3NpdGlvbmluZykgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIGNvbnN0IG9jY3VwaWVkID1cbiAgICAgIHRoaXMuY2hpbGRyZW4ucmVkdWNlKChzdW0sIGMpID0+IHN1bSArIGMuc2l6ZVttYWluUHJvcF0sIDApICsgZ2FwVG90YWxcbiAgICBjb25zdCByZW1haW5pbmcgPSBjb250YWluZXJNYWluIC0gb2NjdXBpZWRcblxuICAgIGxldCBsZWFkaW5nID0gMFxuICAgIGxldCBiZXR3ZWVuID0gbWFpbkdhcFxuICAgIGNvbnN0IG4gPSB0aGlzLmNoaWxkcmVuLmxlbmd0aFxuXG4gICAgc3dpdGNoICh0aGlzLmp1c3RpZnlDb250ZW50KSB7XG4gICAgICBjYXNlIFwiZmxleC1zdGFydFwiOlxuICAgICAgICBicmVhayAvLyBkZWZhdWx0cyBhcmUgZmluZVxuICAgICAgY2FzZSBcImZsZXgtZW5kXCI6XG4gICAgICAgIGxlYWRpbmcgPSByZW1haW5pbmdcbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgXCJjZW50ZXJcIjpcbiAgICAgICAgbGVhZGluZyA9IHJlbWFpbmluZyAvIDJcbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgXCJzcGFjZS1iZXR3ZWVuXCI6XG4gICAgICAgIGJldHdlZW4gPSBuID4gMSA/IG1haW5HYXAgKyByZW1haW5pbmcgLyAobiAtIDEpIDogMFxuICAgICAgICBicmVha1xuICAgICAgY2FzZSBcInNwYWNlLWFyb3VuZFwiOlxuICAgICAgICBiZXR3ZWVuID0gbWFpbkdhcCArIHJlbWFpbmluZyAvIG5cbiAgICAgICAgbGVhZGluZyA9IGJldHdlZW4gLyAyXG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlIFwic3BhY2UtZXZlbmx5XCI6XG4gICAgICAgIGJldHdlZW4gPSBtYWluR2FwICsgcmVtYWluaW5nIC8gKG4gKyAxKVxuICAgICAgICBsZWFkaW5nID0gYmV0d2VlblxuICAgICAgICBicmVha1xuICAgIH1cblxuICAgIC8vIDUuIFBvc2l0aW9uIGNoaWxkcmVuIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIGNvbnN0IG9yZGVyZWQgPSB0aGlzLmRpcmVjdGlvbi5lbmRzV2l0aChcInJldmVyc2VcIilcbiAgICAgID8gWy4uLnRoaXMuY2hpbGRyZW5dLnJldmVyc2UoKVxuICAgICAgOiB0aGlzLmNoaWxkcmVuXG4gICAgbGV0IGN1cnNvciA9IGxlYWRpbmdcblxuICAgIGZvciAoY29uc3QgY2hpbGQgb2Ygb3JkZXJlZCkge1xuICAgICAgaWYgKGhvcml6b250YWwpIHtcbiAgICAgICAgY2hpbGQucG9zaXRpb24ueCA9XG4gICAgICAgICAgdGhpcy5kaXJlY3Rpb24gPT09IFwicm93XCJcbiAgICAgICAgICAgID8gY3Vyc29yXG4gICAgICAgICAgICA6IGNvbnRhaW5lck1haW4gLSBjdXJzb3IgLSBjaGlsZC5zaXplLndpZHRoXG4gICAgICAgIGNoaWxkLnBvc2l0aW9uLnkgPSBjb21wdXRlQ3Jvc3MoXG4gICAgICAgICAgY2hpbGQsXG4gICAgICAgICAgY3Jvc3NQcm9wLFxuICAgICAgICAgIGNvbnRhaW5lckNyb3NzLFxuICAgICAgICAgIHRoaXMuYWxpZ25JdGVtcyxcbiAgICAgICAgKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2hpbGQucG9zaXRpb24ueSA9XG4gICAgICAgICAgdGhpcy5kaXJlY3Rpb24gPT09IFwiY29sdW1uXCJcbiAgICAgICAgICAgID8gY3Vyc29yXG4gICAgICAgICAgICA6IGNvbnRhaW5lck1haW4gLSBjdXJzb3IgLSBjaGlsZC5zaXplLmhlaWdodFxuICAgICAgICBjaGlsZC5wb3NpdGlvbi54ID0gY29tcHV0ZUNyb3NzKFxuICAgICAgICAgIGNoaWxkLFxuICAgICAgICAgIGNyb3NzUHJvcCxcbiAgICAgICAgICBjb250YWluZXJDcm9zcyxcbiAgICAgICAgICB0aGlzLmFsaWduSXRlbXMsXG4gICAgICAgIClcbiAgICAgIH1cbiAgICAgIGN1cnNvciArPSBjaGlsZC5zaXplW21haW5Qcm9wXSArIGJldHdlZW5cbiAgICB9XG5cbiAgICAvLyA2LiBSZWN1cnNlIGludG8gbmVzdGVkIGZsZXggY29udGFpbmVycyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIGZvciAoY29uc3QgY2hpbGQgb2YgdGhpcy5jaGlsZHJlbikge1xuICAgICAgaWYgKGNoaWxkIGluc3RhbmNlb2YgRmxleEJveCkge1xuICAgICAgICAvLyBFbnN1cmUgdGhlIG5lc3RlZCBib3ggbWF0Y2hlcyB0aGUgY29tcHV0ZWQgc2l6ZSAoYWxyZWFkeSBvbiAuc2l6ZSlcbiAgICAgICAgY2hpbGQuYnVpbGQoKVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIC0tLS0tLS0tLS0gaGVscGVycyAtLS0tLS0tLS0tXG4gICAgZnVuY3Rpb24gY29tcHV0ZUNyb3NzKFxuICAgICAgY2hpbGQ6IEZsZXhOb2RlLFxuICAgICAgcHJvcDoga2V5b2YgU2l6ZSxcbiAgICAgIGNvbnRhaW5lckNyb3NzOiBudW1iZXIsXG4gICAgICBhbGlnbkl0ZW1zOiBBbGlnbixcbiAgICApOiBudW1iZXIge1xuICAgICAgY29uc3QgYWxpZ25TZWxmID1cbiAgICAgICAgY2hpbGQuc3R5bGUuYWxpZ25TZWxmICE9PSBcImF1dG9cIlxuICAgICAgICAgID8gKGNoaWxkLnN0eWxlLmFsaWduU2VsZiBhcyBBbGlnbilcbiAgICAgICAgICA6IGFsaWduSXRlbXNcbiAgICAgIHN3aXRjaCAoYWxpZ25TZWxmKSB7XG4gICAgICAgIGNhc2UgXCJmbGV4LXN0YXJ0XCI6XG4gICAgICAgICAgcmV0dXJuIDBcbiAgICAgICAgY2FzZSBcImZsZXgtZW5kXCI6XG4gICAgICAgICAgcmV0dXJuIGNvbnRhaW5lckNyb3NzIC0gY2hpbGQuc2l6ZVtwcm9wXVxuICAgICAgICBjYXNlIFwiY2VudGVyXCI6XG4gICAgICAgICAgcmV0dXJuIChjb250YWluZXJDcm9zcyAtIGNoaWxkLnNpemVbcHJvcF0pIC8gMlxuICAgICAgICBjYXNlIFwic3RyZXRjaFwiOlxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiAwXG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8vIFJvb3QgY29udGFpbmVyIChzYW1lIGFzIEZsZXhCb3ggYnV0IHNlbWFudGljYWxseSBkaXN0aW5jdClcbmV4cG9ydCBjbGFzcyBSb290RmxleEJveCBleHRlbmRzIEZsZXhCb3gge1xuICBjb25zdHJ1Y3Rvcih3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlciwgb3B0czogRmxleEJveE9wdGlvbnMgPSB7fSkge1xuICAgIHN1cGVyKHdpZHRoLCBoZWlnaHQsIG9wdHMpXG4gIH1cblxuICBnZXRMYXlvdXQoKTogUmVjb3JkPHN0cmluZywgeyBwb3NpdGlvbjogUG9zaXRpb247IHNpemU6IFNpemUgfT4ge1xuICAgIHRoaXMuYnVpbGQoKVxuICAgIGNvbnN0IGxheW91dE1hcDogUmVjb3JkPHN0cmluZywgeyBwb3NpdGlvbjogUG9zaXRpb247IHNpemU6IFNpemUgfT4gPSB7fVxuICAgIHRoaXMuX2NvbGxlY3RMYXlvdXQodGhpcywgbGF5b3V0TWFwKVxuICAgIHJldHVybiBsYXlvdXRNYXBcbiAgfVxuXG4gIHByaXZhdGUgX2NvbGxlY3RMYXlvdXQoXG4gICAgYm94OiBGbGV4Qm94LFxuICAgIG1hcDogUmVjb3JkPHN0cmluZywgeyBwb3NpdGlvbjogUG9zaXRpb247IHNpemU6IFNpemUgfT4sXG4gICAgY291bnRlclJlZiA9IHsgY291bnRlcjogMCB9LFxuICApOiB2b2lkIHtcbiAgICBmb3IgKGNvbnN0IGNoaWxkIG9mIGJveC5jaGlsZHJlbikge1xuICAgICAgY29uc3QgaWQgPSBjaGlsZC5pZCA/PyBgXyQkJHtjb3VudGVyUmVmLmNvdW50ZXIrK31gXG4gICAgICBtYXBbaWRdID0geyBwb3NpdGlvbjogY2hpbGQucG9zaXRpb24sIHNpemU6IGNoaWxkLnNpemUgfVxuICAgICAgaWYgKGNoaWxkIGluc3RhbmNlb2YgRmxleEJveCkge1xuICAgICAgICB0aGlzLl9jb2xsZWN0TGF5b3V0KGNoaWxkLCBtYXAsIGNvdW50ZXJSZWYpXG4gICAgICB9XG4gICAgfVxuICB9XG59XG4iLCAiaW1wb3J0IHsgUm9vdEZsZXhCb3gsIEZsZXhCb3ggfSBmcm9tIFwiLi9taW5pbWFsLWZsZXhib3hcIiAvLyBBZGRlZCBGbGV4Qm94XG5pbXBvcnQgdHlwZSB7XG4gIEZsZXhTdHlsZSxcbiAgU2l6ZSxcbiAgUG9zaXRpb24sXG4gIERpcmVjdGlvbixcbiAgSnVzdGlmeSxcbiAgQWxpZ24sXG4gIEZsZXhCb3hPcHRpb25zLFxufSBmcm9tIFwiLi90eXBlc1wiXG5cbmV4cG9ydCBpbnRlcmZhY2UgRmxleEJveEl0ZW0gZXh0ZW5kcyBGbGV4U3R5bGUge1xuICBjaGlsZHJlbj86IEZsZXhCb3hJdGVtW11cbn1cblxuLy8gSGVscGVyIHRvIGV4dHJhY3QgRmxleEJveE9wdGlvbnMgZnJvbSBhIEZsZXhCb3hJdGVtLCB3aXRoIGRlZmF1bHRzLlxuLy8gQXNzdW1lcyBwcm9wZXJ0aWVzIGxpa2UgJ2RpcmVjdGlvbicgbWlnaHQgZXhpc3Qgb24gaXRlbSBkeW5hbWljYWxseS5cbmZ1bmN0aW9uIF9nZXRGbGV4Qm94T3B0aW9ucyhpdGVtOiBGbGV4Qm94SXRlbSk6IEZsZXhCb3hPcHRpb25zIHtcbiAgY29uc3Qgb3B0czogRmxleEJveE9wdGlvbnMgPSB7IGlkOiBpdGVtLmlkIH1cbiAgLy8gUHJvdmlkZSBkZWZhdWx0cyBmcm9tIEZsZXhCb3ggY2xhc3MgaWYgcHJvcGVydGllcyBhcmUgbm90IG9uIGl0ZW1cbiAgb3B0cy5kaXJlY3Rpb24gPSAoaXRlbSBhcyBhbnkpLmRpcmVjdGlvbiA/PyBcInJvd1wiXG4gIG9wdHMuY29sdW1uR2FwID0gKGl0ZW0gYXMgYW55KS5jb2x1bW5HYXAgPz8gMFxuICBvcHRzLnJvd0dhcCA9IChpdGVtIGFzIGFueSkucm93R2FwID8/IDBcbiAgb3B0cy5qdXN0aWZ5Q29udGVudCA9IChpdGVtIGFzIGFueSkuanVzdGlmeUNvbnRlbnQgPz8gXCJmbGV4LXN0YXJ0XCJcbiAgb3B0cy5hbGlnbkl0ZW1zID0gKGl0ZW0gYXMgYW55KS5hbGlnbkl0ZW1zID8/IFwic3RyZXRjaFwiXG4gIHJldHVybiBvcHRzXG59XG5cbi8vIEhlbHBlciBmdW5jdGlvbiB0byByZWN1cnNpdmVseSBwb3B1bGF0ZSBGbGV4Qm94IGluc3RhbmNlcyBmcm9tIEZsZXhCb3hJdGVtIHRyZWVcbmZ1bmN0aW9uIF9wb3B1bGF0ZUZsZXhCb3hSZWN1cnNpdmUoXG4gIGZsZXhDb250YWluZXI6IEZsZXhCb3gsIC8vIFRoZSBGbGV4Qm94IGluc3RhbmNlIHRvIGFkZCBjaGlsZHJlbiB0b1xuICBpdGVtczogRmxleEJveEl0ZW1bXSB8IHVuZGVmaW5lZCwgLy8gVGhlIGxpc3Qgb2YgY2hpbGQgaXRlbXMgdG8gYWRkXG4pIHtcbiAgaWYgKCFpdGVtcykge1xuICAgIHJldHVyblxuICB9XG5cbiAgZm9yIChjb25zdCBpdGVtIG9mIGl0ZW1zKSB7XG4gICAgLy8gJ2l0ZW0nIGlzIGEgRmxleEJveEl0ZW0uIEl0IGluY2x1ZGVzIEZsZXhTdHlsZSBwcm9wZXJ0aWVzLlxuICAgIC8vIFRoZXNlIHByb3BlcnRpZXMgKGZsZXhHcm93LCBmbGV4U2hyaW5rLCBldGMuKSBkZWZpbmUgaG93ICdpdGVtJyBiZWhhdmVzIGFzIGEgY2hpbGQuXG4gICAgLy8gV2UgY2FuIHBhc3MgJ2l0ZW0nIGFzIFBhcnRpYWw8RmxleFN0eWxlPiBiZWNhdXNlIEZsZXhOb2RlIGNvbnN0cnVjdG9yIGhhbmRsZXMgZGVmYXVsdHMuXG5cbiAgICBpZiAoaXRlbS5jaGlsZHJlbiAmJiBpdGVtLmNoaWxkcmVuLmxlbmd0aCA+IDApIHtcbiAgICAgIC8vIFRoaXMgaXRlbSByZXByZXNlbnRzIGEgbmVzdGVkIEZsZXhCb3ggY29udGFpbmVyXG4gICAgICBjb25zdCBuZXN0ZWRCb3hPcHRpb25zID0gX2dldEZsZXhCb3hPcHRpb25zKGl0ZW0pIC8vIEV4dHJhY3QgRmxleEJveE9wdGlvbnMgZm9yIHRoZSBuZXcgY29udGFpbmVyXG5cbiAgICAgIC8vIFVzZSBpdGVtLndpZHRoL2hlaWdodCBmcm9tIGl0cyBzdHlsZSBmb3IgdGhlIGluaXRpYWwgc2l6ZSBvZiB0aGUgbmVzdGVkIEZsZXhCb3guXG4gICAgICAvLyBUaGVzZSBhcmUgdHJlYXRlZCBhcyBleHBsaWNpdCBkaW1lbnNpb25zIGZvciB0aGUgaXRlbSBpdHNlbGYuXG4gICAgICBjb25zdCBpbml0aWFsV2lkdGggPSBpdGVtLndpZHRoID8/IDBcbiAgICAgIGNvbnN0IGluaXRpYWxIZWlnaHQgPSBpdGVtLmhlaWdodCA/PyAwXG5cbiAgICAgIGNvbnN0IG5lc3RlZEZsZXhCb3ggPSBuZXcgRmxleEJveChcbiAgICAgICAgaW5pdGlhbFdpZHRoLFxuICAgICAgICBpbml0aWFsSGVpZ2h0LFxuICAgICAgICBuZXN0ZWRCb3hPcHRpb25zLFxuICAgICAgKVxuXG4gICAgICAvLyBBZGQgdGhlIG5ldyBGbGV4Qm94IChuZXN0ZWRGbGV4Qm94KSBhcyBhIGNoaWxkIHRvIHRoZSBjdXJyZW50IGZsZXhDb250YWluZXIuXG4gICAgICAvLyBUaGUgJ2l0ZW0nIGl0c2VsZiBwcm92aWRlcyB0aGUgRmxleFN0eWxlIGZvciB0aGlzIG5lc3RlZEZsZXhCb3ggQVMgQU4gSVRFTS5cbiAgICAgIGZsZXhDb250YWluZXIuYWRkQ2hpbGQobmVzdGVkRmxleEJveCwgaXRlbSlcblxuICAgICAgX3BvcHVsYXRlRmxleEJveFJlY3Vyc2l2ZShuZXN0ZWRGbGV4Qm94LCBpdGVtLmNoaWxkcmVuKSAvLyBSZWN1cnNlXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRoaXMgaXRlbSBpcyBhIGxlYWYgRmxleEVsZW1lbnRcbiAgICAgIC8vICdpdGVtJyBwcm92aWRlcyB0aGUgRmxleFN0eWxlIGZvciB0aGlzIGVsZW1lbnQuXG4gICAgICBmbGV4Q29udGFpbmVyLmFkZENoaWxkKGl0ZW0pXG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBjb25zdCBmbGV4Qm94TGF5b3V0ID0gKFxuICBwYXJlbnQ6IEZsZXhCb3hJdGVtLCAvLyBUaGlzICdwYXJlbnQnIEZsZXhCb3hJdGVtIGRlc2NyaWJlcyB0aGUgcm9vdCBmbGV4IGNvbnRhaW5lclxuKTogUmVjb3JkPHN0cmluZywgeyBwb3NpdGlvbjogUG9zaXRpb247IHNpemU6IFNpemUgfT4gPT4ge1xuICAvLyBVc2UgcGFyZW50LndpZHRoL2hlaWdodCBmb3IgUm9vdEZsZXhCb3ggZGltZW5zaW9ucywgZGVmYXVsdGluZyB0byAwIGlmIHVuZGVmaW5lZC5cbiAgY29uc3Qgcm9vdFdpZHRoID0gcGFyZW50LndpZHRoID8/IDBcbiAgY29uc3Qgcm9vdEhlaWdodCA9IHBhcmVudC5oZWlnaHQgPz8gMFxuXG4gIC8vIEV4dHJhY3QgRmxleEJveE9wdGlvbnMgZm9yIHRoZSByb290IGNvbnRhaW5lciBmcm9tIHRoZSAncGFyZW50JyBpdGVtLlxuICBjb25zdCByb290T3B0cyA9IF9nZXRGbGV4Qm94T3B0aW9ucyhwYXJlbnQpXG5cbiAgY29uc3Qgcm9vdCA9IG5ldyBSb290RmxleEJveChyb290V2lkdGgsIHJvb3RIZWlnaHQsIHJvb3RPcHRzKVxuXG4gIC8vIFJlY3Vyc2l2ZWx5IHBvcHVsYXRlIHRoZSAncm9vdCcgRmxleEJveCBiYXNlZCBvbiAncGFyZW50LmNoaWxkcmVuJy5cbiAgX3BvcHVsYXRlRmxleEJveFJlY3Vyc2l2ZShyb290LCBwYXJlbnQuY2hpbGRyZW4pXG5cbiAgLy8gQ29tcHV0ZSB0aGUgbGF5b3V0IGFuZCByZXR1cm4gdGhlIG1hcC5cbiAgcmV0dXJuIHJvb3QuZ2V0TGF5b3V0KClcbn1cbiJdLAogICJtYXBwaW5ncyI6ICI7QUFxQkEsSUFBTSxlQUEwQjtBQUFBLEVBQzlCLFVBQVU7QUFBQSxFQUNWLFlBQVk7QUFBQSxFQUNaLFdBQVc7QUFBQSxFQUNYLFdBQVc7QUFBQSxFQUNYLE9BQU87QUFBQSxFQUNQLFFBQVE7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