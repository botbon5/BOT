interface Size {
    width: number;
    height: number;
}
interface Position {
    x: number;
    y: number;
}
type Direction = "row" | "row-reverse" | "column" | "column-reverse";
type Align = "flex-start" | "flex-end" | "center" | "stretch";
type Justify = "flex-start" | "flex-end" | "center" | "space-between" | "space-around" | "space-evenly";
interface FlexStyle {
    id?: string;
    flexGrow: number;
    flexShrink: number;
    flexBasis: number;
    /** Overrides containerʼs alignItems. */
    alignSelf?: Align | "auto";
    /** Explicit width for the item. Typically used for cross-axis sizing or fixed-size main axis. */
    width?: number;
    /** Explicit height for the item. Typically used for cross-axis sizing or fixed-size main axis. */
    height?: number;
}
interface FlexBoxOptions {
    id?: string;
    direction?: Direction;
    columnGap?: number;
    rowGap?: number;
    justifyContent?: Justify;
    alignItems?: Align;
}

interface FlexBoxItem extends FlexStyle {
    children?: FlexBoxItem[];
}
declare const flexBoxLayout: (parent: FlexBoxItem) => Record<string, {
    position: Position;
    size: Size;
}>;

declare abstract class FlexNode {
    id?: string;
    /** Computed layout values */
    readonly size: Size;
    readonly position: Position;
    /** Incoming flex style (grow / shrink / basis / alignSelf) */
    style: FlexStyle;
    constructor(style?: Partial<FlexStyle>);
    /** Recursively lay out the subtree. */
    abstract build(): void;
}
declare class FlexElement extends FlexNode {
    build(): void;
}
declare class FlexBox extends FlexNode {
    readonly children: FlexNode[];
    direction: Direction;
    columnGap: number;
    rowGap: number;
    justifyContent: Justify;
    alignItems: Align;
    constructor(width: number, height: number, opts?: FlexBoxOptions);
    /**
     * addChild(style?) → FlexElement        (leaf)
     * addChild(childBox, style?) → FlexBox  (nest another container)
     */
    addChild(style: Partial<FlexStyle>): FlexElement;
    addChild(box: FlexBox, style?: Partial<FlexStyle>): FlexBox;
    build(): void;
}
declare class RootFlexBox extends FlexBox {
    constructor(width: number, height: number, opts?: FlexBoxOptions);
    getLayout(): Record<string, {
        position: Position;
        size: Size;
    }>;
    private _collectLayout;
}

export { type Align, type Direction, FlexBox, type FlexBoxItem, type FlexBoxOptions, FlexElement, type FlexStyle, type Justify, type Position, RootFlexBox, type Size, flexBoxLayout };
