// lib/pcb/convert-circuit-json-to-pcb-svg.ts
import { stringify } from "svgson";
import {
  applyToPoint as applyToPoint18,
  compose as compose4,
  scale as scale2,
  translate as translate4
} from "transformation-matrix";

// lib/pcb/svg-object-fns/create-svg-objects-from-pcb-trace-error.ts
import { applyToPoint } from "transformation-matrix";
function createSvgObjectsFromPcbTraceError(pcbTraceError, circuitJson, ctx) {
  const { transform, shouldDrawErrors } = ctx;
  if (!shouldDrawErrors) return [];
  const { pcb_port_ids } = pcbTraceError;
  const port1 = circuitJson.find(
    (el) => el.type === "pcb_port" && el.pcb_port_id === pcb_port_ids?.[0]
  );
  const port2 = circuitJson.find(
    (el) => el.type === "pcb_port" && el.pcb_port_id === pcb_port_ids?.[1]
  );
  if (!port1 || !port2) {
    const viaIdMatch = pcbTraceError.message?.match(
      /pcb_via\[#?(pcb_via_\d+)\]/
    );
    const viaId = viaIdMatch?.[1];
    const via = circuitJson.find(
      (el) => el.type === "pcb_via" && el.pcb_via_id === viaId
    );
    if (via && via.type === "pcb_via") {
      return createSvgObjectsForViaTraceError(pcbTraceError, via, ctx);
    }
    if (pcbTraceError.center) {
      const screenCenter = applyToPoint(transform, {
        x: pcbTraceError.center.x,
        y: pcbTraceError.center.y
      });
      return [
        {
          name: "rect",
          type: "element",
          attributes: {
            x: (screenCenter.x - 5).toString(),
            y: (screenCenter.y - 5).toString(),
            width: "10",
            height: "10",
            fill: "red",
            transform: `rotate(45 ${screenCenter.x} ${screenCenter.y})`
          },
          children: [],
          value: ""
        },
        {
          name: "text",
          type: "element",
          attributes: {
            x: screenCenter.x.toString(),
            y: (screenCenter.y - 15).toString(),
            fill: "red",
            "font-family": "sans-serif",
            "font-size": "12",
            "text-anchor": "middle"
          },
          children: [
            {
              type: "text",
              value: pcbTraceError.message || "Pcb Trace Error",
              name: "",
              attributes: {},
              children: []
            }
          ],
          value: ""
        }
      ];
    } else return [];
  }
  const screenPort1 = applyToPoint(transform, {
    x: port1.x,
    y: port1.y
  });
  const screenPort2 = applyToPoint(transform, {
    x: port2.x,
    y: port2.y
  });
  const errorCenter = {
    x: (screenPort1.x + screenPort2.x) / 2,
    y: (screenPort1.y + screenPort2.y) / 2
  };
  if (isNaN(screenPort1.x) || isNaN(screenPort1.y) || isNaN(screenPort2.x) || isNaN(screenPort2.y) || isNaN(errorCenter.x) || isNaN(errorCenter.y)) {
    return [];
  }
  const svgObjects = [
    {
      name: "line",
      type: "element",
      attributes: {
        x1: screenPort1.x.toString(),
        y1: screenPort1.y.toString(),
        x2: errorCenter.x.toString(),
        y2: errorCenter.y.toString(),
        stroke: "red",
        "stroke-width": "1.5",
        "stroke-dasharray": "2,2"
      },
      children: [],
      value: ""
    },
    {
      name: "line",
      type: "element",
      attributes: {
        x1: errorCenter.x.toString(),
        y1: errorCenter.y.toString(),
        x2: screenPort2.x.toString(),
        y2: screenPort2.y.toString(),
        stroke: "red",
        "stroke-width": "1.5",
        "stroke-dasharray": "2,2"
      },
      children: [],
      value: ""
    },
    {
      name: "rect",
      type: "element",
      attributes: {
        x: (errorCenter.x - 5).toString(),
        y: (errorCenter.y - 5).toString(),
        width: "10",
        height: "10",
        fill: "red",
        transform: `rotate(45 ${errorCenter.x} ${errorCenter.y})`
      },
      children: [],
      value: ""
    },
    {
      name: "text",
      type: "element",
      attributes: {
        x: errorCenter.x.toString(),
        y: (errorCenter.y - 15).toString(),
        fill: "red",
        "font-family": "sans-serif",
        "font-size": "12",
        "text-anchor": "middle"
      },
      children: [
        {
          type: "text",
          value: pcbTraceError.message || "Pcb Trace Error",
          name: "",
          attributes: {},
          children: []
        }
      ],
      value: ""
    }
  ];
  return svgObjects;
}
function createSvgObjectsForViaTraceError(pcbTraceError, via, ctx) {
  const { transform } = ctx;
  if (pcbTraceError.center && via) {
    const screenCenter = applyToPoint(transform, {
      x: pcbTraceError.center.x,
      y: pcbTraceError.center.y
    });
    const screenVia = applyToPoint(transform, {
      x: via.x,
      y: via.y
    });
    const dx = screenVia.x - screenCenter.x;
    const dy = screenVia.y - screenCenter.y;
    const dist = Math.sqrt(dx * dx + dy * dy);
    const angle = Math.atan2(dy, dx) * 180 / Math.PI;
    const margin = 10;
    const boxWidth = dist + margin * 2;
    const boxHeight = 20;
    const midX = (screenCenter.x + screenVia.x) / 2;
    const midY = (screenCenter.y + screenVia.y) / 2;
    return [
      // Rotated bounding box
      {
        name: "rect",
        type: "element",
        attributes: {
          x: (midX - boxWidth / 2).toString(),
          y: (midY - boxHeight / 2).toString(),
          width: boxWidth.toString(),
          height: boxHeight.toString(),
          fill: "none",
          stroke: "red",
          "stroke-width": "1",
          "stroke-dasharray": "3,2",
          transform: `rotate(${angle} ${midX} ${midY})`
        },
        children: [],
        value: ""
      },
      // Error diamond
      {
        name: "rect",
        type: "element",
        attributes: {
          x: (midX - 5).toString(),
          y: (midY - 5).toString(),
          width: "10",
          height: "10",
          fill: "red",
          transform: `rotate(45 ${midX} ${midY})`
        },
        children: [],
        value: ""
      },
      // Error label
      {
        name: "text",
        type: "element",
        attributes: {
          x: midX.toString(),
          y: (midY - boxHeight / 2 - 5).toString(),
          fill: "red",
          "font-family": "sans-serif",
          "font-size": "12",
          "text-anchor": "middle"
        },
        children: [
          {
            type: "text",
            value: pcbTraceError.message || "Pcb Trace Error",
            name: "",
            attributes: {},
            children: []
          }
        ],
        value: ""
      }
    ];
  }
  return [];
}

// lib/pcb/svg-object-fns/create-svg-objects-from-pcb-fabrication-note-path.ts
import { applyToPoint as applyToPoint2 } from "transformation-matrix";
function createSvgObjectsFromPcbFabricationNotePath(fabNotePath, ctx) {
  const { transform, layer: layerFilter } = ctx;
  if (!fabNotePath.route || !Array.isArray(fabNotePath.route)) return [];
  const firstPoint = fabNotePath.route[0];
  const lastPoint = fabNotePath.route[fabNotePath.route.length - 1];
  const isClosed = firstPoint.x === lastPoint.x && firstPoint.y === lastPoint.y;
  const path = fabNotePath.route.slice(0, isClosed ? -1 : void 0).map((point, index) => {
    const [x, y] = applyToPoint2(transform, [point.x, point.y]);
    return index === 0 ? `M ${x} ${y}` : `L ${x} ${y}`;
  }).join(" ") + (isClosed ? " Z" : "");
  return [
    {
      name: "path",
      type: "element",
      attributes: {
        class: "pcb-fabrication-note-path",
        stroke: fabNotePath.color || "rgba(255,255,255,0.5)",
        fill: "none",
        d: path,
        "stroke-width": (fabNotePath.stroke_width * Math.abs(transform.a)).toString(),
        "data-pcb-component-id": fabNotePath.pcb_component_id,
        "data-pcb-fabrication-note-path-id": fabNotePath.pcb_fabrication_note_path_id
      },
      value: "",
      children: []
    }
  ];
}

// lib/pcb/svg-object-fns/create-svg-objects-from-pcb-fabrication-note-text.ts
import { toString as matrixToString } from "transformation-matrix";
import { applyToPoint as applyToPoint3, compose, rotate, translate } from "transformation-matrix";
function createSvgObjectsFromPcbFabricationNoteText(pcbFabNoteText, ctx) {
  const { transform, layer: layerFilter } = ctx;
  const {
    anchor_position,
    anchor_alignment,
    text,
    font_size = 1,
    layer = "top",
    color
  } = pcbFabNoteText;
  if (layerFilter && layer !== layerFilter) return [];
  if (!anchor_position || typeof anchor_position.x !== "number" || typeof anchor_position.y !== "number") {
    console.error("Invalid anchor_position:", anchor_position);
    return [];
  }
  const [transformedX, transformedY] = applyToPoint3(transform, [
    anchor_position.x,
    anchor_position.y
  ]);
  const transformedFontSize = font_size * Math.abs(transform.a);
  const textTransform = compose(
    translate(transformedX, transformedY),
    // TODO do anchor_alignment
    rotate(Math.PI / 180)
    // Convert degrees to radians
  );
  const svgObject = {
    name: "text",
    type: "element",
    attributes: {
      x: "0",
      y: "0",
      "font-family": "Arial, sans-serif",
      "font-size": transformedFontSize.toString(),
      "text-anchor": "middle",
      "dominant-baseline": "central",
      transform: matrixToString(textTransform),
      class: "pcb-fabrication-note-text",
      fill: color || "rgba(255,255,255,0.5)"
    },
    children: [
      {
        type: "text",
        value: text,
        name: "",
        attributes: {},
        children: []
      }
    ],
    value: ""
  };
  return [svgObject];
}

// lib/pcb/svg-object-fns/create-svg-objects-from-pcb-plated-hole.ts
import { applyToPoint as applyToPoint4 } from "transformation-matrix";
function createSvgObjectsFromPcbPlatedHole(hole, ctx) {
  const { transform, colorMap: colorMap2 } = ctx;
  const [x, y] = applyToPoint4(transform, [hole.x, hole.y]);
  if (hole.shape === "pill") {
    const scaledOuterWidth = hole.outer_width * Math.abs(transform.a);
    const scaledOuterHeight = hole.outer_height * Math.abs(transform.a);
    const scaledHoleWidth = hole.hole_width * Math.abs(transform.a);
    const scaledHoleHeight = hole.hole_height * Math.abs(transform.a);
    const outerRadiusX = scaledOuterWidth / 2;
    const outerRadiusY = scaledOuterHeight / 2;
    const innerRadiusX = scaledHoleWidth / 2;
    const innerRadiusY = scaledHoleHeight / 2;
    const straightLength = scaledOuterHeight - scaledOuterWidth;
    return [
      {
        name: "g",
        type: "element",
        children: [
          // Outer pill shape
          {
            name: "path",
            type: "element",
            attributes: {
              class: "pcb-hole-outer",
              fill: colorMap2.copper.top,
              d: `M${x - outerRadiusX},${y - straightLength / 2} v${straightLength} a${outerRadiusX},${outerRadiusX} 0 0 0 ${scaledOuterWidth},0 v-${straightLength} a${outerRadiusX},${outerRadiusX} 0 0 0 -${scaledOuterWidth},0 z`
            },
            value: "",
            children: []
          },
          // Inner pill shape
          {
            name: "path",
            type: "element",
            attributes: {
              class: "pcb-hole-inner",
              fill: colorMap2.drill,
              d: `M${x - innerRadiusX},${y - (scaledHoleHeight - scaledHoleWidth) / 2} v${scaledHoleHeight - scaledHoleWidth} a${innerRadiusX},${innerRadiusX} 0 0 0 ${scaledHoleWidth},0 v-${scaledHoleHeight - scaledHoleWidth} a${innerRadiusX},${innerRadiusX} 0 0 0 -${scaledHoleWidth},0 z`
            },
            value: "",
            children: []
          }
        ],
        value: "",
        attributes: {}
      }
    ];
  }
  if (hole.shape === "circle") {
    const scaledOuterWidth = hole.outer_diameter * Math.abs(transform.a);
    const scaledOuterHeight = hole.outer_diameter * Math.abs(transform.a);
    const scaledHoleWidth = hole.hole_diameter * Math.abs(transform.a);
    const scaledHoleHeight = hole.hole_diameter * Math.abs(transform.a);
    const outerRadius = Math.min(scaledOuterWidth, scaledOuterHeight) / 2;
    const innerRadius = Math.min(scaledHoleWidth, scaledHoleHeight) / 2;
    return [
      {
        name: "g",
        type: "element",
        children: [
          {
            name: "circle",
            type: "element",
            attributes: {
              class: "pcb-hole-outer",
              fill: colorMap2.copper.top,
              cx: x.toString(),
              cy: y.toString(),
              r: outerRadius.toString()
            },
            value: "",
            children: []
          },
          {
            name: "circle",
            type: "element",
            attributes: {
              class: "pcb-hole-inner",
              fill: colorMap2.drill,
              cx: x.toString(),
              cy: y.toString(),
              r: innerRadius.toString()
            },
            value: "",
            children: []
          }
        ],
        value: "",
        attributes: {}
      }
    ];
  }
  if (hole.shape === "circular_hole_with_rect_pad") {
    const scaledHoleDiameter = hole.hole_diameter * Math.abs(transform.a);
    const scaledRectPadWidth = hole.rect_pad_width * Math.abs(transform.a);
    const scaledRectPadHeight = hole.rect_pad_height * Math.abs(transform.a);
    const holeRadius = scaledHoleDiameter / 2;
    return [
      {
        name: "g",
        type: "element",
        children: [
          // Rectangular pad (outer shape)
          {
            name: "rect",
            type: "element",
            attributes: {
              class: "pcb-hole-outer-pad",
              fill: colorMap2.copper.top,
              x: (x - scaledRectPadWidth / 2).toString(),
              y: (y - scaledRectPadHeight / 2).toString(),
              width: scaledRectPadWidth.toString(),
              height: scaledRectPadHeight.toString()
            },
            value: "",
            children: []
          },
          // Circular hole inside the rectangle
          {
            name: "circle",
            type: "element",
            attributes: {
              class: "pcb-hole-inner",
              fill: colorMap2.drill,
              cx: x.toString(),
              cy: y.toString(),
              r: holeRadius.toString()
            },
            value: "",
            children: []
          }
        ],
        value: "",
        attributes: {}
      }
    ];
  }
  if (hole.shape === "pill_hole_with_rect_pad") {
    const scaledRectPadWidth = hole.rect_pad_width * Math.abs(transform.a);
    const scaledRectPadHeight = hole.rect_pad_height * Math.abs(transform.a);
    const scaledHoleHeight = hole.hole_height * Math.abs(transform.a);
    const scaledHoleWidth = hole.hole_width * Math.abs(transform.a);
    const holeRadius = Math.min(scaledHoleHeight, scaledHoleWidth) / 2;
    return [
      {
        name: "g",
        type: "element",
        children: [
          // Rectangular pad (outer shape)
          {
            name: "rect",
            type: "element",
            attributes: {
              class: "pcb-hole-outer-pad",
              fill: colorMap2.copper.top,
              x: (x - scaledRectPadWidth / 2).toString(),
              y: (y - scaledRectPadHeight / 2).toString(),
              width: scaledRectPadWidth.toString(),
              height: scaledRectPadHeight.toString()
            },
            value: "",
            children: []
          },
          // pill hole inside the rectangle
          {
            name: "rect",
            type: "element",
            attributes: {
              class: "pcb-hole-inner",
              fill: colorMap2.drill,
              x: (x - scaledHoleWidth / 2).toString(),
              y: (y - scaledHoleHeight / 2).toString(),
              width: scaledHoleWidth.toString(),
              height: scaledHoleHeight.toString(),
              rx: holeRadius.toString(),
              ry: holeRadius.toString()
            },
            value: "",
            children: []
          }
        ],
        value: "",
        attributes: {}
      }
    ];
  }
  return [];
}

// lib/pcb/svg-object-fns/create-svg-objects-from-pcb-silkscreen-path.ts
import { applyToPoint as applyToPoint5 } from "transformation-matrix";
function createSvgObjectsFromPcbSilkscreenPath(silkscreenPath, ctx) {
  const { transform, layer: layerFilter, colorMap: colorMap2 } = ctx;
  if (!silkscreenPath.route || !Array.isArray(silkscreenPath.route)) return [];
  let path = silkscreenPath.route.map((point, index) => {
    const [x, y] = applyToPoint5(transform, [point.x, point.y]);
    return index === 0 ? `M ${x} ${y}` : `L ${x} ${y}`;
  }).join(" ");
  const firstPoint = silkscreenPath.route[0];
  const lastPoint = silkscreenPath.route[silkscreenPath.route.length - 1];
  if (firstPoint && lastPoint && firstPoint.x === lastPoint.x && firstPoint.y === lastPoint.y) {
    path += " Z";
  }
  const layer = silkscreenPath.layer || "top";
  if (layerFilter && layer !== layerFilter) return [];
  const color = layer === "bottom" ? colorMap2.silkscreen.bottom : colorMap2.silkscreen.top;
  return [
    {
      name: "path",
      type: "element",
      attributes: {
        class: `pcb-silkscreen pcb-silkscreen-${layer}`,
        d: path,
        fill: "none",
        stroke: color,
        "stroke-width": (silkscreenPath.stroke_width * Math.abs(transform.a)).toString(),
        "stroke-linecap": "round",
        "stroke-linejoin": "round",
        "data-pcb-component-id": silkscreenPath.pcb_component_id,
        "data-pcb-silkscreen-path-id": silkscreenPath.pcb_silkscreen_path_id
      },
      value: "",
      children: []
    }
  ];
}

// lib/pcb/svg-object-fns/create-svg-objects-from-pcb-silkscreen-text.ts
import {
  applyToPoint as applyToPoint6,
  compose as compose2,
  rotate as rotate2,
  translate as translate2,
  scale,
  toString as matrixToString2
} from "transformation-matrix";
function createSvgObjectsFromPcbSilkscreenText(pcbSilkscreenText, ctx) {
  const { transform, layer: layerFilter, colorMap: colorMap2 } = ctx;
  const {
    anchor_position,
    text,
    font_size = 1,
    layer = "top",
    ccw_rotation = 0,
    anchor_alignment = "center"
  } = pcbSilkscreenText;
  if (layerFilter && layer !== layerFilter) return [];
  if (!anchor_position || typeof anchor_position.x !== "number" || typeof anchor_position.y !== "number") {
    console.error("Invalid anchor_position:", anchor_position);
    return [];
  }
  const [transformedX, transformedY] = applyToPoint6(transform, [
    anchor_position.x,
    anchor_position.y
  ]);
  const transformedFontSize = font_size * Math.abs(transform.a);
  let textAnchor = "middle";
  let dominantBaseline = "central";
  let dx = 0;
  let dy = 0;
  switch (anchor_alignment) {
    case "top_left":
      textAnchor = "start";
      dominantBaseline = "text-before-edge";
      break;
    case "top_center":
      textAnchor = "middle";
      dominantBaseline = "text-before-edge";
      break;
    case "top_right":
      textAnchor = "end";
      dominantBaseline = "text-before-edge";
      break;
    case "center_left":
      textAnchor = "start";
      dominantBaseline = "central";
      break;
    case "center_right":
      textAnchor = "end";
      dominantBaseline = "central";
      break;
    case "bottom_left":
      textAnchor = "start";
      dominantBaseline = "text-after-edge";
      break;
    case "bottom_center":
      textAnchor = "middle";
      dominantBaseline = "text-after-edge";
      break;
    case "bottom_right":
      textAnchor = "end";
      dominantBaseline = "text-after-edge";
      break;
    case "center":
    default:
      textAnchor = "middle";
      dominantBaseline = "central";
      break;
  }
  const textTransform = compose2(
    translate2(transformedX, transformedY),
    rotate2(ccw_rotation * Math.PI / 180),
    ...layer === "bottom" ? [scale(-1, 1)] : []
  );
  const color = layer === "bottom" ? colorMap2.silkscreen.bottom : colorMap2.silkscreen.top;
  const lines = text.split("\n");
  const children = lines.length === 1 ? [
    {
      type: "text",
      value: text,
      name: "",
      attributes: {},
      children: []
    }
  ] : lines.map((line, idx) => ({
    type: "element",
    name: "tspan",
    value: "",
    attributes: {
      x: "0",
      ...idx > 0 ? { dy: transformedFontSize.toString() } : {}
    },
    children: [
      {
        type: "text",
        value: line,
        name: "",
        attributes: {},
        children: []
      }
    ]
  }));
  const svgObject = {
    name: "text",
    type: "element",
    attributes: {
      x: "0",
      y: "0",
      dx: dx.toString(),
      dy: dy.toString(),
      fill: color,
      "font-family": "Arial, sans-serif",
      "font-size": transformedFontSize.toString(),
      "text-anchor": textAnchor,
      "dominant-baseline": dominantBaseline,
      transform: matrixToString2(textTransform),
      class: `pcb-silkscreen-text pcb-silkscreen-${layer}`,
      "data-pcb-silkscreen-text-id": pcbSilkscreenText.pcb_component_id,
      stroke: "none"
    },
    children,
    value: ""
  };
  return [svgObject];
}

// lib/pcb/svg-object-fns/create-svg-objects-from-pcb-silkscreen-rect.ts
import { applyToPoint as applyToPoint7 } from "transformation-matrix";
function createSvgObjectsFromPcbSilkscreenRect(pcbSilkscreenRect, ctx) {
  const { transform, layer: layerFilter, colorMap: colorMap2 } = ctx;
  const {
    center,
    width,
    height,
    layer = "top",
    pcb_silkscreen_rect_id,
    stroke_width,
    is_filled,
    has_stroke,
    is_stroke_dashed
  } = pcbSilkscreenRect;
  if (layerFilter && layer !== layerFilter) return [];
  if (!center || typeof center.x !== "number" || typeof center.y !== "number" || typeof width !== "number" || typeof height !== "number") {
    console.error("Invalid rectangle data:", { center, width, height });
    return [];
  }
  const [transformedX, transformedY] = applyToPoint7(transform, [
    center.x,
    center.y
  ]);
  const transformedWidth = width * Math.abs(transform.a);
  const transformedHeight = height * Math.abs(transform.d);
  const transformedStrokeWidth = stroke_width * Math.abs(transform.a);
  const color = layer === "bottom" ? colorMap2.silkscreen.bottom : colorMap2.silkscreen.top;
  const attributes = {
    x: (transformedX - transformedWidth / 2).toString(),
    y: (transformedY - transformedHeight / 2).toString(),
    width: transformedWidth.toString(),
    height: transformedHeight.toString(),
    class: `pcb-silkscreen-rect pcb-silkscreen-${layer}`,
    "data-pcb-silkscreen-rect-id": pcb_silkscreen_rect_id
  };
  attributes.fill = is_filled ? color : "none";
  let actualHasStroke;
  if (has_stroke === void 0) {
    actualHasStroke = transformedStrokeWidth > 0;
  } else {
    actualHasStroke = has_stroke;
  }
  if (actualHasStroke) {
    attributes.stroke = color;
    attributes["stroke-width"] = transformedStrokeWidth.toString();
    if (is_stroke_dashed) {
      const dashLength = 0.1 * Math.abs(transform.a);
      const gapLength = 0.05 * Math.abs(transform.a);
      attributes["stroke-dasharray"] = `${dashLength} ${gapLength}`;
    }
  } else {
    attributes.stroke = "none";
  }
  const svgObject = {
    name: "rect",
    type: "element",
    attributes,
    value: "",
    children: []
  };
  return [svgObject];
}

// lib/pcb/svg-object-fns/create-svg-objects-from-pcb-silkscreen-circle.ts
import { applyToPoint as applyToPoint8 } from "transformation-matrix";
function createSvgObjectsFromPcbSilkscreenCircle(pcbSilkscreenCircle, ctx) {
  const { transform, layer: layerFilter, colorMap: colorMap2 } = ctx;
  const {
    center,
    radius,
    layer = "top",
    pcb_silkscreen_circle_id,
    stroke_width = 1
  } = pcbSilkscreenCircle;
  if (layerFilter && layer !== layerFilter) return [];
  if (!center || typeof center.x !== "number" || typeof center.y !== "number" || typeof radius !== "number") {
    console.error("Invalid PCB Silkscreen Circle data:", { center, radius });
    return [];
  }
  const [transformedX, transformedY] = applyToPoint8(transform, [
    center.x,
    center.y
  ]);
  const transformedRadius = radius * Math.abs(transform.a);
  const transformedStrokeWidth = stroke_width * Math.abs(transform.a);
  const color = layer === "bottom" ? colorMap2.silkscreen.bottom : colorMap2.silkscreen.top;
  const svgObject = {
    name: "circle",
    type: "element",
    attributes: {
      cx: transformedX.toString(),
      cy: transformedY.toString(),
      r: transformedRadius.toString(),
      class: `pcb-silkscreen-circle pcb-silkscreen-${layer}`,
      stroke: color,
      "stroke-width": transformedStrokeWidth.toString(),
      "data-pcb-silkscreen-circle-id": pcb_silkscreen_circle_id
    },
    value: "",
    children: []
  };
  return [svgObject];
}

// lib/pcb/svg-object-fns/create-svg-objects-from-pcb-silkscreen-line.ts
import { applyToPoint as applyToPoint9 } from "transformation-matrix";
function createSvgObjectsFromPcbSilkscreenLine(pcbSilkscreenLine, ctx) {
  const { transform, layer: layerFilter, colorMap: colorMap2 } = ctx;
  const {
    x1,
    y1,
    x2,
    y2,
    stroke_width,
    layer = "top",
    pcb_silkscreen_line_id
  } = pcbSilkscreenLine;
  if (layerFilter && layer !== layerFilter) return [];
  if (typeof x1 !== "number" || typeof y1 !== "number" || typeof x2 !== "number" || typeof y2 !== "number") {
    console.error("Invalid coordinates:", { x1, y1, x2, y2 });
    return [];
  }
  const [transformedX1, transformedY1] = applyToPoint9(transform, [x1, y1]);
  const [transformedX2, transformedY2] = applyToPoint9(transform, [x2, y2]);
  const transformedStrokeWidth = stroke_width * Math.abs(transform.a);
  const color = layer === "bottom" ? colorMap2.silkscreen.bottom : colorMap2.silkscreen.top;
  return [
    {
      name: "line",
      type: "element",
      attributes: {
        x1: transformedX1.toString(),
        y1: transformedY1.toString(),
        x2: transformedX2.toString(),
        y2: transformedY2.toString(),
        stroke: color,
        "stroke-width": transformedStrokeWidth.toString(),
        class: `pcb-silkscreen-line pcb-silkscreen-${layer}`,
        "data-pcb-silkscreen-line-id": pcb_silkscreen_line_id
      },
      value: "",
      children: []
    }
  ];
}

// lib/utils/pairs.ts
function pairs(arr) {
  const result = [];
  for (let i = 0; i < arr.length - 1; i++) {
    result.push([arr[i], arr[i + 1]]);
  }
  return result;
}

// lib/pcb/svg-object-fns/create-svg-objects-from-pcb-trace.ts
import { applyToPoint as applyToPoint10 } from "transformation-matrix";

// lib/pcb/colors.ts
var DEFAULT_PCB_COLOR_MAP = {
  copper: {
    top: "rgb(200, 52, 52)",
    bottom: "rgb(77, 127, 196)"
  },
  soldermask: {
    top: "rgb(200, 52, 52)",
    bottom: "rgb(77, 127, 196)"
  },
  drill: "#FF26E2",
  silkscreen: {
    top: "#f2eda1",
    bottom: "#5da9e9"
  },
  boardOutline: "rgba(255, 255, 255, 0.5)",
  debugComponent: {
    fill: null,
    stroke: null
  }
};
var HOLE_COLOR = DEFAULT_PCB_COLOR_MAP.drill;
var SILKSCREEN_TOP_COLOR = DEFAULT_PCB_COLOR_MAP.silkscreen.top;
var SILKSCREEN_BOTTOM_COLOR = DEFAULT_PCB_COLOR_MAP.silkscreen.bottom;

// lib/pcb/layer-name-to-color.ts
var LAYER_NAME_TO_COLOR = {
  top: DEFAULT_PCB_COLOR_MAP.copper.top,
  bottom: DEFAULT_PCB_COLOR_MAP.copper.bottom
};
function layerNameToColor(layerName, colorMap2 = DEFAULT_PCB_COLOR_MAP) {
  return colorMap2.copper[layerName] ?? "white";
}
var SOLDER_PASTE_LAYER_NAME_TO_COLOR = {
  bottom: "rgb(105, 105, 105)",
  top: "rgb(105, 105, 105)"
};
function solderPasteLayerNameToColor(layerName) {
  return SOLDER_PASTE_LAYER_NAME_TO_COLOR[layerName] ?? "rgb(105, 105, 105)";
}

// lib/pcb/svg-object-fns/create-svg-objects-from-pcb-trace.ts
function createSvgObjectsFromPcbTrace(trace, ctx) {
  const { transform, layer: layerFilter, colorMap: colorMap2 } = ctx;
  if (!trace.route || !Array.isArray(trace.route) || trace.route.length < 2)
    return [];
  const segments = pairs(trace.route);
  const svgObjects = [];
  for (const [start, end] of segments) {
    const startPoint = applyToPoint10(transform, [start.x, start.y]);
    const endPoint = applyToPoint10(transform, [end.x, end.y]);
    const layer = "layer" in start ? start.layer : "layer" in end ? end.layer : null;
    if (!layer) continue;
    if (layerFilter && layer !== layerFilter) continue;
    const layerColor = colorMap2.soldermask[layer] ?? layerNameToColor(layer, colorMap2);
    const traceWidth = "width" in start ? start.width : "width" in end ? end.width : null;
    const svgObject = {
      name: "path",
      type: "element",
      value: "",
      children: [],
      attributes: {
        class: "pcb-trace",
        stroke: layerColor,
        fill: "none",
        d: `M ${startPoint[0]} ${startPoint[1]} L ${endPoint[0]} ${endPoint[1]}`,
        "stroke-width": traceWidth ? (traceWidth * Math.abs(transform.a)).toString() : "0.3",
        "stroke-linecap": "round",
        "stroke-linejoin": "round",
        "shape-rendering": "crispEdges",
        "data-layer": layer
      }
    };
    svgObjects.push(svgObject);
  }
  svgObjects.sort((a, b) => {
    const layerA = a.attributes["data-layer"];
    const layerB = b.attributes["data-layer"];
    if (layerA === "bottom" && layerB !== "bottom") {
      return -1;
    }
    if (layerA === "top" && layerB !== "top") {
      return 1;
    }
    return 0;
  });
  return svgObjects;
}

// lib/pcb/svg-object-fns/create-svg-objects-from-smt-pads.ts
import { applyToPoint as applyToPoint11 } from "transformation-matrix";
function createSvgObjectsFromSmtPad(pad, ctx) {
  const { transform, layer: layerFilter, colorMap: colorMap2 } = ctx;
  if (layerFilter && pad.layer !== layerFilter) return [];
  if (pad.shape === "rect" || pad.shape === "rotated_rect") {
    const width = pad.width * Math.abs(transform.a);
    const height = pad.height * Math.abs(transform.d);
    const [x, y] = applyToPoint11(transform, [pad.x, pad.y]);
    if (pad.shape === "rotated_rect" && pad.ccw_rotation) {
      return [
        {
          name: "rect",
          type: "element",
          attributes: {
            class: "pcb-pad",
            fill: layerNameToColor(pad.layer, colorMap2),
            x: (-width / 2).toString(),
            y: (-height / 2).toString(),
            width: width.toString(),
            height: height.toString(),
            transform: `translate(${x} ${y}) rotate(${-pad.ccw_rotation})`,
            "data-layer": pad.layer
          }
        }
      ];
    }
    return [
      {
        name: "rect",
        type: "element",
        attributes: {
          class: "pcb-pad",
          fill: layerNameToColor(pad.layer, colorMap2),
          x: (x - width / 2).toString(),
          y: (y - height / 2).toString(),
          width: width.toString(),
          height: height.toString(),
          "data-layer": pad.layer
        }
      }
    ];
  }
  if (pad.shape === "pill") {
    const width = pad.width * Math.abs(transform.a);
    const height = pad.height * Math.abs(transform.d);
    const radius = pad.radius * Math.abs(transform.a);
    const [x, y] = applyToPoint11(transform, [pad.x, pad.y]);
    return [
      {
        name: "rect",
        type: "element",
        attributes: {
          class: "pcb-pad",
          fill: layerNameToColor(pad.layer, colorMap2),
          x: (x - width / 2).toString(),
          y: (y - height / 2).toString(),
          width: width.toString(),
          height: height.toString(),
          rx: radius.toString(),
          ry: radius.toString(),
          "data-layer": pad.layer
        }
      }
    ];
  }
  if (pad.shape === "circle") {
    const radius = pad.radius * Math.abs(transform.a);
    const [x, y] = applyToPoint11(transform, [pad.x, pad.y]);
    return [
      {
        name: "circle",
        type: "element",
        attributes: {
          class: "pcb-pad",
          fill: layerNameToColor(pad.layer, colorMap2),
          cx: x.toString(),
          cy: y.toString(),
          r: radius.toString(),
          "data-layer": pad.layer
        }
      }
    ];
  }
  if (pad.shape === "polygon") {
    const points = (pad.points ?? []).map(
      (point) => applyToPoint11(transform, [point.x, point.y])
    );
    return [
      {
        name: "polygon",
        type: "element",
        attributes: {
          class: "pcb-pad",
          fill: layerNameToColor(pad.layer),
          points: points.map((p) => p.join(",")).join(" "),
          "data-layer": pad.layer
        }
      }
    ];
  }
  return [];
}

// lib/pcb/svg-object-fns/create-svg-objects-from-pcb-board.ts
import { applyToPoint as applyToPoint12 } from "transformation-matrix";
function createSvgObjectsFromPcbBoard(pcbBoard, ctx) {
  const { transform, colorMap: colorMap2 } = ctx;
  const { width, height, center, outline } = pcbBoard;
  let path;
  if (outline && Array.isArray(outline) && outline.length >= 3) {
    path = outline.map((point, index) => {
      const [x, y] = applyToPoint12(transform, [point.x, point.y]);
      return index === 0 ? `M ${x} ${y}` : `L ${x} ${y}`;
    }).join(" ");
  } else {
    const halfWidth = width / 2;
    const halfHeight = height / 2;
    const topLeft = applyToPoint12(transform, [
      center.x - halfWidth,
      center.y - halfHeight
    ]);
    const topRight = applyToPoint12(transform, [
      center.x + halfWidth,
      center.y - halfHeight
    ]);
    const bottomRight = applyToPoint12(transform, [
      center.x + halfWidth,
      center.y + halfHeight
    ]);
    const bottomLeft = applyToPoint12(transform, [
      center.x - halfWidth,
      center.y + halfHeight
    ]);
    path = `M ${topLeft[0]} ${topLeft[1]} L ${topRight[0]} ${topRight[1]} L ${bottomRight[0]} ${bottomRight[1]} L ${bottomLeft[0]} ${bottomLeft[1]}`;
  }
  path += " Z";
  return [
    {
      name: "path",
      type: "element",
      value: "",
      children: [],
      attributes: {
        class: "pcb-board",
        d: path,
        fill: "none",
        stroke: colorMap2.boardOutline,
        "stroke-width": (0.1 * Math.abs(transform.a)).toString()
      }
    }
  ];
}

// lib/pcb/svg-object-fns/create-svg-objects-from-pcb-via.ts
import { applyToPoint as applyToPoint13 } from "transformation-matrix";
function createSvgObjectsFromPcbVia(hole, ctx) {
  const { transform, colorMap: colorMap2 } = ctx;
  const [x, y] = applyToPoint13(transform, [hole.x, hole.y]);
  const scaledOuterWidth = hole.outer_diameter * Math.abs(transform.a);
  const scaledOuterHeight = hole.outer_diameter * Math.abs(transform.a);
  const scaledHoleWidth = hole.hole_diameter * Math.abs(transform.a);
  const scaledHoleHeight = hole.hole_diameter * Math.abs(transform.a);
  const outerRadius = Math.min(scaledOuterWidth, scaledOuterHeight) / 2;
  const innerRadius = Math.min(scaledHoleWidth, scaledHoleHeight) / 2;
  return {
    name: "g",
    type: "element",
    children: [
      {
        name: "circle",
        type: "element",
        attributes: {
          class: "pcb-hole-outer",
          fill: colorMap2.copper.top,
          cx: x.toString(),
          cy: y.toString(),
          r: outerRadius.toString()
        }
      },
      {
        name: "circle",
        type: "element",
        attributes: {
          class: "pcb-hole-inner",
          fill: colorMap2.drill,
          cx: x.toString(),
          cy: y.toString(),
          r: innerRadius.toString()
        }
      }
    ]
  };
}

// lib/pcb/svg-object-fns/create-svg-objects-from-pcb-hole.ts
import { applyToPoint as applyToPoint14 } from "transformation-matrix";
function createSvgObjectsFromPcbHole(hole, ctx) {
  const { transform, colorMap: colorMap2 } = ctx;
  const [x, y] = applyToPoint14(transform, [hole.x, hole.y]);
  if (hole.hole_shape === "circle" || hole.hole_shape === "square") {
    const scaledDiameter = hole.hole_diameter * Math.abs(transform.a);
    const radius = scaledDiameter / 2;
    if (hole.hole_shape === "circle") {
      return [
        {
          name: "circle",
          type: "element",
          attributes: {
            class: "pcb-hole",
            cx: x.toString(),
            cy: y.toString(),
            r: radius.toString(),
            fill: colorMap2.drill
          },
          children: [],
          value: ""
        }
      ];
    }
    return [
      {
        name: "rect",
        type: "element",
        attributes: {
          class: "pcb-hole",
          x: (x - radius).toString(),
          y: (y - radius).toString(),
          width: scaledDiameter.toString(),
          height: scaledDiameter.toString(),
          fill: colorMap2.drill
        },
        children: [],
        value: ""
      }
    ];
  }
  if (hole.hole_shape === "oval") {
    const scaledWidth = hole.hole_width * Math.abs(transform.a);
    const scaledHeight = hole.hole_height * Math.abs(transform.a);
    const rx = scaledWidth / 2;
    const ry = scaledHeight / 2;
    return [
      {
        name: "ellipse",
        type: "element",
        attributes: {
          class: "pcb-hole",
          cx: x.toString(),
          cy: y.toString(),
          rx: rx.toString(),
          ry: ry.toString(),
          fill: colorMap2.drill
        },
        children: [],
        value: ""
      }
    ];
  }
  return [];
}

// lib/pcb/svg-object-fns/create-svg-objects-from-pcb-rats-nests.ts
import {
  getFullConnectivityMapFromCircuitJson
} from "circuit-json-to-connectivity-map";
import "svgson";
import { applyToPoint as applyToPoint15 } from "transformation-matrix";

// lib/pcb/create-svg-objects-from-pcb-rats-nest/get-element-position.ts
import { su } from "@tscircuit/circuit-json-util";
var getElementPosition = (id, circuitJson) => {
  const pcbSmtpad = su(circuitJson).pcb_smtpad.get(id);
  if (pcbSmtpad && "x" in pcbSmtpad && "y" in pcbSmtpad) {
    return { x: pcbSmtpad.x, y: pcbSmtpad.y };
  }
  const pcbPlatedHole = su(circuitJson).pcb_plated_hole.get(id);
  if (pcbPlatedHole && "x" in pcbPlatedHole && "y" in pcbPlatedHole) {
    return { x: pcbPlatedHole.x, y: pcbPlatedHole.y };
  }
  return null;
};

// lib/pcb/create-svg-objects-from-pcb-rats-nest/find-nearest-point-in-nest.ts
import "circuit-json-to-connectivity-map";
var findNearestPointInNet = (sourcePoint, netId, connectivity, circuitJson) => {
  const connectedIds = connectivity.getIdsConnectedToNet(netId);
  let nearestPoint = null;
  let minDistance = Infinity;
  for (const id of connectedIds) {
    const pos = getElementPosition(id, circuitJson);
    if (pos) {
      const dx = sourcePoint.x - pos.x;
      const dy = sourcePoint.y - pos.y;
      const distance = Math.sqrt(dx * dx + dy * dy);
      if (distance > 0 && distance < minDistance) {
        minDistance = distance;
        nearestPoint = pos;
      }
    }
  }
  return nearestPoint;
};

// lib/pcb/svg-object-fns/create-svg-objects-from-pcb-rats-nests.ts
import { su as su2 } from "@tscircuit/circuit-json-util";
function createSvgObjectsForRatsNest(circuitJson, ctx) {
  const { transform } = ctx;
  const connectivity = getFullConnectivityMapFromCircuitJson(circuitJson);
  const pcbPorts = circuitJson.filter((elm) => elm.type === "pcb_port");
  const sourceTraces = circuitJson.filter((elm) => elm.type === "source_trace");
  const ratsNestLines = [];
  pcbPorts.forEach((port, index) => {
    const portId = port.pcb_port_id;
    if (!portId) return;
    const netId = connectivity.getNetConnectedToId(portId);
    if (!netId) return;
    let isInNet = false;
    const sourcePort = su2(circuitJson).source_port.getWhere({
      pcb_port_id: portId
    });
    if (sourcePort && sourcePort.source_port_id) {
      const sourcePortId = sourcePort.source_port_id;
      for (const trace of sourceTraces) {
        if (Array.isArray(trace.connected_source_port_ids) && trace.connected_source_port_ids.includes(sourcePortId) && Array.isArray(trace.connected_source_net_ids) && trace.connected_source_net_ids.length > 0) {
          isInNet = true;
          break;
        }
      }
    }
    const startPoint = { x: port.x, y: port.y };
    const nearestPoint = findNearestPointInNet(
      startPoint,
      netId,
      connectivity,
      circuitJson
    );
    if (!nearestPoint) return;
    ratsNestLines.push({
      key: `${portId}-${index}`,
      startPoint,
      endPoint: nearestPoint,
      isInNet
    });
  });
  const svgObjects = [];
  for (const line of ratsNestLines) {
    const transformedStart = applyToPoint15(transform, [
      line.startPoint.x,
      line.startPoint.y
    ]);
    const transformedEnd = applyToPoint15(transform, [
      line.endPoint.x,
      line.endPoint.y
    ]);
    const attributes = {
      x1: transformedStart[0].toString(),
      y1: transformedStart[1].toString(),
      x2: transformedEnd[0].toString(),
      y2: transformedEnd[1].toString(),
      stroke: "white",
      "stroke-width": "1",
      "stroke-dasharray": "6,6"
    };
    svgObjects.push({
      name: "line",
      type: "element",
      attributes,
      value: "",
      children: []
    });
  }
  return svgObjects;
}

// lib/pcb/svg-object-fns/create-svg-objects-from-pcb-cutout.ts
import {
  applyToPoint as applyToPoint16,
  compose as compose3,
  rotate as rotate3,
  translate as translate3,
  toString as matrixToString6
} from "transformation-matrix";
function createSvgObjectsFromPcbCutout(cutout, ctx) {
  const { transform, colorMap: colorMap2 } = ctx;
  if (cutout.shape === "rect") {
    const rectCutout = cutout;
    const [cx, cy] = applyToPoint16(transform, [
      rectCutout.center.x,
      rectCutout.center.y
    ]);
    const scaledWidth = rectCutout.width * Math.abs(transform.a);
    const scaledHeight = rectCutout.height * Math.abs(transform.d);
    const svgRotation = -(rectCutout.rotation ?? 0);
    return [
      {
        name: "rect",
        type: "element",
        attributes: {
          class: "pcb-cutout pcb-cutout-rect",
          x: (-scaledWidth / 2).toString(),
          y: (-scaledHeight / 2).toString(),
          width: scaledWidth.toString(),
          height: scaledHeight.toString(),
          fill: colorMap2.drill,
          transform: matrixToString6(
            compose3(translate3(cx, cy), rotate3(svgRotation * Math.PI / 180))
          )
        },
        children: [],
        value: ""
      }
    ];
  }
  if (cutout.shape === "circle") {
    const circleCutout = cutout;
    const [cx, cy] = applyToPoint16(transform, [
      circleCutout.center.x,
      circleCutout.center.y
    ]);
    const scaledRadius = circleCutout.radius * Math.abs(transform.a);
    return [
      {
        name: "circle",
        type: "element",
        attributes: {
          class: "pcb-cutout pcb-cutout-circle",
          cx: cx.toString(),
          cy: cy.toString(),
          r: scaledRadius.toString(),
          fill: colorMap2.drill
        },
        children: [],
        value: ""
      }
    ];
  }
  if (cutout.shape === "polygon") {
    const polygonCutout = cutout;
    if (!polygonCutout.points || polygonCutout.points.length === 0) return [];
    const transformedPoints = polygonCutout.points.map(
      (p) => applyToPoint16(transform, [p.x, p.y])
    );
    const pointsString = transformedPoints.map((p) => `${p[0]},${p[1]}`).join(" ");
    return [
      {
        name: "polygon",
        type: "element",
        attributes: {
          class: "pcb-cutout pcb-cutout-polygon",
          points: pointsString,
          fill: colorMap2.drill
        },
        children: [],
        value: ""
      }
    ];
  }
  return [];
}

// lib/pcb/svg-object-fns/create-svg-objects-from-pcb-component.ts
import { applyToPoint as applyToPoint17 } from "transformation-matrix";
function createSvgObjectsFromPcbComponent(component, ctx) {
  const { transform } = ctx;
  const { center, width, height, rotation = 0 } = component;
  const [x, y] = applyToPoint17(transform, [center.x, center.y]);
  const scaledWidth = width * Math.abs(transform.a);
  const scaledHeight = height * Math.abs(transform.d);
  const transformStr = `translate(${x}, ${y}) rotate(${-rotation}) scale(1, -1)`;
  if (!ctx.colorMap.debugComponent?.fill && !ctx.colorMap.debugComponent?.stroke) {
    return [];
  }
  return [
    {
      name: "g",
      type: "element",
      attributes: { transform: transformStr },
      children: [
        {
          name: "rect",
          type: "element",
          attributes: {
            class: "pcb-component",
            x: (-scaledWidth / 2).toString(),
            y: (-scaledHeight / 2).toString(),
            width: scaledWidth.toString(),
            height: scaledHeight.toString(),
            fill: ctx.colorMap.debugComponent.fill ?? "transparent",
            stroke: ctx.colorMap.debugComponent.stroke ?? "transparent"
          }
        }
      ],
      value: ""
    }
  ];
}

// lib/utils/get-software-used-string.ts
function getSoftwareUsedString(circuitJson) {
  const metadata = circuitJson.find(
    (e) => e.type === "project_software_metadata" || e.type === "source_project_metadata"
  );
  return metadata?.software_used_string;
}

// package.json
var package_default = {
  name: "circuit-to-svg",
  type: "module",
  version: "0.0.171",
  description: "Convert Circuit JSON to SVG",
  main: "dist/index.js",
  files: [
    "dist"
  ],
  scripts: {
    start: "storybook dev -p 6006",
    prepublish: "npm run build",
    build: "tsup-node ./lib/index.ts --format esm --dts --sourcemap",
    format: "biome format . --write",
    "format:check": "biome format .",
    storybook: "storybook dev -p 6006",
    "build-storybook": "storybook build"
  },
  license: "ISC",
  devDependencies: {
    "@biomejs/biome": "^1.9.4",
    "@chromatic-com/storybook": "^1.6.1",
    "@storybook/addon-essentials": "^8.2.5",
    "@storybook/addon-interactions": "^8.2.5",
    "@storybook/addon-links": "^8.2.5",
    "@storybook/addon-onboarding": "^8.2.5",
    "@storybook/blocks": "^8.2.5",
    "@storybook/react": "^8.2.5",
    "@storybook/react-vite": "^8.2.5",
    "@storybook/test": "^8.2.5",
    "@tscircuit/core": "0.0.477",
    "@tscircuit/plop": "^0.0.10",
    "@types/bun": "^1.2.8",
    biome: "^0.3.3",
    "bun-match-svg": "^0.0.12",
    "circuit-json": "^0.0.218",
    esbuild: "^0.20.2",
    "performance-now": "^2.1.0",
    react: "^18.3.1",
    "schematic-symbols": "^0.0.153",
    storybook: "^8.2.5",
    tsup: "^8.0.2",
    typescript: "^5.4.5",
    "vite-tsconfig-paths": "^5.0.1",
    "@tscircuit/checks": "^0.0.44",
    "@tscircuit/circuit-json-util": "^0.0.47",
    "@tscircuit/footprinter": "^0.0.203"
  },
  peerDependencies: {
    "circuit-json": "*",
    "@tscircuit/circuit-json-util": "*",
    "@tscircuit/footprinter": "*",
    "schematic-symbols": "*"
  },
  dependencies: {
    "@types/node": "^22.5.5",
    "bun-types": "^1.1.40",
    svgson: "^5.3.1",
    "transformation-matrix": "^2.16.1"
  }
};

// lib/package-version.ts
var CIRCUIT_TO_SVG_VERSION = package_default.version;

// lib/pcb/convert-circuit-json-to-pcb-svg.ts
var OBJECT_ORDER = [
  "pcb_trace_error",
  "pcb_plated_hole",
  "pcb_fabrication_note_text",
  "pcb_fabrication_note_path",
  "pcb_silkscreen_text",
  "pcb_silkscreen_path",
  "pcb_via",
  "pcb_cutout",
  // Draw traces before SMT pads so pads appear on top
  "pcb_smtpad",
  "pcb_trace",
  "pcb_component",
  "pcb_board"
];
function convertCircuitJsonToPcbSvg(circuitJson, options) {
  const drawPaddingOutsideBoard = options?.drawPaddingOutsideBoard ?? true;
  const layer = options?.layer;
  const colorOverrides = options?.colorOverrides;
  const colorMap2 = {
    copper: {
      top: colorOverrides?.copper?.top ?? DEFAULT_PCB_COLOR_MAP.copper.top,
      bottom: colorOverrides?.copper?.bottom ?? DEFAULT_PCB_COLOR_MAP.copper.bottom
    },
    drill: colorOverrides?.drill ?? DEFAULT_PCB_COLOR_MAP.drill,
    silkscreen: {
      top: colorOverrides?.silkscreen?.top ?? DEFAULT_PCB_COLOR_MAP.silkscreen.top,
      bottom: colorOverrides?.silkscreen?.bottom ?? DEFAULT_PCB_COLOR_MAP.silkscreen.bottom
    },
    boardOutline: colorOverrides?.boardOutline ?? DEFAULT_PCB_COLOR_MAP.boardOutline,
    soldermask: {
      top: colorOverrides?.soldermask?.top ?? DEFAULT_PCB_COLOR_MAP.soldermask.top,
      bottom: colorOverrides?.soldermask?.bottom ?? DEFAULT_PCB_COLOR_MAP.soldermask.bottom
    },
    debugComponent: {
      fill: colorOverrides?.debugComponent?.fill ?? DEFAULT_PCB_COLOR_MAP.debugComponent.fill,
      stroke: colorOverrides?.debugComponent?.stroke ?? DEFAULT_PCB_COLOR_MAP.debugComponent.stroke
    }
  };
  let minX = Number.POSITIVE_INFINITY;
  let minY = Number.POSITIVE_INFINITY;
  let maxX = Number.NEGATIVE_INFINITY;
  let maxY = Number.NEGATIVE_INFINITY;
  let boardMinX = Number.POSITIVE_INFINITY;
  let boardMinY = Number.POSITIVE_INFINITY;
  let boardMaxX = Number.NEGATIVE_INFINITY;
  let boardMaxY = Number.NEGATIVE_INFINITY;
  for (const circuitJsonElm of circuitJson) {
    if (circuitJsonElm.type === "pcb_board") {
      if (circuitJsonElm.outline && Array.isArray(circuitJsonElm.outline) && circuitJsonElm.outline.length >= 3) {
        updateBoundsToIncludeOutline(circuitJsonElm.outline);
        updateBoardBoundsToIncludeOutline(circuitJsonElm.outline);
      } else if ("center" in circuitJsonElm && "width" in circuitJsonElm && "height" in circuitJsonElm) {
        updateBounds(
          circuitJsonElm.center,
          circuitJsonElm.width,
          circuitJsonElm.height
        );
        updateBoardBounds(
          circuitJsonElm.center,
          circuitJsonElm.width,
          circuitJsonElm.height
        );
      }
    } else if ("x" in circuitJsonElm && "y" in circuitJsonElm) {
      updateBounds({ x: circuitJsonElm.x, y: circuitJsonElm.y }, 0, 0);
    } else if (circuitJsonElm.type === "pcb_smtpad") {
      const pad = circuitJsonElm;
      if (pad.shape === "rect" || pad.shape === "rotated_rect" || pad.shape === "pill") {
        updateBounds({ x: pad.x, y: pad.y }, pad.width, pad.height);
      } else if (pad.shape === "circle") {
        updateBounds({ x: pad.x, y: pad.y }, pad.radius * 2, pad.radius * 2);
      } else if (pad.shape === "polygon") {
        updateTraceBounds(pad.points);
      }
    } else if ("route" in circuitJsonElm) {
      updateTraceBounds(circuitJsonElm.route);
    } else if (circuitJsonElm.type === "pcb_silkscreen_text" || circuitJsonElm.type === "pcb_silkscreen_rect" || circuitJsonElm.type === "pcb_silkscreen_circle" || circuitJsonElm.type === "pcb_silkscreen_line") {
      updateSilkscreenBounds(circuitJsonElm);
    }
  }
  const padding = drawPaddingOutsideBoard ? 1 : 0;
  const boundsMinX = drawPaddingOutsideBoard || !isFinite(boardMinX) ? minX : boardMinX;
  const boundsMinY = drawPaddingOutsideBoard || !isFinite(boardMinY) ? minY : boardMinY;
  const boundsMaxX = drawPaddingOutsideBoard || !isFinite(boardMaxX) ? maxX : boardMaxX;
  const boundsMaxY = drawPaddingOutsideBoard || !isFinite(boardMaxY) ? maxY : boardMaxY;
  const circuitWidth = boundsMaxX - boundsMinX + 2 * padding;
  const circuitHeight = boundsMaxY - boundsMinY + 2 * padding;
  let svgWidth = options?.width ?? 800;
  let svgHeight = options?.height ?? 600;
  if (options?.matchBoardAspectRatio) {
    const boardWidth = boardMaxX - boardMinX;
    const boardHeight = boardMaxY - boardMinY;
    if (boardWidth > 0 && boardHeight > 0) {
      const aspect = boardWidth / boardHeight;
      if (options?.width && !options?.height) {
        svgHeight = options.width / aspect;
      } else if (options?.height && !options?.width) {
        svgWidth = options.height * aspect;
      } else {
        svgHeight = svgWidth / aspect;
      }
    }
  }
  const paths = [];
  for (const circuitJsonElm of circuitJson) {
    if ("route" in circuitJsonElm && circuitJsonElm.route !== void 0) {
      paths.push(circuitJsonElm.route);
    }
  }
  const scaleX = svgWidth / circuitWidth;
  const scaleY = svgHeight / circuitHeight;
  const scaleFactor = Math.min(scaleX, scaleY);
  const offsetX = (svgWidth - circuitWidth * scaleFactor) / 2;
  const offsetY = (svgHeight - circuitHeight * scaleFactor) / 2;
  const transform = compose4(
    translate4(
      offsetX - boundsMinX * scaleFactor + padding * scaleFactor,
      svgHeight - offsetY + boundsMinY * scaleFactor - padding * scaleFactor
    ),
    scale2(scaleFactor, -scaleFactor)
    // Flip in y-direction
  );
  const ctx = {
    transform,
    layer,
    shouldDrawErrors: options?.shouldDrawErrors,
    drawPaddingOutsideBoard,
    colorMap: colorMap2
  };
  function getLayer(elm) {
    if (elm.type === "pcb_smtpad") {
      return elm.layer === "top" || elm.layer === "bottom" ? elm.layer : void 0;
    }
    if (elm.type === "pcb_trace") {
      for (const seg of elm.route ?? []) {
        const candidate = "layer" in seg && seg.layer || "from_layer" in seg && seg.from_layer || "to_layer" in seg && seg.to_layer || void 0;
        if (candidate === "top" || candidate === "bottom") {
          return candidate;
        }
      }
    }
    return void 0;
  }
  function isCopper(elm) {
    return elm.type === "pcb_trace" || elm.type === "pcb_smtpad";
  }
  let svgObjects = circuitJson.sort((a, b) => {
    const layerA = getLayer(a);
    const layerB = getLayer(b);
    if (isCopper(a) && isCopper(b) && layerA !== layerB) {
      if (layerA === "top") return 1;
      if (layerB === "top") return -1;
      if (layerA === "bottom") return -1;
      if (layerB === "bottom") return 1;
    }
    return (OBJECT_ORDER.indexOf(b.type) ?? 9999) - (OBJECT_ORDER.indexOf(a.type) ?? 9999);
  }).flatMap((elm) => createSvgObjects({ elm, circuitJson, ctx }));
  let strokeWidth = String(0.05 * scaleFactor);
  for (const element of circuitJson) {
    if ("stroke_width" in element) {
      strokeWidth = String(scaleFactor * element.stroke_width);
      break;
    }
  }
  if (options?.shouldDrawRatsNest) {
    const ratsNestObjects = createSvgObjectsForRatsNest(circuitJson, ctx);
    svgObjects = svgObjects.concat(ratsNestObjects);
  }
  const children = [
    {
      name: "style",
      type: "element",
      value: "",
      attributes: {},
      children: [
        {
          type: "text",
          value: "",
          name: "",
          attributes: {},
          children: []
        }
      ]
    },
    {
      name: "rect",
      type: "element",
      value: "",
      attributes: {
        class: "boundary",
        x: "0",
        y: "0",
        fill: options?.backgroundColor ?? "#000",
        width: svgWidth.toString(),
        height: svgHeight.toString()
      },
      children: []
    }
  ];
  if (drawPaddingOutsideBoard) {
    children.push(
      createSvgObjectFromPcbBoundary(transform, minX, minY, maxX, maxY)
    );
  }
  children.push(...svgObjects);
  const softwareUsedString = getSoftwareUsedString(circuitJson);
  const version = CIRCUIT_TO_SVG_VERSION;
  const svgObject = {
    name: "svg",
    type: "element",
    attributes: {
      xmlns: "http://www.w3.org/2000/svg",
      width: svgWidth.toString(),
      height: svgHeight.toString(),
      ...softwareUsedString && {
        "data-software-used-string": softwareUsedString
      },
      ...options?.includeVersion && {
        "data-circuit-to-svg-version": version
      }
    },
    value: "",
    children: children.filter((child) => child !== null)
  };
  try {
    return stringify(svgObject);
  } catch (error) {
    console.error("Error stringifying SVG object:", error);
    throw error;
  }
  function updateBounds(center, width, height) {
    const halfWidth = width / 2;
    const halfHeight = height / 2;
    minX = Math.min(minX, center.x - halfWidth);
    minY = Math.min(minY, center.y - halfHeight);
    maxX = Math.max(maxX, center.x + halfWidth);
    maxY = Math.max(maxY, center.y + halfHeight);
  }
  function updateBoardBounds(center, width, height) {
    const halfWidth = width / 2;
    const halfHeight = height / 2;
    boardMinX = Math.min(boardMinX, center.x - halfWidth);
    boardMinY = Math.min(boardMinY, center.y - halfHeight);
    boardMaxX = Math.max(boardMaxX, center.x + halfWidth);
    boardMaxY = Math.max(boardMaxY, center.y + halfHeight);
  }
  function updateBoundsToIncludeOutline(outline) {
    for (const point of outline) {
      minX = Math.min(minX, point.x);
      minY = Math.min(minY, point.y);
      maxX = Math.max(maxX, point.x);
      maxY = Math.max(maxY, point.y);
    }
  }
  function updateBoardBoundsToIncludeOutline(outline) {
    for (const point of outline) {
      boardMinX = Math.min(boardMinX, point.x);
      boardMinY = Math.min(boardMinY, point.y);
      boardMaxX = Math.max(boardMaxX, point.x);
      boardMaxY = Math.max(boardMaxY, point.y);
    }
  }
  function updateTraceBounds(route) {
    for (const point of route) {
      minX = Math.min(minX, point.x);
      minY = Math.min(minY, point.y);
      maxX = Math.max(maxX, point.x);
      maxY = Math.max(maxY, point.y);
    }
  }
  function updateSilkscreenBounds(item) {
    if (item.type === "pcb_silkscreen_text") {
      updateBounds(item.anchor_position, 0, 0);
    } else if (item.type === "pcb_silkscreen_path") {
      updateTraceBounds(item.route);
    } else if (item.type === "pcb_silkscreen_rect") {
      updateBounds(item.center, item.width, item.height);
    } else if (item.type === "pcb_silkscreen_circle") {
      updateBounds(item.center, item.radius * 2, item.radius * 2);
    } else if (item.type === "pcb_silkscreen_line") {
      updateBounds({ x: item.x1, y: item.y1 }, 0, 0);
      updateBounds({ x: item.x2, y: item.y2 }, 0, 0);
    } else if (item.type === "pcb_cutout") {
      const cutout = item;
      if (cutout.shape === "rect") {
        updateBounds(cutout.center, cutout.width, cutout.height);
      } else if (cutout.shape === "circle") {
        updateBounds(cutout.center, cutout.radius * 2, cutout.radius * 2);
      } else if (cutout.shape === "polygon") {
        updateTraceBounds(cutout.points);
      }
    }
  }
}
function createSvgObjects({
  elm,
  circuitJson,
  ctx
}) {
  switch (elm.type) {
    case "pcb_trace_error":
      return createSvgObjectsFromPcbTraceError(elm, circuitJson, ctx).filter(
        Boolean
      );
    case "pcb_component":
      return createSvgObjectsFromPcbComponent(elm, ctx).filter(Boolean);
    case "pcb_trace":
      return createSvgObjectsFromPcbTrace(elm, ctx);
    case "pcb_plated_hole":
      return createSvgObjectsFromPcbPlatedHole(elm, ctx).filter(Boolean);
    case "pcb_hole":
      return createSvgObjectsFromPcbHole(elm, ctx);
    case "pcb_smtpad":
      return createSvgObjectsFromSmtPad(elm, ctx);
    case "pcb_silkscreen_text":
      return createSvgObjectsFromPcbSilkscreenText(elm, ctx);
    case "pcb_silkscreen_rect":
      return createSvgObjectsFromPcbSilkscreenRect(elm, ctx);
    case "pcb_silkscreen_circle":
      return createSvgObjectsFromPcbSilkscreenCircle(elm, ctx);
    case "pcb_silkscreen_line":
      return createSvgObjectsFromPcbSilkscreenLine(elm, ctx);
    case "pcb_fabrication_note_path":
      return createSvgObjectsFromPcbFabricationNotePath(elm, ctx);
    case "pcb_fabrication_note_text":
      return createSvgObjectsFromPcbFabricationNoteText(elm, ctx);
    case "pcb_silkscreen_path":
      return createSvgObjectsFromPcbSilkscreenPath(elm, ctx);
    case "pcb_board":
      return ctx.drawPaddingOutsideBoard ? createSvgObjectsFromPcbBoard(elm, ctx) : [];
    case "pcb_via":
      return createSvgObjectsFromPcbVia(elm, ctx);
    case "pcb_cutout":
      return createSvgObjectsFromPcbCutout(elm, ctx);
    default:
      return [];
  }
}
function createSvgObjectFromPcbBoundary(transform, minX, minY, maxX, maxY) {
  const [x1, y1] = applyToPoint18(transform, [minX, minY]);
  const [x2, y2] = applyToPoint18(transform, [maxX, maxY]);
  const width = Math.abs(x2 - x1);
  const height = Math.abs(y2 - y1);
  const x = Math.min(x1, x2);
  const y = Math.min(y1, y2);
  return {
    name: "rect",
    type: "element",
    value: "",
    children: [],
    attributes: {
      class: "pcb-boundary",
      fill: "none",
      stroke: "#fff",
      "stroke-width": "0.3",
      x: x.toString(),
      y: y.toString(),
      width: width.toString(),
      height: height.toString()
    }
  };
}
var circuitJsonToPcbSvg = convertCircuitJsonToPcbSvg;

// lib/assembly/convert-circuit-json-to-assembly-svg.ts
import { stringify as stringify2 } from "svgson";
import { su as su3 } from "@tscircuit/circuit-json-util";
import {
  applyToPoint as applyToPoint25,
  compose as compose5,
  scale as scale3,
  translate as translate5
} from "transformation-matrix";

// lib/assembly/svg-object-fns/create-svg-objects-from-assembly-board.ts
import { applyToPoint as applyToPoint19 } from "transformation-matrix";
var DEFAULT_BOARD_STYLE = {
  fill: "none",
  stroke: "rgb(0,0,0)",
  strokeOpacity: "0.8",
  strokeWidthFactor: 0.2
};
function createSvgObjectsFromAssemblyBoard(pcbBoard, transform, style = {}) {
  const { width, height, center, outline } = pcbBoard;
  let path;
  if (outline && Array.isArray(outline) && outline.length >= 3) {
    path = outline.map((point, index) => {
      const [x, y] = applyToPoint19(transform, [point.x, point.y]);
      return index === 0 ? `M ${x} ${y}` : `L ${x} ${y}`;
    }).join(" ");
  } else {
    const halfWidth = width / 2;
    const halfHeight = height / 2;
    const topLeft = applyToPoint19(transform, [
      center.x - halfWidth,
      center.y - halfHeight
    ]);
    const topRight = applyToPoint19(transform, [
      center.x + halfWidth,
      center.y - halfHeight
    ]);
    const bottomRight = applyToPoint19(transform, [
      center.x + halfWidth,
      center.y + halfHeight
    ]);
    const bottomLeft = applyToPoint19(transform, [
      center.x - halfWidth,
      center.y + halfHeight
    ]);
    path = `M ${topLeft[0]} ${topLeft[1]} L ${topRight[0]} ${topRight[1]} L ${bottomRight[0]} ${bottomRight[1]} L ${bottomLeft[0]} ${bottomLeft[1]}`;
  }
  path += " Z";
  return [
    {
      name: "path",
      type: "element",
      value: "",
      children: [],
      attributes: {
        class: "pcb-board",
        d: path,
        fill: style.fill ?? DEFAULT_BOARD_STYLE.fill,
        stroke: style.stroke ?? DEFAULT_BOARD_STYLE.stroke,
        "stroke-opacity": style.strokeOpacity ?? DEFAULT_BOARD_STYLE.strokeOpacity,
        "stroke-width": ((style.strokeWidthFactor ?? DEFAULT_BOARD_STYLE.strokeWidthFactor) * Math.abs(transform.a)).toString()
      }
    }
  ];
}

// lib/assembly/svg-object-fns/create-svg-objects-from-assembly-component.ts
import { applyToPoint as applyToPoint21 } from "transformation-matrix";

// lib/utils/get-sch-font-size.ts
import "transformation-matrix";
var fontSizeMap = {
  pin_number: 0.15,
  negated_pin_number: 0.15 * 0.8,
  reference_designator: 0.18,
  manufacturer_number: 0.18,
  net_label: 0.18,
  error: 0.05
};
var getSchMmFontSize = (textType, fontSize) => {
  return fontSize ?? fontSizeMap[textType];
};
var getSchScreenFontSize = (transform, textType, fontSize) => {
  return Math.abs(transform.a) * getSchMmFontSize(textType, fontSize);
};

// lib/assembly/svg-object-fns/create-svg-objects-from-assembly-component.ts
function createSvgObjectsFromAssemblyComponent(params, ctx) {
  const { elm, portPosition, name, arePinsInterchangeable } = params;
  const { transform } = ctx;
  const { center, width, height, rotation = 0, layer = "top" } = elm;
  if (!center || typeof width !== "number" || typeof height !== "number")
    return null;
  const [x, y] = applyToPoint21(transform, [center.x, center.y]);
  const [pinX, pinY] = applyToPoint21(transform, [portPosition.x, portPosition.y]);
  const scaledWidth = width * Math.abs(transform.a);
  const scaledHeight = height * Math.abs(transform.d);
  const isTopLayer = layer === "top";
  const isPinTop = pinY > y;
  const isPinLeft = pinX < x;
  const children = [
    createComponentPath(scaledWidth, scaledHeight, rotation, layer),
    createComponentLabel(scaledWidth, scaledHeight, name ?? "", transform)
  ];
  if (!arePinsInterchangeable) {
    children.push(
      createPin1Indicator(
        scaledWidth,
        scaledHeight,
        rotation,
        layer,
        isPinTop,
        isPinLeft
      )
    );
  }
  return {
    name: "g",
    type: "element",
    value: "",
    attributes: {
      transform: `translate(${x}, ${y}) scale(1, -1)`
    },
    children
  };
}
function createComponentPath(scaledWidth, scaledHeight, rotation, layer) {
  const w = scaledWidth / 2;
  const h = scaledHeight / 2;
  const strokeWidth = 0.8;
  const path = getRectPathData(w, h, rotation);
  return {
    name: "path",
    type: "element",
    attributes: {
      class: "assembly-component",
      d: path,
      "stroke-width": strokeWidth.toFixed(2),
      transform: `rotate(${-rotation})`,
      "stroke-dasharray": layer === "bottom" ? "2,2" : ""
    },
    value: "",
    children: []
  };
}
function createComponentLabel(scaledWidth, scaledHeight, name, transform) {
  const size = Math.min(scaledWidth, scaledHeight);
  const minFontSize = 3;
  const maxFontSize = 58;
  const fontScale = 0.8;
  const fontSize = Math.min(
    maxFontSize,
    Math.max(minFontSize, size * fontScale)
  );
  const isTall = scaledHeight > scaledWidth;
  return {
    name: "text",
    type: "element",
    attributes: {
      x: "0",
      y: "0",
      class: "assembly-component-label",
      "text-anchor": "middle",
      dy: ".10em",
      style: "pointer-events: none",
      "font-size": `${fontSize.toFixed(1)}px`,
      transform: isTall ? "rotate(90) scale(1, -1)" : "scale(1, -1)"
    },
    children: [
      {
        type: "text",
        value: name || "",
        name: "",
        attributes: {},
        children: []
      }
    ],
    value: ""
  };
}
function createPin1Indicator(scaledWidth, scaledHeight, rotation, layer, isPinTop, isPinLeft) {
  const w = scaledWidth / 2;
  const h = scaledHeight / 2;
  const indicatorSize = Math.min(w, h) * 0.5;
  let points;
  if (isPinTop && isPinLeft) {
    points = [
      [-w, -h],
      // Corner point
      [-w + indicatorSize, -h],
      // Point along top edge
      [-w, -h + indicatorSize]
      // Point along left edge
    ];
  } else if (isPinTop && !isPinLeft) {
    points = [
      [w, -h],
      // Corner point
      [w - indicatorSize, -h],
      // Point along top edge
      [w, -h + indicatorSize]
      // Point along right edge
    ];
  } else if (!isPinTop && isPinLeft) {
    points = [
      [-w, h],
      // Corner point
      [-w + indicatorSize, h],
      // Point along bottom edge
      [-w, h - indicatorSize]
      // Point along left edge
    ];
  } else {
    points = [
      [w, h],
      // Corner point
      [w - indicatorSize, h],
      // Point along bottom edge
      [w, h - indicatorSize]
      // Point along right edge
    ];
  }
  const pointsString = points.map((p) => p.join(",")).join(" ");
  return {
    name: "polygon",
    type: "element",
    attributes: {
      class: "assembly-pin1-indicator",
      points: pointsString,
      fill: "#333",
      stroke: "none",
      transform: `rotate(${-rotation})`
    },
    value: "",
    children: []
  };
}
function getRectPathData(w, h, rotation) {
  const rotatePoint = (x, y, angle) => {
    const rad = Math.PI / 180 * angle;
    const cos = Math.cos(rad);
    const sin = Math.sin(rad);
    return [x * cos - y * sin, x * sin + y * cos];
  };
  const corners = [
    [-w, -h],
    [w, -h],
    [w, h],
    [-w, h]
  ];
  const rotatedCorners = corners.map(([x, y]) => rotatePoint(x, y, rotation));
  const path = rotatedCorners.map(([x, y], i) => i === 0 ? `M${x},${y}` : `L${x},${y}`).join(" ");
  return `${path} Z`;
}

// lib/assembly/svg-object-fns/create-svg-objects-from-assembly-hole.ts
import { applyToPoint as applyToPoint22 } from "transformation-matrix";
var HOLE_COLOR2 = "rgb(190, 190, 190)";
function createSvgObjectsFromAssemblyHole(hole, ctx) {
  const { transform } = ctx;
  const [x, y] = applyToPoint22(transform, [hole.x, hole.y]);
  if (hole.hole_shape === "circle" || hole.hole_shape === "square") {
    const scaledDiameter = hole.hole_diameter * Math.abs(transform.a);
    const radius = scaledDiameter / 2;
    if (hole.hole_shape === "circle") {
      return [
        {
          name: "circle",
          type: "element",
          attributes: {
            class: "assembly-hole",
            cx: x.toString(),
            cy: y.toString(),
            r: radius.toString(),
            fill: HOLE_COLOR2
          },
          children: [],
          value: ""
        }
      ];
    }
    return [
      {
        name: "rect",
        type: "element",
        attributes: {
          class: "assembly-hole",
          x: (x - radius).toString(),
          y: (y - radius).toString(),
          width: scaledDiameter.toString(),
          height: scaledDiameter.toString(),
          fill: HOLE_COLOR2
        },
        children: [],
        value: ""
      }
    ];
  }
  if (hole.hole_shape === "oval") {
    const scaledWidth = hole.hole_width * Math.abs(transform.a);
    const scaledHeight = hole.hole_height * Math.abs(transform.a);
    const rx = scaledWidth / 2;
    const ry = scaledHeight / 2;
    return [
      {
        name: "ellipse",
        type: "element",
        attributes: {
          class: "assembly-hole",
          cx: x.toString(),
          cy: y.toString(),
          rx: rx.toString(),
          ry: ry.toString(),
          fill: HOLE_COLOR2
        },
        children: [],
        value: ""
      }
    ];
  }
  return [];
}

// lib/assembly/svg-object-fns/create-svg-objects-from-assembly-plated-hole.ts
import { applyToPoint as applyToPoint23 } from "transformation-matrix";
var PAD_COLOR = "rgb(210, 210, 210)";
var HOLE_COLOR3 = "rgb(190, 190, 190)";
function createSvgObjectsFromAssemblyPlatedHole(hole, ctx) {
  const { transform } = ctx;
  const [x, y] = applyToPoint23(transform, [hole.x, hole.y]);
  if (hole.shape === "pill") {
    const scaledOuterWidth = hole.outer_width * Math.abs(transform.a);
    const scaledOuterHeight = hole.outer_height * Math.abs(transform.a);
    const scaledHoleWidth = hole.hole_width * Math.abs(transform.a);
    const scaledHoleHeight = hole.hole_height * Math.abs(transform.a);
    const outerRadiusX = scaledOuterWidth / 2;
    const straightLength = scaledOuterHeight - scaledOuterWidth;
    const innerRadiusX = scaledHoleWidth / 2;
    return [
      {
        name: "g",
        type: "element",
        children: [
          // Outer pill shape
          {
            name: "path",
            type: "element",
            attributes: {
              class: "assembly-hole-outer",
              fill: PAD_COLOR,
              d: `M${x - outerRadiusX},${y - straightLength / 2} v${straightLength} a${outerRadiusX},${outerRadiusX} 0 0 0 ${scaledOuterWidth},0 v-${straightLength} a${outerRadiusX},${outerRadiusX} 0 0 0 -${scaledOuterWidth},0 z`
            },
            value: "",
            children: []
          },
          // Inner pill shape
          {
            name: "path",
            type: "element",
            attributes: {
              class: "assembly-hole-inner",
              fill: HOLE_COLOR3,
              d: `M${x - innerRadiusX},${y - (scaledHoleHeight - scaledHoleWidth) / 2} v${scaledHoleHeight - scaledHoleWidth} a${innerRadiusX},${innerRadiusX} 0 0 0 ${scaledHoleWidth},0 v-${scaledHoleHeight - scaledHoleWidth} a${innerRadiusX},${innerRadiusX} 0 0 0 -${scaledHoleWidth},0 z`
            },
            value: "",
            children: []
          }
        ],
        value: "",
        attributes: {}
      }
    ];
  }
  if (hole.shape === "circle") {
    const scaledOuterWidth = hole.outer_diameter * Math.abs(transform.a);
    const scaledOuterHeight = hole.outer_diameter * Math.abs(transform.a);
    const scaledHoleWidth = hole.hole_diameter * Math.abs(transform.a);
    const scaledHoleHeight = hole.hole_diameter * Math.abs(transform.a);
    const outerRadius = Math.min(scaledOuterWidth, scaledOuterHeight) / 2;
    const innerRadius = Math.min(scaledHoleWidth, scaledHoleHeight) / 2;
    return [
      {
        name: "g",
        type: "element",
        children: [
          {
            name: "circle",
            type: "element",
            attributes: {
              class: "assembly-hole-outer",
              fill: PAD_COLOR,
              cx: x.toString(),
              cy: y.toString(),
              r: outerRadius.toString()
            },
            value: "",
            children: []
          },
          {
            name: "circle",
            type: "element",
            attributes: {
              class: "assembly-hole-inner",
              fill: HOLE_COLOR3,
              cx: x.toString(),
              cy: y.toString(),
              r: innerRadius.toString()
            },
            value: "",
            children: []
          }
        ],
        value: "",
        attributes: {}
      }
    ];
  }
  if (hole.shape === "circular_hole_with_rect_pad") {
    const scaledHoleDiameter = hole.hole_diameter * Math.abs(transform.a);
    const scaledRectPadWidth = hole.rect_pad_width * Math.abs(transform.a);
    const scaledRectPadHeight = hole.rect_pad_height * Math.abs(transform.a);
    const holeRadius = scaledHoleDiameter / 2;
    return [
      {
        name: "g",
        type: "element",
        children: [
          // Rectangular pad (outer shape)
          {
            name: "rect",
            type: "element",
            attributes: {
              class: "assembly-hole-outer-pad",
              fill: PAD_COLOR,
              x: (x - scaledRectPadWidth / 2).toString(),
              y: (y - scaledRectPadHeight / 2).toString(),
              width: scaledRectPadWidth.toString(),
              height: scaledRectPadHeight.toString()
            },
            value: "",
            children: []
          },
          // Circular hole inside the rectangle
          {
            name: "circle",
            type: "element",
            attributes: {
              class: "assembly-hole-inner",
              fill: HOLE_COLOR3,
              cx: x.toString(),
              cy: y.toString(),
              r: holeRadius.toString()
            },
            value: "",
            children: []
          }
        ],
        value: "",
        attributes: {}
      }
    ];
  }
  if (hole.shape === "pill_hole_with_rect_pad") {
    const scaledRectPadWidth = hole.rect_pad_width * Math.abs(transform.a);
    const scaledRectPadHeight = hole.rect_pad_height * Math.abs(transform.a);
    const scaledHoleHeight = hole.hole_height * Math.abs(transform.a);
    const scaledHoleWidth = hole.hole_width * Math.abs(transform.a);
    const holeRadius = Math.min(scaledHoleHeight, scaledHoleWidth) / 2;
    return [
      {
        name: "g",
        type: "element",
        children: [
          // Rectangular pad (outer shape)
          {
            name: "rect",
            type: "element",
            attributes: {
              class: "assembly-hole-outer-pad",
              fill: PAD_COLOR,
              x: (x - scaledRectPadWidth / 2).toString(),
              y: (y - scaledRectPadHeight / 2).toString(),
              width: scaledRectPadWidth.toString(),
              height: scaledRectPadHeight.toString()
            },
            value: "",
            children: []
          },
          // pill hole inside the rectangle
          {
            name: "rect",
            type: "element",
            attributes: {
              class: "assembly-hole-inner",
              fill: HOLE_COLOR3,
              x: (x - scaledHoleWidth / 2).toString(),
              y: (y - scaledHoleHeight / 2).toString(),
              width: scaledHoleWidth.toString(),
              height: scaledHoleHeight.toString(),
              rx: holeRadius.toString(),
              ry: holeRadius.toString()
            },
            value: "",
            children: []
          }
        ],
        value: "",
        attributes: {}
      }
    ];
  }
  return [];
}

// lib/assembly/svg-object-fns/create-svg-objects-from-assembly-smt-pad.ts
import { applyToPoint as applyToPoint24 } from "transformation-matrix";
var PAD_COLOR2 = "rgb(210, 210, 210)";
function createSvgObjectsFromAssemblySmtPad(pad, ctx) {
  const { transform } = ctx;
  if (pad.shape === "rect" || pad.shape === "rotated_rect") {
    const width = pad.width * Math.abs(transform.a);
    const height = pad.height * Math.abs(transform.d);
    const [x, y] = applyToPoint24(transform, [pad.x, pad.y]);
    if (pad.shape === "rotated_rect" && pad.ccw_rotation) {
      return [
        {
          name: "rect",
          type: "element",
          attributes: {
            class: "assembly-pad",
            fill: PAD_COLOR2,
            x: (-width / 2).toString(),
            y: (-height / 2).toString(),
            width: width.toString(),
            height: height.toString(),
            transform: `translate(${x} ${y}) rotate(${-pad.ccw_rotation})`,
            "data-layer": pad.layer
          },
          value: "",
          children: []
        }
      ];
    }
    return [
      {
        name: "rect",
        type: "element",
        attributes: {
          class: "assembly-pad",
          fill: PAD_COLOR2,
          x: (x - width / 2).toString(),
          y: (y - height / 2).toString(),
          width: width.toString(),
          height: height.toString(),
          "data-layer": pad.layer
        },
        value: "",
        children: []
      }
    ];
  }
  if (pad.shape === "pill") {
    const width = pad.width * Math.abs(transform.a);
    const height = pad.height * Math.abs(transform.d);
    const radius = pad.radius * Math.abs(transform.a);
    const [x, y] = applyToPoint24(transform, [pad.x, pad.y]);
    return [
      {
        name: "rect",
        type: "element",
        attributes: {
          class: "assembly-pad",
          fill: PAD_COLOR2,
          x: (x - width / 2).toString(),
          y: (y - height / 2).toString(),
          width: width.toString(),
          height: height.toString(),
          rx: radius.toString(),
          ry: radius.toString(),
          "data-layer": pad.layer
        },
        value: "",
        children: []
      }
    ];
  }
  if (pad.shape === "circle") {
    const radius = pad.radius * Math.abs(transform.a);
    const [x, y] = applyToPoint24(transform, [pad.x, pad.y]);
    return [
      {
        name: "circle",
        type: "element",
        attributes: {
          class: "assembly-pad",
          fill: PAD_COLOR2,
          cx: x.toString(),
          cy: y.toString(),
          r: radius.toString(),
          "data-layer": pad.layer
        },
        value: "",
        children: []
      }
    ];
  }
  if (pad.shape === "polygon") {
    const points = (pad.points ?? []).map(
      (point) => applyToPoint24(transform, [point.x, point.y])
    );
    return [
      {
        name: "polygon",
        type: "element",
        attributes: {
          class: "assembly-pad",
          fill: PAD_COLOR2,
          points: points.map((p) => p.join(",")).join(" "),
          "data-layer": pad.layer
        },
        value: "",
        children: []
      }
    ];
  }
  return [];
}

// lib/assembly/convert-circuit-json-to-assembly-svg.ts
var OBJECT_ORDER2 = [
  "pcb_component",
  "pcb_smtpad",
  "pcb_hole",
  "pcb_plated_hole",
  "pcb_board"
];
function convertCircuitJsonToAssemblySvg(soup, options) {
  let minX = Number.POSITIVE_INFINITY;
  let minY = Number.POSITIVE_INFINITY;
  let maxX = Number.NEGATIVE_INFINITY;
  let maxY = Number.NEGATIVE_INFINITY;
  for (const item of soup) {
    if (item.type === "pcb_board") {
      const center = item.center;
      const width = item.width || 0;
      const height = item.height || 0;
      minX = Math.min(minX, center.x - width / 2);
      minY = Math.min(minY, center.y - height / 2);
      maxX = Math.max(maxX, center.x + width / 2);
      maxY = Math.max(maxY, center.y + height / 2);
    }
  }
  const padding = 1;
  const circuitWidth = maxX - minX + 2 * padding;
  const circuitHeight = maxY - minY + 2 * padding;
  const svgWidth = options?.width ?? 800;
  const svgHeight = options?.height ?? 600;
  const scaleX = svgWidth / circuitWidth;
  const scaleY = svgHeight / circuitHeight;
  const scaleFactor = Math.min(scaleX, scaleY);
  const offsetX = (svgWidth - circuitWidth * scaleFactor) / 2;
  const offsetY = (svgHeight - circuitHeight * scaleFactor) / 2;
  const transform = compose5(
    translate5(
      offsetX - minX * scaleFactor + padding * scaleFactor,
      svgHeight - offsetY + minY * scaleFactor - padding * scaleFactor
    ),
    scale3(scaleFactor, -scaleFactor)
    // Flip in y-direction
  );
  const ctx = { transform };
  const svgObjects = soup.sort(
    (a, b) => (OBJECT_ORDER2.indexOf(b.type) ?? 9999) - (OBJECT_ORDER2.indexOf(a.type) ?? 9999)
  ).flatMap((item) => createSvgObjects2(item, ctx, soup));
  const softwareUsedString = getSoftwareUsedString(soup);
  const version = CIRCUIT_TO_SVG_VERSION;
  const svgObject = {
    name: "svg",
    type: "element",
    attributes: {
      xmlns: "http://www.w3.org/2000/svg",
      width: svgWidth.toString(),
      height: svgHeight.toString(),
      ...softwareUsedString && {
        "data-software-used-string": softwareUsedString
      },
      ...options?.includeVersion && {
        "data-circuit-to-svg-version": version
      }
    },
    value: "",
    children: [
      {
        name: "style",
        type: "element",
        children: [
          {
            type: "text",
            value: `
              .assembly-component { 
                fill: none; 
                stroke: #000; 
              }
              .assembly-board { 
                fill: #f2f2f2; 
                stroke: rgb(0,0,0); 
                stroke-opacity: 0.8;
              }
              .assembly-component-label { 
                fill: #000; 
                font-family: Arial, serif;
                font-weight: bold;
                dominant-baseline: middle;
                text-anchor: middle;
              }
              .assembly-boundary { 
                fill: none; 
                stroke: #fff;
                stroke-width: 0.2; 
              }
            `,
            name: "",
            attributes: {},
            children: []
          }
        ],
        value: "",
        attributes: {}
      },
      {
        name: "rect",
        type: "element",
        attributes: {
          fill: "#fff",
          x: "0",
          y: "0",
          width: svgWidth.toString(),
          height: svgHeight.toString()
        },
        value: "",
        children: []
      },
      createSvgObjectFromAssemblyBoundary(transform, minX, minY, maxX, maxY),
      ...svgObjects
    ].filter((child) => child !== null)
  };
  return stringify2(svgObject);
}
function createSvgObjects2(elm, ctx, soup) {
  const sourceComponents = su3(soup).source_component.list();
  switch (elm.type) {
    case "pcb_board":
      return createSvgObjectsFromAssemblyBoard(elm, ctx.transform);
    case "pcb_component": {
      const sourceComponent = sourceComponents.find(
        (item) => item.source_component_id === elm.source_component_id
      );
      const ports = su3(soup).pcb_port.list().filter((port) => port.pcb_component_id === elm.pcb_component_id);
      const firstPort = ports[0];
      if (sourceComponent && firstPort) {
        const arePinsInterchangeable = sourceComponent.are_pins_interchangeable;
        const obj = createSvgObjectsFromAssemblyComponent(
          {
            elm,
            portPosition: { x: firstPort.x, y: firstPort.y },
            name: sourceComponent.name,
            arePinsInterchangeable
          },
          ctx
        );
        return obj ? [obj] : [];
      }
      return [];
    }
    case "pcb_smtpad":
      return createSvgObjectsFromAssemblySmtPad(elm, ctx);
    case "pcb_hole":
      return createSvgObjectsFromAssemblyHole(elm, ctx);
    case "pcb_plated_hole":
      return createSvgObjectsFromAssemblyPlatedHole(elm, ctx);
    default:
      return [];
  }
}
function createSvgObjectFromAssemblyBoundary(transform, minX, minY, maxX, maxY) {
  const [x1, y1] = applyToPoint25(transform, [minX, minY]);
  const [x2, y2] = applyToPoint25(transform, [maxX, maxY]);
  const width = Math.abs(x2 - x1);
  const height = Math.abs(y2 - y1);
  const x = Math.min(x1, x2);
  const y = Math.min(y1, y2);
  return {
    name: "rect",
    type: "element",
    value: "",
    children: [],
    attributes: {
      class: "assembly-boundary",
      x: x.toString(),
      y: y.toString(),
      width: width.toString(),
      height: height.toString()
    }
  };
}

// lib/utils/colors.ts
var colorMap = {
  "3d_viewer": {
    background_bottom: "rgb(102, 102, 128)",
    background_top: "rgb(204, 204, 230)",
    board: "rgb(51, 43, 23)",
    copper: "rgb(179, 156, 0)",
    silkscreen_bottom: "rgb(230, 230, 230)",
    silkscreen_top: "rgb(230, 230, 230)",
    soldermask: "rgb(20, 51, 36)",
    solderpaste: "rgb(128, 128, 128)"
  },
  board: {
    anchor: "rgb(255, 38, 226)",
    aux_items: "rgb(255, 255, 255)",
    b_adhes: "rgb(0, 0, 132)",
    b_crtyd: "rgb(255, 38, 226)",
    b_fab: "rgb(88, 93, 132)",
    b_mask: "rgba(2, 255, 238, 0.400)",
    b_paste: "rgb(0, 194, 194)",
    b_silks: "rgb(232, 178, 167)",
    background: "rgb(0, 16, 35)",
    cmts_user: "rgb(89, 148, 220)",
    copper: {
      b: "rgb(77, 127, 196)",
      f: "rgb(200, 52, 52)",
      in1: "rgb(127, 200, 127)",
      in10: "rgb(237, 124, 51)",
      in11: "rgb(91, 195, 235)",
      in12: "rgb(247, 111, 142)",
      in13: "rgb(167, 165, 198)",
      in14: "rgb(40, 204, 217)",
      in15: "rgb(232, 178, 167)",
      in16: "rgb(242, 237, 161)",
      in17: "rgb(237, 124, 51)",
      in18: "rgb(91, 195, 235)",
      in19: "rgb(247, 111, 142)",
      in2: "rgb(206, 125, 44)",
      in20: "rgb(167, 165, 198)",
      in21: "rgb(40, 204, 217)",
      in22: "rgb(232, 178, 167)",
      in23: "rgb(242, 237, 161)",
      in24: "rgb(237, 124, 51)",
      in25: "rgb(91, 195, 235)",
      in26: "rgb(247, 111, 142)",
      in27: "rgb(167, 165, 198)",
      in28: "rgb(40, 204, 217)",
      in29: "rgb(232, 178, 167)",
      in3: "rgb(79, 203, 203)",
      in30: "rgb(242, 237, 161)",
      in4: "rgb(219, 98, 139)",
      in5: "rgb(167, 165, 198)",
      in6: "rgb(40, 204, 217)",
      in7: "rgb(232, 178, 167)",
      in8: "rgb(242, 237, 161)",
      in9: "rgb(141, 203, 129)"
    },
    cursor: "rgb(255, 255, 255)",
    drc: "rgb(194, 194, 194)",
    drc_error: "rgba(215, 91, 107, 0.800)",
    drc_exclusion: "rgb(255, 255, 255)",
    drc_warning: "rgba(255, 208, 66, 0.902)",
    dwgs_user: "rgb(194, 194, 194)",
    eco1_user: "rgb(180, 219, 210)",
    eco2_user: "rgb(216, 200, 82)",
    edge_cuts: "rgb(208, 210, 205)",
    f_adhes: "rgb(132, 0, 132)",
    f_crtyd: "rgb(255, 0, 245)",
    f_fab: "rgb(175, 175, 175)",
    f_mask: "rgba(216, 100, 255, 0.400)",
    f_paste: "rgba(180, 160, 154, 0.902)",
    f_silks: "rgb(242, 237, 161)",
    footprint_text_back: "rgb(0, 0, 132)",
    footprint_text_front: "rgb(194, 194, 194)",
    footprint_text_invisible: "rgb(132, 132, 132)",
    grid: "rgb(132, 132, 132)",
    grid_axes: "rgb(194, 194, 194)",
    margin: "rgb(255, 38, 226)",
    microvia: "rgb(0, 132, 132)",
    no_connect: "rgb(0, 0, 132)",
    pad_back: "rgb(77, 127, 196)",
    pad_front: "rgb(200, 52, 52)",
    pad_plated_hole: "rgb(194, 194, 0)",
    pad_through_hole: "rgb(227, 183, 46)",
    plated_hole: "rgb(26, 196, 210)",
    ratsnest: "rgba(245, 255, 213, 0.702)",
    select_overlay: "rgb(4, 255, 67)",
    through_via: "rgb(236, 236, 236)",
    user_1: "rgb(194, 194, 194)",
    user_2: "rgb(89, 148, 220)",
    user_3: "rgb(180, 219, 210)",
    user_4: "rgb(216, 200, 82)",
    user_5: "rgb(194, 194, 194)",
    user_6: "rgb(89, 148, 220)",
    user_7: "rgb(180, 219, 210)",
    user_8: "rgb(216, 200, 82)",
    user_9: "rgb(232, 178, 167)",
    via_blind_buried: "rgb(187, 151, 38)",
    via_hole: "rgb(227, 183, 46)",
    via_micro: "rgb(0, 132, 132)",
    via_through: "rgb(236, 236, 236)",
    worksheet: "rgb(200, 114, 171)"
  },
  gerbview: {
    axes: "rgb(0, 0, 132)",
    background: "rgb(0, 0, 0)",
    dcodes: "rgb(255, 255, 255)",
    grid: "rgb(132, 132, 132)",
    layers: [
      "rgb(132, 0, 0)",
      "rgb(194, 194, 0)",
      "rgb(194, 0, 194)",
      "rgb(194, 0, 0)",
      "rgb(0, 132, 132)",
      "rgb(0, 132, 0)",
      "rgb(0, 0, 132)",
      "rgb(132, 132, 132)",
      "rgb(132, 0, 132)",
      "rgb(194, 194, 194)",
      "rgb(132, 0, 132)",
      "rgb(132, 0, 0)",
      "rgb(132, 132, 0)",
      "rgb(194, 194, 194)",
      "rgb(0, 0, 132)",
      "rgb(0, 132, 0)",
      "rgb(132, 0, 0)",
      "rgb(194, 194, 0)",
      "rgb(194, 0, 194)",
      "rgb(194, 0, 0)",
      "rgb(0, 132, 132)",
      "rgb(0, 132, 0)",
      "rgb(0, 0, 132)",
      "rgb(132, 132, 132)",
      "rgb(132, 0, 132)",
      "rgb(194, 194, 194)",
      "rgb(132, 0, 132)",
      "rgb(132, 0, 0)",
      "rgb(132, 132, 0)",
      "rgb(194, 194, 194)",
      "rgb(0, 0, 132)",
      "rgb(0, 132, 0)",
      "rgb(132, 0, 0)",
      "rgb(194, 194, 0)",
      "rgb(194, 0, 194)",
      "rgb(194, 0, 0)",
      "rgb(0, 132, 132)",
      "rgb(0, 132, 0)",
      "rgb(0, 0, 132)",
      "rgb(132, 132, 132)",
      "rgb(132, 0, 132)",
      "rgb(194, 194, 194)",
      "rgb(132, 0, 132)",
      "rgb(132, 0, 0)",
      "rgb(132, 132, 0)",
      "rgb(194, 194, 194)",
      "rgb(0, 0, 132)",
      "rgb(0, 132, 0)",
      "rgb(132, 0, 0)",
      "rgb(194, 194, 0)",
      "rgb(194, 0, 194)",
      "rgb(194, 0, 0)",
      "rgb(0, 132, 132)",
      "rgb(0, 132, 0)",
      "rgb(0, 0, 132)",
      "rgb(132, 132, 132)",
      "rgb(132, 0, 132)",
      "rgb(194, 194, 194)",
      "rgb(132, 0, 132)",
      "rgb(132, 0, 0)"
    ],
    negative_objects: "rgb(132, 132, 132)",
    worksheet: "rgb(0, 0, 132)"
  },
  meta: {
    filename: "kicad_2020",
    name: "KiCad 2020",
    version: 2
  },
  palette: [
    "rgb(132, 0, 0)",
    "rgb(194, 194, 0)",
    "rgb(194, 0, 194)",
    "rgb(194, 0, 0)",
    "rgb(0, 132, 132)",
    "rgb(0, 132, 0)",
    "rgb(0, 0, 132)",
    "rgb(132, 132, 132)",
    "rgb(132, 0, 132)",
    "rgb(194, 194, 194)",
    "rgb(132, 0, 132)",
    "rgb(132, 0, 0)",
    "rgb(132, 132, 0)",
    "rgb(194, 194, 194)",
    "rgb(0, 0, 132)",
    "rgb(0, 132, 0)"
  ],
  schematic: {
    aux_items: "rgb(46, 46, 46)",
    background: "rgb(245, 241, 237)",
    brightened: "rgb(255, 0, 255)",
    bus: "rgb(0, 0, 132)",
    bus_junction: "rgb(0, 0, 132)",
    component_body: "rgb(255, 255, 194)",
    component_outline: "rgb(132, 0, 0)",
    cursor: "rgb(15, 15, 15)",
    erc_error: "rgba(230, 9, 13, 0.800)",
    erc_warning: "rgba(209, 146, 0, 0.800)",
    fields: "rgb(132, 0, 132)",
    grid: "rgb(181, 181, 181)",
    grid_axes: "rgb(0, 0, 132)",
    hidden: "rgb(194, 194, 194)",
    junction: "rgb(0, 150, 0)",
    label_global: "rgb(132, 0, 0)",
    label_background: "rgba(255, 255, 255, 0.6)",
    label_hier: "rgb(114, 86, 0)",
    label_local: "rgb(15, 15, 15)",
    net_name: "rgb(132, 132, 132)",
    no_connect: "rgb(0, 0, 132)",
    note: "rgb(0, 0, 194)",
    override_item_colors: false,
    pin: "rgb(132, 0, 0)",
    pin_name: "rgb(0, 100, 100)",
    pin_number: "rgb(169, 0, 0)",
    reference: "rgb(0, 100, 100)",
    shadow: "rgba(102, 179, 255, 0.800)",
    sheet: "rgb(132, 0, 0)",
    sheet_background: "rgba(253, 255, 231, 0.000)",
    sheet_fields: "rgb(132, 0, 132)",
    sheet_filename: "rgb(114, 86, 0)",
    sheet_label: "rgb(0, 100, 100)",
    sheet_name: "rgb(0, 100, 100)",
    table: "rgb(102, 102, 102)",
    value: "rgb(0, 100, 100)",
    wire: "rgb(0, 150, 0)",
    wire_crossing: "rgb(30, 180, 30)",
    worksheet: "rgb(132, 0, 0)"
  }
};

// lib/sch/convert-circuit-json-to-schematic-svg.ts
import { stringify as stringify3 } from "svgson";
import {
  fromTriangles,
  toSVG
} from "transformation-matrix";

// lib/sch/draw-schematic-grid.ts
import { applyToPoint as applyToPoint26 } from "transformation-matrix";
function drawSchematicGrid(params) {
  const { minX, minY, maxX, maxY } = params.bounds;
  const cellSize = params.cellSize ?? 1;
  const labelCells = params.labelCells ?? false;
  const gridLines = [];
  const transformPoint = (x, y) => {
    const [transformedX, transformedY] = applyToPoint26(params.transform, [x, y]);
    return { x: transformedX, y: transformedY };
  };
  for (let x = Math.floor(minX); x <= Math.ceil(maxX); x += cellSize) {
    const start = transformPoint(x, minY);
    const end = transformPoint(x, maxY);
    gridLines.push({
      name: "line",
      type: "element",
      attributes: {
        x1: start.x.toString(),
        y1: start.y.toString(),
        x2: end.x.toString(),
        y2: end.y.toString(),
        stroke: colorMap.schematic.grid,
        "stroke-width": (0.01 * Math.abs(params.transform.a)).toString(),
        "stroke-opacity": "0.5"
      }
    });
  }
  for (let y = Math.floor(minY); y <= Math.ceil(maxY); y += cellSize) {
    const start = transformPoint(minX, y);
    const end = transformPoint(maxX, y);
    gridLines.push({
      name: "line",
      type: "element",
      attributes: {
        x1: start.x.toString(),
        y1: start.y.toString(),
        x2: end.x.toString(),
        y2: end.y.toString(),
        stroke: colorMap.schematic.grid,
        "stroke-width": (0.01 * Math.abs(params.transform.a)).toString(),
        "stroke-opacity": "0.5"
      }
    });
  }
  if (labelCells) {
    const formatPoint = (x, y) => {
      if (cellSize <= 0.1) return `${x.toFixed(1)},${y.toFixed(1)}`;
      return `${x},${y}`;
    };
    for (let x = Math.floor(minX); x <= Math.ceil(maxX); x += cellSize) {
      for (let y = Math.floor(minY); y <= Math.ceil(maxY); y += cellSize) {
        const point = transformPoint(x, y);
        gridLines.push({
          name: "text",
          type: "element",
          attributes: {
            x: (point.x - 2.5).toString(),
            y: (point.y - 5).toString(),
            fill: colorMap.schematic.grid,
            "font-size": (cellSize / 5 * Math.abs(params.transform.a)).toString(),
            "fill-opacity": "0.5",
            "text-anchor": "middle",
            "dominant-baseline": "middle",
            "font-family": "sans-serif"
          },
          children: [
            {
              type: "text",
              value: formatPoint(x, y),
              name: "",
              attributes: {},
              children: []
            }
          ]
        });
      }
    }
  }
  return {
    name: "g",
    value: "",
    type: "element",
    attributes: { class: "grid" },
    children: gridLines
  };
}

// lib/sch/draw-schematic-labeled-points.ts
import { applyToPoint as applyToPoint27 } from "transformation-matrix";
function drawSchematicLabeledPoints(params) {
  const { points, transform } = params;
  const labeledPointsGroup = [];
  for (const point of points) {
    const [x1, y1] = applyToPoint27(transform, [point.x - 0.1, point.y - 0.1]);
    const [x2, y2] = applyToPoint27(transform, [point.x + 0.1, point.y + 0.1]);
    const [x3, y3] = applyToPoint27(transform, [point.x - 0.1, point.y + 0.1]);
    const [x4, y4] = applyToPoint27(transform, [point.x + 0.1, point.y - 0.1]);
    labeledPointsGroup.push({
      name: "path",
      type: "element",
      attributes: {
        d: `M${x1},${y1} L${x2},${y2} M${x3},${y3} L${x4},${y4}`,
        stroke: colorMap.schematic.grid,
        "stroke-width": (0.02 * Math.abs(transform.a)).toString(),
        "stroke-opacity": "0.7"
      }
    });
    const [labelX, labelY] = applyToPoint27(transform, [
      point.x + 0.15,
      point.y - 0.15
    ]);
    labeledPointsGroup.push({
      name: "text",
      type: "element",
      attributes: {
        x: labelX.toString(),
        y: labelY.toString(),
        fill: colorMap.schematic.grid,
        "font-size": (0.1 * Math.abs(transform.a)).toString(),
        "fill-opacity": "0.7",
        "text-anchor": "start",
        "font-family": "sans-serif",
        "dominant-baseline": "middle"
      },
      children: [
        {
          type: "text",
          value: point.label || `(${point.x},${point.y})`,
          name: "",
          attributes: {},
          children: []
        }
      ]
    });
  }
  return {
    name: "g",
    value: "",
    type: "element",
    attributes: { class: "labeled-points" },
    children: labeledPointsGroup
  };
}

// lib/sch/arial-text-metrics.ts
var arialTextMetrics = {
  "0": {
    width: 13,
    height: 27,
    ascent: 22,
    descent: 5,
    left: -1,
    right: 12
  },
  "1": {
    width: 13,
    height: 27,
    ascent: 22,
    descent: 5,
    left: -3,
    right: 9
  },
  "2": {
    width: 13,
    height: 27,
    ascent: 22,
    descent: 5,
    left: -1,
    right: 12
  },
  "3": {
    width: 13,
    height: 27,
    ascent: 22,
    descent: 5,
    left: -1,
    right: 12
  },
  "4": {
    width: 13,
    height: 27,
    ascent: 22,
    descent: 5,
    left: 0,
    right: 12
  },
  "5": {
    width: 13,
    height: 27,
    ascent: 22,
    descent: 5,
    left: -1,
    right: 12
  },
  "6": {
    width: 13,
    height: 27,
    ascent: 22,
    descent: 5,
    left: -1,
    right: 12
  },
  "7": {
    width: 13,
    height: 27,
    ascent: 22,
    descent: 5,
    left: -1,
    right: 12
  },
  "8": {
    width: 13,
    height: 27,
    ascent: 22,
    descent: 5,
    left: -1,
    right: 12
  },
  "9": {
    width: 13,
    height: 27,
    ascent: 22,
    descent: 5,
    left: -1,
    right: 12
  },
  " ": {
    width: 7,
    height: 27,
    ascent: 22,
    descent: 5,
    left: 0,
    right: 0
  },
  "!": {
    width: 7,
    height: 27,
    ascent: 22,
    descent: 5,
    left: -2,
    right: 5
  },
  '"': {
    width: 9,
    height: 27,
    ascent: 22,
    descent: 5,
    left: -1,
    right: 7
  },
  "#": {
    width: 13,
    height: 27,
    ascent: 22,
    descent: 5,
    left: 0,
    right: 13
  },
  $: {
    width: 13,
    height: 27,
    ascent: 22,
    descent: 5,
    left: -1,
    right: 12
  },
  "%": {
    width: 21,
    height: 27,
    ascent: 22,
    descent: 5,
    left: -1,
    right: 20
  },
  "&": {
    width: 16,
    height: 27,
    ascent: 22,
    descent: 5,
    left: -1,
    right: 15
  },
  "'": {
    width: 5,
    height: 27,
    ascent: 22,
    descent: 5,
    left: -1,
    right: 3
  },
  "(": {
    width: 8,
    height: 27,
    ascent: 22,
    descent: 5,
    left: -1,
    right: 7
  },
  ")": {
    width: 8,
    height: 27,
    ascent: 22,
    descent: 5,
    left: -1,
    right: 7
  },
  "*": {
    width: 9,
    height: 27,
    ascent: 22,
    descent: 5,
    left: -1,
    right: 8
  },
  "+": {
    width: 14,
    height: 27,
    ascent: 22,
    descent: 5,
    left: -1,
    right: 13
  },
  ",": {
    width: 7,
    height: 27,
    ascent: 22,
    descent: 5,
    left: -2,
    right: 5
  },
  "-": {
    width: 8,
    height: 27,
    ascent: 22,
    descent: 5,
    left: -1,
    right: 7
  },
  ".": {
    width: 7,
    height: 27,
    ascent: 22,
    descent: 5,
    left: -2,
    right: 5
  },
  "/": {
    width: 7,
    height: 27,
    ascent: 22,
    descent: 5,
    left: 0,
    right: 7
  },
  ":": {
    width: 7,
    height: 27,
    ascent: 22,
    descent: 5,
    left: -2,
    right: 5
  },
  ";": {
    width: 7,
    height: 27,
    ascent: 22,
    descent: 5,
    left: -2,
    right: 5
  },
  "<": {
    width: 14,
    height: 27,
    ascent: 22,
    descent: 5,
    left: -1,
    right: 13
  },
  "=": {
    width: 14,
    height: 27,
    ascent: 22,
    descent: 5,
    left: -1,
    right: 13
  },
  ">": {
    width: 14,
    height: 27,
    ascent: 22,
    descent: 5,
    left: -1,
    right: 13
  },
  "?": {
    width: 13,
    height: 27,
    ascent: 22,
    descent: 5,
    left: -1,
    right: 12
  },
  "@": {
    width: 24,
    height: 27,
    ascent: 22,
    descent: 5,
    left: -1,
    right: 23
  },
  A: {
    width: 16,
    height: 27,
    ascent: 22,
    descent: 5,
    left: 0,
    right: 16
  },
  B: {
    width: 16,
    height: 27,
    ascent: 22,
    descent: 5,
    left: -2,
    right: 15
  },
  C: {
    width: 17,
    height: 27,
    ascent: 22,
    descent: 5,
    left: -1,
    right: 16
  },
  D: {
    width: 17,
    height: 27,
    ascent: 22,
    descent: 5,
    left: -2,
    right: 16
  },
  E: {
    width: 16,
    height: 27,
    ascent: 22,
    descent: 5,
    left: -2,
    right: 15
  },
  F: {
    width: 15,
    height: 27,
    ascent: 22,
    descent: 5,
    left: -2,
    right: 14
  },
  G: {
    width: 19,
    height: 27,
    ascent: 22,
    descent: 5,
    left: -1,
    right: 17
  },
  H: {
    width: 17,
    height: 27,
    ascent: 22,
    descent: 5,
    left: -2,
    right: 15
  },
  I: {
    width: 7,
    height: 27,
    ascent: 22,
    descent: 5,
    left: -2,
    right: 5
  },
  J: {
    width: 12,
    height: 27,
    ascent: 22,
    descent: 5,
    left: -1,
    right: 10
  },
  K: {
    width: 16,
    height: 27,
    ascent: 22,
    descent: 5,
    left: -2,
    right: 16
  },
  L: {
    width: 13,
    height: 27,
    ascent: 22,
    descent: 5,
    left: -2,
    right: 12
  },
  M: {
    width: 20,
    height: 27,
    ascent: 22,
    descent: 5,
    left: -2,
    right: 18
  },
  N: {
    width: 17,
    height: 27,
    ascent: 22,
    descent: 5,
    left: -2,
    right: 15
  },
  O: {
    width: 19,
    height: 27,
    ascent: 22,
    descent: 5,
    left: -1,
    right: 18
  },
  P: {
    width: 16,
    height: 27,
    ascent: 22,
    descent: 5,
    left: -2,
    right: 15
  },
  Q: {
    width: 19,
    height: 27,
    ascent: 22,
    descent: 5,
    left: -1,
    right: 18
  },
  R: {
    width: 17,
    height: 27,
    ascent: 22,
    descent: 5,
    left: -2,
    right: 17
  },
  S: {
    width: 16,
    height: 27,
    ascent: 22,
    descent: 5,
    left: -1,
    right: 15
  },
  T: {
    width: 15,
    height: 27,
    ascent: 22,
    descent: 5,
    left: -1,
    right: 14
  },
  U: {
    width: 17,
    height: 27,
    ascent: 22,
    descent: 5,
    left: -2,
    right: 15
  },
  V: {
    width: 16,
    height: 27,
    ascent: 22,
    descent: 5,
    left: 0,
    right: 16
  },
  W: {
    width: 23,
    height: 27,
    ascent: 22,
    descent: 5,
    left: 0,
    right: 22
  },
  X: {
    width: 16,
    height: 27,
    ascent: 22,
    descent: 5,
    left: 0,
    right: 16
  },
  Y: {
    width: 16,
    height: 27,
    ascent: 22,
    descent: 5,
    left: 0,
    right: 16
  },
  Z: {
    width: 15,
    height: 27,
    ascent: 22,
    descent: 5,
    left: 0,
    right: 14
  },
  "[": {
    width: 7,
    height: 27,
    ascent: 22,
    descent: 5,
    left: -2,
    right: 6
  },
  "\\": {
    width: 7,
    height: 27,
    ascent: 22,
    descent: 5,
    left: 0,
    right: 7
  },
  "]": {
    width: 7,
    height: 27,
    ascent: 22,
    descent: 5,
    left: 0,
    right: 5
  },
  "^": {
    width: 11,
    height: 27,
    ascent: 22,
    descent: 5,
    left: -1,
    right: 11
  },
  _: {
    width: 13,
    height: 27,
    ascent: 22,
    descent: 5,
    left: 0,
    right: 14
  },
  "`": {
    width: 8,
    height: 27,
    ascent: 22,
    descent: 5,
    left: -1,
    right: 5
  },
  a: {
    width: 13,
    height: 27,
    ascent: 22,
    descent: 5,
    left: -1,
    right: 12
  },
  b: {
    width: 13,
    height: 27,
    ascent: 22,
    descent: 5,
    left: -2,
    right: 12
  },
  c: {
    width: 12,
    height: 27,
    ascent: 22,
    descent: 5,
    left: -1,
    right: 12
  },
  d: {
    width: 13,
    height: 27,
    ascent: 22,
    descent: 5,
    left: -1,
    right: 12
  },
  e: {
    width: 13,
    height: 27,
    ascent: 22,
    descent: 5,
    left: -1,
    right: 12
  },
  f: {
    width: 7,
    height: 27,
    ascent: 22,
    descent: 5,
    left: 0,
    right: 8
  },
  g: {
    width: 13,
    height: 27,
    ascent: 22,
    descent: 5,
    left: -1,
    right: 12
  },
  h: {
    width: 13,
    height: 27,
    ascent: 22,
    descent: 5,
    left: -2,
    right: 12
  },
  i: {
    width: 5,
    height: 27,
    ascent: 22,
    descent: 5,
    left: -2,
    right: 4
  },
  j: {
    width: 5,
    height: 27,
    ascent: 22,
    descent: 5,
    left: 1,
    right: 4
  },
  k: {
    width: 12,
    height: 27,
    ascent: 22,
    descent: 5,
    left: -2,
    right: 12
  },
  l: {
    width: 5,
    height: 27,
    ascent: 22,
    descent: 5,
    left: -2,
    right: 4
  },
  m: {
    width: 20,
    height: 27,
    ascent: 22,
    descent: 5,
    left: -2,
    right: 18
  },
  n: {
    width: 13,
    height: 27,
    ascent: 22,
    descent: 5,
    left: -2,
    right: 12
  },
  o: {
    width: 13,
    height: 27,
    ascent: 22,
    descent: 5,
    left: -1,
    right: 12
  },
  p: {
    width: 13,
    height: 27,
    ascent: 22,
    descent: 5,
    left: -2,
    right: 12
  },
  q: {
    width: 13,
    height: 27,
    ascent: 22,
    descent: 5,
    left: -1,
    right: 12
  },
  r: {
    width: 8,
    height: 27,
    ascent: 22,
    descent: 5,
    left: -2,
    right: 8
  },
  s: {
    width: 12,
    height: 27,
    ascent: 22,
    descent: 5,
    left: -1,
    right: 11
  },
  t: {
    width: 7,
    height: 27,
    ascent: 22,
    descent: 5,
    left: 0,
    right: 6
  },
  u: {
    width: 13,
    height: 27,
    ascent: 22,
    descent: 5,
    left: -2,
    right: 12
  },
  v: {
    width: 12,
    height: 27,
    ascent: 22,
    descent: 5,
    left: 0,
    right: 12
  },
  w: {
    width: 17,
    height: 27,
    ascent: 22,
    descent: 5,
    left: 0,
    right: 17
  },
  x: {
    width: 12,
    height: 27,
    ascent: 22,
    descent: 5,
    left: 0,
    right: 12
  },
  y: {
    width: 12,
    height: 27,
    ascent: 22,
    descent: 5,
    left: 0,
    right: 12
  },
  z: {
    width: 12,
    height: 27,
    ascent: 22,
    descent: 5,
    left: 0,
    right: 11
  },
  "{": {
    width: 8,
    height: 27,
    ascent: 22,
    descent: 5,
    left: -1,
    right: 7
  },
  "|": {
    width: 6,
    height: 27,
    ascent: 22,
    descent: 5,
    left: -2,
    right: 4
  },
  "}": {
    width: 8,
    height: 27,
    ascent: 22,
    descent: 5,
    left: -1,
    right: 7
  },
  "~": {
    width: 14,
    height: 27,
    ascent: 22,
    descent: 5,
    left: -1,
    right: 13
  }
};

// lib/sch/estimate-text-width.ts
var estimateTextWidth = (text) => {
  if (!text) return 0;
  let totalWidth = 0;
  for (const char of text) {
    const metrics = arialTextMetrics[char];
    if (metrics) {
      totalWidth += metrics.width;
    } else {
      totalWidth += arialTextMetrics["?"].width;
    }
  }
  return totalWidth / 27;
};

// lib/sch/get-table-dimensions.ts
var getTableDimensions = (schematicTable, circuitJson) => {
  if (schematicTable.column_widths && schematicTable.column_widths.length > 0 && schematicTable.row_heights && schematicTable.row_heights.length > 0) {
    const unitToMm = (v) => {
      if (typeof v === "number") return v;
      if (v.endsWith("mm")) return parseFloat(v);
      if (v.endsWith("in")) return parseFloat(v) * 25.4;
      return parseFloat(v);
    };
    return {
      column_widths: schematicTable.column_widths.map(unitToMm),
      row_heights: schematicTable.row_heights.map(unitToMm)
    };
  }
  const cells = circuitJson.filter(
    (elm) => elm.type === "schematic_table_cell" && elm.schematic_table_id === schematicTable.schematic_table_id
  );
  if (cells.length === 0) {
    return { column_widths: [], row_heights: [] };
  }
  const numColumns = cells.reduce((max, c) => Math.max(max, c.end_column_index), -1) + 1;
  const numRows = cells.reduce((max, c) => Math.max(max, c.end_row_index), -1) + 1;
  const { cell_padding = 0.2 } = schematicTable;
  const column_widths = new Array(numColumns).fill(0);
  const row_heights = new Array(numRows).fill(0);
  const cell_widths = {};
  const cell_heights = {};
  for (const cell of cells) {
    const fontSizeMm = getSchMmFontSize("reference_designator", cell.font_size);
    const textWidthMm = estimateTextWidth(cell.text ?? "") * fontSizeMm;
    const requiredWidth = textWidthMm + 2 * cell_padding;
    const requiredHeight = fontSizeMm * 1.2 + 2 * cell_padding;
    const key = `${cell.start_row_index}-${cell.start_column_index}`;
    cell_widths[key] = requiredWidth;
    cell_heights[key] = requiredHeight;
  }
  for (let i = 0; i < numRows; i++) {
    for (let j = 0; j < numColumns; j++) {
      const key = `${i}-${j}`;
      if (cell_widths[key] && cell_widths[key] > column_widths[j]) {
        column_widths[j] = cell_widths[key];
      }
      if (cell_heights[key] && cell_heights[key] > row_heights[i]) {
        row_heights[i] = cell_heights[key];
      }
    }
  }
  for (const cell of cells) {
    if (cell.start_column_index === cell.end_column_index && cell.start_row_index === cell.end_row_index)
      continue;
    const key = `${cell.start_row_index}-${cell.start_column_index}`;
    const requiredWidth = cell_widths[key];
    const requiredHeight = cell_heights[key];
    if (requiredWidth === void 0 || requiredHeight === void 0) continue;
    let currentWidth = 0;
    for (let i = cell.start_column_index; i <= cell.end_column_index; i++) {
      currentWidth += column_widths[i];
    }
    if (requiredWidth > currentWidth) {
      const diff = requiredWidth - currentWidth;
      const extraPerColumn = diff / (cell.end_column_index - cell.start_column_index + 1);
      for (let i = cell.start_column_index; i <= cell.end_column_index; i++) {
        column_widths[i] += extraPerColumn;
      }
    }
    let currentHeight = 0;
    for (let i = cell.start_row_index; i <= cell.end_row_index; i++) {
      currentHeight += row_heights[i];
    }
    if (requiredHeight > currentHeight) {
      const diff = requiredHeight - currentHeight;
      const extraPerRow = diff / (cell.end_row_index - cell.start_row_index + 1);
      for (let i = cell.start_row_index; i <= cell.end_row_index; i++) {
        row_heights[i] += extraPerRow;
      }
    }
  }
  return { column_widths, row_heights };
};

// lib/utils/get-unit-vector-from-outside-to-edge.ts
var getUnitVectorFromOutsideToEdge = (side) => {
  switch (side) {
    case "top":
      return { x: 0, y: -1 };
    case "bottom":
      return { x: 0, y: 1 };
    case "left":
      return { x: 1, y: 0 };
    case "right":
      return { x: -1, y: 0 };
  }
  throw new Error(`Invalid side: ${side}`);
};

// lib/utils/net-label-utils.ts
import "transformation-matrix";
import "schematic-symbols";
var ARROW_POINT_WIDTH_FSR = 0.3;
var END_PADDING_FSR = 0.3;
var END_PADDING_EXTRA_PER_CHARACTER_FSR = 0.06;
var ninePointAnchorToTextAnchor = {
  top_left: "start",
  top_right: "end",
  middle_left: "start",
  middle_right: "end",
  bottom_left: "start",
  bottom_right: "end",
  center: "middle",
  middle_top: "middle",
  middle_bottom: "middle"
};
var ninePointAnchorToDominantBaseline = {
  top_left: "hanging",
  top_right: "hanging",
  bottom_left: "ideographic",
  bottom_right: "ideographic",
  center: "middle",
  middle_left: "middle",
  middle_right: "middle",
  middle_top: "hanging",
  middle_bottom: "ideographic"
};
function getPathRotation(anchorSide) {
  const rotationMap = {
    left: 180,
    top: 90,
    bottom: -90,
    right: 0
  };
  return rotationMap[anchorSide] ?? 0;
}
function calculateAnchorPosition(schNetLabel, fontSizeMm, textWidthFSR) {
  const fullWidthFsr = textWidthFSR + ARROW_POINT_WIDTH_FSR * 2 + END_PADDING_EXTRA_PER_CHARACTER_FSR * schNetLabel.text.length + END_PADDING_FSR;
  const realTextGrowthVec = getUnitVectorFromOutsideToEdge(
    schNetLabel.anchor_side
  );
  return schNetLabel.anchor_position ?? {
    x: schNetLabel.center.x - realTextGrowthVec.x * fullWidthFsr * fontSizeMm / 2,
    y: schNetLabel.center.y - realTextGrowthVec.y * fullWidthFsr * fontSizeMm / 2
  };
}

// lib/sch/get-schematic-bounds-from-circuit-json.ts
function getSchematicBoundsFromCircuitJson(soup, padding = 0.5) {
  let minX = Number.POSITIVE_INFINITY;
  let minY = Number.POSITIVE_INFINITY;
  let maxX = Number.NEGATIVE_INFINITY;
  let maxY = Number.NEGATIVE_INFINITY;
  const portSize = 0.2;
  for (const item of soup) {
    if (item.type === "schematic_component") {
      updateBounds(item.center, item.size, 0);
    } else if (item.type === "schematic_port") {
      updateBounds(item.center, { width: portSize, height: portSize }, 0);
    } else if (item.type === "schematic_debug_object") {
      if (item.shape === "rect") {
        updateBounds(item.center, item.size, 0);
      } else if (item.shape === "line") {
        updateBounds(item.start, { width: 0.1, height: 0.1 }, 0);
        updateBounds(item.end, { width: 0.1, height: 0.1 }, 0);
      }
    } else if (item.type === "schematic_net_label") {
      const fontSizeMm = getSchMmFontSize("net_label");
      const textWidth = estimateTextWidth(item.text || "");
      const fullWidthFsr = textWidth + ARROW_POINT_WIDTH_FSR * 2 + END_PADDING_EXTRA_PER_CHARACTER_FSR * (item.text?.length || 0) + END_PADDING_FSR;
      const width = fullWidthFsr * fontSizeMm;
      const height = 1.2 * fontSizeMm;
      const rotation = getPathRotation(item.anchor_side) / 180 * Math.PI;
      const anchorPosition = calculateAnchorPosition(
        item,
        fontSizeMm,
        textWidth
      );
      const growthVec = getUnitVectorFromOutsideToEdge(item.anchor_side);
      const center = {
        x: anchorPosition.x + growthVec.x * width / 2,
        y: anchorPosition.y + growthVec.y * width / 2
      };
      updateBounds(center, { width, height }, rotation);
    } else if (item.type === "schematic_trace") {
      for (const edge of item.edges) {
        updateBounds(edge.from, { width: 0.1, height: 0.1 }, 0);
        updateBounds(edge.to, { width: 0.1, height: 0.1 }, 0);
      }
    } else if (item.type === "schematic_text") {
      const textType = "reference_designator";
      const fontSize = getSchMmFontSize(textType, item.font_size) ?? 0.18;
      const text = item.text ?? "";
      const width = text.length * fontSize;
      const height = fontSize;
      updateBounds(item.position, { width, height }, item.rotation ?? 0);
    } else if (item.type === "schematic_voltage_probe") {
      updateBounds(item.position, { width: 0.2, height: 0.4 }, 0);
    } else if (item.type === "schematic_box") {
      updateBounds(
        {
          x: item.x + item.width / 2,
          y: item.y + item.height / 2
        },
        { width: item.width, height: item.height },
        0
      );
    } else if (item.type === "schematic_table") {
      const { column_widths, row_heights } = getTableDimensions(item, soup);
      const totalWidth = column_widths.reduce((a, b) => a + b, 0);
      const totalHeight = row_heights.reduce((a, b) => a + b, 0);
      const anchor = item.anchor ?? "center";
      let topLeftX = item.anchor_position.x;
      let topLeftY = item.anchor_position.y;
      if (anchor.includes("center")) {
        topLeftX -= totalWidth / 2;
      } else if (anchor.includes("right")) {
        topLeftX -= totalWidth;
      }
      if (anchor.includes("center")) {
        topLeftY += totalHeight / 2;
      } else if (anchor.includes("bottom")) {
        topLeftY += totalHeight;
      }
      const centerX = topLeftX + totalWidth / 2;
      const centerY = topLeftY - totalHeight / 2;
      updateBounds(
        { x: centerX, y: centerY },
        { width: totalWidth, height: totalHeight },
        0
      );
    }
  }
  minX -= padding;
  minY -= padding;
  maxX += padding;
  maxY += padding;
  return { minX, minY, maxX, maxY };
  function updateBounds(center, size, rotation) {
    const corners = [
      { x: -size.width / 2, y: -size.height / 2 },
      { x: size.width / 2, y: -size.height / 2 },
      { x: size.width / 2, y: size.height / 2 },
      { x: -size.width / 2, y: size.height / 2 }
    ];
    for (const corner of corners) {
      const rotatedX = corner.x * Math.cos(rotation) - corner.y * Math.sin(rotation) + center.x;
      const rotatedY = corner.x * Math.sin(rotation) + corner.y * Math.cos(rotation) + center.y;
      minX = Math.min(minX, rotatedX);
      minY = Math.min(minY, rotatedY);
      maxX = Math.max(maxX, rotatedX);
      maxY = Math.max(maxY, rotatedY);
    }
  }
}

// lib/sch/svg-object-fns/create-svg-objects-from-sch-component-with-symbol.ts
import { su as su4 } from "@tscircuit/circuit-json-util";
import { symbols } from "schematic-symbols";
import "svgson";
import {
  applyToPoint as applyToPoint29,
  compose as compose7
} from "transformation-matrix";

// lib/utils/get-sch-stroke-size.ts
var getSchStrokeSize = (transform) => {
  return Math.abs(transform.a) * 0.02;
};

// lib/utils/match-sch-ports-with-symbol-ports.ts
var getAngularDifference = (angle1, angle2) => {
  const a1 = angle1 < 0 ? angle1 + 2 * Math.PI : angle1;
  const a2 = angle2 < 0 ? angle2 + 2 * Math.PI : angle2;
  let diff = Math.abs(a1 - a2);
  if (diff > Math.PI) {
    diff = 2 * Math.PI - diff;
  }
  return diff;
};
var matchSchPortsToSymbolPorts = ({
  schPorts,
  symbol,
  schComponent
}) => {
  const schPortAngles = schPorts.map((port) => {
    const dx = port.center.x - schComponent.center.x;
    const dy = port.center.y - schComponent.center.y;
    return {
      port,
      angle: Math.atan2(dy, dx)
    };
  });
  const symbolPortAngles = symbol.ports.map((port) => {
    const dx = port.x - symbol.center.x;
    const dy = port.y - symbol.center.y;
    return {
      port,
      angle: Math.atan2(dy, dx)
    };
  });
  schPortAngles.sort((a, b) => a.angle - b.angle);
  symbolPortAngles.sort((a, b) => a.angle - b.angle);
  const matches = [];
  const usedSymbolPorts = /* @__PURE__ */ new Set();
  for (const schPortAngle of schPortAngles) {
    let bestMatch = null;
    for (const symbolPortAngle of symbolPortAngles) {
      if (usedSymbolPorts.has(symbolPortAngle.port)) continue;
      const angleDiff = getAngularDifference(
        schPortAngle.angle,
        symbolPortAngle.angle
      );
      if (bestMatch === null || angleDiff < bestMatch.angleDiff) {
        bestMatch = {
          symbolPort: symbolPortAngle.port,
          angleDiff
        };
      }
    }
    if (bestMatch && bestMatch.angleDiff < Math.PI / 4) {
      matches.push({
        schPort: schPortAngle.port,
        symbolPort: bestMatch.symbolPort
      });
      usedSymbolPorts.add(bestMatch.symbolPort);
    }
  }
  return matches;
};

// lib/utils/point-pairs-to-matrix.ts
import { compose as compose6, scale as scale4, translate as translate6 } from "transformation-matrix";
function pointPairsToMatrix(a1, a2, b1, b2) {
  const tx = a2.x - a1.x;
  const ty = a2.y - a1.y;
  const originalDistance = Math.sqrt((b1.x - a1.x) ** 2 + (b1.y - a1.y) ** 2);
  const transformedDistance = Math.sqrt((b2.x - a2.x) ** 2 + (b2.y - a2.y) ** 2);
  const a = transformedDistance / originalDistance;
  const translateMatrix = translate6(tx, ty);
  const scaleMatrix = scale4(a, a);
  return compose6(translateMatrix, scaleMatrix);
}

// lib/sch/svg-object-fns/create-svg-error-text.ts
import { applyToPoint as applyToPoint28 } from "transformation-matrix";
var createSvgSchErrorText = ({
  text,
  realCenter,
  realToScreenTransform
}) => {
  const screenCenter = applyToPoint28(realToScreenTransform, realCenter);
  return {
    type: "element",
    name: "text",
    value: "",
    attributes: {
      x: screenCenter.x.toString(),
      y: screenCenter.y.toString(),
      fill: "red",
      "text-anchor": "middle",
      "dominant-baseline": "middle",
      "font-family": "sans-serif",
      "font-size": `${getSchScreenFontSize(realToScreenTransform, "error")}px`
    },
    children: [
      {
        type: "text",
        value: text,
        name: "",
        attributes: {},
        children: []
      }
    ]
  };
};

// lib/utils/is-source-port-connected.ts
var isSourcePortConnected = (circuitJson, sourcePortId) => {
  for (const elm of circuitJson) {
    if (elm.type !== "source_trace") continue;
    const trace = elm;
    if (Array.isArray(trace.connected_source_port_ids) && trace.connected_source_port_ids.includes(sourcePortId)) {
      return true;
    }
  }
  return false;
};

// lib/sch/svg-object-fns/create-svg-objects-from-sch-component-with-symbol.ts
var ninePointAnchorToTextAnchor2 = {
  top_left: "start",
  top_right: "end",
  middle_left: "start",
  middle_right: "end",
  bottom_left: "start",
  bottom_right: "end",
  center: "middle",
  middle_top: "middle",
  middle_bottom: "middle"
};
var createSvgObjectsFromSchematicComponentWithSymbol = ({
  component: schComponent,
  transform: realToScreenTransform,
  circuitJson,
  colorMap: colorMap2
}) => {
  const svgObjects = [];
  const symbol = symbols[schComponent.symbol_name];
  if (!symbol) {
    return [
      createSvgSchErrorText({
        text: `Symbol not found: ${schComponent.symbol_name}`,
        realCenter: schComponent.center,
        realToScreenTransform
      })
    ];
  }
  const schPorts = su4(circuitJson).schematic_port.list({
    schematic_component_id: schComponent.schematic_component_id
  });
  const srcComponent = su4(circuitJson).source_component.get(
    schComponent.source_component_id
  );
  const schPortsWithSymbolPorts = matchSchPortsToSymbolPorts({
    schPorts,
    symbol,
    schComponent
  });
  if (!schPortsWithSymbolPorts[0]) {
    return [
      createSvgSchErrorText({
        text: `Could not match ports for symbol ${schComponent.symbol_name}`,
        realCenter: schComponent.center,
        realToScreenTransform
      })
    ];
  }
  const transformFromSymbolToReal = pointPairsToMatrix(
    schPortsWithSymbolPorts[1]?.symbolPort ?? symbol.center,
    schPortsWithSymbolPorts[1]?.schPort.center ?? schComponent.center,
    schPortsWithSymbolPorts[0].symbolPort,
    schPortsWithSymbolPorts[0].schPort.center
  );
  const paths = symbol.primitives.filter((p) => p.type === "path");
  const texts = symbol.primitives.filter((p) => p.type === "text");
  const circles = symbol.primitives.filter((p) => p.type === "circle");
  const boxes = symbol.primitives.filter((p) => p.type === "box");
  const connectedSymbolPorts = /* @__PURE__ */ new Set();
  for (const match of schPortsWithSymbolPorts) {
    if (isSourcePortConnected(circuitJson, match.schPort.source_port_id)) {
      connectedSymbolPorts.add(match.symbolPort);
    }
  }
  const bounds = {
    minX: Math.min(...paths.flatMap((p) => p.points.map((pt) => pt.x))),
    maxX: Math.max(...paths.flatMap((p) => p.points.map((pt) => pt.x))),
    minY: Math.min(...paths.flatMap((p) => p.points.map((pt) => pt.y))),
    maxY: Math.max(...paths.flatMap((p) => p.points.map((pt) => pt.y)))
  };
  const [screenMinX, screenMinY] = applyToPoint29(
    compose7(realToScreenTransform, transformFromSymbolToReal),
    [bounds.minX, bounds.minY]
  );
  const [screenMaxX, screenMaxY] = applyToPoint29(
    compose7(realToScreenTransform, transformFromSymbolToReal),
    [bounds.maxX, bounds.maxY]
  );
  const rectHeight = Math.abs(screenMaxY - screenMinY);
  const rectY = Math.min(screenMinY, screenMaxY);
  const rectWidth = Math.abs(screenMaxX - screenMinX);
  const rectX = Math.min(screenMinX, screenMaxX);
  svgObjects.push({
    name: "rect",
    type: "element",
    value: "",
    attributes: {
      class: "component-overlay",
      x: rectX.toString(),
      y: rectY.toString(),
      width: rectWidth.toString(),
      height: rectHeight.toString(),
      fill: "transparent"
    },
    children: []
  });
  for (const path of paths) {
    const { points, color, closed, fill } = path;
    svgObjects.push({
      type: "element",
      name: "path",
      attributes: {
        d: points.map((p, i) => {
          const [x, y] = applyToPoint29(
            compose7(realToScreenTransform, transformFromSymbolToReal),
            [p.x, p.y]
          );
          return `${i === 0 ? "M" : "L"} ${x} ${y}`;
        }).join(" ") + (closed ? " Z" : ""),
        stroke: colorMap2.schematic.component_outline,
        fill: "none",
        "stroke-width": `${getSchStrokeSize(realToScreenTransform)}px`,
        "stroke-linecap": "round"
      },
      value: "",
      children: []
    });
  }
  for (const text of texts) {
    const screenTextPos = applyToPoint29(
      compose7(realToScreenTransform, transformFromSymbolToReal),
      text
    );
    let textValue = "";
    if (text.text === "{REF}") {
      textValue = srcComponent?.name ?? "";
    } else if (text.text === "{VAL}") {
      textValue = schComponent.symbol_display_value ?? "";
    }
    const symbolHeight = Math.abs(bounds.maxY - bounds.minY);
    const offsetFactor = 0.1;
    const baseOffset = symbolHeight * offsetFactor;
    const transformScale = Math.abs(transformFromSymbolToReal.a);
    let verticalOffset = 0;
    if (text.anchor.includes("bottom")) {
      verticalOffset = baseOffset * transformScale;
    } else if (text.anchor.includes("top")) {
      verticalOffset = -baseOffset * transformScale;
    }
    const dominantBaseline = text.anchor.includes("bottom") ? "auto" : text.anchor.includes("top") ? "hanging" : "middle";
    svgObjects.push({
      name: "text",
      type: "element",
      attributes: {
        x: screenTextPos.x.toString(),
        y: (screenTextPos.y + verticalOffset).toString(),
        fill: colorMap2.schematic.label_local,
        "font-family": "sans-serif",
        "text-anchor": ninePointAnchorToTextAnchor2[text.anchor],
        "dominant-baseline": dominantBaseline,
        "font-size": `${getSchScreenFontSize(realToScreenTransform, "reference_designator")}px`
      },
      value: "",
      children: [
        {
          type: "text",
          value: textValue,
          name: "",
          attributes: {},
          children: []
        }
      ]
    });
  }
  for (const box of boxes) {
    const screenBoxPos = applyToPoint29(
      compose7(realToScreenTransform, transformFromSymbolToReal),
      box
    );
    const symbolToScreenScale = compose7(
      realToScreenTransform,
      transformFromSymbolToReal
    ).a;
    svgObjects.push({
      name: "rect",
      type: "element",
      attributes: {
        x: screenBoxPos.x.toString(),
        y: screenBoxPos.y.toString(),
        width: (box.width * symbolToScreenScale).toString(),
        height: (box.height * symbolToScreenScale).toString(),
        fill: "red"
      },
      value: "",
      children: []
    });
  }
  for (const port of symbol.ports) {
    if (connectedSymbolPorts.has(port)) continue;
    const screenPortPos = applyToPoint29(
      compose7(realToScreenTransform, transformFromSymbolToReal),
      port
    );
    svgObjects.push({
      type: "element",
      name: "circle",
      attributes: {
        cx: screenPortPos.x.toString(),
        cy: screenPortPos.y.toString(),
        r: `${Math.abs(realToScreenTransform.a) * 0.02}px`,
        "stroke-width": `${getSchStrokeSize(realToScreenTransform)}px`,
        fill: "none",
        stroke: colorMap2.schematic.component_outline
      },
      value: "",
      children: []
    });
  }
  for (const circle of circles) {
    const screenCirclePos = applyToPoint29(
      compose7(realToScreenTransform, transformFromSymbolToReal),
      circle
    );
    const screenRadius = Math.abs(circle.radius * realToScreenTransform.a);
    svgObjects.push({
      type: "element",
      name: "circle",
      attributes: {
        cx: screenCirclePos.x.toString(),
        cy: screenCirclePos.y.toString(),
        r: `${screenRadius}px`,
        "stroke-width": `${getSchStrokeSize(realToScreenTransform)}px`,
        fill: "none",
        stroke: colorMap2.schematic.component_outline
      },
      value: "",
      children: []
    });
  }
  return svgObjects;
};

// lib/sch/svg-object-fns/create-svg-objects-from-sch-component-with-box.ts
import { su as su7 } from "@tscircuit/circuit-json-util";
import "schematic-symbols";
import "svgson";
import { applyToPoint as applyToPoint35 } from "transformation-matrix";

// lib/sch/svg-object-fns/create-svg-objects-from-sch-port-on-box.ts
import "transformation-matrix";
import "@tscircuit/circuit-json-util";

// lib/sch/svg-object-fns/create-svg-objects-for-sch-port-box-line.ts
import { applyToPoint as applyToPoint30 } from "transformation-matrix";
import { su as su5 } from "@tscircuit/circuit-json-util";
var PIN_CIRCLE_RADIUS_MM = 0.02;
var createSvgObjectsForSchPortBoxLine = ({
  schPort,
  schComponent,
  transform,
  circuitJson
}) => {
  const svgObjects = [];
  const srcPort = su5(circuitJson).source_port.get(schPort.source_port_id);
  const realEdgePos = {
    x: schPort.center.x,
    y: schPort.center.y
  };
  const realPinLineLength = schPort.distance_from_component_edge ?? 0.4;
  switch (schPort.side_of_component) {
    case "left":
      realEdgePos.x += realPinLineLength;
      break;
    case "right":
      realEdgePos.x -= realPinLineLength;
      break;
    case "top":
      realEdgePos.y -= realPinLineLength;
      break;
    case "bottom":
      realEdgePos.y += realPinLineLength;
      break;
  }
  const screenSchPortPos = applyToPoint30(transform, schPort.center);
  const screenRealEdgePos = applyToPoint30(transform, realEdgePos);
  const realLineEnd = { ...schPort.center };
  switch (schPort.side_of_component) {
    case "left":
      realLineEnd.x += PIN_CIRCLE_RADIUS_MM;
      break;
    case "right":
      realLineEnd.x -= PIN_CIRCLE_RADIUS_MM;
      break;
    case "top":
      realLineEnd.y -= PIN_CIRCLE_RADIUS_MM;
      break;
    case "bottom":
      realLineEnd.y += PIN_CIRCLE_RADIUS_MM;
      break;
  }
  const screenLineEnd = applyToPoint30(transform, realLineEnd);
  svgObjects.push({
    name: "line",
    type: "element",
    attributes: {
      class: "component-pin",
      x1: screenLineEnd.x.toString(),
      y1: screenLineEnd.y.toString(),
      x2: screenRealEdgePos.x.toString(),
      y2: screenRealEdgePos.y.toString(),
      "stroke-width": `${getSchStrokeSize(transform)}px`
    },
    value: "",
    children: []
  });
  const isConnected = isSourcePortConnected(circuitJson, schPort.source_port_id);
  const pinRadiusPx = Math.abs(transform.a) * PIN_CIRCLE_RADIUS_MM;
  const pinChildren = [];
  if (!isConnected) {
    pinChildren.push({
      name: "circle",
      type: "element",
      attributes: {
        class: "component-pin",
        cx: screenSchPortPos.x.toString(),
        cy: screenSchPortPos.y.toString(),
        r: pinRadiusPx.toString(),
        "stroke-width": `${getSchStrokeSize(transform)}px`
      },
      value: "",
      children: []
    });
  }
  pinChildren.push({
    name: "rect",
    type: "element",
    attributes: {
      x: (screenSchPortPos.x - pinRadiusPx).toString(),
      y: (screenSchPortPos.y - pinRadiusPx).toString(),
      width: (pinRadiusPx * 2).toString(),
      height: (pinRadiusPx * 2).toString(),
      opacity: "0"
    },
    value: "",
    children: []
  });
  svgObjects.push({
    name: "g",
    type: "element",
    value: "",
    attributes: {
      "data-schematic-port-id": schPort.source_port_id
    },
    children: pinChildren
  });
  return svgObjects;
};

// lib/sch/svg-object-fns/create-svg-objects-for-sch-port-pin-number-text.ts
import { applyToPoint as applyToPoint31 } from "transformation-matrix";
var createSvgObjectsForSchPortPinNumberText = (params) => {
  const svgObjects = [];
  const { schPort, schComponent, transform, circuitJson } = params;
  const realPinNumberPos = {
    x: schPort.center.x,
    y: schPort.center.y
  };
  if (!schPort.side_of_component) return [];
  const vecToEdge = getUnitVectorFromOutsideToEdge(schPort.side_of_component);
  const realPinEdgeDistance = schPort.distance_from_component_edge ?? 0.4;
  realPinNumberPos.x += vecToEdge.x * realPinEdgeDistance / 2;
  realPinNumberPos.y += vecToEdge.y * realPinEdgeDistance / 2;
  if (schPort.side_of_component === "top" || schPort.side_of_component === "bottom") {
    realPinNumberPos.x -= 0.02;
  } else {
    realPinNumberPos.y += 0.02;
  }
  const screenPinNumberTextPos = applyToPoint31(transform, realPinNumberPos);
  svgObjects.push({
    name: "text",
    type: "element",
    attributes: {
      class: "pin-number",
      x: screenPinNumberTextPos.x.toString(),
      y: screenPinNumberTextPos.y.toString(),
      style: "font-family: sans-serif;",
      fill: colorMap.schematic.pin_number,
      "text-anchor": "middle",
      "dominant-baseline": "auto",
      "font-size": `${getSchScreenFontSize(transform, "pin_number")}px`,
      transform: schPort.side_of_component === "top" || schPort.side_of_component === "bottom" ? `rotate(-90 ${screenPinNumberTextPos.x} ${screenPinNumberTextPos.y})` : ""
    },
    children: [
      {
        type: "text",
        value: schPort.pin_number?.toString() || "",
        name: "",
        attributes: {},
        children: []
      }
    ],
    value: ""
  });
  return svgObjects;
};

// lib/sch/svg-object-fns/create-svg-objects-for-sch-port-pin-label.ts
import { applyToPoint as applyToPoint32 } from "transformation-matrix";
var LABEL_DIST_FROM_EDGE_MM = 0.1;
var createSvgObjectsForSchPortPinLabel = (params) => {
  const svgObjects = [];
  const { schPort, schComponent, transform, circuitJson } = params;
  const realPinNumberPos = {
    x: schPort.center.x,
    y: schPort.center.y
  };
  if (!schPort.side_of_component) return [];
  const vecToEdge = getUnitVectorFromOutsideToEdge(schPort.side_of_component);
  const realPinEdgeDistance = schPort.distance_from_component_edge ?? 0.4;
  realPinNumberPos.x += vecToEdge.x * (realPinEdgeDistance + LABEL_DIST_FROM_EDGE_MM);
  realPinNumberPos.y += vecToEdge.y * (realPinEdgeDistance + LABEL_DIST_FROM_EDGE_MM);
  const screenPinNumberTextPos = applyToPoint32(transform, realPinNumberPos);
  const label = schPort.display_pin_label ?? schComponent.port_labels?.[`${schPort.pin_number}`];
  if (!label) return [];
  const isNegated = label.startsWith("N_");
  const displayLabel = isNegated ? label.slice(2) : label;
  let fontSizePx = getSchScreenFontSize(
    transform,
    isNegated ? "negated_pin_number" : "pin_number"
  );
  svgObjects.push({
    name: "text",
    type: "element",
    attributes: {
      class: "pin-number",
      x: screenPinNumberTextPos.x.toString(),
      y: screenPinNumberTextPos.y.toString(),
      style: `font-family: sans-serif;${isNegated ? " text-decoration: overline;" : ""}`,
      fill: colorMap.schematic.pin_number,
      "text-anchor": schPort.side_of_component === "left" || schPort.side_of_component === "bottom" ? "start" : "end",
      "dominant-baseline": "middle",
      "font-size": `${fontSizePx}px`,
      transform: schPort.side_of_component === "top" || schPort.side_of_component === "bottom" ? `rotate(-90 ${screenPinNumberTextPos.x} ${screenPinNumberTextPos.y})` : ""
    },
    children: [
      {
        type: "text",
        value: displayLabel || "",
        name: "",
        attributes: {},
        children: []
      }
    ],
    value: ""
  });
  return svgObjects;
};

// lib/sch/svg-object-fns/create-svg-objects-from-sch-port-on-box.ts
var createSvgObjectsFromSchPortOnBox = (params) => {
  const svgObjects = [];
  const { schPort, schComponent, transform, circuitJson } = params;
  svgObjects.push(...createSvgObjectsForSchPortBoxLine(params));
  svgObjects.push(...createSvgObjectsForSchPortPinNumberText(params));
  svgObjects.push(...createSvgObjectsForSchPortPinLabel(params));
  return svgObjects;
};

// lib/sch/svg-object-fns/create-svg-objects-for-sch-text.ts
import { applyToPoint as applyToPoint34 } from "transformation-matrix";
var createSvgSchText = ({
  elm,
  transform,
  colorMap: colorMap2
}) => {
  const center = applyToPoint34(transform, elm.position);
  const textAnchorMap = {
    center: "middle",
    center_right: "end",
    bottom_left: "start",
    bottom_center: "middle",
    bottom_right: "end",
    left: "start",
    right: "end",
    top: "middle",
    bottom: "middle",
    top_left: "start",
    top_center: "middle",
    top_right: "end",
    center_left: "start"
  };
  const dominantBaselineMap = {
    center: "middle",
    center_right: "middle",
    bottom_left: "ideographic",
    bottom_center: "ideographic",
    bottom_right: "ideographic",
    left: "middle",
    right: "middle",
    top: "hanging",
    bottom: "ideographic",
    top_left: "hanging",
    top_center: "hanging",
    top_right: "hanging",
    center_left: "middle"
  };
  const lines = elm.text.split("\n");
  const children = lines.length === 1 ? [
    {
      type: "text",
      value: elm.text,
      name: elm.schematic_text_id,
      attributes: {},
      children: []
    }
  ] : lines.map((line, idx) => ({
    type: "element",
    name: "tspan",
    value: "",
    attributes: {
      x: center.x.toString(),
      ...idx > 0 ? { dy: "1em" } : {}
    },
    children: [
      {
        type: "text",
        value: line,
        name: idx === 0 ? elm.schematic_text_id : "",
        attributes: {},
        children: []
      }
    ]
  }));
  return {
    type: "element",
    name: "text",
    value: "",
    attributes: {
      x: center.x.toString(),
      y: center.y.toString(),
      fill: elm.color ?? colorMap2.schematic.sheet_label,
      "text-anchor": textAnchorMap[elm.anchor],
      "dominant-baseline": dominantBaselineMap[elm.anchor],
      "font-family": "sans-serif",
      "font-size": `${getSchScreenFontSize(transform, "reference_designator", elm.font_size)}px`,
      transform: `rotate(${elm.rotation}, ${center.x}, ${center.y})`
    },
    children
  };
};

// lib/sch/svg-object-fns/create-svg-objects-from-sch-component-with-box.ts
var createSvgObjectsFromSchematicComponentWithBox = ({
  component: schComponent,
  transform,
  circuitJson,
  colorMap: colorMap2
}) => {
  const svgObjects = [];
  const componentScreenTopLeft = applyToPoint35(transform, {
    x: schComponent.center.x - schComponent.size.width / 2,
    y: schComponent.center.y + schComponent.size.height / 2
  });
  const componentScreenBottomRight = applyToPoint35(transform, {
    x: schComponent.center.x + schComponent.size.width / 2,
    y: schComponent.center.y - schComponent.size.height / 2
  });
  const componentScreenWidth = componentScreenBottomRight.x - componentScreenTopLeft.x;
  const componentScreenHeight = componentScreenBottomRight.y - componentScreenTopLeft.y;
  svgObjects.push({
    name: "rect",
    type: "element",
    value: "",
    attributes: {
      class: "component chip",
      x: componentScreenTopLeft.x.toString(),
      y: componentScreenTopLeft.y.toString(),
      width: componentScreenWidth.toString(),
      height: componentScreenHeight.toString(),
      "stroke-width": `${getSchStrokeSize(transform)}px`,
      fill: colorMap2.schematic.component_body,
      stroke: colorMap2.schematic.component_outline
    },
    children: []
  });
  svgObjects.push({
    name: "rect",
    type: "element",
    value: "",
    attributes: {
      class: "component-overlay",
      x: componentScreenTopLeft.x.toString(),
      y: componentScreenTopLeft.y.toString(),
      width: componentScreenWidth.toString(),
      height: componentScreenHeight.toString(),
      fill: "transparent"
    },
    children: []
  });
  const schTexts = su7(circuitJson).schematic_text.list();
  for (const schText of schTexts) {
    if (schText.schematic_component_id === schComponent.schematic_component_id) {
      svgObjects.push(
        createSvgSchText({
          elm: schText,
          transform,
          colorMap: colorMap2
        })
      );
    }
  }
  const schematicPorts = su7(circuitJson).schematic_port.list({
    schematic_component_id: schComponent.schematic_component_id
  });
  for (const schPort of schematicPorts) {
    svgObjects.push(
      ...createSvgObjectsFromSchPortOnBox({
        schPort,
        schComponent,
        transform,
        circuitJson
      })
    );
  }
  return svgObjects;
};

// lib/sch/svg-object-fns/create-svg-objects-from-sch-component.ts
function createSvgObjectsFromSchematicComponent(params) {
  const { component } = params;
  const innerElements = component.symbol_name ? createSvgObjectsFromSchematicComponentWithSymbol(params) : createSvgObjectsFromSchematicComponentWithBox(params);
  return [
    {
      type: "element",
      name: "g",
      attributes: {
        "data-circuit-json-type": "schematic_component",
        "data-schematic-component-id": component.schematic_component_id
      },
      children: innerElements,
      value: ""
    }
  ];
}

// lib/sch/svg-object-fns/create-svg-objects-from-sch-voltage-probe.ts
import { applyToPoint as applyToPoint36 } from "transformation-matrix";
function createSvgObjectsFromSchVoltageProbe({
  probe,
  transform,
  colorMap: colorMap2
}) {
  const [screenX, screenY] = applyToPoint36(transform, [
    probe.position.x,
    probe.position.y
  ]);
  const arrowLength = Math.abs(transform.a) * 0.6;
  const arrowWidth = Math.abs(transform.a) * 0.28;
  const baseX = screenX + arrowLength * Math.cos(-50 * Math.PI / 180);
  const baseY = screenY + arrowLength * Math.sin(-50 * Math.PI / 180);
  const tipX = screenX;
  const tipY = screenY;
  const arrowPath = [
    `M ${baseX},${baseY}`,
    `L ${tipX},${tipY}`,
    `M ${tipX},${tipY}`,
    `L ${tipX - arrowWidth * Math.cos((-50 + 150) * Math.PI / 180)},${tipY - arrowWidth * Math.sin((-50 + 150) * Math.PI / 180)}`,
    `L ${tipX - arrowWidth * Math.cos((-50 + 210) * Math.PI / 180)},${tipY - arrowWidth * Math.sin((-50 + 210) * Math.PI / 180)}`,
    "Z"
  ].join(" ");
  return [
    {
      name: "path",
      type: "element",
      attributes: {
        d: arrowPath,
        stroke: colorMap2.schematic.reference,
        fill: colorMap2.schematic.reference,
        "stroke-width": `${getSchStrokeSize(transform)}px`
      },
      value: "",
      children: []
    },
    {
      type: "element",
      name: "text",
      value: "",
      attributes: {
        x: (baseX + 8 - (baseX - baseX)).toString(),
        y: (baseY - 10 + (baseY - baseY)).toString(),
        fill: colorMap2.schematic.reference,
        "text-anchor": "middle",
        "dominant-baseline": "middle",
        "font-family": "sans-serif",
        "font-size": `${getSchScreenFontSize(transform, "reference_designator")}px`,
        "font-weight": "bold",
        "data-schematic-voltage-probe-id": probe.schematic_voltage_probe_id
      },
      children: [
        {
          type: "text",
          value: probe.voltage ? `${probe.voltage}V` : "",
          name: "",
          attributes: {},
          children: []
        }
      ]
    }
  ];
}

// lib/sch/svg-object-fns/create-svg-objects-from-sch-debug-object.ts
import { applyToPoint as applyToPoint37 } from "transformation-matrix";
function createSvgObjectsFromSchDebugObject({
  debugObject,
  transform
}) {
  if (debugObject.shape === "rect") {
    let [screenLeft, screenTop] = applyToPoint37(transform, [
      debugObject.center.x - debugObject.size.width / 2,
      debugObject.center.y - debugObject.size.height / 2
    ]);
    let [screenRight, screenBottom] = applyToPoint37(transform, [
      debugObject.center.x + debugObject.size.width / 2,
      debugObject.center.y + debugObject.size.height / 2
    ]);
    [screenTop, screenBottom] = [
      Math.min(screenTop, screenBottom),
      Math.max(screenTop, screenBottom)
    ];
    const width = Math.abs(screenRight - screenLeft);
    const height = Math.abs(screenBottom - screenTop);
    const [screenCenterX, screenCenterY] = applyToPoint37(transform, [
      debugObject.center.x,
      debugObject.center.y
    ]);
    return [
      {
        name: "rect",
        type: "element",
        value: "",
        attributes: {
          x: screenLeft.toString(),
          y: screenTop.toString(),
          width: width.toString(),
          height: height.toString(),
          fill: "none",
          stroke: "red",
          "stroke-width": (0.02 * Math.abs(transform.a)).toString(),
          "stroke-dasharray": "5,5"
        },
        children: debugObject.label ? [
          {
            name: "text",
            type: "element",
            value: "",
            attributes: {
              x: screenCenterX.toString(),
              y: (screenCenterY - 10).toString(),
              "text-anchor": "middle",
              "font-size": (0.2 * Math.abs(transform.a)).toString(),
              fill: "red"
            },
            children: [
              {
                type: "text",
                value: debugObject.label,
                name: "",
                attributes: {},
                children: []
              }
            ]
          }
        ] : []
      }
    ];
  }
  if (debugObject.shape === "line") {
    const [screenStartX, screenStartY] = applyToPoint37(transform, [
      debugObject.start.x,
      debugObject.start.y
    ]);
    const [screenEndX, screenEndY] = applyToPoint37(transform, [
      debugObject.end.x,
      debugObject.end.y
    ]);
    const screenMidX = (screenStartX + screenEndX) / 2;
    const screenMidY = (screenStartY + screenEndY) / 2;
    return [
      {
        name: "line",
        type: "element",
        value: "",
        attributes: {
          x1: screenStartX.toString(),
          y1: screenStartY.toString(),
          x2: screenEndX.toString(),
          y2: screenEndY.toString(),
          stroke: "red",
          "stroke-width": (0.02 * Math.abs(transform.a)).toString(),
          "stroke-dasharray": "5,5"
        },
        children: debugObject.label ? [
          {
            name: "text",
            type: "element",
            value: "",
            attributes: {
              x: screenMidX.toString(),
              y: (screenMidY - 10).toString(),
              "text-anchor": "middle",
              "font-size": (0.2 * Math.abs(transform.a)).toString(),
              fill: "red"
            },
            children: [
              {
                type: "text",
                value: debugObject.label,
                name: "",
                attributes: {},
                children: []
              }
            ]
          }
        ] : []
      }
    ];
  }
  return [];
}

// lib/sch/svg-object-fns/create-svg-objects-from-sch-trace.ts
import { applyToPoint as applyToPoint38 } from "transformation-matrix";
function createSchematicTrace({
  trace,
  transform,
  colorMap: colorMap2
}) {
  const edges = trace.edges;
  if (edges.length === 0) return [];
  const svgObjects = [];
  let path = "";
  for (let edgeIndex = 0; edgeIndex < edges.length; edgeIndex++) {
    const edge = edges[edgeIndex];
    if (edge.is_crossing) continue;
    const [screenFromX, screenFromY] = applyToPoint38(transform, [
      edge.from.x,
      edge.from.y
    ]);
    const [screenToX, screenToY] = applyToPoint38(transform, [
      edge.to.x,
      edge.to.y
    ]);
    if (edgeIndex === 0 || edges[edgeIndex - 1]?.is_crossing) {
      path += `M ${screenFromX} ${screenFromY} L ${screenToX} ${screenToY}`;
    } else {
      path += ` L ${screenToX} ${screenToY}`;
    }
  }
  for (const edge of edges) {
    if (!edge.is_crossing) continue;
    const [screenFromX, screenFromY] = applyToPoint38(transform, [
      edge.from.x,
      edge.from.y
    ]);
    const [screenToX, screenToY] = applyToPoint38(transform, [
      edge.to.x,
      edge.to.y
    ]);
    const midX = (screenFromX + screenToX) / 2;
    const midY = (screenFromY + screenToY) / 2;
    const dx = screenToX - screenFromX;
    const dy = screenToY - screenFromY;
    const len = Math.sqrt(dx * dx + dy * dy);
    const hopHeight = len * 0.7;
    const perpX = -dy / len * hopHeight;
    const perpY = dx / len * hopHeight;
    const controlX = midX + perpX;
    const controlY = midY - Math.abs(perpY);
    svgObjects.push({
      name: "path",
      type: "element",
      attributes: {
        class: "trace-crossing-outline",
        d: `M ${screenFromX} ${screenFromY} Q ${controlX} ${controlY} ${screenToX} ${screenToY}`,
        stroke: colorMap2.schematic.background,
        fill: "none",
        "stroke-width": `${getSchStrokeSize(transform) * 1.5}px`,
        "stroke-linecap": "round"
      },
      value: "",
      children: []
    });
    svgObjects.push({
      name: "path",
      type: "element",
      attributes: {
        d: `M ${screenFromX} ${screenFromY} Q ${controlX} ${controlY} ${screenToX} ${screenToY}`,
        stroke: colorMap2.schematic.wire,
        fill: "none",
        "stroke-width": `${getSchStrokeSize(transform)}px`,
        "stroke-linecap": "round"
      },
      value: "",
      children: []
    });
  }
  if (path) {
    svgObjects.push({
      name: "path",
      type: "element",
      attributes: {
        d: path,
        class: "trace-invisible-hover-outline",
        stroke: colorMap2.schematic.wire,
        fill: "none",
        "stroke-width": `${getSchStrokeSize(transform) * 8}px`,
        "stroke-linecap": "round",
        opacity: "0",
        "stroke-linejoin": "round"
      },
      value: "",
      children: []
    });
    svgObjects.push({
      name: "path",
      type: "element",
      attributes: {
        d: path,
        stroke: colorMap2.schematic.wire,
        fill: "none",
        "stroke-width": `${getSchStrokeSize(transform)}px`,
        "stroke-linecap": "round",
        "stroke-linejoin": "round"
      },
      value: "",
      children: []
    });
  }
  if (trace.junctions) {
    for (const junction of trace.junctions) {
      const [screenX, screenY] = applyToPoint38(transform, [
        junction.x,
        junction.y
      ]);
      svgObjects.push({
        name: "circle",
        type: "element",
        attributes: {
          cx: screenX.toString(),
          cy: screenY.toString(),
          r: (Math.abs(transform.a) * 0.03).toString(),
          class: "trace-junction",
          fill: colorMap2.schematic.junction
        },
        value: "",
        children: []
      });
    }
  }
  return [
    {
      name: "g",
      type: "element",
      value: "",
      attributes: {
        class: "trace",
        "data-circuit-json-type": "schematic_trace",
        "data-schematic-trace-id": trace.schematic_trace_id
      },
      children: svgObjects
    }
  ];
}

// lib/sch/svg-object-fns/create-svg-objects-for-sch-net-label.ts
import {
  applyToPoint as applyToPoint40,
  compose as compose9,
  rotate as rotate5,
  scale as scale6,
  translate as translate9
} from "transformation-matrix";

// lib/sch/svg-object-fns/create-svg-objects-for-sch-net-label-with-symbol.ts
import {
  applyToPoint as applyToPoint39,
  compose as compose8,
  rotate as rotate4,
  scale as scale5,
  translate as translate8
} from "transformation-matrix";
import { symbols as symbols3 } from "schematic-symbols";
var createSvgObjectsForSchNetLabelWithSymbol = ({
  schNetLabel,
  realToScreenTransform,
  colorMap: colorMap2
}) => {
  if (!schNetLabel.text) return [];
  const isNegated = schNetLabel.text.startsWith("N_");
  const labelText = isNegated ? schNetLabel.text.slice(2) : schNetLabel.text;
  const svgObjects = [];
  const symbol = symbols3[schNetLabel.symbol_name];
  if (!symbol) {
    svgObjects.push(
      createSvgSchErrorText({
        text: `Symbol not found: ${schNetLabel.symbol_name}`,
        realCenter: schNetLabel.center,
        realToScreenTransform
      })
    );
    return svgObjects;
  }
  const symbolPaths = symbol.primitives.filter((p) => p.type === "path");
  const symbolTexts = symbol.primitives.filter((p) => p.type === "text");
  const symbolCircles = symbol.primitives.filter((p) => p.type === "circle");
  const symbolBoxes = symbol.primitives.filter((p) => p.type === "box");
  const bounds = {
    minX: Math.min(...symbolPaths.flatMap((p) => p.points.map((pt) => pt.x))),
    maxX: Math.max(...symbolPaths.flatMap((p) => p.points.map((pt) => pt.x))),
    minY: Math.min(...symbolPaths.flatMap((p) => p.points.map((pt) => pt.y))),
    maxY: Math.max(...symbolPaths.flatMap((p) => p.points.map((pt) => pt.y)))
  };
  const fontSizeMm = getSchMmFontSize("net_label");
  const textWidthFSR = estimateTextWidth(labelText || "");
  const fullWidthFsr = textWidthFSR + ARROW_POINT_WIDTH_FSR * 2 + END_PADDING_EXTRA_PER_CHARACTER_FSR * labelText.length + END_PADDING_FSR;
  const realTextGrowthVec = getUnitVectorFromOutsideToEdge(
    schNetLabel.anchor_side
  );
  const realAnchorPosition = schNetLabel.anchor_position ?? {
    x: schNetLabel.center.x - realTextGrowthVec.x * fullWidthFsr * fontSizeMm / 2,
    y: schNetLabel.center.y - realTextGrowthVec.y * fullWidthFsr * fontSizeMm / 2
  };
  const pathRotation = 0;
  const rotationMatrix = rotate4(pathRotation / 180 * Math.PI);
  const symbolBounds = {
    minX: Math.min(
      ...symbol.primitives.flatMap(
        (p) => p.type === "path" ? p.points.map((pt) => pt.x) : []
      )
    ),
    maxX: Math.max(
      ...symbol.primitives.flatMap(
        (p) => p.type === "path" ? p.points.map((pt) => pt.x) : []
      )
    ),
    minY: Math.min(
      ...symbol.primitives.flatMap(
        (p) => p.type === "path" ? p.points.map((pt) => pt.y) : []
      )
    ),
    maxY: Math.max(
      ...symbol.primitives.flatMap(
        (p) => p.type === "path" ? p.points.map((pt) => pt.y) : []
      )
    )
  };
  const symbolEndPoint = symbol.ports?.[0] ? { x: symbol.ports[0].x, y: symbol.ports[0].y } : {
    x: symbolBounds.minX,
    y: (symbolBounds.minY + symbolBounds.maxY) / 2
  };
  const rotatedSymbolEnd = applyToPoint39(rotationMatrix, symbolEndPoint);
  const symbolToRealTransform = compose8(
    translate8(
      realAnchorPosition.x - rotatedSymbolEnd.x,
      realAnchorPosition.y - rotatedSymbolEnd.y
    ),
    rotationMatrix,
    scale5(1)
    // Use full symbol size
  );
  const [screenMinX, screenMinY] = applyToPoint39(
    compose8(realToScreenTransform, symbolToRealTransform),
    [bounds.minX, bounds.minY]
  );
  const [screenMaxX, screenMaxY] = applyToPoint39(
    compose8(realToScreenTransform, symbolToRealTransform),
    [bounds.maxX, bounds.maxY]
  );
  const rectHeight = Math.abs(screenMaxY - screenMinY);
  const rectY = Math.min(screenMinY, screenMaxY);
  const rectWidth = Math.abs(screenMaxX - screenMinX);
  const rectX = Math.min(screenMinX, screenMaxX);
  svgObjects.push({
    name: "rect",
    type: "element",
    value: "",
    attributes: {
      class: "component-overlay",
      x: rectX.toString(),
      y: rectY.toString(),
      width: rectWidth.toString(),
      height: rectHeight.toString(),
      fill: "transparent"
    },
    children: []
  });
  for (const path of symbolPaths) {
    const symbolPath = path.points.map((p, i) => {
      const [x, y] = applyToPoint39(
        compose8(realToScreenTransform, symbolToRealTransform),
        [p.x, p.y]
      );
      return `${i === 0 ? "M" : "L"} ${x} ${y}`;
    }).join(" ");
    svgObjects.push({
      name: "path",
      type: "element",
      attributes: {
        d: symbolPath + (path.closed ? " Z" : ""),
        stroke: colorMap2.schematic.component_outline,
        fill: "none",
        "stroke-width": `${getSchStrokeSize(realToScreenTransform)}px`,
        "stroke-linecap": "round"
      },
      value: "",
      children: []
    });
  }
  for (const text of symbolTexts) {
    const screenTextPos = applyToPoint39(
      compose8(realToScreenTransform, symbolToRealTransform),
      text
    );
    let textValue = text.text;
    if (textValue === "{REF}") {
      textValue = labelText || "";
    } else if (textValue === "{VAL}") {
      textValue = "";
    }
    const scale9 = Math.abs(realToScreenTransform.a);
    const baseOffset = scale9 * 0.1;
    const offsetScreenPos = {
      x: screenTextPos.x,
      y: screenTextPos.y
    };
    svgObjects.push({
      name: "text",
      type: "element",
      attributes: {
        x: offsetScreenPos.x.toString(),
        y: offsetScreenPos.y.toString(),
        fill: colorMap2.schematic.label_local,
        "font-family": "sans-serif",
        "text-anchor": ninePointAnchorToTextAnchor[text.anchor],
        "dominant-baseline": ninePointAnchorToDominantBaseline[text.anchor],
        "font-size": `${getSchScreenFontSize(realToScreenTransform, "reference_designator")}px`,
        ...isNegated && textValue === labelText ? { style: "text-decoration: overline;" } : {}
      },
      children: [
        {
          type: "text",
          value: textValue,
          name: "",
          attributes: {},
          children: []
        }
      ],
      value: ""
    });
  }
  for (const box of symbolBoxes) {
    const screenBoxPos = applyToPoint39(
      compose8(realToScreenTransform, symbolToRealTransform),
      box
    );
    const symbolToScreenScale = compose8(
      realToScreenTransform,
      symbolToRealTransform
    ).a;
    svgObjects.push({
      name: "rect",
      type: "element",
      attributes: {
        x: screenBoxPos.x.toString(),
        y: screenBoxPos.y.toString(),
        width: (box.width * symbolToScreenScale).toString(),
        height: (box.height * symbolToScreenScale).toString(),
        fill: "red"
      },
      value: "",
      children: []
    });
  }
  for (const circle of symbolCircles) {
    const screenCirclePos = applyToPoint39(
      compose8(realToScreenTransform, symbolToRealTransform),
      circle
    );
    const symbolToScreenScale = compose8(
      realToScreenTransform,
      symbolToRealTransform
    ).a;
    svgObjects.push({
      name: "circle",
      type: "element",
      attributes: {
        cx: screenCirclePos.x.toString(),
        cy: screenCirclePos.y.toString(),
        r: (circle.radius * symbolToScreenScale).toString(),
        fill: "none",
        stroke: colorMap2.schematic.component_outline,
        "stroke-width": `${getSchStrokeSize(realToScreenTransform)}px`
      },
      value: "",
      children: []
    });
  }
  return svgObjects;
};

// lib/sch/svg-object-fns/create-svg-objects-for-sch-net-label.ts
var createSvgObjectsForSchNetLabel = ({
  schNetLabel,
  realToScreenTransform,
  colorMap: colorMap2
}) => {
  if (!schNetLabel.text) return [];
  const labelText = schNetLabel.text;
  if (schNetLabel.symbol_name) {
    return createSvgObjectsForSchNetLabelWithSymbol({
      schNetLabel,
      realToScreenTransform,
      colorMap: colorMap2
    });
  }
  const svgObjects = [];
  const fontSizePx = getSchScreenFontSize(realToScreenTransform, "net_label");
  const fontSizeMm = getSchMmFontSize("net_label");
  const textWidthFSR = estimateTextWidth(labelText || "");
  const screenCenter = applyToPoint40(realToScreenTransform, schNetLabel.center);
  const realTextGrowthVec = getUnitVectorFromOutsideToEdge(
    schNetLabel.anchor_side
  );
  const screenTextGrowthVec = { ...realTextGrowthVec };
  screenTextGrowthVec.y *= -1;
  const fullWidthFsr = textWidthFSR + ARROW_POINT_WIDTH_FSR * 2 + END_PADDING_EXTRA_PER_CHARACTER_FSR * labelText.length + END_PADDING_FSR;
  const screenAnchorPosition = schNetLabel.anchor_position ? applyToPoint40(realToScreenTransform, schNetLabel.anchor_position) : {
    x: screenCenter.x - screenTextGrowthVec.x * fullWidthFsr * fontSizePx / 2,
    y: screenCenter.y - screenTextGrowthVec.y * fullWidthFsr * fontSizePx / 2
  };
  const realAnchorPosition = schNetLabel.anchor_position ?? {
    x: schNetLabel.center.x - realTextGrowthVec.x * fullWidthFsr * fontSizeMm / 2,
    y: schNetLabel.center.y - realTextGrowthVec.y * fullWidthFsr * fontSizeMm / 2
  };
  const pathRotation = {
    left: 0,
    top: -90,
    bottom: 90,
    right: 180
  }[schNetLabel.anchor_side];
  const screenOutlinePoints = [
    // Arrow point in font-relative coordinates
    {
      x: 0,
      y: 0
    },
    // Top left corner in font-relative coordinates
    {
      x: ARROW_POINT_WIDTH_FSR,
      y: 0.6
    },
    // Top right corner in font-relative coordinates
    {
      x: ARROW_POINT_WIDTH_FSR * 2 + END_PADDING_FSR + END_PADDING_EXTRA_PER_CHARACTER_FSR * labelText.length + textWidthFSR,
      y: 0.6
    },
    // Bottom right corner in font-relative coordinates
    {
      x: ARROW_POINT_WIDTH_FSR * 2 + END_PADDING_FSR + END_PADDING_EXTRA_PER_CHARACTER_FSR * labelText.length + textWidthFSR,
      y: -0.6
    },
    // Bottom left corner in font-relative coordinates
    {
      x: ARROW_POINT_WIDTH_FSR,
      y: -0.6
    }
  ].map(
    (fontRelativePoint) => applyToPoint40(
      compose9(
        realToScreenTransform,
        translate9(realAnchorPosition.x, realAnchorPosition.y),
        scale6(fontSizeMm),
        rotate5(pathRotation / 180 * Math.PI)
      ),
      fontRelativePoint
    )
  );
  const pathD = `
    M ${screenOutlinePoints[0].x},${screenOutlinePoints[0].y}
    L ${screenOutlinePoints[1].x},${screenOutlinePoints[1].y}
    L ${screenOutlinePoints[2].x},${screenOutlinePoints[2].y}
    L ${screenOutlinePoints[3].x},${screenOutlinePoints[3].y}
    L ${screenOutlinePoints[4].x},${screenOutlinePoints[4].y}
    Z
  `;
  svgObjects.push({
    name: "path",
    type: "element",
    attributes: {
      class: "net-label",
      d: pathD,
      fill: colorMap2.schematic.label_background,
      stroke: colorMap2.schematic.label_global,
      "stroke-width": `${getSchStrokeSize(realToScreenTransform)}px`
    },
    value: "",
    children: []
  });
  const screenTextPos = {
    x: screenAnchorPosition.x + screenTextGrowthVec.x * fontSizePx * 0.5,
    y: screenAnchorPosition.y + screenTextGrowthVec.y * fontSizePx * 0.5
  };
  const textAnchor = {
    left: "start",
    top: "start",
    bottom: "start",
    right: "end"
  }[schNetLabel.anchor_side];
  const textTransformString = {
    left: "",
    right: "",
    top: `rotate(90 ${screenTextPos.x} ${screenTextPos.y})`,
    bottom: `rotate(-90 ${screenTextPos.x} ${screenTextPos.y})`
  }[schNetLabel.anchor_side];
  svgObjects.push({
    name: "text",
    type: "element",
    attributes: {
      class: "net-label-text",
      x: screenTextPos.x.toString(),
      y: screenTextPos.y.toString(),
      fill: colorMap2.schematic.label_global,
      "text-anchor": textAnchor,
      "dominant-baseline": "central",
      "font-family": "sans-serif",
      "font-variant-numeric": "tabular-nums",
      "font-size": `${fontSizePx}px`,
      transform: textTransformString
    },
    children: [
      {
        type: "text",
        value: labelText || "",
        name: "",
        attributes: {},
        children: []
      }
    ],
    value: ""
  });
  return svgObjects;
};

// lib/sch/svg-object-fns/create-svg-objects-from-sch-box.ts
import { applyToPoint as applyToPoint41 } from "transformation-matrix";
var createSvgObjectsFromSchematicBox = ({
  schematicBox,
  transform,
  colorMap: colorMap2
}) => {
  const topLeft = applyToPoint41(transform, {
    x: schematicBox.x,
    y: schematicBox.y
  });
  const bottomRight = applyToPoint41(transform, {
    x: schematicBox.x + schematicBox.width,
    y: schematicBox.y + schematicBox.height
  });
  const yTop = Math.min(topLeft.y, bottomRight.y);
  const yBottom = Math.max(topLeft.y, bottomRight.y);
  const xLeft = Math.min(topLeft.x, bottomRight.x);
  const xRight = Math.max(topLeft.x, bottomRight.x);
  const strokeWidthPx = getSchStrokeSize(transform);
  const attributes = {
    class: "schematic-box",
    x: xLeft.toString(),
    y: yTop.toString(),
    width: (xRight - xLeft).toString(),
    height: (yBottom - yTop).toString(),
    "stroke-width": `${strokeWidthPx}px`,
    stroke: colorMap2.schematic.component_outline || "black",
    fill: "transparent"
  };
  if (schematicBox.is_dashed) {
    const dashLength = 8 * strokeWidthPx;
    const gapLength = 4 * strokeWidthPx;
    attributes["stroke-dasharray"] = `${dashLength} ${gapLength}`;
  }
  return [
    {
      name: "rect",
      type: "element",
      value: "",
      attributes,
      children: []
    }
  ];
};

// lib/sch/svg-object-fns/create-svg-objects-from-sch-table.ts
import { applyToPoint as applyToPoint42 } from "transformation-matrix";
var createSvgObjectsFromSchematicTable = ({
  schematicTable,
  transform,
  colorMap: colorMap2,
  circuitJson
}) => {
  const {
    anchor_position,
    border_width = 0.05,
    anchor = "center"
  } = schematicTable;
  const { column_widths, row_heights } = getTableDimensions(
    schematicTable,
    circuitJson
  );
  const totalWidth = column_widths.reduce((a, b) => a + b, 0);
  const totalHeight = row_heights.reduce((a, b) => a + b, 0);
  let topLeftX = anchor_position.x;
  let topLeftY = anchor_position.y;
  if (anchor.includes("center")) {
    topLeftX -= totalWidth / 2;
  } else if (anchor.includes("right")) {
    topLeftX -= totalWidth;
  }
  if (anchor.includes("center")) {
    topLeftY += totalHeight / 2;
  } else if (anchor.includes("bottom")) {
    topLeftY += totalHeight;
  }
  const svgObjects = [];
  const borderStrokeWidth = border_width * Math.abs(transform.a);
  const gridStrokeWidth = getSchStrokeSize(transform);
  const [screenTopLeftX, screenTopLeftY] = applyToPoint42(transform, [
    topLeftX,
    topLeftY
  ]);
  const [screenBottomRightX, screenBottomRightY] = applyToPoint42(transform, [
    topLeftX + totalWidth,
    topLeftY - totalHeight
  ]);
  svgObjects.push({
    name: "rect",
    type: "element",
    attributes: {
      x: screenTopLeftX.toString(),
      y: screenTopLeftY.toString(),
      width: (screenBottomRightX - screenTopLeftX).toString(),
      height: (screenBottomRightY - screenTopLeftY).toString(),
      fill: "none",
      stroke: colorMap2.schematic.table,
      "stroke-width": borderStrokeWidth.toString()
    },
    children: [],
    value: ""
  });
  const cells = circuitJson.filter(
    (elm) => elm.type === "schematic_table_cell" && elm.schematic_table_id === schematicTable.schematic_table_id
  );
  let currentX = topLeftX;
  for (let i = 0; i < column_widths.length - 1; i++) {
    currentX += column_widths[i];
    let segmentStartY = topLeftY;
    for (let j = 0; j < row_heights.length; j++) {
      const segmentEndY = segmentStartY - row_heights[j];
      const isMerged = cells.some(
        (cell) => cell.start_column_index <= i && cell.end_column_index > i && cell.start_row_index <= j && cell.end_row_index >= j
      );
      if (!isMerged) {
        const start = applyToPoint42(transform, { x: currentX, y: segmentStartY });
        const end = applyToPoint42(transform, { x: currentX, y: segmentEndY });
        svgObjects.push({
          name: "line",
          type: "element",
          attributes: {
            x1: start.x.toString(),
            y1: start.y.toString(),
            x2: end.x.toString(),
            y2: end.y.toString(),
            stroke: colorMap2.schematic.table,
            "stroke-width": gridStrokeWidth.toString()
          },
          children: [],
          value: ""
        });
      }
      segmentStartY = segmentEndY;
    }
  }
  let currentY = topLeftY;
  for (let i = 0; i < row_heights.length - 1; i++) {
    currentY -= row_heights[i];
    let segmentStartX = topLeftX;
    for (let j = 0; j < column_widths.length; j++) {
      const segmentEndX = segmentStartX + column_widths[j];
      const isMerged = cells.some(
        (cell) => cell.start_row_index <= i && cell.end_row_index > i && cell.start_column_index <= j && cell.end_column_index >= j
      );
      if (!isMerged) {
        const start = applyToPoint42(transform, {
          x: segmentStartX,
          y: currentY
        });
        const end = applyToPoint42(transform, { x: segmentEndX, y: currentY });
        svgObjects.push({
          name: "line",
          type: "element",
          attributes: {
            x1: start.x.toString(),
            y1: start.y.toString(),
            x2: end.x.toString(),
            y2: end.y.toString(),
            stroke: colorMap2.schematic.table,
            "stroke-width": gridStrokeWidth.toString()
          },
          children: [],
          value: ""
        });
      }
      segmentStartX = segmentEndX;
    }
  }
  for (const cell of cells) {
    if (cell.text) {
      const cellWidth = column_widths.slice(cell.start_column_index, cell.end_column_index + 1).reduce((a, b) => a + b, 0);
      const cellHeight = row_heights.slice(cell.start_row_index, cell.end_row_index + 1).reduce((a, b) => a + b, 0);
      const cellTopLeftX = topLeftX + column_widths.slice(0, cell.start_column_index).reduce((a, b) => a + b, 0);
      const cellTopLeftY = topLeftY - row_heights.slice(0, cell.start_row_index).reduce((a, b) => a + b, 0);
      const { cell_padding = 0.2 } = schematicTable;
      const horizontal_align = cell.horizontal_align ?? "center";
      const vertical_align = cell.vertical_align ?? "middle";
      let realTextAnchorPos = {
        x: cellTopLeftX + cellWidth / 2,
        y: cellTopLeftY - cellHeight / 2
      };
      if (horizontal_align === "left") {
        realTextAnchorPos.x = cellTopLeftX + cell_padding;
      } else if (horizontal_align === "right") {
        realTextAnchorPos.x = cellTopLeftX + cellWidth - cell_padding;
      }
      if (vertical_align === "top") {
        realTextAnchorPos.y = cellTopLeftY - cell_padding;
      } else if (vertical_align === "bottom") {
        realTextAnchorPos.y = cellTopLeftY - cellHeight + cell_padding;
      }
      const screenTextAnchorPos = applyToPoint42(transform, realTextAnchorPos);
      const fontSize = getSchScreenFontSize(
        transform,
        "reference_designator",
        cell.font_size
      );
      const textAnchorMap = {
        left: "start",
        center: "middle",
        right: "end"
      };
      const dominantBaselineMap = {
        top: "hanging",
        middle: "middle",
        bottom: "ideographic"
      };
      svgObjects.push({
        name: "text",
        type: "element",
        attributes: {
          x: screenTextAnchorPos.x.toString(),
          y: screenTextAnchorPos.y.toString(),
          "font-size": `${fontSize}px`,
          "text-anchor": textAnchorMap[horizontal_align],
          "dominant-baseline": dominantBaselineMap[vertical_align],
          fill: colorMap2.schematic.table,
          "font-family": "sans-serif"
        },
        children: [
          {
            type: "text",
            value: cell.text,
            name: "",
            attributes: {},
            children: []
          }
        ],
        value: ""
      });
    }
  }
  return [
    {
      name: "g",
      type: "element",
      attributes: {
        "data-schematic-table-id": schematicTable.schematic_table_id
      },
      children: svgObjects,
      value: ""
    }
  ];
};

// lib/sch/svg-object-fns/create-svg-objects-for-sch-port-hover.ts
import { su as su8 } from "@tscircuit/circuit-json-util";
import { applyToPoint as applyToPoint43 } from "transformation-matrix";
var PIN_CIRCLE_RADIUS_MM2 = 0.02;
var createSvgObjectsForSchPortHover = ({
  schPort,
  transform
}) => {
  const screenSchPortPos = applyToPoint43(transform, schPort.center);
  const pinRadiusPx = Math.abs(transform.a) * PIN_CIRCLE_RADIUS_MM2 * 2;
  return [
    {
      name: "g",
      type: "element",
      value: "",
      attributes: {
        class: "schematic-port-hover",
        "data-schematic-port-id": schPort.source_port_id
      },
      children: [
        {
          name: "circle",
          type: "element",
          value: "",
          attributes: {
            cx: screenSchPortPos.x.toString(),
            cy: screenSchPortPos.y.toString(),
            r: pinRadiusPx.toString(),
            fill: "red",
            opacity: "0"
          },
          children: []
        }
      ]
    }
  ];
};
var createSvgObjectsForSchComponentPortHovers = ({
  component,
  transform,
  circuitJson
}) => {
  const schematicPorts = su8(circuitJson).schematic_port.list({
    schematic_component_id: component.schematic_component_id
  });
  const svgs = [];
  for (const schPort of schematicPorts) {
    svgs.push(...createSvgObjectsForSchPortHover({ schPort, transform }));
  }
  return svgs;
};

// lib/sch/convert-circuit-json-to-schematic-svg.ts
function convertCircuitJsonToSchematicSvg(circuitJson, options) {
  const realBounds = getSchematicBoundsFromCircuitJson(circuitJson);
  const realWidth = realBounds.maxX - realBounds.minX;
  const realHeight = realBounds.maxY - realBounds.minY;
  const svgWidth = options?.width ?? 1200;
  const svgHeight = options?.height ?? 600;
  const colorOverrides = options?.colorOverrides;
  const colorMap2 = {
    ...colorMap,
    schematic: {
      ...colorMap.schematic,
      ...colorOverrides?.schematic ?? {}
    }
  };
  const circuitAspectRatio = realWidth / realHeight;
  const containerAspectRatio = svgWidth / svgHeight;
  let screenPaddingPx;
  if (circuitAspectRatio > containerAspectRatio) {
    const newHeight = svgWidth / circuitAspectRatio;
    screenPaddingPx = {
      x: 0,
      y: (svgHeight - newHeight) / 2
    };
  } else {
    const newWidth = svgHeight * circuitAspectRatio;
    screenPaddingPx = {
      x: (svgWidth - newWidth) / 2,
      y: 0
    };
  }
  const transform = fromTriangles(
    [
      { x: realBounds.minX, y: realBounds.maxY },
      { x: realBounds.maxX, y: realBounds.maxY },
      { x: realBounds.maxX, y: realBounds.minY }
    ],
    [
      { x: screenPaddingPx.x, y: screenPaddingPx.y },
      { x: svgWidth - screenPaddingPx.x, y: screenPaddingPx.y },
      { x: svgWidth - screenPaddingPx.x, y: svgHeight - screenPaddingPx.y }
    ]
  );
  const svgChildren = [];
  svgChildren.push({
    name: "rect",
    type: "element",
    attributes: {
      class: "boundary",
      x: "0",
      y: "0",
      width: svgWidth.toString(),
      height: svgHeight.toString()
    },
    children: [],
    value: ""
  });
  if (options?.grid) {
    const gridConfig = typeof options.grid === "object" ? options.grid : {};
    svgChildren.push(
      drawSchematicGrid({ bounds: realBounds, transform, ...gridConfig })
    );
  }
  const schDebugObjectSvgs = [];
  const schComponentSvgs = [];
  const schTraceSvgs = [];
  const schNetLabel = [];
  const schText = [];
  const voltageProbeSvgs = [];
  const schBoxSvgs = [];
  const schTableSvgs = [];
  const schPortHoverSvgs = [];
  for (const elm of circuitJson) {
    if (elm.type === "schematic_debug_object") {
      schDebugObjectSvgs.push(
        ...createSvgObjectsFromSchDebugObject({
          debugObject: elm,
          transform
        })
      );
    } else if (elm.type === "schematic_component") {
      schComponentSvgs.push(
        ...createSvgObjectsFromSchematicComponent({
          component: elm,
          transform,
          circuitJson,
          colorMap: colorMap2
        })
      );
      schPortHoverSvgs.push(
        ...createSvgObjectsForSchComponentPortHovers({
          component: elm,
          transform,
          circuitJson
        })
      );
    } else if (elm.type === "schematic_box") {
      schBoxSvgs.push(
        ...createSvgObjectsFromSchematicBox({
          schematicBox: elm,
          transform,
          colorMap: colorMap2
        })
      );
    } else if (elm.type === "schematic_trace") {
      schTraceSvgs.push(
        ...createSchematicTrace({
          trace: elm,
          transform,
          colorMap: colorMap2
        })
      );
    } else if (elm.type === "schematic_net_label") {
      schNetLabel.push(
        ...createSvgObjectsForSchNetLabel({
          schNetLabel: elm,
          realToScreenTransform: transform,
          colorMap: colorMap2
        })
      );
    } else if (elm.type === "schematic_text" && !elm.schematic_component_id) {
      schText.push(
        createSvgSchText({
          elm,
          transform,
          colorMap: colorMap2
        })
      );
    } else if (elm.type === "schematic_voltage_probe") {
      voltageProbeSvgs.push(
        ...createSvgObjectsFromSchVoltageProbe({
          probe: elm,
          transform,
          colorMap: colorMap2
        })
      );
    } else if (elm.type === "schematic_table") {
      schTableSvgs.push(
        ...createSvgObjectsFromSchematicTable({
          schematicTable: elm,
          transform,
          colorMap: colorMap2,
          circuitJson
        })
      );
    }
  }
  svgChildren.push(
    ...schDebugObjectSvgs,
    ...schComponentSvgs,
    ...schTraceSvgs,
    ...schPortHoverSvgs,
    ...schNetLabel,
    ...schText,
    ...schBoxSvgs,
    ...voltageProbeSvgs,
    ...schTableSvgs
  );
  if (options?.labeledPoints) {
    svgChildren.push(
      drawSchematicLabeledPoints({
        points: options.labeledPoints,
        transform
      })
    );
  }
  const softwareUsedString = getSoftwareUsedString(circuitJson);
  const version = CIRCUIT_TO_SVG_VERSION;
  const svgObject = {
    name: "svg",
    type: "element",
    attributes: {
      xmlns: "http://www.w3.org/2000/svg",
      width: svgWidth.toString(),
      height: svgHeight.toString(),
      style: `background-color: ${colorMap2.schematic.background}`,
      "data-real-to-screen-transform": toSVG(transform),
      ...softwareUsedString && {
        "data-software-used-string": softwareUsedString
      },
      ...options?.includeVersion && {
        "data-circuit-to-svg-version": version
      }
    },
    children: [
      // Add styles
      {
        name: "style",
        type: "element",
        children: [
          {
            type: "text",
            // DO NOT USE THESE CLASSES!!!!
            // PUT STYLES IN THE SVG OBJECTS THEMSELVES
            value: `
              .boundary { fill: ${colorMap2.schematic.background}; }
              .schematic-boundary { fill: none; stroke: #fff; }
              .component { fill: none; stroke: ${colorMap2.schematic.component_outline}; }
              .chip { fill: ${colorMap2.schematic.component_body}; stroke: ${colorMap2.schematic.component_outline}; }
              .component-pin { fill: none; stroke: ${colorMap2.schematic.component_outline}; }
              .trace:hover {
                filter: invert(1);
              }
              .trace:hover .trace-crossing-outline {
                opacity: 0;
              }
              .trace:hover .trace-junction {
                filter: invert(1);
              }
              .text { font-family: sans-serif; fill: ${colorMap2.schematic.wire}; }
              .pin-number { fill: ${colorMap2.schematic.pin_number}; }
              .port-label { fill: ${colorMap2.schematic.reference}; }
              .component-name { fill: ${colorMap2.schematic.reference}; }
            `,
            name: "",
            attributes: {},
            children: []
          }
        ],
        value: "",
        attributes: {}
      },
      ...svgChildren
    ],
    value: ""
  };
  return stringify3(svgObject);
}
var circuitJsonToSchematicSvg = convertCircuitJsonToSchematicSvg;

// lib/pcb/convert-circuit-json-to-solder-paste-mask.ts
import { stringify as stringify4 } from "svgson";
import {
  applyToPoint as applyToPoint46,
  compose as compose11,
  scale as scale8,
  translate as translate11
} from "transformation-matrix";

// lib/pcb/svg-object-fns/convert-circuit-json-to-solder-paste-mask.ts
import { applyToPoint as applyToPoint45 } from "transformation-matrix";
function createSvgObjectsFromSolderPaste(solderPaste, ctx) {
  const { transform, layer: layerFilter } = ctx;
  if (layerFilter && solderPaste.layer !== layerFilter) return [];
  const [x, y] = applyToPoint45(transform, [solderPaste.x, solderPaste.y]);
  if (solderPaste.shape === "rect" || solderPaste.shape === "rotated_rect") {
    const width = solderPaste.width * Math.abs(transform.a);
    const height = solderPaste.height * Math.abs(transform.d);
    if (solderPaste.shape === "rotated_rect" && solderPaste.ccw_rotation) {
      return [
        {
          name: "rect",
          type: "element",
          attributes: {
            class: "pcb-solder-paste",
            fill: solderPasteLayerNameToColor(solderPaste.layer),
            x: (-width / 2).toString(),
            y: (-height / 2).toString(),
            width: width.toString(),
            height: height.toString(),
            transform: `translate(${x} ${y}) rotate(${-solderPaste.ccw_rotation})`
          }
        }
      ];
    }
    return [
      {
        name: "rect",
        type: "element",
        attributes: {
          class: "pcb-solder-paste",
          fill: solderPasteLayerNameToColor(solderPaste.layer),
          x: (x - width / 2).toString(),
          y: (y - height / 2).toString(),
          width: width.toString(),
          height: height.toString()
        }
      }
    ];
  }
  if (solderPaste.shape === "pill") {
    const width = solderPaste.width * Math.abs(transform.a);
    const height = solderPaste.height * Math.abs(transform.d);
    const radius = solderPaste.radius * Math.abs(transform.a);
    return [
      {
        name: "rect",
        type: "element",
        attributes: {
          class: "pcb-solder-paste",
          fill: solderPasteLayerNameToColor(solderPaste.layer),
          x: (x - width / 2).toString(),
          y: (y - height / 2).toString(),
          width: width.toString(),
          height: height.toString(),
          rx: radius.toString()
        }
      }
    ];
  }
  if (solderPaste.shape === "circle") {
    const radius = solderPaste.radius * Math.abs(transform.a);
    return [
      {
        name: "circle",
        type: "element",
        attributes: {
          class: "pcb-solder-paste",
          fill: solderPasteLayerNameToColor(solderPaste.layer),
          cx: x.toString(),
          cy: y.toString(),
          r: radius.toString()
        }
      }
    ];
  }
}

// lib/pcb/convert-circuit-json-to-solder-paste-mask.ts
var OBJECT_ORDER3 = [
  "pcb_board",
  "pcb_solder_paste"
];
function convertCircuitJsonToSolderPasteMask(circuitJson, options) {
  let minX = Number.POSITIVE_INFINITY;
  let minY = Number.POSITIVE_INFINITY;
  let maxX = Number.NEGATIVE_INFINITY;
  let maxY = Number.NEGATIVE_INFINITY;
  const filteredCircuitJson = circuitJson.filter(
    (elm) => elm.type === "pcb_board" || elm.type === "pcb_solder_paste" && elm.layer === options.layer
  );
  for (const item of filteredCircuitJson) {
    if (item.type === "pcb_board") {
      if (item.outline && Array.isArray(item.outline) && item.outline.length >= 3) {
        updateBoundsToIncludeOutline(item.outline);
      } else if ("center" in item && "width" in item && "height" in item) {
        updateBounds(item.center, item.width, item.height);
      }
    } else if (item.type === "pcb_solder_paste" && "x" in item && "y" in item) {
      updateBounds({ x: item.x, y: item.y }, 0, 0);
    }
  }
  const padding = 1;
  const circuitWidth = maxX - minX + 2 * padding;
  const circuitHeight = maxY - minY + 2 * padding;
  const svgWidth = options.width ?? 800;
  const svgHeight = options.height ?? 600;
  const scaleX = svgWidth / circuitWidth;
  const scaleY = svgHeight / circuitHeight;
  const scaleFactor = Math.min(scaleX, scaleY);
  const offsetX = (svgWidth - circuitWidth * scaleFactor) / 2;
  const offsetY = (svgHeight - circuitHeight * scaleFactor) / 2;
  const transform = compose11(
    translate11(
      offsetX - minX * scaleFactor + padding * scaleFactor,
      svgHeight - offsetY + minY * scaleFactor - padding * scaleFactor
    ),
    scale8(scaleFactor, -scaleFactor)
    // Flip in y-direction
  );
  const ctx = {
    transform,
    layer: options.layer,
    colorMap: DEFAULT_PCB_COLOR_MAP
  };
  const svgObjects = filteredCircuitJson.sort(
    (a, b) => (OBJECT_ORDER3.indexOf(b.type) ?? 9999) - (OBJECT_ORDER3.indexOf(a.type) ?? 9999)
  ).flatMap((item) => createSvgObjects3({ elm: item, ctx }));
  const softwareUsedString = getSoftwareUsedString(circuitJson);
  const version = CIRCUIT_TO_SVG_VERSION;
  const svgObject = {
    name: "svg",
    type: "element",
    attributes: {
      xmlns: "http://www.w3.org/2000/svg",
      width: svgWidth.toString(),
      height: svgHeight.toString(),
      ...softwareUsedString && {
        "data-software-used-string": softwareUsedString
      },
      ...options.includeVersion && {
        "data-circuit-to-svg-version": version
      }
    },
    value: "",
    children: [
      {
        name: "style",
        type: "element",
        children: [
          {
            type: "text",
            value: ""
          }
        ]
      },
      {
        name: "rect",
        type: "element",
        attributes: {
          class: "boundary",
          x: "0",
          y: "0",
          fill: "#000",
          width: svgWidth.toString(),
          height: svgHeight.toString()
        }
      },
      createSvgObjectFromPcbBoundary2(transform, minX, minY, maxX, maxY),
      ...svgObjects
    ].filter((child) => child !== null)
  };
  try {
    return stringify4(svgObject);
  } catch (error) {
    console.error("Error stringifying SVG object:", error);
    throw error;
  }
  function updateBounds(center, width, height) {
    const halfWidth = width / 2;
    const halfHeight = height / 2;
    minX = Math.min(minX, center.x - halfWidth);
    minY = Math.min(minY, center.y - halfHeight);
    maxX = Math.max(maxX, center.x + halfWidth);
    maxY = Math.max(maxY, center.y + halfHeight);
  }
  function updateBoundsToIncludeOutline(outline) {
    for (const point of outline) {
      minX = Math.min(minX, point.x);
      minY = Math.min(minY, point.y);
      maxX = Math.max(maxX, point.x);
      maxY = Math.max(maxY, point.y);
    }
  }
}
function createSvgObjects3({ elm, ctx }) {
  const { transform } = ctx;
  switch (elm.type) {
    case "pcb_board":
      return createSvgObjectsFromPcbBoard(elm, ctx);
    case "pcb_solder_paste":
      return createSvgObjectsFromSolderPaste(elm, ctx);
    default:
      return [];
  }
}
function createSvgObjectFromPcbBoundary2(transform, minX, minY, maxX, maxY) {
  const [x1, y1] = applyToPoint46(transform, [minX, minY]);
  const [x2, y2] = applyToPoint46(transform, [maxX, maxY]);
  const width = Math.abs(x2 - x1);
  const height = Math.abs(y2 - y1);
  const x = Math.min(x1, x2);
  const y = Math.min(y1, y2);
  return {
    name: "rect",
    type: "element",
    value: "",
    children: [],
    attributes: {
      class: "pcb-boundary",
      fill: "none",
      stroke: "#fff",
      "stroke-width": "0.3",
      x: x.toString(),
      y: y.toString(),
      width: width.toString(),
      height: height.toString()
    }
  };
}
export {
  CIRCUIT_TO_SVG_VERSION,
  circuitJsonToPcbSvg,
  circuitJsonToSchematicSvg,
  convertCircuitJsonToAssemblySvg,
  convertCircuitJsonToPcbSvg,
  convertCircuitJsonToSchematicSvg,
  convertCircuitJsonToSolderPasteMask,
  createSvgObjectsForSchComponentPortHovers,
  getSoftwareUsedString
};
//# sourceMappingURL=index.js.map