{"version":3,"sources":["../lib/pcb/convert-circuit-json-to-pcb-svg.ts","../lib/pcb/svg-object-fns/create-svg-objects-from-pcb-trace-error.ts","../lib/pcb/svg-object-fns/create-svg-objects-from-pcb-fabrication-note-path.ts","../lib/pcb/svg-object-fns/create-svg-objects-from-pcb-fabrication-note-text.ts","../lib/pcb/svg-object-fns/create-svg-objects-from-pcb-plated-hole.ts","../lib/pcb/svg-object-fns/create-svg-objects-from-pcb-silkscreen-path.ts","../lib/pcb/svg-object-fns/create-svg-objects-from-pcb-silkscreen-text.ts","../lib/pcb/svg-object-fns/create-svg-objects-from-pcb-silkscreen-rect.ts","../lib/pcb/svg-object-fns/create-svg-objects-from-pcb-silkscreen-circle.ts","../lib/pcb/svg-object-fns/create-svg-objects-from-pcb-silkscreen-line.ts","../lib/utils/pairs.ts","../lib/pcb/svg-object-fns/create-svg-objects-from-pcb-trace.ts","../lib/pcb/colors.ts","../lib/pcb/layer-name-to-color.ts","../lib/pcb/svg-object-fns/create-svg-objects-from-smt-pads.ts","../lib/pcb/svg-object-fns/create-svg-objects-from-pcb-board.ts","../lib/pcb/svg-object-fns/create-svg-objects-from-pcb-via.ts","../lib/pcb/svg-object-fns/create-svg-objects-from-pcb-hole.ts","../lib/pcb/svg-object-fns/create-svg-objects-from-pcb-rats-nests.ts","../lib/pcb/create-svg-objects-from-pcb-rats-nest/get-element-position.ts","../lib/pcb/create-svg-objects-from-pcb-rats-nest/find-nearest-point-in-nest.ts","../lib/pcb/svg-object-fns/create-svg-objects-from-pcb-cutout.ts","../lib/pcb/svg-object-fns/create-svg-objects-from-pcb-component.ts","../lib/utils/get-software-used-string.ts","../package.json","../lib/package-version.ts","../lib/assembly/convert-circuit-json-to-assembly-svg.ts","../lib/assembly/svg-object-fns/create-svg-objects-from-assembly-board.ts","../lib/assembly/svg-object-fns/create-svg-objects-from-assembly-component.ts","../lib/utils/get-sch-font-size.ts","../lib/assembly/svg-object-fns/create-svg-objects-from-assembly-hole.ts","../lib/assembly/svg-object-fns/create-svg-objects-from-assembly-plated-hole.ts","../lib/assembly/svg-object-fns/create-svg-objects-from-assembly-smt-pad.ts","../lib/utils/colors.ts","../lib/sch/convert-circuit-json-to-schematic-svg.ts","../lib/sch/draw-schematic-grid.ts","../lib/sch/draw-schematic-labeled-points.ts","../lib/sch/arial-text-metrics.ts","../lib/sch/estimate-text-width.ts","../lib/sch/get-table-dimensions.ts","../lib/utils/get-unit-vector-from-outside-to-edge.ts","../lib/utils/net-label-utils.ts","../lib/sch/get-schematic-bounds-from-circuit-json.ts","../lib/sch/svg-object-fns/create-svg-objects-from-sch-component-with-symbol.ts","../lib/utils/get-sch-stroke-size.ts","../lib/utils/match-sch-ports-with-symbol-ports.ts","../lib/utils/point-pairs-to-matrix.ts","../lib/sch/svg-object-fns/create-svg-error-text.ts","../lib/utils/is-source-port-connected.ts","../lib/sch/svg-object-fns/create-svg-objects-from-sch-component-with-box.ts","../lib/sch/svg-object-fns/create-svg-objects-from-sch-port-on-box.ts","../lib/sch/svg-object-fns/create-svg-objects-for-sch-port-box-line.ts","../lib/sch/svg-object-fns/create-svg-objects-for-sch-port-pin-number-text.ts","../lib/sch/svg-object-fns/create-svg-objects-for-sch-port-pin-label.ts","../lib/sch/svg-object-fns/create-svg-objects-for-sch-text.ts","../lib/sch/svg-object-fns/create-svg-objects-from-sch-component.ts","../lib/sch/svg-object-fns/create-svg-objects-from-sch-voltage-probe.ts","../lib/sch/svg-object-fns/create-svg-objects-from-sch-debug-object.ts","../lib/sch/svg-object-fns/create-svg-objects-from-sch-trace.ts","../lib/sch/svg-object-fns/create-svg-objects-for-sch-net-label.ts","../lib/sch/svg-object-fns/create-svg-objects-for-sch-net-label-with-symbol.ts","../lib/sch/svg-object-fns/create-svg-objects-from-sch-box.ts","../lib/sch/svg-object-fns/create-svg-objects-from-sch-table.ts","../lib/sch/svg-object-fns/create-svg-objects-for-sch-port-hover.ts","../lib/pcb/convert-circuit-json-to-solder-paste-mask.ts","../lib/pcb/svg-object-fns/convert-circuit-json-to-solder-paste-mask.ts"],"sourcesContent":["import type {\n  Point,\n  AnyCircuitElement,\n  pcb_cutout,\n  PcbCutout,\n  VisibleLayer,\n} from \"circuit-json\"\nimport { type INode as SvgObject, stringify } from \"svgson\"\nimport {\n  type Matrix,\n  applyToPoint,\n  compose,\n  scale,\n  translate,\n} from \"transformation-matrix\"\nimport { createSvgObjectsFromPcbTraceError } from \"./svg-object-fns/create-svg-objects-from-pcb-trace-error\"\nimport { createSvgObjectsFromPcbFabricationNotePath } from \"./svg-object-fns/create-svg-objects-from-pcb-fabrication-note-path\"\nimport { createSvgObjectsFromPcbFabricationNoteText } from \"./svg-object-fns/create-svg-objects-from-pcb-fabrication-note-text\"\nimport { createSvgObjectsFromPcbPlatedHole } from \"./svg-object-fns/create-svg-objects-from-pcb-plated-hole\"\nimport { createSvgObjectsFromPcbSilkscreenPath } from \"./svg-object-fns/create-svg-objects-from-pcb-silkscreen-path\"\nimport { createSvgObjectsFromPcbSilkscreenText } from \"./svg-object-fns/create-svg-objects-from-pcb-silkscreen-text\"\nimport { createSvgObjectsFromPcbSilkscreenRect } from \"./svg-object-fns/create-svg-objects-from-pcb-silkscreen-rect\"\nimport { createSvgObjectsFromPcbSilkscreenCircle } from \"./svg-object-fns/create-svg-objects-from-pcb-silkscreen-circle\"\nimport { createSvgObjectsFromPcbSilkscreenLine } from \"./svg-object-fns/create-svg-objects-from-pcb-silkscreen-line\"\nimport { createSvgObjectsFromPcbTrace } from \"./svg-object-fns/create-svg-objects-from-pcb-trace\"\nimport { createSvgObjectsFromSmtPad } from \"./svg-object-fns/create-svg-objects-from-smt-pads\"\nimport { createSvgObjectsFromPcbBoard } from \"./svg-object-fns/create-svg-objects-from-pcb-board\"\nimport { createSvgObjectsFromPcbVia } from \"./svg-object-fns/create-svg-objects-from-pcb-via\"\nimport { createSvgObjectsFromPcbHole } from \"./svg-object-fns/create-svg-objects-from-pcb-hole\"\nimport { createSvgObjectsForRatsNest } from \"./svg-object-fns/create-svg-objects-from-pcb-rats-nests\"\nimport { createSvgObjectsFromPcbCutout } from \"./svg-object-fns/create-svg-objects-from-pcb-cutout\"\nimport {\n  DEFAULT_PCB_COLOR_MAP,\n  type PcbColorMap,\n  type PcbColorOverrides,\n} from \"./colors\"\nimport { createSvgObjectsFromPcbComponent } from \"./svg-object-fns/create-svg-objects-from-pcb-component\"\nimport { getSoftwareUsedString } from \"../utils/get-software-used-string\"\nimport { CIRCUIT_TO_SVG_VERSION } from \"../package-version\"\n\nconst OBJECT_ORDER: AnyCircuitElement[\"type\"][] = [\n  \"pcb_trace_error\",\n  \"pcb_plated_hole\",\n  \"pcb_fabrication_note_text\",\n  \"pcb_fabrication_note_path\",\n  \"pcb_silkscreen_text\",\n  \"pcb_silkscreen_path\",\n  \"pcb_via\",\n  \"pcb_cutout\",\n  // Draw traces before SMT pads so pads appear on top\n  \"pcb_smtpad\",\n  \"pcb_trace\",\n  \"pcb_component\",\n  \"pcb_board\",\n]\n\ninterface PointObjectNotation {\n  x: number\n  y: number\n}\n\ninterface Options {\n  colorOverrides?: PcbColorOverrides\n  width?: number\n  height?: number\n  shouldDrawErrors?: boolean\n  shouldDrawRatsNest?: boolean\n  layer?: \"top\" | \"bottom\"\n  matchBoardAspectRatio?: boolean\n  backgroundColor?: string\n  drawPaddingOutsideBoard?: boolean\n  includeVersion?: boolean\n}\n\nexport interface PcbContext {\n  transform: Matrix\n  layer?: \"top\" | \"bottom\"\n  shouldDrawErrors?: boolean\n  drawPaddingOutsideBoard?: boolean\n  colorMap: PcbColorMap\n}\n\nexport function convertCircuitJsonToPcbSvg(\n  circuitJson: AnyCircuitElement[],\n  options?: Options,\n): string {\n  const drawPaddingOutsideBoard = options?.drawPaddingOutsideBoard ?? true\n  const layer = options?.layer\n  const colorOverrides = options?.colorOverrides\n\n  const colorMap: PcbColorMap = {\n    copper: {\n      top: colorOverrides?.copper?.top ?? DEFAULT_PCB_COLOR_MAP.copper.top,\n      bottom:\n        colorOverrides?.copper?.bottom ?? DEFAULT_PCB_COLOR_MAP.copper.bottom,\n    },\n    drill: colorOverrides?.drill ?? DEFAULT_PCB_COLOR_MAP.drill,\n    silkscreen: {\n      top:\n        colorOverrides?.silkscreen?.top ?? DEFAULT_PCB_COLOR_MAP.silkscreen.top,\n      bottom:\n        colorOverrides?.silkscreen?.bottom ??\n        DEFAULT_PCB_COLOR_MAP.silkscreen.bottom,\n    },\n    boardOutline:\n      colorOverrides?.boardOutline ?? DEFAULT_PCB_COLOR_MAP.boardOutline,\n    soldermask: {\n      top:\n        colorOverrides?.soldermask?.top ?? DEFAULT_PCB_COLOR_MAP.soldermask.top,\n      bottom:\n        colorOverrides?.soldermask?.bottom ??\n        DEFAULT_PCB_COLOR_MAP.soldermask.bottom,\n    },\n    debugComponent: {\n      fill:\n        colorOverrides?.debugComponent?.fill ??\n        DEFAULT_PCB_COLOR_MAP.debugComponent.fill,\n      stroke:\n        colorOverrides?.debugComponent?.stroke ??\n        DEFAULT_PCB_COLOR_MAP.debugComponent.stroke,\n    },\n  }\n\n  let minX = Number.POSITIVE_INFINITY\n  let minY = Number.POSITIVE_INFINITY\n  let maxX = Number.NEGATIVE_INFINITY\n  let maxY = Number.NEGATIVE_INFINITY\n\n  // Track bounds for pcb_board specifically\n  let boardMinX = Number.POSITIVE_INFINITY\n  let boardMinY = Number.POSITIVE_INFINITY\n  let boardMaxX = Number.NEGATIVE_INFINITY\n  let boardMaxY = Number.NEGATIVE_INFINITY\n\n  // Process all elements to determine bounds\n  for (const circuitJsonElm of circuitJson) {\n    if (circuitJsonElm.type === \"pcb_board\") {\n      if (\n        circuitJsonElm.outline &&\n        Array.isArray(circuitJsonElm.outline) &&\n        circuitJsonElm.outline.length >= 3\n      ) {\n        updateBoundsToIncludeOutline(circuitJsonElm.outline)\n        updateBoardBoundsToIncludeOutline(circuitJsonElm.outline)\n      } else if (\n        \"center\" in circuitJsonElm &&\n        \"width\" in circuitJsonElm &&\n        \"height\" in circuitJsonElm\n      ) {\n        updateBounds(\n          circuitJsonElm.center,\n          circuitJsonElm.width,\n          circuitJsonElm.height,\n        )\n        updateBoardBounds(\n          circuitJsonElm.center,\n          circuitJsonElm.width,\n          circuitJsonElm.height,\n        )\n      }\n    } else if (\"x\" in circuitJsonElm && \"y\" in circuitJsonElm) {\n      updateBounds({ x: circuitJsonElm.x, y: circuitJsonElm.y }, 0, 0)\n    } else if (circuitJsonElm.type === \"pcb_smtpad\") {\n      const pad = circuitJsonElm as any\n      if (\n        pad.shape === \"rect\" ||\n        pad.shape === \"rotated_rect\" ||\n        pad.shape === \"pill\"\n      ) {\n        updateBounds({ x: pad.x, y: pad.y }, pad.width, pad.height)\n      } else if (pad.shape === \"circle\") {\n        updateBounds({ x: pad.x, y: pad.y }, pad.radius * 2, pad.radius * 2)\n      } else if (pad.shape === \"polygon\") {\n        updateTraceBounds(pad.points)\n      }\n    } else if (\"route\" in circuitJsonElm) {\n      updateTraceBounds(circuitJsonElm.route)\n    } else if (\n      circuitJsonElm.type === \"pcb_silkscreen_text\" ||\n      circuitJsonElm.type === \"pcb_silkscreen_rect\" ||\n      circuitJsonElm.type === \"pcb_silkscreen_circle\" ||\n      circuitJsonElm.type === \"pcb_silkscreen_line\"\n    ) {\n      updateSilkscreenBounds(circuitJsonElm)\n    }\n  }\n\n  const padding = drawPaddingOutsideBoard ? 1 : 0\n  const boundsMinX =\n    drawPaddingOutsideBoard || !isFinite(boardMinX) ? minX : boardMinX\n  const boundsMinY =\n    drawPaddingOutsideBoard || !isFinite(boardMinY) ? minY : boardMinY\n  const boundsMaxX =\n    drawPaddingOutsideBoard || !isFinite(boardMaxX) ? maxX : boardMaxX\n  const boundsMaxY =\n    drawPaddingOutsideBoard || !isFinite(boardMaxY) ? maxY : boardMaxY\n\n  const circuitWidth = boundsMaxX - boundsMinX + 2 * padding\n  const circuitHeight = boundsMaxY - boundsMinY + 2 * padding\n\n  let svgWidth = options?.width ?? 800\n  let svgHeight = options?.height ?? 600\n\n  if (options?.matchBoardAspectRatio) {\n    const boardWidth = boardMaxX - boardMinX\n    const boardHeight = boardMaxY - boardMinY\n    if (boardWidth > 0 && boardHeight > 0) {\n      const aspect = boardWidth / boardHeight\n      if (options?.width && !options?.height) {\n        svgHeight = options.width / aspect\n      } else if (options?.height && !options?.width) {\n        svgWidth = options.height * aspect\n      } else {\n        svgHeight = svgWidth / aspect\n      }\n    }\n  }\n  const paths: PointObjectNotation[][] = []\n  for (const circuitJsonElm of circuitJson) {\n    if (\"route\" in circuitJsonElm && circuitJsonElm.route !== undefined) {\n      paths.push(circuitJsonElm.route as PointObjectNotation[])\n    }\n  }\n\n  // Calculate scale factor to fit the circuit within the SVG, maintaining aspect ratio\n  const scaleX = svgWidth / circuitWidth\n  const scaleY = svgHeight / circuitHeight\n  const scaleFactor = Math.min(scaleX, scaleY)\n\n  // Calculate centering offsets\n  const offsetX = (svgWidth - circuitWidth * scaleFactor) / 2\n  const offsetY = (svgHeight - circuitHeight * scaleFactor) / 2\n\n  const transform = compose(\n    translate(\n      offsetX - boundsMinX * scaleFactor + padding * scaleFactor,\n      svgHeight - offsetY + boundsMinY * scaleFactor - padding * scaleFactor,\n    ),\n    scale(scaleFactor, -scaleFactor), // Flip in y-direction\n  )\n\n  const ctx: PcbContext = {\n    transform,\n    layer,\n    shouldDrawErrors: options?.shouldDrawErrors,\n    drawPaddingOutsideBoard,\n    colorMap,\n  }\n\n  function getLayer(elm: AnyCircuitElement): VisibleLayer | undefined {\n    if (elm.type === \"pcb_smtpad\") {\n      return elm.layer === \"top\" || elm.layer === \"bottom\"\n        ? elm.layer\n        : undefined\n    }\n    if (elm.type === \"pcb_trace\") {\n      for (const seg of elm.route ?? []) {\n        const candidate =\n          (\"layer\" in seg && seg.layer) ||\n          (\"from_layer\" in seg && seg.from_layer) ||\n          (\"to_layer\" in seg && seg.to_layer) ||\n          undefined\n\n        if (candidate === \"top\" || candidate === \"bottom\") {\n          return candidate\n        }\n      }\n    }\n    return undefined\n  }\n\n  function isCopper(elm: AnyCircuitElement) {\n    return elm.type === \"pcb_trace\" || elm.type === \"pcb_smtpad\"\n  }\n\n  let svgObjects = circuitJson\n    .sort((a, b) => {\n      const layerA = getLayer(a)\n      const layerB = getLayer(b)\n\n      if (isCopper(a) && isCopper(b) && layerA !== layerB) {\n        if (layerA === \"top\") return 1\n        if (layerB === \"top\") return -1\n        if (layerA === \"bottom\") return -1\n        if (layerB === \"bottom\") return 1\n      }\n\n      return (\n        (OBJECT_ORDER.indexOf(b.type) ?? 9999) -\n        (OBJECT_ORDER.indexOf(a.type) ?? 9999)\n      )\n    })\n    .flatMap((elm) => createSvgObjects({ elm, circuitJson, ctx }))\n\n  let strokeWidth = String(0.05 * scaleFactor)\n\n  for (const element of circuitJson) {\n    if (\"stroke_width\" in element) {\n      strokeWidth = String(scaleFactor * element.stroke_width)\n      break\n    }\n  }\n\n  if (options?.shouldDrawRatsNest) {\n    const ratsNestObjects = createSvgObjectsForRatsNest(circuitJson, ctx)\n    svgObjects = svgObjects.concat(ratsNestObjects)\n  }\n\n  const children: SvgObject[] = [\n    {\n      name: \"style\",\n      type: \"element\",\n      value: \"\",\n      attributes: {},\n      children: [\n        {\n          type: \"text\",\n          value: \"\",\n          name: \"\",\n          attributes: {},\n          children: [],\n        },\n      ],\n    },\n    {\n      name: \"rect\",\n      type: \"element\",\n      value: \"\",\n      attributes: {\n        class: \"boundary\",\n        x: \"0\",\n        y: \"0\",\n        fill: options?.backgroundColor ?? \"#000\",\n        width: svgWidth.toString(),\n        height: svgHeight.toString(),\n      },\n      children: [],\n    },\n  ]\n\n  if (drawPaddingOutsideBoard) {\n    children.push(\n      createSvgObjectFromPcbBoundary(transform, minX, minY, maxX, maxY),\n    )\n  }\n\n  children.push(...svgObjects)\n\n  const softwareUsedString = getSoftwareUsedString(circuitJson)\n  const version = CIRCUIT_TO_SVG_VERSION\n\n  const svgObject: SvgObject = {\n    name: \"svg\",\n    type: \"element\",\n    attributes: {\n      xmlns: \"http://www.w3.org/2000/svg\",\n      width: svgWidth.toString(),\n      height: svgHeight.toString(),\n      ...(softwareUsedString && {\n        \"data-software-used-string\": softwareUsedString,\n      }),\n      ...(options?.includeVersion && {\n        \"data-circuit-to-svg-version\": version,\n      }),\n    },\n    value: \"\",\n    children: children.filter((child): child is SvgObject => child !== null),\n  }\n\n  try {\n    return stringify(svgObject as SvgObject)\n  } catch (error) {\n    console.error(\"Error stringifying SVG object:\", error)\n    throw error\n  }\n\n  function updateBounds(center: any, width: any, height: any) {\n    const halfWidth = width / 2\n    const halfHeight = height / 2\n    minX = Math.min(minX, center.x - halfWidth)\n    minY = Math.min(minY, center.y - halfHeight)\n    maxX = Math.max(maxX, center.x + halfWidth)\n    maxY = Math.max(maxY, center.y + halfHeight)\n  }\n\n  function updateBoardBounds(center: any, width: any, height: any) {\n    const halfWidth = width / 2\n    const halfHeight = height / 2\n    boardMinX = Math.min(boardMinX, center.x - halfWidth)\n    boardMinY = Math.min(boardMinY, center.y - halfHeight)\n    boardMaxX = Math.max(boardMaxX, center.x + halfWidth)\n    boardMaxY = Math.max(boardMaxY, center.y + halfHeight)\n  }\n\n  function updateBoundsToIncludeOutline(outline: Point[]) {\n    for (const point of outline) {\n      minX = Math.min(minX, point.x)\n      minY = Math.min(minY, point.y)\n      maxX = Math.max(maxX, point.x)\n      maxY = Math.max(maxY, point.y)\n    }\n  }\n\n  function updateBoardBoundsToIncludeOutline(outline: Point[]) {\n    for (const point of outline) {\n      boardMinX = Math.min(boardMinX, point.x)\n      boardMinY = Math.min(boardMinY, point.y)\n      boardMaxX = Math.max(boardMaxX, point.x)\n      boardMaxY = Math.max(boardMaxY, point.y)\n    }\n  }\n\n  function updateTraceBounds(route: any[]) {\n    for (const point of route) {\n      minX = Math.min(minX, point.x)\n      minY = Math.min(minY, point.y)\n      maxX = Math.max(maxX, point.x)\n      maxY = Math.max(maxY, point.y)\n    }\n  }\n\n  function updateSilkscreenBounds(item: AnyCircuitElement) {\n    if (item.type === \"pcb_silkscreen_text\") {\n      updateBounds(item.anchor_position, 0, 0)\n    } else if (item.type === \"pcb_silkscreen_path\") {\n      updateTraceBounds(item.route)\n    } else if (item.type === \"pcb_silkscreen_rect\") {\n      updateBounds(item.center, item.width, item.height)\n    } else if (item.type === \"pcb_silkscreen_circle\") {\n      updateBounds(item.center, item.radius * 2, item.radius * 2)\n    } else if (item.type === \"pcb_silkscreen_line\") {\n      updateBounds({ x: item.x1, y: item.y1 }, 0, 0)\n      updateBounds({ x: item.x2, y: item.y2 }, 0, 0)\n    } else if (item.type === \"pcb_cutout\") {\n      const cutout = item as PcbCutout\n      if (cutout.shape === \"rect\") {\n        updateBounds(cutout.center, cutout.width, cutout.height)\n      } else if (cutout.shape === \"circle\") {\n        updateBounds(cutout.center, cutout.radius * 2, cutout.radius * 2)\n      } else if (cutout.shape === \"polygon\") {\n        updateTraceBounds(cutout.points)\n      }\n    }\n  }\n}\n\ninterface CreateSvgObjectsParams {\n  elm: AnyCircuitElement\n  circuitJson: AnyCircuitElement[]\n  ctx: PcbContext\n}\n\nfunction createSvgObjects({\n  elm,\n  circuitJson,\n  ctx,\n}: CreateSvgObjectsParams): SvgObject[] {\n  switch (elm.type) {\n    case \"pcb_trace_error\":\n      return createSvgObjectsFromPcbTraceError(elm, circuitJson, ctx).filter(\n        Boolean,\n      )\n    case \"pcb_component\":\n      return createSvgObjectsFromPcbComponent(elm, ctx).filter(Boolean)\n    case \"pcb_trace\":\n      return createSvgObjectsFromPcbTrace(elm, ctx)\n    case \"pcb_plated_hole\":\n      return createSvgObjectsFromPcbPlatedHole(elm, ctx).filter(Boolean)\n    case \"pcb_hole\":\n      return createSvgObjectsFromPcbHole(elm, ctx)\n    case \"pcb_smtpad\":\n      return createSvgObjectsFromSmtPad(elm, ctx)\n    case \"pcb_silkscreen_text\":\n      return createSvgObjectsFromPcbSilkscreenText(elm, ctx)\n    case \"pcb_silkscreen_rect\":\n      return createSvgObjectsFromPcbSilkscreenRect(elm, ctx)\n    case \"pcb_silkscreen_circle\":\n      return createSvgObjectsFromPcbSilkscreenCircle(elm, ctx)\n    case \"pcb_silkscreen_line\":\n      return createSvgObjectsFromPcbSilkscreenLine(elm, ctx)\n\n    case \"pcb_fabrication_note_path\":\n      return createSvgObjectsFromPcbFabricationNotePath(elm, ctx)\n    case \"pcb_fabrication_note_text\":\n      return createSvgObjectsFromPcbFabricationNoteText(elm, ctx)\n    case \"pcb_silkscreen_path\":\n      return createSvgObjectsFromPcbSilkscreenPath(elm, ctx)\n    case \"pcb_board\":\n      return ctx.drawPaddingOutsideBoard\n        ? createSvgObjectsFromPcbBoard(elm, ctx)\n        : []\n    case \"pcb_via\":\n      return createSvgObjectsFromPcbVia(elm, ctx)\n    case \"pcb_cutout\":\n      return createSvgObjectsFromPcbCutout(elm as any, ctx)\n    default:\n      return []\n  }\n}\n\nfunction createSvgObjectFromPcbBoundary(\n  transform: any,\n  minX: number,\n  minY: number,\n  maxX: number,\n  maxY: number,\n): SvgObject {\n  const [x1, y1] = applyToPoint(transform, [minX, minY])\n  const [x2, y2] = applyToPoint(transform, [maxX, maxY])\n  const width = Math.abs(x2 - x1)\n  const height = Math.abs(y2 - y1)\n  const x = Math.min(x1, x2)\n  const y = Math.min(y1, y2)\n  return {\n    name: \"rect\",\n    type: \"element\",\n    value: \"\",\n    children: [],\n    attributes: {\n      class: \"pcb-boundary\",\n      fill: \"none\",\n      stroke: \"#fff\",\n      \"stroke-width\": \"0.3\",\n      x: x.toString(),\n      y: y.toString(),\n      width: width.toString(),\n      height: height.toString(),\n    },\n  }\n}\n\n/**\n * @deprecated use `convertCircuitJsonToPcbSvg` instead\n */\nexport const circuitJsonToPcbSvg = convertCircuitJsonToPcbSvg\n","import type { PcbTraceError, PcbPort, AnyCircuitElement } from \"circuit-json\"\nimport type { SvgObject } from \"../../../lib/svg-object\"\nimport { applyToPoint } from \"transformation-matrix\"\nimport type { PcbContext } from \"../convert-circuit-json-to-pcb-svg\"\n\nexport function createSvgObjectsFromPcbTraceError(\n  pcbTraceError: PcbTraceError,\n  circuitJson: AnyCircuitElement[],\n  ctx: PcbContext,\n): SvgObject[] {\n  const { transform, shouldDrawErrors } = ctx\n  if (!shouldDrawErrors) return []\n\n  const { pcb_port_ids } = pcbTraceError\n\n  const port1 = circuitJson.find(\n    (el): el is PcbPort =>\n      el.type === \"pcb_port\" && el.pcb_port_id === pcb_port_ids?.[0],\n  )\n  const port2 = circuitJson.find(\n    (el): el is PcbPort =>\n      el.type === \"pcb_port\" && el.pcb_port_id === pcb_port_ids?.[1],\n  )\n\n  if (!port1 || !port2) {\n    const viaIdMatch = pcbTraceError.message?.match(\n      /pcb_via\\[#?(pcb_via_\\d+)\\]/,\n    )\n    const viaId = viaIdMatch?.[1]\n    const via = circuitJson.find(\n      (el) => el.type === \"pcb_via\" && el.pcb_via_id === viaId,\n    ) as { x: number; y: number; type: string } | undefined\n\n    if (via && via.type === \"pcb_via\") {\n      return createSvgObjectsForViaTraceError(pcbTraceError, via, ctx)\n    }\n\n    if (pcbTraceError.center) {\n      const screenCenter = applyToPoint(transform, {\n        x: pcbTraceError.center.x,\n        y: pcbTraceError.center.y,\n      })\n      return [\n        {\n          name: \"rect\",\n          type: \"element\",\n          attributes: {\n            x: (screenCenter.x - 5).toString(),\n            y: (screenCenter.y - 5).toString(),\n            width: \"10\",\n            height: \"10\",\n            fill: \"red\",\n            transform: `rotate(45 ${screenCenter.x} ${screenCenter.y})`,\n          },\n          children: [],\n          value: \"\",\n        },\n        {\n          name: \"text\",\n          type: \"element\",\n          attributes: {\n            x: screenCenter.x.toString(),\n            y: (screenCenter.y - 15).toString(),\n            fill: \"red\",\n            \"font-family\": \"sans-serif\",\n            \"font-size\": \"12\",\n            \"text-anchor\": \"middle\",\n          },\n          children: [\n            {\n              type: \"text\",\n              value: pcbTraceError.message || \"Pcb Trace Error\",\n              name: \"\",\n              attributes: {},\n              children: [],\n            },\n          ],\n          value: \"\",\n        },\n      ]\n    } else return []\n  }\n\n  const screenPort1 = applyToPoint(transform, {\n    x: port1.x,\n    y: port1.y,\n  })\n  const screenPort2 = applyToPoint(transform, {\n    x: port2.x,\n    y: port2.y,\n  })\n\n  const errorCenter = {\n    x: (screenPort1.x + screenPort2.x) / 2,\n    y: (screenPort1.y + screenPort2.y) / 2,\n  }\n\n  if (\n    isNaN(screenPort1.x) ||\n    isNaN(screenPort1.y) ||\n    isNaN(screenPort2.x) ||\n    isNaN(screenPort2.y) ||\n    isNaN(errorCenter.x) ||\n    isNaN(errorCenter.y)\n  ) {\n    return []\n  }\n\n  const svgObjects: SvgObject[] = [\n    {\n      name: \"line\",\n      type: \"element\",\n      attributes: {\n        x1: screenPort1.x.toString(),\n        y1: screenPort1.y.toString(),\n        x2: errorCenter.x.toString(),\n        y2: errorCenter.y.toString(),\n        stroke: \"red\",\n        \"stroke-width\": \"1.5\",\n        \"stroke-dasharray\": \"2,2\",\n      },\n      children: [],\n      value: \"\",\n    },\n    {\n      name: \"line\",\n      type: \"element\",\n      attributes: {\n        x1: errorCenter.x.toString(),\n        y1: errorCenter.y.toString(),\n        x2: screenPort2.x.toString(),\n        y2: screenPort2.y.toString(),\n        stroke: \"red\",\n        \"stroke-width\": \"1.5\",\n        \"stroke-dasharray\": \"2,2\",\n      },\n      children: [],\n      value: \"\",\n    },\n    {\n      name: \"rect\",\n      type: \"element\",\n      attributes: {\n        x: (errorCenter.x - 5).toString(),\n        y: (errorCenter.y - 5).toString(),\n        width: \"10\",\n        height: \"10\",\n        fill: \"red\",\n        transform: `rotate(45 ${errorCenter.x} ${errorCenter.y})`,\n      },\n      children: [],\n      value: \"\",\n    },\n    {\n      name: \"text\",\n      type: \"element\",\n      attributes: {\n        x: errorCenter.x.toString(),\n        y: (errorCenter.y - 15).toString(),\n        fill: \"red\",\n        \"font-family\": \"sans-serif\",\n        \"font-size\": \"12\",\n        \"text-anchor\": \"middle\",\n      },\n      children: [\n        {\n          type: \"text\",\n          value: pcbTraceError.message || \"Pcb Trace Error\",\n          name: \"\",\n          attributes: {},\n          children: [],\n        },\n      ],\n      value: \"\",\n    },\n  ]\n\n  return svgObjects\n}\n\nfunction createSvgObjectsForViaTraceError(\n  pcbTraceError: PcbTraceError,\n  via: { x: number; y: number },\n  ctx: PcbContext,\n): SvgObject[] {\n  const { transform } = ctx\n  if (pcbTraceError.center && via) {\n    const screenCenter = applyToPoint(transform, {\n      x: pcbTraceError.center.x,\n      y: pcbTraceError.center.y,\n    })\n    const screenVia = applyToPoint(transform, {\n      x: via.x,\n      y: via.y,\n    })\n\n    // Vector from center to via\n    const dx = screenVia.x - screenCenter.x\n    const dy = screenVia.y - screenCenter.y\n    const dist = Math.sqrt(dx * dx + dy * dy)\n    const angle = (Math.atan2(dy, dx) * 180) / Math.PI\n    const margin = 10 // px\n    const boxWidth = dist + margin * 2\n    const boxHeight = 20 // px, can be adjusted\n    const midX = (screenCenter.x + screenVia.x) / 2\n    const midY = (screenCenter.y + screenVia.y) / 2\n\n    return [\n      // Rotated bounding box\n      {\n        name: \"rect\",\n        type: \"element\",\n        attributes: {\n          x: (midX - boxWidth / 2).toString(),\n          y: (midY - boxHeight / 2).toString(),\n          width: boxWidth.toString(),\n          height: boxHeight.toString(),\n          fill: \"none\",\n          stroke: \"red\",\n          \"stroke-width\": \"1\",\n          \"stroke-dasharray\": \"3,2\",\n          transform: `rotate(${angle} ${midX} ${midY})`,\n        },\n        children: [],\n        value: \"\",\n      },\n      // Error diamond\n      {\n        name: \"rect\",\n        type: \"element\",\n        attributes: {\n          x: (midX - 5).toString(),\n          y: (midY - 5).toString(),\n          width: \"10\",\n          height: \"10\",\n          fill: \"red\",\n          transform: `rotate(45 ${midX} ${midY})`,\n        },\n        children: [],\n        value: \"\",\n      },\n      // Error label\n      {\n        name: \"text\",\n        type: \"element\",\n        attributes: {\n          x: midX.toString(),\n          y: (midY - boxHeight / 2 - 5).toString(),\n          fill: \"red\",\n          \"font-family\": \"sans-serif\",\n          \"font-size\": \"12\",\n          \"text-anchor\": \"middle\",\n        },\n        children: [\n          {\n            type: \"text\",\n            value: pcbTraceError.message || \"Pcb Trace Error\",\n            name: \"\",\n            attributes: {},\n            children: [],\n          },\n        ],\n        value: \"\",\n      },\n    ]\n  }\n\n  return []\n}\n","import type { PcbSilkscreenPath, PcbFabricationNotePath } from \"circuit-json\"\nimport { applyToPoint } from \"transformation-matrix\"\nimport type { SvgObject } from \"lib/svg-object\"\nimport type { PcbContext } from \"../convert-circuit-json-to-pcb-svg\"\n\nexport function createSvgObjectsFromPcbFabricationNotePath(\n  fabNotePath: PcbFabricationNotePath,\n  ctx: PcbContext,\n): SvgObject[] {\n  const { transform, layer: layerFilter } = ctx\n  if (!fabNotePath.route || !Array.isArray(fabNotePath.route)) return []\n\n  // Close the path if the first and last points are the same\n  const firstPoint = fabNotePath.route[0]\n  const lastPoint = fabNotePath.route[fabNotePath.route.length - 1]\n  const isClosed =\n    firstPoint!.x === lastPoint!.x && firstPoint!.y === lastPoint!.y\n\n  const path =\n    fabNotePath.route\n      .slice(0, isClosed ? -1 : undefined)\n      .map((point: any, index: number) => {\n        const [x, y] = applyToPoint(transform, [point.x, point.y])\n        return index === 0 ? `M ${x} ${y}` : `L ${x} ${y}`\n      })\n      .join(\" \") + (isClosed ? \" Z\" : \"\")\n\n  return [\n    {\n      name: \"path\",\n      type: \"element\",\n      attributes: {\n        class: \"pcb-fabrication-note-path\",\n        stroke: fabNotePath.color || \"rgba(255,255,255,0.5)\",\n        fill: \"none\",\n        d: path,\n        \"stroke-width\": (\n          fabNotePath.stroke_width * Math.abs(transform.a)\n        ).toString(),\n        \"data-pcb-component-id\": fabNotePath.pcb_component_id,\n        \"data-pcb-fabrication-note-path-id\":\n          fabNotePath.pcb_fabrication_note_path_id,\n      },\n      value: \"\",\n      children: [],\n    },\n  ]\n}\n","import type { PcbFabricationNoteText } from \"circuit-json\"\nimport type { INode as SvgObject } from \"svgson\"\nimport { toString as matrixToString } from \"transformation-matrix\"\nimport { applyToPoint, compose, rotate, translate } from \"transformation-matrix\"\nimport type { PcbContext } from \"../convert-circuit-json-to-pcb-svg\"\n\nexport function createSvgObjectsFromPcbFabricationNoteText(\n  pcbFabNoteText: PcbFabricationNoteText,\n  ctx: PcbContext,\n): SvgObject[] {\n  const { transform, layer: layerFilter } = ctx\n  const {\n    anchor_position,\n    anchor_alignment,\n    text,\n    font_size = 1,\n    layer = \"top\",\n    color,\n  } = pcbFabNoteText\n\n  if (layerFilter && layer !== layerFilter) return []\n\n  if (\n    !anchor_position ||\n    typeof anchor_position.x !== \"number\" ||\n    typeof anchor_position.y !== \"number\"\n  ) {\n    console.error(\"Invalid anchor_position:\", anchor_position)\n    return []\n  }\n\n  const [transformedX, transformedY] = applyToPoint(transform, [\n    anchor_position.x,\n    anchor_position.y,\n  ])\n  const transformedFontSize = font_size * Math.abs(transform.a)\n\n  // Remove ${} from text value and handle undefined text\n\n  // Create a composite transformation\n  const textTransform = compose(\n    translate(transformedX, transformedY), // TODO do anchor_alignment\n    rotate(Math.PI / 180), // Convert degrees to radians\n  )\n\n  const svgObject: SvgObject = {\n    name: \"text\",\n    type: \"element\",\n    attributes: {\n      x: \"0\",\n      y: \"0\",\n      \"font-family\": \"Arial, sans-serif\",\n      \"font-size\": transformedFontSize.toString(),\n      \"text-anchor\": \"middle\",\n      \"dominant-baseline\": \"central\",\n      transform: matrixToString(textTransform),\n      class: \"pcb-fabrication-note-text\",\n      fill: color || \"rgba(255,255,255,0.5)\",\n    },\n    children: [\n      {\n        type: \"text\",\n        value: text,\n        name: \"\",\n        attributes: {},\n        children: [],\n      },\n    ],\n    value: \"\",\n  }\n\n  return [svgObject]\n}\n","import type { PCBPlatedHole } from \"circuit-json\"\nimport { applyToPoint } from \"transformation-matrix\"\nimport type { SvgObject } from \"lib/svg-object\"\nimport type { PcbContext } from \"../convert-circuit-json-to-pcb-svg\"\n\nexport function createSvgObjectsFromPcbPlatedHole(\n  hole: PCBPlatedHole,\n  ctx: PcbContext,\n): SvgObject[] {\n  const { transform, colorMap } = ctx\n  const [x, y] = applyToPoint(transform, [hole.x, hole.y])\n\n  if (hole.shape === \"pill\") {\n    const scaledOuterWidth = hole.outer_width * Math.abs(transform.a)\n    const scaledOuterHeight = hole.outer_height * Math.abs(transform.a)\n    const scaledHoleWidth = hole.hole_width * Math.abs(transform.a)\n    const scaledHoleHeight = hole.hole_height * Math.abs(transform.a)\n\n    const outerRadiusX = scaledOuterWidth / 2\n    const outerRadiusY = scaledOuterHeight / 2\n    const innerRadiusX = scaledHoleWidth / 2\n    const innerRadiusY = scaledHoleHeight / 2\n    const straightLength = scaledOuterHeight - scaledOuterWidth\n\n    return [\n      {\n        name: \"g\",\n        type: \"element\",\n        children: [\n          // Outer pill shape\n          {\n            name: \"path\",\n            type: \"element\",\n            attributes: {\n              class: \"pcb-hole-outer\",\n              fill: colorMap.copper.top,\n              d:\n                `M${x - outerRadiusX},${y - straightLength / 2} ` +\n                `v${straightLength} ` +\n                `a${outerRadiusX},${outerRadiusX} 0 0 0 ${scaledOuterWidth},0 ` +\n                `v-${straightLength} ` +\n                `a${outerRadiusX},${outerRadiusX} 0 0 0 -${scaledOuterWidth},0 z`,\n            },\n            value: \"\",\n            children: [],\n          },\n          // Inner pill shape\n          {\n            name: \"path\",\n            type: \"element\",\n            attributes: {\n              class: \"pcb-hole-inner\",\n              fill: colorMap.drill,\n\n              d:\n                `M${x - innerRadiusX},${y - (scaledHoleHeight - scaledHoleWidth) / 2} ` +\n                `v${scaledHoleHeight - scaledHoleWidth} ` +\n                `a${innerRadiusX},${innerRadiusX} 0 0 0 ${scaledHoleWidth},0 ` +\n                `v-${scaledHoleHeight - scaledHoleWidth} ` +\n                `a${innerRadiusX},${innerRadiusX} 0 0 0 -${scaledHoleWidth},0 z`,\n            },\n            value: \"\",\n            children: [],\n          },\n        ],\n        value: \"\",\n        attributes: {},\n      },\n    ]\n  }\n\n  // Fallback to circular hole if not pill-shaped\n  if (hole.shape === \"circle\") {\n    const scaledOuterWidth = hole.outer_diameter * Math.abs(transform.a)\n    const scaledOuterHeight = hole.outer_diameter * Math.abs(transform.a)\n    const scaledHoleWidth = hole.hole_diameter * Math.abs(transform.a)\n    const scaledHoleHeight = hole.hole_diameter * Math.abs(transform.a)\n\n    const outerRadius = Math.min(scaledOuterWidth, scaledOuterHeight) / 2\n    const innerRadius = Math.min(scaledHoleWidth, scaledHoleHeight) / 2\n    return [\n      {\n        name: \"g\",\n        type: \"element\",\n        children: [\n          {\n            name: \"circle\",\n            type: \"element\",\n            attributes: {\n              class: \"pcb-hole-outer\",\n              fill: colorMap.copper.top,\n              cx: x.toString(),\n              cy: y.toString(),\n              r: outerRadius.toString(),\n            },\n            value: \"\",\n            children: [],\n          },\n          {\n            name: \"circle\",\n            type: \"element\",\n            attributes: {\n              class: \"pcb-hole-inner\",\n              fill: colorMap.drill,\n\n              cx: x.toString(),\n              cy: y.toString(),\n              r: innerRadius.toString(),\n            },\n            value: \"\",\n            children: [],\n          },\n        ],\n        value: \"\",\n        attributes: {},\n      },\n    ]\n  }\n\n  // Handle circular hole with rectangular pad (hole is circle, outer pad is rectangle)\n  if (hole.shape === \"circular_hole_with_rect_pad\") {\n    const scaledHoleDiameter = hole.hole_diameter * Math.abs(transform.a)\n    const scaledRectPadWidth = hole.rect_pad_width * Math.abs(transform.a)\n    const scaledRectPadHeight = hole.rect_pad_height * Math.abs(transform.a)\n\n    const holeRadius = scaledHoleDiameter / 2\n\n    return [\n      {\n        name: \"g\",\n        type: \"element\",\n        children: [\n          // Rectangular pad (outer shape)\n          {\n            name: \"rect\",\n            type: \"element\",\n            attributes: {\n              class: \"pcb-hole-outer-pad\",\n              fill: colorMap.copper.top,\n              x: (x - scaledRectPadWidth / 2).toString(),\n              y: (y - scaledRectPadHeight / 2).toString(),\n              width: scaledRectPadWidth.toString(),\n              height: scaledRectPadHeight.toString(),\n            },\n            value: \"\",\n            children: [],\n          },\n          // Circular hole inside the rectangle\n          {\n            name: \"circle\",\n            type: \"element\",\n            attributes: {\n              class: \"pcb-hole-inner\",\n              fill: colorMap.drill,\n              cx: x.toString(),\n              cy: y.toString(),\n              r: holeRadius.toString(),\n            },\n            value: \"\",\n            children: [],\n          },\n        ],\n        value: \"\",\n        attributes: {},\n      },\n    ]\n  }\n  if (hole.shape === \"pill_hole_with_rect_pad\") {\n    const scaledRectPadWidth = hole.rect_pad_width * Math.abs(transform.a)\n    const scaledRectPadHeight = hole.rect_pad_height * Math.abs(transform.a)\n\n    const scaledHoleHeight = hole.hole_height * Math.abs(transform.a)\n    const scaledHoleWidth = hole.hole_width * Math.abs(transform.a)\n\n    // Use the minimum of scaledHoleHeight and scaledHoleWidth for the radius\n    const holeRadius = Math.min(scaledHoleHeight, scaledHoleWidth) / 2\n\n    return [\n      {\n        name: \"g\",\n        type: \"element\",\n        children: [\n          // Rectangular pad (outer shape)\n          {\n            name: \"rect\",\n            type: \"element\",\n            attributes: {\n              class: \"pcb-hole-outer-pad\",\n              fill: colorMap.copper.top,\n              x: (x - scaledRectPadWidth / 2).toString(),\n              y: (y - scaledRectPadHeight / 2).toString(),\n              width: scaledRectPadWidth.toString(),\n              height: scaledRectPadHeight.toString(),\n            },\n            value: \"\",\n            children: [],\n          },\n          // pill hole inside the rectangle\n          {\n            name: \"rect\",\n            type: \"element\",\n            attributes: {\n              class: \"pcb-hole-inner\",\n              fill: colorMap.drill,\n              x: (x - scaledHoleWidth / 2).toString(),\n              y: (y - scaledHoleHeight / 2).toString(),\n              width: scaledHoleWidth.toString(),\n              height: scaledHoleHeight.toString(),\n              rx: holeRadius.toString(),\n              ry: holeRadius.toString(),\n            },\n            value: \"\",\n            children: [],\n          },\n        ],\n        value: \"\",\n        attributes: {},\n      },\n    ]\n  }\n\n  return []\n}\n","import type { PcbSilkscreenPath } from \"circuit-json\"\nimport { applyToPoint } from \"transformation-matrix\"\nimport type { SvgObject } from \"lib/svg-object\"\n\nimport type { PcbContext } from \"../convert-circuit-json-to-pcb-svg\"\n\nexport function createSvgObjectsFromPcbSilkscreenPath(\n  silkscreenPath: PcbSilkscreenPath,\n  ctx: PcbContext,\n): SvgObject[] {\n  const { transform, layer: layerFilter, colorMap } = ctx\n  if (!silkscreenPath.route || !Array.isArray(silkscreenPath.route)) return []\n\n  let path = silkscreenPath.route\n    .map((point: any, index: number) => {\n      const [x, y] = applyToPoint(transform, [point.x, point.y])\n      return index === 0 ? `M ${x} ${y}` : `L ${x} ${y}`\n    })\n    .join(\" \")\n\n  // Close the path if the first and last points match\n  const firstPoint = silkscreenPath.route[0]\n  const lastPoint = silkscreenPath.route[silkscreenPath.route.length - 1]\n  if (\n    firstPoint &&\n    lastPoint &&\n    firstPoint.x === lastPoint.x &&\n    firstPoint.y === lastPoint.y\n  ) {\n    path += \" Z\"\n  }\n\n  const layer = silkscreenPath.layer || \"top\"\n  if (layerFilter && layer !== layerFilter) return []\n  const color =\n    layer === \"bottom\" ? colorMap.silkscreen.bottom : colorMap.silkscreen.top\n\n  return [\n    {\n      name: \"path\",\n      type: \"element\",\n      attributes: {\n        class: `pcb-silkscreen pcb-silkscreen-${layer}`,\n        d: path,\n        fill: \"none\",\n        stroke: color,\n        \"stroke-width\": (\n          silkscreenPath.stroke_width * Math.abs(transform.a)\n        ).toString(),\n        \"stroke-linecap\": \"round\",\n        \"stroke-linejoin\": \"round\",\n        \"data-pcb-component-id\": silkscreenPath.pcb_component_id,\n        \"data-pcb-silkscreen-path-id\": silkscreenPath.pcb_silkscreen_path_id,\n      },\n      value: \"\",\n      children: [],\n    },\n  ]\n}\n","import type { PcbSilkscreenText } from \"circuit-json\"\nimport type { INode as SvgObject } from \"svgson\"\nimport {\n  applyToPoint,\n  compose,\n  rotate,\n  translate,\n  scale,\n  toString as matrixToString,\n} from \"transformation-matrix\"\nimport type { PcbContext } from \"../convert-circuit-json-to-pcb-svg\"\nexport function createSvgObjectsFromPcbSilkscreenText(\n  pcbSilkscreenText: PcbSilkscreenText,\n  ctx: PcbContext,\n): SvgObject[] {\n  const { transform, layer: layerFilter, colorMap } = ctx\n  const {\n    anchor_position,\n    text,\n    font_size = 1,\n    layer = \"top\",\n    ccw_rotation = 0,\n    anchor_alignment = \"center\",\n  } = pcbSilkscreenText\n\n  if (layerFilter && layer !== layerFilter) return []\n\n  if (\n    !anchor_position ||\n    typeof anchor_position.x !== \"number\" ||\n    typeof anchor_position.y !== \"number\"\n  ) {\n    console.error(\"Invalid anchor_position:\", anchor_position)\n    return []\n  }\n\n  const [transformedX, transformedY] = applyToPoint(transform, [\n    anchor_position.x,\n    anchor_position.y,\n  ])\n\n  const transformedFontSize = font_size * Math.abs(transform.a)\n\n  // Set text-anchor and dominant-baseline based on alignment\n  let textAnchor: string = \"middle\"\n  let dominantBaseline: string = \"central\"\n  let dx = 0\n  let dy = 0\n\n  switch (anchor_alignment) {\n    case \"top_left\":\n      textAnchor = \"start\"\n      dominantBaseline = \"text-before-edge\"\n      break\n    case \"top_center\":\n      textAnchor = \"middle\"\n      dominantBaseline = \"text-before-edge\"\n      break\n    case \"top_right\":\n      textAnchor = \"end\"\n      dominantBaseline = \"text-before-edge\"\n      break\n    case \"center_left\":\n      textAnchor = \"start\"\n      dominantBaseline = \"central\"\n      break\n    case \"center_right\":\n      textAnchor = \"end\"\n      dominantBaseline = \"central\"\n      break\n    case \"bottom_left\":\n      textAnchor = \"start\"\n      dominantBaseline = \"text-after-edge\"\n      break\n    case \"bottom_center\":\n      textAnchor = \"middle\"\n      dominantBaseline = \"text-after-edge\"\n      break\n    case \"bottom_right\":\n      textAnchor = \"end\"\n      dominantBaseline = \"text-after-edge\"\n      break\n    case \"center\":\n    default:\n      textAnchor = \"middle\"\n      dominantBaseline = \"central\"\n      break\n  }\n\n  const textTransform = compose(\n    translate(transformedX, transformedY),\n    rotate((ccw_rotation * Math.PI) / 180),\n    ...(layer === \"bottom\" ? [scale(-1, 1)] : []),\n  )\n\n  const color =\n    layer === \"bottom\" ? colorMap.silkscreen.bottom : colorMap.silkscreen.top\n\n  const lines = text.split(\"\\n\")\n\n  const children: SvgObject[] =\n    lines.length === 1\n      ? [\n          {\n            type: \"text\",\n            value: text,\n            name: \"\",\n            attributes: {},\n            children: [],\n          },\n        ]\n      : lines.map((line, idx) => ({\n          type: \"element\",\n          name: \"tspan\",\n          value: \"\",\n          attributes: {\n            x: \"0\",\n            ...(idx > 0 ? { dy: transformedFontSize.toString() } : {}),\n          },\n          children: [\n            {\n              type: \"text\",\n              value: line,\n              name: \"\",\n              attributes: {},\n              children: [],\n            },\n          ],\n        }))\n\n  const svgObject: SvgObject = {\n    name: \"text\",\n    type: \"element\",\n    attributes: {\n      x: \"0\",\n      y: \"0\",\n      dx: dx.toString(),\n      dy: dy.toString(),\n      fill: color,\n      \"font-family\": \"Arial, sans-serif\",\n      \"font-size\": transformedFontSize.toString(),\n      \"text-anchor\": textAnchor,\n      \"dominant-baseline\": dominantBaseline,\n      transform: matrixToString(textTransform),\n      class: `pcb-silkscreen-text pcb-silkscreen-${layer}`,\n      \"data-pcb-silkscreen-text-id\": pcbSilkscreenText.pcb_component_id,\n      stroke: \"none\",\n    },\n    children,\n    value: \"\",\n  }\n\n  return [svgObject]\n}\n","import type { PcbSilkscreenRect } from \"circuit-json\"\nimport type { INode as SvgObject } from \"svgson\"\nimport { applyToPoint, toString as matrixToString } from \"transformation-matrix\"\nimport type { PcbContext } from \"../convert-circuit-json-to-pcb-svg\"\n\nexport function createSvgObjectsFromPcbSilkscreenRect(\n  pcbSilkscreenRect: PcbSilkscreenRect,\n  ctx: PcbContext,\n): SvgObject[] {\n  const { transform, layer: layerFilter, colorMap } = ctx\n  const {\n    center,\n    width,\n    height,\n    layer = \"top\",\n    pcb_silkscreen_rect_id,\n    stroke_width,\n    is_filled,\n    has_stroke,\n    is_stroke_dashed,\n  } = pcbSilkscreenRect\n\n  if (layerFilter && layer !== layerFilter) return []\n\n  if (\n    !center ||\n    typeof center.x !== \"number\" ||\n    typeof center.y !== \"number\" ||\n    typeof width !== \"number\" ||\n    typeof height !== \"number\"\n  ) {\n    console.error(\"Invalid rectangle data:\", { center, width, height })\n    return []\n  }\n\n  const [transformedX, transformedY] = applyToPoint(transform, [\n    center.x,\n    center.y,\n  ])\n\n  const transformedWidth = width * Math.abs(transform.a)\n  const transformedHeight = height * Math.abs(transform.d)\n\n  const transformedStrokeWidth = stroke_width * Math.abs(transform.a)\n\n  const color =\n    layer === \"bottom\" ? colorMap.silkscreen.bottom : colorMap.silkscreen.top\n\n  const attributes: { [key: string]: string } = {\n    x: (transformedX - transformedWidth / 2).toString(),\n    y: (transformedY - transformedHeight / 2).toString(),\n    width: transformedWidth.toString(),\n    height: transformedHeight.toString(),\n    class: `pcb-silkscreen-rect pcb-silkscreen-${layer}`,\n    \"data-pcb-silkscreen-rect-id\": pcb_silkscreen_rect_id,\n  }\n\n  attributes.fill = is_filled ? color : \"none\"\n\n  let actualHasStroke: boolean\n  if (has_stroke === undefined) {\n    actualHasStroke = transformedStrokeWidth > 0\n  } else {\n    actualHasStroke = has_stroke\n  }\n\n  if (actualHasStroke) {\n    attributes.stroke = color\n    attributes[\"stroke-width\"] = transformedStrokeWidth.toString()\n    if (is_stroke_dashed) {\n      const dashLength = 0.1 * Math.abs(transform.a) // 0.1mm dash\n      const gapLength = 0.05 * Math.abs(transform.a) // 0.05mm gap\n      attributes[\"stroke-dasharray\"] = `${dashLength} ${gapLength}`\n    }\n  } else {\n    attributes.stroke = \"none\"\n  }\n\n  const svgObject: SvgObject = {\n    name: \"rect\",\n    type: \"element\",\n    attributes,\n    value: \"\",\n    children: [],\n  }\n\n  return [svgObject]\n}\n","import type { PcbSilkscreenCircle } from \"circuit-json\"\nimport type { INode as SvgObject } from \"svgson\"\nimport { applyToPoint, toString as matrixToString } from \"transformation-matrix\"\nimport type { PcbContext } from \"../convert-circuit-json-to-pcb-svg\"\n\nexport function createSvgObjectsFromPcbSilkscreenCircle(\n  pcbSilkscreenCircle: PcbSilkscreenCircle,\n  ctx: PcbContext,\n): SvgObject[] {\n  const { transform, layer: layerFilter, colorMap } = ctx\n  const {\n    center,\n    radius,\n    layer = \"top\",\n    pcb_silkscreen_circle_id,\n    stroke_width = 1,\n  } = pcbSilkscreenCircle\n\n  if (layerFilter && layer !== layerFilter) return []\n\n  if (\n    !center ||\n    typeof center.x !== \"number\" ||\n    typeof center.y !== \"number\" ||\n    typeof radius !== \"number\"\n  ) {\n    console.error(\"Invalid PCB Silkscreen Circle data:\", { center, radius })\n    return []\n  }\n\n  const [transformedX, transformedY] = applyToPoint(transform, [\n    center.x,\n    center.y,\n  ])\n\n  const transformedRadius = radius * Math.abs(transform.a)\n\n  const transformedStrokeWidth = stroke_width * Math.abs(transform.a)\n\n  const color =\n    layer === \"bottom\" ? colorMap.silkscreen.bottom : colorMap.silkscreen.top\n\n  const svgObject: SvgObject = {\n    name: \"circle\",\n    type: \"element\",\n    attributes: {\n      cx: transformedX.toString(),\n      cy: transformedY.toString(),\n      r: transformedRadius.toString(),\n      class: `pcb-silkscreen-circle pcb-silkscreen-${layer}`,\n      stroke: color,\n      \"stroke-width\": transformedStrokeWidth.toString(),\n      \"data-pcb-silkscreen-circle-id\": pcb_silkscreen_circle_id,\n    },\n    value: \"\",\n    children: [],\n  }\n\n  return [svgObject]\n}\n","import type { PcbSilkscreenLine } from \"circuit-json\"\nimport type { INode as SvgObject } from \"svgson\"\nimport { applyToPoint, toString as matrixToString } from \"transformation-matrix\"\nimport type { PcbContext } from \"../convert-circuit-json-to-pcb-svg\"\n\nexport function createSvgObjectsFromPcbSilkscreenLine(\n  pcbSilkscreenLine: PcbSilkscreenLine,\n  ctx: PcbContext,\n): SvgObject[] {\n  const { transform, layer: layerFilter, colorMap } = ctx\n  const {\n    x1,\n    y1,\n    x2,\n    y2,\n    stroke_width,\n    layer = \"top\",\n    pcb_silkscreen_line_id,\n  } = pcbSilkscreenLine\n\n  if (layerFilter && layer !== layerFilter) return []\n\n  if (\n    typeof x1 !== \"number\" ||\n    typeof y1 !== \"number\" ||\n    typeof x2 !== \"number\" ||\n    typeof y2 !== \"number\"\n  ) {\n    console.error(\"Invalid coordinates:\", { x1, y1, x2, y2 })\n    return []\n  }\n\n  const [transformedX1, transformedY1] = applyToPoint(transform, [x1, y1])\n  const [transformedX2, transformedY2] = applyToPoint(transform, [x2, y2])\n\n  const transformedStrokeWidth = stroke_width * Math.abs(transform.a)\n\n  const color =\n    layer === \"bottom\" ? colorMap.silkscreen.bottom : colorMap.silkscreen.top\n\n  return [\n    {\n      name: \"line\",\n      type: \"element\",\n      attributes: {\n        x1: transformedX1.toString(),\n        y1: transformedY1.toString(),\n        x2: transformedX2.toString(),\n        y2: transformedY2.toString(),\n        stroke: color,\n        \"stroke-width\": transformedStrokeWidth.toString(),\n        class: `pcb-silkscreen-line pcb-silkscreen-${layer}`,\n        \"data-pcb-silkscreen-line-id\": pcb_silkscreen_line_id,\n      },\n      value: \"\",\n      children: [],\n    },\n  ]\n}\n","/**\n * Return pairs of adjacent elements in an array.\n */\nexport function pairs<T>(arr: Array<T>): Array<[T, T]> {\n  const result: Array<[T, T]> = []\n  for (let i = 0; i < arr.length - 1; i++) {\n    result.push([arr[i]!, arr[i + 1]!])\n  }\n  return result\n}\n","import type { PCBTrace } from \"circuit-json\"\nimport { pairs } from \"lib/utils/pairs\"\nimport type { INode as SvgObject } from \"svgson\"\nimport { applyToPoint } from \"transformation-matrix\"\nimport { layerNameToColor } from \"../layer-name-to-color\"\nimport type { PcbContext } from \"../convert-circuit-json-to-pcb-svg\"\n\nexport function createSvgObjectsFromPcbTrace(\n  trace: PCBTrace,\n  ctx: PcbContext,\n): SvgObject[] {\n  const { transform, layer: layerFilter, colorMap } = ctx\n  if (!trace.route || !Array.isArray(trace.route) || trace.route.length < 2)\n    return []\n\n  const segments = pairs(trace.route)\n  const svgObjects: SvgObject[] = []\n\n  for (const [start, end] of segments) {\n    const startPoint = applyToPoint(transform, [start.x, start.y])\n    const endPoint = applyToPoint(transform, [end.x, end.y])\n\n    const layer =\n      \"layer\" in start ? start.layer : \"layer\" in end ? end.layer : null\n    if (!layer) continue\n    if (layerFilter && layer !== layerFilter) continue\n\n    const layerColor =\n      colorMap.soldermask[layer as keyof typeof colorMap.soldermask] ??\n      layerNameToColor(layer, colorMap)\n\n    const traceWidth =\n      \"width\" in start ? start.width : \"width\" in end ? end.width : null\n\n    const svgObject: SvgObject = {\n      name: \"path\",\n      type: \"element\",\n      value: \"\",\n      children: [],\n      attributes: {\n        class: \"pcb-trace\",\n        stroke: layerColor,\n        fill: \"none\",\n        d: `M ${startPoint[0]} ${startPoint[1]} L ${endPoint[0]} ${endPoint[1]}`,\n        \"stroke-width\": traceWidth\n          ? (traceWidth * Math.abs(transform.a)).toString()\n          : \"0.3\",\n        \"stroke-linecap\": \"round\",\n        \"stroke-linejoin\": \"round\",\n        \"shape-rendering\": \"crispEdges\",\n        \"data-layer\": layer,\n      },\n    }\n\n    svgObjects.push(svgObject)\n  }\n\n  svgObjects.sort((a, b) => {\n    const layerA = a.attributes[\"data-layer\"]\n    const layerB = b.attributes[\"data-layer\"]\n\n    if (layerA === \"bottom\" && layerB !== \"bottom\") {\n      return -1\n    }\n    if (layerA === \"top\" && layerB !== \"top\") {\n      return 1\n    }\n    return 0\n  })\n\n  return svgObjects\n}\n","export interface PcbColorMap {\n  copper: {\n    top: string\n    bottom: string\n  }\n  drill: string\n  silkscreen: {\n    top: string\n    bottom: string\n  }\n  boardOutline: string\n  soldermask: {\n    top: string\n    bottom: string\n  }\n  debugComponent: {\n    fill: string | null\n    stroke: string | null\n  }\n}\n\nexport interface PcbColorOverrides {\n  copper?: Partial<PcbColorMap[\"copper\"]>\n  drill?: string\n  silkscreen?: Partial<PcbColorMap[\"silkscreen\"]>\n  boardOutline?: string\n  soldermask?: Partial<PcbColorMap[\"soldermask\"]>\n  debugComponent?: Partial<PcbColorMap[\"debugComponent\"]>\n}\n\nexport const DEFAULT_PCB_COLOR_MAP: PcbColorMap = {\n  copper: {\n    top: \"rgb(200, 52, 52)\",\n    bottom: \"rgb(77, 127, 196)\",\n  },\n  soldermask: {\n    top: \"rgb(200, 52, 52)\",\n    bottom: \"rgb(77, 127, 196)\",\n  },\n  drill: \"#FF26E2\",\n  silkscreen: {\n    top: \"#f2eda1\",\n    bottom: \"#5da9e9\",\n  },\n  boardOutline: \"rgba(255, 255, 255, 0.5)\",\n  debugComponent: {\n    fill: null,\n    stroke: null,\n  },\n}\n\nexport const HOLE_COLOR = DEFAULT_PCB_COLOR_MAP.drill\nexport const SILKSCREEN_TOP_COLOR = DEFAULT_PCB_COLOR_MAP.silkscreen.top\nexport const SILKSCREEN_BOTTOM_COLOR = DEFAULT_PCB_COLOR_MAP.silkscreen.bottom // Blue color for bottom silkscreen\n","/**\n * TODO use @tscircuit/pcb-colors when it's published\n */\nimport type { PcbColorMap } from \"./colors\"\nimport { DEFAULT_PCB_COLOR_MAP } from \"./colors\"\n\nexport const LAYER_NAME_TO_COLOR = {\n  top: DEFAULT_PCB_COLOR_MAP.copper.top,\n  bottom: DEFAULT_PCB_COLOR_MAP.copper.bottom,\n}\n\nexport function layerNameToColor(\n  layerName: string,\n  colorMap: PcbColorMap = DEFAULT_PCB_COLOR_MAP,\n) {\n  return colorMap.copper[layerName as keyof typeof colorMap.copper] ?? \"white\"\n}\n\nexport const SOLDER_PASTE_LAYER_NAME_TO_COLOR = {\n  bottom: \"rgb(105, 105, 105)\",\n  top: \"rgb(105, 105, 105)\",\n}\n\nexport function solderPasteLayerNameToColor(layerName: string) {\n  return (\n    SOLDER_PASTE_LAYER_NAME_TO_COLOR[\n      layerName as keyof typeof SOLDER_PASTE_LAYER_NAME_TO_COLOR\n    ] ?? \"rgb(105, 105, 105)\"\n  )\n}\n","import type { PcbSmtPad } from \"circuit-json\"\nimport { applyToPoint } from \"transformation-matrix\"\nimport { layerNameToColor } from \"../layer-name-to-color\"\nimport type { PcbContext } from \"../convert-circuit-json-to-pcb-svg\"\n\nexport function createSvgObjectsFromSmtPad(\n  pad: PcbSmtPad,\n  ctx: PcbContext,\n): any {\n  const { transform, layer: layerFilter, colorMap } = ctx\n\n  if (layerFilter && pad.layer !== layerFilter) return []\n\n  if (pad.shape === \"rect\" || pad.shape === \"rotated_rect\") {\n    const width = pad.width * Math.abs(transform.a)\n    const height = pad.height * Math.abs(transform.d)\n    const [x, y] = applyToPoint(transform, [pad.x, pad.y])\n\n    if (pad.shape === \"rotated_rect\" && pad.ccw_rotation) {\n      return [\n        {\n          name: \"rect\",\n          type: \"element\",\n          attributes: {\n            class: \"pcb-pad\",\n            fill: layerNameToColor(pad.layer, colorMap),\n            x: (-width / 2).toString(),\n            y: (-height / 2).toString(),\n            width: width.toString(),\n            height: height.toString(),\n            transform: `translate(${x} ${y}) rotate(${-pad.ccw_rotation})`,\n            \"data-layer\": pad.layer,\n          },\n        },\n      ]\n    }\n\n    return [\n      {\n        name: \"rect\",\n        type: \"element\",\n        attributes: {\n          class: \"pcb-pad\",\n          fill: layerNameToColor(pad.layer, colorMap),\n          x: (x - width / 2).toString(),\n          y: (y - height / 2).toString(),\n          width: width.toString(),\n          height: height.toString(),\n          \"data-layer\": pad.layer,\n        },\n      },\n    ]\n  }\n\n  if (pad.shape === \"pill\") {\n    const width = pad.width * Math.abs(transform.a)\n    const height = pad.height * Math.abs(transform.d)\n    const radius = pad.radius * Math.abs(transform.a)\n    const [x, y] = applyToPoint(transform, [pad.x, pad.y])\n\n    return [\n      {\n        name: \"rect\",\n        type: \"element\",\n        attributes: {\n          class: \"pcb-pad\",\n          fill: layerNameToColor(pad.layer, colorMap),\n          x: (x - width / 2).toString(),\n          y: (y - height / 2).toString(),\n          width: width.toString(),\n          height: height.toString(),\n          rx: radius.toString(),\n          ry: radius.toString(),\n          \"data-layer\": pad.layer,\n        },\n      },\n    ]\n  }\n  if (pad.shape === \"circle\") {\n    const radius = pad.radius * Math.abs(transform.a)\n    const [x, y] = applyToPoint(transform, [pad.x, pad.y])\n\n    return [\n      {\n        name: \"circle\",\n        type: \"element\",\n        attributes: {\n          class: \"pcb-pad\",\n          fill: layerNameToColor(pad.layer, colorMap),\n          cx: x.toString(),\n          cy: y.toString(),\n          r: radius.toString(),\n          \"data-layer\": pad.layer,\n        },\n      },\n    ]\n  }\n\n  if (pad.shape === \"polygon\") {\n    const points = (pad.points ?? []).map((point) =>\n      applyToPoint(transform, [point.x, point.y]),\n    )\n\n    return [\n      {\n        name: \"polygon\",\n        type: \"element\",\n        attributes: {\n          class: \"pcb-pad\",\n          fill: layerNameToColor(pad.layer),\n          points: points.map((p) => p.join(\",\")).join(\" \"),\n          \"data-layer\": pad.layer,\n        },\n      },\n    ]\n  }\n\n  // TODO: Implement SMT pad circles/ovals etc.\n  return []\n}\n","import type { PCBBoard, Point } from \"circuit-json\"\nimport { applyToPoint } from \"transformation-matrix\"\nimport type { SvgObject } from \"lib/svg-object\"\nimport type { PcbContext } from \"../convert-circuit-json-to-pcb-svg\"\n\nexport function createSvgObjectsFromPcbBoard(\n  pcbBoard: PCBBoard,\n  ctx: PcbContext,\n): SvgObject[] {\n  const { transform, colorMap } = ctx\n  const { width, height, center, outline } = pcbBoard\n\n  let path: string\n  if (outline && Array.isArray(outline) && outline.length >= 3) {\n    path = outline\n      .map((point: Point, index: number) => {\n        const [x, y] = applyToPoint(transform, [point.x, point.y])\n        return index === 0 ? `M ${x} ${y}` : `L ${x} ${y}`\n      })\n      .join(\" \")\n  } else {\n    const halfWidth = width / 2\n    const halfHeight = height / 2\n\n    const topLeft = applyToPoint(transform, [\n      center.x - halfWidth,\n      center.y - halfHeight,\n    ])\n    const topRight = applyToPoint(transform, [\n      center.x + halfWidth,\n      center.y - halfHeight,\n    ])\n    const bottomRight = applyToPoint(transform, [\n      center.x + halfWidth,\n      center.y + halfHeight,\n    ])\n    const bottomLeft = applyToPoint(transform, [\n      center.x - halfWidth,\n      center.y + halfHeight,\n    ])\n\n    path =\n      `M ${topLeft[0]} ${topLeft[1]} ` +\n      `L ${topRight[0]} ${topRight[1]} ` +\n      `L ${bottomRight[0]} ${bottomRight[1]} ` +\n      `L ${bottomLeft[0]} ${bottomLeft[1]}`\n  }\n\n  path += \" Z\"\n\n  return [\n    {\n      name: \"path\",\n      type: \"element\",\n      value: \"\",\n      children: [],\n      attributes: {\n        class: \"pcb-board\",\n        d: path,\n        fill: \"none\",\n        stroke: colorMap.boardOutline,\n        \"stroke-width\": (0.1 * Math.abs(transform.a)).toString(),\n      },\n    },\n  ]\n}\n","import type { PCBVia } from \"circuit-json\"\nimport { applyToPoint } from \"transformation-matrix\"\nimport type { PcbContext } from \"../convert-circuit-json-to-pcb-svg\"\n\nexport function createSvgObjectsFromPcbVia(hole: PCBVia, ctx: PcbContext): any {\n  const { transform, colorMap } = ctx\n  const [x, y] = applyToPoint(transform, [hole.x, hole.y])\n  const scaledOuterWidth = hole.outer_diameter * Math.abs(transform.a)\n  const scaledOuterHeight = hole.outer_diameter * Math.abs(transform.a)\n  const scaledHoleWidth = hole.hole_diameter * Math.abs(transform.a)\n  const scaledHoleHeight = hole.hole_diameter * Math.abs(transform.a)\n\n  const outerRadius = Math.min(scaledOuterWidth, scaledOuterHeight) / 2\n  const innerRadius = Math.min(scaledHoleWidth, scaledHoleHeight) / 2\n  return {\n    name: \"g\",\n    type: \"element\",\n    children: [\n      {\n        name: \"circle\",\n        type: \"element\",\n        attributes: {\n          class: \"pcb-hole-outer\",\n          fill: colorMap.copper.top,\n          cx: x.toString(),\n          cy: y.toString(),\n          r: outerRadius.toString(),\n        },\n      },\n      {\n        name: \"circle\",\n        type: \"element\",\n        attributes: {\n          class: \"pcb-hole-inner\",\n          fill: colorMap.drill,\n\n          cx: x.toString(),\n          cy: y.toString(),\n          r: innerRadius.toString(),\n        },\n      },\n    ],\n  }\n}\n","import type { PCBHole } from \"circuit-json\"\nimport { applyToPoint } from \"transformation-matrix\"\nimport type { SvgObject } from \"lib/svg-object\"\nimport type { PcbContext } from \"../convert-circuit-json-to-pcb-svg\"\n\nexport function createSvgObjectsFromPcbHole(\n  hole: PCBHole,\n  ctx: PcbContext,\n): SvgObject[] {\n  const { transform, colorMap } = ctx\n  const [x, y] = applyToPoint(transform, [hole.x, hole.y])\n\n  if (hole.hole_shape === \"circle\" || hole.hole_shape === \"square\") {\n    const scaledDiameter = hole.hole_diameter * Math.abs(transform.a)\n    const radius = scaledDiameter / 2\n\n    if (hole.hole_shape === \"circle\") {\n      return [\n        {\n          name: \"circle\",\n          type: \"element\",\n          attributes: {\n            class: \"pcb-hole\",\n            cx: x.toString(),\n            cy: y.toString(),\n            r: radius.toString(),\n            fill: colorMap.drill,\n          },\n          children: [],\n          value: \"\",\n        },\n      ]\n    }\n    // Square hole\n    return [\n      {\n        name: \"rect\",\n        type: \"element\",\n        attributes: {\n          class: \"pcb-hole\",\n          x: (x - radius).toString(),\n          y: (y - radius).toString(),\n          width: scaledDiameter.toString(),\n          height: scaledDiameter.toString(),\n          fill: colorMap.drill,\n        },\n        children: [],\n        value: \"\",\n      },\n    ]\n  }\n  if (hole.hole_shape === \"oval\") {\n    const scaledWidth = hole.hole_width * Math.abs(transform.a)\n    const scaledHeight = hole.hole_height * Math.abs(transform.a)\n    const rx = scaledWidth / 2\n    const ry = scaledHeight / 2\n\n    return [\n      {\n        name: \"ellipse\",\n        type: \"element\",\n        attributes: {\n          class: \"pcb-hole\",\n          cx: x.toString(),\n          cy: y.toString(),\n          rx: rx.toString(),\n          ry: ry.toString(),\n          fill: colorMap.drill,\n        },\n        children: [],\n        value: \"\",\n      },\n    ]\n  }\n\n  return []\n}\n","import {\n  ConnectivityMap,\n  getFullConnectivityMapFromCircuitJson,\n} from \"circuit-json-to-connectivity-map\"\nimport type { AnyCircuitElement } from \"circuit-json\"\nimport { type INode as SvgObject } from \"svgson\"\nimport { applyToPoint } from \"transformation-matrix\"\nimport { findNearestPointInNet } from \"../create-svg-objects-from-pcb-rats-nest/find-nearest-point-in-nest\"\nimport { su } from \"@tscircuit/circuit-json-util\"\nimport type { PcbContext } from \"../convert-circuit-json-to-pcb-svg\"\n\ninterface RatsNestLine {\n  key: string\n  startPoint: { x: number; y: number }\n  endPoint: { x: number; y: number }\n  isInNet: boolean\n}\n\nexport function createSvgObjectsForRatsNest(\n  circuitJson: AnyCircuitElement[],\n  ctx: PcbContext,\n): SvgObject[] {\n  const { transform } = ctx\n  // Compute connectivity using the helper from the imported package.\n  const connectivity: ConnectivityMap =\n    getFullConnectivityMapFromCircuitJson(circuitJson)\n\n  // Filter for ports and traces that are relevant for rats nest.\n  const pcbPorts = circuitJson.filter((elm) => elm.type === \"pcb_port\")\n  const sourceTraces = circuitJson.filter((elm) => elm.type === \"source_trace\")\n\n  const ratsNestLines: RatsNestLine[] = []\n\n  pcbPorts.forEach((port, index) => {\n    const portId = (port as any).pcb_port_id\n    if (!portId) return\n\n    const netId = connectivity.getNetConnectedToId(portId)\n    if (!netId) return\n\n    // Determine whether the port is in net via a connected source trace.\n    let isInNet = false\n    const sourcePort = su(circuitJson).source_port.getWhere({\n      pcb_port_id: portId,\n    })\n    if (sourcePort && (sourcePort as any).source_port_id) {\n      const sourcePortId = (sourcePort as any).source_port_id\n      for (const trace of sourceTraces) {\n        if (\n          Array.isArray((trace as any).connected_source_port_ids) &&\n          (trace as any).connected_source_port_ids.includes(sourcePortId) &&\n          Array.isArray((trace as any).connected_source_net_ids) &&\n          (trace as any).connected_source_net_ids.length > 0\n        ) {\n          isInNet = true\n          break\n        }\n      }\n    }\n\n    const startPoint = { x: (port as any).x, y: (port as any).y }\n\n    // Find the nearest point in the net using ConnectivityMap\n    const nearestPoint = findNearestPointInNet(\n      startPoint,\n      netId,\n      connectivity,\n      circuitJson,\n    )\n\n    if (!nearestPoint) return\n\n    ratsNestLines.push({\n      key: `${portId}-${index}`,\n      startPoint,\n      endPoint: nearestPoint,\n      isInNet,\n    })\n  })\n\n  // Create SVG <line> objects for each rats nest connection.\n  const svgObjects: SvgObject[] = []\n  for (const line of ratsNestLines) {\n    const transformedStart = applyToPoint(transform, [\n      line.startPoint.x,\n      line.startPoint.y,\n    ])\n    const transformedEnd = applyToPoint(transform, [\n      line.endPoint.x,\n      line.endPoint.y,\n    ])\n    const attributes: { [key: string]: string } = {\n      x1: transformedStart[0].toString(),\n      y1: transformedStart[1].toString(),\n      x2: transformedEnd[0].toString(),\n      y2: transformedEnd[1].toString(),\n      stroke: \"white\",\n      \"stroke-width\": \"1\",\n      \"stroke-dasharray\": \"6,6\",\n    }\n\n    svgObjects.push({\n      name: \"line\",\n      type: \"element\",\n      attributes,\n      value: \"\",\n      children: [],\n    })\n  }\n\n  return svgObjects\n}\n","import type { AnyCircuitElement } from \"circuit-json\"\nimport { su } from \"@tscircuit/circuit-json-util\"\n\ninterface Position {\n  x: number\n  y: number\n}\n\nexport const getElementPosition = (\n  id: string,\n  circuitJson: AnyCircuitElement[],\n): Position | null => {\n  // Try to find the element as a pcb_smtpad\n  const pcbSmtpad = su(circuitJson).pcb_smtpad.get(id)\n  if (pcbSmtpad && \"x\" in pcbSmtpad && \"y\" in pcbSmtpad) {\n    return { x: pcbSmtpad.x, y: pcbSmtpad.y }\n  }\n\n  // Try to find the element as a pcb_plated_hole\n  const pcbPlatedHole = su(circuitJson).pcb_plated_hole.get(id)\n  if (pcbPlatedHole && \"x\" in pcbPlatedHole && \"y\" in pcbPlatedHole) {\n    return { x: pcbPlatedHole.x, y: pcbPlatedHole.y }\n  }\n\n  // If neither is found, return null\n  return null\n}\n","import type { AnyCircuitElement } from \"circuit-json\"\nimport { getElementPosition } from \"./get-element-position\"\nimport { ConnectivityMap } from \"circuit-json-to-connectivity-map\"\n\nexport const findNearestPointInNet = (\n  sourcePoint: { x: number; y: number },\n  netId: string,\n  connectivity: ConnectivityMap,\n  circuitJson: AnyCircuitElement[],\n): { x: number; y: number } | null => {\n  const connectedIds = connectivity.getIdsConnectedToNet(netId)\n  let nearestPoint: { x: number; y: number } | null = null\n  let minDistance = Infinity\n\n  for (const id of connectedIds) {\n    const pos = getElementPosition(id, circuitJson)\n    if (pos) {\n      const dx = sourcePoint.x - pos.x\n      const dy = sourcePoint.y - pos.y\n      const distance = Math.sqrt(dx * dx + dy * dy)\n      if (distance > 0 && distance < minDistance) {\n        minDistance = distance\n        nearestPoint = pos\n      }\n    }\n  }\n\n  return nearestPoint\n}\n","import type {\n  PcbCutout,\n  PcbCutoutRect,\n  PcbCutoutCircle,\n  PcbCutoutPolygon,\n  Point,\n} from \"circuit-json\"\nimport type { SvgObject } from \"lib/svg-object\"\nimport {\n  applyToPoint,\n  compose,\n  rotate,\n  translate,\n  toString as matrixToString,\n} from \"transformation-matrix\"\nimport type { PcbContext } from \"../convert-circuit-json-to-pcb-svg\"\n\nexport function createSvgObjectsFromPcbCutout(\n  cutout: PcbCutout,\n  ctx: PcbContext,\n): SvgObject[] {\n  const { transform, colorMap } = ctx\n  if (cutout.shape === \"rect\") {\n    const rectCutout = cutout as PcbCutoutRect\n    const [cx, cy] = applyToPoint(transform, [\n      rectCutout.center.x,\n      rectCutout.center.y,\n    ])\n    const scaledWidth = rectCutout.width * Math.abs(transform.a)\n    const scaledHeight = rectCutout.height * Math.abs(transform.d)\n    const svgRotation = -(rectCutout.rotation ?? 0)\n\n    return [\n      {\n        name: \"rect\",\n        type: \"element\",\n        attributes: {\n          class: \"pcb-cutout pcb-cutout-rect\",\n          x: (-scaledWidth / 2).toString(),\n          y: (-scaledHeight / 2).toString(),\n          width: scaledWidth.toString(),\n          height: scaledHeight.toString(),\n          fill: colorMap.drill,\n          transform: matrixToString(\n            compose(translate(cx, cy), rotate((svgRotation * Math.PI) / 180)),\n          ),\n        },\n        children: [],\n        value: \"\",\n      },\n    ]\n  }\n  if (cutout.shape === \"circle\") {\n    const circleCutout = cutout as PcbCutoutCircle\n    const [cx, cy] = applyToPoint(transform, [\n      circleCutout.center.x,\n      circleCutout.center.y,\n    ])\n    const scaledRadius = circleCutout.radius * Math.abs(transform.a)\n\n    return [\n      {\n        name: \"circle\",\n        type: \"element\",\n        attributes: {\n          class: \"pcb-cutout pcb-cutout-circle\",\n          cx: cx.toString(),\n          cy: cy.toString(),\n          r: scaledRadius.toString(),\n          fill: colorMap.drill,\n        },\n        children: [],\n        value: \"\",\n      },\n    ]\n  }\n  if (cutout.shape === \"polygon\") {\n    const polygonCutout = cutout as PcbCutoutPolygon\n    if (!polygonCutout.points || polygonCutout.points.length === 0) return []\n\n    const transformedPoints = polygonCutout.points.map((p: Point) =>\n      applyToPoint(transform, [p.x, p.y]),\n    )\n    const pointsString = transformedPoints\n      .map((p) => `${p[0]},${p[1]}`)\n      .join(\" \")\n\n    return [\n      {\n        name: \"polygon\",\n        type: \"element\",\n        attributes: {\n          class: \"pcb-cutout pcb-cutout-polygon\",\n          points: pointsString,\n          fill: colorMap.drill,\n        },\n        children: [],\n        value: \"\",\n      },\n    ]\n  }\n\n  return []\n}\n","import { applyToPoint } from \"transformation-matrix\"\nimport type { PcbContext } from \"../convert-circuit-json-to-pcb-svg\"\nimport type { SvgObject } from \"lib/svg-object\"\n\nexport function createSvgObjectsFromPcbComponent(\n  component: any,\n  ctx: PcbContext,\n): SvgObject[] {\n  const { transform } = ctx\n  const { center, width, height, rotation = 0 } = component\n  const [x, y] = applyToPoint(transform, [center.x, center.y])\n  const scaledWidth = width * Math.abs(transform.a)\n  const scaledHeight = height * Math.abs(transform.d)\n  const transformStr = `translate(${x}, ${y}) rotate(${-rotation}) scale(1, -1)`\n\n  if (\n    !ctx.colorMap.debugComponent?.fill &&\n    !ctx.colorMap.debugComponent?.stroke\n  ) {\n    return []\n  }\n\n  return [\n    {\n      name: \"g\",\n      type: \"element\",\n      attributes: { transform: transformStr },\n      children: [\n        {\n          name: \"rect\",\n          type: \"element\",\n          attributes: {\n            class: \"pcb-component\",\n            x: (-scaledWidth / 2).toString(),\n            y: (-scaledHeight / 2).toString(),\n            width: scaledWidth.toString(),\n            height: scaledHeight.toString(),\n            fill: ctx.colorMap.debugComponent.fill ?? \"transparent\",\n            stroke: ctx.colorMap.debugComponent.stroke ?? \"transparent\",\n          },\n        } as any,\n      ],\n      value: \"\",\n    },\n  ]\n}\n","import type { AnyCircuitElement } from \"circuit-json\"\n\nexport function getSoftwareUsedString(\n  circuitJson: AnyCircuitElement[],\n): string | undefined {\n  const metadata = circuitJson.find(\n    (e) =>\n      (e as any).type === \"project_software_metadata\" ||\n      (e as any).type === \"source_project_metadata\",\n  ) as { software_used_string?: string } | undefined\n\n  return metadata?.software_used_string\n}\n","{\n  \"name\": \"circuit-to-svg\",\n  \"type\": \"module\",\n  \"version\": \"0.0.171\",\n  \"description\": \"Convert Circuit JSON to SVG\",\n  \"main\": \"dist/index.js\",\n  \"files\": [\n    \"dist\"\n  ],\n  \"scripts\": {\n    \"start\": \"storybook dev -p 6006\",\n    \"prepublish\": \"npm run build\",\n    \"build\": \"tsup-node ./lib/index.ts --format esm --dts --sourcemap\",\n    \"format\": \"biome format . --write\",\n    \"format:check\": \"biome format .\",\n    \"storybook\": \"storybook dev -p 6006\",\n    \"build-storybook\": \"storybook build\"\n  },\n  \"license\": \"ISC\",\n  \"devDependencies\": {\n    \"@biomejs/biome\": \"^1.9.4\",\n    \"@chromatic-com/storybook\": \"^1.6.1\",\n    \"@storybook/addon-essentials\": \"^8.2.5\",\n    \"@storybook/addon-interactions\": \"^8.2.5\",\n    \"@storybook/addon-links\": \"^8.2.5\",\n    \"@storybook/addon-onboarding\": \"^8.2.5\",\n    \"@storybook/blocks\": \"^8.2.5\",\n    \"@storybook/react\": \"^8.2.5\",\n    \"@storybook/react-vite\": \"^8.2.5\",\n    \"@storybook/test\": \"^8.2.5\",\n    \"@tscircuit/core\": \"0.0.477\",\n    \"@tscircuit/plop\": \"^0.0.10\",\n    \"@types/bun\": \"^1.2.8\",\n    \"biome\": \"^0.3.3\",\n    \"bun-match-svg\": \"^0.0.12\",\n    \"circuit-json\": \"^0.0.218\",\n    \"esbuild\": \"^0.20.2\",\n    \"performance-now\": \"^2.1.0\",\n    \"react\": \"^18.3.1\",\n    \"schematic-symbols\": \"^0.0.153\",\n    \"storybook\": \"^8.2.5\",\n    \"tsup\": \"^8.0.2\",\n    \"typescript\": \"^5.4.5\",\n    \"vite-tsconfig-paths\": \"^5.0.1\",\n    \"@tscircuit/checks\": \"^0.0.44\",\n    \"@tscircuit/circuit-json-util\": \"^0.0.47\",\n    \"@tscircuit/footprinter\": \"^0.0.203\"\n  },\n  \"peerDependencies\": {\n    \"circuit-json\": \"*\",\n    \"@tscircuit/circuit-json-util\": \"*\",\n    \"@tscircuit/footprinter\": \"*\",\n    \"schematic-symbols\": \"*\"\n  },\n  \"dependencies\": {\n    \"@types/node\": \"^22.5.5\",\n    \"bun-types\": \"^1.1.40\",\n    \"svgson\": \"^5.3.1\",\n    \"transformation-matrix\": \"^2.16.1\"\n  }\n}\n","import pkg from \"../package.json\" with { type: \"json\" }\n\nexport const CIRCUIT_TO_SVG_VERSION = (pkg as { version: string }).version\n","import type { Point, AnyCircuitElement } from \"circuit-json\"\nimport { type INode as SvgObject, stringify } from \"svgson\"\nimport { su } from \"@tscircuit/circuit-json-util\"\nimport {\n  type Matrix,\n  applyToPoint,\n  compose,\n  scale,\n  translate,\n} from \"transformation-matrix\"\nimport { createSvgObjectsFromAssemblyBoard } from \"./svg-object-fns/create-svg-objects-from-assembly-board\"\nimport { createSvgObjectsFromAssemblyComponent } from \"./svg-object-fns/create-svg-objects-from-assembly-component\"\nimport { createSvgObjectsFromAssemblyHole } from \"./svg-object-fns/create-svg-objects-from-assembly-hole\"\nimport { createSvgObjectsFromAssemblyPlatedHole } from \"./svg-object-fns/create-svg-objects-from-assembly-plated-hole\"\nimport { createSvgObjectsFromAssemblySmtPad } from \"./svg-object-fns/create-svg-objects-from-assembly-smt-pad\"\nimport { getSoftwareUsedString } from \"../utils/get-software-used-string\"\nimport { CIRCUIT_TO_SVG_VERSION } from \"../package-version\"\n\nconst OBJECT_ORDER: AnyCircuitElement[\"type\"][] = [\n  \"pcb_component\",\n  \"pcb_smtpad\",\n  \"pcb_hole\",\n  \"pcb_plated_hole\",\n  \"pcb_board\",\n]\n\ninterface Options {\n  width?: number\n  height?: number\n  includeVersion?: boolean\n}\n\nexport interface AssemblySvgContext {\n  transform: Matrix\n}\n\nexport function convertCircuitJsonToAssemblySvg(\n  soup: AnyCircuitElement[],\n  options?: Options,\n): string {\n  let minX = Number.POSITIVE_INFINITY\n  let minY = Number.POSITIVE_INFINITY\n  let maxX = Number.NEGATIVE_INFINITY\n  let maxY = Number.NEGATIVE_INFINITY\n\n  // Process all elements to determine bounds\n  for (const item of soup) {\n    if (item.type === \"pcb_board\") {\n      const center = item.center\n      const width = item.width || 0\n      const height = item.height || 0\n      minX = Math.min(minX, center.x - width / 2)\n      minY = Math.min(minY, center.y - height / 2)\n      maxX = Math.max(maxX, center.x + width / 2)\n      maxY = Math.max(maxY, center.y + height / 2)\n    }\n  }\n\n  const padding = 1\n  const circuitWidth = maxX - minX + 2 * padding\n  const circuitHeight = maxY - minY + 2 * padding\n\n  const svgWidth = options?.width ?? 800\n  const svgHeight = options?.height ?? 600\n\n  const scaleX = svgWidth / circuitWidth\n  const scaleY = svgHeight / circuitHeight\n  const scaleFactor = Math.min(scaleX, scaleY)\n\n  const offsetX = (svgWidth - circuitWidth * scaleFactor) / 2\n  const offsetY = (svgHeight - circuitHeight * scaleFactor) / 2\n\n  const transform = compose(\n    translate(\n      offsetX - minX * scaleFactor + padding * scaleFactor,\n      svgHeight - offsetY + minY * scaleFactor - padding * scaleFactor,\n    ),\n    scale(scaleFactor, -scaleFactor), // Flip in y-direction\n  )\n\n  const ctx: AssemblySvgContext = { transform }\n\n  const svgObjects = soup\n    .sort(\n      (a, b) =>\n        (OBJECT_ORDER.indexOf(b.type) ?? 9999) -\n        (OBJECT_ORDER.indexOf(a.type) ?? 9999),\n    )\n    .flatMap((item) => createSvgObjects(item, ctx, soup))\n\n  const softwareUsedString = getSoftwareUsedString(soup)\n  const version = CIRCUIT_TO_SVG_VERSION\n\n  const svgObject: SvgObject = {\n    name: \"svg\",\n    type: \"element\",\n    attributes: {\n      xmlns: \"http://www.w3.org/2000/svg\",\n      width: svgWidth.toString(),\n      height: svgHeight.toString(),\n      ...(softwareUsedString && {\n        \"data-software-used-string\": softwareUsedString,\n      }),\n      ...(options?.includeVersion && {\n        \"data-circuit-to-svg-version\": version,\n      }),\n    },\n    value: \"\",\n    children: [\n      {\n        name: \"style\",\n        type: \"element\",\n        children: [\n          {\n            type: \"text\",\n            value: `\n              .assembly-component { \n                fill: none; \n                stroke: #000; \n              }\n              .assembly-board { \n                fill: #f2f2f2; \n                stroke: rgb(0,0,0); \n                stroke-opacity: 0.8;\n              }\n              .assembly-component-label { \n                fill: #000; \n                font-family: Arial, serif;\n                font-weight: bold;\n                dominant-baseline: middle;\n                text-anchor: middle;\n              }\n              .assembly-boundary { \n                fill: none; \n                stroke: #fff;\n                stroke-width: 0.2; \n              }\n            `,\n            name: \"\",\n            attributes: {},\n            children: [],\n          },\n        ],\n        value: \"\",\n        attributes: {},\n      },\n      {\n        name: \"rect\",\n        type: \"element\",\n        attributes: {\n          fill: \"#fff\",\n          x: \"0\",\n          y: \"0\",\n          width: svgWidth.toString(),\n          height: svgHeight.toString(),\n        },\n        value: \"\",\n        children: [],\n      },\n      createSvgObjectFromAssemblyBoundary(transform, minX, minY, maxX, maxY),\n      ...svgObjects,\n    ].filter((child): child is SvgObject => child !== null),\n  }\n\n  return stringify(svgObject)\n}\n\nfunction createSvgObjects(\n  elm: AnyCircuitElement,\n  ctx: AssemblySvgContext,\n  soup: AnyCircuitElement[],\n): SvgObject[] {\n  const sourceComponents = su(soup).source_component.list()\n\n  switch (elm.type) {\n    case \"pcb_board\":\n      return createSvgObjectsFromAssemblyBoard(elm, ctx.transform)\n\n    case \"pcb_component\": {\n      const sourceComponent = sourceComponents.find(\n        (item) => item.source_component_id === elm.source_component_id,\n      )\n      const ports = su(soup)\n        .pcb_port.list()\n        .filter((port) => port.pcb_component_id === elm.pcb_component_id)\n      const firstPort = ports[0]\n\n      // Proceed only if both sourceComponent and firstPort are found\n      if (sourceComponent && firstPort) {\n        const arePinsInterchangeable = sourceComponent.are_pins_interchangeable\n        const obj = createSvgObjectsFromAssemblyComponent(\n          {\n            elm,\n            portPosition: { x: firstPort.x, y: firstPort.y },\n            name: sourceComponent.name,\n            arePinsInterchangeable,\n          },\n          ctx,\n        )\n        return obj ? [obj] : []\n      }\n\n      return []\n    }\n    case \"pcb_smtpad\":\n      return createSvgObjectsFromAssemblySmtPad(elm, ctx)\n    case \"pcb_hole\":\n      return createSvgObjectsFromAssemblyHole(elm, ctx)\n    case \"pcb_plated_hole\":\n      return createSvgObjectsFromAssemblyPlatedHole(elm, ctx)\n\n    default:\n      return []\n  }\n}\n\nfunction createSvgObjectFromAssemblyBoundary(\n  transform: Matrix,\n  minX: number,\n  minY: number,\n  maxX: number,\n  maxY: number,\n): SvgObject {\n  const [x1, y1] = applyToPoint(transform, [minX, minY])\n  const [x2, y2] = applyToPoint(transform, [maxX, maxY])\n  const width = Math.abs(x2 - x1)\n  const height = Math.abs(y2 - y1)\n  const x = Math.min(x1, x2)\n  const y = Math.min(y1, y2)\n  return {\n    name: \"rect\",\n    type: \"element\",\n    value: \"\",\n    children: [],\n    attributes: {\n      class: \"assembly-boundary\",\n      x: x.toString(),\n      y: y.toString(),\n      width: width.toString(),\n      height: height.toString(),\n    },\n  }\n}\n\nexport default convertCircuitJsonToAssemblySvg\n","import type { PCBBoard, Point } from \"circuit-json\"\nimport { applyToPoint, type Matrix } from \"transformation-matrix\"\nimport type { SvgObject } from \"lib/svg-object\"\n\ninterface BoardStyle {\n  fill: string\n  stroke: string\n  strokeOpacity: string\n  strokeWidthFactor: number\n}\n\nconst DEFAULT_BOARD_STYLE: BoardStyle = {\n  fill: \"none\",\n  stroke: \"rgb(0,0,0)\",\n  strokeOpacity: \"0.8\",\n  strokeWidthFactor: 0.2,\n}\n\nexport function createSvgObjectsFromAssemblyBoard(\n  pcbBoard: PCBBoard,\n  transform: Matrix,\n  style: Partial<BoardStyle> = {},\n): SvgObject[] {\n  const { width, height, center, outline } = pcbBoard\n\n  let path: string\n  if (outline && Array.isArray(outline) && outline.length >= 3) {\n    path = outline\n      .map((point: Point, index: number) => {\n        const [x, y] = applyToPoint(transform, [point.x, point.y])\n        return index === 0 ? `M ${x} ${y}` : `L ${x} ${y}`\n      })\n      .join(\" \")\n  } else {\n    const halfWidth = width / 2\n    const halfHeight = height / 2\n\n    const topLeft = applyToPoint(transform, [\n      center.x - halfWidth,\n      center.y - halfHeight,\n    ])\n    const topRight = applyToPoint(transform, [\n      center.x + halfWidth,\n      center.y - halfHeight,\n    ])\n    const bottomRight = applyToPoint(transform, [\n      center.x + halfWidth,\n      center.y + halfHeight,\n    ])\n    const bottomLeft = applyToPoint(transform, [\n      center.x - halfWidth,\n      center.y + halfHeight,\n    ])\n\n    path =\n      `M ${topLeft[0]} ${topLeft[1]} ` +\n      `L ${topRight[0]} ${topRight[1]} ` +\n      `L ${bottomRight[0]} ${bottomRight[1]} ` +\n      `L ${bottomLeft[0]} ${bottomLeft[1]}`\n  }\n\n  path += \" Z\"\n\n  return [\n    {\n      name: \"path\",\n      type: \"element\",\n      value: \"\",\n      children: [],\n      attributes: {\n        class: \"pcb-board\",\n        d: path,\n        fill: style.fill ?? DEFAULT_BOARD_STYLE.fill,\n        stroke: style.stroke ?? DEFAULT_BOARD_STYLE.stroke,\n        \"stroke-opacity\":\n          style.strokeOpacity ?? DEFAULT_BOARD_STYLE.strokeOpacity,\n        \"stroke-width\": (\n          (style.strokeWidthFactor ?? DEFAULT_BOARD_STYLE.strokeWidthFactor) *\n          Math.abs(transform.a)\n        ).toString(),\n      },\n    },\n  ]\n}\n","import type { AnyCircuitElement, LayerRef, Point } from \"circuit-json\"\nimport type { INode as SvgObject } from \"svgson\"\nimport { type Matrix, applyToPoint } from \"transformation-matrix\"\nimport { getSchScreenFontSize } from \"lib/utils/get-sch-font-size\"\nimport type { AssemblySvgContext } from \"../convert-circuit-json-to-assembly-svg\"\n\nexport interface AssemblyComponentParams {\n  elm: AnyCircuitElement\n  portPosition: { x: number; y: number }\n  name: string\n  arePinsInterchangeable?: boolean\n}\n\ninterface ComponentProps {\n  center: Point\n  width: number\n  height: number\n  rotation?: number\n  layer?: LayerRef\n}\n\nexport function createSvgObjectsFromAssemblyComponent(\n  params: AssemblyComponentParams,\n  ctx: AssemblySvgContext,\n): SvgObject | null {\n  const { elm, portPosition, name, arePinsInterchangeable } = params\n  const { transform } = ctx\n  const { center, width, height, rotation = 0, layer = \"top\" } = elm as any\n  if (!center || typeof width !== \"number\" || typeof height !== \"number\")\n    return null\n  const [x, y] = applyToPoint(transform, [center.x, center.y])\n  const [pinX, pinY] = applyToPoint(transform, [portPosition.x, portPosition.y])\n  const scaledWidth = width * Math.abs(transform.a)\n  const scaledHeight = height * Math.abs(transform.d)\n\n  const isTopLayer = layer === \"top\"\n  const isPinTop = pinY > y\n  const isPinLeft = pinX < x\n\n  const children: SvgObject[] = [\n    createComponentPath(scaledWidth, scaledHeight, rotation, layer),\n    createComponentLabel(scaledWidth, scaledHeight, name ?? \"\", transform),\n  ]\n\n  if (!arePinsInterchangeable) {\n    children.push(\n      createPin1Indicator(\n        scaledWidth,\n        scaledHeight,\n        rotation,\n        layer,\n        isPinTop,\n        isPinLeft,\n      ),\n    )\n  }\n\n  return {\n    name: \"g\",\n    type: \"element\",\n    value: \"\",\n    attributes: {\n      transform: `translate(${x}, ${y}) scale(1, -1)`,\n    },\n    children,\n  }\n}\n\nfunction createComponentPath(\n  scaledWidth: number,\n  scaledHeight: number,\n  rotation: number,\n  layer: LayerRef,\n): SvgObject {\n  const w = scaledWidth / 2\n  const h = scaledHeight / 2\n  const strokeWidth = 0.8\n  const path = getRectPathData(w, h, rotation)\n\n  return {\n    name: \"path\",\n    type: \"element\",\n    attributes: {\n      class: \"assembly-component\",\n      d: path,\n      \"stroke-width\": strokeWidth.toFixed(2),\n      transform: `rotate(${-rotation})`,\n      \"stroke-dasharray\": layer === \"bottom\" ? \"2,2\" : \"\",\n    },\n    value: \"\",\n    children: [],\n  }\n}\n\nfunction createComponentLabel(\n  scaledWidth: number,\n  scaledHeight: number,\n  name: string,\n  transform: Matrix,\n): SvgObject {\n  // Use the smaller dimension as the scale factor\n  const size = Math.min(scaledWidth, scaledHeight)\n\n  // Adjusted font sizing with smaller scale for small components\n  const minFontSize = 3\n  const maxFontSize = 58\n  const fontScale = 0.8 // Smaller scale for small components\n  const fontSize = Math.min(\n    maxFontSize,\n    Math.max(minFontSize, size * fontScale),\n  )\n\n  // Determine if component is tall (height significantly larger than width)\n  const isTall = scaledHeight > scaledWidth\n\n  return {\n    name: \"text\",\n    type: \"element\",\n    attributes: {\n      x: \"0\",\n      y: \"0\",\n      class: \"assembly-component-label\",\n      \"text-anchor\": \"middle\",\n      dy: \".10em\",\n      style: \"pointer-events: none\",\n      \"font-size\": `${fontSize.toFixed(1)}px`,\n      transform: isTall ? \"rotate(90) scale(1, -1)\" : \"scale(1, -1)\",\n    },\n    children: [\n      {\n        type: \"text\",\n        value: name || \"\",\n        name: \"\",\n        attributes: {},\n        children: [],\n      },\n    ],\n    value: \"\",\n  }\n}\n\nfunction createPin1Indicator(\n  scaledWidth: number,\n  scaledHeight: number,\n  rotation: number,\n  layer: LayerRef,\n  isPinTop: boolean,\n  isPinLeft: boolean,\n): SvgObject {\n  const w = scaledWidth / 2\n  const h = scaledHeight / 2\n  const indicatorSize = Math.min(w, h) * 0.5\n\n  let points: [number, number][]\n\n  if (isPinTop && isPinLeft) {\n    // Top-left corner\n    points = [\n      [-w, -h], // Corner point\n      [-w + indicatorSize, -h], // Point along top edge\n      [-w, -h + indicatorSize], // Point along left edge\n    ]\n  } else if (isPinTop && !isPinLeft) {\n    // Top-right corner\n    points = [\n      [w, -h], // Corner point\n      [w - indicatorSize, -h], // Point along top edge\n      [w, -h + indicatorSize], // Point along right edge\n    ]\n  } else if (!isPinTop && isPinLeft) {\n    // Bottom-left corner\n    points = [\n      [-w, h], // Corner point\n      [-w + indicatorSize, h], // Point along bottom edge\n      [-w, h - indicatorSize], // Point along left edge\n    ]\n  } else {\n    // Bottom-right corner\n    points = [\n      [w, h], // Corner point\n      [w - indicatorSize, h], // Point along bottom edge\n      [w, h - indicatorSize], // Point along right edge\n    ]\n  }\n\n  const pointsString = points.map((p) => p.join(\",\")).join(\" \")\n\n  return {\n    name: \"polygon\",\n    type: \"element\",\n    attributes: {\n      class: \"assembly-pin1-indicator\",\n      points: pointsString,\n      fill: \"#333\",\n      stroke: \"none\",\n      transform: `rotate(${-rotation})`,\n    },\n    value: \"\",\n    children: [],\n  }\n}\n\nfunction getRectPathData(w: number, h: number, rotation: number): string {\n  const rotatePoint = (\n    x: number,\n    y: number,\n    angle: number,\n  ): [number, number] => {\n    const rad = (Math.PI / 180) * angle\n    const cos = Math.cos(rad)\n    const sin = Math.sin(rad)\n    return [x * cos - y * sin, x * sin + y * cos]\n  }\n\n  const corners: [number, number][] = [\n    [-w, -h],\n    [w, -h],\n    [w, h],\n    [-w, h],\n  ]\n\n  const rotatedCorners = corners.map(([x, y]) => rotatePoint(x, y, rotation))\n\n  const path = rotatedCorners\n    .map(([x, y], i) => (i === 0 ? `M${x},${y}` : `L${x},${y}`))\n    .join(\" \")\n  return `${path} Z`\n}\n","import type { Matrix } from \"transformation-matrix\"\nimport { applyToPoint } from \"transformation-matrix\"\n\ntype SchTextType =\n  | \"pin_number\"\n  | \"negated_pin_number\"\n  | \"reference_designator\"\n  | \"manufacturer_number\"\n  | \"net_label\"\n  | \"error\"\n\nconst fontSizeMap: Record<SchTextType, number> = {\n  pin_number: 0.15,\n  negated_pin_number: 0.15 * 0.8,\n  reference_designator: 0.18,\n  manufacturer_number: 0.18,\n  net_label: 0.18,\n  error: 0.05,\n}\n\nexport const getSchMmFontSize = (textType: SchTextType, fontSize?: number) => {\n  return fontSize ?? fontSizeMap[textType]\n}\n\nexport const getSchScreenFontSize = (\n  transform: Matrix,\n  textType: SchTextType,\n  fontSize?: number,\n) => {\n  return Math.abs(transform.a) * getSchMmFontSize(textType, fontSize)\n}\n","import type { PCBHole } from \"circuit-json\"\nimport { applyToPoint } from \"transformation-matrix\"\nimport type { SvgObject } from \"lib/svg-object\"\nimport type { AssemblySvgContext } from \"../convert-circuit-json-to-assembly-svg\"\n\nconst HOLE_COLOR = \"rgb(190, 190, 190)\" // Darker gray for holes\n\nexport function createSvgObjectsFromAssemblyHole(\n  hole: PCBHole,\n  ctx: AssemblySvgContext,\n): SvgObject[] {\n  const { transform } = ctx\n  const [x, y] = applyToPoint(transform, [hole.x, hole.y])\n\n  if (hole.hole_shape === \"circle\" || hole.hole_shape === \"square\") {\n    const scaledDiameter = hole.hole_diameter * Math.abs(transform.a)\n    const radius = scaledDiameter / 2\n\n    if (hole.hole_shape === \"circle\") {\n      return [\n        {\n          name: \"circle\",\n          type: \"element\",\n          attributes: {\n            class: \"assembly-hole\",\n            cx: x.toString(),\n            cy: y.toString(),\n            r: radius.toString(),\n            fill: HOLE_COLOR,\n          },\n          children: [],\n          value: \"\",\n        },\n      ]\n    }\n    // Square hole\n    return [\n      {\n        name: \"rect\",\n        type: \"element\",\n        attributes: {\n          class: \"assembly-hole\",\n          x: (x - radius).toString(),\n          y: (y - radius).toString(),\n          width: scaledDiameter.toString(),\n          height: scaledDiameter.toString(),\n          fill: HOLE_COLOR,\n        },\n        children: [],\n        value: \"\",\n      },\n    ]\n  }\n  if (hole.hole_shape === \"oval\") {\n    const scaledWidth = hole.hole_width * Math.abs(transform.a)\n    const scaledHeight = hole.hole_height * Math.abs(transform.a)\n    const rx = scaledWidth / 2\n    const ry = scaledHeight / 2\n\n    return [\n      {\n        name: \"ellipse\",\n        type: \"element\",\n        attributes: {\n          class: \"assembly-hole\",\n          cx: x.toString(),\n          cy: y.toString(),\n          rx: rx.toString(),\n          ry: ry.toString(),\n          fill: HOLE_COLOR,\n        },\n        children: [],\n        value: \"\",\n      },\n    ]\n  }\n\n  return []\n}\n","import type { PCBPlatedHole } from \"circuit-json\"\nimport { applyToPoint } from \"transformation-matrix\"\nimport type { SvgObject } from \"lib/svg-object\"\nimport type { AssemblySvgContext } from \"../convert-circuit-json-to-assembly-svg\"\n\nconst PAD_COLOR = \"rgb(210, 210, 210)\" // Lighter gray for pads\nconst HOLE_COLOR = \"rgb(190, 190, 190)\" // Darker gray for holes\n\nexport function createSvgObjectsFromAssemblyPlatedHole(\n  hole: PCBPlatedHole,\n  ctx: AssemblySvgContext,\n): SvgObject[] {\n  const { transform } = ctx\n  const [x, y] = applyToPoint(transform, [hole.x, hole.y])\n\n  if (hole.shape === \"pill\") {\n    const scaledOuterWidth = hole.outer_width * Math.abs(transform.a)\n    const scaledOuterHeight = hole.outer_height * Math.abs(transform.a)\n    const scaledHoleWidth = hole.hole_width * Math.abs(transform.a)\n    const scaledHoleHeight = hole.hole_height * Math.abs(transform.a)\n\n    const outerRadiusX = scaledOuterWidth / 2\n    const straightLength = scaledOuterHeight - scaledOuterWidth\n    const innerRadiusX = scaledHoleWidth / 2\n\n    return [\n      {\n        name: \"g\",\n        type: \"element\",\n        children: [\n          // Outer pill shape\n          {\n            name: \"path\",\n            type: \"element\",\n            attributes: {\n              class: \"assembly-hole-outer\",\n              fill: PAD_COLOR,\n              d:\n                `M${x - outerRadiusX},${y - straightLength / 2} ` +\n                `v${straightLength} ` +\n                `a${outerRadiusX},${outerRadiusX} 0 0 0 ${scaledOuterWidth},0 ` +\n                `v-${straightLength} ` +\n                `a${outerRadiusX},${outerRadiusX} 0 0 0 -${scaledOuterWidth},0 z`,\n            },\n            value: \"\",\n            children: [],\n          },\n          // Inner pill shape\n          {\n            name: \"path\",\n            type: \"element\",\n            attributes: {\n              class: \"assembly-hole-inner\",\n              fill: HOLE_COLOR,\n              d:\n                `M${x - innerRadiusX},${y - (scaledHoleHeight - scaledHoleWidth) / 2} ` +\n                `v${scaledHoleHeight - scaledHoleWidth} ` +\n                `a${innerRadiusX},${innerRadiusX} 0 0 0 ${scaledHoleWidth},0 ` +\n                `v-${scaledHoleHeight - scaledHoleWidth} ` +\n                `a${innerRadiusX},${innerRadiusX} 0 0 0 -${scaledHoleWidth},0 z`,\n            },\n            value: \"\",\n            children: [],\n          },\n        ],\n        value: \"\",\n        attributes: {},\n      },\n    ]\n  }\n\n  // Fallback to circular hole if not pill-shaped\n  if (hole.shape === \"circle\") {\n    const scaledOuterWidth = hole.outer_diameter * Math.abs(transform.a)\n    const scaledOuterHeight = hole.outer_diameter * Math.abs(transform.a)\n    const scaledHoleWidth = hole.hole_diameter * Math.abs(transform.a)\n    const scaledHoleHeight = hole.hole_diameter * Math.abs(transform.a)\n\n    const outerRadius = Math.min(scaledOuterWidth, scaledOuterHeight) / 2\n    const innerRadius = Math.min(scaledHoleWidth, scaledHoleHeight) / 2\n    return [\n      {\n        name: \"g\",\n        type: \"element\",\n        children: [\n          {\n            name: \"circle\",\n            type: \"element\",\n            attributes: {\n              class: \"assembly-hole-outer\",\n              fill: PAD_COLOR,\n              cx: x.toString(),\n              cy: y.toString(),\n              r: outerRadius.toString(),\n            },\n            value: \"\",\n            children: [],\n          },\n          {\n            name: \"circle\",\n            type: \"element\",\n            attributes: {\n              class: \"assembly-hole-inner\",\n              fill: HOLE_COLOR,\n              cx: x.toString(),\n              cy: y.toString(),\n              r: innerRadius.toString(),\n            },\n            value: \"\",\n            children: [],\n          },\n        ],\n        value: \"\",\n        attributes: {},\n      },\n    ]\n  }\n\n  // Handle circular hole with rectangular pad (hole is circle, outer pad is rectangle)\n  if (hole.shape === \"circular_hole_with_rect_pad\") {\n    const scaledHoleDiameter = hole.hole_diameter * Math.abs(transform.a)\n    const scaledRectPadWidth = hole.rect_pad_width * Math.abs(transform.a)\n    const scaledRectPadHeight = hole.rect_pad_height * Math.abs(transform.a)\n\n    const holeRadius = scaledHoleDiameter / 2\n\n    return [\n      {\n        name: \"g\",\n        type: \"element\",\n        children: [\n          // Rectangular pad (outer shape)\n          {\n            name: \"rect\",\n            type: \"element\",\n            attributes: {\n              class: \"assembly-hole-outer-pad\",\n              fill: PAD_COLOR,\n              x: (x - scaledRectPadWidth / 2).toString(),\n              y: (y - scaledRectPadHeight / 2).toString(),\n              width: scaledRectPadWidth.toString(),\n              height: scaledRectPadHeight.toString(),\n            },\n            value: \"\",\n            children: [],\n          },\n          // Circular hole inside the rectangle\n          {\n            name: \"circle\",\n            type: \"element\",\n            attributes: {\n              class: \"assembly-hole-inner\",\n              fill: HOLE_COLOR,\n              cx: x.toString(),\n              cy: y.toString(),\n              r: holeRadius.toString(),\n            },\n            value: \"\",\n            children: [],\n          },\n        ],\n        value: \"\",\n        attributes: {},\n      },\n    ]\n  }\n  if (hole.shape === \"pill_hole_with_rect_pad\") {\n    const scaledRectPadWidth = hole.rect_pad_width * Math.abs(transform.a)\n    const scaledRectPadHeight = hole.rect_pad_height * Math.abs(transform.a)\n\n    const scaledHoleHeight = hole.hole_height * Math.abs(transform.a)\n    const scaledHoleWidth = hole.hole_width * Math.abs(transform.a)\n\n    // Use the minimum of scaledHoleHeight and scaledHoleWidth for the radius\n    const holeRadius = Math.min(scaledHoleHeight, scaledHoleWidth) / 2\n\n    return [\n      {\n        name: \"g\",\n        type: \"element\",\n        children: [\n          // Rectangular pad (outer shape)\n          {\n            name: \"rect\",\n            type: \"element\",\n            attributes: {\n              class: \"assembly-hole-outer-pad\",\n              fill: PAD_COLOR,\n              x: (x - scaledRectPadWidth / 2).toString(),\n              y: (y - scaledRectPadHeight / 2).toString(),\n              width: scaledRectPadWidth.toString(),\n              height: scaledRectPadHeight.toString(),\n            },\n            value: \"\",\n            children: [],\n          },\n          // pill hole inside the rectangle\n          {\n            name: \"rect\",\n            type: \"element\",\n            attributes: {\n              class: \"assembly-hole-inner\",\n              fill: HOLE_COLOR,\n              x: (x - scaledHoleWidth / 2).toString(),\n              y: (y - scaledHoleHeight / 2).toString(),\n              width: scaledHoleWidth.toString(),\n              height: scaledHoleHeight.toString(),\n              rx: holeRadius.toString(),\n              ry: holeRadius.toString(),\n            },\n            value: \"\",\n            children: [],\n          },\n        ],\n        value: \"\",\n        attributes: {},\n      },\n    ]\n  }\n\n  return []\n}\n","import type { PcbSmtPad } from \"circuit-json\"\nimport { applyToPoint } from \"transformation-matrix\"\nimport type { SvgObject } from \"lib/svg-object\"\nimport type { AssemblySvgContext } from \"../convert-circuit-json-to-assembly-svg\"\n\nconst PAD_COLOR = \"rgb(210, 210, 210)\" // Lighter gray for pads\n\nexport function createSvgObjectsFromAssemblySmtPad(\n  pad: PcbSmtPad,\n  ctx: AssemblySvgContext,\n): SvgObject[] {\n  const { transform } = ctx\n\n  if (pad.shape === \"rect\" || pad.shape === \"rotated_rect\") {\n    const width = pad.width * Math.abs(transform.a)\n    const height = pad.height * Math.abs(transform.d)\n    const [x, y] = applyToPoint(transform, [pad.x, pad.y])\n\n    if (pad.shape === \"rotated_rect\" && pad.ccw_rotation) {\n      return [\n        {\n          name: \"rect\",\n          type: \"element\",\n          attributes: {\n            class: \"assembly-pad\",\n            fill: PAD_COLOR,\n            x: (-width / 2).toString(),\n            y: (-height / 2).toString(),\n            width: width.toString(),\n            height: height.toString(),\n            transform: `translate(${x} ${y}) rotate(${-pad.ccw_rotation})`,\n            \"data-layer\": pad.layer,\n          },\n          value: \"\",\n          children: [],\n        },\n      ]\n    }\n\n    return [\n      {\n        name: \"rect\",\n        type: \"element\",\n        attributes: {\n          class: \"assembly-pad\",\n          fill: PAD_COLOR,\n          x: (x - width / 2).toString(),\n          y: (y - height / 2).toString(),\n          width: width.toString(),\n          height: height.toString(),\n          \"data-layer\": pad.layer,\n        },\n        value: \"\",\n        children: [],\n      },\n    ]\n  }\n\n  if (pad.shape === \"pill\") {\n    const width = pad.width * Math.abs(transform.a)\n    const height = pad.height * Math.abs(transform.d)\n    const radius = pad.radius * Math.abs(transform.a)\n    const [x, y] = applyToPoint(transform, [pad.x, pad.y])\n\n    return [\n      {\n        name: \"rect\",\n        type: \"element\",\n        attributes: {\n          class: \"assembly-pad\",\n          fill: PAD_COLOR,\n          x: (x - width / 2).toString(),\n          y: (y - height / 2).toString(),\n          width: width.toString(),\n          height: height.toString(),\n          rx: radius.toString(),\n          ry: radius.toString(),\n          \"data-layer\": pad.layer,\n        },\n        value: \"\",\n        children: [],\n      },\n    ]\n  }\n  if (pad.shape === \"circle\") {\n    const radius = pad.radius * Math.abs(transform.a)\n    const [x, y] = applyToPoint(transform, [pad.x, pad.y])\n\n    return [\n      {\n        name: \"circle\",\n        type: \"element\",\n        attributes: {\n          class: \"assembly-pad\",\n          fill: PAD_COLOR,\n          cx: x.toString(),\n          cy: y.toString(),\n          r: radius.toString(),\n          \"data-layer\": pad.layer,\n        },\n        value: \"\",\n        children: [],\n      },\n    ]\n  }\n\n  if (pad.shape === \"polygon\") {\n    const points = (pad.points ?? []).map((point) =>\n      applyToPoint(transform, [point.x, point.y]),\n    )\n\n    return [\n      {\n        name: \"polygon\",\n        type: \"element\",\n        attributes: {\n          class: \"assembly-pad\",\n          fill: PAD_COLOR,\n          points: points.map((p) => p.join(\",\")).join(\" \"),\n          \"data-layer\": pad.layer,\n        },\n        value: \"\",\n        children: [],\n      },\n    ]\n  }\n\n  return []\n}\n","// Kicad-2020 color scheme\nexport const colorMap = {\n  \"3d_viewer\": {\n    background_bottom: \"rgb(102, 102, 128)\",\n    background_top: \"rgb(204, 204, 230)\",\n    board: \"rgb(51, 43, 23)\",\n    copper: \"rgb(179, 156, 0)\",\n    silkscreen_bottom: \"rgb(230, 230, 230)\",\n    silkscreen_top: \"rgb(230, 230, 230)\",\n    soldermask: \"rgb(20, 51, 36)\",\n    solderpaste: \"rgb(128, 128, 128)\",\n  },\n  board: {\n    anchor: \"rgb(255, 38, 226)\",\n    aux_items: \"rgb(255, 255, 255)\",\n    b_adhes: \"rgb(0, 0, 132)\",\n    b_crtyd: \"rgb(255, 38, 226)\",\n    b_fab: \"rgb(88, 93, 132)\",\n    b_mask: \"rgba(2, 255, 238, 0.400)\",\n    b_paste: \"rgb(0, 194, 194)\",\n    b_silks: \"rgb(232, 178, 167)\",\n    background: \"rgb(0, 16, 35)\",\n    cmts_user: \"rgb(89, 148, 220)\",\n    copper: {\n      b: \"rgb(77, 127, 196)\",\n      f: \"rgb(200, 52, 52)\",\n      in1: \"rgb(127, 200, 127)\",\n      in10: \"rgb(237, 124, 51)\",\n      in11: \"rgb(91, 195, 235)\",\n      in12: \"rgb(247, 111, 142)\",\n      in13: \"rgb(167, 165, 198)\",\n      in14: \"rgb(40, 204, 217)\",\n      in15: \"rgb(232, 178, 167)\",\n      in16: \"rgb(242, 237, 161)\",\n      in17: \"rgb(237, 124, 51)\",\n      in18: \"rgb(91, 195, 235)\",\n      in19: \"rgb(247, 111, 142)\",\n      in2: \"rgb(206, 125, 44)\",\n      in20: \"rgb(167, 165, 198)\",\n      in21: \"rgb(40, 204, 217)\",\n      in22: \"rgb(232, 178, 167)\",\n      in23: \"rgb(242, 237, 161)\",\n      in24: \"rgb(237, 124, 51)\",\n      in25: \"rgb(91, 195, 235)\",\n      in26: \"rgb(247, 111, 142)\",\n      in27: \"rgb(167, 165, 198)\",\n      in28: \"rgb(40, 204, 217)\",\n      in29: \"rgb(232, 178, 167)\",\n      in3: \"rgb(79, 203, 203)\",\n      in30: \"rgb(242, 237, 161)\",\n      in4: \"rgb(219, 98, 139)\",\n      in5: \"rgb(167, 165, 198)\",\n      in6: \"rgb(40, 204, 217)\",\n      in7: \"rgb(232, 178, 167)\",\n      in8: \"rgb(242, 237, 161)\",\n      in9: \"rgb(141, 203, 129)\",\n    },\n    cursor: \"rgb(255, 255, 255)\",\n    drc: \"rgb(194, 194, 194)\",\n    drc_error: \"rgba(215, 91, 107, 0.800)\",\n    drc_exclusion: \"rgb(255, 255, 255)\",\n    drc_warning: \"rgba(255, 208, 66, 0.902)\",\n    dwgs_user: \"rgb(194, 194, 194)\",\n    eco1_user: \"rgb(180, 219, 210)\",\n    eco2_user: \"rgb(216, 200, 82)\",\n    edge_cuts: \"rgb(208, 210, 205)\",\n    f_adhes: \"rgb(132, 0, 132)\",\n    f_crtyd: \"rgb(255, 0, 245)\",\n    f_fab: \"rgb(175, 175, 175)\",\n    f_mask: \"rgba(216, 100, 255, 0.400)\",\n    f_paste: \"rgba(180, 160, 154, 0.902)\",\n    f_silks: \"rgb(242, 237, 161)\",\n    footprint_text_back: \"rgb(0, 0, 132)\",\n    footprint_text_front: \"rgb(194, 194, 194)\",\n    footprint_text_invisible: \"rgb(132, 132, 132)\",\n    grid: \"rgb(132, 132, 132)\",\n    grid_axes: \"rgb(194, 194, 194)\",\n    margin: \"rgb(255, 38, 226)\",\n    microvia: \"rgb(0, 132, 132)\",\n    no_connect: \"rgb(0, 0, 132)\",\n    pad_back: \"rgb(77, 127, 196)\",\n    pad_front: \"rgb(200, 52, 52)\",\n    pad_plated_hole: \"rgb(194, 194, 0)\",\n    pad_through_hole: \"rgb(227, 183, 46)\",\n    plated_hole: \"rgb(26, 196, 210)\",\n    ratsnest: \"rgba(245, 255, 213, 0.702)\",\n    select_overlay: \"rgb(4, 255, 67)\",\n    through_via: \"rgb(236, 236, 236)\",\n    user_1: \"rgb(194, 194, 194)\",\n    user_2: \"rgb(89, 148, 220)\",\n    user_3: \"rgb(180, 219, 210)\",\n    user_4: \"rgb(216, 200, 82)\",\n    user_5: \"rgb(194, 194, 194)\",\n    user_6: \"rgb(89, 148, 220)\",\n    user_7: \"rgb(180, 219, 210)\",\n    user_8: \"rgb(216, 200, 82)\",\n    user_9: \"rgb(232, 178, 167)\",\n    via_blind_buried: \"rgb(187, 151, 38)\",\n    via_hole: \"rgb(227, 183, 46)\",\n    via_micro: \"rgb(0, 132, 132)\",\n    via_through: \"rgb(236, 236, 236)\",\n    worksheet: \"rgb(200, 114, 171)\",\n  },\n  gerbview: {\n    axes: \"rgb(0, 0, 132)\",\n    background: \"rgb(0, 0, 0)\",\n    dcodes: \"rgb(255, 255, 255)\",\n    grid: \"rgb(132, 132, 132)\",\n    layers: [\n      \"rgb(132, 0, 0)\",\n      \"rgb(194, 194, 0)\",\n      \"rgb(194, 0, 194)\",\n      \"rgb(194, 0, 0)\",\n      \"rgb(0, 132, 132)\",\n      \"rgb(0, 132, 0)\",\n      \"rgb(0, 0, 132)\",\n      \"rgb(132, 132, 132)\",\n      \"rgb(132, 0, 132)\",\n      \"rgb(194, 194, 194)\",\n      \"rgb(132, 0, 132)\",\n      \"rgb(132, 0, 0)\",\n      \"rgb(132, 132, 0)\",\n      \"rgb(194, 194, 194)\",\n      \"rgb(0, 0, 132)\",\n      \"rgb(0, 132, 0)\",\n      \"rgb(132, 0, 0)\",\n      \"rgb(194, 194, 0)\",\n      \"rgb(194, 0, 194)\",\n      \"rgb(194, 0, 0)\",\n      \"rgb(0, 132, 132)\",\n      \"rgb(0, 132, 0)\",\n      \"rgb(0, 0, 132)\",\n      \"rgb(132, 132, 132)\",\n      \"rgb(132, 0, 132)\",\n      \"rgb(194, 194, 194)\",\n      \"rgb(132, 0, 132)\",\n      \"rgb(132, 0, 0)\",\n      \"rgb(132, 132, 0)\",\n      \"rgb(194, 194, 194)\",\n      \"rgb(0, 0, 132)\",\n      \"rgb(0, 132, 0)\",\n      \"rgb(132, 0, 0)\",\n      \"rgb(194, 194, 0)\",\n      \"rgb(194, 0, 194)\",\n      \"rgb(194, 0, 0)\",\n      \"rgb(0, 132, 132)\",\n      \"rgb(0, 132, 0)\",\n      \"rgb(0, 0, 132)\",\n      \"rgb(132, 132, 132)\",\n      \"rgb(132, 0, 132)\",\n      \"rgb(194, 194, 194)\",\n      \"rgb(132, 0, 132)\",\n      \"rgb(132, 0, 0)\",\n      \"rgb(132, 132, 0)\",\n      \"rgb(194, 194, 194)\",\n      \"rgb(0, 0, 132)\",\n      \"rgb(0, 132, 0)\",\n      \"rgb(132, 0, 0)\",\n      \"rgb(194, 194, 0)\",\n      \"rgb(194, 0, 194)\",\n      \"rgb(194, 0, 0)\",\n      \"rgb(0, 132, 132)\",\n      \"rgb(0, 132, 0)\",\n      \"rgb(0, 0, 132)\",\n      \"rgb(132, 132, 132)\",\n      \"rgb(132, 0, 132)\",\n      \"rgb(194, 194, 194)\",\n      \"rgb(132, 0, 132)\",\n      \"rgb(132, 0, 0)\",\n    ],\n    negative_objects: \"rgb(132, 132, 132)\",\n    worksheet: \"rgb(0, 0, 132)\",\n  },\n  meta: {\n    filename: \"kicad_2020\",\n    name: \"KiCad 2020\",\n    version: 2,\n  },\n  palette: [\n    \"rgb(132, 0, 0)\",\n    \"rgb(194, 194, 0)\",\n    \"rgb(194, 0, 194)\",\n    \"rgb(194, 0, 0)\",\n    \"rgb(0, 132, 132)\",\n    \"rgb(0, 132, 0)\",\n    \"rgb(0, 0, 132)\",\n    \"rgb(132, 132, 132)\",\n    \"rgb(132, 0, 132)\",\n    \"rgb(194, 194, 194)\",\n    \"rgb(132, 0, 132)\",\n    \"rgb(132, 0, 0)\",\n    \"rgb(132, 132, 0)\",\n    \"rgb(194, 194, 194)\",\n    \"rgb(0, 0, 132)\",\n    \"rgb(0, 132, 0)\",\n  ],\n  schematic: {\n    aux_items: \"rgb(46, 46, 46)\",\n    background: \"rgb(245, 241, 237)\",\n    brightened: \"rgb(255, 0, 255)\",\n    bus: \"rgb(0, 0, 132)\",\n    bus_junction: \"rgb(0, 0, 132)\",\n    component_body: \"rgb(255, 255, 194)\",\n    component_outline: \"rgb(132, 0, 0)\",\n    cursor: \"rgb(15, 15, 15)\",\n    erc_error: \"rgba(230, 9, 13, 0.800)\",\n    erc_warning: \"rgba(209, 146, 0, 0.800)\",\n    fields: \"rgb(132, 0, 132)\",\n    grid: \"rgb(181, 181, 181)\",\n    grid_axes: \"rgb(0, 0, 132)\",\n    hidden: \"rgb(194, 194, 194)\",\n    junction: \"rgb(0, 150, 0)\",\n    label_global: \"rgb(132, 0, 0)\",\n    label_background: \"rgba(255, 255, 255, 0.6)\",\n    label_hier: \"rgb(114, 86, 0)\",\n    label_local: \"rgb(15, 15, 15)\",\n    net_name: \"rgb(132, 132, 132)\",\n    no_connect: \"rgb(0, 0, 132)\",\n    note: \"rgb(0, 0, 194)\",\n    override_item_colors: false,\n    pin: \"rgb(132, 0, 0)\",\n    pin_name: \"rgb(0, 100, 100)\",\n    pin_number: \"rgb(169, 0, 0)\",\n    reference: \"rgb(0, 100, 100)\",\n    shadow: \"rgba(102, 179, 255, 0.800)\",\n    sheet: \"rgb(132, 0, 0)\",\n    sheet_background: \"rgba(253, 255, 231, 0.000)\",\n    sheet_fields: \"rgb(132, 0, 132)\",\n    sheet_filename: \"rgb(114, 86, 0)\",\n    sheet_label: \"rgb(0, 100, 100)\",\n    sheet_name: \"rgb(0, 100, 100)\",\n    table: \"rgb(102, 102, 102)\",\n    value: \"rgb(0, 100, 100)\",\n    wire: \"rgb(0, 150, 0)\",\n    wire_crossing: \"rgb(30, 180, 30)\",\n    worksheet: \"rgb(132, 0, 0)\",\n  },\n}\n\nexport type ColorMap = typeof colorMap\n","import type { AnyCircuitElement } from \"circuit-json\"\nimport type { SvgObject } from \"lib/svg-object\"\nimport { colorMap as defaultColorMap, type ColorMap } from \"lib/utils/colors\"\nimport { stringify } from \"svgson\"\nimport {\n  applyToPoint,\n  compose,\n  scale,\n  translate,\n  fromTriangles,\n  type Matrix,\n  fromTwoMovingPoints,\n  toSVG,\n} from \"transformation-matrix\"\nimport { drawSchematicGrid } from \"./draw-schematic-grid\"\nimport { drawSchematicLabeledPoints } from \"./draw-schematic-labeled-points\"\nimport { getSchematicBoundsFromCircuitJson } from \"./get-schematic-bounds-from-circuit-json\"\nimport { createSvgObjectsFromSchematicComponent } from \"./svg-object-fns/create-svg-objects-from-sch-component\"\nimport { createSvgObjectsFromSchVoltageProbe } from \"./svg-object-fns/create-svg-objects-from-sch-voltage-probe\"\nimport { createSvgObjectsFromSchDebugObject } from \"./svg-object-fns/create-svg-objects-from-sch-debug-object\"\nimport { createSchematicTrace } from \"./svg-object-fns/create-svg-objects-from-sch-trace\"\nimport { createSvgObjectsForSchNetLabel } from \"./svg-object-fns/create-svg-objects-for-sch-net-label\"\nimport { createSvgSchText } from \"./svg-object-fns/create-svg-objects-for-sch-text\"\nimport { createSvgObjectsFromSchematicBox } from \"./svg-object-fns/create-svg-objects-from-sch-box\"\nimport { getSoftwareUsedString } from \"lib/utils/get-software-used-string\"\nimport { CIRCUIT_TO_SVG_VERSION } from \"lib/package-version\"\nimport { createSvgObjectsFromSchematicTable } from \"./svg-object-fns/create-svg-objects-from-sch-table\"\nimport { createSvgObjectsForSchComponentPortHovers } from \"./svg-object-fns/create-svg-objects-for-sch-port-hover\"\n\nexport type ColorOverrides = {\n  schematic?: Partial<ColorMap[\"schematic\"]>\n}\n\ninterface Options {\n  colorOverrides?: ColorOverrides\n  width?: number\n  height?: number\n  grid?: boolean | { cellSize?: number; labelCells?: boolean }\n  labeledPoints?: Array<{ x: number; y: number; label: string }>\n  includeVersion?: boolean\n}\n\nexport function convertCircuitJsonToSchematicSvg(\n  circuitJson: AnyCircuitElement[],\n  options?: Options,\n): string {\n  // Get bounds with padding\n  const realBounds = getSchematicBoundsFromCircuitJson(circuitJson)\n  const realWidth = realBounds.maxX - realBounds.minX\n  const realHeight = realBounds.maxY - realBounds.minY\n\n  const svgWidth = options?.width ?? 1200\n  const svgHeight = options?.height ?? 600\n  const colorOverrides = options?.colorOverrides\n\n  const colorMap: ColorMap = {\n    ...defaultColorMap,\n    schematic: {\n      ...defaultColorMap.schematic,\n      ...(colorOverrides?.schematic ?? {}),\n    },\n  }\n\n  // Compute the padding such that we maintain the same aspect ratio\n  const circuitAspectRatio = realWidth / realHeight\n  const containerAspectRatio = svgWidth / svgHeight\n\n  let screenPaddingPx: { x: number; y: number }\n  if (circuitAspectRatio > containerAspectRatio) {\n    // Circuit is wider than container - fit to width\n    const newHeight = svgWidth / circuitAspectRatio\n    screenPaddingPx = {\n      x: 0,\n      y: (svgHeight - newHeight) / 2,\n    }\n  } else {\n    // Circuit is taller than container - fit to height\n    const newWidth = svgHeight * circuitAspectRatio\n    screenPaddingPx = {\n      x: (svgWidth - newWidth) / 2,\n      y: 0,\n    }\n  }\n\n  // Calculate projection using REAL points and SCREEN points\n  // We're saying to map the real bounds to the screen bounds by giving 3 points\n  // for each coordinate space\n  const transform = fromTriangles(\n    [\n      { x: realBounds.minX, y: realBounds.maxY },\n      { x: realBounds.maxX, y: realBounds.maxY },\n      { x: realBounds.maxX, y: realBounds.minY },\n    ],\n    [\n      { x: screenPaddingPx.x, y: screenPaddingPx.y },\n      { x: svgWidth - screenPaddingPx.x, y: screenPaddingPx.y },\n      { x: svgWidth - screenPaddingPx.x, y: svgHeight - screenPaddingPx.y },\n    ],\n  )\n  const svgChildren: SvgObject[] = []\n\n  // Add background rectangle\n  svgChildren.push({\n    name: \"rect\",\n    type: \"element\",\n    attributes: {\n      class: \"boundary\",\n      x: \"0\",\n      y: \"0\",\n      width: svgWidth.toString(),\n      height: svgHeight.toString(),\n    },\n    children: [],\n    value: \"\",\n  })\n\n  // Add grid if enabled\n  if (options?.grid) {\n    const gridConfig = typeof options.grid === \"object\" ? options.grid : {}\n    svgChildren.push(\n      drawSchematicGrid({ bounds: realBounds, transform, ...gridConfig }),\n    )\n  }\n\n  const schDebugObjectSvgs: SvgObject[] = []\n  const schComponentSvgs: SvgObject[] = []\n  const schTraceSvgs: SvgObject[] = []\n  const schNetLabel: SvgObject[] = []\n  const schText: SvgObject[] = []\n  const voltageProbeSvgs: SvgObject[] = []\n  const schBoxSvgs: SvgObject[] = []\n  const schTableSvgs: SvgObject[] = []\n  const schPortHoverSvgs: SvgObject[] = []\n  for (const elm of circuitJson) {\n    if (elm.type === \"schematic_debug_object\") {\n      schDebugObjectSvgs.push(\n        ...createSvgObjectsFromSchDebugObject({\n          debugObject: elm,\n          transform,\n        }),\n      )\n    } else if (elm.type === \"schematic_component\") {\n      schComponentSvgs.push(\n        ...createSvgObjectsFromSchematicComponent({\n          component: elm,\n          transform,\n          circuitJson,\n          colorMap,\n        }),\n      )\n      schPortHoverSvgs.push(\n        ...createSvgObjectsForSchComponentPortHovers({\n          component: elm,\n          transform,\n          circuitJson,\n        }),\n      )\n    } else if (elm.type === \"schematic_box\") {\n      schBoxSvgs.push(\n        ...createSvgObjectsFromSchematicBox({\n          schematicBox: elm,\n          transform,\n          colorMap,\n        }),\n      )\n    } else if (elm.type === \"schematic_trace\") {\n      schTraceSvgs.push(\n        ...createSchematicTrace({\n          trace: elm,\n          transform,\n          colorMap,\n        }),\n      )\n    } else if (elm.type === \"schematic_net_label\") {\n      schNetLabel.push(\n        ...createSvgObjectsForSchNetLabel({\n          schNetLabel: elm,\n          realToScreenTransform: transform,\n          colorMap,\n        }),\n      )\n    } else if (elm.type === \"schematic_text\" && !elm.schematic_component_id) {\n      schText.push(\n        createSvgSchText({\n          elm,\n          transform,\n          colorMap,\n        }),\n      )\n    } else if (elm.type === \"schematic_voltage_probe\") {\n      voltageProbeSvgs.push(\n        ...createSvgObjectsFromSchVoltageProbe({\n          probe: elm,\n          transform,\n          colorMap,\n        }),\n      )\n    } else if (elm.type === \"schematic_table\") {\n      schTableSvgs.push(\n        ...createSvgObjectsFromSchematicTable({\n          schematicTable: elm,\n          transform,\n          colorMap,\n          circuitJson,\n        }),\n      )\n    }\n  }\n\n  // Add elements in correct order\n  svgChildren.push(\n    ...schDebugObjectSvgs,\n    ...schComponentSvgs,\n    ...schTraceSvgs,\n    ...schPortHoverSvgs,\n    ...schNetLabel,\n    ...schText,\n    ...schBoxSvgs,\n    ...voltageProbeSvgs,\n    ...schTableSvgs,\n  )\n\n  // Add labeled points if provided\n  if (options?.labeledPoints) {\n    svgChildren.push(\n      drawSchematicLabeledPoints({\n        points: options.labeledPoints,\n        transform,\n      }),\n    )\n  }\n\n  const softwareUsedString = getSoftwareUsedString(circuitJson)\n  const version = CIRCUIT_TO_SVG_VERSION\n\n  const svgObject: SvgObject = {\n    name: \"svg\",\n    type: \"element\",\n    attributes: {\n      xmlns: \"http://www.w3.org/2000/svg\",\n      width: svgWidth.toString(),\n      height: svgHeight.toString(),\n      style: `background-color: ${colorMap.schematic.background}`,\n      \"data-real-to-screen-transform\": toSVG(transform),\n      ...(softwareUsedString && {\n        \"data-software-used-string\": softwareUsedString,\n      }),\n      ...(options?.includeVersion && {\n        \"data-circuit-to-svg-version\": version,\n      }),\n    },\n    children: [\n      // Add styles\n      {\n        name: \"style\",\n        type: \"element\",\n        children: [\n          {\n            type: \"text\",\n\n            // DO NOT USE THESE CLASSES!!!!\n            // PUT STYLES IN THE SVG OBJECTS THEMSELVES\n            value: `\n              .boundary { fill: ${colorMap.schematic.background}; }\n              .schematic-boundary { fill: none; stroke: #fff; }\n              .component { fill: none; stroke: ${colorMap.schematic.component_outline}; }\n              .chip { fill: ${colorMap.schematic.component_body}; stroke: ${colorMap.schematic.component_outline}; }\n              .component-pin { fill: none; stroke: ${colorMap.schematic.component_outline}; }\n              .trace:hover {\n                filter: invert(1);\n              }\n              .trace:hover .trace-crossing-outline {\n                opacity: 0;\n              }\n              .trace:hover .trace-junction {\n                filter: invert(1);\n              }\n              .text { font-family: sans-serif; fill: ${colorMap.schematic.wire}; }\n              .pin-number { fill: ${colorMap.schematic.pin_number}; }\n              .port-label { fill: ${colorMap.schematic.reference}; }\n              .component-name { fill: ${colorMap.schematic.reference}; }\n            `,\n            name: \"\",\n            attributes: {},\n            children: [],\n          },\n        ],\n        value: \"\",\n        attributes: {},\n      },\n      ...svgChildren,\n    ],\n    value: \"\",\n  }\n\n  return stringify(svgObject)\n}\n\n/**\n * @deprecated use `convertCircuitJsonToSchematicSvg` instead\n */\nexport const circuitJsonToSchematicSvg = convertCircuitJsonToSchematicSvg\n","import { colorMap } from \"lib/utils/colors\"\nimport type { INode as SvgObject } from \"svgson\"\nimport { applyToPoint, type Matrix } from \"transformation-matrix\"\n\nexport function drawSchematicGrid(params: {\n  bounds: {\n    minX: number\n    minY: number\n    maxX: number\n    maxY: number\n  }\n  transform: Matrix\n  cellSize?: number\n  labelCells?: boolean\n}): SvgObject {\n  const { minX, minY, maxX, maxY } = params.bounds\n  const cellSize = params.cellSize ?? 1\n  const labelCells = params.labelCells ?? false\n  const gridLines: any[] = []\n\n  // Helper function to transform points\n  const transformPoint = (x: number, y: number) => {\n    const [transformedX, transformedY] = applyToPoint(params.transform, [x, y])\n    return { x: transformedX, y: transformedY }\n  }\n\n  // Vertical lines\n  for (let x = Math.floor(minX); x <= Math.ceil(maxX); x += cellSize) {\n    const start = transformPoint(x, minY)\n    const end = transformPoint(x, maxY)\n\n    gridLines.push({\n      name: \"line\",\n      type: \"element\",\n      attributes: {\n        x1: start.x.toString(),\n        y1: start.y.toString(),\n        x2: end.x.toString(),\n        y2: end.y.toString(),\n        stroke: colorMap.schematic.grid,\n        \"stroke-width\": (0.01 * Math.abs(params.transform.a)).toString(),\n        \"stroke-opacity\": \"0.5\",\n      },\n    })\n  }\n\n  // Horizontal lines\n  for (let y = Math.floor(minY); y <= Math.ceil(maxY); y += cellSize) {\n    const start = transformPoint(minX, y)\n    const end = transformPoint(maxX, y)\n\n    gridLines.push({\n      name: \"line\",\n      type: \"element\",\n      attributes: {\n        x1: start.x.toString(),\n        y1: start.y.toString(),\n        x2: end.x.toString(),\n        y2: end.y.toString(),\n        stroke: colorMap.schematic.grid,\n        \"stroke-width\": (0.01 * Math.abs(params.transform.a)).toString(),\n        \"stroke-opacity\": \"0.5\",\n      },\n    })\n  }\n\n  // Add cell labels if enabled\n  if (labelCells) {\n    const formatPoint = (x: number, y: number) => {\n      if (cellSize <= 0.1) return `${x.toFixed(1)},${y.toFixed(1)}`\n      return `${x},${y}`\n    }\n    for (let x = Math.floor(minX); x <= Math.ceil(maxX); x += cellSize) {\n      for (let y = Math.floor(minY); y <= Math.ceil(maxY); y += cellSize) {\n        const point = transformPoint(x, y)\n\n        gridLines.push({\n          name: \"text\",\n          type: \"element\",\n          attributes: {\n            x: (point.x - 2.5).toString(),\n            y: (point.y - 5).toString(),\n            fill: colorMap.schematic.grid,\n            \"font-size\": (\n              (cellSize / 5) *\n              Math.abs(params.transform.a)\n            ).toString(),\n            \"fill-opacity\": \"0.5\",\n            \"text-anchor\": \"middle\",\n            \"dominant-baseline\": \"middle\",\n            \"font-family\": \"sans-serif\",\n          },\n          children: [\n            {\n              type: \"text\",\n              value: formatPoint(x, y),\n              name: \"\",\n              attributes: {},\n              children: [],\n            },\n          ],\n        })\n      }\n    }\n  }\n\n  return {\n    name: \"g\",\n    value: \"\",\n    type: \"element\",\n    attributes: { class: \"grid\" },\n    children: gridLines,\n  }\n}\n","import { colorMap } from \"lib/utils/colors\"\nimport type { INode as SvgObject } from \"svgson\"\nimport { applyToPoint, type Matrix } from \"transformation-matrix\"\n\ninterface LabeledPoint {\n  x: number\n  y: number\n  label?: string\n}\n\nexport function drawSchematicLabeledPoints(params: {\n  points: LabeledPoint[]\n  transform: Matrix\n}): SvgObject {\n  const { points, transform } = params\n  const labeledPointsGroup: any[] = []\n\n  for (const point of points) {\n    // Transform offset points for X marker\n    const [x1, y1] = applyToPoint(transform, [point.x - 0.1, point.y - 0.1])\n    const [x2, y2] = applyToPoint(transform, [point.x + 0.1, point.y + 0.1])\n    const [x3, y3] = applyToPoint(transform, [point.x - 0.1, point.y + 0.1])\n    const [x4, y4] = applyToPoint(transform, [point.x + 0.1, point.y - 0.1])\n\n    // Add X marker\n    labeledPointsGroup.push({\n      name: \"path\",\n      type: \"element\",\n      attributes: {\n        d: `M${x1},${y1} L${x2},${y2} M${x3},${y3} L${x4},${y4}`,\n        stroke: colorMap.schematic.grid,\n        \"stroke-width\": (0.02 * Math.abs(transform.a)).toString(),\n        \"stroke-opacity\": \"0.7\",\n      },\n    })\n\n    // Transform label position\n    const [labelX, labelY] = applyToPoint(transform, [\n      point.x + 0.15,\n      point.y - 0.15,\n    ])\n\n    // Add label\n    labeledPointsGroup.push({\n      name: \"text\",\n      type: \"element\",\n      attributes: {\n        x: labelX.toString(),\n        y: labelY.toString(),\n        fill: colorMap.schematic.grid,\n        \"font-size\": (0.1 * Math.abs(transform.a)).toString(),\n        \"fill-opacity\": \"0.7\",\n        \"text-anchor\": \"start\",\n        \"font-family\": \"sans-serif\",\n        \"dominant-baseline\": \"middle\",\n      },\n      children: [\n        {\n          type: \"text\",\n          value: point.label || `(${point.x},${point.y})`,\n          name: \"\",\n          attributes: {},\n          children: [],\n        },\n      ],\n    })\n  }\n\n  return {\n    name: \"g\",\n    value: \"\",\n    type: \"element\",\n    attributes: { class: \"labeled-points\" },\n    children: labeledPointsGroup,\n  }\n}\n","// https://claude.ai/share/5e327d90-627f-48d5-9a51-ba6117479007\nexport const arialTextMetrics = {\n  \"0\": {\n    width: 13,\n    height: 27,\n    ascent: 22,\n    descent: 5,\n    left: -1,\n    right: 12,\n  },\n  \"1\": {\n    width: 13,\n    height: 27,\n    ascent: 22,\n    descent: 5,\n    left: -3,\n    right: 9,\n  },\n  \"2\": {\n    width: 13,\n    height: 27,\n    ascent: 22,\n    descent: 5,\n    left: -1,\n    right: 12,\n  },\n  \"3\": {\n    width: 13,\n    height: 27,\n    ascent: 22,\n    descent: 5,\n    left: -1,\n    right: 12,\n  },\n  \"4\": {\n    width: 13,\n    height: 27,\n    ascent: 22,\n    descent: 5,\n    left: 0,\n    right: 12,\n  },\n  \"5\": {\n    width: 13,\n    height: 27,\n    ascent: 22,\n    descent: 5,\n    left: -1,\n    right: 12,\n  },\n  \"6\": {\n    width: 13,\n    height: 27,\n    ascent: 22,\n    descent: 5,\n    left: -1,\n    right: 12,\n  },\n  \"7\": {\n    width: 13,\n    height: 27,\n    ascent: 22,\n    descent: 5,\n    left: -1,\n    right: 12,\n  },\n  \"8\": {\n    width: 13,\n    height: 27,\n    ascent: 22,\n    descent: 5,\n    left: -1,\n    right: 12,\n  },\n  \"9\": {\n    width: 13,\n    height: 27,\n    ascent: 22,\n    descent: 5,\n    left: -1,\n    right: 12,\n  },\n  \" \": {\n    width: 7,\n    height: 27,\n    ascent: 22,\n    descent: 5,\n    left: 0,\n    right: 0,\n  },\n  \"!\": {\n    width: 7,\n    height: 27,\n    ascent: 22,\n    descent: 5,\n    left: -2,\n    right: 5,\n  },\n  '\"': {\n    width: 9,\n    height: 27,\n    ascent: 22,\n    descent: 5,\n    left: -1,\n    right: 7,\n  },\n  \"#\": {\n    width: 13,\n    height: 27,\n    ascent: 22,\n    descent: 5,\n    left: 0,\n    right: 13,\n  },\n  $: {\n    width: 13,\n    height: 27,\n    ascent: 22,\n    descent: 5,\n    left: -1,\n    right: 12,\n  },\n  \"%\": {\n    width: 21,\n    height: 27,\n    ascent: 22,\n    descent: 5,\n    left: -1,\n    right: 20,\n  },\n  \"&\": {\n    width: 16,\n    height: 27,\n    ascent: 22,\n    descent: 5,\n    left: -1,\n    right: 15,\n  },\n  \"'\": {\n    width: 5,\n    height: 27,\n    ascent: 22,\n    descent: 5,\n    left: -1,\n    right: 3,\n  },\n  \"(\": {\n    width: 8,\n    height: 27,\n    ascent: 22,\n    descent: 5,\n    left: -1,\n    right: 7,\n  },\n  \")\": {\n    width: 8,\n    height: 27,\n    ascent: 22,\n    descent: 5,\n    left: -1,\n    right: 7,\n  },\n  \"*\": {\n    width: 9,\n    height: 27,\n    ascent: 22,\n    descent: 5,\n    left: -1,\n    right: 8,\n  },\n  \"+\": {\n    width: 14,\n    height: 27,\n    ascent: 22,\n    descent: 5,\n    left: -1,\n    right: 13,\n  },\n  \",\": {\n    width: 7,\n    height: 27,\n    ascent: 22,\n    descent: 5,\n    left: -2,\n    right: 5,\n  },\n  \"-\": {\n    width: 8,\n    height: 27,\n    ascent: 22,\n    descent: 5,\n    left: -1,\n    right: 7,\n  },\n  \".\": {\n    width: 7,\n    height: 27,\n    ascent: 22,\n    descent: 5,\n    left: -2,\n    right: 5,\n  },\n  \"/\": {\n    width: 7,\n    height: 27,\n    ascent: 22,\n    descent: 5,\n    left: 0,\n    right: 7,\n  },\n  \":\": {\n    width: 7,\n    height: 27,\n    ascent: 22,\n    descent: 5,\n    left: -2,\n    right: 5,\n  },\n  \";\": {\n    width: 7,\n    height: 27,\n    ascent: 22,\n    descent: 5,\n    left: -2,\n    right: 5,\n  },\n  \"<\": {\n    width: 14,\n    height: 27,\n    ascent: 22,\n    descent: 5,\n    left: -1,\n    right: 13,\n  },\n  \"=\": {\n    width: 14,\n    height: 27,\n    ascent: 22,\n    descent: 5,\n    left: -1,\n    right: 13,\n  },\n  \">\": {\n    width: 14,\n    height: 27,\n    ascent: 22,\n    descent: 5,\n    left: -1,\n    right: 13,\n  },\n  \"?\": {\n    width: 13,\n    height: 27,\n    ascent: 22,\n    descent: 5,\n    left: -1,\n    right: 12,\n  },\n  \"@\": {\n    width: 24,\n    height: 27,\n    ascent: 22,\n    descent: 5,\n    left: -1,\n    right: 23,\n  },\n  A: {\n    width: 16,\n    height: 27,\n    ascent: 22,\n    descent: 5,\n    left: 0,\n    right: 16,\n  },\n  B: {\n    width: 16,\n    height: 27,\n    ascent: 22,\n    descent: 5,\n    left: -2,\n    right: 15,\n  },\n  C: {\n    width: 17,\n    height: 27,\n    ascent: 22,\n    descent: 5,\n    left: -1,\n    right: 16,\n  },\n  D: {\n    width: 17,\n    height: 27,\n    ascent: 22,\n    descent: 5,\n    left: -2,\n    right: 16,\n  },\n  E: {\n    width: 16,\n    height: 27,\n    ascent: 22,\n    descent: 5,\n    left: -2,\n    right: 15,\n  },\n  F: {\n    width: 15,\n    height: 27,\n    ascent: 22,\n    descent: 5,\n    left: -2,\n    right: 14,\n  },\n  G: {\n    width: 19,\n    height: 27,\n    ascent: 22,\n    descent: 5,\n    left: -1,\n    right: 17,\n  },\n  H: {\n    width: 17,\n    height: 27,\n    ascent: 22,\n    descent: 5,\n    left: -2,\n    right: 15,\n  },\n  I: {\n    width: 7,\n    height: 27,\n    ascent: 22,\n    descent: 5,\n    left: -2,\n    right: 5,\n  },\n  J: {\n    width: 12,\n    height: 27,\n    ascent: 22,\n    descent: 5,\n    left: -1,\n    right: 10,\n  },\n  K: {\n    width: 16,\n    height: 27,\n    ascent: 22,\n    descent: 5,\n    left: -2,\n    right: 16,\n  },\n  L: {\n    width: 13,\n    height: 27,\n    ascent: 22,\n    descent: 5,\n    left: -2,\n    right: 12,\n  },\n  M: {\n    width: 20,\n    height: 27,\n    ascent: 22,\n    descent: 5,\n    left: -2,\n    right: 18,\n  },\n  N: {\n    width: 17,\n    height: 27,\n    ascent: 22,\n    descent: 5,\n    left: -2,\n    right: 15,\n  },\n  O: {\n    width: 19,\n    height: 27,\n    ascent: 22,\n    descent: 5,\n    left: -1,\n    right: 18,\n  },\n  P: {\n    width: 16,\n    height: 27,\n    ascent: 22,\n    descent: 5,\n    left: -2,\n    right: 15,\n  },\n  Q: {\n    width: 19,\n    height: 27,\n    ascent: 22,\n    descent: 5,\n    left: -1,\n    right: 18,\n  },\n  R: {\n    width: 17,\n    height: 27,\n    ascent: 22,\n    descent: 5,\n    left: -2,\n    right: 17,\n  },\n  S: {\n    width: 16,\n    height: 27,\n    ascent: 22,\n    descent: 5,\n    left: -1,\n    right: 15,\n  },\n  T: {\n    width: 15,\n    height: 27,\n    ascent: 22,\n    descent: 5,\n    left: -1,\n    right: 14,\n  },\n  U: {\n    width: 17,\n    height: 27,\n    ascent: 22,\n    descent: 5,\n    left: -2,\n    right: 15,\n  },\n  V: {\n    width: 16,\n    height: 27,\n    ascent: 22,\n    descent: 5,\n    left: 0,\n    right: 16,\n  },\n  W: {\n    width: 23,\n    height: 27,\n    ascent: 22,\n    descent: 5,\n    left: 0,\n    right: 22,\n  },\n  X: {\n    width: 16,\n    height: 27,\n    ascent: 22,\n    descent: 5,\n    left: 0,\n    right: 16,\n  },\n  Y: {\n    width: 16,\n    height: 27,\n    ascent: 22,\n    descent: 5,\n    left: 0,\n    right: 16,\n  },\n  Z: {\n    width: 15,\n    height: 27,\n    ascent: 22,\n    descent: 5,\n    left: 0,\n    right: 14,\n  },\n  \"[\": {\n    width: 7,\n    height: 27,\n    ascent: 22,\n    descent: 5,\n    left: -2,\n    right: 6,\n  },\n  \"\\\\\": {\n    width: 7,\n    height: 27,\n    ascent: 22,\n    descent: 5,\n    left: 0,\n    right: 7,\n  },\n  \"]\": {\n    width: 7,\n    height: 27,\n    ascent: 22,\n    descent: 5,\n    left: 0,\n    right: 5,\n  },\n  \"^\": {\n    width: 11,\n    height: 27,\n    ascent: 22,\n    descent: 5,\n    left: -1,\n    right: 11,\n  },\n  _: {\n    width: 13,\n    height: 27,\n    ascent: 22,\n    descent: 5,\n    left: 0,\n    right: 14,\n  },\n  \"`\": {\n    width: 8,\n    height: 27,\n    ascent: 22,\n    descent: 5,\n    left: -1,\n    right: 5,\n  },\n  a: {\n    width: 13,\n    height: 27,\n    ascent: 22,\n    descent: 5,\n    left: -1,\n    right: 12,\n  },\n  b: {\n    width: 13,\n    height: 27,\n    ascent: 22,\n    descent: 5,\n    left: -2,\n    right: 12,\n  },\n  c: {\n    width: 12,\n    height: 27,\n    ascent: 22,\n    descent: 5,\n    left: -1,\n    right: 12,\n  },\n  d: {\n    width: 13,\n    height: 27,\n    ascent: 22,\n    descent: 5,\n    left: -1,\n    right: 12,\n  },\n  e: {\n    width: 13,\n    height: 27,\n    ascent: 22,\n    descent: 5,\n    left: -1,\n    right: 12,\n  },\n  f: {\n    width: 7,\n    height: 27,\n    ascent: 22,\n    descent: 5,\n    left: 0,\n    right: 8,\n  },\n  g: {\n    width: 13,\n    height: 27,\n    ascent: 22,\n    descent: 5,\n    left: -1,\n    right: 12,\n  },\n  h: {\n    width: 13,\n    height: 27,\n    ascent: 22,\n    descent: 5,\n    left: -2,\n    right: 12,\n  },\n  i: {\n    width: 5,\n    height: 27,\n    ascent: 22,\n    descent: 5,\n    left: -2,\n    right: 4,\n  },\n  j: {\n    width: 5,\n    height: 27,\n    ascent: 22,\n    descent: 5,\n    left: 1,\n    right: 4,\n  },\n  k: {\n    width: 12,\n    height: 27,\n    ascent: 22,\n    descent: 5,\n    left: -2,\n    right: 12,\n  },\n  l: {\n    width: 5,\n    height: 27,\n    ascent: 22,\n    descent: 5,\n    left: -2,\n    right: 4,\n  },\n  m: {\n    width: 20,\n    height: 27,\n    ascent: 22,\n    descent: 5,\n    left: -2,\n    right: 18,\n  },\n  n: {\n    width: 13,\n    height: 27,\n    ascent: 22,\n    descent: 5,\n    left: -2,\n    right: 12,\n  },\n  o: {\n    width: 13,\n    height: 27,\n    ascent: 22,\n    descent: 5,\n    left: -1,\n    right: 12,\n  },\n  p: {\n    width: 13,\n    height: 27,\n    ascent: 22,\n    descent: 5,\n    left: -2,\n    right: 12,\n  },\n  q: {\n    width: 13,\n    height: 27,\n    ascent: 22,\n    descent: 5,\n    left: -1,\n    right: 12,\n  },\n  r: {\n    width: 8,\n    height: 27,\n    ascent: 22,\n    descent: 5,\n    left: -2,\n    right: 8,\n  },\n  s: {\n    width: 12,\n    height: 27,\n    ascent: 22,\n    descent: 5,\n    left: -1,\n    right: 11,\n  },\n  t: {\n    width: 7,\n    height: 27,\n    ascent: 22,\n    descent: 5,\n    left: 0,\n    right: 6,\n  },\n  u: {\n    width: 13,\n    height: 27,\n    ascent: 22,\n    descent: 5,\n    left: -2,\n    right: 12,\n  },\n  v: {\n    width: 12,\n    height: 27,\n    ascent: 22,\n    descent: 5,\n    left: 0,\n    right: 12,\n  },\n  w: {\n    width: 17,\n    height: 27,\n    ascent: 22,\n    descent: 5,\n    left: 0,\n    right: 17,\n  },\n  x: {\n    width: 12,\n    height: 27,\n    ascent: 22,\n    descent: 5,\n    left: 0,\n    right: 12,\n  },\n  y: {\n    width: 12,\n    height: 27,\n    ascent: 22,\n    descent: 5,\n    left: 0,\n    right: 12,\n  },\n  z: {\n    width: 12,\n    height: 27,\n    ascent: 22,\n    descent: 5,\n    left: 0,\n    right: 11,\n  },\n  \"{\": {\n    width: 8,\n    height: 27,\n    ascent: 22,\n    descent: 5,\n    left: -1,\n    right: 7,\n  },\n  \"|\": {\n    width: 6,\n    height: 27,\n    ascent: 22,\n    descent: 5,\n    left: -2,\n    right: 4,\n  },\n  \"}\": {\n    width: 8,\n    height: 27,\n    ascent: 22,\n    descent: 5,\n    left: -1,\n    right: 7,\n  },\n  \"~\": {\n    width: 14,\n    height: 27,\n    ascent: 22,\n    descent: 5,\n    left: -1,\n    right: 13,\n  },\n}\n","import { arialTextMetrics } from \"./arial-text-metrics\"\n\nexport const estimateTextWidth = (text: string): number => {\n  if (!text) return 0\n\n  let totalWidth = 0\n  for (const char of text) {\n    const metrics = arialTextMetrics[char as keyof typeof arialTextMetrics]\n    if (metrics) {\n      totalWidth += metrics.width\n    } else {\n      // Default width for unknown characters\n      totalWidth += arialTextMetrics[\"?\"].width\n    }\n  }\n\n  // Return width normalized to font size 1\n  return totalWidth / 27 // Normalize by font height from metrics\n}\n","import type {\n  AnyCircuitElement,\n  SchematicTable,\n  SchematicTableCell,\n} from \"circuit-json\"\nimport { getSchMmFontSize } from \"lib/utils/get-sch-font-size\"\nimport { estimateTextWidth } from \"./estimate-text-width\"\n\nexport const getTableDimensions = (\n  schematicTable: SchematicTable,\n  circuitJson: AnyCircuitElement[],\n) => {\n  if (\n    schematicTable.column_widths &&\n    schematicTable.column_widths.length > 0 &&\n    schematicTable.row_heights &&\n    schematicTable.row_heights.length > 0\n  ) {\n    const unitToMm = (v: number | string) => {\n      if (typeof v === \"number\") return v\n      if (v.endsWith(\"mm\")) return parseFloat(v)\n      if (v.endsWith(\"in\")) return parseFloat(v) * 25.4\n      return parseFloat(v)\n    }\n    return {\n      column_widths: schematicTable.column_widths.map(unitToMm),\n      row_heights: schematicTable.row_heights.map(unitToMm),\n    }\n  }\n  const cells = circuitJson.filter(\n    (elm): elm is SchematicTableCell =>\n      elm.type === \"schematic_table_cell\" &&\n      elm.schematic_table_id === schematicTable.schematic_table_id,\n  )\n\n  if (cells.length === 0) {\n    return { column_widths: [], row_heights: [] }\n  }\n\n  const numColumns =\n    cells.reduce((max, c) => Math.max(max, c.end_column_index), -1) + 1\n  const numRows =\n    cells.reduce((max, c) => Math.max(max, c.end_row_index), -1) + 1\n\n  const { cell_padding = 0.2 } = schematicTable\n\n  const column_widths = new Array(numColumns).fill(0)\n  const row_heights = new Array(numRows).fill(0)\n\n  // First pass: determine minimum size for each cell\n  const cell_widths: { [key: string]: number } = {}\n  const cell_heights: { [key: string]: number } = {}\n\n  for (const cell of cells) {\n    const fontSizeMm = getSchMmFontSize(\"reference_designator\", cell.font_size)\n    const textWidthMm = estimateTextWidth(cell.text ?? \"\") * fontSizeMm\n    const requiredWidth = textWidthMm + 2 * cell_padding\n    const requiredHeight = fontSizeMm * 1.2 + 2 * cell_padding\n\n    const key = `${cell.start_row_index}-${cell.start_column_index}`\n    cell_widths[key] = requiredWidth\n    cell_heights[key] = requiredHeight\n  }\n\n  // Second pass: set column and row sizes based on the max required\n  for (let i = 0; i < numRows; i++) {\n    for (let j = 0; j < numColumns; j++) {\n      const key = `${i}-${j}`\n      if (cell_widths[key] && cell_widths[key]! > column_widths[j]!) {\n        column_widths[j] = cell_widths[key]!\n      }\n      if (cell_heights[key] && cell_heights[key]! > row_heights[i]!) {\n        row_heights[i] = cell_heights[key]!\n      }\n    }\n  }\n\n  // Third pass: adjust for merged cells\n  for (const cell of cells) {\n    if (\n      cell.start_column_index === cell.end_column_index &&\n      cell.start_row_index === cell.end_row_index\n    )\n      continue\n\n    const key = `${cell.start_row_index}-${cell.start_column_index}`\n    const requiredWidth = cell_widths[key]\n    const requiredHeight = cell_heights[key]\n\n    if (requiredWidth === undefined || requiredHeight === undefined) continue\n\n    let currentWidth = 0\n    for (let i = cell.start_column_index; i <= cell.end_column_index; i++) {\n      currentWidth += column_widths[i]!\n    }\n\n    if (requiredWidth > currentWidth) {\n      const diff = requiredWidth - currentWidth\n      const extraPerColumn =\n        diff / (cell.end_column_index - cell.start_column_index + 1)\n      for (let i = cell.start_column_index; i <= cell.end_column_index; i++) {\n        column_widths[i] += extraPerColumn\n      }\n    }\n\n    let currentHeight = 0\n    for (let i = cell.start_row_index; i <= cell.end_row_index; i++) {\n      currentHeight += row_heights[i]!\n    }\n\n    if (requiredHeight > currentHeight) {\n      const diff = requiredHeight - currentHeight\n      const extraPerRow = diff / (cell.end_row_index - cell.start_row_index + 1)\n      for (let i = cell.start_row_index; i <= cell.end_row_index; i++) {\n        row_heights[i] += extraPerRow\n      }\n    }\n  }\n\n  return { column_widths, row_heights }\n}\n","/**\n * Given a side, gives you the unit vector you would move in if you were coming\n * towards that edge from the outside. This is the same as the unit vector from\n * a port to the edge of a schematic box. This function assumes cartesian\n * coordinates (Y positive is up)\n */\nexport const getUnitVectorFromOutsideToEdge = (\n  side: \"top\" | \"bottom\" | \"left\" | \"right\",\n) => {\n  switch (side) {\n    case \"top\":\n      return { x: 0, y: -1 }\n    case \"bottom\":\n      return { x: 0, y: 1 }\n    case \"left\":\n      return { x: 1, y: 0 }\n    case \"right\":\n      return { x: -1, y: 0 }\n  }\n  throw new Error(`Invalid side: ${side}`)\n}\n","import type { SchematicNetLabel } from \"circuit-json\"\nimport { getUnitVectorFromOutsideToEdge } from \"lib/utils/get-unit-vector-from-outside-to-edge\"\nimport { type Matrix } from \"transformation-matrix\"\nimport { type TextPrimitive } from \"schematic-symbols\"\n\nexport const ARROW_POINT_WIDTH_FSR = 0.3\nexport const END_PADDING_FSR = 0.3\nexport const END_PADDING_EXTRA_PER_CHARACTER_FSR = 0.06\n\nexport const ninePointAnchorToTextAnchor: Record<\n  TextPrimitive[\"anchor\"],\n  \"middle\" | \"start\" | \"end\"\n> = {\n  top_left: \"start\",\n  top_right: \"end\",\n  middle_left: \"start\",\n  middle_right: \"end\",\n  bottom_left: \"start\",\n  bottom_right: \"end\",\n  center: \"middle\",\n  middle_top: \"middle\",\n  middle_bottom: \"middle\",\n}\n\nexport const ninePointAnchorToDominantBaseline: Record<\n  TextPrimitive[\"anchor\"],\n  \"hanging\" | \"ideographic\" | \"middle\"\n> = {\n  top_left: \"hanging\",\n  top_right: \"hanging\",\n  bottom_left: \"ideographic\",\n  bottom_right: \"ideographic\",\n  center: \"middle\",\n  middle_left: \"middle\",\n  middle_right: \"middle\",\n  middle_top: \"hanging\",\n  middle_bottom: \"ideographic\",\n}\n\nexport function getPathRotation(anchorSide: string): number {\n  const rotationMap = {\n    left: 180,\n    top: 90,\n    bottom: -90,\n    right: 0,\n  }\n  return rotationMap[anchorSide as keyof typeof rotationMap] ?? 0\n}\n\nexport function getTextOffsets(pathRotation: number, transform: Matrix) {\n  const scale = Math.abs(transform.a)\n  const baseOffset = scale * 0.1\n\n  const rotationOffsetMap: Record<string, { x: number; y: number }> = {\n    \"0\": { x: baseOffset * 0.8, y: -baseOffset }, // Left\n    \"-90\": { x: baseOffset * -3.5, y: baseOffset * 2.8 }, // Top\n    \"90\": { x: -baseOffset * -3.55, y: -baseOffset * 4.2 }, // Bottom\n    \"180\": { x: -baseOffset * 0.85, y: -baseOffset * 0.2 }, // Right\n  }\n\n  return rotationOffsetMap[pathRotation.toString()] || { x: 0, y: 0 }\n}\n\nexport function calculateAnchorPosition(\n  schNetLabel: SchematicNetLabel,\n  fontSizeMm: number,\n  textWidthFSR: number,\n) {\n  const fullWidthFsr =\n    textWidthFSR +\n    ARROW_POINT_WIDTH_FSR * 2 +\n    END_PADDING_EXTRA_PER_CHARACTER_FSR * schNetLabel.text.length +\n    END_PADDING_FSR\n\n  const realTextGrowthVec = getUnitVectorFromOutsideToEdge(\n    schNetLabel.anchor_side,\n  )\n\n  return (\n    schNetLabel.anchor_position ?? {\n      x:\n        schNetLabel.center.x -\n        (realTextGrowthVec.x * fullWidthFsr * fontSizeMm) / 2,\n      y:\n        schNetLabel.center.y -\n        (realTextGrowthVec.y * fullWidthFsr * fontSizeMm) / 2,\n    }\n  )\n}\n","import type { AnyCircuitElement } from \"circuit-json\"\nimport { getTableDimensions } from \"./get-table-dimensions\"\nimport { getSchMmFontSize } from \"lib/utils/get-sch-font-size\"\nimport {\n  ARROW_POINT_WIDTH_FSR,\n  END_PADDING_EXTRA_PER_CHARACTER_FSR,\n  END_PADDING_FSR,\n  getPathRotation,\n  calculateAnchorPosition,\n} from \"lib/utils/net-label-utils\"\nimport { getUnitVectorFromOutsideToEdge } from \"lib/utils/get-unit-vector-from-outside-to-edge\"\nimport { estimateTextWidth } from \"./estimate-text-width\"\ninterface Bounds {\n  minX: number\n  minY: number\n  maxX: number\n  maxY: number\n}\n\nexport function getSchematicBoundsFromCircuitJson(\n  soup: AnyCircuitElement[],\n  padding = 0.5,\n): Bounds {\n  let minX = Number.POSITIVE_INFINITY\n  let minY = Number.POSITIVE_INFINITY\n  let maxX = Number.NEGATIVE_INFINITY\n  let maxY = Number.NEGATIVE_INFINITY\n\n  const portSize = 0.2\n\n  // Find the bounds\n  for (const item of soup) {\n    if (item.type === \"schematic_component\") {\n      updateBounds(item.center, item.size, 0)\n    } else if (item.type === \"schematic_port\") {\n      updateBounds(item.center, { width: portSize, height: portSize }, 0)\n    } else if (item.type === \"schematic_debug_object\") {\n      if (item.shape === \"rect\") {\n        updateBounds(item.center, item.size, 0)\n      } else if (item.shape === \"line\") {\n        updateBounds(item.start, { width: 0.1, height: 0.1 }, 0)\n        updateBounds(item.end, { width: 0.1, height: 0.1 }, 0)\n      }\n    } else if (item.type === \"schematic_net_label\") {\n      const fontSizeMm = getSchMmFontSize(\"net_label\")\n      const textWidth = estimateTextWidth(item.text || \"\")\n      const fullWidthFsr =\n        textWidth +\n        ARROW_POINT_WIDTH_FSR * 2 +\n        END_PADDING_EXTRA_PER_CHARACTER_FSR * (item.text?.length || 0) +\n        END_PADDING_FSR\n      const width = fullWidthFsr * fontSizeMm\n      const height = 1.2 * fontSizeMm\n      const rotation = (getPathRotation(item.anchor_side) / 180) * Math.PI\n\n      const anchorPosition = calculateAnchorPosition(\n        item,\n        fontSizeMm,\n        textWidth,\n      )\n      const growthVec = getUnitVectorFromOutsideToEdge(item.anchor_side)\n      const center = {\n        x: anchorPosition.x + (growthVec.x * width) / 2,\n        y: anchorPosition.y + (growthVec.y * width) / 2,\n      }\n\n      updateBounds(center, { width, height }, rotation)\n    } else if (item.type === \"schematic_trace\") {\n      for (const edge of item.edges) {\n        updateBounds(edge.from, { width: 0.1, height: 0.1 }, 0)\n        updateBounds(edge.to, { width: 0.1, height: 0.1 }, 0)\n      }\n    } else if (item.type === \"schematic_text\") {\n      const textType = \"reference_designator\"\n      const fontSize = getSchMmFontSize(textType, item.font_size) ?? 0.18\n      const text = item.text ?? \"\"\n      const width = text.length * fontSize\n      const height = fontSize\n      updateBounds(item.position, { width, height }, item.rotation ?? 0)\n    } else if (item.type === \"schematic_voltage_probe\") {\n      updateBounds(item.position, { width: 0.2, height: 0.4 }, 0) // width and height of the probe (Arrow)\n    } else if (item.type === \"schematic_box\") {\n      updateBounds(\n        {\n          x: item.x + item.width / 2,\n          y: item.y + item.height / 2,\n        },\n        { width: item.width, height: item.height },\n        0,\n      )\n    } else if (item.type === \"schematic_table\") {\n      const { column_widths, row_heights } = getTableDimensions(item, soup)\n      const totalWidth = column_widths.reduce((a, b) => a + b, 0)\n      const totalHeight = row_heights.reduce((a, b) => a + b, 0)\n      const anchor = item.anchor ?? \"center\"\n\n      let topLeftX = item.anchor_position.x\n      let topLeftY = item.anchor_position.y\n\n      // Horizontal alignment\n      if (anchor.includes(\"center\")) {\n        topLeftX -= totalWidth / 2\n      } else if (anchor.includes(\"right\")) {\n        topLeftX -= totalWidth\n      }\n\n      // Vertical alignment\n      if (anchor.includes(\"center\")) {\n        topLeftY += totalHeight / 2\n      } else if (anchor.includes(\"bottom\")) {\n        topLeftY += totalHeight\n      }\n\n      const centerX = topLeftX + totalWidth / 2\n      const centerY = topLeftY - totalHeight / 2\n\n      updateBounds(\n        { x: centerX, y: centerY },\n        { width: totalWidth, height: totalHeight },\n        0,\n      )\n    }\n  }\n\n  // Add padding to bounds\n  minX -= padding\n  minY -= padding\n  maxX += padding\n  maxY += padding\n\n  return { minX, minY, maxX, maxY }\n\n  function updateBounds(center: any, size: any, rotation: number) {\n    const corners = [\n      { x: -size.width / 2, y: -size.height / 2 },\n      { x: size.width / 2, y: -size.height / 2 },\n      { x: size.width / 2, y: size.height / 2 },\n      { x: -size.width / 2, y: size.height / 2 },\n    ]\n\n    for (const corner of corners) {\n      const rotatedX =\n        corner.x * Math.cos(rotation) - corner.y * Math.sin(rotation) + center.x\n      const rotatedY =\n        corner.x * Math.sin(rotation) + corner.y * Math.cos(rotation) + center.y\n      minX = Math.min(minX, rotatedX)\n      minY = Math.min(minY, rotatedY)\n      maxX = Math.max(maxX, rotatedX)\n      maxY = Math.max(maxY, rotatedY)\n    }\n  }\n}\n","import { su } from \"@tscircuit/circuit-json-util\"\nimport type {\n  AnyCircuitElement,\n  SchematicComponent,\n  SchematicPort,\n} from \"circuit-json\"\nimport type { SvgObject } from \"lib/svg-object\"\nimport type { ColorMap } from \"lib/utils/colors\"\nimport { getSvg, symbols, type SchSymbol } from \"schematic-symbols\"\nimport { parseSync } from \"svgson\"\nimport {\n  applyToPoint,\n  compose,\n  translate,\n  type Matrix,\n} from \"transformation-matrix\"\nimport { getSchStrokeSize } from \"lib/utils/get-sch-stroke-size\"\nimport { matchSchPortsToSymbolPorts } from \"lib/utils/match-sch-ports-with-symbol-ports\"\nimport { pointPairsToMatrix } from \"lib/utils/point-pairs-to-matrix\"\nimport { getSchScreenFontSize } from \"lib/utils/get-sch-font-size\"\nimport type { TextPrimitive } from \"schematic-symbols\"\nimport { createSvgSchErrorText } from \"./create-svg-error-text\"\nimport { isSourcePortConnected } from \"lib/utils/is-source-port-connected\"\n\nconst ninePointAnchorToTextAnchor: Record<\n  TextPrimitive[\"anchor\"],\n  \"middle\" | \"start\" | \"end\"\n> = {\n  top_left: \"start\",\n  top_right: \"end\",\n  middle_left: \"start\",\n  middle_right: \"end\",\n  bottom_left: \"start\",\n  bottom_right: \"end\",\n  center: \"middle\",\n  middle_top: \"middle\",\n  middle_bottom: \"middle\",\n}\n\nconst ninePointAnchorToDominantBaseline: Record<\n  TextPrimitive[\"anchor\"],\n  \"hanging\" | \"ideographic\" | \"middle\"\n> = {\n  top_left: \"hanging\",\n  top_right: \"hanging\",\n  bottom_left: \"ideographic\",\n  bottom_right: \"ideographic\",\n  center: \"middle\",\n  middle_left: \"middle\",\n  middle_right: \"middle\",\n  middle_top: \"hanging\",\n  middle_bottom: \"ideographic\",\n}\n\nexport const createSvgObjectsFromSchematicComponentWithSymbol = ({\n  component: schComponent,\n  transform: realToScreenTransform,\n  circuitJson,\n  colorMap,\n}: {\n  component: SchematicComponent\n  transform: Matrix\n  circuitJson: AnyCircuitElement[]\n  colorMap: ColorMap\n}): SvgObject[] => {\n  const svgObjects: SvgObject[] = []\n\n  const symbol: SchSymbol = (symbols as any)[schComponent.symbol_name!]\n\n  if (!symbol) {\n    return [\n      createSvgSchErrorText({\n        text: `Symbol not found: ${schComponent.symbol_name}`,\n        realCenter: schComponent.center,\n        realToScreenTransform,\n      }),\n    ]\n  }\n\n  const schPorts = su(circuitJson as any).schematic_port.list({\n    schematic_component_id: schComponent.schematic_component_id,\n  }) as SchematicPort[]\n\n  const srcComponent = su(circuitJson as any).source_component.get(\n    schComponent.source_component_id,\n  )\n  // Match schPorts to symbol ports using angle from schematic component center\n  const schPortsWithSymbolPorts = matchSchPortsToSymbolPorts({\n    schPorts,\n    symbol,\n    schComponent,\n  })\n\n  if (!schPortsWithSymbolPorts[0]) {\n    return [\n      createSvgSchErrorText({\n        text: `Could not match ports for symbol ${schComponent.symbol_name}`,\n        realCenter: schComponent.center,\n        realToScreenTransform,\n      }),\n    ]\n  }\n\n  const transformFromSymbolToReal = pointPairsToMatrix(\n    schPortsWithSymbolPorts[1]?.symbolPort ?? symbol.center,\n    schPortsWithSymbolPorts[1]?.schPort.center ?? schComponent.center,\n    schPortsWithSymbolPorts[0].symbolPort,\n    schPortsWithSymbolPorts[0].schPort.center,\n  )\n\n  const paths = symbol.primitives.filter((p) => p.type === \"path\")\n  const texts = symbol.primitives.filter((p) => p.type === \"text\")\n  const circles = symbol.primitives.filter((p) => p.type === \"circle\")\n  const boxes = symbol.primitives.filter((p) => p.type === \"box\")\n\n  const connectedSymbolPorts = new Set<SchSymbol[\"ports\"][number]>()\n  for (const match of schPortsWithSymbolPorts) {\n    if (isSourcePortConnected(circuitJson, match.schPort.source_port_id)) {\n      connectedSymbolPorts.add(match.symbolPort)\n    }\n  }\n\n  const bounds = {\n    minX: Math.min(...paths.flatMap((p) => p.points.map((pt) => pt.x))),\n    maxX: Math.max(...paths.flatMap((p) => p.points.map((pt) => pt.x))),\n    minY: Math.min(...paths.flatMap((p) => p.points.map((pt) => pt.y))),\n    maxY: Math.max(...paths.flatMap((p) => p.points.map((pt) => pt.y))),\n  }\n  const [screenMinX, screenMinY] = applyToPoint(\n    compose(realToScreenTransform, transformFromSymbolToReal),\n    [bounds.minX, bounds.minY],\n  )\n\n  const [screenMaxX, screenMaxY] = applyToPoint(\n    compose(realToScreenTransform, transformFromSymbolToReal),\n    [bounds.maxX, bounds.maxY],\n  )\n  const rectHeight = Math.abs(screenMaxY - screenMinY)\n  const rectY = Math.min(screenMinY, screenMaxY)\n  const rectWidth = Math.abs(screenMaxX - screenMinX)\n  const rectX = Math.min(screenMinX, screenMaxX)\n  svgObjects.push({\n    name: \"rect\",\n    type: \"element\",\n    value: \"\",\n    attributes: {\n      class: \"component-overlay\",\n      x: rectX.toString(),\n      y: rectY.toString(),\n      width: rectWidth.toString(),\n      height: rectHeight.toString(),\n      fill: \"transparent\",\n    },\n    children: [],\n  })\n  for (const path of paths) {\n    const { points, color, closed, fill } = path\n    svgObjects.push({\n      type: \"element\",\n      name: \"path\",\n      attributes: {\n        d:\n          points\n            .map((p, i) => {\n              const [x, y] = applyToPoint(\n                compose(realToScreenTransform, transformFromSymbolToReal),\n                [p.x, p.y],\n              )\n              return `${i === 0 ? \"M\" : \"L\"} ${x} ${y}`\n            })\n            .join(\" \") + (closed ? \" Z\" : \"\"),\n        stroke: colorMap.schematic.component_outline,\n        fill: \"none\",\n        \"stroke-width\": `${getSchStrokeSize(realToScreenTransform)}px`,\n        \"stroke-linecap\": \"round\",\n      },\n      value: \"\",\n      children: [],\n    })\n  }\n\n  for (const text of texts) {\n    const screenTextPos = applyToPoint(\n      compose(realToScreenTransform, transformFromSymbolToReal),\n      text,\n    )\n\n    let textValue = \"\"\n    if (text.text === \"{REF}\") {\n      textValue = srcComponent?.name ?? \"\"\n    } else if (text.text === \"{VAL}\") {\n      textValue = schComponent.symbol_display_value ?? \"\"\n    }\n\n    const symbolHeight = Math.abs(bounds.maxY - bounds.minY)\n    const offsetFactor = 0.1\n    const baseOffset = symbolHeight * offsetFactor\n    const transformScale = Math.abs(transformFromSymbolToReal.a)\n\n    let verticalOffset = 0\n\n    if (text.anchor.includes(\"bottom\")) {\n      verticalOffset = baseOffset * transformScale\n    } else if (text.anchor.includes(\"top\")) {\n      verticalOffset = -baseOffset * transformScale\n    }\n\n    const dominantBaseline = text.anchor.includes(\"bottom\")\n      ? \"auto\"\n      : text.anchor.includes(\"top\")\n        ? \"hanging\"\n        : \"middle\"\n\n    svgObjects.push({\n      name: \"text\",\n      type: \"element\",\n      attributes: {\n        x: screenTextPos.x.toString(),\n        y: (screenTextPos.y + verticalOffset).toString(),\n        fill: colorMap.schematic.label_local,\n        \"font-family\": \"sans-serif\",\n        \"text-anchor\": ninePointAnchorToTextAnchor[text.anchor],\n        \"dominant-baseline\": dominantBaseline,\n        \"font-size\": `${getSchScreenFontSize(realToScreenTransform, \"reference_designator\")}px`,\n      },\n      value: \"\",\n      children: [\n        {\n          type: \"text\",\n          value: textValue,\n          name: \"\",\n          attributes: {},\n          children: [],\n        },\n      ],\n    })\n  }\n\n  // Draw Boxes\n\n  for (const box of boxes) {\n    const screenBoxPos = applyToPoint(\n      compose(realToScreenTransform, transformFromSymbolToReal),\n      box,\n    )\n    const symbolToScreenScale = compose(\n      realToScreenTransform,\n      transformFromSymbolToReal,\n    ).a\n\n    svgObjects.push({\n      name: \"rect\",\n      type: \"element\",\n      attributes: {\n        x: screenBoxPos.x.toString(),\n        y: screenBoxPos.y.toString(),\n        width: (box.width * symbolToScreenScale).toString(),\n        height: (box.height * symbolToScreenScale).toString(),\n        fill: \"red\",\n      },\n      value: \"\",\n      children: [],\n    })\n  }\n\n  // Draw Ports for debugging\n  for (const port of symbol.ports) {\n    if (connectedSymbolPorts.has(port)) continue\n    const screenPortPos = applyToPoint(\n      compose(realToScreenTransform, transformFromSymbolToReal),\n      port,\n    )\n    svgObjects.push({\n      type: \"element\",\n      name: \"circle\",\n      attributes: {\n        cx: screenPortPos.x.toString(),\n        cy: screenPortPos.y.toString(),\n        r: `${Math.abs(realToScreenTransform.a) * 0.02}px`,\n        \"stroke-width\": `${getSchStrokeSize(realToScreenTransform)}px`,\n        fill: \"none\",\n        stroke: colorMap.schematic.component_outline,\n      },\n      value: \"\",\n      children: [],\n    })\n  }\n\n  for (const circle of circles) {\n    const screenCirclePos = applyToPoint(\n      compose(realToScreenTransform, transformFromSymbolToReal),\n      circle,\n    )\n    const screenRadius = Math.abs(circle.radius * realToScreenTransform.a)\n    svgObjects.push({\n      type: \"element\",\n      name: \"circle\",\n      attributes: {\n        cx: screenCirclePos.x.toString(),\n        cy: screenCirclePos.y.toString(),\n        r: `${screenRadius}px`,\n        \"stroke-width\": `${getSchStrokeSize(realToScreenTransform)}px`,\n        fill: \"none\",\n        stroke: colorMap.schematic.component_outline,\n      },\n      value: \"\",\n      children: [],\n    })\n  }\n  return svgObjects\n}\n","import type { Matrix } from \"transformation-matrix\"\n\n// 0.02mm -> 2px\nexport const getSchStrokeSize = (transform: Matrix) => {\n  return Math.abs(transform.a) * 0.02\n}\n","import type { SchematicComponent, SchematicPort } from \"circuit-json\"\nimport type { SchSymbol } from \"schematic-symbols\"\n\n// export const matchSchPortsToSymbolPorts = ({\n//   schPorts,\n//   symbol,\n//   schComponent,\n// }: {\n//   schPorts: SchematicPort[]\n//   schComponent: SchematicComponent\n//   symbol: SchSymbol\n// }): Array<{\n//   schPort: SchematicPort\n//   symbolPort: SchSymbol[\"ports\"][number]\n// }> => {\n//   // schPorts is Array<{ center: { x: number; y: number } }>\n//   // schComponent.center is { x: number; y: number }\n//   // symbol.ports is Array<{ x: number; y: number }>\n//   // symbol.center is { x: number; y: number }\n//   // Use the angles from the schComponent center to the schPorts to match with the angles from the symbol center to the symbol ports\n//   // If a port isn't matched because there are more schPorts than symbolPorts (or vice versa), then the unmatched ports should be ignored (not returned)\n// }\n\n// Helper function to calculate smallest angular difference accounting for wraparound\nconst getAngularDifference = (angle1: number, angle2: number): number => {\n  // Convert from [-π, π] to [0, 2π] for easier comparison\n  const a1 = angle1 < 0 ? angle1 + 2 * Math.PI : angle1\n  const a2 = angle2 < 0 ? angle2 + 2 * Math.PI : angle2\n\n  // Calculate direct difference\n  let diff = Math.abs(a1 - a2)\n  // If the difference is greater than π, then the smaller angle is going the other way around\n  if (diff > Math.PI) {\n    diff = 2 * Math.PI - diff\n  }\n  return diff\n}\n\nexport const matchSchPortsToSymbolPorts = ({\n  schPorts,\n  symbol,\n  schComponent,\n}: {\n  schPorts: SchematicPort[]\n  schComponent: SchematicComponent\n  symbol: SchSymbol\n}): Array<{\n  schPort: SchematicPort\n  symbolPort: SchSymbol[\"ports\"][number]\n}> => {\n  // Calculate angles for schematic ports\n  const schPortAngles = schPorts.map((port) => {\n    const dx = port.center.x - schComponent.center.x\n    const dy = port.center.y - schComponent.center.y\n    return {\n      port,\n      angle: Math.atan2(dy, dx),\n    }\n  })\n\n  // Calculate angles for symbol ports\n  const symbolPortAngles = symbol.ports.map((port) => {\n    const dx = port.x - symbol.center.x\n    const dy = port.y - symbol.center.y\n    return {\n      port,\n      angle: Math.atan2(dy, dx),\n    }\n  })\n\n  // Sort both arrays by angle to help with initial matching\n  // Note: The sorting is less critical now that we handle wraparound properly\n  schPortAngles.sort((a, b) => a.angle - b.angle)\n  symbolPortAngles.sort((a, b) => a.angle - b.angle)\n\n  const matches: Array<{\n    schPort: SchematicPort\n    symbolPort: SchSymbol[\"ports\"][number]\n  }> = []\n\n  // Keep track of used symbol ports to avoid duplicate matches\n  const usedSymbolPorts = new Set<SchSymbol[\"ports\"][number]>()\n\n  // For each schematic port, find the best matching symbol port\n  for (const schPortAngle of schPortAngles) {\n    let bestMatch: {\n      symbolPort: SchSymbol[\"ports\"][number]\n      angleDiff: number\n    } | null = null\n\n    // Compare against all available symbol ports\n    for (const symbolPortAngle of symbolPortAngles) {\n      // Skip if this symbol port is already matched\n      if (usedSymbolPorts.has(symbolPortAngle.port)) continue\n\n      const angleDiff = getAngularDifference(\n        schPortAngle.angle,\n        symbolPortAngle.angle,\n      )\n\n      if (bestMatch === null || angleDiff < bestMatch.angleDiff) {\n        bestMatch = {\n          symbolPort: symbolPortAngle.port,\n          angleDiff,\n        }\n      }\n    }\n\n    // If we found a match and the angular difference is reasonable (e.g., less than 45 degrees)\n    if (bestMatch && bestMatch.angleDiff < Math.PI / 4) {\n      matches.push({\n        schPort: schPortAngle.port,\n        symbolPort: bestMatch.symbolPort,\n      })\n      usedSymbolPorts.add(bestMatch.symbolPort)\n    }\n  }\n\n  return matches\n}\n","import { type Matrix, compose, scale, translate } from \"transformation-matrix\"\n\ntype Point = { x: number; y: number }\n\nexport function pointPairsToMatrix(\n  a1: Point,\n  a2: Point,\n  b1: Point,\n  b2: Point,\n): Matrix {\n  // Calculate the translation based on the first point pair (A -> A')\n  const tx = a2.x - a1.x\n  const ty = a2.y - a1.y\n\n  // Calculate scaling factors using the distances between points\n  const originalDistance = Math.sqrt((b1.x - a1.x) ** 2 + (b1.y - a1.y) ** 2)\n  const transformedDistance = Math.sqrt((b2.x - a2.x) ** 2 + (b2.y - a2.y) ** 2)\n\n  const a = transformedDistance / originalDistance\n\n  // Create and compose the transformations\n  const translateMatrix = translate(tx, ty)\n  const scaleMatrix = scale(a, a)\n\n  return compose(translateMatrix, scaleMatrix)\n}\n","import type { SvgObject } from \"lib/svg-object\"\nimport { getSchScreenFontSize } from \"lib/utils/get-sch-font-size\"\nimport { applyToPoint, type Point, type Matrix } from \"transformation-matrix\"\n\nexport const createSvgSchErrorText = ({\n  text,\n  realCenter,\n  realToScreenTransform,\n}: {\n  text: string\n  realCenter: { x: number; y: number }\n  realToScreenTransform: Matrix\n}): SvgObject => {\n  const screenCenter = applyToPoint(realToScreenTransform, realCenter)\n\n  return {\n    type: \"element\",\n    name: \"text\",\n    value: \"\",\n    attributes: {\n      x: screenCenter.x.toString(),\n      y: screenCenter.y.toString(),\n      fill: \"red\",\n      \"text-anchor\": \"middle\",\n      \"dominant-baseline\": \"middle\",\n      \"font-family\": \"sans-serif\",\n      \"font-size\": `${getSchScreenFontSize(realToScreenTransform, \"error\")}px`,\n    },\n    children: [\n      {\n        type: \"text\",\n        value: text,\n        name: \"\",\n        attributes: {},\n        children: [],\n      },\n    ],\n  }\n}\n","import type { AnyCircuitElement } from \"circuit-json\"\n\nexport const isSourcePortConnected = (\n  circuitJson: AnyCircuitElement[],\n  sourcePortId: string,\n): boolean => {\n  for (const elm of circuitJson) {\n    if (elm.type !== \"source_trace\") continue\n    const trace = elm as any\n    if (\n      Array.isArray(trace.connected_source_port_ids) &&\n      trace.connected_source_port_ids.includes(sourcePortId)\n    ) {\n      return true\n    }\n  }\n  return false\n}\n","import { su } from \"@tscircuit/circuit-json-util\"\nimport type {\n  AnyCircuitElement,\n  SchematicComponent,\n  SchematicPort,\n  SourceSimpleChip,\n} from \"circuit-json\"\nimport type { SvgObject } from \"lib/svg-object\"\nimport type { ColorMap } from \"lib/utils/colors\"\nimport { getSvg, symbols } from \"schematic-symbols\"\nimport { parseSync } from \"svgson\"\nimport { applyToPoint, type Matrix } from \"transformation-matrix\"\nimport { createSvgObjectsFromSchematicComponentWithSymbol } from \"./create-svg-objects-from-sch-component-with-symbol\"\nimport { createSvgObjectsFromSchPortOnBox } from \"./create-svg-objects-from-sch-port-on-box\"\nimport { getSchStrokeSize } from \"lib/utils/get-sch-stroke-size\"\nimport { getSchScreenFontSize } from \"lib/utils/get-sch-font-size\"\nimport { createSvgSchText } from \"./create-svg-objects-for-sch-text\"\n\nexport const createSvgObjectsFromSchematicComponentWithBox = ({\n  component: schComponent,\n  transform,\n  circuitJson,\n  colorMap,\n}: {\n  component: SchematicComponent\n  transform: Matrix\n  circuitJson: AnyCircuitElement[]\n  colorMap: ColorMap\n}): SvgObject[] => {\n  const svgObjects: SvgObject[] = []\n\n  const componentScreenTopLeft = applyToPoint(transform, {\n    x: schComponent.center.x - schComponent.size.width / 2,\n    y: schComponent.center.y + schComponent.size.height / 2,\n  })\n  const componentScreenBottomRight = applyToPoint(transform, {\n    x: schComponent.center.x + schComponent.size.width / 2,\n    y: schComponent.center.y - schComponent.size.height / 2,\n  })\n  const componentScreenWidth =\n    componentScreenBottomRight.x - componentScreenTopLeft.x\n  const componentScreenHeight =\n    componentScreenBottomRight.y - componentScreenTopLeft.y\n\n  // Add basic rectangle for component body\n  svgObjects.push({\n    name: \"rect\",\n    type: \"element\",\n    value: \"\",\n    attributes: {\n      class: \"component chip\",\n      x: componentScreenTopLeft.x.toString(),\n      y: componentScreenTopLeft.y.toString(),\n      width: componentScreenWidth.toString(),\n      height: componentScreenHeight.toString(),\n      \"stroke-width\": `${getSchStrokeSize(transform)}px`,\n      fill: colorMap.schematic.component_body,\n      stroke: colorMap.schematic.component_outline,\n    },\n    children: [],\n  })\n\n  svgObjects.push({\n    name: \"rect\",\n    type: \"element\",\n    value: \"\",\n    attributes: {\n      class: \"component-overlay\",\n      x: componentScreenTopLeft.x.toString(),\n      y: componentScreenTopLeft.y.toString(),\n      width: componentScreenWidth.toString(),\n      height: componentScreenHeight.toString(),\n      fill: \"transparent\",\n    },\n    children: [],\n  })\n\n  const schTexts = su(circuitJson as any).schematic_text.list()\n\n  for (const schText of schTexts) {\n    if (\n      schText.schematic_component_id === schComponent.schematic_component_id\n    ) {\n      svgObjects.push(\n        createSvgSchText({\n          elm: schText,\n          transform,\n          colorMap,\n        }),\n      )\n    }\n  }\n  // // Process ports\n  const schematicPorts = su(circuitJson as any).schematic_port.list({\n    schematic_component_id: schComponent.schematic_component_id,\n  }) as SchematicPort[]\n\n  for (const schPort of schematicPorts) {\n    svgObjects.push(\n      ...createSvgObjectsFromSchPortOnBox({\n        schPort,\n        schComponent,\n        transform,\n        circuitJson,\n      }),\n    )\n  }\n\n  return svgObjects\n}\n","import type {\n  AnyCircuitElement,\n  SchematicComponent,\n  SchematicPort,\n} from \"circuit-json\"\nimport type { SvgObject } from \"lib/svg-object\"\nimport { applyToPoint, type Matrix } from \"transformation-matrix\"\nimport { su } from \"@tscircuit/circuit-json-util\"\nimport { createSvgObjectsForSchPortBoxLine } from \"./create-svg-objects-for-sch-port-box-line\"\nimport { createSvgObjectsForSchPortPinNumberText } from \"./create-svg-objects-for-sch-port-pin-number-text\"\nimport { createSvgObjectsForSchPortPinLabel } from \"./create-svg-objects-for-sch-port-pin-label\"\n\nexport const createSvgObjectsFromSchPortOnBox = (params: {\n  schPort: SchematicPort\n  schComponent: SchematicComponent\n  transform: Matrix\n  circuitJson: AnyCircuitElement[]\n}): SvgObject[] => {\n  const svgObjects: SvgObject[] = []\n  const { schPort, schComponent, transform, circuitJson } = params\n\n  svgObjects.push(...createSvgObjectsForSchPortBoxLine(params))\n  svgObjects.push(...createSvgObjectsForSchPortPinNumberText(params))\n  svgObjects.push(...createSvgObjectsForSchPortPinLabel(params))\n\n  return svgObjects\n}\n","import type {\n  AnyCircuitElement,\n  SchematicComponent,\n  SchematicPort,\n} from \"circuit-json\"\nimport type { SvgObject } from \"lib/svg-object\"\nimport { applyToPoint, type Matrix } from \"transformation-matrix\"\nimport { su } from \"@tscircuit/circuit-json-util\"\nimport { isSourcePortConnected } from \"lib/utils/is-source-port-connected\"\nimport { getSchStrokeSize } from \"lib/utils/get-sch-stroke-size\"\n\nconst PIN_CIRCLE_RADIUS_MM = 0.02\n\n/**\n * The schematic port box line is the line and circle that goes from the edge\n * of the component box to the port.\n */\nexport const createSvgObjectsForSchPortBoxLine = ({\n  schPort,\n  schComponent,\n  transform,\n  circuitJson,\n}: {\n  schPort: SchematicPort\n  schComponent: SchematicComponent\n  transform: Matrix\n  circuitJson: AnyCircuitElement[]\n}): SvgObject[] => {\n  const svgObjects: SvgObject[] = []\n\n  const srcPort = su(circuitJson as any).source_port.get(schPort.source_port_id)\n\n  const realEdgePos = {\n    x: schPort.center.x,\n    y: schPort.center.y,\n  }\n\n  // schPort.distance_from_component_edge is currently calculated incorrectly\n  // in core\n  const realPinLineLength = schPort.distance_from_component_edge ?? 0.4\n\n  switch (schPort.side_of_component) {\n    case \"left\":\n      realEdgePos.x += realPinLineLength\n      break\n    case \"right\":\n      realEdgePos.x -= realPinLineLength\n      break\n    case \"top\":\n      realEdgePos.y -= realPinLineLength\n      break\n    case \"bottom\":\n      realEdgePos.y += realPinLineLength\n      break\n  }\n\n  const screenSchPortPos = applyToPoint(transform, schPort.center)\n  const screenRealEdgePos = applyToPoint(transform, realEdgePos)\n\n  // Subtract the pin circle radius from the pin line length to get the end\n  const realLineEnd = { ...schPort.center }\n\n  switch (schPort.side_of_component) {\n    case \"left\":\n      realLineEnd.x += PIN_CIRCLE_RADIUS_MM\n      break\n    case \"right\":\n      realLineEnd.x -= PIN_CIRCLE_RADIUS_MM\n      break\n    case \"top\":\n      realLineEnd.y -= PIN_CIRCLE_RADIUS_MM\n      break\n    case \"bottom\":\n      realLineEnd.y += PIN_CIRCLE_RADIUS_MM\n      break\n  }\n  const screenLineEnd = applyToPoint(transform, realLineEnd)\n\n  // Add port line\n  svgObjects.push({\n    name: \"line\",\n    type: \"element\",\n    attributes: {\n      class: \"component-pin\",\n      x1: screenLineEnd.x.toString(),\n      y1: screenLineEnd.y.toString(),\n      x2: screenRealEdgePos.x.toString(),\n      y2: screenRealEdgePos.y.toString(),\n      \"stroke-width\": `${getSchStrokeSize(transform)}px`,\n    },\n    value: \"\",\n    children: [],\n  })\n\n  const isConnected = isSourcePortConnected(circuitJson, schPort.source_port_id)\n  const pinRadiusPx = Math.abs(transform.a) * PIN_CIRCLE_RADIUS_MM\n\n  const pinChildren: SvgObject[] = []\n\n  if (!isConnected) {\n    pinChildren.push({\n      name: \"circle\",\n      type: \"element\",\n      attributes: {\n        class: \"component-pin\",\n        cx: screenSchPortPos.x.toString(),\n        cy: screenSchPortPos.y.toString(),\n        r: pinRadiusPx.toString(),\n        \"stroke-width\": `${getSchStrokeSize(transform)}px`,\n      },\n      value: \"\",\n      children: [],\n    })\n  }\n\n  pinChildren.push({\n    name: \"rect\",\n    type: \"element\",\n    attributes: {\n      x: (screenSchPortPos.x - pinRadiusPx).toString(),\n      y: (screenSchPortPos.y - pinRadiusPx).toString(),\n      width: (pinRadiusPx * 2).toString(),\n      height: (pinRadiusPx * 2).toString(),\n      opacity: \"0\",\n    },\n    value: \"\",\n    children: [],\n  })\n\n  svgObjects.push({\n    name: \"g\",\n    type: \"element\",\n    value: \"\",\n    attributes: {\n      \"data-schematic-port-id\": schPort.source_port_id,\n    },\n    children: pinChildren,\n  })\n\n  return svgObjects\n}\n","import type {\n  AnyCircuitElement,\n  SchematicComponent,\n  SchematicPort,\n} from \"circuit-json\"\nimport type { SvgObject } from \"lib/svg-object\"\nimport { colorMap } from \"lib/utils/colors\"\nimport { getSchScreenFontSize } from \"lib/utils/get-sch-font-size\"\nimport { getUnitVectorFromOutsideToEdge } from \"lib/utils/get-unit-vector-from-outside-to-edge\"\nimport { applyToPoint, type Matrix } from \"transformation-matrix\"\n\nexport const createSvgObjectsForSchPortPinNumberText = (params: {\n  schPort: SchematicPort\n  schComponent: SchematicComponent\n  transform: Matrix\n  circuitJson: AnyCircuitElement[]\n}): SvgObject[] => {\n  const svgObjects: SvgObject[] = []\n  const { schPort, schComponent, transform, circuitJson } = params\n\n  const realPinNumberPos = {\n    x: schPort.center.x,\n    y: schPort.center.y,\n  }\n\n  if (!schPort.side_of_component) return []\n  const vecToEdge = getUnitVectorFromOutsideToEdge(schPort.side_of_component)\n\n  const realPinEdgeDistance = schPort.distance_from_component_edge ?? 0.4\n\n  // Move the pin number halfway to the edge of the box component so it sits\n  // between the edge and the port, exactly in the middle\n  realPinNumberPos.x += (vecToEdge.x * realPinEdgeDistance) / 2\n  realPinNumberPos.y += (vecToEdge.y * realPinEdgeDistance) / 2\n\n  if (\n    schPort.side_of_component === \"top\" ||\n    schPort.side_of_component === \"bottom\"\n  ) {\n    // Move the pin number text to the left a bit so it doesn't hit the port line\n    realPinNumberPos.x -= 0.02 //mm\n  } else {\n    // Move the pin number text up a bit so it doesn't hit the port line\n    realPinNumberPos.y += 0.02 //mm\n  }\n\n  // Transform the pin position from local to global coordinates\n  const screenPinNumberTextPos = applyToPoint(transform, realPinNumberPos)\n\n  svgObjects.push({\n    name: \"text\",\n    type: \"element\",\n    attributes: {\n      class: \"pin-number\",\n      x: screenPinNumberTextPos.x.toString(),\n      y: screenPinNumberTextPos.y.toString(),\n      style: \"font-family: sans-serif;\",\n      fill: colorMap.schematic.pin_number,\n      \"text-anchor\": \"middle\",\n      \"dominant-baseline\": \"auto\",\n      \"font-size\": `${getSchScreenFontSize(transform, \"pin_number\")}px`,\n      transform:\n        schPort.side_of_component === \"top\" ||\n        schPort.side_of_component === \"bottom\"\n          ? `rotate(-90 ${screenPinNumberTextPos.x} ${screenPinNumberTextPos.y})`\n          : \"\",\n    },\n    children: [\n      {\n        type: \"text\",\n        value: schPort.pin_number?.toString() || \"\",\n        name: \"\",\n        attributes: {},\n        children: [],\n      },\n    ],\n    value: \"\",\n  })\n\n  return svgObjects\n}\n","import type {\n  AnyCircuitElement,\n  SchematicComponent,\n  SchematicPort,\n} from \"circuit-json\"\nimport type { SvgObject } from \"lib/svg-object\"\nimport { colorMap } from \"lib/utils/colors\"\nimport { getSchScreenFontSize } from \"lib/utils/get-sch-font-size\"\nimport { getUnitVectorFromOutsideToEdge } from \"lib/utils/get-unit-vector-from-outside-to-edge\"\nimport { applyToPoint, type Matrix } from \"transformation-matrix\"\n\nconst LABEL_DIST_FROM_EDGE_MM = 0.1\n\nexport const createSvgObjectsForSchPortPinLabel = (params: {\n  schPort: SchematicPort\n  schComponent: SchematicComponent\n  transform: Matrix\n  circuitJson: AnyCircuitElement[]\n}): SvgObject[] => {\n  const svgObjects: SvgObject[] = []\n  const { schPort, schComponent, transform, circuitJson } = params\n\n  const realPinNumberPos = {\n    x: schPort.center.x,\n    y: schPort.center.y,\n  }\n\n  if (!schPort.side_of_component) return []\n  const vecToEdge = getUnitVectorFromOutsideToEdge(schPort.side_of_component)\n\n  const realPinEdgeDistance = schPort.distance_from_component_edge ?? 0.4\n\n  // Move the pin number halfway to the edge of the box component so it sits\n  // between the edge and the port, exactly in the middle\n  realPinNumberPos.x +=\n    vecToEdge.x * (realPinEdgeDistance + LABEL_DIST_FROM_EDGE_MM)\n  realPinNumberPos.y +=\n    vecToEdge.y * (realPinEdgeDistance + LABEL_DIST_FROM_EDGE_MM)\n\n  // Transform the pin position from local to global coordinates\n  const screenPinNumberTextPos = applyToPoint(transform, realPinNumberPos)\n\n  const label =\n    schPort.display_pin_label ??\n    schComponent.port_labels?.[`${schPort.pin_number}`]\n\n  if (!label) return []\n\n  const isNegated = label.startsWith(\"N_\")\n  const displayLabel = isNegated ? label.slice(2) : label\n\n  let fontSizePx = getSchScreenFontSize(\n    transform,\n    isNegated ? \"negated_pin_number\" : \"pin_number\",\n  )\n\n  svgObjects.push({\n    name: \"text\",\n    type: \"element\",\n    attributes: {\n      class: \"pin-number\",\n      x: screenPinNumberTextPos.x.toString(),\n      y: screenPinNumberTextPos.y.toString(),\n      style: `font-family: sans-serif;${isNegated ? \" text-decoration: overline;\" : \"\"}`,\n      fill: colorMap.schematic.pin_number,\n      \"text-anchor\":\n        schPort.side_of_component === \"left\" ||\n        schPort.side_of_component === \"bottom\"\n          ? \"start\"\n          : \"end\",\n      \"dominant-baseline\": \"middle\",\n      \"font-size\": `${fontSizePx}px`,\n      transform:\n        schPort.side_of_component === \"top\" ||\n        schPort.side_of_component === \"bottom\"\n          ? `rotate(-90 ${screenPinNumberTextPos.x} ${screenPinNumberTextPos.y})`\n          : \"\",\n    },\n    children: [\n      {\n        type: \"text\",\n        value: displayLabel || \"\",\n        name: \"\",\n        attributes: {},\n        children: [],\n      },\n    ],\n    value: \"\",\n  })\n\n  return svgObjects\n}\n","import type { SchematicText } from \"circuit-json\"\nimport type { SvgObject } from \"lib/svg-object\"\nimport type { ColorMap } from \"lib/utils/colors\"\nimport { getSchScreenFontSize } from \"lib/utils/get-sch-font-size\"\nimport { applyToPoint, type Matrix } from \"transformation-matrix\"\n\nexport const createSvgSchText = ({\n  elm,\n  transform,\n  colorMap,\n}: {\n  elm: SchematicText\n  transform: Matrix\n  colorMap: ColorMap\n}): SvgObject => {\n  // Apply transformation\n  const center = applyToPoint(transform, elm.position)\n\n  const textAnchorMap: Record<\n    | \"center\"\n    | \"left\"\n    | \"right\"\n    | \"top\"\n    | \"bottom\"\n    | \"top_left\"\n    | \"top_center\"\n    | \"top_right\"\n    | \"center_left\"\n    | \"center_right\"\n    | \"bottom_left\"\n    | \"bottom_center\"\n    | \"bottom_right\",\n    string\n  > = {\n    center: \"middle\",\n    center_right: \"end\",\n    bottom_left: \"start\",\n    bottom_center: \"middle\",\n    bottom_right: \"end\",\n    left: \"start\",\n    right: \"end\",\n    top: \"middle\",\n    bottom: \"middle\",\n    top_left: \"start\",\n    top_center: \"middle\",\n    top_right: \"end\",\n    center_left: \"start\",\n  }\n\n  const dominantBaselineMap: Record<\n    | \"center\"\n    | \"left\"\n    | \"right\"\n    | \"top\"\n    | \"bottom\"\n    | \"top_left\"\n    | \"top_center\"\n    | \"top_right\"\n    | \"center_left\"\n    | \"center_right\"\n    | \"bottom_left\"\n    | \"bottom_center\"\n    | \"bottom_right\",\n    string\n  > = {\n    center: \"middle\",\n    center_right: \"middle\",\n    bottom_left: \"ideographic\",\n    bottom_center: \"ideographic\",\n    bottom_right: \"ideographic\",\n    left: \"middle\",\n    right: \"middle\",\n    top: \"hanging\",\n    bottom: \"ideographic\",\n    top_left: \"hanging\",\n    top_center: \"hanging\",\n    top_right: \"hanging\",\n    center_left: \"middle\",\n  }\n\n  const lines = elm.text.split(\"\\n\")\n\n  const children: SvgObject[] =\n    lines.length === 1\n      ? [\n          {\n            type: \"text\",\n            value: elm.text,\n            name: elm.schematic_text_id,\n            attributes: {},\n            children: [],\n          },\n        ]\n      : lines.map((line, idx) => ({\n          type: \"element\",\n          name: \"tspan\",\n          value: \"\",\n          attributes: {\n            x: center.x.toString(),\n            ...(idx > 0 ? { dy: \"1em\" } : {}),\n          },\n          children: [\n            {\n              type: \"text\",\n              value: line,\n              name: idx === 0 ? elm.schematic_text_id : \"\",\n              attributes: {},\n              children: [],\n            },\n          ],\n        }))\n\n  return {\n    type: \"element\",\n    name: \"text\",\n    value: \"\",\n    attributes: {\n      x: center.x.toString(),\n      y: center.y.toString(),\n      fill: elm.color ?? colorMap.schematic.sheet_label,\n      \"text-anchor\": textAnchorMap[elm.anchor],\n      \"dominant-baseline\": dominantBaselineMap[elm.anchor],\n      \"font-family\": \"sans-serif\",\n      \"font-size\": `${getSchScreenFontSize(transform, \"reference_designator\", elm.font_size)}px`,\n      transform: `rotate(${elm.rotation}, ${center.x}, ${center.y})`,\n    },\n    children,\n  }\n}\n","import type { AnyCircuitElement, SchematicComponent } from \"circuit-json\"\nimport type { SvgObject } from \"lib/svg-object\"\nimport type { ColorMap } from \"lib/utils/colors\"\nimport { createSvgObjectsFromSchematicComponentWithSymbol } from \"./create-svg-objects-from-sch-component-with-symbol\"\nimport { createSvgObjectsFromSchematicComponentWithBox } from \"./create-svg-objects-from-sch-component-with-box\"\nimport type { Matrix } from \"transformation-matrix\"\n\nexport function createSvgObjectsFromSchematicComponent(params: {\n  component: SchematicComponent\n  transform: Matrix\n  circuitJson: AnyCircuitElement[]\n  colorMap: ColorMap\n}): SvgObject[] {\n  const { component } = params\n\n  const innerElements = component.symbol_name\n    ? createSvgObjectsFromSchematicComponentWithSymbol(params)\n    : createSvgObjectsFromSchematicComponentWithBox(params)\n\n  return [\n    {\n      type: \"element\",\n      name: \"g\",\n      attributes: {\n        \"data-circuit-json-type\": \"schematic_component\",\n        \"data-schematic-component-id\": component.schematic_component_id,\n      },\n      children: innerElements,\n      value: \"\",\n    },\n  ]\n}\n","import type { SchematicVoltageProbe } from \"circuit-json\"\nimport type { SvgObject } from \"lib/svg-object\"\nimport type { ColorMap } from \"lib/utils/colors\"\nimport { getSchStrokeSize } from \"lib/utils/get-sch-stroke-size\"\nimport { getSchScreenFontSize } from \"lib/utils/get-sch-font-size\"\nimport { applyToPoint, type Matrix } from \"transformation-matrix\"\n\nexport function createSvgObjectsFromSchVoltageProbe({\n  probe,\n  transform,\n  colorMap,\n}: {\n  probe: SchematicVoltageProbe\n  transform: Matrix\n  colorMap: ColorMap\n}): SvgObject[] {\n  const [screenX, screenY] = applyToPoint(transform, [\n    probe.position.x,\n    probe.position.y,\n  ])\n\n  const arrowLength = Math.abs(transform.a) * 0.6\n  const arrowWidth = Math.abs(transform.a) * 0.28\n\n  const baseX = screenX + arrowLength * Math.cos((-50 * Math.PI) / 180)\n  const baseY = screenY + arrowLength * Math.sin((-50 * Math.PI) / 180)\n\n  const tipX = screenX\n  const tipY = screenY\n\n  const arrowPath = [\n    `M ${baseX},${baseY}`,\n    `L ${tipX},${tipY}`,\n    `M ${tipX},${tipY}`,\n    `L ${tipX - arrowWidth * Math.cos(((-50 + 150) * Math.PI) / 180)},${tipY - arrowWidth * Math.sin(((-50 + 150) * Math.PI) / 180)}`,\n    `L ${tipX - arrowWidth * Math.cos(((-50 + 210) * Math.PI) / 180)},${tipY - arrowWidth * Math.sin(((-50 + 210) * Math.PI) / 180)}`,\n    \"Z\",\n  ].join(\" \")\n\n  return [\n    {\n      name: \"path\",\n      type: \"element\",\n      attributes: {\n        d: arrowPath,\n        stroke: colorMap.schematic.reference,\n        fill: colorMap.schematic.reference,\n        \"stroke-width\": `${getSchStrokeSize(transform)}px`,\n      },\n      value: \"\",\n      children: [],\n    },\n    {\n      type: \"element\",\n      name: \"text\",\n      value: \"\",\n      attributes: {\n        x: (baseX + 8 - (baseX - baseX)).toString(),\n        y: (baseY - 10 + (baseY - baseY)).toString(),\n        fill: colorMap.schematic.reference,\n        \"text-anchor\": \"middle\",\n        \"dominant-baseline\": \"middle\",\n        \"font-family\": \"sans-serif\",\n        \"font-size\": `${getSchScreenFontSize(transform, \"reference_designator\")}px`,\n        \"font-weight\": \"bold\",\n        \"data-schematic-voltage-probe-id\": probe.schematic_voltage_probe_id,\n      },\n      children: [\n        {\n          type: \"text\",\n          value: probe.voltage ? `${probe.voltage}V` : \"\",\n          name: \"\",\n          attributes: {},\n          children: [],\n        },\n      ],\n    },\n  ]\n}\n","import type { SchematicDebugObject } from \"circuit-json\"\nimport type { INode as SvgObject } from \"svgson\"\nimport { applyToPoint, type Matrix } from \"transformation-matrix\"\n\nexport function createSvgObjectsFromSchDebugObject({\n  debugObject,\n  transform,\n}: {\n  debugObject: SchematicDebugObject\n  transform: Matrix\n}): SvgObject[] {\n  if (debugObject.shape === \"rect\") {\n    // Transform all corners\n    let [screenLeft, screenTop] = applyToPoint(transform, [\n      debugObject.center.x - debugObject.size.width / 2,\n      debugObject.center.y - debugObject.size.height / 2,\n    ])\n    let [screenRight, screenBottom] = applyToPoint(transform, [\n      debugObject.center.x + debugObject.size.width / 2,\n      debugObject.center.y + debugObject.size.height / 2,\n    ])\n    ;[screenTop, screenBottom] = [\n      Math.min(screenTop, screenBottom),\n      Math.max(screenTop, screenBottom),\n    ]\n\n    // Calculate screen width and height\n    const width = Math.abs(screenRight - screenLeft)\n    const height = Math.abs(screenBottom - screenTop)\n\n    const [screenCenterX, screenCenterY] = applyToPoint(transform, [\n      debugObject.center.x,\n      debugObject.center.y,\n    ])\n\n    return [\n      {\n        name: \"rect\",\n        type: \"element\",\n        value: \"\",\n        attributes: {\n          x: screenLeft.toString(),\n          y: screenTop.toString(),\n          width: width.toString(),\n          height: height.toString(),\n          fill: \"none\",\n          stroke: \"red\",\n          \"stroke-width\": (0.02 * Math.abs(transform.a)).toString(),\n          \"stroke-dasharray\": \"5,5\",\n        },\n        children: debugObject.label\n          ? [\n              {\n                name: \"text\",\n                type: \"element\",\n                value: \"\",\n                attributes: {\n                  x: screenCenterX.toString(),\n                  y: (screenCenterY - 10).toString(),\n                  \"text-anchor\": \"middle\",\n                  \"font-size\": (0.2 * Math.abs(transform.a)).toString(),\n                  fill: \"red\",\n                },\n                children: [\n                  {\n                    type: \"text\",\n                    value: debugObject.label,\n                    name: \"\",\n                    attributes: {},\n                    children: [],\n                  },\n                ],\n              },\n            ]\n          : [],\n      },\n    ]\n  }\n  if (debugObject.shape === \"line\") {\n    // Transform start and end points - flip Y coordinates\n    const [screenStartX, screenStartY] = applyToPoint(transform, [\n      debugObject.start.x,\n      debugObject.start.y,\n    ])\n    const [screenEndX, screenEndY] = applyToPoint(transform, [\n      debugObject.end.x,\n      debugObject.end.y,\n    ])\n\n    // Calculate midpoint for label\n    const screenMidX = (screenStartX + screenEndX) / 2\n    const screenMidY = (screenStartY + screenEndY) / 2\n\n    return [\n      {\n        name: \"line\",\n        type: \"element\",\n        value: \"\",\n        attributes: {\n          x1: screenStartX.toString(),\n          y1: screenStartY.toString(),\n          x2: screenEndX.toString(),\n          y2: screenEndY.toString(),\n          stroke: \"red\",\n          \"stroke-width\": (0.02 * Math.abs(transform.a)).toString(),\n          \"stroke-dasharray\": \"5,5\",\n        },\n        children: debugObject.label\n          ? [\n              {\n                name: \"text\",\n                type: \"element\",\n                value: \"\",\n                attributes: {\n                  x: screenMidX.toString(),\n                  y: (screenMidY - 10).toString(),\n                  \"text-anchor\": \"middle\",\n                  \"font-size\": (0.2 * Math.abs(transform.a)).toString(),\n                  fill: \"red\",\n                },\n                children: [\n                  {\n                    type: \"text\",\n                    value: debugObject.label,\n                    name: \"\",\n                    attributes: {},\n                    children: [],\n                  },\n                ],\n              },\n            ]\n          : [],\n      },\n    ]\n  }\n  return []\n}\n","import type { SchematicTrace } from \"circuit-json\"\nimport type { SvgObject } from \"lib/svg-object\"\nimport type { ColorMap } from \"lib/utils/colors\"\nimport { getSchStrokeSize } from \"lib/utils/get-sch-stroke-size\"\nimport { applyToPoint, type Matrix } from \"transformation-matrix\"\n\nexport function createSchematicTrace({\n  trace,\n  transform,\n  colorMap,\n}: {\n  trace: SchematicTrace\n  transform: Matrix\n  colorMap: ColorMap\n}): SvgObject[] {\n  const edges = trace.edges\n  if (edges.length === 0) return []\n  const svgObjects: SvgObject[] = []\n\n  let path = \"\"\n\n  // Process edges into an SVG path\n  for (let edgeIndex = 0; edgeIndex < edges.length; edgeIndex++) {\n    const edge = edges[edgeIndex]!\n\n    if (edge.is_crossing) continue\n\n    // Transform the points using the matrix\n    const [screenFromX, screenFromY] = applyToPoint(transform, [\n      edge.from.x,\n      edge.from.y,\n    ])\n    const [screenToX, screenToY] = applyToPoint(transform, [\n      edge.to.x,\n      edge.to.y,\n    ])\n\n    // Regular straight line for non-crossing traces\n    if (edgeIndex === 0 || edges[edgeIndex - 1]?.is_crossing) {\n      path += `M ${screenFromX} ${screenFromY} L ${screenToX} ${screenToY}`\n    } else {\n      path += ` L ${screenToX} ${screenToY}`\n    }\n  }\n\n  // Process wire crossings with little \"hops\" or arcs\n  for (const edge of edges) {\n    if (!edge.is_crossing) continue\n\n    // Transform the points using the matrix\n    const [screenFromX, screenFromY] = applyToPoint(transform, [\n      edge.from.x,\n      edge.from.y,\n    ])\n    const [screenToX, screenToY] = applyToPoint(transform, [\n      edge.to.x,\n      edge.to.y,\n    ])\n    // For crossing traces, create a small arc/hop\n    const midX = (screenFromX + screenToX) / 2\n    const midY = (screenFromY + screenToY) / 2\n\n    // Calculate perpendicular offset for the arc\n    const dx = screenToX - screenFromX\n    const dy = screenToY - screenFromY\n    const len = Math.sqrt(dx * dx + dy * dy)\n    const hopHeight = len * 0.7\n\n    // Perpendicular vector\n    const perpX = (-dy / len) * hopHeight\n    const perpY = (dx / len) * hopHeight\n\n    // Control point for the quadratic curve\n    const controlX = midX + perpX\n    const controlY = midY - Math.abs(perpY)\n\n    // Arc Shadow\n    svgObjects.push({\n      name: \"path\",\n      type: \"element\",\n      attributes: {\n        class: \"trace-crossing-outline\",\n        d: `M ${screenFromX} ${screenFromY} Q ${controlX} ${controlY} ${screenToX} ${screenToY}`,\n        stroke: colorMap.schematic.background,\n        fill: \"none\",\n        \"stroke-width\": `${getSchStrokeSize(transform) * 1.5}px`,\n        \"stroke-linecap\": \"round\",\n      },\n      value: \"\",\n      children: [],\n    })\n    svgObjects.push({\n      name: \"path\",\n      type: \"element\",\n      attributes: {\n        d: `M ${screenFromX} ${screenFromY} Q ${controlX} ${controlY} ${screenToX} ${screenToY}`,\n        stroke: colorMap.schematic.wire,\n        fill: \"none\",\n        \"stroke-width\": `${getSchStrokeSize(transform)}px`,\n        \"stroke-linecap\": \"round\",\n      },\n      value: \"\",\n      children: [],\n    })\n  }\n\n  if (path) {\n    // Makes hovering over trace (which inverts the colors) easier\n    svgObjects.push({\n      name: \"path\",\n      type: \"element\",\n      attributes: {\n        d: path,\n        class: \"trace-invisible-hover-outline\",\n        stroke: colorMap.schematic.wire,\n        fill: \"none\",\n        \"stroke-width\": `${getSchStrokeSize(transform) * 8}px`,\n        \"stroke-linecap\": \"round\",\n        opacity: \"0\",\n        \"stroke-linejoin\": \"round\",\n      },\n      value: \"\",\n      children: [],\n    })\n    svgObjects.push({\n      name: \"path\",\n      type: \"element\",\n      attributes: {\n        d: path,\n        stroke: colorMap.schematic.wire,\n        fill: \"none\",\n        \"stroke-width\": `${getSchStrokeSize(transform)}px`,\n        \"stroke-linecap\": \"round\",\n        \"stroke-linejoin\": \"round\",\n      },\n      value: \"\",\n      children: [],\n    })\n  }\n\n  // Add junction circles\n  if (trace.junctions) {\n    for (const junction of trace.junctions) {\n      const [screenX, screenY] = applyToPoint(transform, [\n        junction.x,\n        junction.y,\n      ])\n      svgObjects.push({\n        name: \"circle\",\n        type: \"element\",\n        attributes: {\n          cx: screenX.toString(),\n          cy: screenY.toString(),\n          r: (Math.abs(transform.a) * 0.03).toString(),\n          class: \"trace-junction\",\n          fill: colorMap.schematic.junction,\n        },\n        value: \"\",\n        children: [],\n      })\n    }\n  }\n\n  return [\n    {\n      name: \"g\",\n      type: \"element\",\n      value: \"\",\n      attributes: {\n        class: \"trace\",\n        \"data-circuit-json-type\": \"schematic_trace\",\n        \"data-schematic-trace-id\": trace.schematic_trace_id,\n      },\n      children: svgObjects,\n    },\n  ]\n}\n","import type { SchematicNetLabel } from \"circuit-json\"\nimport type { SvgObject } from \"lib/svg-object\"\nimport type { ColorMap } from \"lib/utils/colors\"\nimport {\n  getSchMmFontSize,\n  getSchScreenFontSize,\n} from \"lib/utils/get-sch-font-size\"\nimport { getSchStrokeSize } from \"lib/utils/get-sch-stroke-size\"\nimport { getUnitVectorFromOutsideToEdge } from \"lib/utils/get-unit-vector-from-outside-to-edge\"\nimport {\n  applyToPoint,\n  compose,\n  rotate,\n  scale,\n  translate,\n  type Matrix,\n} from \"transformation-matrix\"\nimport { estimateTextWidth } from \"../estimate-text-width\"\nimport { createSvgObjectsForSchNetLabelWithSymbol } from \"./create-svg-objects-for-sch-net-label-with-symbol\"\nimport {\n  ARROW_POINT_WIDTH_FSR,\n  END_PADDING_FSR,\n  END_PADDING_EXTRA_PER_CHARACTER_FSR,\n} from \"../../utils/net-label-utils\"\n\nexport const createSvgObjectsForSchNetLabel = ({\n  schNetLabel,\n  realToScreenTransform,\n  colorMap,\n}: {\n  schNetLabel: SchematicNetLabel\n  realToScreenTransform: Matrix\n  colorMap: ColorMap\n}): SvgObject[] => {\n  if (!schNetLabel.text) return []\n\n  const labelText = schNetLabel.text\n\n  // If symbol_name is provided, use the symbol renderer\n  if (schNetLabel.symbol_name) {\n    return createSvgObjectsForSchNetLabelWithSymbol({\n      schNetLabel,\n      realToScreenTransform,\n      colorMap,\n    })\n  }\n\n  const svgObjects: SvgObject[] = []\n\n  const fontSizePx = getSchScreenFontSize(realToScreenTransform, \"net_label\")\n  const fontSizeMm = getSchMmFontSize(\"net_label\")\n  const textWidthFSR = estimateTextWidth(labelText || \"\")\n\n  // Transform the center position to screen coordinates\n  const screenCenter = applyToPoint(realToScreenTransform, schNetLabel.center)\n\n  const realTextGrowthVec = getUnitVectorFromOutsideToEdge(\n    schNetLabel.anchor_side,\n  )\n\n  const screenTextGrowthVec = { ...realTextGrowthVec }\n  screenTextGrowthVec.y *= -1 // Invert y direction because anchor_side is pre-transform\n\n  const fullWidthFsr =\n    textWidthFSR +\n    ARROW_POINT_WIDTH_FSR * 2 +\n    END_PADDING_EXTRA_PER_CHARACTER_FSR * labelText.length +\n    END_PADDING_FSR\n  const screenAnchorPosition = schNetLabel.anchor_position\n    ? applyToPoint(realToScreenTransform, schNetLabel.anchor_position)\n    : {\n        x:\n          screenCenter.x -\n          (screenTextGrowthVec.x * fullWidthFsr * fontSizePx) / 2,\n        y:\n          screenCenter.y -\n          (screenTextGrowthVec.y * fullWidthFsr * fontSizePx) / 2,\n      }\n  const realAnchorPosition = schNetLabel.anchor_position ?? {\n    x:\n      schNetLabel.center.x -\n      (realTextGrowthVec.x * fullWidthFsr * fontSizeMm) / 2,\n    y:\n      schNetLabel.center.y -\n      (realTextGrowthVec.y * fullWidthFsr * fontSizeMm) / 2,\n  }\n\n  // Get rotation angle based on anchor_side\n  const pathRotation = {\n    left: 0,\n    top: -90,\n    bottom: 90,\n    right: 180,\n  }[schNetLabel.anchor_side]\n\n  // Calculate the points for the outline\n  const screenOutlinePoints: Array<{ x: number; y: number }> = [\n    // Arrow point in font-relative coordinates\n    {\n      x: 0,\n      y: 0,\n    },\n    // Top left corner in font-relative coordinates\n    {\n      x: ARROW_POINT_WIDTH_FSR,\n      y: 0.6,\n    },\n    // Top right corner in font-relative coordinates\n    {\n      x:\n        ARROW_POINT_WIDTH_FSR * 2 +\n        END_PADDING_FSR +\n        END_PADDING_EXTRA_PER_CHARACTER_FSR * labelText.length +\n        textWidthFSR,\n      y: 0.6,\n    },\n    // Bottom right corner in font-relative coordinates\n    {\n      x:\n        ARROW_POINT_WIDTH_FSR * 2 +\n        END_PADDING_FSR +\n        END_PADDING_EXTRA_PER_CHARACTER_FSR * labelText.length +\n        textWidthFSR,\n      y: -0.6,\n    },\n    // Bottom left corner in font-relative coordinates\n    {\n      x: ARROW_POINT_WIDTH_FSR,\n      y: -0.6,\n    },\n  ].map((fontRelativePoint) =>\n    applyToPoint(\n      compose(\n        realToScreenTransform,\n        translate(realAnchorPosition.x, realAnchorPosition.y),\n        scale(fontSizeMm),\n        rotate((pathRotation / 180) * Math.PI),\n      ),\n      fontRelativePoint,\n    ),\n  )\n\n  // Create the label path\n  const pathD = `\n    M ${screenOutlinePoints[0]!.x},${screenOutlinePoints[0]!.y}\n    L ${screenOutlinePoints[1]!.x},${screenOutlinePoints[1]!.y}\n    L ${screenOutlinePoints[2]!.x},${screenOutlinePoints[2]!.y}\n    L ${screenOutlinePoints[3]!.x},${screenOutlinePoints[3]!.y}\n    L ${screenOutlinePoints[4]!.x},${screenOutlinePoints[4]!.y}\n    Z\n  `\n\n  // Add the label container path\n  svgObjects.push({\n    name: \"path\",\n    type: \"element\",\n    attributes: {\n      class: \"net-label\",\n      d: pathD,\n      fill: colorMap.schematic.label_background,\n      stroke: colorMap.schematic.label_global,\n      \"stroke-width\": `${getSchStrokeSize(realToScreenTransform)}px`,\n    },\n    value: \"\",\n    children: [],\n  })\n\n  const screenTextPos = {\n    x: screenAnchorPosition.x + screenTextGrowthVec.x * fontSizePx * 0.5,\n    y: screenAnchorPosition.y + screenTextGrowthVec.y * fontSizePx * 0.5,\n  }\n\n  const textAnchor = {\n    left: \"start\",\n    top: \"start\",\n    bottom: \"start\",\n    right: \"end\",\n  }[schNetLabel.anchor_side]\n\n  const textTransformString = {\n    left: \"\",\n    right: \"\",\n    top: `rotate(90 ${screenTextPos.x} ${screenTextPos.y})`,\n    bottom: `rotate(-90 ${screenTextPos.x} ${screenTextPos.y})`,\n  }[schNetLabel.anchor_side]\n\n  // Add the label text\n  svgObjects.push({\n    name: \"text\",\n    type: \"element\",\n    attributes: {\n      class: \"net-label-text\",\n      x: screenTextPos.x.toString(),\n      y: screenTextPos.y.toString(),\n      fill: colorMap.schematic.label_global,\n      \"text-anchor\": textAnchor,\n      \"dominant-baseline\": \"central\",\n      \"font-family\": \"sans-serif\",\n      \"font-variant-numeric\": \"tabular-nums\",\n      \"font-size\": `${fontSizePx}px`,\n      transform: textTransformString,\n    },\n    children: [\n      {\n        type: \"text\",\n        value: labelText || \"\",\n        name: \"\",\n        attributes: {},\n        children: [],\n      },\n    ],\n    value: \"\",\n  })\n\n  return svgObjects\n}\n","import type { SchematicNetLabel } from \"circuit-json\"\nimport type { SvgObject } from \"lib/svg-object\"\nimport {\n  getSchMmFontSize,\n  getSchScreenFontSize,\n} from \"lib/utils/get-sch-font-size\"\nimport { getSchStrokeSize } from \"lib/utils/get-sch-stroke-size\"\nimport {\n  applyToPoint,\n  compose,\n  rotate,\n  scale,\n  translate,\n  type Matrix,\n} from \"transformation-matrix\"\nimport { estimateTextWidth } from \"../estimate-text-width\"\nimport { symbols } from \"schematic-symbols\"\nimport { createSvgSchErrorText } from \"./create-svg-error-text\"\nimport {\n  ninePointAnchorToTextAnchor,\n  ninePointAnchorToDominantBaseline,\n  ARROW_POINT_WIDTH_FSR,\n  END_PADDING_EXTRA_PER_CHARACTER_FSR,\n  END_PADDING_FSR,\n  getTextOffsets,\n} from \"../../utils/net-label-utils\"\nimport { getUnitVectorFromOutsideToEdge } from \"lib/utils/get-unit-vector-from-outside-to-edge\"\nimport type { ColorMap } from \"lib/utils/colors\"\n\nexport const createSvgObjectsForSchNetLabelWithSymbol = ({\n  schNetLabel,\n  realToScreenTransform,\n  colorMap,\n}: {\n  schNetLabel: SchematicNetLabel\n  realToScreenTransform: Matrix\n  colorMap: ColorMap\n}): SvgObject[] => {\n  if (!schNetLabel.text) return []\n  const isNegated = schNetLabel.text.startsWith(\"N_\")\n  const labelText = isNegated ? schNetLabel.text.slice(2) : schNetLabel.text\n  const svgObjects: SvgObject[] = []\n\n  // If symbol name is provided, draw the symbol\n  const symbol = symbols[schNetLabel.symbol_name as keyof typeof symbols]\n  if (!symbol) {\n    svgObjects.push(\n      createSvgSchErrorText({\n        text: `Symbol not found: ${schNetLabel.symbol_name}`,\n        realCenter: schNetLabel.center,\n        realToScreenTransform,\n      }),\n    )\n    return svgObjects\n  }\n  const symbolPaths = symbol.primitives.filter((p) => p.type === \"path\")\n  const symbolTexts = symbol.primitives.filter((p) => p.type === \"text\")\n  const symbolCircles = symbol.primitives.filter((p) => p.type === \"circle\")\n  const symbolBoxes = symbol.primitives.filter((p) => p.type === \"box\")\n\n  // Calculate symbol bounds for overlay\n  const bounds = {\n    minX: Math.min(...symbolPaths.flatMap((p) => p.points.map((pt) => pt.x))),\n    maxX: Math.max(...symbolPaths.flatMap((p) => p.points.map((pt) => pt.x))),\n    minY: Math.min(...symbolPaths.flatMap((p) => p.points.map((pt) => pt.y))),\n    maxY: Math.max(...symbolPaths.flatMap((p) => p.points.map((pt) => pt.y))),\n  }\n\n  // Use the same positioning logic as the net label text\n  const fontSizeMm = getSchMmFontSize(\"net_label\")\n  const textWidthFSR = estimateTextWidth(labelText || \"\")\n\n  const fullWidthFsr =\n    textWidthFSR +\n    ARROW_POINT_WIDTH_FSR * 2 +\n    END_PADDING_EXTRA_PER_CHARACTER_FSR * labelText.length +\n    END_PADDING_FSR\n\n  const realTextGrowthVec = getUnitVectorFromOutsideToEdge(\n    schNetLabel.anchor_side,\n  )\n\n  const realAnchorPosition = schNetLabel.anchor_position ?? {\n    x:\n      schNetLabel.center.x -\n      (realTextGrowthVec.x * fullWidthFsr * fontSizeMm) / 2,\n    y:\n      schNetLabel.center.y -\n      (realTextGrowthVec.y * fullWidthFsr * fontSizeMm) / 2,\n  }\n\n  // Symbols referenced by name already encode their orientation, so\n  // no additional rotation should be applied based on `anchor_side`.\n  const pathRotation = 0\n\n  // Create transformation matrix that matches net label positioning\n  // Calculate the rotation matrix based on the path rotation\n  const rotationMatrix = rotate((pathRotation / 180) * Math.PI)\n\n  // Calculate the symbol's end point after rotation\n  const symbolBounds = {\n    minX: Math.min(\n      ...symbol.primitives.flatMap((p) =>\n        p.type === \"path\" ? p.points.map((pt) => pt.x) : [],\n      ),\n    ),\n    maxX: Math.max(\n      ...symbol.primitives.flatMap((p) =>\n        p.type === \"path\" ? p.points.map((pt) => pt.x) : [],\n      ),\n    ),\n    minY: Math.min(\n      ...symbol.primitives.flatMap((p) =>\n        p.type === \"path\" ? p.points.map((pt) => pt.y) : [],\n      ),\n    ),\n    maxY: Math.max(\n      ...symbol.primitives.flatMap((p) =>\n        p.type === \"path\" ? p.points.map((pt) => pt.y) : [],\n      ),\n    ),\n  }\n\n  // Use the first port as the connection point when available. This\n  // accounts for symbols whose anchor is not the leftmost edge (e.g.\n  // vertically oriented ground/VCC symbols).\n  const symbolEndPoint = symbol.ports?.[0]\n    ? { x: symbol.ports[0].x, y: symbol.ports[0].y }\n    : {\n        x: symbolBounds.minX,\n        y: (symbolBounds.minY + symbolBounds.maxY) / 2,\n      }\n\n  const rotatedSymbolEnd = applyToPoint(rotationMatrix, symbolEndPoint)\n\n  // Adjust the translation to account for rotated symbol end\n  const symbolToRealTransform = compose(\n    translate(\n      realAnchorPosition.x - rotatedSymbolEnd.x,\n      realAnchorPosition.y - rotatedSymbolEnd.y,\n    ),\n    rotationMatrix,\n    scale(1), // Use full symbol size\n  )\n\n  // Calculate screen bounds\n  const [screenMinX, screenMinY] = applyToPoint(\n    compose(realToScreenTransform, symbolToRealTransform),\n    [bounds.minX, bounds.minY],\n  )\n  const [screenMaxX, screenMaxY] = applyToPoint(\n    compose(realToScreenTransform, symbolToRealTransform),\n    [bounds.maxX, bounds.maxY],\n  )\n\n  const rectHeight = Math.abs(screenMaxY - screenMinY)\n  const rectY = Math.min(screenMinY, screenMaxY)\n  const rectWidth = Math.abs(screenMaxX - screenMinX)\n  const rectX = Math.min(screenMinX, screenMaxX)\n\n  // Add overlay rectangle\n  svgObjects.push({\n    name: \"rect\",\n    type: \"element\",\n    value: \"\",\n    attributes: {\n      class: \"component-overlay\",\n      x: rectX.toString(),\n      y: rectY.toString(),\n      width: rectWidth.toString(),\n      height: rectHeight.toString(),\n      fill: \"transparent\",\n    },\n    children: [],\n  })\n\n  // Draw symbol paths\n  for (const path of symbolPaths) {\n    const symbolPath = path.points\n      .map((p, i) => {\n        const [x, y] = applyToPoint(\n          compose(realToScreenTransform, symbolToRealTransform),\n          [p.x, p.y],\n        )\n        return `${i === 0 ? \"M\" : \"L\"} ${x} ${y}`\n      })\n      .join(\" \")\n\n    svgObjects.push({\n      name: \"path\",\n      type: \"element\",\n      attributes: {\n        d: symbolPath + (path.closed ? \" Z\" : \"\"),\n        stroke: colorMap.schematic.component_outline,\n        fill: \"none\",\n        \"stroke-width\": `${getSchStrokeSize(realToScreenTransform)}px`,\n        \"stroke-linecap\": \"round\",\n      },\n      value: \"\",\n      children: [],\n    })\n  }\n\n  // Draw symbol texts\n  for (const text of symbolTexts) {\n    const screenTextPos = applyToPoint(\n      compose(realToScreenTransform, symbolToRealTransform),\n      text,\n    )\n\n    let textValue = text.text\n    if (textValue === \"{REF}\") {\n      textValue = labelText || \"\"\n    } else if (textValue === \"{VAL}\") {\n      textValue = \"\" // You can modify this if needed\n    }\n\n    // Adjust vertical positioning for left anchor side\n\n    // Calculate scale-adjusted text offset based on transform\n    const scale = Math.abs(realToScreenTransform.a)\n    const baseOffset = scale * 0.1 // Base offset unit in screen coordinates\n\n    // Symbols define their own text placement, so no additional\n    // offsets should be applied based on path rotation.\n    const offsetScreenPos = {\n      x: screenTextPos.x,\n      y: screenTextPos.y,\n    }\n\n    svgObjects.push({\n      name: \"text\",\n      type: \"element\",\n      attributes: {\n        x: offsetScreenPos.x.toString(),\n        y: offsetScreenPos.y.toString(),\n        fill: colorMap.schematic.label_local,\n        \"font-family\": \"sans-serif\",\n        \"text-anchor\": ninePointAnchorToTextAnchor[text.anchor],\n        \"dominant-baseline\": ninePointAnchorToDominantBaseline[text.anchor],\n        \"font-size\": `${getSchScreenFontSize(realToScreenTransform, \"reference_designator\")}px`,\n        ...(isNegated && textValue === labelText\n          ? { style: \"text-decoration: overline;\" }\n          : {}),\n      },\n      children: [\n        {\n          type: \"text\",\n          value: textValue,\n          name: \"\",\n          attributes: {},\n          children: [],\n        },\n      ],\n      value: \"\",\n    })\n  }\n  // Draw symbol boxes\n  for (const box of symbolBoxes) {\n    const screenBoxPos = applyToPoint(\n      compose(realToScreenTransform, symbolToRealTransform),\n      box,\n    )\n    const symbolToScreenScale = compose(\n      realToScreenTransform,\n      symbolToRealTransform,\n    ).a\n\n    svgObjects.push({\n      name: \"rect\",\n      type: \"element\",\n      attributes: {\n        x: screenBoxPos.x.toString(),\n        y: screenBoxPos.y.toString(),\n        width: (box.width * symbolToScreenScale).toString(),\n        height: (box.height * symbolToScreenScale).toString(),\n        fill: \"red\",\n      },\n      value: \"\",\n      children: [],\n    })\n  }\n\n  // Draw symbol circles\n  for (const circle of symbolCircles) {\n    const screenCirclePos = applyToPoint(\n      compose(realToScreenTransform, symbolToRealTransform),\n      circle,\n    )\n    const symbolToScreenScale = compose(\n      realToScreenTransform,\n      symbolToRealTransform,\n    ).a\n\n    svgObjects.push({\n      name: \"circle\",\n      type: \"element\",\n      attributes: {\n        cx: screenCirclePos.x.toString(),\n        cy: screenCirclePos.y.toString(),\n        r: (circle.radius * symbolToScreenScale).toString(),\n        fill: \"none\",\n        stroke: colorMap.schematic.component_outline,\n        \"stroke-width\": `${getSchStrokeSize(realToScreenTransform)}px`,\n      },\n      value: \"\",\n      children: [],\n    })\n  }\n\n  return svgObjects\n}\n","import { applyToPoint, type Matrix } from \"transformation-matrix\"\nimport type { SvgObject } from \"lib/svg-object\"\nimport type { ColorMap } from \"lib/utils/colors\"\nimport { getSchStrokeSize } from \"lib/utils/get-sch-stroke-size\"\nimport type { SchematicBox } from \"circuit-json\"\n\nexport const createSvgObjectsFromSchematicBox = ({\n  schematicBox,\n  transform,\n  colorMap,\n}: {\n  schematicBox: SchematicBox\n  transform: Matrix\n  colorMap: ColorMap\n}): SvgObject[] => {\n  const topLeft = applyToPoint(transform, {\n    x: schematicBox.x,\n    y: schematicBox.y,\n  })\n  const bottomRight = applyToPoint(transform, {\n    x: schematicBox.x + schematicBox.width,\n    y: schematicBox.y + schematicBox.height,\n  })\n\n  const yTop = Math.min(topLeft.y, bottomRight.y)\n  const yBottom = Math.max(topLeft.y, bottomRight.y)\n  const xLeft = Math.min(topLeft.x, bottomRight.x)\n  const xRight = Math.max(topLeft.x, bottomRight.x)\n\n  const strokeWidthPx = getSchStrokeSize(transform)\n  const attributes: Record<string, string> = {\n    class: \"schematic-box\",\n    x: xLeft.toString(),\n    y: yTop.toString(),\n    width: (xRight - xLeft).toString(),\n    height: (yBottom - yTop).toString(),\n    \"stroke-width\": `${strokeWidthPx}px`,\n    stroke: colorMap.schematic.component_outline || \"black\",\n    fill: \"transparent\",\n  }\n\n  if (schematicBox.is_dashed) {\n    // Scale dash length according to zoom level\n    const dashLength = 8 * strokeWidthPx\n    const gapLength = 4 * strokeWidthPx\n    attributes[\"stroke-dasharray\"] = `${dashLength} ${gapLength}`\n  }\n\n  return [\n    {\n      name: \"rect\",\n      type: \"element\",\n      value: \"\",\n      attributes,\n      children: [],\n    },\n  ]\n}\n","import type {\n  AnyCircuitElement,\n  SchematicTable,\n  SchematicTableCell,\n} from \"circuit-json\"\nimport type { SvgObject } from \"lib/svg-object\"\nimport type { ColorMap } from \"lib/utils/colors\"\nimport { getSchScreenFontSize } from \"lib/utils/get-sch-font-size\"\nimport { getSchStrokeSize } from \"lib/utils/get-sch-stroke-size\"\nimport { applyToPoint, type Matrix } from \"transformation-matrix\"\nimport { getTableDimensions } from \"../get-table-dimensions\"\n\nexport const createSvgObjectsFromSchematicTable = ({\n  schematicTable,\n  transform,\n  colorMap,\n  circuitJson,\n}: {\n  schematicTable: SchematicTable\n  transform: Matrix\n  colorMap: ColorMap\n  circuitJson: AnyCircuitElement[]\n}): SvgObject[] => {\n  const {\n    anchor_position,\n    border_width = 0.05,\n    anchor = \"center\",\n  } = schematicTable\n\n  const { column_widths, row_heights } = getTableDimensions(\n    schematicTable,\n    circuitJson,\n  )\n\n  const totalWidth = column_widths.reduce((a, b) => a + b, 0)\n  const totalHeight = row_heights.reduce((a, b) => a + b, 0)\n\n  let topLeftX = anchor_position.x\n  let topLeftY = anchor_position.y\n\n  // Horizontal alignment\n  if (anchor.includes(\"center\")) {\n    topLeftX -= totalWidth / 2\n  } else if (anchor.includes(\"right\")) {\n    topLeftX -= totalWidth\n  }\n\n  // Vertical alignment\n  if (anchor.includes(\"center\")) {\n    topLeftY += totalHeight / 2\n  } else if (anchor.includes(\"bottom\")) {\n    topLeftY += totalHeight\n  }\n\n  const svgObjects: SvgObject[] = []\n  const borderStrokeWidth = border_width * Math.abs(transform.a)\n  const gridStrokeWidth = getSchStrokeSize(transform)\n\n  // Draw border\n  const [screenTopLeftX, screenTopLeftY] = applyToPoint(transform, [\n    topLeftX,\n    topLeftY,\n  ])\n  const [screenBottomRightX, screenBottomRightY] = applyToPoint(transform, [\n    topLeftX + totalWidth,\n    topLeftY - totalHeight,\n  ])\n\n  svgObjects.push({\n    name: \"rect\",\n    type: \"element\",\n    attributes: {\n      x: screenTopLeftX.toString(),\n      y: screenTopLeftY.toString(),\n      width: (screenBottomRightX - screenTopLeftX).toString(),\n      height: (screenBottomRightY - screenTopLeftY).toString(),\n      fill: \"none\",\n      stroke: colorMap.schematic.table,\n      \"stroke-width\": borderStrokeWidth.toString(),\n    },\n    children: [],\n    value: \"\",\n  })\n\n  // Draw grid lines\n  const cells = circuitJson.filter(\n    (elm): elm is SchematicTableCell =>\n      elm.type === \"schematic_table_cell\" &&\n      elm.schematic_table_id === schematicTable.schematic_table_id,\n  )\n\n  let currentX = topLeftX\n  for (let i = 0; i < column_widths.length - 1; i++) {\n    currentX += column_widths[i]!\n    let segmentStartY = topLeftY\n    for (let j = 0; j < row_heights.length; j++) {\n      const segmentEndY = segmentStartY - row_heights[j]!\n      const isMerged = cells.some(\n        (cell) =>\n          cell.start_column_index <= i &&\n          cell.end_column_index > i &&\n          cell.start_row_index <= j &&\n          cell.end_row_index >= j,\n      )\n\n      if (!isMerged) {\n        const start = applyToPoint(transform, { x: currentX, y: segmentStartY })\n        const end = applyToPoint(transform, { x: currentX, y: segmentEndY })\n        svgObjects.push({\n          name: \"line\",\n          type: \"element\",\n          attributes: {\n            x1: start.x.toString(),\n            y1: start.y.toString(),\n            x2: end.x.toString(),\n            y2: end.y.toString(),\n            stroke: colorMap.schematic.table,\n            \"stroke-width\": gridStrokeWidth.toString(),\n          },\n          children: [],\n          value: \"\",\n        })\n      }\n      segmentStartY = segmentEndY\n    }\n  }\n\n  let currentY = topLeftY\n  for (let i = 0; i < row_heights.length - 1; i++) {\n    currentY -= row_heights[i]!\n    let segmentStartX = topLeftX\n    for (let j = 0; j < column_widths.length; j++) {\n      const segmentEndX = segmentStartX + column_widths[j]!\n      const isMerged = cells.some(\n        (cell) =>\n          cell.start_row_index <= i &&\n          cell.end_row_index > i &&\n          cell.start_column_index <= j &&\n          cell.end_column_index >= j,\n      )\n\n      if (!isMerged) {\n        const start = applyToPoint(transform, {\n          x: segmentStartX,\n          y: currentY,\n        })\n        const end = applyToPoint(transform, { x: segmentEndX, y: currentY })\n        svgObjects.push({\n          name: \"line\",\n          type: \"element\",\n          attributes: {\n            x1: start.x.toString(),\n            y1: start.y.toString(),\n            x2: end.x.toString(),\n            y2: end.y.toString(),\n            stroke: colorMap.schematic.table,\n            \"stroke-width\": gridStrokeWidth.toString(),\n          },\n          children: [],\n          value: \"\",\n        })\n      }\n      segmentStartX = segmentEndX\n    }\n  }\n\n  // Draw cells\n\n  for (const cell of cells) {\n    if (cell.text) {\n      // Calculate cell dimensions\n      const cellWidth = column_widths\n        .slice(cell.start_column_index, cell.end_column_index + 1)\n        .reduce((a, b) => a + b, 0)\n      const cellHeight = row_heights\n        .slice(cell.start_row_index, cell.end_row_index + 1)\n        .reduce((a, b) => a + b, 0)\n\n      // Calculate cell top-left position\n      const cellTopLeftX =\n        topLeftX +\n        column_widths\n          .slice(0, cell.start_column_index)\n          .reduce((a, b) => a + b, 0)\n      const cellTopLeftY =\n        topLeftY -\n        row_heights.slice(0, cell.start_row_index).reduce((a, b) => a + b, 0)\n\n      const { cell_padding = 0.2 } = schematicTable\n      const horizontal_align = cell.horizontal_align ?? \"center\"\n      const vertical_align = cell.vertical_align ?? \"middle\"\n\n      let realTextAnchorPos = {\n        x: cellTopLeftX + cellWidth / 2,\n        y: cellTopLeftY - cellHeight / 2,\n      }\n\n      if (horizontal_align === \"left\") {\n        realTextAnchorPos.x = cellTopLeftX + cell_padding\n      } else if (horizontal_align === \"right\") {\n        realTextAnchorPos.x = cellTopLeftX + cellWidth - cell_padding\n      }\n\n      if (vertical_align === \"top\") {\n        realTextAnchorPos.y = cellTopLeftY - cell_padding\n      } else if (vertical_align === \"bottom\") {\n        realTextAnchorPos.y = cellTopLeftY - cellHeight + cell_padding\n      }\n\n      const screenTextAnchorPos = applyToPoint(transform, realTextAnchorPos)\n\n      const fontSize = getSchScreenFontSize(\n        transform,\n        \"reference_designator\",\n        cell.font_size,\n      )\n\n      const textAnchorMap: Record<\n        \"left\" | \"center\" | \"right\",\n        \"start\" | \"middle\" | \"end\"\n      > = {\n        left: \"start\",\n        center: \"middle\",\n        right: \"end\",\n      }\n\n      const dominantBaselineMap: Record<\n        \"top\" | \"middle\" | \"bottom\",\n        \"hanging\" | \"middle\" | \"ideographic\"\n      > = {\n        top: \"hanging\",\n        middle: \"middle\",\n        bottom: \"ideographic\",\n      }\n\n      svgObjects.push({\n        name: \"text\",\n        type: \"element\",\n        attributes: {\n          x: screenTextAnchorPos.x.toString(),\n          y: screenTextAnchorPos.y.toString(),\n          \"font-size\": `${fontSize}px`,\n          \"text-anchor\": textAnchorMap[horizontal_align],\n          \"dominant-baseline\": dominantBaselineMap[vertical_align],\n          fill: colorMap.schematic.table,\n          \"font-family\": \"sans-serif\",\n        },\n        children: [\n          {\n            type: \"text\",\n            value: cell.text,\n            name: \"\",\n            attributes: {},\n            children: [],\n          },\n        ],\n        value: \"\",\n      })\n    }\n  }\n\n  return [\n    {\n      name: \"g\",\n      type: \"element\",\n      attributes: {\n        \"data-schematic-table-id\": schematicTable.schematic_table_id,\n      },\n      children: svgObjects,\n      value: \"\",\n    },\n  ]\n}\n","import type {\n  AnyCircuitElement,\n  SchematicComponent,\n  SchematicPort,\n} from \"circuit-json\"\nimport type { SvgObject } from \"lib/svg-object\"\nimport { su } from \"@tscircuit/circuit-json-util\"\nimport { applyToPoint, type Matrix } from \"transformation-matrix\"\n\nconst PIN_CIRCLE_RADIUS_MM = 0.02\n\nexport const createSvgObjectsForSchPortHover = ({\n  schPort,\n  transform,\n}: {\n  schPort: SchematicPort\n  transform: Matrix\n}): SvgObject[] => {\n  const screenSchPortPos = applyToPoint(transform, schPort.center)\n  const pinRadiusPx = Math.abs(transform.a) * PIN_CIRCLE_RADIUS_MM * 2\n\n  return [\n    {\n      name: \"g\",\n      type: \"element\",\n      value: \"\",\n      attributes: {\n        class: \"schematic-port-hover\",\n        \"data-schematic-port-id\": schPort.source_port_id,\n      },\n      children: [\n        {\n          name: \"circle\",\n          type: \"element\",\n          value: \"\",\n          attributes: {\n            cx: screenSchPortPos.x.toString(),\n            cy: screenSchPortPos.y.toString(),\n            r: pinRadiusPx.toString(),\n            fill: \"red\",\n            opacity: \"0\",\n          },\n          children: [],\n        },\n      ],\n    },\n  ]\n}\n\nexport const createSvgObjectsForSchComponentPortHovers = ({\n  component,\n  transform,\n  circuitJson,\n}: {\n  component: SchematicComponent\n  transform: Matrix\n  circuitJson: AnyCircuitElement[]\n}): SvgObject[] => {\n  const schematicPorts = su(circuitJson as any).schematic_port.list({\n    schematic_component_id: component.schematic_component_id,\n  }) as SchematicPort[]\n\n  const svgs: SvgObject[] = []\n  for (const schPort of schematicPorts) {\n    svgs.push(...createSvgObjectsForSchPortHover({ schPort, transform }))\n  }\n\n  return svgs\n}\n","import type { Point, AnyCircuitElement } from \"circuit-json\"\nimport { type INode as SvgObject, stringify } from \"svgson\"\nimport {\n  applyToPoint,\n  compose,\n  scale,\n  translate,\n  type Matrix,\n} from \"transformation-matrix\"\nimport { createSvgObjectsFromPcbBoard } from \"./svg-object-fns/create-svg-objects-from-pcb-board\"\nimport { createSvgObjectsFromSolderPaste } from \"./svg-object-fns/convert-circuit-json-to-solder-paste-mask\"\nimport type { PcbContext } from \"./convert-circuit-json-to-pcb-svg\"\nimport { DEFAULT_PCB_COLOR_MAP } from \"./colors\"\nimport { getSoftwareUsedString } from \"../utils/get-software-used-string\"\nimport { CIRCUIT_TO_SVG_VERSION } from \"../package-version\"\n\nconst OBJECT_ORDER: AnyCircuitElement[\"type\"][] = [\n  \"pcb_board\",\n  \"pcb_solder_paste\",\n]\n\ninterface Options {\n  layer: \"top\" | \"bottom\"\n  width?: number\n  height?: number\n  includeVersion?: boolean\n}\n\nexport function convertCircuitJsonToSolderPasteMask(\n  circuitJson: AnyCircuitElement[],\n  options: Options,\n): string {\n  let minX = Number.POSITIVE_INFINITY\n  let minY = Number.POSITIVE_INFINITY\n  let maxX = Number.NEGATIVE_INFINITY\n  let maxY = Number.NEGATIVE_INFINITY\n\n  // Filter to include only pcb_board and pcb_solder_paste elements for the specified layer\n  const filteredCircuitJson = circuitJson.filter(\n    (elm) =>\n      elm.type === \"pcb_board\" ||\n      (elm.type === \"pcb_solder_paste\" && elm.layer === options.layer),\n  )\n\n  // Process filtered elements to determine bounds\n  for (const item of filteredCircuitJson) {\n    if (item.type === \"pcb_board\") {\n      if (\n        item.outline &&\n        Array.isArray(item.outline) &&\n        item.outline.length >= 3\n      ) {\n        updateBoundsToIncludeOutline(item.outline)\n      } else if (\"center\" in item && \"width\" in item && \"height\" in item) {\n        updateBounds(item.center, item.width, item.height)\n      }\n    } else if (item.type === \"pcb_solder_paste\" && \"x\" in item && \"y\" in item) {\n      updateBounds({ x: item.x, y: item.y }, 0, 0)\n    }\n  }\n\n  const padding = 1 // Consistent with reference code\n  const circuitWidth = maxX - minX + 2 * padding\n  const circuitHeight = maxY - minY + 2 * padding\n\n  const svgWidth = options.width ?? 800\n  const svgHeight = options.height ?? 600\n\n  // Calculate scale factor to fit the circuit within the SVG, maintaining aspect ratio\n  const scaleX = svgWidth / circuitWidth\n  const scaleY = svgHeight / circuitHeight\n  const scaleFactor = Math.min(scaleX, scaleY)\n\n  // Calculate centering offsets\n  const offsetX = (svgWidth - circuitWidth * scaleFactor) / 2\n  const offsetY = (svgHeight - circuitHeight * scaleFactor) / 2\n\n  const transform = compose(\n    translate(\n      offsetX - minX * scaleFactor + padding * scaleFactor,\n      svgHeight - offsetY + minY * scaleFactor - padding * scaleFactor,\n    ),\n    scale(scaleFactor, -scaleFactor), // Flip in y-direction\n  )\n\n  const ctx: PcbContext = {\n    transform,\n    layer: options.layer,\n    colorMap: DEFAULT_PCB_COLOR_MAP,\n  }\n\n  // Sort elements by OBJECT_ORDER and convert to SVG objects\n  const svgObjects = filteredCircuitJson\n    .sort(\n      (a, b) =>\n        (OBJECT_ORDER.indexOf(b.type) ?? 9999) -\n        (OBJECT_ORDER.indexOf(a.type) ?? 9999),\n    )\n    .flatMap((item) => createSvgObjects({ elm: item, ctx }))\n\n  const softwareUsedString = getSoftwareUsedString(circuitJson)\n  const version = CIRCUIT_TO_SVG_VERSION\n\n  const svgObject: SvgObject = {\n    name: \"svg\",\n    type: \"element\",\n    attributes: {\n      xmlns: \"http://www.w3.org/2000/svg\",\n      width: svgWidth.toString(),\n      height: svgHeight.toString(),\n      ...(softwareUsedString && {\n        \"data-software-used-string\": softwareUsedString,\n      }),\n      ...(options.includeVersion && {\n        \"data-circuit-to-svg-version\": version,\n      }),\n    },\n    value: \"\",\n    children: [\n      {\n        name: \"style\",\n        type: \"element\",\n        children: [\n          {\n            type: \"text\",\n            value: \"\",\n          },\n        ],\n      },\n      {\n        name: \"rect\",\n        type: \"element\",\n        attributes: {\n          class: \"boundary\",\n          x: \"0\",\n          y: \"0\",\n          fill: \"#000\",\n          width: svgWidth.toString(),\n          height: svgHeight.toString(),\n        },\n      },\n      createSvgObjectFromPcbBoundary(transform, minX, minY, maxX, maxY),\n      ...svgObjects,\n    ].filter((child): child is SvgObject => child !== null),\n  }\n\n  try {\n    return stringify(svgObject)\n  } catch (error) {\n    console.error(\"Error stringifying SVG object:\", error)\n    throw error\n  }\n\n  function updateBounds(center: any, width: any, height: any) {\n    const halfWidth = width / 2\n    const halfHeight = height / 2\n    minX = Math.min(minX, center.x - halfWidth)\n    minY = Math.min(minY, center.y - halfHeight)\n    maxX = Math.max(maxX, center.x + halfWidth)\n    maxY = Math.max(maxY, center.y + halfHeight)\n  }\n\n  function updateBoundsToIncludeOutline(outline: Point[]) {\n    for (const point of outline) {\n      minX = Math.min(minX, point.x)\n      minY = Math.min(minY, point.y)\n      maxX = Math.max(maxX, point.x)\n      maxY = Math.max(maxY, point.y)\n    }\n  }\n}\n\ninterface CreateSvgObjectsParams {\n  elm: AnyCircuitElement\n  ctx: PcbContext\n}\n\nfunction createSvgObjects({ elm, ctx }: CreateSvgObjectsParams): SvgObject[] {\n  const { transform } = ctx\n  switch (elm.type) {\n    case \"pcb_board\":\n      return createSvgObjectsFromPcbBoard(elm, ctx)\n    case \"pcb_solder_paste\":\n      return createSvgObjectsFromSolderPaste(elm, ctx)\n    default:\n      return []\n  }\n}\n\nfunction createSvgObjectFromPcbBoundary(\n  transform: Matrix,\n  minX: number,\n  minY: number,\n  maxX: number,\n  maxY: number,\n): SvgObject {\n  const [x1, y1] = applyToPoint(transform, [minX, minY])\n  const [x2, y2] = applyToPoint(transform, [maxX, maxY])\n  const width = Math.abs(x2 - x1)\n  const height = Math.abs(y2 - y1)\n  const x = Math.min(x1, x2)\n  const y = Math.min(y1, y2)\n  return {\n    name: \"rect\",\n    type: \"element\",\n    value: \"\",\n    children: [],\n    attributes: {\n      class: \"pcb-boundary\",\n      fill: \"none\",\n      stroke: \"#fff\",\n      \"stroke-width\": \"0.3\",\n      x: x.toString(),\n      y: y.toString(),\n      width: width.toString(),\n      height: height.toString(),\n    },\n  }\n}\n","import type { PcbSolderPaste } from \"circuit-json\"\nimport { applyToPoint } from \"transformation-matrix\"\nimport { solderPasteLayerNameToColor } from \"../layer-name-to-color\"\nimport type { PcbContext } from \"../convert-circuit-json-to-pcb-svg\"\n\nexport function createSvgObjectsFromSolderPaste(\n  solderPaste: PcbSolderPaste,\n  ctx: PcbContext,\n): any {\n  const { transform, layer: layerFilter } = ctx\n  if (layerFilter && solderPaste.layer !== layerFilter) return []\n  const [x, y] = applyToPoint(transform, [solderPaste.x, solderPaste.y])\n\n  if (solderPaste.shape === \"rect\" || solderPaste.shape === \"rotated_rect\") {\n    const width = solderPaste.width * Math.abs(transform.a)\n    const height = solderPaste.height * Math.abs(transform.d)\n\n    if (solderPaste.shape === \"rotated_rect\" && solderPaste.ccw_rotation) {\n      return [\n        {\n          name: \"rect\",\n          type: \"element\",\n          attributes: {\n            class: \"pcb-solder-paste\",\n            fill: solderPasteLayerNameToColor(solderPaste.layer),\n            x: (-width / 2).toString(),\n            y: (-height / 2).toString(),\n            width: width.toString(),\n            height: height.toString(),\n            transform: `translate(${x} ${y}) rotate(${-solderPaste.ccw_rotation})`,\n          },\n        },\n      ]\n    }\n\n    return [\n      {\n        name: \"rect\",\n        type: \"element\",\n        attributes: {\n          class: \"pcb-solder-paste\",\n          fill: solderPasteLayerNameToColor(solderPaste.layer),\n          x: (x - width / 2).toString(),\n          y: (y - height / 2).toString(),\n          width: width.toString(),\n          height: height.toString(),\n        },\n      },\n    ]\n  }\n  // Implement pill-shaped SMT pad\n  if (solderPaste.shape === \"pill\") {\n    const width = solderPaste.width * Math.abs(transform.a)\n    const height = solderPaste.height * Math.abs(transform.d)\n    const radius = solderPaste.radius * Math.abs(transform.a)\n\n    return [\n      {\n        name: \"rect\",\n        type: \"element\",\n        attributes: {\n          class: \"pcb-solder-paste\",\n          fill: solderPasteLayerNameToColor(solderPaste.layer),\n          x: (x - width / 2).toString(),\n          y: (y - height / 2).toString(),\n          width: width.toString(),\n          height: height.toString(),\n          rx: radius.toString(),\n        },\n      },\n    ]\n  }\n  // Implement circle-shaped SMT pad\n  if (solderPaste.shape === \"circle\") {\n    const radius = solderPaste.radius * Math.abs(transform.a)\n\n    return [\n      {\n        name: \"circle\",\n        type: \"element\",\n        attributes: {\n          class: \"pcb-solder-paste\",\n          fill: solderPasteLayerNameToColor(solderPaste.layer),\n          cx: x.toString(),\n          cy: y.toString(),\n          r: radius.toString(),\n        },\n      },\n    ]\n  }\n}\n"],"mappings":"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","names":["applyToPoint","compose","scale","translate","applyToPoint","applyToPoint","applyToPoint","colorMap","applyToPoint","colorMap","applyToPoint","compose","rotate","translate","matrixToString","colorMap","applyToPoint","colorMap","applyToPoint","colorMap","applyToPoint","colorMap","applyToPoint","colorMap","colorMap","applyToPoint","applyToPoint","colorMap","applyToPoint","applyToPoint","colorMap","applyToPoint","colorMap","applyToPoint","colorMap","applyToPoint","su","applyToPoint","applyToPoint","compose","rotate","translate","matrixToString","colorMap","applyToPoint","colorMap","compose","translate","scale","applyToPoint","stringify","su","applyToPoint","compose","scale","translate","applyToPoint","applyToPoint","applyToPoint","applyToPoint","HOLE_COLOR","applyToPoint","HOLE_COLOR","applyToPoint","PAD_COLOR","OBJECT_ORDER","compose","translate","scale","createSvgObjects","stringify","su","applyToPoint","stringify","applyToPoint","applyToPoint","su","applyToPoint","compose","compose","scale","translate","applyToPoint","ninePointAnchorToTextAnchor","colorMap","su","applyToPoint","compose","ninePointAnchorToTextAnchor","su","applyToPoint","applyToPoint","su","su","applyToPoint","applyToPoint","applyToPoint","applyToPoint","colorMap","colorMap","applyToPoint","su","applyToPoint","colorMap","applyToPoint","applyToPoint","colorMap","applyToPoint","compose","rotate","scale","translate","applyToPoint","compose","rotate","scale","translate","symbols","colorMap","symbols","rotate","applyToPoint","compose","translate","scale","colorMap","applyToPoint","compose","translate","scale","rotate","applyToPoint","colorMap","applyToPoint","applyToPoint","colorMap","applyToPoint","su","applyToPoint","PIN_CIRCLE_RADIUS_MM","colorMap","stringify","stringify","applyToPoint","compose","scale","translate","applyToPoint","applyToPoint","OBJECT_ORDER","compose","translate","scale","createSvgObjects","createSvgObjectFromPcbBoundary","stringify","applyToPoint"]}