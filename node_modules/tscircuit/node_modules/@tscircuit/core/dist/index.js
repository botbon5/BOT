var __defProp = Object.defineProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};

// lib/components/index.ts
var components_exports = {};
__export(components_exports, {
  Battery: () => Battery,
  Board: () => Board,
  Breakout: () => Breakout,
  BreakoutPoint: () => BreakoutPoint,
  Capacitor: () => Capacitor,
  Chip: () => Chip,
  Constraint: () => Constraint2,
  Crystal: () => Crystal,
  Cutout: () => Cutout,
  Diode: () => Diode,
  FabricationNotePath: () => FabricationNotePath,
  FabricationNoteText: () => FabricationNoteText,
  Footprint: () => Footprint,
  Fuse: () => Fuse,
  Group: () => Group,
  Hole: () => Hole,
  Inductor: () => Inductor,
  Jumper: () => Jumper,
  Keepout: () => Keepout,
  Led: () => Led,
  Mosfet: () => Mosfet,
  Net: () => Net,
  NetLabel: () => NetLabel,
  NormalComponent: () => NormalComponent,
  PcbTrace: () => PcbTrace,
  PinHeader: () => PinHeader,
  PlatedHole: () => PlatedHole,
  Port: () => Port,
  Potentiometer: () => Potentiometer,
  PowerSource: () => PowerSource,
  PrimitiveComponent: () => PrimitiveComponent2,
  PushButton: () => PushButton,
  Renderable: () => Renderable,
  Resistor: () => Resistor,
  Resonator: () => Resonator,
  SchematicBox: () => SchematicBox,
  SchematicCell: () => SchematicCell,
  SchematicRow: () => SchematicRow,
  SchematicTable: () => SchematicTable,
  SchematicText: () => SchematicText,
  SilkscreenCircle: () => SilkscreenCircle,
  SilkscreenLine: () => SilkscreenLine,
  SilkscreenPath: () => SilkscreenPath,
  SilkscreenRect: () => SilkscreenRect,
  SilkscreenText: () => SilkscreenText,
  SmtPad: () => SmtPad,
  SolderJumper: () => SolderJumper,
  Subcircuit: () => Subcircuit,
  Switch: () => Switch,
  TestPoint: () => TestPoint,
  Trace: () => Trace3,
  TraceHint: () => TraceHint,
  Transistor: () => Transistor,
  Via: () => Via
});

// lib/components/base-components/NormalComponent/NormalComponent.ts
import { fp } from "@tscircuit/footprinter";
import {
  pcb_manual_edit_conflict_warning,
  point3,
  rotation,
  schematic_manual_edit_conflict_warning
} from "circuit-json";
import Debug4 from "debug";

// lib/fiber/create-instance-from-react-element.ts
import React from "react";
import ReactReconciler from "react-reconciler";
import ReactReconciler18 from "react-reconciler-18";
import { DefaultEventPriority } from "react-reconciler/constants.js";

// lib/components/base-components/Renderable.ts
import Debug from "debug";
var debug = Debug("tscircuit:renderable");
var orderedRenderPhases = [
  "ReactSubtreesRender",
  "PcbFootprintStringRender",
  "InitializePortsFromChildren",
  "CreateNetsFromProps",
  "CreateTracesFromProps",
  "CreateTracesFromNetLabels",
  "CreateTraceHintsFromProps",
  "SourceGroupRender",
  "AssignNameToUnnamedComponents",
  "SourceRender",
  "SourceParentAttachment",
  "PortMatching",
  "OptimizeSelectorCache",
  "SourceTraceRender",
  "SourceAddConnectivityMapKey",
  "SchematicComponentRender",
  "SchematicPortRender",
  "SchematicPrimitiveRender",
  "SchematicLayout",
  "SchematicTraceRender",
  "SchematicReplaceNetLabelsWithSymbols",
  "PcbComponentRender",
  "PcbPrimitiveRender",
  "PcbFootprintLayout",
  "PcbPortRender",
  "PcbPortAttachment",
  "PcbLayout",
  "PcbComponentSizeCalculation",
  "PcbBoardAutoSize",
  "PcbTraceHintRender",
  "PcbTraceRender",
  "PcbRouteNetIslands",
  "PcbDesignRuleChecks",
  "CadModelRender",
  "PartsEngineRender"
];
var globalRenderCounter = 0;
var Renderable = class {
  renderPhaseStates;
  shouldBeRemoved = false;
  children;
  /** PCB-only SMTPads, PlatedHoles, Holes, Silkscreen elements etc. */
  isPcbPrimitive = false;
  /** Schematic-only, lines, boxes, indicators etc. */
  isSchematicPrimitive = false;
  _renderId;
  _currentRenderPhase = null;
  _asyncEffects = [];
  parent = null;
  constructor(props) {
    this._renderId = `${globalRenderCounter++}`;
    this.children = [];
    this.renderPhaseStates = {};
    for (const phase of orderedRenderPhases) {
      this.renderPhaseStates[phase] = {
        initialized: false,
        dirty: false
      };
    }
  }
  _markDirty(phase) {
    this.renderPhaseStates[phase].dirty = true;
    const phaseIndex = orderedRenderPhases.indexOf(phase);
    for (let i = phaseIndex + 1; i < orderedRenderPhases.length; i++) {
      this.renderPhaseStates[orderedRenderPhases[i]].dirty = true;
    }
    if (this.parent?._markDirty) {
      this.parent._markDirty(phase);
    }
  }
  _queueAsyncEffect(effectName, effect) {
    const asyncEffect = {
      promise: effect(),
      // TODO don't start effects until end of render cycle
      phase: this._currentRenderPhase,
      effectName,
      complete: false
    };
    this._asyncEffects.push(asyncEffect);
    if ("root" in this && this.root) {
      ;
      this.root.emit("asyncEffect:start", {
        effectName,
        componentDisplayName: this.getString(),
        phase: asyncEffect.phase
      });
    }
    asyncEffect.promise.then(() => {
      asyncEffect.complete = true;
      if ("root" in this && this.root) {
        ;
        this.root.emit("asyncEffect:end", {
          effectName,
          componentDisplayName: this.getString(),
          phase: asyncEffect.phase
        });
      }
    }).catch((error) => {
      console.error(
        `Async effect error in ${asyncEffect.phase} "${effectName}":
${error.stack}`
      );
      asyncEffect.complete = true;
      if ("root" in this && this.root) {
        ;
        this.root.emit("asyncEffect:end", {
          effectName,
          componentDisplayName: this.getString(),
          phase: asyncEffect.phase,
          error: error.toString()
        });
      }
    });
  }
  _emitRenderLifecycleEvent(phase, startOrEnd) {
    debug(`${phase}:${startOrEnd} ${this.getString()}`);
    const granular_event_type = `renderable:renderLifecycle:${phase}:${startOrEnd}`;
    const eventPayload = {
      renderId: this._renderId,
      componentDisplayName: this.getString(),
      type: granular_event_type
    };
    if ("root" in this && this.root) {
      ;
      this.root.emit(granular_event_type, eventPayload);
      this.root.emit("renderable:renderLifecycle:anyEvent", {
        ...eventPayload,
        type: granular_event_type
      });
    }
  }
  getString() {
    return this.constructor.name;
  }
  _hasIncompleteAsyncEffects() {
    return this._asyncEffects.some((effect) => !effect.complete);
  }
  getCurrentRenderPhase() {
    return this._currentRenderPhase;
  }
  getRenderGraph() {
    return {
      id: this._renderId,
      currentPhase: this._currentRenderPhase,
      renderPhaseStates: this.renderPhaseStates,
      shouldBeRemoved: this.shouldBeRemoved,
      children: this.children.map(
        (child) => child.getRenderGraph()
      )
    };
  }
  runRenderCycle() {
    for (const renderPhase of orderedRenderPhases) {
      this.runRenderPhaseForChildren(renderPhase);
      this.runRenderPhase(renderPhase);
    }
  }
  /**
   * This runs all the render methods for a given phase, calling one of:
   * - doInitial*
   * - update*
   *  -remove*
   *  ...depending on the current state of the component.
   */
  runRenderPhase(phase) {
    this._currentRenderPhase = phase;
    const phaseState = this.renderPhaseStates[phase];
    const isInitialized = phaseState.initialized;
    const isDirty = phaseState.dirty;
    if (!isInitialized && this.shouldBeRemoved) return;
    if (this.shouldBeRemoved && isInitialized) {
      this._emitRenderLifecycleEvent(phase, "start");
      this?.[`remove${phase}`]?.();
      phaseState.initialized = false;
      phaseState.dirty = false;
      this._emitRenderLifecycleEvent(phase, "end");
      return;
    }
    const prevPhaseIndex = orderedRenderPhases.indexOf(phase) - 1;
    if (prevPhaseIndex >= 0) {
      const prevPhase = orderedRenderPhases[prevPhaseIndex];
      const hasIncompleteEffects = this._asyncEffects.filter((e) => e.phase === prevPhase).some((e) => !e.complete);
      if (hasIncompleteEffects) return;
    }
    this._emitRenderLifecycleEvent(phase, "start");
    if (isInitialized) {
      if (isDirty) {
        ;
        this?.[`update${phase}`]?.();
        phaseState.dirty = false;
      }
      this._emitRenderLifecycleEvent(phase, "end");
      return;
    }
    phaseState.dirty = false;
    this?.[`doInitial${phase}`]?.();
    phaseState.initialized = true;
    this._emitRenderLifecycleEvent(phase, "end");
  }
  runRenderPhaseForChildren(phase) {
    for (const child of this.children) {
      child.runRenderPhaseForChildren(phase);
      child.runRenderPhase(phase);
    }
  }
  renderError(message) {
    if (typeof message === "string") {
      throw new Error(message);
    }
    throw new Error(JSON.stringify(message, null, 2));
  }
};

// lib/fiber/catalogue.ts
var catalogue = {};
var extendCatalogue = (objects) => {
  const altKeys = Object.fromEntries(
    Object.entries(objects).map(([key, v]) => [key.toLowerCase(), v])
  );
  Object.assign(catalogue, objects);
  Object.assign(catalogue, altKeys);
};

// lib/errors/InvalidProps.ts
var InvalidProps = class extends Error {
  constructor(componentName, originalProps, formattedError) {
    let message;
    const propsWithError = Object.keys(formattedError).filter(
      (k) => k !== "_errors"
    );
    const propMessage = propsWithError.map((k) => {
      if (formattedError[k]._errors[0]) {
        return `${k} (${formattedError[k]._errors[0]})`;
      }
      return `${k} (${JSON.stringify(formattedError[k])})`;
    }).join(", ");
    if ("name" in originalProps) {
      message = `Invalid props for ${componentName} "${originalProps.name}": ${propMessage}`;
    } else if ("footprint" in originalProps && typeof originalProps.footprint === "string") {
      message = `Invalid props for ${componentName} (unnamed ${originalProps.footprint} component): ${propMessage}`;
    } else {
      message = `Invalid props for ${componentName} (unnamed): ${propMessage}`;
    }
    super(message);
    this.componentName = componentName;
    this.originalProps = originalProps;
    this.formattedError = formattedError;
  }
};

// lib/fiber/create-instance-from-react-element.ts
import { identity as identity2 } from "transformation-matrix";

// lib/components/base-components/PrimitiveComponent/PrimitiveComponent.ts
import "debug";

// lib/utils/selector-matching/is-matching-selector.ts
function isMatchingSelector(component, selector) {
  const idMatch = selector.match(/^#(\w+)/);
  if (idMatch) {
    return component.props.id === idMatch[1];
  }
  const classMatch = selector.match(/^\.(\w+)/);
  if (classMatch) {
    return component.isMatchingNameOrAlias(classMatch[1]);
  }
  let [type, ...conditions] = selector.split(/(?=[#.[])/);
  if (type === "pin") type = "port";
  if (type && type !== "*" && component.lowercaseComponentName !== type.toLowerCase()) {
    return false;
  }
  return conditions.every((condition) => {
    if (condition.startsWith("#")) {
      return component.props.id === condition.slice(1);
    }
    if (condition.startsWith(".")) {
      return component.isMatchingNameOrAlias(condition.slice(1));
    }
    const match = condition.match(/\[(\w+)=['"]?(.+?)['"]?\]/);
    if (!match) return true;
    const [, prop, value] = match;
    return component.props[prop].toString() === value;
  });
}

// lib/components/base-components/PrimitiveComponent/PrimitiveComponent.ts
import { symbols } from "schematic-symbols";
import {
  applyToPoint,
  compose,
  flipY,
  identity,
  rotate,
  translate
} from "transformation-matrix";
import { z } from "zod";
import { selectOne, selectAll } from "css-select";

// lib/components/base-components/PrimitiveComponent/cssSelectPrimitiveComponentAdapter.ts
var cssSelectPrimitiveComponentAdapter = {
  // Is the node an element?
  isTag: (node) => true,
  // Get the parent of the node
  getParent: (node) => node.parent,
  // Get the children of the node
  getChildren: (node) => node.children,
  // Get the name of the tag
  getName: (node) => node.lowercaseComponentName,
  // Get the attribute value
  getAttributeValue: (node, name) => {
    if (name === "class" && "getNameAndAliases" in node) {
      return node.getNameAndAliases().join(" ");
    }
    if (name === "name" && node._parsedProps?.name) {
      return node._parsedProps.name;
    }
    if (node._parsedProps && name in node._parsedProps) {
      const value = node._parsedProps[name];
      return typeof value === "string" ? value : value !== null && value !== void 0 ? String(value) : null;
    }
    return null;
  },
  // Check if a node has an attribute
  hasAttrib: (node, name) => {
    if (name === "class") {
      return !!node._parsedProps?.name;
    }
    return node._parsedProps && name in node._parsedProps;
  },
  // Get the siblings of the node
  getSiblings: (node) => {
    if (!node.parent) return [];
    return node.parent.children;
  },
  // Get the previous sibling
  prevElementSibling: (node) => {
    if (!node.parent) return null;
    const siblings = node.parent.children;
    const idx = siblings.indexOf(node);
    return idx > 0 ? siblings[idx - 1] : null;
  },
  // Get the text content
  getText: () => "",
  // Remove the node
  removeSubsets: (nodes) => {
    return nodes.filter(
      (node, i) => !nodes.some(
        (other, j) => i !== j && other !== node && other.getDescendants().includes(node)
      )
    );
  },
  // Determine if element a is a subset of element b
  existsOne: (test, nodes) => {
    return nodes.some(test);
  },
  // Find all elements matching a selector
  findAll: (test, nodes) => {
    const result = [];
    const recurse = (node) => {
      if (test(node)) {
        result.push(node);
      }
      for (const child of node.children) {
        recurse(child);
      }
    };
    for (const node of nodes) {
      recurse(node);
    }
    return result;
  },
  // Find one element matching a selector
  findOne: (test, nodes) => {
    for (const node of nodes) {
      if (test(node)) return node;
      const children = node.children;
      if (children.length > 0) {
        const result = cssSelectPrimitiveComponentAdapter.findOne(
          test,
          children
        );
        if (result) return result;
      }
    }
    return null;
  },
  equals: (a, b) => {
    return a._renderId === b._renderId;
  },
  isHovered: (elem) => false,
  isVisited: (elem) => false,
  isActive: (elem) => false
};
var cssSelectPrimitiveComponentAdapterWithoutSubcircuits = {
  ...cssSelectPrimitiveComponentAdapter,
  getChildren: (node) => node.children.filter((c) => !c.isSubcircuit)
};
var cssSelectPrimitiveComponentAdapterOnlySubcircuits = {
  ...cssSelectPrimitiveComponentAdapter,
  getChildren: (node) => node.children.filter((c) => c.isSubcircuit)
};

// lib/components/base-components/PrimitiveComponent/preprocessSelector.ts
var preprocessSelector = (selector) => {
  if (/net\.[^\s>]*\./.test(selector)) {
    throw new Error(
      'Net names cannot contain a period, try using "sel.net..." to autocomplete with conventional net names, e.g. V3_3'
    );
  }
  if (/net\.[^\s>]*[+-]/.test(selector)) {
    throw new Error(
      'Net names cannot contain "+" or "-", try using underscores instead, e.g. VCC_P'
    );
  }
  if (/net\.[0-9]/.test(selector)) {
    const match = selector.match(/net\.([^ >]+)/);
    const netName = match ? match[1] : "";
    throw new Error(
      `Net name "${netName}" cannot start with a number, try using a prefix like "VBUS1"`
    );
  }
  return selector.replace(/ pin(?=[\d.])/g, " port").replace(/ subcircuit\./g, " group[isSubcircuit=true]").replace(/([^ ])\>([^ ])/g, "$1 > $2").replace(
    /(^|[ >])(?!pin\.)(?!port\.)(?!net\.)([A-Z][A-Za-z0-9_-]*)\.([A-Za-z0-9_-]+)/g,
    (_, sep, name, pin) => {
      const pinPart = /^\d+$/.test(pin) ? `pin${pin}` : pin;
      return `${sep}.${name} > .${pinPart}`;
    }
  ).trim();
};

// lib/components/base-components/PrimitiveComponent/PrimitiveComponent.ts
var cssSelectOptionsInsideSubcircuit = {
  adapter: cssSelectPrimitiveComponentAdapterWithoutSubcircuits,
  cacheResults: true
};
var PrimitiveComponent2 = class extends Renderable {
  parent = null;
  children;
  childrenPendingRemoval;
  get config() {
    return {
      componentName: "",
      zodProps: z.object({}).passthrough()
    };
  }
  props;
  _parsedProps;
  get componentName() {
    return this.config.componentName;
  }
  getInheritedProperty(propertyName) {
    let current = this;
    while (current) {
      if (current._parsedProps && propertyName in current._parsedProps) {
        return current._parsedProps[propertyName];
      }
      current = current.parent;
    }
    if (this.root?.platform && propertyName in this.root.platform) {
      return this.root.platform[propertyName];
    }
    return void 0;
  }
  get lowercaseComponentName() {
    return this.componentName.toLowerCase();
  }
  externallyAddedAliases;
  /**
   * An subcircuit is self-contained. All the selectors inside
   * a subcircuit are relative to the subcircuit group. You can have multiple
   * subcircuits and their selectors will not interact with each other (even if the
   * components share the same names) unless you explicitly break out some ports
   */
  get isSubcircuit() {
    return Boolean(this.props.subcircuit) || this.lowercaseComponentName === "group" && this?.parent?.isRoot;
  }
  get isGroup() {
    return this.lowercaseComponentName === "group";
  }
  get name() {
    return this._parsedProps.name ?? this.fallbackUnassignedName;
  }
  /**
   * A primitive container is a component that contains one or more ports and
   * primitive components that are designed to interact.
   *
   * For example a resistor contains ports and smtpads that interact, so the
   * resistor is a primitive container. Inside a primitive container, the ports
   * and pads are likely to reference each other and look for eachother during
   * the port matching phase.
   *
   */
  isPrimitiveContainer = false;
  canHaveTextChildren = false;
  source_group_id = null;
  source_component_id = null;
  schematic_component_id = null;
  pcb_component_id = null;
  cad_component_id = null;
  fallbackUnassignedName;
  constructor(props) {
    super(props);
    this.children = [];
    this.childrenPendingRemoval = [];
    this.props = props ?? {};
    this.externallyAddedAliases = [];
    const zodProps = "partial" in this.config.zodProps ? this.config.zodProps.partial({
      name: true
    }) : this.config.zodProps;
    const parsePropsResult = zodProps.safeParse(props ?? {});
    if (parsePropsResult.success) {
      this._parsedProps = parsePropsResult.data;
    } else {
      throw new InvalidProps(
        this.lowercaseComponentName,
        this.props,
        parsePropsResult.error.format()
      );
    }
  }
  setProps(props) {
    const newProps = this.config.zodProps.parse({
      ...this.props,
      ...props
    });
    const oldProps = this.props;
    this.props = newProps;
    this._parsedProps = this.config.zodProps.parse(props);
    this.onPropsChange({
      oldProps,
      newProps,
      changedProps: Object.keys(props)
    });
    this.parent?.onChildChanged?.(this);
  }
  /**
   * Computes a transformation matrix from the props of this component for PCB
   * components
   */
  computePcbPropsTransform() {
    const { _parsedProps: props } = this;
    const matrix = compose(
      translate(props.pcbX ?? 0, props.pcbY ?? 0),
      rotate((props.pcbRotation ?? 0) * Math.PI / 180)
    );
    return matrix;
  }
  /**
   * Compute a transformation matrix combining all parent transforms for PCB
   * components, including this component's translation and rotation.
   *
   * This is used to compute this component's position as well as all children
   * components positions before layout is applied
   */
  _computePcbGlobalTransformBeforeLayout() {
    const { _parsedProps: props } = this;
    const manualPlacement = this.getSubcircuit()._getPcbManualPlacementForComponent(this);
    if (manualPlacement && this.props.pcbX === void 0 && this.props.pcbY === void 0) {
      return compose(
        this.parent?._computePcbGlobalTransformBeforeLayout() ?? identity(),
        compose(
          translate(manualPlacement.x, manualPlacement.y),
          rotate((props.pcbRotation ?? 0) * Math.PI / 180)
        )
      );
    }
    if (this.isPcbPrimitive) {
      const primitiveContainer = this.getPrimitiveContainer();
      if (primitiveContainer) {
        const isFlipped = primitiveContainer._parsedProps.layer === "bottom";
        const containerCenter = primitiveContainer._getGlobalPcbPositionBeforeLayout();
        if (isFlipped) {
          const flipOperation = compose(
            translate(containerCenter.x, containerCenter.y),
            flipY(),
            translate(-containerCenter.x, -containerCenter.y)
          );
          return compose(
            this.parent?._computePcbGlobalTransformBeforeLayout() ?? identity(),
            flipY(),
            this.computePcbPropsTransform()
          );
        }
      }
    }
    return compose(
      this.parent?._computePcbGlobalTransformBeforeLayout() ?? identity(),
      this.computePcbPropsTransform()
    );
  }
  getPrimitiveContainer() {
    if (this.isPrimitiveContainer) return this;
    return this.parent?.getPrimitiveContainer?.() ?? null;
  }
  /**
   * Compute the PCB bounds of this component the circuit json elements
   * associated with it.
   */
  _getPcbCircuitJsonBounds() {
    return {
      center: { x: 0, y: 0 },
      bounds: { left: 0, top: 0, right: 0, bottom: 0 },
      width: 0,
      height: 0
    };
  }
  /**
   * Determine if this pcb primitive should be flipped because the primitive
   * container is flipped
   *
   * TODO use footprint.originalLayer instead of assuming everything is defined
   * relative to the top layer
   */
  _getPcbPrimitiveFlippedHelpers() {
    const container = this.getPrimitiveContainer();
    const isFlipped = !container ? false : container._parsedProps.layer === "bottom";
    const maybeFlipLayer = (layer) => {
      if (isFlipped) {
        return layer === "top" ? "bottom" : "top";
      }
      return layer;
    };
    return { isFlipped, maybeFlipLayer };
  }
  /**
   * Set the position of this component from the layout solver. This method
   * should operate using CircuitJson associated with this component, like
   * _getPcbCircuitJsonBounds it can be called multiple times as different
   * parents apply layout to their children.
   */
  _setPositionFromLayout(newCenter) {
    throw new Error(
      `_setPositionFromLayout not implemented for ${this.componentName}`
    );
  }
  /**
   * Computes a transformation matrix from the props of this component for
   * schematic components
   */
  computeSchematicPropsTransform() {
    const { _parsedProps: props } = this;
    return compose(translate(props.schX ?? 0, props.schY ?? 0));
  }
  /**
   * Compute a transformation matrix combining all parent transforms for this
   * component
   */
  computeSchematicGlobalTransform() {
    const manualPlacementTransform = this._getSchematicGlobalManualPlacementTransform(this);
    if (manualPlacementTransform) return manualPlacementTransform;
    return compose(
      this.parent?.computeSchematicGlobalTransform?.() ?? identity(),
      this.computeSchematicPropsTransform()
    );
  }
  _getSchematicSymbolName() {
    const { _parsedProps: props } = this;
    const base_symbol_name = this.config.schematicSymbolName;
    const orientationRotationMap = {
      horizontal: 0,
      pos_left: 0,
      neg_right: 0,
      pos_right: 180,
      neg_left: 180,
      pos_top: 270,
      neg_bottom: 90,
      vertical: 270,
      pos_bottom: 90,
      neg_top: 90
    };
    let normalizedRotation = props.schOrientation !== void 0 ? orientationRotationMap[props.schOrientation] : props.schRotation;
    if (normalizedRotation === void 0) {
      normalizedRotation = 0;
    }
    normalizedRotation = normalizedRotation % 360;
    if (normalizedRotation < 0) {
      normalizedRotation += 360;
    }
    if (props.schRotation !== void 0 && normalizedRotation % 90 !== 0) {
      throw new Error(
        `Schematic rotation ${props.schRotation} is not supported for ${this.componentName}`
      );
    }
    const symbol_name_horz = `${base_symbol_name}_horz`;
    const symbol_name_vert = `${base_symbol_name}_vert`;
    const symbol_name_up = `${base_symbol_name}_up`;
    const symbol_name_down = `${base_symbol_name}_down`;
    const symbol_name_left = `${base_symbol_name}_left`;
    const symbol_name_right = `${base_symbol_name}_right`;
    if (symbol_name_right in symbols && normalizedRotation === 0) {
      return symbol_name_right;
    }
    if (symbol_name_up in symbols && normalizedRotation === 90) {
      return symbol_name_up;
    }
    if (symbol_name_left in symbols && normalizedRotation === 180) {
      return symbol_name_left;
    }
    if (symbol_name_down in symbols && normalizedRotation === 270) {
      return symbol_name_down;
    }
    if (symbol_name_horz in symbols) {
      if (normalizedRotation === 0) return symbol_name_horz;
      if (normalizedRotation === 180) return symbol_name_horz;
    }
    if (symbol_name_vert in symbols) {
      if (normalizedRotation === 90) return symbol_name_vert;
      if (normalizedRotation === 270) return symbol_name_vert;
    }
    if (base_symbol_name in symbols) return base_symbol_name;
    return void 0;
  }
  _getSchematicSymbolNameOrThrow() {
    const symbol_name = this._getSchematicSymbolName();
    if (!symbol_name) {
      throw new Error(
        `No schematic symbol found (given: "${this.config.schematicSymbolName}")`
      );
    }
    return symbol_name;
  }
  getSchematicSymbol() {
    const symbol_name = this._getSchematicSymbolName();
    if (!symbol_name) return null;
    return symbols[symbol_name] ?? null;
  }
  /**
   * Subcircuit groups have a prop called "layout" that can include manual
   * placements for pcb components. These are typically added from an IDE
   */
  _getPcbManualPlacementForComponent(component) {
    if (!this.isSubcircuit) return null;
    const manualEdits = this.props.manualEdits;
    if (!manualEdits) return null;
    const placementConfigPositions = manualEdits?.pcb_placements;
    if (!placementConfigPositions) return null;
    for (const position of placementConfigPositions) {
      if (isMatchingSelector(component, position.selector) || component.props.name === position.selector) {
        const center = applyToPoint(
          this._computePcbGlobalTransformBeforeLayout(),
          position.center
        );
        return center;
      }
    }
    return null;
  }
  _getSchematicManualPlacementForComponent(component) {
    if (!this.isSubcircuit) return null;
    const manualEdits = this.props.manualEdits;
    if (!manualEdits) return null;
    const placementConfigPositions = manualEdits.schematic_placements;
    if (!placementConfigPositions) return null;
    for (const position of placementConfigPositions) {
      if (isMatchingSelector(component, position.selector) || component.props.name === position.selector) {
        const center = applyToPoint(
          this.computeSchematicGlobalTransform(),
          position.center
        );
        return center;
      }
    }
    return null;
  }
  _getSchematicGlobalManualPlacementTransform(component) {
    const manualEdits = this.getSubcircuit()?._parsedProps.manualEdits;
    if (!manualEdits) return null;
    for (const position of manualEdits.schematic_placements ?? []) {
      if (isMatchingSelector(component, position.selector) || component.props.name === position.selector) {
        if (position.relative_to === "group_center") {
          return compose(
            this.parent?._computePcbGlobalTransformBeforeLayout() ?? identity(),
            translate(position.center.x, position.center.y)
          );
        }
      }
    }
    return null;
  }
  _getGlobalPcbPositionBeforeLayout() {
    return applyToPoint(this._computePcbGlobalTransformBeforeLayout(), {
      x: 0,
      y: 0
    });
  }
  _getGlobalSchematicPositionBeforeLayout() {
    return applyToPoint(this.computeSchematicGlobalTransform(), { x: 0, y: 0 });
  }
  get root() {
    return this.parent?.root ?? null;
  }
  onAddToParent(parent) {
    this.parent = parent;
  }
  /**
   * Called whenever the props change
   */
  onPropsChange(params) {
  }
  onChildChanged(child) {
    this.parent?.onChildChanged?.(child);
  }
  add(component) {
    const textContent = component.__text;
    if (typeof textContent === "string") {
      if (this.canHaveTextChildren || textContent.trim() === "") {
        return;
      }
      throw new Error(
        `Invalid JSX Element: Expected a React component but received text "${textContent}"`
      );
    }
    if (Object.keys(component).length === 0) {
      return;
    }
    if (this.lowercaseComponentName === "board" && component.lowercaseComponentName === "board") {
      throw new Error("Nested boards are not supported");
    }
    if (!component.onAddToParent) {
      throw new Error(
        `Invalid JSX Element: Expected a React component but received "${JSON.stringify(
          component
        )}"`
      );
    }
    component.onAddToParent(this);
    component.parent = this;
    this.children.push(component);
  }
  addAll(components) {
    for (const component of components) {
      this.add(component);
    }
  }
  remove(component) {
    this.children = this.children.filter((c) => c !== component);
    this.childrenPendingRemoval.push(component);
    component.shouldBeRemoved = true;
  }
  getSubcircuitSelector() {
    const name = this.name;
    const endPart = name ? `${this.lowercaseComponentName}.${name}` : this.lowercaseComponentName;
    if (!this.parent) return endPart;
    if (this.parent.isSubcircuit) return endPart;
    return `${this.parent.getSubcircuitSelector()} > ${endPart}`;
  }
  getFullPathSelector() {
    const name = this.name;
    const endPart = name ? `${this.lowercaseComponentName}.${name}` : this.lowercaseComponentName;
    const parentSelector = this.parent?.getFullPathSelector?.();
    if (!parentSelector) return endPart;
    return `${parentSelector} > ${endPart}`;
  }
  getNameAndAliases() {
    return [this.name, ...this._parsedProps.portHints ?? []].filter(Boolean);
  }
  isMatchingNameOrAlias(name) {
    return this.getNameAndAliases().includes(name);
  }
  isMatchingAnyOf(aliases) {
    return this.getNameAndAliases().some(
      (a) => aliases.map((a2) => a2.toString()).includes(a)
    );
  }
  getPcbSize() {
    throw new Error(`getPcbSize not implemented for ${this.componentName}`);
  }
  doesSelectorMatch(selector) {
    const myTypeNames = [this.componentName, this.lowercaseComponentName];
    const myClassNames = [this.name].filter(Boolean);
    const parts = selector.trim().split(/\> /)[0];
    const firstPart = parts[0];
    if (parts.length > 1) return false;
    if (selector === "*") return true;
    if (selector[0] === "#" && selector.slice(1) === this.props.id) return true;
    if (selector[0] === "." && myClassNames.includes(selector.slice(1)))
      return true;
    if (/^[a-zA-Z0-9_]/.test(firstPart) && myTypeNames.includes(firstPart))
      return true;
    return false;
  }
  getSubcircuit() {
    if (this.isSubcircuit) return this;
    const group = this.parent?.getSubcircuit?.();
    if (!group)
      throw new Error("Component is not inside an opaque group (no board?)");
    return group;
  }
  getGroup() {
    if (this.isGroup) return this;
    return this.parent?.getGroup?.() ?? null;
  }
  doInitialAssignNameToUnnamedComponents() {
    if (!this._parsedProps.name) {
      this.fallbackUnassignedName = `UNNAMED_${this.getSubcircuit().subcircuit_id}`;
    }
  }
  doInitialOptimizeSelectorCache() {
    if (!this.isSubcircuit) return;
    const ports = this.selectAll("port");
    for (const port of ports) {
      const parentAliases = port.parent?.getNameAndAliases();
      const portAliases = port.getNameAndAliases();
      if (!parentAliases) continue;
      for (const parentAlias of parentAliases) {
        for (const portAlias of portAliases) {
          const selectors = [
            `.${parentAlias} > .${portAlias}`,
            `.${parentAlias} .${portAlias}`
          ];
          for (const selector of selectors) {
            const ar = this._cachedSelectAllQueries.get(selector);
            if (ar) {
              ar.push(port);
            } else {
              this._cachedSelectAllQueries.set(selector, [port]);
            }
          }
        }
      }
    }
    for (const [selector, ports2] of this._cachedSelectAllQueries.entries()) {
      if (ports2.length === 1) {
        this._cachedSelectOneQueries.set(selector, ports2[0]);
      }
    }
  }
  _cachedSelectAllQueries = /* @__PURE__ */ new Map();
  selectAll(selectorRaw) {
    if (this._cachedSelectAllQueries.has(selectorRaw)) {
      return this._cachedSelectAllQueries.get(
        selectorRaw
      );
    }
    const selector = preprocessSelector(selectorRaw);
    const result = selectAll(selector, this, cssSelectOptionsInsideSubcircuit);
    if (result.length > 0) {
      this._cachedSelectAllQueries.set(selectorRaw, result);
      return result;
    }
    const [firstpart, ...rest] = selector.split(" ");
    const subcircuit = selectOne(firstpart, this, {
      adapter: cssSelectPrimitiveComponentAdapterOnlySubcircuits
    });
    if (!subcircuit) return [];
    const result2 = subcircuit.selectAll(rest.join(" "));
    this._cachedSelectAllQueries.set(selectorRaw, result2);
    return result2;
  }
  _cachedSelectOneQueries = /* @__PURE__ */ new Map();
  selectOne(selectorRaw, options) {
    if (this._cachedSelectOneQueries.has(selectorRaw)) {
      return this._cachedSelectOneQueries.get(selectorRaw);
    }
    const selector = preprocessSelector(selectorRaw);
    if (options?.port) {
      options.type = "port";
    }
    let result = null;
    if (options?.type) {
      const allMatching = selectAll(
        selector,
        this,
        cssSelectOptionsInsideSubcircuit
      );
      result = allMatching.find(
        (n) => n.lowercaseComponentName === options.type
      );
    }
    result ??= selectOne(
      selector,
      this,
      cssSelectOptionsInsideSubcircuit
    );
    if (result) {
      this._cachedSelectOneQueries.set(selectorRaw, result);
      return result;
    }
    const [firstpart, ...rest] = selector.split(" ");
    const subcircuit = selectOne(firstpart, this, {
      adapter: cssSelectPrimitiveComponentAdapterOnlySubcircuits
    });
    if (!subcircuit) return null;
    result = subcircuit.selectOne(rest.join(" "), options);
    this._cachedSelectOneQueries.set(selectorRaw, result);
    return result;
  }
  getAvailablePcbLayers() {
    if (this.isPcbPrimitive) {
      const { maybeFlipLayer } = this._getPcbPrimitiveFlippedHelpers();
      if ("layer" in this._parsedProps || this.componentName === "SmtPad") {
        const layer = maybeFlipLayer(this._parsedProps.layer ?? "top");
        return [layer];
      }
      if ("layers" in this._parsedProps) {
        return this._parsedProps.layers;
      }
      if (this.componentName === "PlatedHole") {
        return this.root?._getBoard()?.allLayers ?? ["top", "bottom"];
      }
      return [];
    }
    return [];
  }
  /**
   * Returns all descendants
   *
   * NOTE: This crosses subcircuit boundaries, you may want to use
   * getSelectableDescendants instead
   */
  getDescendants() {
    const descendants = [];
    for (const child of this.children) {
      descendants.push(child);
      descendants.push(...child.getDescendants());
    }
    return descendants;
  }
  /**
   * Returns all descendants that are accessible without crossing a subcircuit
   * boundary
   */
  getSelectableDescendants() {
    const descendants = [];
    for (const child of this.children) {
      if (child.isSubcircuit) {
        descendants.push(child);
      } else {
        descendants.push(child);
        descendants.push(...child.getSelectableDescendants());
      }
    }
    return descendants;
  }
  /**
   * Return the number of pins in this component, this is important for
   * NormalComponents
   */
  _getPinCount() {
    return 0;
  }
  /**
   * If this component represents a SchematicBox (like a Chip), return the
   * dimensions of the box, which allows computing the position of ports etc.
   */
  _getSchematicBoxDimensions() {
    return null;
  }
  _getSchematicBoxComponentDimensions() {
    if (this.getSchematicSymbol()) return null;
    if (!this.config.shouldRenderAsSchematicBox) return null;
    const { _parsedProps: props } = this;
    const dimensions = {
      schWidth: props.schWidth,
      schHeight: props.schHeight
    };
    return dimensions;
  }
  // TODO we shouldn't need to override this, errors can be rendered and handled
  // by the Renderable class, however, the Renderable class currently doesn't
  // have access to the database or cleanup
  renderError(message) {
    if (typeof message === "string") {
      return super.renderError(message);
    }
    this.root?.db.pcb_placement_error.insert(message);
  }
  getString() {
    const { lowercaseComponentName: cname, _parsedProps: props, parent } = this;
    if (props?.pinNumber !== void 0 && parent?.props?.name && props?.name) {
      return `<${cname}#${this._renderId}(pin:${props.pinNumber} .${parent?.props.name}>.${props.name}) />`;
    }
    if (parent?.props?.name && props?.name) {
      return `<${cname}#${this._renderId}(.${parent?.props.name}>.${props?.name}) />`;
    }
    if (props?.from && props?.to) {
      return `<${cname}#${this._renderId}(from:${props.from} to:${props?.to}) />`;
    }
    if (props?.name) {
      return `<${cname}#${this._renderId} name=".${props?.name}" />`;
    }
    if (props?.portHints) {
      return `<${cname}#${this._renderId}(${props.portHints.map((ph) => `.${ph}`).join(", ")}) />`;
    }
    return `<${cname}#${this._renderId} />`;
  }
  get [Symbol.toStringTag]() {
    return this.getString();
  }
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return this.getString();
  }
};

// lib/components/primitive-components/ErrorPlaceholder.ts
import { z as z2 } from "zod";
var ErrorPlaceholderComponent = class extends PrimitiveComponent2 {
  constructor(props, error) {
    super(props);
    this._parsedProps = {
      ...props,
      error,
      type: props.type || "unknown",
      component_name: props.name,
      error_type: "source_failed_to_create_component_error",
      message: error instanceof Error ? error.message : String(error),
      pcbX: props.pcbX,
      pcbY: props.pcbY,
      schX: props.schX,
      schY: props.schY
    };
  }
  get config() {
    return {
      componentName: "ErrorPlaceholder",
      zodProps: z2.object({}).passthrough()
    };
  }
  doInitialSourceRender() {
    if (this.root?.db) {
      const pcbPosition = this._getGlobalPcbPositionBeforeLayout();
      const schematicPosition = this._getGlobalSchematicPositionBeforeLayout();
      this.root.db.source_failed_to_create_component_error.insert({
        component_name: this._parsedProps.component_name,
        error_type: "source_failed_to_create_component_error",
        message: this._parsedProps.error?.formattedError?._errors?.join("; ") || this._parsedProps.message,
        pcb_center: pcbPosition,
        schematic_center: schematicPosition
      });
    }
  }
};
function createErrorPlaceholderComponent(props, error) {
  return new ErrorPlaceholderComponent(props, error);
}

// lib/fiber/create-instance-from-react-element.ts
function prepare(object, state) {
  const instance = object;
  instance.__tsci = {
    ...state
  };
  return object;
}
var hostConfig = {
  supportsMutation: true,
  createInstance(type, props) {
    const target = catalogue[type];
    if (!target) {
      if (Object.keys(catalogue).length === 0) {
        throw new Error(
          "No components registered in catalogue, did you forget to import lib/register-catalogue in your test file?"
        );
      }
      throw new Error(
        `Unsupported component type "${type}". No element with this name is registered in the @tscircuit/core catalogue. Check for typos or see https://docs.tscircuit.com/category/built-in-elements for a list of valid components. To add your own component, see docs/CREATING_NEW_COMPONENTS.md`
      );
    }
    try {
      const instance = prepare(new target(props), {});
      return instance;
    } catch (error) {
      return createErrorPlaceholderComponent(props, error);
    }
  },
  createTextInstance(text) {
    return { __text: text };
  },
  appendInitialChild(parentInstance, child) {
    parentInstance.add(child);
  },
  appendChild(parentInstance, child) {
    parentInstance.add(child);
  },
  appendChildToContainer(container, child) {
    container.add(child);
  },
  finalizeInitialChildren() {
    return false;
  },
  prepareUpdate() {
    return null;
  },
  shouldSetTextContent() {
    return false;
  },
  getRootHostContext() {
    return {};
  },
  getChildHostContext() {
    return {};
  },
  prepareForCommit() {
    return null;
  },
  resetAfterCommit() {
  },
  commitMount() {
  },
  commitUpdate() {
  },
  removeChild() {
  },
  clearContainer() {
  },
  supportsPersistence: false,
  getPublicInstance(instance) {
    return instance;
  },
  preparePortalMount(containerInfo) {
    throw new Error("Function not implemented.");
  },
  scheduleTimeout(fn, delay) {
    throw new Error("Function not implemented.");
  },
  cancelTimeout(id) {
    throw new Error("Function not implemented.");
  },
  noTimeout: void 0,
  isPrimaryRenderer: false,
  getInstanceFromNode(node) {
    throw new Error("Function not implemented.");
  },
  beforeActiveInstanceBlur() {
    throw new Error("Function not implemented.");
  },
  afterActiveInstanceBlur() {
    throw new Error("Function not implemented.");
  },
  prepareScopeUpdate: (scopeInstance, instance) => {
    throw new Error("Function not implemented.");
  },
  getInstanceFromScope: (scopeInstance) => {
    throw new Error("Function not implemented.");
  },
  detachDeletedInstance: (node) => {
    throw new Error("Function not implemented.");
  },
  // https://github.com/pmndrs/react-three-fiber/pull/2360#discussion_r916356874
  getCurrentEventPriority: () => DefaultEventPriority,
  // @ts-expect-error
  // https://github.com/diegomura/react-pdf/blob/fabecc56727dfb6d590a3fa1e11f50250ecbbea1/packages/reconciler/src/reconciler-31.js#L57
  getCurrentUpdatePriority: () => DefaultEventPriority,
  resolveUpdatePriority: () => DefaultEventPriority,
  setCurrentUpdatePriority: () => {
  },
  maySuspendCommit: () => false,
  supportsHydration: false
};
var reconciler;
if (React.version.startsWith("19.")) {
  reconciler = ReactReconciler(hostConfig);
} else {
  reconciler = ReactReconciler18(hostConfig);
}
var createInstanceFromReactElement = (reactElm) => {
  const rootContainer = {
    children: [],
    props: {
      name: "$root"
    },
    add(instance) {
      instance.parent = this;
      this.children.push(instance);
    },
    computePcbGlobalTransform() {
      return identity2();
    }
  };
  const containerErrors = [];
  const container = reconciler.createContainer(
    // TODO Replace with store like react-three-fiber
    // https://github.com/pmndrs/react-three-fiber/blob/a457290856f57741bf8beef4f6ff9dbf4879c0a5/packages/fiber/src/core/index.tsx#L172
    // https://github.com/pmndrs/react-three-fiber/blob/master/packages/fiber/src/core/store.ts#L168
    rootContainer,
    0,
    null,
    false,
    null,
    "tsci",
    (error) => {
      console.log("Error in createContainer");
      console.error(error);
      containerErrors.push(error);
    },
    null
  );
  if (React.version.startsWith("19.")) {
    reconciler.updateContainerSync(reactElm, container, null, () => {
    });
    reconciler.flushSyncWork();
  } else {
    reconciler.updateContainer(reactElm, container, null, () => {
    });
  }
  if (containerErrors.length > 0) {
    throw containerErrors[0];
  }
  const rootInstance = reconciler.getPublicRootInstance(
    container
  );
  if (rootInstance) return rootInstance;
  return rootContainer.children[0];
};

// lib/soup/underscorifyPinStyles.ts
import "circuit-json";
import "zod";

// lib/utils/schematic/parsePinNumberFromLabelsOrThrow.ts
var parsePinNumberFromLabelsOrThrow = (pinNumberOrLabel, pinLabels) => {
  if (typeof pinNumberOrLabel === "number") {
    return pinNumberOrLabel;
  }
  if (pinNumberOrLabel.startsWith("pin")) {
    const pinNumber = Number(pinNumberOrLabel.slice(3));
    return pinNumber;
  }
  if (!pinLabels) {
    throw new Error(
      `No pin labels provided and pin number or label is not a number: "${pinNumberOrLabel}"`
    );
  }
  for (const pinNumberKey in pinLabels) {
    const aliases = Array.isArray(pinLabels[pinNumberKey]) ? pinLabels[pinNumberKey] : [pinLabels[pinNumberKey]];
    if (aliases.includes(pinNumberOrLabel)) {
      return Number(pinNumberKey.replace("pin", ""));
    }
  }
  throw new Error(
    `No pin labels provided and pin number or label is not a number: "${pinNumberOrLabel}"`
  );
};

// lib/soup/underscorifyPinStyles.ts
var underscorifyPinStyles = (pinStyles, pinLabels) => {
  if (!pinStyles) return void 0;
  const underscorePinStyles = {};
  const mergedStyles = {};
  for (const [pinNameOrLabel, pinStyle] of Object.entries(pinStyles)) {
    const pinNumber = parsePinNumberFromLabelsOrThrow(pinNameOrLabel, pinLabels);
    mergedStyles[pinNumber] = {
      ...mergedStyles[pinNumber],
      ...pinStyle
    };
  }
  for (const [pinNumber, pinStyle] of Object.entries(mergedStyles)) {
    const pinKey = `pin${pinNumber}`;
    underscorePinStyles[pinKey] = {
      bottom_margin: pinStyle.bottomMargin,
      left_margin: pinStyle.leftMargin,
      right_margin: pinStyle.rightMargin,
      top_margin: pinStyle.topMargin
    };
  }
  return underscorePinStyles;
};

// lib/soup/underscorifyPortArrangement.ts
var underscorifyPortArrangement = (portArrangement) => {
  if (!portArrangement) return void 0;
  if ("leftSide" in portArrangement || "rightSide" in portArrangement || "topSide" in portArrangement || "bottomSide" in portArrangement) {
    return {
      left_side: portArrangement.leftSide,
      right_side: portArrangement.rightSide,
      top_side: portArrangement.topSide,
      bottom_side: portArrangement.bottomSide
    };
  }
  if ("leftPinCount" in portArrangement || "rightPinCount" in portArrangement || "topPinCount" in portArrangement || "bottomPinCount" in portArrangement) {
    return {
      left_size: portArrangement.leftPinCount,
      right_size: portArrangement.rightPinCount,
      top_size: portArrangement.topPinCount,
      bottom_size: portArrangement.bottomPinCount
    };
  }
  if ("leftSize" in portArrangement || "rightSize" in portArrangement || "topSize" in portArrangement || "bottomSize" in portArrangement) {
    return {
      left_size: portArrangement.leftSize,
      right_size: portArrangement.rightSize,
      top_size: portArrangement.topSize,
      bottom_size: portArrangement.bottomSize
    };
  }
  return void 0;
};

// lib/components/primitive-components/Net.ts
import { z as z4 } from "zod";

// lib/utils/pairs.ts
function pairs(arr) {
  const result = [];
  for (let i = 0; i < arr.length - 1; i++) {
    result.push([arr[i], arr[i + 1]]);
  }
  return result;
}

// lib/components/primitive-components/Net.ts
import { autoroute } from "@tscircuit/infgrid-ijump-astar";
var netProps = z4.object({
  name: z4.string().refine(
    (val) => !/[+-]/.test(val),
    'Net names cannot contain "+" or "-", try using underscores instead, e.g. VCC_P'
  )
});
var Net = class extends PrimitiveComponent2 {
  source_net_id;
  get config() {
    return {
      componentName: "Net",
      zodProps: netProps
    };
  }
  getPortSelector() {
    return `net.${this.props.name}`;
  }
  doInitialSourceRender() {
    const { db } = this.root;
    const { _parsedProps: props } = this;
    const net = db.source_net.insert({
      name: props.name,
      member_source_group_ids: []
    });
    this.source_net_id = net.source_net_id;
  }
  doInitialSourceParentAttachment() {
    const subcircuit = this.getSubcircuit();
    if (!subcircuit) return;
    const { db } = this.root;
    db.source_net.update(this.source_net_id, {
      subcircuit_id: subcircuit.subcircuit_id
    });
  }
  /**
   * Get all ports connected to this net.
   *
   * TODO currently we're not checking for indirect connections (traces that are
   * connected to other traces that are in turn connected to the net)
   */
  getAllConnectedPorts() {
    const allPorts = this.getSubcircuit().selectAll("port");
    const connectedPorts = [];
    for (const port of allPorts) {
      const traces = port._getDirectlyConnectedTraces();
      for (const trace of traces) {
        if (trace._isExplicitlyConnectedToNet(this)) {
          connectedPorts.push(port);
          break;
        }
      }
    }
    return connectedPorts;
  }
  /**
   * Get all traces that are directly connected to this net, i.e. they list
   * this net in their path, from, or to props
   */
  _getAllDirectlyConnectedTraces() {
    const allTraces = this.getSubcircuit().selectAll("trace");
    const connectedTraces = [];
    for (const trace of allTraces) {
      if (trace._isExplicitlyConnectedToNet(this)) {
        connectedTraces.push(trace);
      }
    }
    return connectedTraces;
  }
  /**
   * Add PCB Traces to connect net islands together. A net island is a set of
   * ports that are connected to each other. If a there are multiple net islands
   * that means that the net is not fully connected and we need to add traces
   * such that the nets are fully connected
   *
   * Sometimes this phase doesn't find any net islands if the autorouter did
   * a good job and connected the islands. In some sense this is a "backup"
   * routing phase for autorouters that don't care about connecting nets.
   *
   * This should only run if the autorouter is sequential-trace
   */
  doInitialPcbRouteNetIslands() {
    if (this.root?.pcbDisabled) return;
    if (this.getSubcircuit()._parsedProps.routingDisabled) return;
    if (this.getSubcircuit()._getAutorouterConfig().groupMode !== "sequential-trace")
      return;
    const { db } = this.root;
    const { _parsedProps: props } = this;
    const traces = this._getAllDirectlyConnectedTraces().filter(
      (trace) => (trace._portsRoutedOnPcb?.length ?? 0) > 0
    );
    const islands = [];
    for (const trace of traces) {
      const tracePorts = trace._portsRoutedOnPcb;
      const traceIsland = islands.find(
        (island) => tracePorts.some((port) => island.ports.includes(port))
      );
      if (!traceIsland) {
        islands.push({ ports: [...tracePorts], traces: [trace] });
        continue;
      }
      traceIsland.traces.push(trace);
      traceIsland.ports.push(...tracePorts);
    }
    if (islands.length === 0) {
      return;
    }
    const islandPairs = pairs(islands);
    for (const [A, B] of islandPairs) {
      const Apositions = A.ports.map(
        (port) => port._getGlobalPcbPositionBeforeLayout()
      );
      const Bpositions = B.ports.map(
        (port) => port._getGlobalPcbPositionBeforeLayout()
      );
      let closestDist = Infinity;
      let closestPair = [-1, -1];
      for (let i = 0; i < Apositions.length; i++) {
        const Apos = Apositions[i];
        for (let j = 0; j < Bpositions.length; j++) {
          const Bpos = Bpositions[j];
          const dist = Math.sqrt(
            (Apos.x - Bpos.x) ** 2 + (Apos.y - Bpos.y) ** 2
          );
          if (dist < closestDist) {
            closestDist = dist;
            closestPair = [i, j];
          }
        }
      }
      const Aport = A.ports[closestPair[0]];
      const Bport = B.ports[closestPair[1]];
      const pcbElements = db.toArray().filter(
        (elm) => elm.type === "pcb_smtpad" || elm.type === "pcb_trace" || elm.type === "pcb_plated_hole" || elm.type === "pcb_hole" || elm.type === "source_port" || elm.type === "pcb_port"
      );
      const { solution } = autoroute(
        pcbElements.concat([
          {
            type: "source_trace",
            source_trace_id: "__net_trace_tmp",
            connected_source_port_ids: [
              Aport.source_port_id,
              Bport.source_port_id
            ]
          }
        ])
        // Remove as any when autorouting-dataset has been updated
      );
      const trace = solution[0];
      if (!trace) {
        this.renderError({
          pcb_trace_error_id: "",
          pcb_trace_id: "__net_trace_tmp",
          pcb_component_ids: [
            Aport.pcb_component_id,
            Bport.pcb_component_id
          ].filter(Boolean),
          pcb_port_ids: [Aport.pcb_port_id, Bport.pcb_port_id].filter(
            Boolean
          ),
          type: "pcb_trace_error",
          error_type: "pcb_trace_error",
          message: `Failed to route net islands for "${this.getString()}"`,
          source_trace_id: "__net_trace_tmp"
        });
        return;
      }
      db.pcb_trace.insert(trace);
    }
  }
  renderError(message) {
    if (typeof message === "string") {
      return super.renderError(message);
    }
    this.root?.db.pcb_trace_error.insert(message);
  }
};

// lib/utils/components/createNetsFromProps.ts
var createNetsFromProps = (component, props) => {
  for (const prop of props) {
    if (typeof prop === "string" && prop.startsWith("net.")) {
      if (/net\.[^\s>]*\./.test(prop)) {
        throw new Error(
          'Net names cannot contain a period, try using "sel.net..." to autocomplete with conventional net names, e.g. V3_3'
        );
      }
      if (/net\.[^\s>]*[+-]/.test(prop)) {
        throw new Error(
          'Net names cannot contain "+" or "-", try using underscores instead, e.g. VCC_P'
        );
      }
      if (/net\.[0-9]/.test(prop)) {
        const netName = prop.split("net.")[1];
        throw new Error(
          `Net name "${netName}" cannot start with a number, try using a prefix like "VBUS1"`
        );
      }
      const subcircuit = component.getSubcircuit();
      if (!subcircuit.selectOne(prop)) {
        const net = new Net({
          name: prop.split("net.")[1]
        });
        subcircuit.add(net);
      }
    }
  }
};

// lib/components/primitive-components/SmtPad.ts
import { smtPadProps } from "@tscircuit/props";
import { decomposeTSR } from "transformation-matrix";
var SmtPad = class extends PrimitiveComponent2 {
  pcb_smtpad_id = null;
  matchedPort = null;
  isPcbPrimitive = true;
  get config() {
    return {
      componentName: "SmtPad",
      zodProps: smtPadProps
    };
  }
  getPcbSize() {
    const { _parsedProps: props } = this;
    if (props.shape === "circle") {
      return { width: props.radius * 2, height: props.radius * 2 };
    }
    if (props.shape === "rect") {
      return { width: props.width, height: props.height };
    }
    if (props.shape === "polygon") {
      const points = props.points;
      const xs = points.map((p) => p.x);
      const ys = points.map((p) => p.y);
      const minX = Math.min(...xs);
      const maxX = Math.max(...xs);
      const minY = Math.min(...ys);
      const maxY = Math.max(...ys);
      return { width: maxX - minX, height: maxY - minY };
    }
    throw new Error(
      `getPcbSize for shape "${props.shape}" not implemented for ${this.componentName}`
    );
  }
  doInitialPortMatching() {
    const parentPorts = this.getPrimitiveContainer()?.selectAll(
      "port"
    );
    if (!this.props.portHints) {
      return;
    }
    for (const port of parentPorts) {
      if (port.isMatchingAnyOf(this.props.portHints)) {
        this.matchedPort = port;
        port.registerMatch(this);
        return;
      }
    }
  }
  doInitialPcbPrimitiveRender() {
    if (this.root?.pcbDisabled) return;
    const { db } = this.root;
    const { _parsedProps: props } = this;
    if (!props.portHints) return;
    const container = this.getPrimitiveContainer();
    const subcircuit = this.getSubcircuit();
    const position = this._getGlobalPcbPositionBeforeLayout();
    const containerCenter = container?._getGlobalPcbPositionBeforeLayout();
    const decomposedMat = decomposeTSR(
      this._computePcbGlobalTransformBeforeLayout()
    );
    const isRotated90 = Math.abs(decomposedMat.rotation.angle * (180 / Math.PI) - 90) % 180 < 0.01;
    const { maybeFlipLayer } = this._getPcbPrimitiveFlippedHelpers();
    const parentRotation = container?._parsedProps.pcbRotation ?? 0;
    let pcb_smtpad = null;
    const pcb_component_id = this.parent?.pcb_component_id ?? this.getPrimitiveContainer()?.pcb_component_id;
    if (props.shape === "circle") {
      pcb_smtpad = db.pcb_smtpad.insert({
        pcb_component_id,
        pcb_port_id: this.matchedPort?.pcb_port_id,
        // port likely isn't matched
        layer: maybeFlipLayer(props.layer ?? "top"),
        shape: "circle",
        radius: props.radius,
        port_hints: props.portHints.map((ph) => ph.toString()),
        x: position.x,
        y: position.y,
        subcircuit_id: subcircuit?.subcircuit_id ?? void 0
      });
      db.pcb_solder_paste.insert({
        layer: pcb_smtpad.layer,
        shape: "circle",
        radius: pcb_smtpad.radius * 0.7,
        x: pcb_smtpad.x,
        y: pcb_smtpad.y,
        pcb_component_id: pcb_smtpad.pcb_component_id,
        pcb_smtpad_id: pcb_smtpad.pcb_smtpad_id,
        subcircuit_id: subcircuit?.subcircuit_id ?? void 0,
        pcb_group_id: this.getGroup()?.pcb_group_id ?? void 0
      });
    } else if (props.shape === "rect") {
      pcb_smtpad = parentRotation === 0 || isRotated90 ? db.pcb_smtpad.insert({
        pcb_component_id,
        pcb_port_id: this.matchedPort?.pcb_port_id,
        // port likely isn't matched
        layer: maybeFlipLayer(props.layer ?? "top"),
        shape: "rect",
        width: isRotated90 ? props.height : props.width,
        height: isRotated90 ? props.width : props.height,
        port_hints: props.portHints.map((ph) => ph.toString()),
        x: position.x,
        y: position.y,
        subcircuit_id: subcircuit?.subcircuit_id ?? void 0,
        pcb_group_id: this.getGroup()?.pcb_group_id ?? void 0
      }) : db.pcb_smtpad.insert({
        pcb_component_id,
        layer: maybeFlipLayer(props.layer ?? "top"),
        shape: "rotated_rect",
        width: props.width,
        height: props.height,
        x: position.x,
        y: position.y,
        ccw_rotation: parentRotation,
        port_hints: props.portHints.map((ph) => ph.toString()),
        subcircuit_id: subcircuit?.subcircuit_id ?? void 0,
        pcb_group_id: this.getGroup()?.pcb_group_id ?? void 0
      });
      if (pcb_smtpad.shape === "rect")
        db.pcb_solder_paste.insert({
          layer: maybeFlipLayer(props.layer ?? "top"),
          shape: "rect",
          width: pcb_smtpad.width * 0.7,
          height: pcb_smtpad.height * 0.7,
          x: pcb_smtpad.x,
          y: pcb_smtpad.y,
          pcb_component_id: pcb_smtpad.pcb_component_id,
          pcb_smtpad_id: pcb_smtpad.pcb_smtpad_id,
          subcircuit_id: subcircuit?.subcircuit_id ?? void 0,
          pcb_group_id: this.getGroup()?.pcb_group_id ?? void 0
        });
      if (pcb_smtpad.shape === "rotated_rect")
        db.pcb_solder_paste.insert({
          layer: maybeFlipLayer(props.layer ?? "top"),
          shape: "rotated_rect",
          width: pcb_smtpad.width * 0.7,
          height: pcb_smtpad.height * 0.7,
          x: pcb_smtpad.x,
          y: pcb_smtpad.y,
          ccw_rotation: parentRotation,
          pcb_component_id: pcb_smtpad.pcb_component_id,
          pcb_smtpad_id: pcb_smtpad.pcb_smtpad_id,
          subcircuit_id: subcircuit?.subcircuit_id ?? void 0,
          pcb_group_id: this.getGroup()?.pcb_group_id ?? void 0
        });
    } else if (props.shape === "polygon") {
      pcb_smtpad = db.pcb_smtpad.insert({
        pcb_component_id,
        pcb_port_id: this.matchedPort?.pcb_port_id,
        // port likely isn't matched
        layer: maybeFlipLayer(props.layer ?? "top"),
        shape: "polygon",
        points: props.points.map((p) => ({
          x: p.x + position.x,
          y: p.y + position.y
        })),
        port_hints: props.portHints.map((ph) => ph.toString()),
        subcircuit_id: subcircuit?.subcircuit_id ?? void 0,
        pcb_group_id: this.getGroup()?.pcb_group_id ?? void 0
      });
    }
    if (pcb_smtpad) {
      this.pcb_smtpad_id = pcb_smtpad.pcb_smtpad_id;
    }
  }
  doInitialPcbPortAttachment() {
    if (this.root?.pcbDisabled) return;
    const { db } = this.root;
    db.pcb_smtpad.update(this.pcb_smtpad_id, {
      pcb_port_id: this.matchedPort?.pcb_port_id
    });
  }
  _getPcbCircuitJsonBounds() {
    const { db } = this.root;
    const smtpad = db.pcb_smtpad.get(this.pcb_smtpad_id);
    if (smtpad.shape === "rect") {
      return {
        center: { x: smtpad.x, y: smtpad.y },
        bounds: {
          left: smtpad.x - smtpad.width / 2,
          top: smtpad.y + smtpad.height / 2,
          right: smtpad.x + smtpad.width / 2,
          bottom: smtpad.y - smtpad.height / 2
        },
        width: smtpad.width,
        height: smtpad.height
      };
    }
    if (smtpad.shape === "rotated_rect") {
      const angleRad = smtpad.ccw_rotation * Math.PI / 180;
      const cosAngle = Math.cos(angleRad);
      const sinAngle = Math.sin(angleRad);
      const w2 = smtpad.width / 2;
      const h2 = smtpad.height / 2;
      const xExtent = Math.abs(w2 * cosAngle) + Math.abs(h2 * sinAngle);
      const yExtent = Math.abs(w2 * sinAngle) + Math.abs(h2 * cosAngle);
      return {
        center: { x: smtpad.x, y: smtpad.y },
        bounds: {
          left: smtpad.x - xExtent,
          right: smtpad.x + xExtent,
          top: smtpad.y - yExtent,
          bottom: smtpad.y + yExtent
        },
        width: xExtent * 2,
        height: yExtent * 2
      };
    }
    if (smtpad.shape === "circle") {
      return {
        center: { x: smtpad.x, y: smtpad.y },
        bounds: {
          left: smtpad.x - smtpad.radius,
          top: smtpad.y - smtpad.radius,
          right: smtpad.x + smtpad.radius,
          bottom: smtpad.y + smtpad.radius
        },
        width: smtpad.radius * 2,
        height: smtpad.radius * 2
      };
    }
    if (smtpad.shape === "polygon") {
      const points = smtpad.points;
      const xs = points.map((p) => p.x);
      const ys = points.map((p) => p.y);
      const minX = Math.min(...xs);
      const maxX = Math.max(...xs);
      const minY = Math.min(...ys);
      const maxY = Math.max(...ys);
      return {
        center: { x: (minX + maxX) / 2, y: (minY + maxY) / 2 },
        bounds: {
          left: minX,
          top: maxY,
          right: maxX,
          bottom: minY
        },
        width: maxX - minX,
        height: maxY - minY
      };
    }
    throw new Error(
      `circuitJson bounds calculation not implemented for shape "${smtpad.shape}"`
    );
  }
  _setPositionFromLayout(newCenter) {
    const { db } = this.root;
    db.pcb_smtpad.update(this.pcb_smtpad_id, {
      x: newCenter.x,
      y: newCenter.y
    });
    const solderPaste = db.pcb_solder_paste.list().find((elm) => elm.pcb_smtpad_id === this.pcb_smtpad_id);
    db.pcb_solder_paste.update(solderPaste?.pcb_solder_paste_id, {
      x: newCenter.x,
      y: newCenter.y
    });
    this.matchedPort?._setPositionFromLayout(newCenter);
  }
};

// lib/components/primitive-components/SilkscreenPath.ts
import { silkscreenPathProps } from "@tscircuit/props";
import { applyToPoint as applyToPoint2 } from "transformation-matrix";
var SilkscreenPath = class extends PrimitiveComponent2 {
  pcb_silkscreen_path_id = null;
  isPcbPrimitive = true;
  get config() {
    return {
      componentName: "SilkscreenPath",
      zodProps: silkscreenPathProps
    };
  }
  doInitialPcbPrimitiveRender() {
    if (this.root?.pcbDisabled) return;
    const { db } = this.root;
    const { _parsedProps: props } = this;
    const { maybeFlipLayer } = this._getPcbPrimitiveFlippedHelpers();
    const layer = maybeFlipLayer(props.layer ?? "top");
    if (layer !== "top" && layer !== "bottom") {
      throw new Error(
        `Invalid layer "${layer}" for SilkscreenPath. Must be "top" or "bottom".`
      );
    }
    const transform = this._computePcbGlobalTransformBeforeLayout();
    const subcircuit = this.getSubcircuit();
    const pcb_silkscreen_path = db.pcb_silkscreen_path.insert({
      pcb_component_id: this.parent?.pcb_component_id,
      layer,
      route: props.route.map((p) => {
        const transformedPosition = applyToPoint2(transform, {
          x: p.x,
          y: p.y
        });
        return {
          ...p,
          x: transformedPosition.x,
          y: transformedPosition.y
        };
      }),
      stroke_width: props.strokeWidth ?? 0.1,
      subcircuit_id: subcircuit?.subcircuit_id ?? void 0,
      pcb_group_id: this.getGroup()?.pcb_group_id ?? void 0
    });
    this.pcb_silkscreen_path_id = pcb_silkscreen_path.pcb_silkscreen_path_id;
  }
  getPcbSize() {
    const { _parsedProps: props } = this;
    if (!props.route || props.route.length === 0) {
      return { width: 0, height: 0 };
    }
    let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
    for (const point of props.route) {
      minX = Math.min(minX, point.x);
      maxX = Math.max(maxX, point.x);
      minY = Math.min(minY, point.y);
      maxY = Math.max(maxY, point.y);
    }
    return {
      width: maxX - minX,
      height: maxY - minY
    };
  }
};

// lib/components/primitive-components/PcbTrace.ts
import { z as z5 } from "zod";
import { pcb_trace_route_point } from "circuit-json";
import { applyToPoint as applyToPoint3 } from "transformation-matrix";
var pcbTraceProps = z5.object({
  route: z5.array(pcb_trace_route_point),
  // If this primitive PcbTrace needs to be associated with a source_trace_id
  // it can be added as a prop here. For footprints, it's often not needed.
  source_trace_id: z5.string().optional()
});
var PcbTrace = class extends PrimitiveComponent2 {
  pcb_trace_id = null;
  isPcbPrimitive = true;
  get config() {
    return {
      componentName: "PcbTrace",
      zodProps: pcbTraceProps
    };
  }
  doInitialPcbPrimitiveRender() {
    if (this.root?.pcbDisabled) return;
    const { db } = this.root;
    const { _parsedProps: props } = this;
    const container = this.getPrimitiveContainer();
    const subcircuit = this.getSubcircuit();
    const { maybeFlipLayer } = this._getPcbPrimitiveFlippedHelpers();
    const parentTransform = this._computePcbGlobalTransformBeforeLayout();
    const transformedRoute = props.route.map((point) => {
      const { x, y, ...restOfPoint } = point;
      const transformedPoint = applyToPoint3(parentTransform, { x, y });
      if (point.route_type === "wire" && point.layer) {
        return {
          ...transformedPoint,
          ...restOfPoint,
          layer: maybeFlipLayer(point.layer)
        };
      }
      return { ...transformedPoint, ...restOfPoint };
    });
    const pcb_trace = db.pcb_trace.insert({
      pcb_component_id: container.pcb_component_id,
      source_trace_id: props.source_trace_id,
      route: transformedRoute,
      subcircuit_id: subcircuit?.subcircuit_id ?? void 0,
      pcb_group_id: this.getGroup()?.pcb_group_id ?? void 0
    });
    this.pcb_trace_id = pcb_trace.pcb_trace_id;
  }
  getPcbSize() {
    const { _parsedProps: props } = this;
    if (!props.route || props.route.length === 0) {
      return { width: 0, height: 0 };
    }
    let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
    for (const point of props.route) {
      minX = Math.min(minX, point.x);
      maxX = Math.max(maxX, point.x);
      minY = Math.min(minY, point.y);
      maxY = Math.max(maxY, point.y);
      if (point.route_type === "wire") {
        minX = Math.min(minX, point.x - point.width / 2);
        maxX = Math.max(maxX, point.x + point.width / 2);
        minY = Math.min(minY, point.y - point.width / 2);
        maxY = Math.max(maxY, point.y + point.width / 2);
      }
    }
    if (minX === Infinity || maxX === -Infinity || minY === Infinity || maxY === -Infinity) {
      return { width: 0, height: 0 };
    }
    return {
      width: maxX - minX,
      height: maxY - minY
    };
  }
};

// lib/components/primitive-components/PlatedHole.ts
import { platedHoleProps } from "@tscircuit/props";
var PlatedHole = class extends PrimitiveComponent2 {
  pcb_plated_hole_id = null;
  matchedPort = null;
  isPcbPrimitive = true;
  get config() {
    return {
      componentName: "PlatedHole",
      zodProps: platedHoleProps
    };
  }
  getAvailablePcbLayers() {
    return ["top", "inner1", "inner2", "bottom"];
  }
  getPcbSize() {
    const { _parsedProps: props } = this;
    if (props.shape === "circle") {
      return { width: props.outerDiameter, height: props.outerDiameter };
    }
    if (props.shape === "oval" || props.shape === "pill") {
      return { width: props.outerWidth, height: props.outerHeight };
    }
    if (props.shape === "circular_hole_with_rect_pad") {
      return { width: props.rectPadWidth, height: props.rectPadHeight };
    }
    if (props.shape === "pill_hole_with_rect_pad") {
      return { width: props.rectPadWidth, height: props.rectPadHeight };
    }
    throw new Error(
      `getPcbSize for shape "${props.shape}" not implemented for ${this.componentName}`
    );
  }
  _getPcbCircuitJsonBounds() {
    const { db } = this.root;
    const platedHole = db.pcb_plated_hole.get(this.pcb_plated_hole_id);
    const size = this.getPcbSize();
    return {
      center: { x: platedHole.x, y: platedHole.y },
      bounds: {
        left: platedHole.x - size.width / 2,
        top: platedHole.y + size.height / 2,
        right: platedHole.x + size.width / 2,
        bottom: platedHole.y - size.height / 2
      },
      width: size.width,
      height: size.height
    };
  }
  _setPositionFromLayout(newCenter) {
    const { db } = this.root;
    db.pcb_plated_hole.update(this.pcb_plated_hole_id, {
      x: newCenter.x,
      y: newCenter.y
    });
    this.matchedPort?._setPositionFromLayout(newCenter);
  }
  doInitialPortMatching() {
    const parentPorts = this.getPrimitiveContainer()?.selectAll(
      "port"
    );
    if (!this.props.portHints) {
      return;
    }
    for (const port of parentPorts) {
      if (port.isMatchingAnyOf(this.props.portHints)) {
        this.matchedPort = port;
        port.registerMatch(this);
        return;
      }
    }
  }
  doInitialPcbPrimitiveRender() {
    if (this.root?.pcbDisabled) return;
    const { db } = this.root;
    const { _parsedProps: props } = this;
    const position = this._getGlobalPcbPositionBeforeLayout();
    const pcb_component_id = this.parent?.pcb_component_id ?? this.getPrimitiveContainer()?.pcb_component_id;
    const subcircuit = this.getSubcircuit();
    if (props.shape === "circle") {
      const pcb_plated_hole = db.pcb_plated_hole.insert({
        pcb_component_id,
        pcb_port_id: this.matchedPort?.pcb_port_id,
        // @ts-ignore - some issue with circuit-json union type
        outer_diameter: props.outerDiameter,
        hole_diameter: props.holeDiameter,
        shape: "circle",
        port_hints: this.getNameAndAliases(),
        x: position.x,
        y: position.y,
        layers: ["top", "bottom"],
        subcircuit_id: subcircuit?.subcircuit_id ?? void 0,
        pcb_group_id: this.getGroup()?.pcb_group_id ?? void 0
      });
      this.pcb_plated_hole_id = pcb_plated_hole.pcb_plated_hole_id;
      db.pcb_solder_paste.insert({
        layer: "top",
        shape: "circle",
        // @ts-ignore: no idea why this is triggering
        radius: props.outerDiameter / 2,
        x: position.x,
        y: position.y,
        subcircuit_id: subcircuit?.subcircuit_id ?? void 0,
        pcb_group_id: this.getGroup()?.pcb_group_id ?? void 0
      });
      db.pcb_solder_paste.insert({
        layer: "bottom",
        shape: "circle",
        // @ts-ignore: no idea why this is triggering
        radius: props.outerDiameter / 2,
        x: position.x,
        y: position.y,
        subcircuit_id: subcircuit?.subcircuit_id ?? void 0,
        pcb_group_id: this.getGroup()?.pcb_group_id ?? void 0
      });
    } else if (props.shape === "pill" || props.shape === "oval") {
      const pcb_plated_hole = db.pcb_plated_hole.insert({
        pcb_component_id,
        pcb_port_id: this.matchedPort?.pcb_port_id,
        outer_width: props.outerWidth,
        outer_height: props.outerHeight,
        hole_width: props.holeWidth,
        hole_height: props.holeHeight,
        shape: props.shape,
        port_hints: this.getNameAndAliases(),
        x: position.x,
        y: position.y,
        layers: ["top", "bottom"],
        subcircuit_id: subcircuit?.subcircuit_id ?? void 0,
        pcb_group_id: this.getGroup()?.pcb_group_id ?? void 0
        // NOTE: currently PcbPlatedHoleOval erroneously includes both the shape "pill" and "oval"
      });
      this.pcb_plated_hole_id = pcb_plated_hole.pcb_plated_hole_id;
      db.pcb_solder_paste.insert({
        layer: "top",
        shape: props.shape,
        // @ts-ignore: no idea why this is triggering
        width: props.outerWidth,
        height: props.outerHeight,
        x: position.x,
        y: position.y,
        subcircuit_id: subcircuit?.subcircuit_id ?? void 0,
        pcb_group_id: this.getGroup()?.pcb_group_id ?? void 0
      });
      db.pcb_solder_paste.insert({
        layer: "bottom",
        shape: props.shape,
        // @ts-ignore: no idea why this is triggering
        width: props.outerWidth,
        height: props.outerHeight,
        x: position.x,
        y: position.y,
        subcircuit_id: subcircuit?.subcircuit_id ?? void 0,
        pcb_group_id: this.getGroup()?.pcb_group_id ?? void 0
      });
    } else if (props.shape === "circular_hole_with_rect_pad") {
      const pcb_plated_hole = db.pcb_plated_hole.insert({
        pcb_component_id,
        pcb_port_id: this.matchedPort?.pcb_port_id,
        hole_diameter: props.holeDiameter,
        rect_pad_width: props.rectPadWidth,
        rect_pad_height: props.rectPadHeight,
        shape: "circular_hole_with_rect_pad",
        port_hints: this.getNameAndAliases(),
        x: position.x,
        y: position.y,
        layers: ["top", "bottom"],
        subcircuit_id: subcircuit?.subcircuit_id ?? void 0,
        pcb_group_id: this.getGroup()?.pcb_group_id ?? void 0
      });
      this.pcb_plated_hole_id = pcb_plated_hole.pcb_plated_hole_id;
    } else if (props.shape === "pill_hole_with_rect_pad") {
      const pcb_plated_hole = db.pcb_plated_hole.insert({
        pcb_component_id,
        pcb_port_id: this.matchedPort?.pcb_port_id,
        hole_width: props.holeWidth,
        hole_height: props.holeHeight,
        rect_pad_width: props.rectPadWidth,
        rect_pad_height: props.rectPadHeight,
        shape: "pill_hole_with_rect_pad",
        port_hints: this.getNameAndAliases(),
        x: position.x,
        y: position.y,
        layers: ["top", "bottom"],
        subcircuit_id: subcircuit?.subcircuit_id ?? void 0,
        pcb_group_id: this.getGroup()?.pcb_group_id ?? void 0
      });
      this.pcb_plated_hole_id = pcb_plated_hole.pcb_plated_hole_id;
    }
  }
  doInitialPcbPortAttachment() {
    if (this.root?.pcbDisabled) return;
    const { db } = this.root;
    db.pcb_plated_hole.update(this.pcb_plated_hole_id, {
      pcb_port_id: this.matchedPort?.pcb_port_id
    });
  }
};

// lib/components/primitive-components/Keepout.ts
import { pcbKeepoutProps } from "@tscircuit/props";
import { decomposeTSR as decomposeTSR2 } from "transformation-matrix";
var Keepout = class extends PrimitiveComponent2 {
  pcb_keepout_id = null;
  isPcbPrimitive = true;
  get config() {
    return {
      componentName: "Keepout",
      zodProps: pcbKeepoutProps
    };
  }
  doInitialPcbPrimitiveRender() {
    if (this.root?.pcbDisabled) return;
    const subcircuit = this.getSubcircuit();
    const { db } = this.root;
    const { _parsedProps: props } = this;
    const position = this._getGlobalPcbPositionBeforeLayout();
    const decomposedMat = decomposeTSR2(
      this._computePcbGlobalTransformBeforeLayout()
    );
    const isRotated90 = Math.abs(decomposedMat.rotation.angle * (180 / Math.PI) - 90) % 180 < 0.01;
    let pcb_keepout = null;
    if (props.shape === "circle") {
      pcb_keepout = db.pcb_keepout.insert({
        layers: ["top"],
        shape: "circle",
        // @ts-ignore: no idea why this is triggering
        radius: props.radius,
        center: {
          x: position.x,
          y: position.y
        },
        subcircuit_id: subcircuit?.subcircuit_id ?? void 0,
        pcb_group_id: subcircuit?.getGroup()?.pcb_group_id ?? void 0
      });
    } else if (props.shape === "rect") {
      pcb_keepout = db.pcb_keepout.insert({
        layers: ["top"],
        shape: "rect",
        ...isRotated90 ? { width: props.height, height: props.width } : { width: props.width, height: props.height },
        // @ts-ignore: no idea why this is triggering
        center: {
          x: position.x,
          y: position.y
        },
        subcircuit_id: subcircuit?.subcircuit_id ?? void 0,
        pcb_group_id: subcircuit?.getGroup()?.pcb_group_id ?? void 0
      });
    }
    if (pcb_keepout) {
      this.pcb_keepout_id = pcb_keepout.pcb_keepout_id;
    }
  }
};

// lib/components/primitive-components/Hole.ts
import { holeProps } from "@tscircuit/props";
var Hole = class extends PrimitiveComponent2 {
  pcb_hole_id = null;
  isPcbPrimitive = true;
  get config() {
    return {
      componentName: "Hole",
      zodProps: holeProps
    };
  }
  getPcbSize() {
    const { _parsedProps: props } = this;
    return { width: props.diameter, height: props.diameter };
  }
  doInitialPcbPrimitiveRender() {
    if (this.root?.pcbDisabled) return;
    const { db } = this.root;
    const { _parsedProps: props } = this;
    const subcircuit = this.getSubcircuit();
    const position = this._getGlobalPcbPositionBeforeLayout();
    const inserted_hole = db.pcb_hole.insert({
      hole_shape: "circle",
      // @ts-ignore
      hole_diameter: props.diameter,
      x: position.x,
      y: position.y,
      subcircuit_id: subcircuit?.subcircuit_id ?? void 0,
      pcb_group_id: subcircuit?.getGroup()?.pcb_group_id ?? void 0
    });
    this.pcb_hole_id = inserted_hole.pcb_hole_id;
  }
  _getPcbCircuitJsonBounds() {
    const { db } = this.root;
    const hole = db.pcb_hole.get(this.pcb_hole_id);
    const size = this.getPcbSize();
    return {
      center: { x: hole.x, y: hole.y },
      bounds: {
        left: hole.x - size.width / 2,
        top: hole.y - size.height / 2,
        right: hole.x + size.width / 2,
        bottom: hole.y + size.height / 2
      },
      width: size.width,
      height: size.height
    };
  }
  _setPositionFromLayout(newCenter) {
    const { db } = this.root;
    db.pcb_hole.update(this.pcb_hole_id, {
      x: newCenter.x,
      y: newCenter.y
    });
  }
};

// lib/components/primitive-components/SilkscreenText.ts
import { silkscreenTextProps } from "@tscircuit/props";
var SilkscreenText = class extends PrimitiveComponent2 {
  isPcbPrimitive = true;
  get config() {
    return {
      componentName: "SilkscreenText",
      zodProps: silkscreenTextProps
    };
  }
  doInitialPcbPrimitiveRender() {
    if (this.root?.pcbDisabled) return;
    const { db } = this.root;
    const { _parsedProps: props } = this;
    const container = this.getPrimitiveContainer();
    const position = this._getGlobalPcbPositionBeforeLayout();
    const { maybeFlipLayer } = this._getPcbPrimitiveFlippedHelpers();
    const subcircuit = this.getSubcircuit();
    db.pcb_silkscreen_text.insert({
      anchor_alignment: props.anchorAlignment,
      anchor_position: {
        x: position.x,
        y: position.y
      },
      font: props.font ?? "tscircuit2024",
      font_size: props.fontSize ?? 1,
      layer: maybeFlipLayer(props.layer ?? "top"),
      text: props.text ?? "",
      ccw_rotation: props.pcbRotation,
      pcb_component_id: container.pcb_component_id,
      subcircuit_id: subcircuit?.subcircuit_id ?? void 0,
      pcb_group_id: this.getGroup()?.pcb_group_id ?? void 0
    });
  }
  getPcbSize() {
    const { _parsedProps: props } = this;
    const fontSize = props.fontSize ?? 1;
    const text = props.text ?? "";
    const textWidth = text.length * fontSize;
    const textHeight = fontSize;
    return { width: textWidth * fontSize, height: textHeight * fontSize };
  }
};

// lib/components/primitive-components/Cutout.ts
import { applyToPoint as applyToPoint4 } from "transformation-matrix";
import { cutoutProps } from "@tscircuit/props";
var Cutout = class extends PrimitiveComponent2 {
  pcb_cutout_id = null;
  isPcbPrimitive = true;
  get config() {
    return {
      componentName: "Cutout",
      zodProps: cutoutProps
    };
  }
  doInitialPcbPrimitiveRender() {
    if (this.root?.pcbDisabled) return;
    const { db } = this.root;
    const { _parsedProps: props } = this;
    const subcircuit = this.getSubcircuit();
    const pcb_group_id = this.getGroup()?.pcb_group_id ?? void 0;
    const globalPosition = this._getGlobalPcbPositionBeforeLayout();
    let inserted_pcb_cutout = void 0;
    if (props.shape === "rect") {
      const rectData = {
        shape: "rect",
        center: globalPosition,
        width: props.width,
        height: props.height,
        subcircuit_id: subcircuit?.subcircuit_id ?? void 0,
        pcb_group_id
      };
      inserted_pcb_cutout = db.pcb_cutout.insert(rectData);
    } else if (props.shape === "circle") {
      const circleData = {
        shape: "circle",
        center: globalPosition,
        radius: props.radius,
        subcircuit_id: subcircuit?.subcircuit_id ?? void 0,
        pcb_group_id
      };
      inserted_pcb_cutout = db.pcb_cutout.insert(circleData);
    } else if (props.shape === "polygon") {
      const transform = this._computePcbGlobalTransformBeforeLayout();
      const transformedPoints = props.points.map(
        (p) => applyToPoint4(transform, p)
      );
      const polygonData = {
        shape: "polygon",
        points: transformedPoints,
        subcircuit_id: subcircuit?.subcircuit_id ?? void 0,
        pcb_group_id
      };
      inserted_pcb_cutout = db.pcb_cutout.insert(polygonData);
    }
    if (inserted_pcb_cutout) {
      this.pcb_cutout_id = inserted_pcb_cutout.pcb_cutout_id;
    }
  }
  getPcbSize() {
    const { _parsedProps: props } = this;
    if (props.shape === "rect") {
      return { width: props.width, height: props.height };
    }
    if (props.shape === "circle") {
      return { width: props.radius * 2, height: props.radius * 2 };
    }
    if (props.shape === "polygon") {
      if (props.points.length === 0) return { width: 0, height: 0 };
      let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
      for (const point of props.points) {
        minX = Math.min(minX, point.x);
        maxX = Math.max(maxX, point.x);
        minY = Math.min(minY, point.y);
        maxY = Math.max(maxY, point.y);
      }
      return { width: maxX - minX, height: maxY - minY };
    }
    return { width: 0, height: 0 };
  }
  _getPcbCircuitJsonBounds() {
    if (!this.pcb_cutout_id) return super._getPcbCircuitJsonBounds();
    const { db } = this.root;
    const cutout = db.pcb_cutout.get(this.pcb_cutout_id);
    if (!cutout) return super._getPcbCircuitJsonBounds();
    if (cutout.shape === "rect") {
      return {
        center: cutout.center,
        bounds: {
          left: cutout.center.x - cutout.width / 2,
          top: cutout.center.y + cutout.height / 2,
          // Assuming Y is up
          right: cutout.center.x + cutout.width / 2,
          bottom: cutout.center.y - cutout.height / 2
        },
        width: cutout.width,
        height: cutout.height
      };
    } else if (cutout.shape === "circle") {
      return {
        center: cutout.center,
        bounds: {
          left: cutout.center.x - cutout.radius,
          top: cutout.center.y + cutout.radius,
          right: cutout.center.x + cutout.radius,
          bottom: cutout.center.y - cutout.radius
        },
        width: cutout.radius * 2,
        height: cutout.radius * 2
      };
    } else if (cutout.shape === "polygon") {
      if (cutout.points.length === 0) return super._getPcbCircuitJsonBounds();
      let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
      for (const point of cutout.points) {
        minX = Math.min(minX, point.x);
        maxX = Math.max(maxX, point.x);
        minY = Math.min(minY, point.y);
        maxY = Math.max(maxY, point.y);
      }
      return {
        center: { x: (minX + maxX) / 2, y: (minY + maxY) / 2 },
        bounds: { left: minX, top: maxY, right: maxX, bottom: minY },
        width: maxX - minX,
        height: maxY - minY
      };
    }
    return super._getPcbCircuitJsonBounds();
  }
  _setPositionFromLayout(newCenter) {
    if (!this.pcb_cutout_id) return;
    const { db } = this.root;
    const cutout = db.pcb_cutout.get(this.pcb_cutout_id);
    if (!cutout) return;
    if (cutout.shape === "rect" || cutout.shape === "circle") {
      db.pcb_cutout.update(this.pcb_cutout_id, {
        ...cutout,
        center: newCenter
      });
    } else if (cutout.shape === "polygon") {
      const oldCenter = this._getPcbCircuitJsonBounds().center;
      const dx = newCenter.x - oldCenter.x;
      const dy = newCenter.y - oldCenter.y;
      const newPoints = cutout.points.map((p) => ({
        x: p.x + dx,
        y: p.y + dy
      }));
      db.pcb_cutout.update(this.pcb_cutout_id, {
        ...cutout,
        points: newPoints
      });
    }
  }
};

// lib/utils/createPinrowSilkscreenText.ts
var createPinrowSilkscreenText = ({
  elm,
  pinLabels,
  layer,
  readableRotation,
  anchorAlignment
}) => {
  const pinNum = elm.text.replace(/[{}]/g, "").toLowerCase();
  let label = pinNum;
  if (Array.isArray(pinLabels)) {
    const index = parseInt(pinNum.replace(/[^\d]/g, ""), 10) - 1;
    label = String(pinLabels[index] ?? pinNum);
  } else if (typeof pinLabels === "object") {
    label = String(pinLabels[pinNum] ?? pinNum);
  }
  return new SilkscreenText({
    anchorAlignment: anchorAlignment || "center",
    text: label ?? pinNum,
    layer: layer || "top",
    fontSize: elm.font_size + 0.2,
    pcbX: isNaN(elm.anchor_position.x) ? 0 : elm.anchor_position.x,
    pcbY: elm.anchor_position.y,
    pcbRotation: readableRotation ?? 0
  });
};

// lib/utils/createComponentsFromCircuitJson.ts
var calculateCcwRotation = (componentRotationStr, elementCcwRotation) => {
  const componentAngle = parseInt(componentRotationStr || "0", 10);
  const baseRotation = -componentAngle;
  const totalRotation = baseRotation + (elementCcwRotation ?? 0);
  const normalizedRotation = (totalRotation % 360 + 360) % 360;
  return normalizedRotation;
};
var createComponentsFromCircuitJson = ({
  componentName,
  componentRotation,
  footprint,
  pinLabels,
  pcbPinLabels
}, soup) => {
  const components = [];
  for (const elm of soup) {
    if (elm.type === "pcb_smtpad" && elm.shape === "rect") {
      components.push(
        new SmtPad({
          pcbX: elm.x,
          pcbY: elm.y,
          layer: elm.layer,
          shape: "rect",
          height: elm.height,
          width: elm.width,
          portHints: elm.port_hints
        })
      );
    } else if (elm.type === "pcb_smtpad" && elm.shape === "circle") {
      components.push(
        new SmtPad({
          pcbX: elm.x,
          pcbY: elm.y,
          layer: elm.layer,
          shape: "circle",
          radius: elm.radius,
          portHints: elm.port_hints
        })
      );
    } else if (elm.type === "pcb_silkscreen_path") {
      components.push(
        new SilkscreenPath({
          layer: elm.layer,
          route: elm.route,
          strokeWidth: elm.stroke_width
        })
      );
    } else if (elm.type === "pcb_plated_hole") {
      if (elm.shape === "circle") {
        components.push(
          new PlatedHole({
            pcbX: elm.x,
            pcbY: elm.y,
            shape: "circle",
            holeDiameter: elm.hole_diameter,
            outerDiameter: elm.outer_diameter,
            portHints: elm.port_hints
          })
        );
      } else if (elm.shape === "circular_hole_with_rect_pad") {
        components.push(
          new PlatedHole({
            pcbX: elm.x,
            pcbY: elm.y,
            shape: "circular_hole_with_rect_pad",
            holeDiameter: elm.hole_diameter,
            rectPadHeight: elm.rect_pad_height,
            rectPadWidth: elm.rect_pad_width,
            portHints: elm.port_hints
          })
        );
      }
    } else if (elm.type === "pcb_keepout" && elm.shape === "circle") {
      components.push(
        new Keepout({
          pcbX: elm.center.x,
          pcbY: elm.center.y,
          shape: "circle",
          radius: elm.radius
        })
      );
    } else if (elm.type === "pcb_keepout" && elm.shape === "rect") {
      components.push(
        new Keepout({
          pcbX: elm.center.x,
          pcbY: elm.center.y,
          shape: "rect",
          width: elm.width,
          height: elm.height
        })
      );
    } else if (elm.type === "pcb_hole" && elm.hole_shape === "circle") {
      components.push(
        new Hole({
          pcbX: elm.x,
          pcbY: elm.y,
          diameter: elm.hole_diameter
        })
      );
    } else if (elm.type === "pcb_cutout") {
      if (elm.shape === "rect") {
        components.push(
          new Cutout({
            pcbX: elm.center.x,
            pcbY: elm.center.y,
            shape: "rect",
            width: elm.width,
            height: elm.height
          })
        );
      } else if (elm.shape === "circle") {
        components.push(
          new Cutout({
            pcbX: elm.center.x,
            pcbY: elm.center.y,
            shape: "circle",
            radius: elm.radius
          })
        );
      } else if (elm.shape === "polygon") {
        components.push(
          new Cutout({
            shape: "polygon",
            points: elm.points
          })
        );
      }
    } else if (elm.type === "pcb_silkscreen_text") {
      const ccwRotation = calculateCcwRotation(
        componentRotation,
        elm.ccw_rotation
      );
      if (footprint.includes("pinrow") && elm.text.includes("PIN")) {
        components.push(
          createPinrowSilkscreenText({
            elm,
            pinLabels: pcbPinLabels ?? pinLabels,
            layer: elm.layer,
            readableRotation: ccwRotation,
            anchorAlignment: elm.anchor_alignment
          })
        );
      } else {
        components.push(
          new SilkscreenText({
            anchorAlignment: elm.anchor_alignment || "center",
            text: componentName,
            fontSize: elm.font_size + 0.2,
            pcbX: Number.isNaN(elm.anchor_position.x) ? 0 : elm.anchor_position.x,
            pcbY: elm.anchor_position.y,
            pcbRotation: ccwRotation ?? 0
          })
        );
      }
    } else if (elm.type === "pcb_trace") {
      components.push(
        new PcbTrace({
          route: elm.route
        })
      );
    }
  }
  return components;
};

// lib/utils/get-bounds-of-pcb-components.ts
function getBoundsOfPcbComponents(components) {
  let minX = Infinity;
  let minY = Infinity;
  let maxX = -Infinity;
  let maxY = -Infinity;
  let hasValidComponents = false;
  for (const child of components) {
    if (child.isPcbPrimitive && !child.componentName.startsWith("Silkscreen")) {
      const { x, y } = child._getGlobalPcbPositionBeforeLayout();
      const { width: width2, height: height2 } = child.getPcbSize();
      minX = Math.min(minX, x - width2 / 2);
      minY = Math.min(minY, y - height2 / 2);
      maxX = Math.max(maxX, x + width2 / 2);
      maxY = Math.max(maxY, y + height2 / 2);
      hasValidComponents = true;
    } else if (child.children.length > 0) {
      const childBounds = getBoundsOfPcbComponents(child.children);
      if (childBounds.width > 0 || childBounds.height > 0) {
        minX = Math.min(minX, childBounds.minX);
        minY = Math.min(minY, childBounds.minY);
        maxX = Math.max(maxX, childBounds.maxX);
        maxY = Math.max(maxY, childBounds.maxY);
        hasValidComponents = true;
      }
    }
  }
  if (!hasValidComponents) {
    return {
      minX: 0,
      minY: 0,
      maxX: 0,
      maxY: 0,
      width: 0,
      height: 0
    };
  }
  let width = maxX - minX;
  let height = maxY - minY;
  if (width < 0) width = 0;
  if (height < 0) height = 0;
  return {
    minX,
    minY,
    maxX,
    maxY,
    width,
    height
  };
}

// lib/utils/get-relative-direction.ts
function getRelativeDirection(pointA, pointB) {
  const dx = pointB.x - pointA.x;
  const dy = pointB.y - pointA.y;
  if (Math.abs(dx) > Math.abs(dy)) {
    return dx >= 0 ? "right" : "left";
  }
  return dy >= 0 ? "up" : "down";
}

// lib/components/primitive-components/Port/Port.ts
import "schematic-symbols";
import { applyToPoint as applyToPoint5, compose as compose3, translate as translate3 } from "transformation-matrix";
import { z as z6 } from "zod";

// lib/components/primitive-components/Port/areAllPcbPrimitivesOverlapping.ts
var areAllPcbPrimitivesOverlapping = (pcbPrimitives) => {
  if (pcbPrimitives.length <= 1) return true;
  const bounds = pcbPrimitives.map((p) => {
    const circuitBounds = p._getPcbCircuitJsonBounds();
    return {
      left: circuitBounds.bounds.left,
      right: circuitBounds.bounds.right,
      top: circuitBounds.bounds.top,
      bottom: circuitBounds.bounds.bottom
    };
  });
  const overlaps = Array(bounds.length).fill(false).map(() => Array(bounds.length).fill(false));
  for (let i = 0; i < bounds.length; i++) {
    for (let j = i + 1; j < bounds.length; j++) {
      const a = bounds[i];
      const b = bounds[j];
      overlaps[i][j] = overlaps[j][i] = !(a.right < b.left || a.left > b.right || a.bottom > b.top || a.top < b.bottom);
    }
  }
  const visited = /* @__PURE__ */ new Set();
  const dfs = (node) => {
    visited.add(node);
    for (let i = 0; i < bounds.length; i++) {
      if (overlaps[node][i] && !visited.has(i)) {
        dfs(i);
      }
    }
  };
  dfs(0);
  return visited.size === bounds.length;
};

// lib/components/primitive-components/Port/getCenterOfPcbPrimitives.ts
var getCenterOfPcbPrimitives = (pcbPrimitives) => {
  if (pcbPrimitives.length === 0) {
    throw new Error("Cannot get center of empty PCB primitives array");
  }
  const positions = pcbPrimitives.map((p) => p._getPcbCircuitJsonBounds().center).filter(Boolean);
  const sumX = positions.reduce((sum, pos) => sum + pos.x, 0);
  const sumY = positions.reduce((sum, pos) => sum + pos.y, 0);
  return {
    x: sumX / positions.length,
    y: sumY / positions.length
  };
};

// lib/components/primitive-components/Port/Port.ts
var portProps = z6.object({
  name: z6.string().optional(),
  pinNumber: z6.number().optional(),
  aliases: z6.array(z6.string()).optional()
});
var Port = class extends PrimitiveComponent2 {
  source_port_id = null;
  pcb_port_id = null;
  schematic_port_id = null;
  schematicSymbolPortDef = null;
  matchedComponents;
  facingDirection = null;
  originDescription = null;
  get config() {
    return {
      componentName: "Port",
      zodProps: portProps
    };
  }
  constructor(props, opts = {}) {
    if (!props.name && props.pinNumber !== void 0)
      props.name = `pin${props.pinNumber}`;
    if (!props.name) {
      throw new Error("Port must have a name or a pinNumber");
    }
    super(props);
    if (opts.originDescription) {
      this.originDescription = opts.originDescription;
    }
    this.matchedComponents = [];
  }
  _getGlobalPcbPositionBeforeLayout() {
    const matchedPcbElm = this.matchedComponents.find((c) => c.isPcbPrimitive);
    const parentComponent = this.parent;
    if (parentComponent && !parentComponent.props.footprint) {
      throw new Error(
        `${parentComponent.componentName} "${parentComponent.props.name}" does not have a footprint. Add a footprint prop, e.g. <${parentComponent.componentName.toLowerCase()} footprint="..." />`
      );
    }
    if (!matchedPcbElm) {
      throw new Error(
        `Port ${this} has no matching PCB primitives. This often means the footprint's pads lack matching port hints.`
      );
    }
    return matchedPcbElm?._getGlobalPcbPositionBeforeLayout() ?? { x: 0, y: 0 };
  }
  _getPcbCircuitJsonBounds() {
    if (!this.pcb_port_id) {
      return super._getPcbCircuitJsonBounds();
    }
    const { db } = this.root;
    const pcb_port = db.pcb_port.get(this.pcb_port_id);
    return {
      center: { x: pcb_port.x, y: pcb_port.y },
      bounds: { left: 0, top: 0, right: 0, bottom: 0 },
      width: 0,
      height: 0
    };
  }
  _getGlobalPcbPositionAfterLayout() {
    return this._getPcbCircuitJsonBounds().center;
  }
  _getPortsInternallyConnectedToThisPort() {
    const parent = this.parent;
    if (!parent || !parent._getInternallyConnectedPins) return [];
    const internallyConnectedPorts = parent._getInternallyConnectedPins();
    for (const ports of internallyConnectedPorts) {
      if (ports.some((port) => port === this)) {
        return ports;
      }
    }
    return [];
  }
  /**
   * Return true if this port has a schematic representation and can be rendered
   * to the schematic.
   *
   * Sometimes things like mounting holes don't have a schematic representation
   * and aren't rendered to the schematic.
   *
   * It's common for a schematic symbol to not have a representation for all of
   * the pins on a footprint, e.g. a pushbutton has 4 pins but is typically
   * represented by a two-pin symbol. In these cases, it's best to use
   * internallyConnectedPorts or externallyConnectedPorts to ensure the things
   * are rendered properly.
   */
  _hasSchematicPort() {
    const symbol = this.parent?.getSchematicSymbol();
    if (symbol) {
      if (this.schematicSymbolPortDef) return true;
      const portsInternallyConnectedToThisPort = this._getPortsInternallyConnectedToThisPort();
      if (portsInternallyConnectedToThisPort.some((p) => p.schematicSymbolPortDef))
        return true;
      return false;
    }
    const parentBoxDim = this?.parent?._getSchematicBoxDimensions();
    if (parentBoxDim && this.props.pinNumber !== void 0) {
      const localPortPosition = parentBoxDim.getPortPositionByPinNumber(
        this.props.pinNumber
      );
      if (localPortPosition) return true;
    }
    return false;
  }
  _getGlobalSchematicPositionBeforeLayout() {
    const symbol = this.parent?.getSchematicSymbol();
    if (symbol) {
      let schematicSymbolPortDef = this.schematicSymbolPortDef;
      if (!schematicSymbolPortDef) {
        schematicSymbolPortDef = this._getPortsInternallyConnectedToThisPort().find(
          (p) => p.schematicSymbolPortDef
        )?.schematicSymbolPortDef ?? null;
        if (!schematicSymbolPortDef) {
          throw new Error(
            `Couldn't find schematicSymbolPortDef for port ${this.getString()}, searched internally connected ports and none had a schematicSymbolPortDef. Why are we trying to get the schematic position of this port?`
          );
        }
      }
      const transform = compose3(
        this.parent.computeSchematicGlobalTransform(),
        translate3(-symbol.center.x, -symbol.center.y)
      );
      return applyToPoint5(transform, schematicSymbolPortDef);
    }
    const parentBoxDim = this?.parent?._getSchematicBoxDimensions();
    if (parentBoxDim && this.props.pinNumber !== void 0) {
      const localPortPosition = parentBoxDim.getPortPositionByPinNumber(
        this.props.pinNumber
      );
      if (!localPortPosition) {
        throw new Error(
          `Couldn't find position for schematic_port for port ${this.getString()} inside of the schematic box`
        );
      }
      return applyToPoint5(
        this.parent.computeSchematicGlobalTransform(),
        localPortPosition
      );
    }
    throw new Error(
      `Couldn't find position for schematic_port for port ${this.getString()}`
    );
  }
  _getGlobalSchematicPositionAfterLayout() {
    const { db } = this.root;
    if (!this.schematic_port_id) {
      throw new Error(
        `Can't get schematic port position after layout for "${this.getString()}", no schematic_port_id`
      );
    }
    const schematic_port = db.schematic_port.get(this.schematic_port_id);
    if (!schematic_port)
      throw new Error(
        `Schematic port not found when trying to get post-layout position: ${this.schematic_port_id}`
      );
    return schematic_port.center;
  }
  /**
   * Smtpads and platedholes call this method to register themselves as a match
   * for this port. All the matching is done by primitives other than the Port,
   * but everyone registers themselves as a match with their Port.
   */
  registerMatch(component) {
    this.matchedComponents.push(component);
  }
  getNameAndAliases() {
    const { _parsedProps: props } = this;
    return Array.from(
      /* @__PURE__ */ new Set([
        ...props.aliases ?? [],
        ...props.name ? [props.name] : [],
        ...typeof props.pinNumber === "number" ? [`pin${props.pinNumber}`, props.pinNumber.toString()] : [],
        ...this.externallyAddedAliases ?? []
      ])
    );
  }
  isMatchingPort(port) {
    return this.isMatchingAnyOf(port.getNameAndAliases());
  }
  getPortSelector() {
    return `.${this.parent?.props.name} > port.${this.props.name}`;
  }
  getAvailablePcbLayers() {
    return Array.from(
      new Set(this.matchedComponents.flatMap((c) => c.getAvailablePcbLayers()))
    );
  }
  /**
   * Return traces that are explicitly connected to this port (not via a net)
   */
  _getDirectlyConnectedTraces() {
    const allSubcircuitTraces = this.getSubcircuit().selectAll(
      "trace"
    );
    const connectedTraces = allSubcircuitTraces.filter(
      (trace) => trace._isExplicitlyConnectedToPort(this)
    );
    return connectedTraces;
  }
  doInitialSourceRender() {
    const { db } = this.root;
    const { _parsedProps: props } = this;
    const port_hints = this.getNameAndAliases();
    const source_port = db.source_port.insert({
      name: props.name,
      pin_number: props.pinNumber,
      port_hints,
      source_component_id: this.parent?.source_component_id,
      subcircuit_id: this.getSubcircuit()?.subcircuit_id
    });
    this.source_port_id = source_port.source_port_id;
  }
  doInitialSourceParentAttachment() {
    const { db } = this.root;
    if (!this.parent?.source_component_id) {
      throw new Error(
        `${this.getString()} has no parent source component (parent: ${this.parent?.getString()})`
      );
    }
    db.source_port.update(this.source_port_id, {
      source_component_id: this.parent?.source_component_id,
      subcircuit_id: this.getSubcircuit()?.subcircuit_id
    });
    this.source_component_id = this.parent?.source_component_id;
  }
  doInitialPcbPortRender() {
    if (this.root?.pcbDisabled) return;
    const { db } = this.root;
    const { matchedComponents } = this;
    if (!this.parent?.pcb_component_id) {
      throw new Error(
        `${this.getString()} has no parent pcb component, cannot render pcb_port (parent: ${this.parent?.getString()})`
      );
    }
    const pcbMatches = matchedComponents.filter((c) => c.isPcbPrimitive);
    if (pcbMatches.length === 0) return;
    let matchCenter = null;
    if (pcbMatches.length === 1) {
      matchCenter = pcbMatches[0]._getPcbCircuitJsonBounds().center;
    }
    if (pcbMatches.length > 1) {
      if (!areAllPcbPrimitivesOverlapping(pcbMatches)) {
        throw new Error(
          `${this.getString()} has multiple non-overlapping pcb matches, unclear how to place pcb_port: ${pcbMatches.map((c) => c.getString()).join(", ")}. (Note: tscircuit core does not currently allow you to specify internally connected pcb primitives with the same port hints, try giving them different port hints and specifying they are connected externally- or file an issue)`
        );
      }
      matchCenter = getCenterOfPcbPrimitives(pcbMatches);
    }
    if (matchCenter) {
      const subcircuit = this.getSubcircuit();
      const pcb_port = db.pcb_port.insert({
        pcb_component_id: this.parent?.pcb_component_id,
        layers: this.getAvailablePcbLayers(),
        subcircuit_id: subcircuit?.subcircuit_id ?? void 0,
        pcb_group_id: this.getGroup()?.pcb_group_id ?? void 0,
        ...matchCenter,
        source_port_id: this.source_port_id
      });
      this.pcb_port_id = pcb_port.pcb_port_id;
    } else {
      const pcbMatch = pcbMatches[0];
      throw new Error(
        `${pcbMatch.getString()} does not have a center or _getGlobalPcbPositionBeforeLayout method (needed for pcb_port placement)`
      );
    }
  }
  doInitialSchematicPortRender() {
    const { db } = this.root;
    const { _parsedProps: props } = this;
    const container = this.getPrimitiveContainer();
    if (!container) return;
    if (!this._hasSchematicPort()) return;
    const containerCenter = container._getGlobalSchematicPositionBeforeLayout();
    const portCenter = this._getGlobalSchematicPositionBeforeLayout();
    let localPortInfo = null;
    const containerDims = container._getSchematicBoxDimensions();
    if (containerDims && props.pinNumber !== void 0) {
      localPortInfo = containerDims.getPortPositionByPinNumber(props.pinNumber);
    }
    if (this.getSubcircuit().props._schDebugObjectsEnabled) {
      db.schematic_debug_object.insert({
        shape: "rect",
        center: portCenter,
        size: {
          width: 0.1,
          height: 0.1
        },
        label: "obstacle"
      });
    }
    if (!localPortInfo?.side) {
      this.facingDirection = getRelativeDirection(containerCenter, portCenter);
    } else {
      this.facingDirection = {
        left: "left",
        right: "right",
        top: "up",
        bottom: "down"
      }[localPortInfo.side];
    }
    const sourcePort = db.source_port.get(this.source_port_id);
    const labelHints = [];
    for (const portHint of sourcePort?.port_hints ?? []) {
      if (portHint.match(/^(pin)?\d+$/)) continue;
      if (portHint.match(/^(left|right)/) && !sourcePort?.name.match(/^(left|right)/))
        continue;
      labelHints.push(portHint);
    }
    let bestDisplayPinLabel = void 0;
    const showPinAliases = this.parent?.props?.showPinAliases;
    if (showPinAliases && labelHints.length > 0) {
      bestDisplayPinLabel = labelHints.join("/");
    } else if (labelHints.length > 0) {
      bestDisplayPinLabel = labelHints[labelHints.length - 1];
    }
    const schematic_port = db.schematic_port.insert({
      schematic_component_id: this.parent?.schematic_component_id,
      center: portCenter,
      source_port_id: this.source_port_id,
      facing_direction: this.facingDirection,
      distance_from_component_edge: 0.4,
      side_of_component: localPortInfo?.side,
      pin_number: props.pinNumber,
      true_ccw_index: localPortInfo?.trueIndex,
      display_pin_label: bestDisplayPinLabel,
      is_connected: false
    });
    this.schematic_port_id = schematic_port.schematic_port_id;
  }
  _setPositionFromLayout(newCenter) {
    const { db } = this.root;
    if (!this.pcb_port_id) return;
    db.pcb_port.update(this.pcb_port_id, {
      x: newCenter.x,
      y: newCenter.y
    });
  }
  _hasMatchedPcbPrimitive() {
    return this.matchedComponents.some((c) => c.isPcbPrimitive);
  }
};

// lib/utils/getPortFromHints.ts
var getPinNumberFromLabels = (labels) => {
  const pinNumber = labels.find((p) => /^(pin)?\d+$/.test(p));
  if (!pinNumber) return null;
  return Number.parseInt(pinNumber.replace(/^pin/, ""));
};
function getPortFromHints(hints, opts) {
  const pinNumber = getPinNumberFromLabels(hints);
  if (!pinNumber) return null;
  const aliasesFromHints = hints.filter(
    (p) => p.toString() !== pinNumber.toString() && p !== `pin${pinNumber}`
  );
  const aliases = [
    ...aliasesFromHints,
    ...opts?.additionalAliases?.[`pin${pinNumber}`] ?? []
  ];
  return new Port({
    pinNumber,
    aliases
  });
}

// lib/utils/schematic/getSizeOfSidesFromPortArrangement.ts
var hasExplicitPinMapping = (pa) => {
  for (const side of [
    "leftSide",
    "rightSide",
    "topSide",
    "bottomSide"
  ]) {
    if (side in pa && typeof pa[side] === "number") {
      throw new Error(
        `A number was specified for "${side}", you probably meant to use "size" not "side"`
      );
    }
  }
  return "leftSide" in pa || "rightSide" in pa || "topSide" in pa || "bottomSide" in pa;
};
var getSizeOfSidesFromPortArrangement = (pa) => {
  if (hasExplicitPinMapping(pa)) {
    return {
      leftSize: pa.leftSide?.pins.length ?? 0,
      rightSize: pa.rightSide?.pins.length ?? 0,
      topSize: pa.topSide?.pins.length ?? 0,
      bottomSize: pa.bottomSide?.pins.length ?? 0
    };
  }
  const { leftSize = 0, rightSize = 0, topSize = 0, bottomSize = 0 } = pa;
  return { leftSize, rightSize, topSize, bottomSize };
};

// lib/utils/schematic/getAllDimensionsForSchematicBox.ts
function isExplicitPinMappingArrangement(arrangement) {
  const a = arrangement;
  return a.leftSide !== void 0 || a.rightSide !== void 0 || a.topSide !== void 0 || a.bottomSide !== void 0;
}
var getAllDimensionsForSchematicBox = (params) => {
  const portDistanceFromEdge = params.portDistanceFromEdge ?? 0.4;
  let sidePinCounts = params.schPortArrangement ? getSizeOfSidesFromPortArrangement(params.schPortArrangement) : null;
  const sideLengths = {
    left: 0,
    right: 0,
    top: 0,
    bottom: 0
  };
  let pinCount = params.pinCount ?? null;
  if (pinCount === null) {
    if (sidePinCounts) {
      pinCount = sidePinCounts.leftSize + sidePinCounts.rightSize + sidePinCounts.topSize;
    } else {
      throw new Error("Could not determine pin count for the schematic box");
    }
  }
  if (pinCount && !sidePinCounts) {
    const rightSize = Math.floor(pinCount / 2);
    sidePinCounts = {
      leftSize: pinCount - rightSize,
      rightSize,
      topSize: 0,
      bottomSize: 0
    };
  }
  if (!sidePinCounts) {
    sidePinCounts = {
      leftSize: 0,
      rightSize: 0,
      topSize: 0,
      bottomSize: 0
    };
  }
  const getPinNumberUsingSideIndex = ({
    side,
    sideIndex,
    truePinIndex: truePinIndex2
  }) => {
    if (!params.schPortArrangement) return truePinIndex2 + 1;
    if (!isExplicitPinMappingArrangement(params.schPortArrangement))
      return truePinIndex2 + 1;
    const normalCcwDirection = {
      left: "top-to-bottom",
      bottom: "left-to-right",
      right: "bottom-to-top",
      top: "right-to-left"
    }[side];
    const directionAlongSide = params.schPortArrangement?.[`${side}Side`]?.direction ?? normalCcwDirection;
    const pinsDefinitionForSide = params.schPortArrangement?.[`${side}Side`]?.pins;
    let sideIndexWithDirectionCorrection = sideIndex;
    if (directionAlongSide !== normalCcwDirection) {
      sideIndexWithDirectionCorrection = pinsDefinitionForSide.length - sideIndex - 1;
    }
    return parsePinNumberFromLabelsOrThrow(
      pinsDefinitionForSide[sideIndexWithDirectionCorrection],
      params.pinLabels
    );
  };
  const orderedTruePorts = [];
  let currentDistanceFromEdge = 0;
  let truePinIndex = 0;
  for (let sideIndex = 0; sideIndex < sidePinCounts.leftSize; sideIndex++) {
    const pinNumber = getPinNumberUsingSideIndex({
      side: "left",
      sideIndex,
      truePinIndex
    });
    const pinStyle = params.numericSchPinStyle?.[`pin${pinNumber}`] ?? params.numericSchPinStyle?.[pinNumber];
    if (pinStyle?.topMargin) {
      currentDistanceFromEdge += pinStyle.topMargin;
    }
    orderedTruePorts.push({
      trueIndex: truePinIndex,
      pinNumber,
      side: "left",
      distanceFromOrthogonalEdge: currentDistanceFromEdge
    });
    if (pinStyle?.bottomMargin) {
      currentDistanceFromEdge += pinStyle.bottomMargin;
    }
    const isLastPinOnSide = sideIndex === sidePinCounts.leftSize - 1;
    if (!isLastPinOnSide) {
      currentDistanceFromEdge += params.schPinSpacing;
    } else {
      sideLengths.left = currentDistanceFromEdge;
    }
    truePinIndex++;
  }
  currentDistanceFromEdge = 0;
  for (let sideIndex = 0; sideIndex < sidePinCounts.bottomSize; sideIndex++) {
    const pinNumber = getPinNumberUsingSideIndex({
      side: "bottom",
      sideIndex,
      truePinIndex
    });
    const pinStyle = params.numericSchPinStyle?.[`pin${pinNumber}`] ?? params.numericSchPinStyle?.[pinNumber];
    if (pinStyle?.leftMargin) {
      currentDistanceFromEdge += pinStyle.leftMargin;
    }
    orderedTruePorts.push({
      trueIndex: truePinIndex,
      pinNumber,
      side: "bottom",
      distanceFromOrthogonalEdge: currentDistanceFromEdge
    });
    if (pinStyle?.rightMargin) {
      currentDistanceFromEdge += pinStyle.rightMargin;
    }
    const isLastPinOnSide = sideIndex === sidePinCounts.bottomSize - 1;
    if (!isLastPinOnSide) {
      currentDistanceFromEdge += params.schPinSpacing;
    } else {
      sideLengths.bottom = currentDistanceFromEdge;
    }
    truePinIndex++;
  }
  currentDistanceFromEdge = 0;
  for (let sideIndex = 0; sideIndex < sidePinCounts.rightSize; sideIndex++) {
    const pinNumber = getPinNumberUsingSideIndex({
      side: "right",
      sideIndex,
      truePinIndex
    });
    const pinStyle = params.numericSchPinStyle?.[`pin${pinNumber}`] ?? params.numericSchPinStyle?.[pinNumber];
    if (pinStyle?.bottomMargin) {
      currentDistanceFromEdge += pinStyle.bottomMargin;
    }
    orderedTruePorts.push({
      trueIndex: truePinIndex,
      pinNumber,
      side: "right",
      distanceFromOrthogonalEdge: currentDistanceFromEdge
    });
    if (pinStyle?.topMargin) {
      currentDistanceFromEdge += pinStyle.topMargin;
    }
    const isLastPinOnSide = sideIndex === sidePinCounts.rightSize - 1;
    if (!isLastPinOnSide) {
      currentDistanceFromEdge += params.schPinSpacing;
    } else {
      sideLengths.right = currentDistanceFromEdge;
    }
    truePinIndex++;
  }
  currentDistanceFromEdge = 0;
  for (let sideIndex = 0; sideIndex < sidePinCounts.topSize; sideIndex++) {
    const pinNumber = getPinNumberUsingSideIndex({
      side: "top",
      sideIndex,
      truePinIndex
    });
    const pinStyle = params.numericSchPinStyle?.[`pin${pinNumber}`] ?? params.numericSchPinStyle?.[pinNumber];
    if (pinStyle?.rightMargin) {
      currentDistanceFromEdge += pinStyle.rightMargin;
    }
    orderedTruePorts.push({
      trueIndex: truePinIndex,
      pinNumber,
      side: "top",
      distanceFromOrthogonalEdge: currentDistanceFromEdge
    });
    if (pinStyle?.leftMargin) {
      currentDistanceFromEdge += pinStyle.leftMargin;
    }
    const isLastPinOnSide = sideIndex === sidePinCounts.topSize - 1;
    if (!isLastPinOnSide) {
      currentDistanceFromEdge += params.schPinSpacing;
    } else {
      sideLengths.top = currentDistanceFromEdge;
    }
    truePinIndex++;
  }
  let schWidth = params.schWidth;
  if (schWidth === void 0) {
    schWidth = Math.max(
      sideLengths.top + params.schPinSpacing * 2,
      sideLengths.bottom + params.schPinSpacing * 2
    );
    const labelWidth = params.pinLabels ? Math.max(
      ...Object.values(params.pinLabels).map(
        (label) => label.length * 0.1
        // Estimated text width
      )
    ) : 0;
    const LABEL_PADDING = labelWidth > 0 ? 1.1 : 0;
    schWidth = Math.max(schWidth, labelWidth + LABEL_PADDING);
  }
  let schHeight = params.schHeight;
  if (!schHeight) {
    schHeight = Math.max(
      sideLengths.left + params.schPinSpacing * 2,
      sideLengths.right + params.schPinSpacing * 2
    );
  }
  const trueEdgePositions = {
    // Top left corner
    left: {
      x: -schWidth / 2 - portDistanceFromEdge,
      y: sideLengths.left / 2
    },
    // bottom left corner
    bottom: {
      x: -sideLengths.bottom / 2,
      y: -schHeight / 2 - portDistanceFromEdge
    },
    // bottom right corner
    right: {
      x: schWidth / 2 + portDistanceFromEdge,
      y: -sideLengths.right / 2
    },
    // top right corner
    top: {
      x: sideLengths.top / 2,
      y: schHeight / 2 + portDistanceFromEdge
    }
  };
  const trueEdgeTraversalDirections = {
    left: { x: 0, y: -1 },
    right: { x: 0, y: 1 },
    top: { x: -1, y: 0 },
    bottom: { x: 1, y: 0 }
  };
  const truePortsWithPositions = orderedTruePorts.map((p) => {
    const { distanceFromOrthogonalEdge, side } = p;
    const edgePos = trueEdgePositions[side];
    const edgeDir = trueEdgeTraversalDirections[side];
    return {
      x: edgePos.x + distanceFromOrthogonalEdge * edgeDir.x,
      y: edgePos.y + distanceFromOrthogonalEdge * edgeDir.y,
      ...p
    };
  });
  return {
    getPortPositionByPinNumber(pinNumber) {
      const port = truePortsWithPositions.find(
        (p) => p.pinNumber.toString() === pinNumber.toString()
      );
      if (!port) {
        return null;
      }
      return port;
    },
    getSize() {
      return { width: schWidth, height: schHeight };
    },
    getSizeIncludingPins() {
      return {
        width: schWidth + (sidePinCounts.leftSize || sidePinCounts.rightSize ? 0.4 : 0),
        height: schHeight + (sidePinCounts.topSize || sidePinCounts.bottomSize ? 0.4 : 0)
      };
    },
    pinCount
  };
};

// lib/components/base-components/NormalComponent/NormalComponent.ts
import {
  isValidElement as isReactElement,
  isValidElement
} from "react";
import { symbols as symbols2 } from "schematic-symbols";
import { z as z8 } from "zod";

// lib/components/primitive-components/Footprint.ts
import { footprintProps } from "@tscircuit/props";
import * as kiwi from "@lume/kiwi";
import Debug3 from "debug";
var debug2 = Debug3("tscircuit:core:footprint");
var Footprint = class extends PrimitiveComponent2 {
  get config() {
    return {
      componentName: "Footprint",
      zodProps: footprintProps
    };
  }
  /**
   * A footprint is a constrainedlayout, the db elements are adjusted according
   * to any constraints that are defined.
   */
  doInitialPcbFootprintLayout() {
    if (this.root?.pcbDisabled) return;
    const constraints = this.children.filter(
      (child) => child.componentName === "Constraint"
    );
    if (constraints.length === 0) return;
    const { isFlipped } = this._getPcbPrimitiveFlippedHelpers();
    const maybeFlipLeftRight = (props) => {
      if (isFlipped) {
        if ("left" in props && "right" in props) {
          return {
            ...props,
            left: props.right,
            right: props.left
          };
        }
      }
      return props;
    };
    const involvedComponents = constraints.flatMap(
      (constraint) => constraint._getAllReferencedComponents().componentsWithSelectors
    ).map(({ component, selector, componentSelector, edge }) => ({
      component,
      selector,
      componentSelector,
      edge,
      bounds: component._getPcbCircuitJsonBounds()
    }));
    if (involvedComponents.some((c) => c.edge)) {
      throw new Error(
        "edge constraints not implemented yet for footprint layout, contributions welcome!"
      );
    }
    function getComponentDetails(selector) {
      return involvedComponents.find(({ selector: s }) => s === selector);
    }
    const solver = new kiwi.Solver();
    const kVars = {};
    function getKVar(name) {
      if (!(name in kVars)) {
        kVars[name] = new kiwi.Variable(name);
        solver.addEditVariable(kVars[name], kiwi.Strength.weak);
      }
      return kVars[name];
    }
    for (const { selector, bounds: bounds2 } of involvedComponents) {
      const kvx = getKVar(`${selector}_x`);
      const kvy = getKVar(`${selector}_y`);
      solver.suggestValue(kvx, bounds2.center.x);
      solver.suggestValue(kvy, bounds2.center.y);
    }
    for (const constraint of constraints) {
      const props = constraint._parsedProps;
      if ("xDist" in props) {
        const { xDist, left, right, edgeToEdge, centerToCenter } = maybeFlipLeftRight(props);
        const leftVar = getKVar(`${left}_x`);
        const rightVar = getKVar(`${right}_x`);
        const leftBounds = getComponentDetails(left)?.bounds;
        const rightBounds = getComponentDetails(right)?.bounds;
        if (centerToCenter) {
          const expr = new kiwi.Expression(rightVar, [-1, leftVar]);
          solver.addConstraint(
            new kiwi.Constraint(
              expr,
              kiwi.Operator.Eq,
              props.xDist,
              kiwi.Strength.required
            )
          );
        } else if (edgeToEdge) {
          const expr = new kiwi.Expression(
            rightVar,
            -rightBounds.width / 2,
            [-1, leftVar],
            -leftBounds.width / 2
          );
          solver.addConstraint(
            new kiwi.Constraint(
              expr,
              kiwi.Operator.Eq,
              props.xDist,
              kiwi.Strength.required
            )
          );
        }
      } else if ("yDist" in props) {
        const { yDist, top, bottom, edgeToEdge, centerToCenter } = props;
        const topVar = getKVar(`${top}_y`);
        const bottomVar = getKVar(`${bottom}_y`);
        const topBounds = getComponentDetails(top)?.bounds;
        const bottomBounds = getComponentDetails(bottom)?.bounds;
        if (centerToCenter) {
          const expr = new kiwi.Expression(topVar, [-1, bottomVar]);
          solver.addConstraint(
            new kiwi.Constraint(
              expr,
              kiwi.Operator.Eq,
              props.yDist,
              kiwi.Strength.required
            )
          );
        } else if (edgeToEdge) {
          const expr = new kiwi.Expression(
            topVar,
            topBounds.height / 2,
            [-1, bottomVar],
            -bottomBounds.height / 2
          );
          solver.addConstraint(
            new kiwi.Constraint(
              expr,
              kiwi.Operator.Eq,
              props.yDist,
              kiwi.Strength.required
            )
          );
        }
      } else if ("sameY" in props) {
        const { for: selectors } = props;
        if (selectors.length < 2) continue;
        const vars = selectors.map((selector) => getKVar(`${selector}_y`));
        const expr = new kiwi.Expression(...vars.slice(1));
        solver.addConstraint(
          new kiwi.Constraint(
            expr,
            kiwi.Operator.Eq,
            vars[0],
            kiwi.Strength.required
          )
        );
      } else if ("sameX" in props) {
        const { for: selectors } = props;
        if (selectors.length < 2) continue;
        const vars = selectors.map((selector) => getKVar(`${selector}_x`));
        const expr = new kiwi.Expression(...vars.slice(1));
        solver.addConstraint(
          new kiwi.Constraint(
            expr,
            kiwi.Operator.Eq,
            vars[0],
            kiwi.Strength.required
          )
        );
      }
    }
    solver.updateVariables();
    if (debug2.enabled) {
      console.log("Solution to layout constraints:");
      console.table(
        Object.entries(kVars).map(([key, kvar]) => ({
          var: key,
          val: kvar.value()
        }))
      );
    }
    const bounds = {
      left: Infinity,
      right: -Infinity,
      top: -Infinity,
      bottom: Infinity
    };
    for (const {
      selector,
      bounds: { width, height }
    } of involvedComponents) {
      const kvx = getKVar(`${selector}_x`);
      const kvy = getKVar(`${selector}_y`);
      const newLeft = kvx.value() - width / 2;
      const newRight = kvx.value() + width / 2;
      const newTop = kvy.value() + height / 2;
      const newBottom = kvy.value() - height / 2;
      bounds.left = Math.min(bounds.left, newLeft);
      bounds.right = Math.max(bounds.right, newRight);
      bounds.top = Math.max(bounds.top, newTop);
      bounds.bottom = Math.min(bounds.bottom, newBottom);
    }
    const globalOffset = {
      x: -(bounds.right + bounds.left) / 2,
      y: -(bounds.top + bounds.bottom) / 2
    };
    const containerPos = this.getPrimitiveContainer()._getGlobalPcbPositionBeforeLayout();
    globalOffset.x += containerPos.x;
    globalOffset.y += containerPos.y;
    for (const { component, selector } of involvedComponents) {
      const kvx = getKVar(`${selector}_x`);
      const kvy = getKVar(`${selector}_y`);
      component._setPositionFromLayout({
        x: kvx.value() + globalOffset.x,
        y: kvy.value() + globalOffset.y
      });
    }
  }
};

// lib/utils/schematic/getNumericSchPinStyle.ts
var getNumericSchPinStyle = (pinStyles, pinLabels) => {
  if (!pinStyles) return void 0;
  const numericPinStyles = {};
  for (const [pinNameOrLabel, pinStyle] of Object.entries(pinStyles)) {
    const pinNumber = parsePinNumberFromLabelsOrThrow(pinNameOrLabel, pinLabels);
    const pinStyleWithSideFirst = {
      leftMargin: pinStyle.marginLeft ?? pinStyle.leftMargin,
      rightMargin: pinStyle.marginRight ?? pinStyle.rightMargin,
      topMargin: pinStyle.marginTop ?? pinStyle.topMargin,
      bottomMargin: pinStyle.marginBottom ?? pinStyle.bottomMargin
    };
    numericPinStyles[`pin${pinNumber}`] = {
      ...numericPinStyles[`pin${pinNumber}`],
      ...pinStyleWithSideFirst
    };
  }
  return numericPinStyles;
};

// lib/components/primitive-components/Trace/Trace.ts
import "@tscircuit/infgrid-ijump-astar";
import { traceProps } from "@tscircuit/props";
import "circuit-json";
import "circuit-json-to-connectivity-map";

// lib/utils/autorouting/DirectLineRouter.ts
var DirectLineRouter = class {
  input;
  constructor({ input }) {
    this.input = input;
  }
  solveAndMapToTraces() {
    const traces = [];
    for (const connection of this.input.connections) {
      if (connection.pointsToConnect.length !== 2) continue;
      const [start, end] = connection.pointsToConnect;
      const trace = {
        type: "pcb_trace",
        pcb_trace_id: "",
        connection_name: connection.name,
        route: [
          {
            route_type: "wire",
            x: start.x,
            y: start.y,
            layer: "top",
            width: 0.1
          },
          {
            route_type: "wire",
            x: end.x,
            y: end.y,
            layer: "top",
            width: 0.1
          }
        ]
      };
      traces.push(trace);
    }
    return traces;
  }
};

// lib/utils/autorouting/computeObstacleBounds.ts
var computeObstacleBounds = (obstacles) => {
  const minX = Math.min(...obstacles.map((o) => o.center.x));
  const maxX = Math.max(...obstacles.map((o) => o.center.x));
  const minY = Math.min(...obstacles.map((o) => o.center.y));
  const maxY = Math.max(...obstacles.map((o) => o.center.y));
  return { minX, maxX, minY, maxY };
};

// lib/utils/autorouting/findPossibleTraceLayerCombinations.ts
var LAYER_SELECTION_PREFERENCE = ["top", "bottom", "inner1", "inner2"];
var findPossibleTraceLayerCombinations = (hints, layer_path = []) => {
  const candidates = [];
  if (layer_path.length === 0) {
    const starting_layers = hints[0].layers;
    for (const layer of starting_layers) {
      candidates.push(
        ...findPossibleTraceLayerCombinations(hints.slice(1), [layer])
      );
    }
    return candidates;
  }
  if (hints.length === 0) return [];
  const current_hint = hints[0];
  const is_possibly_via = current_hint.via || current_hint.optional_via;
  const last_layer = layer_path[layer_path.length - 1];
  if (hints.length === 1) {
    const last_hint = current_hint;
    if (last_hint.layers && is_possibly_via) {
      return last_hint.layers.map((layer) => ({
        layer_path: [...layer_path, layer]
      }));
    }
    if (last_hint.layers?.includes(last_layer)) {
      return [{ layer_path: [...layer_path, last_layer] }];
    }
    return [];
  }
  if (!is_possibly_via) {
    if (current_hint.layers) {
      if (!current_hint.layers.includes(last_layer)) {
        return [];
      }
    }
    return findPossibleTraceLayerCombinations(
      hints.slice(1),
      layer_path.concat([last_layer])
    );
  }
  const candidate_next_layers = (current_hint.optional_via ? LAYER_SELECTION_PREFERENCE : LAYER_SELECTION_PREFERENCE.filter((layer) => layer !== last_layer)).filter(
    (layer) => !current_hint.layers || current_hint.layers?.includes(layer)
  );
  for (const candidate_next_layer of candidate_next_layers) {
    candidates.push(
      ...findPossibleTraceLayerCombinations(
        hints.slice(1),
        layer_path.concat(candidate_next_layer)
      )
    );
  }
  return candidates;
};

// lib/utils/autorouting/getDominantDirection.ts
function getDominantDirection(edge) {
  const delta = {
    x: edge.to.x - edge.from.x,
    y: edge.to.y - edge.from.y
  };
  const absX = Math.abs(delta.x);
  const absY = Math.abs(delta.y);
  if (absX > absY) {
    return delta.x > 0 ? "right" : "left";
  }
  return delta.y > 0 ? "down" : "up";
}

// lib/utils/autorouting/mergeRoutes.ts
function pdist(a, b) {
  return Math.hypot(a.x - b.x, a.y - b.y);
}
var mergeRoutes = (routes) => {
  if (routes.length === 1) return routes[0];
  if (routes.some((r) => r.length === 0)) {
    throw new Error("Cannot merge routes with zero length");
  }
  const merged = [];
  const first_route_fp = routes[0][0];
  const first_route_lp = routes[0][routes[0].length - 1];
  const second_route_fp = routes[1][0];
  const second_route_lp = routes[1][routes[1].length - 1];
  const best_reverse_dist = Math.min(
    pdist(first_route_fp, second_route_fp),
    pdist(first_route_fp, second_route_lp)
  );
  const best_normal_dist = Math.min(
    pdist(first_route_lp, second_route_fp),
    pdist(first_route_lp, second_route_lp)
  );
  if (best_reverse_dist < best_normal_dist) {
    merged.push(...routes[0].reverse());
  } else {
    merged.push(...routes[0]);
  }
  for (let i = 1; i < routes.length; i++) {
    const last_merged_point = merged[merged.length - 1];
    const next_route = routes[i];
    const next_first_point = next_route[0];
    const next_last_point = next_route[next_route.length - 1];
    const distance_to_first = pdist(last_merged_point, next_first_point);
    const distance_to_last = pdist(last_merged_point, next_last_point);
    if (distance_to_first < distance_to_last) {
      merged.push(...next_route);
    } else {
      merged.push(...next_route.reverse());
    }
  }
  for (let i = 1; i < merged.length - 1; i++) {
    const lastPoint = merged[i - 1];
    const currentPoint = merged[i];
    if (lastPoint.route_type !== "wire") continue;
    if (currentPoint.route_type !== "wire") continue;
    if (lastPoint.layer !== currentPoint.layer) {
      merged.splice(i, 0, {
        x: lastPoint.x,
        y: lastPoint.y,
        from_layer: lastPoint.layer,
        to_layer: currentPoint.layer,
        route_type: "via"
      });
    }
  }
  return merged;
};

// lib/utils/getClosest.ts
var getDistance = (a, b) => {
  const aPos = "_getGlobalPcbPositionBeforeLayout" in a ? a._getGlobalPcbPositionBeforeLayout() : a;
  const bPos = "_getGlobalPcbPositionBeforeLayout" in b ? b._getGlobalPcbPositionBeforeLayout() : b;
  return Math.sqrt((aPos.x - bPos.x) ** 2 + (aPos.y - bPos.y) ** 2);
};
function getClosest(point, candidates) {
  if (candidates.length === 0)
    throw new Error("No candidates given to getClosest method");
  let closest = candidates[0];
  let closestDist = Infinity;
  for (const candidate of candidates) {
    const dist = getDistance(point, candidate);
    if (dist < closestDist) {
      closest = candidate;
      closestDist = dist;
    }
  }
  return closest;
}

// lib/utils/schematic/countComplexElements.ts
var countComplexElements = (junctions, edges) => {
  let count = 0;
  count += junctions.length ?? 0;
  count += edges.filter((edge) => edge.is_crossing).length;
  for (let i = 1; i < edges.length; i++) {
    const prev = edges[i - 1];
    const curr = edges[i];
    const prevVertical = Math.abs(prev.from.x - prev.to.x) < 0.01;
    const currVertical = Math.abs(curr.from.x - curr.to.x) < 0.01;
    if (prevVertical !== currVertical) count++;
  }
  return count;
};

// lib/utils/schematic/getEnteringEdgeFromDirection.ts
var getEnteringEdgeFromDirection = (direction) => {
  return {
    up: "bottom",
    down: "top",
    left: "right",
    right: "left"
  }[direction] ?? null;
};

// lib/utils/schematic/getStubEdges.ts
import { distance } from "@tscircuit/math-utils";
var getStubEdges = ({
  firstEdge,
  firstEdgePort,
  firstDominantDirection,
  lastEdge,
  lastEdgePort,
  lastDominantDirection
}) => {
  if (firstEdge && firstEdgePort) {
    return getStubEdges({
      lastEdge: {
        from: firstEdge.to,
        to: firstEdge.from
      },
      lastEdgePort: firstEdgePort,
      lastDominantDirection: firstDominantDirection
    }).reverse().map((e) => ({
      from: e.to,
      to: e.from
    }));
  }
  let edges = [];
  if (lastEdge && lastEdgePort) {
    const intermediatePoint = { x: lastEdge.to.x, y: lastEdge.to.y };
    if (lastDominantDirection === "left" || lastDominantDirection === "right") {
      intermediatePoint.x = lastEdgePort.position.x;
      edges.push({
        from: lastEdge.to,
        to: { ...intermediatePoint }
      });
      edges.push({
        from: intermediatePoint,
        to: { ...lastEdgePort.position }
      });
    } else {
      intermediatePoint.y = lastEdgePort.position.y;
      edges.push({
        from: lastEdge.to,
        to: { ...intermediatePoint }
      });
      edges.push({
        from: intermediatePoint,
        to: { ...lastEdgePort.position }
      });
    }
  }
  edges = edges.filter((e) => distance(e.from, e.to) > 0.01);
  return edges;
};

// lib/utils/try-now.ts
function tryNow(fn) {
  try {
    return [fn(), null];
  } catch (e) {
    return [null, e];
  }
}

// lib/components/primitive-components/Trace/Trace.ts
import "zod";

// lib/components/primitive-components/Trace/trace-utils/get-max-length-from-connected-capacitors.ts
var getMaxLengthFromConnectedCapacitors = (ports, { db }) => {
  const capacitorMaxLengths = ports.map((port) => {
    const sourcePort = db.source_port.get(port.source_port_id);
    if (!sourcePort?.source_component_id) return null;
    const sourceComponent = db.source_component.get(
      sourcePort.source_component_id
    );
    if (sourceComponent?.ftype === "simple_capacitor") {
      return sourceComponent.max_decoupling_trace_length;
    }
    return null;
  }).filter((length2) => length2 !== null);
  if (capacitorMaxLengths.length === 0) return void 0;
  return Math.min(...capacitorMaxLengths);
};

// lib/components/primitive-components/Trace/trace-utils/get-trace-display-name.ts
function getTraceDisplayName({
  ports,
  nets
}) {
  if (ports.length >= 2) {
    return `${ports[0]?.selector} to ${ports[1]?.selector}`;
  }
  if (ports.length === 1 && nets.length === 1) {
    return `${ports[0]?.selector} to net.${nets[0]._parsedProps.name}`;
  }
  return void 0;
}

// lib/utils/is-route-outside-board.ts
var isRouteOutsideBoard = (mergedRoute, { db }) => {
  const pcbBoard = db.pcb_board.list()[0];
  if (pcbBoard.outline) {
    const boardOutline = pcbBoard.outline;
    const isInsidePolygon = (point, polygon) => {
      let inside = false;
      for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
        const xi = polygon[i].x, yi = polygon[i].y;
        const xj = polygon[j].x, yj = polygon[j].y;
        const intersect = yi > point.y !== yj > point.y && point.x < (xj - xi) * (point.y - yi) / (yj - yi) + xi;
        if (intersect) inside = !inside;
      }
      return inside;
    };
    return mergedRoute.some((point) => !isInsidePolygon(point, boardOutline));
  }
  const boardWidth = pcbBoard.width;
  const boardHeight = pcbBoard.height;
  const boardCenterX = pcbBoard.center.x;
  const boardCenterY = pcbBoard.center.y;
  const outsideBoard = mergedRoute.some((point) => {
    return point.x < boardCenterX - boardWidth / 2 || point.y < boardCenterY - boardHeight / 2 || point.x > boardCenterX + boardWidth / 2 || point.y > boardCenterY + boardHeight / 2;
  });
  return outsideBoard;
};

// lib/utils/obstacles/getObstaclesFromRoute.ts
var isCloseTo = (a, b) => Math.abs(a - b) < 1e-4;
var getObstaclesFromRoute = (route, source_trace_id, { viaDiameter = 0.5 } = {}) => {
  const obstacles = [];
  for (let i = 0; i < route.length - 1; i++) {
    const [start, end] = [route[i], route[i + 1]];
    const prev = i - 1 >= 0 ? route[i - 1] : null;
    const isHorz = isCloseTo(start.y, end.y);
    const isVert = isCloseTo(start.x, end.x);
    if (!isHorz && !isVert) {
      throw new Error(
        `getObstaclesFromTrace currently only supports horizontal and vertical traces (not diagonals) Conflicting trace: ${source_trace_id}, start: (${start.x}, ${start.y}), end: (${end.x}, ${end.y})`
      );
    }
    const obstacle = {
      type: "rect",
      layers: [start.layer],
      center: {
        x: (start.x + end.x) / 2,
        y: (start.y + end.y) / 2
      },
      width: isHorz ? Math.abs(start.x - end.x) : 0.1,
      // TODO use route width
      height: isVert ? Math.abs(start.y - end.y) : 0.1,
      // TODO use route width
      connectedTo: [source_trace_id]
    };
    obstacles.push(obstacle);
    if (prev && prev.layer === start.layer && start.layer !== end.layer) {
      const via = {
        type: "rect",
        layers: [start.layer, end.layer],
        center: {
          x: start.x,
          y: start.y
        },
        connectedTo: [source_trace_id],
        width: viaDiameter,
        height: viaDiameter
      };
      obstacles.push(via);
    }
  }
  return obstacles;
};

// lib/utils/obstacles/generateApproximatingRects.ts
function generateApproximatingRects(rotatedRect, numRects = 4) {
  const { center, width, height, rotation: rotation2 } = rotatedRect;
  const rects = [];
  const angleRad = rotation2 * Math.PI / 180;
  const cosAngle = Math.cos(angleRad);
  const sinAngle = Math.sin(angleRad);
  const normalizedRotation = (rotation2 % 360 + 360) % 360;
  const sliceAlongWidth = height <= width ? normalizedRotation >= 45 && normalizedRotation < 135 || normalizedRotation >= 225 && normalizedRotation < 315 : normalizedRotation >= 135 && normalizedRotation < 225 || normalizedRotation >= 315 || normalizedRotation < 45;
  if (sliceAlongWidth) {
    const sliceWidth = width / numRects;
    for (let i = 0; i < numRects; i++) {
      const x = (i - numRects / 2 + 0.5) * sliceWidth;
      const rotatedX = -x * cosAngle;
      const rotatedY = -x * sinAngle;
      const coverageWidth = sliceWidth * 1.1;
      const coverageHeight = Math.abs(height * cosAngle) + Math.abs(sliceWidth * sinAngle);
      rects.push({
        center: {
          x: center.x + rotatedX,
          y: center.y + rotatedY
        },
        width: coverageWidth,
        height: coverageHeight
      });
    }
  } else {
    const sliceHeight = height / numRects;
    for (let i = 0; i < numRects; i++) {
      const y = (i - numRects / 2 + 0.5) * sliceHeight;
      const rotatedX = -y * sinAngle;
      const rotatedY = y * cosAngle;
      const coverageWidth = Math.abs(width * cosAngle) + Math.abs(sliceHeight * sinAngle);
      const coverageHeight = sliceHeight * 1.1;
      rects.push({
        center: {
          x: center.x + rotatedX,
          y: center.y + rotatedY
        },
        width: coverageWidth,
        height: coverageHeight
      });
    }
  }
  return rects;
}

// lib/utils/obstacles/fillPolygonWithRects.ts
function fillPolygonWithRects(polygon, options = {}) {
  if (polygon.length < 3) return [];
  const { rectHeight = 0.1 } = options;
  const rects = [];
  const yCoords = polygon.map((p) => p.y);
  const minY = Math.min(...yCoords);
  const maxY = Math.max(...yCoords);
  for (let y = minY; y < maxY; y += rectHeight) {
    const scanlineY = y + rectHeight / 2;
    const intersections = [];
    for (let i = 0; i < polygon.length; i++) {
      const p1 = polygon[i];
      const p2 = polygon[(i + 1) % polygon.length];
      if (p1.y <= scanlineY && p2.y > scanlineY || p2.y <= scanlineY && p1.y > scanlineY) {
        const x = (scanlineY - p1.y) * (p2.x - p1.x) / (p2.y - p1.y) + p1.x;
        intersections.push(x);
      }
    }
    intersections.sort((a, b) => a - b);
    for (let i = 0; i < intersections.length; i += 2) {
      if (i + 1 < intersections.length) {
        const x1 = intersections[i];
        const x2 = intersections[i + 1];
        const width = x2 - x1;
        if (width > 1e-6) {
          rects.push({
            center: {
              x: x1 + width / 2,
              y: scanlineY
            },
            width,
            height: rectHeight
          });
        }
      }
    }
  }
  return rects;
}

// lib/utils/obstacles/fillCircleWithRects.ts
function fillCircleWithRects(circle, options = {}) {
  const { center, radius } = circle;
  const { rectHeight = 0.1 } = options;
  const rects = [];
  const numSlices = Math.ceil(radius * 2 / rectHeight);
  for (let i = 0; i < numSlices; i++) {
    const y = center.y - radius + (i + 0.5) * rectHeight;
    const dy = y - center.y;
    const halfWidth = Math.sqrt(radius * radius - dy * dy);
    if (halfWidth > 0) {
      rects.push({
        center: {
          x: center.x,
          y
        },
        width: halfWidth * 2,
        height: rectHeight
      });
    }
  }
  return rects;
}

// lib/utils/obstacles/getObstaclesFromCircuitJson.ts
var EVERY_LAYER = ["top", "inner1", "inner2", "bottom"];
var getObstaclesFromCircuitJson = (soup, connMap) => {
  const withNetId = (idList) => connMap ? idList.concat(
    idList.map((id) => connMap?.getNetConnectedToId(id)).filter(Boolean)
  ) : idList;
  const obstacles = [];
  for (const element of soup) {
    if (element.type === "pcb_smtpad") {
      if (element.shape === "circle") {
        obstacles.push({
          // @ts-ignore
          type: "oval",
          layers: [element.layer],
          center: {
            x: element.x,
            y: element.y
          },
          width: element.radius * 2,
          height: element.radius * 2,
          connectedTo: withNetId([element.pcb_smtpad_id])
        });
      } else if (element.shape === "rect") {
        obstacles.push({
          type: "rect",
          layers: [element.layer],
          center: {
            x: element.x,
            y: element.y
          },
          width: element.width,
          height: element.height,
          connectedTo: withNetId([element.pcb_smtpad_id])
        });
      } else if (element.shape === "rotated_rect") {
        const rotatedRect = {
          center: { x: element.x, y: element.y },
          width: element.width,
          height: element.height,
          rotation: element.ccw_rotation
        };
        const approximatingRects = generateApproximatingRects(rotatedRect);
        for (const rect of approximatingRects) {
          obstacles.push({
            type: "rect",
            layers: [element.layer],
            center: rect.center,
            width: rect.width,
            height: rect.height,
            connectedTo: withNetId([element.pcb_smtpad_id])
          });
        }
      }
    } else if (element.type === "pcb_keepout") {
      if (element.shape === "circle") {
        obstacles.push({
          // @ts-ignore
          type: "oval",
          layers: element.layers,
          center: {
            x: element.center.x,
            y: element.center.y
          },
          width: element.radius * 2,
          height: element.radius * 2,
          connectedTo: []
        });
      } else if (element.shape === "rect") {
        obstacles.push({
          type: "rect",
          layers: element.layers,
          center: {
            x: element.center.x,
            y: element.center.y
          },
          width: element.width,
          height: element.height,
          connectedTo: []
        });
      }
    } else if (element.type === "pcb_cutout") {
      if (element.shape === "rect") {
        obstacles.push({
          type: "rect",
          layers: EVERY_LAYER,
          center: {
            x: element.center.x,
            y: element.center.y
          },
          width: element.width,
          height: element.height,
          connectedTo: []
        });
      } else if (element.shape === "circle") {
        const approximatingRects = fillCircleWithRects(
          {
            center: element.center,
            radius: element.radius
          },
          { rectHeight: 0.6 }
        );
        for (const rect of approximatingRects) {
          obstacles.push({
            type: "rect",
            layers: EVERY_LAYER,
            center: rect.center,
            width: rect.width,
            height: rect.height,
            connectedTo: []
          });
        }
      } else if (element.shape === "polygon") {
        const approximatingRects = fillPolygonWithRects(element.points, {
          rectHeight: 0.6
        });
        for (const rect of approximatingRects) {
          obstacles.push({
            type: "rect",
            layers: EVERY_LAYER,
            center: rect.center,
            width: rect.width,
            height: rect.height,
            connectedTo: []
          });
        }
      }
    } else if (element.type === "pcb_hole") {
      if (element.hole_shape === "oval") {
        obstacles.push({
          // @ts-ignore
          type: "oval",
          center: {
            x: element.x,
            y: element.y
          },
          width: element.hole_width,
          height: element.hole_height,
          connectedTo: []
        });
      } else if (element.hole_shape === "square") {
        obstacles.push({
          type: "rect",
          layers: EVERY_LAYER,
          center: {
            x: element.x,
            y: element.y
          },
          width: element.hole_diameter,
          height: element.hole_diameter,
          connectedTo: []
        });
      } else if (
        // @ts-ignore
        element.hole_shape === "round" || element.hole_shape === "circle"
      ) {
        obstacles.push({
          type: "rect",
          layers: EVERY_LAYER,
          center: {
            x: element.x,
            y: element.y
          },
          width: element.hole_diameter,
          height: element.hole_diameter,
          connectedTo: []
        });
      }
    } else if (element.type === "pcb_plated_hole") {
      if (element.shape === "circle") {
        obstacles.push({
          // @ts-ignore
          type: "oval",
          layers: EVERY_LAYER,
          center: {
            x: element.x,
            y: element.y
          },
          width: element.outer_diameter,
          height: element.outer_diameter,
          connectedTo: withNetId([element.pcb_plated_hole_id])
        });
      } else if (element.shape === "circular_hole_with_rect_pad") {
        obstacles.push({
          // @ts-ignore
          type: "rect",
          layers: EVERY_LAYER,
          center: {
            x: element.x,
            y: element.y
          },
          width: element.rect_pad_width,
          height: element.rect_pad_height,
          connectedTo: withNetId([element.pcb_plated_hole_id])
        });
      } else if (element.shape === "oval" || element.shape === "pill") {
        obstacles.push({
          // @ts-ignore
          type: "oval",
          layers: EVERY_LAYER,
          center: {
            x: element.x,
            y: element.y
          },
          width: element.outer_width,
          height: element.outer_height,
          connectedTo: withNetId([element.pcb_plated_hole_id])
        });
      }
    } else if (element.type === "pcb_trace") {
      const traceObstacles = getObstaclesFromRoute(
        element.route.map((rp) => ({
          x: rp.x,
          y: rp.y,
          layer: "layer" in rp ? rp.layer : rp.from_layer
        })),
        element.source_trace_id
      );
      obstacles.push(...traceObstacles);
    } else if (element.type === "pcb_via") {
      obstacles.push({
        type: "rect",
        layers: element.layers,
        center: {
          x: element.x,
          y: element.y
        },
        connectedTo: [],
        // TODO we can associate source_ports with this via
        width: element.outer_diameter,
        height: element.outer_diameter
      });
    }
  }
  return obstacles;
};

// lib/utils/schematic/computeSchematicNetLabelCenter.ts
var computeSchematicNetLabelCenter = ({
  anchor_position,
  anchor_side,
  text,
  font_size = 0.18
}) => {
  const charWidth = 0.1 * (font_size / 0.18);
  const width = text.length * charWidth;
  const height = font_size;
  const center = { ...anchor_position };
  switch (anchor_side) {
    case "right":
      center.x -= width / 2;
      break;
    case "left":
      center.x += width / 2;
      break;
    case "top":
      center.y -= height / 2;
      break;
    case "bottom":
      center.y += height / 2;
      break;
  }
  return center;
};

// lib/components/primitive-components/Trace/Trace_doInitialSchematicTraceRender.ts
import { MultilayerIjump } from "@tscircuit/infgrid-ijump-astar";
import "circuit-json";
import { calculateElbow } from "calculate-elbow";
import { doesLineIntersectLine as doesLineIntersectLine3 } from "@tscircuit/math-utils";

// lib/components/primitive-components/Trace/trace-utils/create-schematic-trace-crossing-segments.ts
import { distance as distance2, doesLineIntersectLine } from "@tscircuit/math-utils";

// lib/components/primitive-components/Trace/trace-utils/get-other-schematic-traces.ts
var getOtherSchematicTraces = ({
  db,
  source_trace_id,
  sameNetOnly,
  differentNetOnly
}) => {
  if (!sameNetOnly && !differentNetOnly) {
    differentNetOnly = true;
  }
  const mySourceTrace = db.source_trace.get(source_trace_id);
  const traces = [];
  for (const otherSchematicTrace of db.schematic_trace.list()) {
    if (otherSchematicTrace.source_trace_id === source_trace_id) continue;
    const otherSourceTrace = db.source_trace.get(
      otherSchematicTrace.source_trace_id
    );
    const isSameNet = otherSourceTrace?.subcircuit_connectivity_map_key === mySourceTrace.subcircuit_connectivity_map_key;
    if (differentNetOnly && isSameNet) {
      continue;
    }
    if (sameNetOnly && !isSameNet) {
      continue;
    }
    traces.push(otherSchematicTrace);
  }
  return traces;
};

// lib/components/primitive-components/Trace/trace-utils/create-schematic-trace-crossing-segments.ts
import { getUnitVectorFromPointAToB } from "@tscircuit/math-utils";
var createSchematicTraceCrossingSegments = ({
  edges: inputEdges,
  otherEdges
}) => {
  const edges = [...inputEdges];
  for (let i = 0; i < edges.length; i++) {
    if (i > 2e3) {
      throw new Error(
        "Over 2000 iterations spent inside createSchematicTraceCrossingSegments, you have triggered an infinite loop, please report this!"
      );
    }
    const edge = edges[i];
    const edgeOrientation = Math.abs(edge.from.x - edge.to.x) < 0.01 ? "vertical" : edge.from.y === edge.to.y ? "horizontal" : "not-orthogonal";
    if (edgeOrientation === "not-orthogonal") {
      continue;
    }
    const otherEdgesIntersections = [];
    for (const otherEdge of otherEdges) {
      const otherOrientation = otherEdge.from.x === otherEdge.to.x ? "vertical" : otherEdge.from.y === otherEdge.to.y ? "horizontal" : "not-orthogonal";
      if (otherOrientation === "not-orthogonal") continue;
      if (edgeOrientation === otherOrientation)
        continue;
      const hasIntersection = doesLineIntersectLine(
        [edge.from, edge.to],
        [otherEdge.from, otherEdge.to],
        { lineThickness: 0.01 }
      );
      if (hasIntersection) {
        const intersectX = edgeOrientation === "vertical" ? edge.from.x : otherEdge.from.x;
        const intersectY = edgeOrientation === "vertical" ? otherEdge.from.y : edge.from.y;
        const crossingPoint2 = { x: intersectX, y: intersectY };
        otherEdgesIntersections.push({
          otherEdge,
          crossingPoint: crossingPoint2,
          distanceFromEdgeFrom: distance2(edge.from, crossingPoint2)
        });
      }
    }
    if (otherEdgesIntersections.length === 0) continue;
    let closestIntersection = otherEdgesIntersections[0];
    for (const intersection of otherEdgesIntersections) {
      if (intersection.distanceFromEdgeFrom < closestIntersection.distanceFromEdgeFrom) {
        closestIntersection = intersection;
      }
    }
    const crossingPoint = closestIntersection.crossingPoint;
    const crossingSegmentLength = 0.075;
    if (crossingPoint.x === edge.from.x && crossingPoint.y === edge.from.y) {
      continue;
    }
    const crossingUnitVec = getUnitVectorFromPointAToB(edge.from, crossingPoint);
    const beforeCrossing = {
      x: crossingPoint.x - crossingUnitVec.x * crossingSegmentLength / 2,
      y: crossingPoint.y - crossingUnitVec.y * crossingSegmentLength / 2
    };
    const afterCrossing = {
      x: crossingPoint.x + crossingUnitVec.x * crossingSegmentLength / 2,
      y: crossingPoint.y + crossingUnitVec.y * crossingSegmentLength / 2
    };
    const overshot = distance2(afterCrossing, edge.to) < crossingSegmentLength;
    const newEdges = [
      { from: edge.from, to: beforeCrossing },
      { from: beforeCrossing, to: afterCrossing, is_crossing: true },
      { from: afterCrossing, to: edge.to }
    ];
    edges.splice(i, 1, ...newEdges);
    i += newEdges.length - 2;
    if (overshot) {
      i++;
    }
  }
  return edges;
};

// lib/components/primitive-components/Trace/trace-utils/create-schematic-trace-junctions.ts
var TOLERANCE = 1e-3;
var isPointWithinEdge = (point, edge) => {
  const minX = Math.min(edge.from.x, edge.to.x);
  const maxX = Math.max(edge.from.x, edge.to.x);
  const minY = Math.min(edge.from.y, edge.to.y);
  const maxY = Math.max(edge.from.y, edge.to.y);
  return point.x >= minX && point.x <= maxX && point.y >= minY && point.y <= maxY;
};
var getEdgeOrientation = (edge) => {
  const isVertical = Math.abs(edge.from.x - edge.to.x) < TOLERANCE;
  const isHorizontal = Math.abs(edge.from.y - edge.to.y) < TOLERANCE;
  if (isVertical) return "vertical";
  if (isHorizontal) return "horizontal";
  return "diagonal";
};
var getIntersectionPoint = (edge1, edge2) => {
  const orientation1 = getEdgeOrientation(edge1);
  const orientation2 = getEdgeOrientation(edge2);
  if (orientation1 === orientation2) {
    return null;
  }
  if (orientation1 === "vertical" && orientation2 === "horizontal" || orientation1 === "horizontal" && orientation2 === "vertical") {
    const verticalEdge = orientation1 === "vertical" ? edge1 : edge2;
    const horizontalEdge = orientation1 === "horizontal" ? edge1 : edge2;
    const x2 = verticalEdge.from.x;
    const y2 = horizontalEdge.from.y;
    const intersection2 = { x: x2, y: y2 };
    return isPointWithinEdge(intersection2, edge1) && isPointWithinEdge(intersection2, edge2) ? intersection2 : null;
  }
  if (orientation1 === "vertical" || orientation2 === "vertical") {
    const verticalEdge = orientation1 === "vertical" ? edge1 : edge2;
    const diagonalEdge = orientation1 === "vertical" ? edge2 : edge1;
    const x2 = verticalEdge.from.x;
    const m = (diagonalEdge.to.y - diagonalEdge.from.y) / (diagonalEdge.to.x - diagonalEdge.from.x);
    const b = diagonalEdge.from.y - m * diagonalEdge.from.x;
    const y2 = m * x2 + b;
    const intersection2 = { x: x2, y: y2 };
    return isPointWithinEdge(intersection2, edge1) && isPointWithinEdge(intersection2, edge2) ? intersection2 : null;
  }
  const m1 = (edge1.to.y - edge1.from.y) / (edge1.to.x - edge1.from.x);
  const b1 = edge1.from.y - m1 * edge1.from.x;
  const m2 = (edge2.to.y - edge2.from.y) / (edge2.to.x - edge2.from.x);
  const b2 = edge2.from.y - m2 * edge2.from.x;
  if (Math.abs(m1 - m2) < TOLERANCE) {
    return null;
  }
  const x = (b2 - b1) / (m1 - m2);
  const y = m1 * x + b1;
  const intersection = { x, y };
  return isPointWithinEdge(intersection, edge1) && isPointWithinEdge(intersection, edge2) ? intersection : null;
};
var createSchematicTraceJunctions = ({
  edges: myEdges,
  db,
  source_trace_id
}) => {
  const otherEdges = getOtherSchematicTraces({
    db,
    source_trace_id,
    sameNetOnly: true
  }).flatMap((t) => t.edges);
  const junctions = /* @__PURE__ */ new Map();
  for (const myEdge of myEdges) {
    for (const otherEdge of otherEdges) {
      const intersection = getIntersectionPoint(myEdge, otherEdge);
      if (intersection) {
        const key = `${intersection.x.toFixed(6)},${intersection.y.toFixed(6)}`;
        if (!junctions.has(key)) {
          junctions.set(key, intersection);
        }
      }
    }
  }
  return Array.from(junctions.values());
};

// lib/components/primitive-components/Trace/trace-utils/get-obstacles-for-trace.ts
import { getUnitVectorFromDirection } from "@tscircuit/math-utils";

// lib/utils/autorouting/getBoundsForSchematic.ts
function getBoundsForSchematic(db) {
  let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
  for (const elm of db) {
    let cx, cy, w, h;
    if (elm.type === "schematic_component") {
      cx = elm.center?.x;
      cy = elm.center?.y;
      w = elm.size?.width;
      h = elm.size?.height;
    } else if (elm.type === "schematic_box") {
      cx = elm.x;
      cy = elm.y;
      w = elm.width;
      h = elm.height;
    } else if (elm.type === "schematic_port") {
      cx = elm.center?.x;
      cy = elm.center?.y;
      w = 0.2;
      h = 0.2;
    } else if (elm.type === "schematic_text") {
      cx = elm.position?.x;
      cy = elm.position?.y;
      w = (elm.text?.length ?? 0) * 0.1;
      h = 0.2;
    }
    if (typeof cx === "number" && typeof cy === "number" && typeof w === "number" && typeof h === "number") {
      minX = Math.min(minX, cx - w / 2);
      maxX = Math.max(maxX, cx + w / 2);
      minY = Math.min(minY, cy - h / 2);
      maxY = Math.max(maxY, cy + h / 2);
    }
  }
  return { minX, maxX, minY, maxY };
}

// lib/utils/autorouting/getObstaclesFromBounds.ts
function getObstaclesFromBounds(bounds, opts = {}) {
  const { minX, maxX, minY, maxY } = bounds;
  const PADDING = opts.padding ?? 1;
  if (!isFinite(minX) || !isFinite(maxX) || !isFinite(minY) || !isFinite(maxY))
    return [];
  const left = minX - PADDING;
  const right = maxX + PADDING;
  const top = maxY + PADDING;
  const bottom = minY - PADDING;
  const thickness = 0.01;
  return [
    // Top border (horizontal)
    {
      type: "rect",
      layers: ["top"],
      center: { x: (left + right) / 2, y: top },
      width: right - left,
      height: thickness,
      connectedTo: []
    },
    // Bottom border (horizontal)
    {
      type: "rect",
      layers: ["top"],
      center: { x: (left + right) / 2, y: bottom },
      width: right - left,
      height: thickness,
      connectedTo: []
    },
    // Left border (vertical)
    {
      type: "rect",
      layers: ["top"],
      center: { x: left, y: (top + bottom) / 2 },
      width: thickness,
      height: top - bottom,
      connectedTo: []
    },
    // Right border (vertical)
    {
      type: "rect",
      layers: ["top"],
      center: { x: right, y: (top + bottom) / 2 },
      width: thickness,
      height: top - bottom,
      connectedTo: []
    }
  ];
}

// lib/components/primitive-components/Trace/trace-utils/get-obstacles-for-trace.ts
var getSchematicObstaclesForTrace = (trace) => {
  const db = trace.root.db;
  const connectedPorts = trace._findConnectedPorts().ports ?? [];
  const connectedPortIds = new Set(
    connectedPorts.map((p) => p.schematic_port_id)
  );
  const obstacles = [];
  for (const elm of db.toArray()) {
    if (elm.type === "schematic_component") {
      const isSymbol = Boolean(elm.symbol_name);
      const dominateAxis = elm.size.width > elm.size.height ? "horz" : "vert";
      obstacles.push({
        type: "rect",
        layers: ["top"],
        center: elm.center,
        width: elm.size.width + (isSymbol && dominateAxis === "horz" ? -0.5 : 0),
        height: elm.size.height + (isSymbol && dominateAxis === "vert" ? -0.5 : 0),
        connectedTo: []
      });
    }
    if (elm.type === "schematic_port") {
      if (connectedPortIds.has(elm.schematic_port_id)) {
        continue;
      }
      const dirVec = elm.facing_direction ? getUnitVectorFromDirection(elm.facing_direction) : {
        x: 0,
        y: 0
      };
      obstacles.push({
        type: "rect",
        layers: ["top"],
        center: {
          x: elm.center.x - dirVec.x * 0.1,
          y: elm.center.y - dirVec.y * 0.1
        },
        width: 0.1 + Math.abs(dirVec.x) * 0.3,
        height: 0.1 + Math.abs(dirVec.y) * 0.3,
        connectedTo: []
      });
    }
    if (elm.type === "schematic_text") {
      obstacles.push({
        type: "rect",
        layers: ["top"],
        center: elm.position,
        width: (elm.text?.length ?? 0) * 0.1,
        height: 0.2,
        connectedTo: []
      });
    }
    if (elm.type === "schematic_box") {
      obstacles.push({
        type: "rect",
        layers: ["top"],
        center: { x: elm.x, y: elm.y },
        width: elm.width,
        height: elm.height,
        connectedTo: []
      });
    }
  }
  const bounds = getBoundsForSchematic(db.toArray());
  obstacles.push(...getObstaclesFromBounds(bounds, { padding: 1 }));
  return obstacles;
};

// lib/components/primitive-components/Trace/trace-utils/push-edges-of-schematic-trace-to-prevent-overlap.ts
import { doesLineIntersectLine as doesLineIntersectLine2 } from "@tscircuit/math-utils";
var pushEdgesOfSchematicTraceToPreventOverlap = ({
  edges,
  db,
  source_trace_id
}) => {
  const mySourceTrace = db.source_trace.get(source_trace_id);
  const otherEdges = getOtherSchematicTraces({
    db,
    source_trace_id,
    differentNetOnly: true
  }).flatMap((t) => t.edges);
  const edgeOrientation = (edge) => {
    const { from, to } = edge;
    return from.x === to.x ? "vertical" : "horizontal";
  };
  for (const mySegment of edges) {
    const mySegmentOrientation = edgeOrientation(mySegment);
    const findOverlappingParallelSegment = () => otherEdges.find(
      (otherEdge) => edgeOrientation(otherEdge) === mySegmentOrientation && doesLineIntersectLine2(
        [mySegment.from, mySegment.to],
        [otherEdge.from, otherEdge.to],
        {
          lineThickness: 0.05
        }
      )
    );
    let overlappingParallelSegmentFromOtherTrace = findOverlappingParallelSegment();
    while (overlappingParallelSegmentFromOtherTrace) {
      if (mySegmentOrientation === "horizontal") {
        mySegment.from.y += 0.1;
        mySegment.to.y += 0.1;
      } else {
        mySegment.from.x += 0.1;
        mySegment.to.x += 0.1;
      }
      overlappingParallelSegmentFromOtherTrace = findOverlappingParallelSegment();
    }
  }
};

// lib/utils/schematic/convertFacingDirectionToElbowDirection.ts
var convertFacingDirectionToElbowDirection = (facingDirection) => {
  switch (facingDirection) {
    case "up":
      return "y+";
    case "down":
      return "y-";
    case "left":
      return "x-";
    case "right":
      return "x+";
    default:
  }
};

// lib/components/primitive-components/Trace/Trace_doInitialSchematicTraceRender.ts
var Trace_doInitialSchematicTraceRender = (trace) => {
  if (trace.root?.schematicDisabled) return;
  const { db } = trace.root;
  const { _parsedProps: props, parent } = trace;
  if (!parent) throw new Error("Trace has no parent");
  const { allPortsFound, portsWithSelectors: connectedPorts } = trace._findConnectedPorts();
  const { netsWithSelectors } = trace._findConnectedNets();
  if (!allPortsFound) return;
  const portIds = connectedPorts.map((p) => p.port.schematic_port_id).sort();
  const portPairKey = portIds.join(",");
  const board = trace.root?._getBoard();
  if (board?._connectedSchematicPortPairs) {
    if (board._connectedSchematicPortPairs.has(portPairKey)) {
      return;
    }
  }
  const connection = {
    name: trace.source_trace_id,
    pointsToConnect: []
  };
  const obstacles = getSchematicObstaclesForTrace(trace);
  const portsWithPosition = connectedPorts.map(({ port }) => ({
    port,
    position: port._getGlobalSchematicPositionAfterLayout(),
    schematic_port_id: port.schematic_port_id ?? void 0,
    facingDirection: port.facingDirection
  }));
  const isPortAndNetConnection = portsWithPosition.length === 1 && netsWithSelectors.length === 1;
  if (isPortAndNetConnection) {
    const net = netsWithSelectors[0].net;
    const { port, position: anchorPos } = portsWithPosition[0];
    let connectedNetLabel = trace.getSubcircuit().selectAll("netlabel").find((nl) => {
      const conn = nl._parsedProps.connection ?? nl._parsedProps.connectsTo;
      if (!conn) return false;
      if (Array.isArray(conn)) {
        return conn.some((selector) => {
          const targetPort2 = trace.getSubcircuit().selectOne(selector, {
            port: true
          });
          return targetPort2 === port;
        });
      }
      const targetPort = trace.getSubcircuit().selectOne(conn, {
        port: true
      });
      return targetPort === port;
    });
    if (!connectedNetLabel) {
      const dbNetLabel = db.schematic_net_label.getWhere({
        source_trace_id: trace.source_trace_id
      });
      if (dbNetLabel) {
        connectedNetLabel = dbNetLabel;
      }
    }
    if (connectedNetLabel) {
      const labelPos = "_getGlobalSchematicPositionBeforeLayout" in connectedNetLabel ? connectedNetLabel._getGlobalSchematicPositionBeforeLayout() : connectedNetLabel.anchor_position;
      const edges2 = [];
      if (anchorPos.x === labelPos.x || anchorPos.y === labelPos.y) {
        edges2.push({ from: anchorPos, to: labelPos });
      } else {
        edges2.push({ from: anchorPos, to: { x: labelPos.x, y: anchorPos.y } });
        edges2.push({ from: { x: labelPos.x, y: anchorPos.y }, to: labelPos });
      }
      const dbTrace2 = db.schematic_trace.insert({
        source_trace_id: trace.source_trace_id,
        edges: edges2,
        junctions: []
      });
      trace.schematic_trace_id = dbTrace2.schematic_trace_id;
      return;
    }
    if (trace.props.schDisplayLabel) {
      const side2 = getEnteringEdgeFromDirection(port.facingDirection) ?? "bottom";
      db.schematic_net_label.insert({
        text: trace.props.schDisplayLabel,
        source_net_id: net.source_net_id,
        anchor_position: anchorPos,
        center: computeSchematicNetLabelCenter({
          anchor_position: anchorPos,
          anchor_side: side2,
          text: trace.props.schDisplayLabel
        }),
        anchor_side: side2
      });
      return;
    }
    const side = getEnteringEdgeFromDirection(port.facingDirection) ?? "bottom";
    const netLabel = db.schematic_net_label.insert({
      text: net._parsedProps.name,
      source_net_id: net.source_net_id,
      anchor_position: anchorPos,
      center: computeSchematicNetLabelCenter({
        anchor_position: anchorPos,
        anchor_side: side,
        text: net._parsedProps.name
      }),
      anchor_side: side
    });
    return;
  }
  if (trace.props.schDisplayLabel) {
    if ("from" in trace.props && "to" in trace.props || "path" in trace.props) {
      trace._doInitialSchematicTraceRenderWithDisplayLabel();
      return;
    }
  }
  if (portsWithPosition.length < 2) {
    return;
  }
  const attemptElbowEdges = () => {
    const elbowEdges = [];
    for (let i = 0; i < portsWithPosition.length - 1; i++) {
      const start = portsWithPosition[i];
      const end = portsWithPosition[i + 1];
      const path = calculateElbow(
        {
          x: start.position.x,
          y: start.position.y,
          facingDirection: convertFacingDirectionToElbowDirection(
            start.facingDirection
          )
        },
        {
          x: end.position.x,
          y: end.position.y,
          facingDirection: convertFacingDirectionToElbowDirection(
            end.facingDirection
          )
        }
      );
      for (let j = 0; j < path.length - 1; j++) {
        elbowEdges.push({ from: path[j], to: path[j + 1] });
      }
    }
    const doesSegmentIntersectRect = (edge, rect) => {
      const halfW = rect.width / 2;
      const halfH = rect.height / 2;
      const left = rect.center.x - halfW;
      const right = rect.center.x + halfW;
      const top = rect.center.y - halfH;
      const bottom = rect.center.y + halfH;
      const inRect = (p) => p.x >= left && p.x <= right && p.y >= top && p.y <= bottom;
      if (inRect(edge.from) || inRect(edge.to)) return true;
      const rectEdges = [
        [
          { x: left, y: top },
          { x: right, y: top }
        ],
        [
          { x: right, y: top },
          { x: right, y: bottom }
        ],
        [
          { x: right, y: bottom },
          { x: left, y: bottom }
        ],
        [
          { x: left, y: bottom },
          { x: left, y: top }
        ]
      ];
      return rectEdges.some(
        (r) => doesLineIntersectLine3([edge.from, edge.to], r, { lineThickness: 0 })
      );
    };
    for (const edge of elbowEdges) {
      for (const obstacle of obstacles) {
        if (doesSegmentIntersectRect(edge, obstacle)) {
          return null;
        }
      }
    }
    return elbowEdges;
  };
  let edges = attemptElbowEdges();
  if (edges && edges.length === 0) {
    edges = null;
  }
  connection.pointsToConnect = portsWithPosition.map(({ position }) => ({
    ...position,
    layer: "top"
  }));
  const bounds = computeObstacleBounds(obstacles);
  const BOUNDS_MARGIN = 2;
  const simpleRouteJsonInput = {
    minTraceWidth: 0.1,
    obstacles,
    connections: [connection],
    bounds: {
      minX: bounds.minX - BOUNDS_MARGIN,
      maxX: bounds.maxX + BOUNDS_MARGIN,
      minY: bounds.minY - BOUNDS_MARGIN,
      maxY: bounds.maxY + BOUNDS_MARGIN
    },
    layerCount: 1
  };
  let Autorouter = MultilayerIjump;
  let skipOtherTraceInteraction = false;
  if (trace.getSubcircuit().props._schDirectLineRoutingEnabled) {
    Autorouter = DirectLineRouter;
    skipOtherTraceInteraction = true;
  }
  if (!edges) {
    const autorouter = new Autorouter({
      input: simpleRouteJsonInput,
      MAX_ITERATIONS: 100,
      OBSTACLE_MARGIN: 0.1,
      isRemovePathLoopsEnabled: true,
      isShortenPathWithShortcutsEnabled: true,
      marginsWithCosts: [
        {
          margin: 1,
          enterCost: 0,
          travelCostFactor: 1
        },
        {
          margin: 0.3,
          enterCost: 0,
          travelCostFactor: 1
        },
        {
          margin: 0.2,
          enterCost: 0,
          travelCostFactor: 2
        },
        {
          margin: 0.1,
          enterCost: 0,
          travelCostFactor: 3
        }
      ]
    });
    let results = autorouter.solveAndMapToTraces();
    if (results.length === 0) {
      if (trace._isSymbolToChipConnection() || trace._isSymbolToSymbolConnection() || trace._isChipToChipConnection()) {
        trace._doInitialSchematicTraceRenderWithDisplayLabel();
        return;
      }
      const directLineRouter = new DirectLineRouter({
        input: simpleRouteJsonInput
      });
      results = directLineRouter.solveAndMapToTraces();
      skipOtherTraceInteraction = true;
    }
    const [{ route }] = results;
    edges = [];
    for (let i = 0; i < route.length - 1; i++) {
      edges.push({
        from: route[i],
        to: route[i + 1]
      });
    }
  }
  const source_trace_id = trace.source_trace_id;
  let junctions = [];
  if (!skipOtherTraceInteraction) {
    pushEdgesOfSchematicTraceToPreventOverlap({ edges, db, source_trace_id });
    const otherEdges = getOtherSchematicTraces({
      db,
      source_trace_id,
      differentNetOnly: true
    }).flatMap((t) => t.edges);
    edges = createSchematicTraceCrossingSegments({ edges, otherEdges });
    junctions = createSchematicTraceJunctions({
      edges,
      db,
      source_trace_id: trace.source_trace_id
    });
  }
  if (!edges || edges.length === 0) {
    return;
  }
  const lastEdge = edges[edges.length - 1];
  const lastEdgePort = portsWithPosition[portsWithPosition.length - 1];
  const lastDominantDirection = getDominantDirection(lastEdge);
  edges.push(...getStubEdges({ lastEdge, lastEdgePort, lastDominantDirection }));
  const firstEdge = edges[0];
  const firstEdgePort = portsWithPosition[0];
  const firstDominantDirection = getDominantDirection(firstEdge);
  edges.unshift(
    ...getStubEdges({
      firstEdge,
      firstEdgePort,
      firstDominantDirection
    })
  );
  if (!trace.source_trace_id) {
    throw new Error("Missing source_trace_id for schematic trace insertion.");
  }
  if (trace.getSubcircuit()._parsedProps.schTraceAutoLabelEnabled && countComplexElements(junctions, edges) >= 5 && (trace._isSymbolToChipConnection() || trace._isSymbolToSymbolConnection() || trace._isChipToChipConnection())) {
    trace._doInitialSchematicTraceRenderWithDisplayLabel();
    return;
  }
  const dbTrace = db.schematic_trace.insert({
    source_trace_id: trace.source_trace_id,
    edges,
    junctions
  });
  trace.schematic_trace_id = dbTrace.schematic_trace_id;
  for (const { port } of connectedPorts) {
    if (port.schematic_port_id) {
      db.schematic_port.update(port.schematic_port_id, { is_connected: true });
    }
  }
  if (board?._connectedSchematicPortPairs)
    board._connectedSchematicPortPairs.add(portPairKey);
};

// lib/components/primitive-components/Trace/Trace_doInitialPcbTraceRender.ts
import { MultilayerIjump as MultilayerIjump2 } from "@tscircuit/infgrid-ijump-astar";
import "circuit-json";
import { getFullConnectivityMapFromCircuitJson } from "circuit-json-to-connectivity-map";

// lib/components/primitive-components/Trace/trace-utils/compute-trace-length.ts
function getTraceLength(route) {
  let totalLength = 0;
  for (let i = 0; i < route.length; i++) {
    const point = route[i];
    if (point.route_type === "wire") {
      const nextPoint = route[i + 1];
      if (nextPoint) {
        const dx = nextPoint.x - point.x;
        const dy = nextPoint.y - point.y;
        totalLength += Math.sqrt(dx * dx + dy * dy);
      }
    } else if (point.route_type === "via") {
      totalLength += 1.6;
    }
  }
  return totalLength;
}

// lib/components/primitive-components/Trace/Trace_doInitialPcbTraceRender.ts
var portToObjective = (port) => {
  const portPosition = port._getGlobalPcbPositionAfterLayout();
  return {
    ...portPosition,
    layers: port.getAvailablePcbLayers()
  };
};
var SHOULD_USE_SINGLE_LAYER_ROUTING = false;
function Trace_doInitialPcbTraceRender(trace) {
  if (trace.root?.pcbDisabled) return;
  const { db } = trace.root;
  const { _parsedProps: props, parent } = trace;
  const subcircuit = trace.getSubcircuit();
  if (!parent) throw new Error("Trace has no parent");
  if (subcircuit._parsedProps.routingDisabled) {
    return;
  }
  const cachedRoute = subcircuit._parsedProps.pcbRouteCache?.pcbTraces;
  if (cachedRoute) {
    const pcb_trace2 = db.pcb_trace.insert({
      route: cachedRoute.flatMap((trace2) => trace2.route),
      source_trace_id: trace.source_trace_id,
      subcircuit_id: subcircuit?.subcircuit_id ?? void 0,
      pcb_group_id: trace.getGroup()?.pcb_group_id ?? void 0
    });
    trace.pcb_trace_id = pcb_trace2.pcb_trace_id;
    return;
  }
  if (!subcircuit._shouldUseTraceByTraceRouting()) {
    return;
  }
  const { allPortsFound, ports } = trace._findConnectedPorts();
  const portsConnectedOnPcbViaNet = [];
  if (!allPortsFound) return;
  const portsWithoutMatchedPcbPrimitive = [];
  for (const port of ports) {
    if (!port._hasMatchedPcbPrimitive()) {
      portsWithoutMatchedPcbPrimitive.push(port);
    }
  }
  if (portsWithoutMatchedPcbPrimitive.length > 0) {
    db.pcb_trace_error.insert({
      error_type: "pcb_trace_error",
      source_trace_id: trace.source_trace_id,
      message: `Some ports did not have a matching PCB primitive (e.g. a pad or plated hole), this can happen if a footprint is missing. As a result, ${trace} wasn't routed. Missing ports: ${portsWithoutMatchedPcbPrimitive.map((p) => p.getString()).join(", ")}`,
      pcb_trace_id: trace.pcb_trace_id,
      pcb_component_ids: [],
      pcb_port_ids: portsWithoutMatchedPcbPrimitive.map((p) => p.pcb_port_id).filter(Boolean)
    });
    return;
  }
  const nets = trace._findConnectedNets().netsWithSelectors;
  if (ports.length === 0 && nets.length === 2) {
    trace.renderError(
      `Trace connects two nets, we haven't implemented a way to route this yet`
    );
    return;
  } else if (ports.length === 1 && nets.length === 1) {
    const port = ports[0];
    const portsInNet = nets[0].net.getAllConnectedPorts();
    const otherPortsInNet = portsInNet.filter((p) => p !== port);
    if (otherPortsInNet.length === 0) {
      console.log(
        "Nothing to connect this port to, the net is empty. TODO should emit a warning!"
      );
      return;
    }
    const closestPortInNet = getClosest(port, otherPortsInNet);
    portsConnectedOnPcbViaNet.push(closestPortInNet);
    ports.push(closestPortInNet);
  } else if (ports.length > 1 && nets.length >= 1) {
    trace.renderError(
      `Trace has more than one port and one or more nets, we don't currently support this type of complex trace routing`
    );
    return;
  }
  const hints = ports.flatMap(
    (port) => port.matchedComponents.filter((c) => c.componentName === "TraceHint")
  );
  const pcbRouteHints = (trace._parsedProps.pcbRouteHints ?? []).concat(
    hints.flatMap((h) => h.getPcbRouteHints())
  );
  if (ports.length > 2) {
    trace.renderError(
      `Trace has more than two ports (${ports.map((p) => p.getString()).join(
        ", "
      )}), routing between more than two ports for a single trace is not implemented`
    );
    return;
  }
  const alreadyRoutedTraces = trace.getSubcircuit().selectAll("trace").filter(
    (trace2) => trace2.renderPhaseStates.PcbTraceRender.initialized
  );
  const isAlreadyRouted = alreadyRoutedTraces.some(
    (trace2) => trace2._portsRoutedOnPcb.length === ports.length && trace2._portsRoutedOnPcb.every(
      (portRoutedByOtherTrace) => ports.includes(portRoutedByOtherTrace)
    )
  );
  if (isAlreadyRouted) {
    return;
  }
  let orderedRouteObjectives = [];
  if (pcbRouteHints.length === 0) {
    orderedRouteObjectives = [
      portToObjective(ports[0]),
      portToObjective(ports[1])
    ];
  } else {
    orderedRouteObjectives = [
      portToObjective(ports[0]),
      ...pcbRouteHints,
      portToObjective(ports[1])
    ];
  }
  const candidateLayerCombinations = findPossibleTraceLayerCombinations(
    orderedRouteObjectives
  );
  if (SHOULD_USE_SINGLE_LAYER_ROUTING && candidateLayerCombinations.length === 0) {
    trace.renderError(
      `Could not find a common layer (using hints) for trace ${trace.getString()}`
    );
    return;
  }
  const connMap = getFullConnectivityMapFromCircuitJson(
    trace.root.db.toArray()
  );
  const [obstacles, errGettingObstacles] = tryNow(
    () => getObstaclesFromCircuitJson(trace.root.db.toArray())
    // Remove as any when autorouting-dataset gets updated
  );
  if (errGettingObstacles) {
    trace.renderError({
      type: "pcb_trace_error",
      error_type: "pcb_trace_error",
      pcb_trace_error_id: trace.pcb_trace_id,
      message: `Error getting obstacles for autorouting: ${errGettingObstacles.message}`,
      source_trace_id: trace.source_trace_id,
      center: { x: 0, y: 0 },
      pcb_port_ids: ports.map((p) => p.pcb_port_id),
      pcb_trace_id: trace.pcb_trace_id,
      pcb_component_ids: []
    });
    return;
  }
  for (const obstacle of obstacles) {
    const connectedTo = obstacle.connectedTo;
    if (connectedTo.length > 0) {
      const netId = connMap.getNetConnectedToId(obstacle.connectedTo[0]);
      if (netId) {
        obstacle.connectedTo.push(netId);
      }
    }
  }
  let orderedRoutePoints = [];
  if (candidateLayerCombinations.length === 0) {
    orderedRoutePoints = orderedRouteObjectives;
  } else {
    const candidateLayerSelections = candidateLayerCombinations[0].layer_path;
    orderedRoutePoints = orderedRouteObjectives.map((t, idx) => {
      if (t.via) {
        return {
          ...t,
          via_to_layer: candidateLayerSelections[idx]
        };
      }
      return { ...t, layers: [candidateLayerSelections[idx]] };
    });
  }
  ;
  orderedRoutePoints[0].pcb_port_id = ports[0].pcb_port_id;
  orderedRoutePoints[orderedRoutePoints.length - 1].pcb_port_id = ports[1].pcb_port_id;
  const routes = [];
  for (const [a, b] of pairs(orderedRoutePoints)) {
    const dominantLayer = "via_to_layer" in a ? a.via_to_layer : null;
    const BOUNDS_MARGIN = 2;
    const aLayer = "layers" in a && a.layers.length === 1 ? a.layers[0] : dominantLayer ?? "top";
    const bLayer = "layers" in b && b.layers.length === 1 ? b.layers[0] : dominantLayer ?? "top";
    const pcbPortA = "pcb_port_id" in a ? a.pcb_port_id : null;
    const pcbPortB = "pcb_port_id" in b ? b.pcb_port_id : null;
    const minTraceWidth = trace.getSubcircuit()._parsedProps.minTraceWidth ?? 0.16;
    const ijump = new MultilayerIjump2({
      OBSTACLE_MARGIN: minTraceWidth * 2,
      isRemovePathLoopsEnabled: true,
      optimizeWithGoalBoxes: Boolean(pcbPortA && pcbPortB),
      connMap,
      input: {
        obstacles,
        minTraceWidth,
        connections: [
          {
            name: trace.source_trace_id,
            pointsToConnect: [
              { ...a, layer: aLayer, pcb_port_id: pcbPortA },
              { ...b, layer: bLayer, pcb_port_id: pcbPortB }
            ]
          }
        ],
        layerCount: 2,
        bounds: {
          minX: Math.min(a.x, b.x) - BOUNDS_MARGIN,
          maxX: Math.max(a.x, b.x) + BOUNDS_MARGIN,
          minY: Math.min(a.y, b.y) - BOUNDS_MARGIN,
          maxY: Math.max(a.y, b.y) + BOUNDS_MARGIN
        }
      }
    });
    let traces = null;
    try {
      traces = ijump.solveAndMapToTraces();
    } catch (e) {
      trace.renderError({
        type: "pcb_trace_error",
        pcb_trace_error_id: trace.source_trace_id,
        error_type: "pcb_trace_error",
        message: `error solving route: ${e.message}`,
        source_trace_id: trace.pcb_trace_id,
        center: { x: (a.x + b.x) / 2, y: (a.y + b.y) / 2 },
        pcb_port_ids: ports.map((p) => p.pcb_port_id),
        pcb_trace_id: trace.pcb_trace_id,
        pcb_component_ids: ports.map((p) => p.pcb_component_id)
      });
    }
    if (!traces) return;
    if (traces.length === 0) {
      trace.renderError({
        type: "pcb_trace_error",
        error_type: "pcb_trace_error",
        pcb_trace_error_id: trace.pcb_trace_id,
        message: `Could not find a route for ${trace}`,
        source_trace_id: trace.source_trace_id,
        center: { x: (a.x + b.x) / 2, y: (a.y + b.y) / 2 },
        pcb_port_ids: ports.map((p) => p.pcb_port_id),
        pcb_trace_id: trace.pcb_trace_id,
        pcb_component_ids: ports.map((p) => p.pcb_component_id)
      });
      return;
    }
    const [autoroutedTrace] = traces;
    if (dominantLayer) {
      autoroutedTrace.route = autoroutedTrace.route.map((p) => {
        if (p.route_type === "wire" && !p.layer) {
          p.layer = dominantLayer;
        }
        return p;
      });
    }
    if (pcbPortA && autoroutedTrace.route[0].route_type === "wire") {
      autoroutedTrace.route[0].start_pcb_port_id = pcbPortA;
    }
    const lastRoutePoint = autoroutedTrace.route[autoroutedTrace.route.length - 1];
    if (pcbPortB && lastRoutePoint.route_type === "wire") {
      lastRoutePoint.end_pcb_port_id = pcbPortB;
    }
    routes.push(autoroutedTrace.route);
  }
  const mergedRoute = mergeRoutes(routes);
  const traceLength = getTraceLength(mergedRoute);
  const pcb_trace = db.pcb_trace.insert({
    route: mergedRoute,
    source_trace_id: trace.source_trace_id,
    subcircuit_id: trace.getSubcircuit()?.subcircuit_id,
    trace_length: traceLength
  });
  trace._portsRoutedOnPcb = ports;
  trace.pcb_trace_id = pcb_trace.pcb_trace_id;
  for (const point of mergedRoute) {
    if (point.route_type === "via") {
      db.pcb_via.insert({
        pcb_trace_id: pcb_trace.pcb_trace_id,
        x: point.x,
        y: point.y,
        hole_diameter: 0.3,
        outer_diameter: 0.6,
        layers: [point.from_layer, point.to_layer],
        from_layer: point.from_layer,
        to_layer: point.to_layer
      });
    }
  }
  trace._insertErrorIfTraceIsOutsideBoard(mergedRoute, ports);
}

// lib/components/primitive-components/Trace/Trace__doInitialSchematicTraceRenderWithDisplayLabel.ts
function Trace__doInitialSchematicTraceRenderWithDisplayLabel(trace) {
  if (trace.root?.schematicDisabled) return;
  const { db } = trace.root;
  const { _parsedProps: props, parent } = trace;
  if (!parent) throw new Error("Trace has no parent");
  const { allPortsFound, portsWithSelectors: connectedPorts } = trace._findConnectedPorts();
  if (!allPortsFound) return;
  const portsWithPosition = connectedPorts.map(({ port }) => ({
    port,
    position: port._getGlobalSchematicPositionAfterLayout(),
    schematic_port_id: port.schematic_port_id,
    facingDirection: port.facingDirection
  }));
  if (portsWithPosition.length < 2) {
    throw new Error("Expected at least two ports in portsWithPosition.");
  }
  let fromPortName;
  let toPortName;
  const fromAnchorPos = portsWithPosition[0].position;
  const fromPort = portsWithPosition[0].port;
  if ("path" in trace.props) {
    if (trace.props.path.length !== 2) {
      throw new Error("Invalid 'path': Must contain exactly two elements.");
    }
    ;
    [fromPortName, toPortName] = trace.props.path;
  } else {
    if (!("from" in trace.props && "to" in trace.props)) {
      throw new Error("Missing 'from' or 'to' properties in props.");
    }
    fromPortName = trace.props.from;
    toPortName = trace.props.to;
  }
  if (!fromPort.source_port_id) {
    throw new Error(
      `Missing source_port_id for the 'from' port (${fromPortName}).`
    );
  }
  const toAnchorPos = portsWithPosition[1].position;
  const toPort = portsWithPosition[1].port;
  if (!toPort.source_port_id) {
    throw new Error(`Missing source_port_id for the 'to' port (${toPortName}).`);
  }
  const existingFromNetLabel = db.schematic_net_label.list().find((label) => label.source_net_id === fromPort.source_port_id);
  const existingToNetLabel = db.schematic_net_label.list().find((label) => label.source_net_id === toPort.source_port_id);
  const [firstPort, secondPort] = connectedPorts.map(({ port }) => port);
  const isFirstPortSchematicBox = firstPort.parent?.config.shouldRenderAsSchematicBox;
  const pinFullName = isFirstPortSchematicBox ? `${firstPort?.parent?.props.name}_${firstPort?.props.name}` : `${secondPort?.parent?.props.name}_${secondPort?.props.name}`;
  const netLabelText = trace.props.schDisplayLabel ?? pinFullName;
  if (existingFromNetLabel && existingFromNetLabel.text !== netLabelText) {
    existingFromNetLabel.text = `${netLabelText} / ${existingFromNetLabel.text}`;
  }
  if (existingToNetLabel && existingToNetLabel?.text !== netLabelText) {
    existingToNetLabel.text = `${netLabelText} / ${existingToNetLabel.text}`;
  }
  if (!existingToNetLabel) {
    const toSide = getEnteringEdgeFromDirection(toPort.facingDirection) ?? "bottom";
    db.schematic_net_label.insert({
      text: trace.props.schDisplayLabel ?? pinFullName,
      source_net_id: toPort.source_port_id,
      anchor_position: toAnchorPos,
      center: computeSchematicNetLabelCenter({
        anchor_position: toAnchorPos,
        anchor_side: toSide,
        text: trace.props.schDisplayLabel ?? pinFullName
      }),
      anchor_side: toSide
    });
  }
  if (!existingFromNetLabel) {
    const fromSide = getEnteringEdgeFromDirection(fromPort.facingDirection) ?? "bottom";
    db.schematic_net_label.insert({
      text: trace.props.schDisplayLabel ?? pinFullName,
      source_net_id: fromPort.source_port_id,
      anchor_position: fromAnchorPos,
      center: computeSchematicNetLabelCenter({
        anchor_position: fromAnchorPos,
        anchor_side: fromSide,
        text: trace.props.schDisplayLabel ?? pinFullName
      }),
      anchor_side: fromSide
    });
  }
}

// lib/components/primitive-components/Trace/Trace__findConnectedPorts.ts
function Trace__findConnectedPorts(trace) {
  const { db } = trace.root;
  const { _parsedProps: props, parent } = trace;
  if (!parent) throw new Error("Trace has no parent");
  const portSelectors = trace.getTracePortPathSelectors();
  const portsWithSelectors = portSelectors.map((selector) => ({
    selector,
    port: trace.getSubcircuit().selectOne(selector, { type: "port" }) ?? null
  }));
  for (const { selector, port } of portsWithSelectors) {
    if (!port) {
      let parentSelector;
      let portToken;
      const dotIndex = selector.lastIndexOf(".");
      if (dotIndex !== -1 && dotIndex > selector.lastIndexOf(" ")) {
        parentSelector = selector.slice(0, dotIndex);
        portToken = selector.slice(dotIndex + 1);
      } else {
        const match = selector.match(/^(.*[ >])?([^ >]+)$/);
        parentSelector = match?.[1]?.trim() ?? "";
        portToken = match?.[2] ?? selector;
      }
      let targetComponent = parentSelector ? trace.getSubcircuit().selectOne(parentSelector) : null;
      if (!targetComponent && parentSelector && !/[.#\[]/.test(parentSelector)) {
        targetComponent = trace.getSubcircuit().selectOne(`.${parentSelector}`);
      }
      if (!targetComponent) {
        if (parentSelector) {
          trace.renderError(
            `Could not find port for selector "${selector}". Component "${parentSelector}" not found`
          );
        } else {
          trace.renderError(`Could not find port for selector "${selector}"`);
        }
      } else {
        const ports = targetComponent.children.filter(
          (c) => c.componentName === "Port"
        );
        const portLabel = portToken.includes(".") ? portToken.split(".").pop() ?? "" : portToken;
        const portNames = ports.flatMap((c) => c.getNameAndAliases());
        const hasCustomLabels = portNames.some((n) => !/^(pin\d+|\d+)$/.test(n));
        const labelList = Array.from(new Set(portNames)).join(", ");
        let detail;
        if (ports.length === 0) {
          detail = "It has no ports";
        } else if (!hasCustomLabels) {
          detail = `It has ${ports.length} pins and no pinLabels (consider adding pinLabels)`;
        } else {
          detail = `It has [${labelList}]`;
        }
        trace.renderError(
          `Could not find port for selector "${selector}". Component "${targetComponent.props.name ?? parentSelector}" found, but does not have pin "${portLabel}". ${detail}`
        );
      }
    }
  }
  if (portsWithSelectors.some((p) => !p.port)) {
    return { allPortsFound: false };
  }
  return {
    allPortsFound: true,
    portsWithSelectors,
    ports: portsWithSelectors.map(({ port }) => port)
  };
}

// lib/components/primitive-components/Trace/Trace.ts
var Trace3 = class extends PrimitiveComponent2 {
  source_trace_id = null;
  pcb_trace_id = null;
  schematic_trace_id = null;
  _portsRoutedOnPcb;
  subcircuit_connectivity_map_key = null;
  _traceConnectionHash = null;
  constructor(props) {
    super(props);
    this._portsRoutedOnPcb = [];
  }
  get config() {
    return {
      zodProps: traceProps,
      componentName: "Trace"
    };
  }
  _getTracePortOrNetSelectorListFromProps() {
    if ("from" in this.props && "to" in this.props) {
      return [
        typeof this.props.from === "string" ? this.props.from : this.props.from.getPortSelector(),
        typeof this.props.to === "string" ? this.props.to : this.props.to.getPortSelector()
      ];
    }
    if ("path" in this.props) {
      return this.props.path.map(
        (p) => typeof p === "string" ? p : p.getPortSelector()
      );
    }
    return [];
  }
  getTracePortPathSelectors() {
    return this._getTracePortOrNetSelectorListFromProps().filter(
      (selector) => !selector.includes("net.")
    );
  }
  getTracePathNetSelectors() {
    return this._getTracePortOrNetSelectorListFromProps().filter(
      (selector) => selector.includes("net.")
    );
  }
  _findConnectedPorts() {
    return Trace__findConnectedPorts(this);
  }
  _resolveNet(selector) {
    const direct = this.getSubcircuit().selectOne(selector, {
      type: "net"
    });
    if (direct) return direct;
    const match = selector.match(/^net\.(.+)$/);
    const netName = match ? match[1] : null;
    if (!netName) return null;
    const allDescendants = this.root._getBoard().getDescendants();
    return allDescendants.find(
      (d) => d.componentName === "Net" && d._parsedProps.name === netName
    ) || null;
  }
  _findConnectedNets() {
    const netsWithSelectors = this.getTracePathNetSelectors().map(
      (selector) => ({
        selector,
        net: this._resolveNet(selector)
      })
    );
    const undefinedNets = netsWithSelectors.filter((n) => !n.net);
    if (undefinedNets.length > 0) {
      this.renderError(
        `Could not find net for selector "${undefinedNets[0].selector}" inside ${this}`
      );
    }
    return { netsWithSelectors, nets: netsWithSelectors.map((n) => n.net) };
  }
  /**
   * Get all the traces that are connected in any degree to this trace, this is
   * used during autorouting to routes to pass through traces connected to the
   * same net.
   */
  _getAllTracesConnectedToSameNet() {
    const traces = this.getSubcircuit().selectAll("trace");
    const myNets = this._findConnectedNets().nets;
    const myPorts = this._findConnectedPorts().ports ?? [];
    return traces.filter((t) => {
      if (t === this) return false;
      const tNets = t._findConnectedNets().nets;
      const tPorts = t._findConnectedPorts().ports ?? [];
      return tNets.some((n) => myNets.includes(n)) || tPorts.some((p) => myPorts.includes(p));
    });
  }
  /**
   * Determine if a trace is explicitly connected to a port (not via a net)
   */
  _isExplicitlyConnectedToPort(port) {
    const { allPortsFound, portsWithSelectors: portsWithMetadata } = this._findConnectedPorts();
    if (!allPortsFound) return false;
    const ports = portsWithMetadata.map((p) => p.port);
    return ports.includes(port);
  }
  /**
   * Determine if a trace is explicitly connected to a net (not via a port)
   */
  _isExplicitlyConnectedToNet(net) {
    const nets = this._findConnectedNets().nets;
    return nets.includes(net);
  }
  doInitialCreateNetsFromProps() {
    createNetsFromProps(this, this.getTracePathNetSelectors());
  }
  _computeTraceConnectionHash() {
    const { allPortsFound, ports } = this._findConnectedPorts();
    if (!allPortsFound || !ports) return null;
    const sortedPorts = [...ports].sort(
      (a, b) => (a.pcb_port_id || "").localeCompare(b.pcb_port_id || "")
    );
    const allIds = sortedPorts.map((p) => p.pcb_port_id);
    return allIds.join(",");
  }
  doInitialSourceTraceRender() {
    const { db } = this.root;
    const { _parsedProps: props, parent } = this;
    if (!parent) {
      this.renderError("Trace has no parent");
      return;
    }
    const { allPortsFound, portsWithSelectors: ports } = this._findConnectedPorts();
    if (!allPortsFound) return;
    this._traceConnectionHash = this._computeTraceConnectionHash();
    const existingTraces = db.source_trace.list();
    const existingTrace = existingTraces.find(
      (t) => t.subcircuit_connectivity_map_key === this.subcircuit_connectivity_map_key && t.connected_source_port_ids.sort().join(",") === this._traceConnectionHash
    );
    if (existingTrace) {
      this.source_trace_id = existingTrace.source_trace_id;
      return;
    }
    const nets = this._findConnectedNets().nets;
    const displayName = getTraceDisplayName({ ports, nets });
    const trace = db.source_trace.insert({
      connected_source_port_ids: ports.map((p) => p.port.source_port_id),
      connected_source_net_ids: nets.map((n) => n.source_net_id),
      subcircuit_id: this.getSubcircuit()?.subcircuit_id,
      max_length: getMaxLengthFromConnectedCapacitors(
        ports.map((p) => p.port),
        { db }
      ) ?? props.maxLength,
      display_name: displayName,
      min_trace_thickness: props.thickness
    });
    this.source_trace_id = trace.source_trace_id;
  }
  _insertErrorIfTraceIsOutsideBoard(mergedRoute, ports) {
    const { db } = this.root;
    const isOutsideBoard = isRouteOutsideBoard(mergedRoute, { db });
    if (isOutsideBoard) {
      db.pcb_trace_error.insert({
        error_type: "pcb_trace_error",
        source_trace_id: this.source_trace_id,
        message: `Trace ${this.getString()} routed outside the board boundaries.`,
        pcb_trace_id: this.pcb_trace_id,
        pcb_component_ids: [],
        pcb_port_ids: ports.map((p) => p.pcb_port_id)
      });
    }
  }
  doInitialPcbTraceRender() {
    Trace_doInitialPcbTraceRender(this);
  }
  _doInitialSchematicTraceRenderWithDisplayLabel() {
    Trace__doInitialSchematicTraceRenderWithDisplayLabel(this);
  }
  _isSymbolToChipConnection() {
    const { allPortsFound, ports } = this._findConnectedPorts();
    if (!allPortsFound || ports.length !== 2) return false;
    const [port1, port2] = ports;
    if (!port1?.parent || !port2?.parent) return false;
    const isPort1Chip = port1.parent.config.shouldRenderAsSchematicBox;
    const isPort2Chip = port2.parent.config.shouldRenderAsSchematicBox;
    return isPort1Chip && !isPort2Chip || !isPort1Chip && isPort2Chip;
  }
  _isSymbolToSymbolConnection() {
    const { allPortsFound, ports } = this._findConnectedPorts();
    if (!allPortsFound || ports.length !== 2) return false;
    const [port1, port2] = ports;
    if (!port1?.parent || !port2?.parent) return false;
    const isPort1Symbol = !port1.parent.config.shouldRenderAsSchematicBox;
    const isPort2Symbol = !port2.parent.config.shouldRenderAsSchematicBox;
    return isPort1Symbol && isPort2Symbol;
  }
  _isChipToChipConnection() {
    const { allPortsFound, ports } = this._findConnectedPorts();
    if (!allPortsFound || ports.length !== 2) return false;
    const [port1, port2] = ports;
    if (!port1?.parent || !port2?.parent) return false;
    const isPort1Chip = port1.parent.config.shouldRenderAsSchematicBox;
    const isPort2Chip = port2.parent.config.shouldRenderAsSchematicBox;
    return isPort1Chip && isPort2Chip;
  }
  doInitialSchematicTraceRender() {
    Trace_doInitialSchematicTraceRender(this);
  }
};

// lib/components/base-components/NormalComponent/NormalComponent.ts
var debug3 = Debug4("tscircuit:core");
var rotation3 = z8.object({
  x: rotation,
  y: rotation,
  z: rotation
});
var NormalComponent = class extends PrimitiveComponent2 {
  reactSubtrees = [];
  _impliedFootprint;
  isPrimitiveContainer = true;
  _asyncSupplierPartNumbers;
  pcb_missing_footprint_error_id;
  _hasStartedFootprintUrlLoad = false;
  /**
   * Override this property for component defaults
   */
  get defaultInternallyConnectedPinNames() {
    return [];
  }
  get internallyConnectedPinNames() {
    return this._parsedProps.internallyConnectedPins ?? this.defaultInternallyConnectedPinNames;
  }
  constructor(props) {
    super(props);
    this._addChildrenFromStringFootprint();
    this.initPorts();
  }
  /**
   * Override this method for better control over the auto-discovery of ports.
   *
   * If you override this method just do something like:
   * initPorts() {
   *   this.add(new Port({ pinNumber: 1, aliases: ["anode", "pos"] }))
   *   this.add(new Port({ pinNumber: 2, aliases: ["cathode", "neg"] }))
   * }
   *
   * By default, we'll pull the ports from the first place we find them:
   * 1. `config.schematicSymbolName`
   * 2. `props.footprint`
   *
   */
  initPorts(opts = {}) {
    if (this.root?.schematicDisabled) return;
    const { config } = this;
    const portsToCreate = [];
    const schPortArrangement = this._getSchematicPortArrangement();
    if (schPortArrangement && !this._parsedProps.pinLabels) {
      for (const side in schPortArrangement) {
        const pins = schPortArrangement[side].pins;
        if (Array.isArray(pins)) {
          for (const pinNumberOrLabel of pins) {
            const pinNumber = parsePinNumberFromLabelsOrThrow(
              pinNumberOrLabel,
              this._parsedProps.pinLabels
            );
            portsToCreate.push(
              new Port(
                {
                  pinNumber,
                  aliases: opts.additionalAliases?.[`pin${pinNumber}`] ?? []
                },
                {
                  originDescription: `schPortArrangement:${side}`
                }
              )
            );
          }
        }
      }
      const sides = ["left", "right", "top", "bottom"];
      let pinNum = 1;
      for (const side of sides) {
        const size = schPortArrangement[`${side}Size`];
        for (let i = 0; i < size; i++) {
          portsToCreate.push(
            new Port(
              {
                pinNumber: pinNum++,
                aliases: opts.additionalAliases?.[`pin${pinNum}`] ?? []
              },
              {
                originDescription: `schPortArrangement:${side}`
              }
            )
          );
        }
      }
    }
    const pinLabels = this._parsedProps.pinLabels;
    if (pinLabels) {
      for (let [pinNumber, label] of Object.entries(pinLabels)) {
        pinNumber = pinNumber.replace("pin", "");
        let existingPort = portsToCreate.find(
          (p) => p._parsedProps.pinNumber === Number(pinNumber)
        );
        const primaryLabel = Array.isArray(label) ? label[0] : label;
        const otherLabels = Array.isArray(label) ? label.slice(1) : [];
        if (!existingPort) {
          existingPort = new Port(
            {
              pinNumber: parseInt(pinNumber),
              name: primaryLabel,
              aliases: [
                ...otherLabels,
                ...opts.additionalAliases?.[`pin${parseInt(pinNumber)}`] ?? []
              ]
            },
            {
              originDescription: `pinLabels:pin${pinNumber}`
            }
          );
          portsToCreate.push(existingPort);
        } else {
          existingPort.externallyAddedAliases.push(primaryLabel, ...otherLabels);
          existingPort.props.name = primaryLabel;
        }
      }
    }
    if (config.schematicSymbolName) {
      const sym = symbols2[this._getSchematicSymbolNameOrThrow()];
      if (!sym) return;
      for (const symPort of sym.ports) {
        const pinNumber = getPinNumberFromLabels(symPort.labels);
        if (!pinNumber) continue;
        const existingPort = portsToCreate.find(
          (p) => p._parsedProps.pinNumber === Number(pinNumber)
        );
        if (existingPort) {
          existingPort.schematicSymbolPortDef = symPort;
        } else {
          const port = getPortFromHints(
            symPort.labels.concat(
              opts.additionalAliases?.[`pin${pinNumber}`] ?? []
            )
          );
          if (port) {
            port.originDescription = `schematicSymbol:labels[0]:${symPort.labels[0]}`;
            port.schematicSymbolPortDef = symPort;
            portsToCreate.push(port);
          }
        }
      }
      this.addAll(portsToCreate);
    }
    if (!this._getSchematicPortArrangement()) {
      const portsFromFootprint = this.getPortsFromFootprint(opts);
      for (const port of portsFromFootprint) {
        if (!portsToCreate.some(
          (p) => p.isMatchingAnyOf(port.getNameAndAliases())
        )) {
          portsToCreate.push(port);
        }
      }
    }
    for (let pn = 1; pn <= (opts.pinCount ?? this._getPinCount()); pn++) {
      if (!schPortArrangement) continue;
      if (portsToCreate.find((p) => p._parsedProps.pinNumber === pn)) continue;
      let explicitlyListedPinNumbersInSchPortArrangement = [
        ...schPortArrangement.leftSide?.pins ?? [],
        ...schPortArrangement.rightSide?.pins ?? [],
        ...schPortArrangement.topSide?.pins ?? [],
        ...schPortArrangement.bottomSide?.pins ?? []
      ].map(
        (pn2) => parsePinNumberFromLabelsOrThrow(pn2, this._parsedProps.pinLabels)
      );
      if ([
        "leftSize",
        "rightSize",
        "topSize",
        "bottomSize",
        "leftPinCount",
        "rightPinCount",
        "topPinCount",
        "bottomPinCount"
      ].some((key) => key in schPortArrangement)) {
        explicitlyListedPinNumbersInSchPortArrangement = Array.from(
          { length: this._getPinCount() },
          (_, i) => i + 1
        );
      }
      if (!explicitlyListedPinNumbersInSchPortArrangement.includes(pn)) {
        continue;
      }
      portsToCreate.push(
        new Port(
          {
            pinNumber: pn,
            aliases: opts.additionalAliases?.[`pin${pn}`] ?? []
          },
          {
            originDescription: `notOtherwiseAddedButDeducedFromPinCount:${pn}`
          }
        )
      );
    }
    if (portsToCreate.length > 0) {
      this.addAll(portsToCreate);
    }
  }
  _getImpliedFootprintString() {
    return null;
  }
  _isFootprintUrl(s) {
    return s.startsWith("http://") || s.startsWith("https://");
  }
  _addChildrenFromStringFootprint() {
    const { pcbRotation, pinLabels, pcbPinLabels } = this.props;
    let { footprint } = this.props;
    footprint ??= this._getImpliedFootprintString?.();
    if (!footprint) return;
    if (typeof footprint === "string") {
      if (this._isFootprintUrl(footprint)) return;
      const fpSoup = fp.string(footprint).soup();
      const fpComponents = createComponentsFromCircuitJson(
        {
          componentName: this.name ?? this.componentName,
          componentRotation: pcbRotation,
          footprint,
          pinLabels,
          pcbPinLabels
        },
        fpSoup
      );
      this.addAll(fpComponents);
    }
  }
  get portMap() {
    return new Proxy(
      {},
      {
        get: (target, prop) => {
          const port = this.children.find(
            (c) => c.componentName === "Port" && c.isMatchingNameOrAlias(prop)
          );
          if (!port) {
            throw new Error(
              `There was an issue finding the port "${prop.toString()}" inside of a ${this.componentName} component with name: "${this.props.name}". This is a bug in @tscircuit/core`
            );
          }
          return port;
        }
      }
    );
  }
  getInstanceForReactElement(element) {
    for (const subtree of this.reactSubtrees) {
      if (subtree.element === element) return subtree.component;
    }
    return null;
  }
  doInitialSourceRender() {
    const ftype = this.config.sourceFtype;
    if (!ftype) return;
    const { db } = this.root;
    const { _parsedProps: props } = this;
    const source_component = db.source_component.insert({
      ftype,
      name: this.name,
      manufacturer_part_number: props.manufacturerPartNumber ?? props.mfn,
      supplier_part_numbers: props.supplierPartNumbers
    });
    this.source_component_id = source_component.source_component_id;
  }
  /**
   * Render the schematic component for this NormalComponent using the
   * config.schematicSymbolName if it exists, or create a generic box if
   * no symbol is defined.
   *
   * You can override this method to do more complicated things.
   */
  doInitialSchematicComponentRender() {
    if (this.root?.schematicDisabled) return;
    const { db } = this.root;
    const { schematicSymbolName } = this.config;
    if (schematicSymbolName) {
      this._doInitialSchematicComponentRenderWithSymbol();
    } else {
      const dimensions = this._getSchematicBoxDimensions();
      if (dimensions) {
        this._doInitialSchematicComponentRenderWithSchematicBoxDimensions();
      }
    }
    const manualPlacement = this.getSubcircuit()?._getSchematicManualPlacementForComponent(this);
    if (this.schematic_component_id && (this.props.schX !== void 0 || this.props.schY !== void 0) && !!manualPlacement) {
      if (!this.schematic_component_id) {
        return;
      }
      const warning = schematic_manual_edit_conflict_warning.parse({
        type: "schematic_manual_edit_conflict_warning",
        schematic_manual_edit_conflict_warning_id: `schematic_manual_edit_conflict_${this.source_component_id}`,
        message: `${this.getString()} has both manual placement and prop coordinates. schX and schY will be used. Remove schX/schY or clear the manual placement.`,
        schematic_component_id: this.schematic_component_id,
        source_component_id: this.source_component_id,
        subcircuit_id: this.getSubcircuit()?.subcircuit_id
      });
      db.schematic_manual_edit_conflict_warning.insert(warning);
    }
  }
  _getSchematicSymbolDisplayValue() {
    return void 0;
  }
  _getInternallyConnectedPins() {
    if (this.internallyConnectedPinNames.length === 0) return [];
    const internallyConnectedPorts = [];
    for (const netPortNames of this.internallyConnectedPinNames) {
      const ports = [];
      for (const portName of netPortNames) {
        ports.push(this.portMap[portName]);
      }
      internallyConnectedPorts.push(ports);
    }
    return internallyConnectedPorts;
  }
  _doInitialSchematicComponentRenderWithSymbol() {
    if (this.root?.schematicDisabled) return;
    const { db } = this.root;
    const { _parsedProps: props } = this;
    const symbol_name = this._getSchematicSymbolNameOrThrow();
    const symbol = symbols2[symbol_name];
    const center = this._getGlobalSchematicPositionBeforeLayout();
    if (symbol) {
      const schematic_component2 = db.schematic_component.insert({
        center,
        size: symbol.size,
        source_component_id: this.source_component_id,
        symbol_name,
        symbol_display_value: this._getSchematicSymbolDisplayValue()
      });
      this.schematic_component_id = schematic_component2.schematic_component_id;
    }
  }
  _doInitialSchematicComponentRenderWithSchematicBoxDimensions() {
    if (this.root?.schematicDisabled) return;
    const { db } = this.root;
    const { _parsedProps: props } = this;
    const dimensions = this._getSchematicBoxDimensions();
    const primaryPortLabels = {};
    if (Array.isArray(props.pinLabels)) {
      props.pinLabels.forEach((label, index) => {
        primaryPortLabels[String(index + 1)] = label;
      });
    } else {
      for (const [port, label] of Object.entries(props.pinLabels ?? {})) {
        primaryPortLabels[port] = Array.isArray(label) ? label[0] : label;
      }
    }
    const center = this._getGlobalSchematicPositionBeforeLayout();
    const schPortArrangement = this._getSchematicPortArrangement();
    const schematic_component2 = db.schematic_component.insert({
      center,
      rotation: props.schRotation ?? 0,
      size: dimensions.getSize(),
      // We should be using the full size, but circuit-to-svg incorrectly
      // uses the schematic_component size to draw boxes instead of the
      // schematic_box size
      // size: dimensions.getSizeIncludingPins(),
      port_arrangement: underscorifyPortArrangement(schPortArrangement),
      pin_spacing: props.schPinSpacing ?? 0.2,
      // @ts-ignore soup needs to support distance for pin_styles
      pin_styles: underscorifyPinStyles(props.schPinStyle, props.pinLabels),
      port_labels: primaryPortLabels,
      source_component_id: this.source_component_id
    });
    const hasTopOrBottomPins = schPortArrangement?.topSide !== void 0 || schPortArrangement?.bottomSide !== void 0;
    const schematic_box_width = dimensions?.getSize().width;
    const schematic_box_height = dimensions?.getSize().height;
    const manufacturer_part_number_schematic_text = db.schematic_text.insert({
      text: props.manufacturerPartNumber ?? "",
      schematic_component_id: schematic_component2.schematic_component_id,
      anchor: "left",
      rotation: 0,
      position: {
        x: hasTopOrBottomPins ? center.x + (schematic_box_width ?? 0) / 2 + 0.1 : center.x - (schematic_box_width ?? 0) / 2,
        y: hasTopOrBottomPins ? center.y + (schematic_box_height ?? 0) / 2 + 0.35 : center.y - (schematic_box_height ?? 0) / 2 - 0.13
      },
      color: "#006464",
      font_size: 0.18
    });
    const component_name_text = db.schematic_text.insert({
      text: props.name ?? "",
      schematic_component_id: schematic_component2.schematic_component_id,
      anchor: "left",
      rotation: 0,
      position: {
        x: hasTopOrBottomPins ? center.x + (schematic_box_width ?? 0) / 2 + 0.1 : center.x - (schematic_box_width ?? 0) / 2,
        y: hasTopOrBottomPins ? center.y + (schematic_box_height ?? 0) / 2 + 0.55 : center.y + (schematic_box_height ?? 0) / 2 + 0.13
      },
      color: "#006464",
      font_size: 0.18
    });
    this.schematic_component_id = schematic_component2.schematic_component_id;
  }
  doInitialPcbComponentRender() {
    if (this.root?.pcbDisabled) return;
    const { db } = this.root;
    const { _parsedProps: props } = this;
    const subcircuit = this.getSubcircuit();
    const pcb_component = db.pcb_component.insert({
      center: this._getGlobalPcbPositionBeforeLayout(),
      // width/height are computed in the PcbComponentSizeCalculation phase
      width: 0,
      height: 0,
      layer: props.layer ?? "top",
      rotation: props.pcbRotation ?? 0,
      source_component_id: this.source_component_id,
      subcircuit_id: subcircuit.subcircuit_id ?? void 0
    });
    const footprint = props.footprint ?? this._getImpliedFootprintString();
    if (!footprint && !this.isGroup) {
      const footprint_error = db.pcb_missing_footprint_error.insert({
        message: `No footprint found for component: ${this.getString()}`,
        source_component_id: `${this.source_component_id}`,
        error_type: "pcb_missing_footprint_error"
      });
      this.pcb_missing_footprint_error_id = footprint_error.pcb_missing_footprint_error_id;
    }
    this.pcb_component_id = pcb_component.pcb_component_id;
    const manualPlacement = this.getSubcircuit()._getPcbManualPlacementForComponent(this);
    if ((this.props.pcbX !== void 0 || this.props.pcbY !== void 0) && !!manualPlacement) {
      const warning = pcb_manual_edit_conflict_warning.parse({
        type: "pcb_manual_edit_conflict_warning",
        pcb_manual_edit_conflict_warning_id: `pcb_manual_edit_conflict_${this.source_component_id}`,
        message: `${this.getString()} has both manual placement and prop coordinates. pcbX and pcbY will be used. Remove pcbX/pcbY or clear the manual placement.`,
        pcb_component_id: this.pcb_component_id,
        source_component_id: this.source_component_id,
        subcircuit_id: subcircuit.subcircuit_id ?? void 0
      });
      db.pcb_manual_edit_conflict_warning.insert(warning);
    }
  }
  /**
   * At this stage, the smtpads/pcb primitives are placed, so we can compute
   * the width/height of the component
   */
  doInitialPcbComponentSizeCalculation() {
    if (this.root?.pcbDisabled) return;
    if (!this.pcb_component_id) return;
    const { db } = this.root;
    const { _parsedProps: props } = this;
    const bounds = getBoundsOfPcbComponents(this.children);
    if (bounds.width === 0 || bounds.height === 0) return;
    const center = {
      x: (bounds.minX + bounds.maxX) / 2,
      y: (bounds.minY + bounds.maxY) / 2
    };
    db.pcb_component.update(this.pcb_component_id, {
      center,
      width: bounds.width,
      height: bounds.height
    });
  }
  _renderReactSubtree(element) {
    return {
      element,
      component: createInstanceFromReactElement(element)
    };
  }
  doInitialInitializePortsFromChildren() {
    this.initPorts();
  }
  doInitialReactSubtreesRender() {
  }
  doInitialPcbFootprintStringRender() {
    let { footprint } = this.props;
    footprint ??= this._getImpliedFootprintString?.();
    if (!footprint) return;
    const { pcbRotation, pinLabels, pcbPinLabels } = this.props;
    if (typeof footprint === "string" && this._isFootprintUrl(footprint)) {
      if (this._hasStartedFootprintUrlLoad) return;
      this._hasStartedFootprintUrlLoad = true;
      const url = footprint;
      this._queueAsyncEffect("load-footprint-url", async () => {
        const res = await fetch(url);
        const soup = await res.json();
        const fpComponents = createComponentsFromCircuitJson(
          {
            componentName: this.name,
            componentRotation: pcbRotation,
            footprint: url,
            pinLabels,
            pcbPinLabels
          },
          soup
        );
        this.addAll(fpComponents);
        this._markDirty("InitializePortsFromChildren");
      });
      return;
    }
    if (isReactElement(footprint)) {
      if (this.reactSubtrees.some((rs) => rs.element === footprint)) return;
      const subtree = this._renderReactSubtree(footprint);
      this.reactSubtrees.push(subtree);
      this.add(subtree.component);
      return;
    }
    if (!isValidElement(footprint) && footprint.componentName === "Footprint") {
      this.add(footprint);
    }
  }
  _hasExistingPortExactly(port1) {
    const existingPorts = this.children.filter(
      (c) => c.componentName === "Port"
    );
    return existingPorts.some((port2) => {
      const aliases1 = port1.getNameAndAliases();
      const aliases2 = port2.getNameAndAliases();
      return aliases1.length === aliases2.length && aliases1.every((alias) => aliases2.includes(alias));
    });
  }
  add(componentOrElm) {
    let component;
    if (isReactElement(componentOrElm)) {
      const subtree = this._renderReactSubtree(componentOrElm);
      this.reactSubtrees.push(subtree);
      component = subtree.component;
    } else {
      component = componentOrElm;
    }
    if (component.componentName === "Port") {
      if (this._hasExistingPortExactly(component)) return;
      const existingPorts = this.children.filter(
        (c) => c.componentName === "Port"
      );
      const conflictingPort = existingPorts.find(
        (p) => p.isMatchingAnyOf(component.getNameAndAliases())
      );
      if (conflictingPort) {
        debug3(
          `Similar ports added. Port 1: ${conflictingPort}, Port 2: ${component}`
        );
      }
    }
    super.add(component);
  }
  getPortsFromFootprint(opts) {
    let { footprint } = this.props;
    if (!footprint || isValidElement(footprint)) {
      footprint = this.children.find((c) => c.componentName === "Footprint");
    }
    if (typeof footprint === "string") {
      if (this._isFootprintUrl(footprint)) return [];
      const fpSoup = fp.string(footprint).soup();
      const newPorts2 = [];
      for (const elm of fpSoup) {
        if ("port_hints" in elm && elm.port_hints) {
          const newPort = getPortFromHints(elm.port_hints, opts);
          if (!newPort) continue;
          newPort.originDescription = `footprint:string:${footprint}:port_hints[0]:${elm.port_hints[0]}`;
          newPorts2.push(newPort);
        }
      }
      return newPorts2;
    }
    if (!isValidElement(footprint) && footprint && footprint.componentName === "Footprint") {
      const fp2 = footprint;
      let pinNumber = 1;
      const newPorts2 = [];
      for (const fpChild of fp2.children) {
        if (!fpChild.props.portHints) continue;
        let portHintsList = fpChild.props.portHints;
        const hasPinPrefix = portHintsList.some(
          (hint) => hint.startsWith("pin")
        );
        if (!hasPinPrefix) {
          portHintsList = [...portHintsList, `pin${pinNumber}`];
        }
        pinNumber++;
        const newPort = getPortFromHints(portHintsList);
        if (!newPort) continue;
        newPort.originDescription = `footprint:${footprint}`;
        newPorts2.push(newPort);
      }
      return newPorts2;
    }
    const newPorts = [];
    if (!footprint) {
      for (const child of this.children) {
        if (child.props.portHints && child.isPcbPrimitive) {
          const port = getPortFromHints(child.props.portHints);
          if (port) newPorts.push(port);
        }
      }
    }
    return newPorts;
  }
  getPortsFromSchematicSymbol() {
    if (this.root?.schematicDisabled) return [];
    const { config } = this;
    if (!config.schematicSymbolName) return [];
    const symbol = symbols2[config.schematicSymbolName];
    if (!symbol) return [];
    const newPorts = [];
    for (const symbolPort of symbol.ports) {
      const port = getPortFromHints(symbolPort.labels);
      if (port) {
        port.schematicSymbolPortDef = symbolPort;
        newPorts.push(port);
      }
    }
    return newPorts;
  }
  doInitialCreateNetsFromProps() {
    this._createNetsFromProps(this._getNetsFromConnectionsProp());
  }
  _getNetsFromConnectionsProp() {
    const { _parsedProps: props } = this;
    const propsWithConnections = [];
    if (props.connections) {
      for (const [pinName, target] of Object.entries(props.connections)) {
        const targets = Array.isArray(target) ? target : [target];
        for (const targetPath of targets) {
          propsWithConnections.push(targetPath);
        }
      }
    }
    return propsWithConnections;
  }
  _createNetsFromProps(propsWithConnections) {
    createNetsFromProps(this, propsWithConnections);
  }
  _getPcbCircuitJsonBounds() {
    const { db } = this.root;
    if (!this.pcb_component_id) return super._getPcbCircuitJsonBounds();
    const pcb_component = db.pcb_component.get(this.pcb_component_id);
    return {
      center: { x: pcb_component.center.x, y: pcb_component.center.y },
      bounds: {
        left: pcb_component.center.x - pcb_component.width / 2,
        top: pcb_component.center.y - pcb_component.height / 2,
        right: pcb_component.center.x + pcb_component.width / 2,
        bottom: pcb_component.center.y + pcb_component.height / 2
      },
      width: pcb_component.width,
      height: pcb_component.height
    };
  }
  _getPinCountFromSchematicPortArrangement() {
    const schPortArrangement = this._getSchematicPortArrangement();
    if (!schPortArrangement) return 0;
    const isExplicitPinMapping = isExplicitPinMappingArrangement(schPortArrangement);
    if (!isExplicitPinMapping) {
      return (schPortArrangement.leftSize ?? schPortArrangement.leftPinCount ?? 0) + (schPortArrangement.rightSize ?? schPortArrangement.rightPinCount ?? 0) + (schPortArrangement.topSize ?? schPortArrangement.topPinCount ?? 0) + (schPortArrangement.bottomSize ?? schPortArrangement.bottomPinCount ?? 0);
    }
    const { leftSide, rightSide, topSide, bottomSide } = schPortArrangement;
    return Math.max(
      ...leftSide?.pins ?? [],
      ...rightSide?.pins ?? [],
      ...topSide?.pins ?? [],
      ...bottomSide?.pins ?? []
    );
  }
  _getPinCount() {
    const schPortArrangement = this._getSchematicPortArrangement();
    if (schPortArrangement) {
      const pinCountFromSchematicPortArrangement = this._getPinCountFromSchematicPortArrangement();
      return pinCountFromSchematicPortArrangement;
    }
    const portsFromFootprint = this.getPortsFromFootprint();
    if (portsFromFootprint.length > 0) {
      return portsFromFootprint.length;
    }
    const { pinLabels } = this._parsedProps;
    if (pinLabels) {
      if (Array.isArray(pinLabels)) {
        return pinLabels.length;
      }
      const pinNumbers = Object.keys(pinLabels).map((k) => k.startsWith("pin") ? parseInt(k.slice(3)) : parseInt(k)).filter((n) => !Number.isNaN(n));
      if (pinNumbers.length > 0) {
        return Math.max(...pinNumbers);
      }
      return Object.keys(pinLabels).length;
    }
    return 0;
  }
  /**
   * Override the schematic port arrangement if you want to customize where pins
   * appear on a schematic box, e.g. for a pin header
   */
  _getSchematicPortArrangement() {
    return this._parsedProps.schPinArrangement ?? this._parsedProps.schPortArrangement;
  }
  _getSchematicBoxDimensions() {
    if (this.getSchematicSymbol()) return null;
    if (!this.config.shouldRenderAsSchematicBox) return null;
    const { _parsedProps: props } = this;
    const pinCount = this._getPinCount();
    const pinSpacing = props.schPinSpacing ?? 0.2;
    const dimensions = getAllDimensionsForSchematicBox({
      schWidth: props.schWidth,
      schHeight: props.schHeight,
      schPinSpacing: pinSpacing,
      numericSchPinStyle: getNumericSchPinStyle(
        props.schPinStyle,
        props.pinLabels
      ),
      pinCount,
      schPortArrangement: this._getSchematicPortArrangement(),
      pinLabels: props.pinLabels
    });
    return dimensions;
  }
  doInitialCadModelRender() {
    const { db } = this.root;
    const { boardThickness = 0 } = this.root?._getBoard() ?? {};
    const cadModel = this._parsedProps.cadModel;
    if (!this.pcb_component_id) return;
    if (!cadModel && !this.props.footprint) return;
    if (cadModel === null) return;
    const bounds = this._getPcbCircuitJsonBounds();
    const pcb_component = db.pcb_component.get(this.pcb_component_id);
    if (typeof cadModel === "string") {
      throw new Error("String cadModel not yet implemented");
    }
    const rotationOffset = rotation3.parse({
      x: 0,
      y: 0,
      z: typeof cadModel?.rotationOffset === "number" ? cadModel.rotationOffset : 0,
      ...typeof cadModel?.rotationOffset === "object" ? cadModel.rotationOffset ?? {} : {}
    });
    const positionOffset = point3.parse({
      x: 0,
      y: 0,
      z: 0,
      ...typeof cadModel?.positionOffset === "object" ? cadModel.positionOffset : {}
    });
    const computedLayer = this.props.layer === "bottom" ? "bottom" : "top";
    const cad_model = db.cad_component.insert({
      // TODO z maybe depends on layer
      position: {
        x: bounds.center.x + positionOffset.x,
        y: bounds.center.y + positionOffset.y,
        z: (computedLayer === "bottom" ? -boardThickness / 2 : boardThickness / 2) + positionOffset.z
      },
      rotation: {
        x: rotationOffset.x,
        y: (computedLayer === "top" ? 0 : 180) + rotationOffset.y,
        z: computedLayer === "bottom" ? -((pcb_component?.rotation ?? 0) + rotationOffset.z) + 180 : (pcb_component?.rotation ?? 0) + rotationOffset.z
      },
      pcb_component_id: this.pcb_component_id,
      source_component_id: this.source_component_id,
      model_stl_url: "stlUrl" in (cadModel ?? {}) ? this._addCachebustToModelUrl(cadModel.stlUrl) : void 0,
      model_obj_url: "objUrl" in (cadModel ?? {}) ? this._addCachebustToModelUrl(cadModel.objUrl) : void 0,
      model_jscad: "jscad" in (cadModel ?? {}) ? cadModel.jscad : void 0,
      footprinter_string: typeof this.props.footprint === "string" && !cadModel ? this.props.footprint : void 0
    });
  }
  _addCachebustToModelUrl(url) {
    if (!url || !url.includes("modelcdn.tscircuit.com")) return url;
    const origin = this.root?.getClientOrigin() ?? "";
    return `${url}${url.includes("?") ? "&" : "?"}cachebust_origin=${encodeURIComponent(origin)}`;
  }
  _getPartsEngineCacheKey(source_component, footprinterString) {
    return JSON.stringify({
      ftype: source_component.ftype,
      name: source_component.name,
      manufacturer_part_number: source_component.manufacturer_part_number,
      footprinterString
    });
  }
  async _getSupplierPartNumbers(partsEngine, source_component, footprinterString) {
    if (this.props.doNotPlace) return {};
    const cacheEngine = this.root?.platform?.localCacheEngine;
    const cacheKey = this._getPartsEngineCacheKey(
      source_component,
      footprinterString
    );
    if (cacheEngine) {
      const cached = await cacheEngine.getItem(cacheKey);
      if (cached) {
        try {
          return JSON.parse(cached);
        } catch {
        }
      }
    }
    const result = await Promise.resolve(
      partsEngine.findPart({
        sourceComponent: source_component,
        footprinterString
      })
    );
    const supplierPartNumbers = result === "Not found" ? {} : result;
    if (cacheEngine) {
      try {
        await cacheEngine.setItem(cacheKey, JSON.stringify(supplierPartNumbers));
      } catch {
      }
    }
    return supplierPartNumbers;
  }
  doInitialPartsEngineRender() {
    if (this.props.doNotPlace) return;
    const partsEngine = this.getInheritedProperty("partsEngine");
    if (!partsEngine) return;
    const { db } = this.root;
    const source_component = db.source_component.get(this.source_component_id);
    if (!source_component) return;
    if (source_component.supplier_part_numbers) return;
    let footprinterString;
    if (this.props.footprint && typeof this.props.footprint === "string") {
      footprinterString = this.props.footprint;
    }
    const supplierPartNumbersMaybePromise = this._getSupplierPartNumbers(
      partsEngine,
      source_component,
      footprinterString
    );
    if (!(supplierPartNumbersMaybePromise instanceof Promise)) {
      db.source_component.update(this.source_component_id, {
        supplier_part_numbers: supplierPartNumbersMaybePromise
      });
      return;
    }
    this._queueAsyncEffect("get-supplier-part-numbers", async () => {
      this._asyncSupplierPartNumbers = await supplierPartNumbersMaybePromise;
      this._markDirty("PartsEngineRender");
    });
  }
  updatePartsEngineRender() {
    if (this.props.doNotPlace) return;
    const { db } = this.root;
    const source_component = db.source_component.get(this.source_component_id);
    if (!source_component) return;
    if (source_component.supplier_part_numbers) return;
    if (this._asyncSupplierPartNumbers) {
      db.source_component.update(this.source_component_id, {
        supplier_part_numbers: this._asyncSupplierPartNumbers
      });
      return;
    }
  }
  doInitialCreateTracesFromProps() {
    this._createTracesFromConnectionsProp();
  }
  _createTracesFromConnectionsProp() {
    const { _parsedProps: props } = this;
    if (props.connections) {
      for (const [pinName, target] of Object.entries(props.connections)) {
        const targets = Array.isArray(target) ? target : [target];
        for (const targetPath of targets) {
          this.add(
            new Trace3({
              from: `${this.getSubcircuitSelector()} > port.${pinName}`,
              to: targetPath
            })
          );
        }
      }
    }
  }
};

// lib/components/normal-components/Board.ts
import { boardProps } from "@tscircuit/props";
import { identity as identity3 } from "transformation-matrix";

// lib/components/primitive-components/Group/Group.ts
import {
  groupProps
} from "@tscircuit/props";

// lib/utils/autorouting/CapacityMeshAutorouter.ts
import { CapacityMeshSolver } from "@tscircuit/capacity-autorouter";

// lib/errors/AutorouterError.ts
import packageJson from "@tscircuit/capacity-autorouter/package.json" with { type: "json" };
var autorouterVersion = packageJson.version ?? "unknown";
var AutorouterError = class extends Error {
  constructor(message) {
    super(`${message} (capacity-autorouter@${autorouterVersion})`);
    this.name = "AutorouterError";
  }
};

// lib/utils/autorouting/CapacityMeshAutorouter.ts
var CapacityMeshAutorouter = class {
  input;
  isRouting = false;
  solver;
  eventHandlers = {
    complete: [],
    error: [],
    progress: []
  };
  cycleCount = 0;
  stepDelay;
  timeoutId;
  constructor(input, options = {}) {
    this.input = input;
    const { capacityDepth, targetMinCapacity, stepDelay = 0 } = options;
    this.solver = new CapacityMeshSolver(input, {
      capacityDepth,
      targetMinCapacity,
      cacheProvider: null
    });
    this.stepDelay = stepDelay;
  }
  /**
   * Start the autorouting process asynchronously
   * This will emit progress events during routing and a complete event when done
   */
  start() {
    if (this.isRouting) return;
    this.isRouting = true;
    this.cycleCount = 0;
    this.runCycleAndQueueNextCycle();
  }
  /**
   * Execute the next routing step and schedule the following one if needed
   */
  runCycleAndQueueNextCycle() {
    if (!this.isRouting) return;
    try {
      if (this.solver.solved || this.solver.failed) {
        if (this.solver.failed) {
          this.emitEvent({
            type: "error",
            error: new AutorouterError(this.solver.error || "Routing failed")
          });
        } else {
          this.emitEvent({
            type: "complete",
            traces: this.solver.getOutputSimpleRouteJson().traces || []
          });
        }
        this.isRouting = false;
        return;
      }
      const startTime = Date.now();
      const startIterations = this.solver.iterations;
      while (Date.now() - startTime < 250 && !this.solver.failed && !this.solver.solved) {
        this.solver.step();
      }
      const iterationsPerSecond = (this.solver.iterations - startIterations) / (Date.now() - startTime) * 1e3;
      this.cycleCount++;
      const debugGraphics = this.solver?.preview() || void 0;
      const progress = this.solver.progress;
      this.emitEvent({
        type: "progress",
        steps: this.cycleCount,
        iterationsPerSecond,
        progress,
        phase: this.solver.getCurrentPhase(),
        debugGraphics
      });
      if (this.stepDelay > 0) {
        this.timeoutId = setTimeout(
          () => this.runCycleAndQueueNextCycle(),
          this.stepDelay
        );
      } else {
        this.timeoutId = setTimeout(
          () => this.runCycleAndQueueNextCycle(),
          0
        );
      }
    } catch (error) {
      this.emitEvent({
        type: "error",
        error: error instanceof Error ? new AutorouterError(error.message) : new AutorouterError(String(error))
      });
      this.isRouting = false;
    }
  }
  /**
   * Stop the routing process if it's in progress
   */
  stop() {
    if (!this.isRouting) return;
    this.isRouting = false;
    if (this.timeoutId !== void 0) {
      clearTimeout(this.timeoutId);
      this.timeoutId = void 0;
    }
  }
  on(event, callback) {
    if (event === "complete") {
      this.eventHandlers.complete.push(
        callback
      );
    } else if (event === "error") {
      this.eventHandlers.error.push(
        callback
      );
    } else if (event === "progress") {
      this.eventHandlers.progress.push(
        callback
      );
    }
  }
  /**
   * Emit an event to all registered handlers
   */
  emitEvent(event) {
    if (event.type === "complete") {
      for (const handler of this.eventHandlers.complete) {
        handler(event);
      }
    } else if (event.type === "error") {
      for (const handler of this.eventHandlers.error) {
        handler(event);
      }
    } else if (event.type === "progress") {
      for (const handler of this.eventHandlers.progress) {
        handler(event);
      }
    }
  }
  /**
   * Solve the routing problem synchronously
   * @returns Array of routed traces
   */
  solveSync() {
    this.solver.solve();
    if (this.solver.failed) {
      throw new AutorouterError(this.solver.error || "Routing failed");
    }
    return this.solver.getOutputSimpleRouteJson().traces || [];
  }
};

// lib/components/primitive-components/Group/Group.ts
import "circuit-json";
import Debug7 from "debug";
import "zod";

// lib/components/primitive-components/TraceHint.ts
import { traceHintProps } from "@tscircuit/props";
import { applyToPoint as applyToPoint6 } from "transformation-matrix";
var TraceHint = class extends PrimitiveComponent2 {
  matchedPort = null;
  get config() {
    return {
      componentName: "TraceHint",
      zodProps: traceHintProps
    };
  }
  doInitialPortMatching() {
    const { db } = this.root;
    const { _parsedProps: props, parent } = this;
    if (!parent) return;
    if (parent.componentName === "Trace") {
      this.renderError(
        `Port inference inside trace is not yet supported (${this})`
      );
      return;
    }
    if (!parent) throw new Error("TraceHint has no parent");
    if (!props.for) {
      this.renderError(`TraceHint has no for property (${this})`);
      return;
    }
    const port = parent.selectOne(props.for, { type: "port" });
    if (!port) {
      this.renderError(
        `${this} could not find port for selector "${props.for}"`
      );
    }
    this.matchedPort = port;
    port.registerMatch(this);
  }
  getPcbRouteHints() {
    const { _parsedProps: props } = this;
    const offsets = props.offset ? [props.offset] : props.offsets;
    if (!offsets) return [];
    const globalTransform = this._computePcbGlobalTransformBeforeLayout();
    return offsets.map(
      (offset) => ({
        ...applyToPoint6(globalTransform, offset),
        via: offset.via,
        to_layer: offset.to_layer,
        trace_width: offset.trace_width
      })
    );
  }
  doInitialPcbTraceHintRender() {
    if (this.root?.pcbDisabled) return;
    const { db } = this.root;
    const { _parsedProps: props } = this;
    db.pcb_trace_hint.insert({
      pcb_component_id: this.matchedPort?.pcb_component_id,
      pcb_port_id: this.matchedPort?.pcb_port_id,
      route: this.getPcbRouteHints()
    });
  }
};

// lib/utils/edit-events/apply-pcb-edit-events-to-manual-edits-file.ts
import "zod";
import { su } from "@tscircuit/circuit-json-util";
var applyPcbEditEventsToManualEditsFile = ({
  circuitJson,
  editEvents,
  manualEditsFile
}) => {
  const updatedManualEditsFile = {
    ...manualEditsFile,
    pcb_placements: [...manualEditsFile.pcb_placements ?? []]
  };
  for (const editEvent of editEvents) {
    if (editEvent.edit_event_type === "edit_pcb_component_location") {
      const { pcb_component_id, new_center } = editEvent;
      const pcb_component = su(circuitJson).pcb_component.get(pcb_component_id);
      if (!pcb_component) continue;
      const source_component = su(circuitJson).source_component.get(
        pcb_component.source_component_id
      );
      if (!source_component) continue;
      const existingPlacementIndex = updatedManualEditsFile.pcb_placements?.findIndex(
        (p) => p.selector === source_component.name
      );
      const newPlacement = {
        selector: source_component.name,
        center: new_center,
        relative_to: "group_center"
      };
      if (existingPlacementIndex >= 0) {
        updatedManualEditsFile.pcb_placements[existingPlacementIndex] = newPlacement;
      } else {
        updatedManualEditsFile.pcb_placements.push(newPlacement);
      }
    }
  }
  return updatedManualEditsFile;
};

// lib/utils/edit-events/apply-schematic-edit-events-to-manual-edits-file.ts
import { su as su2 } from "@tscircuit/circuit-json-util";
import "zod";
var applySchematicEditEventsToManualEditsFile = ({
  circuitJson,
  editEvents,
  manualEditsFile
}) => {
  const updatedManualEditsFile = {
    ...manualEditsFile,
    schematic_placements: [...manualEditsFile.schematic_placements ?? []]
  };
  for (const editEvent of editEvents) {
    if (editEvent.edit_event_type === "edit_schematic_component_location") {
      const { schematic_component_id, new_center } = editEvent;
      const schematic_component2 = su2(circuitJson).schematic_component.get(
        schematic_component_id
      );
      if (!schematic_component2) continue;
      const source_component = su2(circuitJson).source_component.get(
        schematic_component2.source_component_id
      );
      if (!source_component) continue;
      const existingPlacementIndex = updatedManualEditsFile.schematic_placements?.findIndex(
        (p) => p.selector === source_component.name
      );
      const newPlacement = {
        selector: source_component.name,
        center: new_center,
        relative_to: "group_center"
      };
      if (existingPlacementIndex >= 0) {
        updatedManualEditsFile.schematic_placements[existingPlacementIndex] = newPlacement;
      } else {
        updatedManualEditsFile.schematic_placements.push(newPlacement);
      }
    }
  }
  return updatedManualEditsFile;
};

// lib/utils/edit-events/apply-edit-events-to-manual-edits-file.ts
var applyEditEventsToManualEditsFile = ({
  circuitJson,
  editEvents,
  manualEditsFile
}) => {
  const schematicEditEvents = editEvents.filter(
    (event) => event.edit_event_type === "edit_schematic_component_location"
  );
  const pcbEditEvents = editEvents.filter(
    (event) => event.edit_event_type === "edit_pcb_component_location"
  );
  let updatedManualEditsFile = manualEditsFile;
  if (schematicEditEvents.length > 0) {
    updatedManualEditsFile = applySchematicEditEventsToManualEditsFile({
      circuitJson,
      editEvents: schematicEditEvents,
      manualEditsFile: updatedManualEditsFile
    });
  }
  if (pcbEditEvents.length > 0) {
    updatedManualEditsFile = applyPcbEditEventsToManualEditsFile({
      circuitJson,
      editEvents: pcbEditEvents,
      manualEditsFile: updatedManualEditsFile
    });
  }
  return updatedManualEditsFile;
};

// lib/utils/edit-events/apply-edit-events-to-circuit-json.ts
import { transformPCBElement } from "@tscircuit/circuit-json-util";
import { translate as translate4 } from "transformation-matrix";

// lib/utils/edit-events/apply-trace-hint-edit-event.ts
import { su as su3 } from "@tscircuit/circuit-json-util";
var applyTraceHintEditEvent = (circuitJson, edit_event) => {
  const existingTraceHint = su3(circuitJson).pcb_trace_hint.get(
    edit_event.pcb_trace_hint_id
  );
  if (existingTraceHint) {
    circuitJson = circuitJson.map(
      (e) => e.pcb_trace_hint_id === edit_event.pcb_trace_hint_id ? {
        ...e,
        route: edit_event.route
      } : e
    );
  } else {
    const pcbPort = su3(circuitJson).pcb_port.get(edit_event.pcb_port_id);
    circuitJson = circuitJson.filter(
      (e) => !(e.type === "pcb_trace_hint" && e.pcb_port_id === edit_event.pcb_port_id)
    ).concat([
      {
        type: "pcb_trace_hint",
        pcb_trace_hint_id: edit_event.pcb_trace_hint_id,
        route: edit_event.route,
        pcb_port_id: edit_event.pcb_port_id,
        pcb_component_id: pcbPort?.pcb_component_id
      }
    ]);
  }
  return circuitJson;
};

// lib/utils/edit-events/apply-edit-events-to-circuit-json.ts
var applyEditEvents = ({
  circuitJson,
  editEvents
}) => {
  circuitJson = JSON.parse(JSON.stringify(circuitJson));
  for (const editEvent of editEvents) {
    if (editEvent.edit_event_type === "edit_pcb_component_location") {
      const component = circuitJson.find(
        (e) => e.type === "pcb_component" && e.pcb_component_id === editEvent.pcb_component_id
      );
      const needsMovement = !component || component.center.x !== editEvent.new_center.x || component.center.y !== editEvent.new_center.y;
      if (needsMovement && editEvent.original_center) {
        const mat = translate4(
          editEvent.new_center.x - editEvent.original_center.x,
          editEvent.new_center.y - editEvent.original_center.y
        );
        circuitJson = circuitJson.map(
          (e) => e.pcb_component_id !== editEvent.pcb_component_id ? e : transformPCBElement(e, mat)
        );
      }
    } else if (editEvent.edit_event_type === "edit_schematic_component_location") {
      circuitJson = circuitJson.map((e) => {
        if (e.type === "schematic_component" && e.schematic_component_id === editEvent.schematic_component_id) {
          return {
            ...e,
            center: editEvent.new_center
          };
        }
        return e;
      });
    } else if (editEvent.edit_event_type === "edit_pcb_trace_hint") {
      circuitJson = applyTraceHintEditEvent(circuitJson, editEvent);
    }
  }
  return circuitJson;
};

// lib/utils/autorouting/getSimpleRouteJsonFromCircuitJson.ts
import { su as su4 } from "@tscircuit/circuit-json-util";
import {
  getFullConnectivityMapFromCircuitJson as getFullConnectivityMapFromCircuitJson3
} from "circuit-json-to-connectivity-map";

// lib/utils/autorouting/getAncestorSubcircuitIds.ts
var getDescendantSubcircuitIds = (db, root_subcircuit_id) => {
  const groups = db.source_group.list();
  const result = [];
  const findDescendants = (parentId) => {
    const children = groups.filter(
      (group) => group.parent_subcircuit_id === parentId
    );
    for (const child of children) {
      if (child.subcircuit_id) {
        result.push(child.subcircuit_id);
        findDescendants(child.subcircuit_id);
      }
    }
  };
  findDescendants(root_subcircuit_id);
  return result;
};

// lib/utils/autorouting/getSimpleRouteJsonFromCircuitJson.ts
var getSimpleRouteJsonFromCircuitJson = ({
  db,
  circuitJson,
  subcircuit_id,
  minTraceWidth = 0.1
}) => {
  if (!db && circuitJson) {
    db = su4(circuitJson);
  }
  if (!db) {
    throw new Error("db or circuitJson is required");
  }
  const traceHints = db.pcb_trace_hint.list();
  const relevantSubcircuitIds = subcircuit_id ? /* @__PURE__ */ new Set([subcircuit_id]) : null;
  if (subcircuit_id) {
    const descendantSubcircuitIds = getDescendantSubcircuitIds(
      db,
      subcircuit_id
    );
    for (const id of descendantSubcircuitIds) {
      relevantSubcircuitIds.add(id);
    }
  }
  const subcircuitElements = (circuitJson ?? db.toArray()).filter(
    (e) => !subcircuit_id || "subcircuit_id" in e && relevantSubcircuitIds.has(e.subcircuit_id)
  );
  const board = db.pcb_board.list()[0];
  db = su4(subcircuitElements);
  const connMap = getFullConnectivityMapFromCircuitJson3(subcircuitElements);
  const obstacles = getObstaclesFromCircuitJson(
    [
      ...db.pcb_component.list(),
      ...db.pcb_smtpad.list(),
      ...db.pcb_plated_hole.list(),
      ...db.pcb_hole.list(),
      ...db.pcb_via.list()
      // getObstaclesFromSoup is old and doesn't support diagonal traces
      // ...db.pcb_trace.list(),
    ].filter(
      (e) => !subcircuit_id || relevantSubcircuitIds?.has(e.subcircuit_id)
    ),
    connMap
  );
  for (const obstacle of obstacles) {
    const additionalIds = obstacle.connectedTo.flatMap(
      (id) => connMap.getIdsConnectedToNet(id)
    );
    obstacle.connectedTo.push(...additionalIds);
  }
  const allPoints = obstacles.flatMap((o) => [
    {
      x: o.center.x - o.width / 2,
      y: o.center.y - o.height / 2
    },
    {
      x: o.center.x + o.width / 2,
      y: o.center.y + o.height / 2
    }
  ]);
  let bounds;
  if (board) {
    bounds = {
      minX: board.center.x - board.width / 2,
      maxX: board.center.x + board.width / 2,
      minY: board.center.y - board.height / 2,
      maxY: board.center.y + board.height / 2
    };
  } else {
    bounds = {
      minX: Math.min(...allPoints.map((p) => p.x)) - 1,
      maxX: Math.max(...allPoints.map((p) => p.x)) + 1,
      minY: Math.min(...allPoints.map((p) => p.y)) - 1,
      maxY: Math.max(...allPoints.map((p) => p.y)) + 1
    };
  }
  if (subcircuit_id) {
    const group = db.pcb_group.getWhere({ subcircuit_id });
    if (group) {
      const groupBounds = {
        minX: group.center.x - group.width / 2,
        maxX: group.center.x + group.width / 2,
        minY: group.center.y - group.height / 2,
        maxY: group.center.y + group.height / 2
      };
      bounds = {
        minX: Math.min(bounds.minX, groupBounds.minX),
        maxX: Math.max(bounds.maxX, groupBounds.maxX),
        minY: Math.min(bounds.minY, groupBounds.minY),
        maxY: Math.max(bounds.maxY, groupBounds.maxY)
      };
    }
  }
  const directTraceConnections = db.source_trace.list().map((trace) => {
    const connectedPorts = trace.connected_source_port_ids.map((id) => {
      const source_port = db.source_port.get(id);
      const pcb_port = db.pcb_port.getWhere({ source_port_id: id });
      return {
        ...source_port,
        ...pcb_port
      };
    });
    if (connectedPorts.length < 2) return null;
    const [portA, portB] = connectedPorts;
    const layerA = portA.layers?.[0] ?? "top";
    const layerB = portB.layers?.[0] ?? "top";
    const matchingHints = traceHints.filter(
      (hint) => hint.pcb_port_id === portA.pcb_port_id || hint.pcb_port_id === portB.pcb_port_id
    );
    const hintPoints = [];
    for (const hint of matchingHints) {
      const port = db.pcb_port.get(hint.pcb_port_id);
      const layer = port?.layers?.[0] ?? "top";
      for (const pt of hint.route) {
        hintPoints.push({
          x: pt.x,
          y: pt.y,
          layer
        });
      }
    }
    return {
      name: trace.source_trace_id ?? connMap.getNetConnectedToId(trace.source_trace_id) ?? "",
      source_trace_id: trace.source_trace_id,
      pointsToConnect: [
        {
          x: portA.x,
          y: portA.y,
          layer: layerA,
          pointId: portA.pcb_port_id,
          pcb_port_id: portA.pcb_port_id
        },
        ...hintPoints,
        {
          x: portB.x,
          y: portB.y,
          layer: layerB,
          pointId: portB.pcb_port_id,
          pcb_port_id: portB.pcb_port_id
        }
      ]
    };
  }).filter((c) => c !== null);
  const directTraceConnectionsById = new Map(
    directTraceConnections.map((c) => [c.source_trace_id, c])
  );
  const source_nets = db.source_net.list().filter(
    (e) => !subcircuit_id || relevantSubcircuitIds?.has(e.subcircuit_id)
  );
  const connectionsFromNets = [];
  for (const net of source_nets) {
    const connectedSourceTraces = db.source_trace.list().filter((st) => st.connected_source_net_ids?.includes(net.source_net_id));
    connectionsFromNets.push({
      name: net.source_net_id ?? connMap.getNetConnectedToId(net.source_net_id),
      pointsToConnect: connectedSourceTraces.flatMap((st) => {
        const pcb_ports = db.pcb_port.list().filter(
          (p) => st.connected_source_port_ids.includes(p.source_port_id)
        );
        return pcb_ports.map((p) => ({
          x: p.x,
          y: p.y,
          layer: p.layers?.[0] ?? "top",
          pointId: p.pcb_port_id,
          pcb_port_id: p.pcb_port_id
        }));
      })
    });
  }
  const breakoutPoints = db.pcb_breakout_point.list().filter(
    (bp) => !subcircuit_id || relevantSubcircuitIds?.has(bp.subcircuit_id)
  );
  const connectionsFromBreakoutPoints = [];
  const breakoutTraceConnectionsById = /* @__PURE__ */ new Map();
  for (const bp of breakoutPoints) {
    const pt = { x: bp.x, y: bp.y, layer: "top" };
    if (bp.source_trace_id) {
      const conn = directTraceConnectionsById.get(bp.source_trace_id) ?? breakoutTraceConnectionsById.get(bp.source_trace_id);
      if (conn) {
        conn.pointsToConnect.push(pt);
      } else {
        const newConn = {
          name: bp.source_trace_id,
          source_trace_id: bp.source_trace_id,
          pointsToConnect: [pt]
        };
        connectionsFromBreakoutPoints.push(newConn);
        breakoutTraceConnectionsById.set(bp.source_trace_id, newConn);
      }
    } else if (bp.source_net_id) {
      const conn = connectionsFromNets.find((c) => c.name === bp.source_net_id);
      if (conn) {
        conn.pointsToConnect.push(pt);
      } else {
        connectionsFromBreakoutPoints.push({
          name: bp.source_net_id,
          pointsToConnect: [pt]
        });
      }
    } else if (bp.source_port_id) {
      const pcb_port = db.pcb_port.getWhere({
        source_port_id: bp.source_port_id
      });
      if (pcb_port) {
        connectionsFromBreakoutPoints.push({
          name: bp.source_port_id,
          // direct connection from port to breakout point
          source_trace_id: void 0,
          pointsToConnect: [
            {
              x: pcb_port.x,
              y: pcb_port.y,
              layer: pcb_port.layers?.[0] ?? "top",
              pointId: pcb_port.pcb_port_id,
              // @ts-ignore
              pcb_port_id: pcb_port.pcb_port_id
            },
            pt
          ]
        });
      }
    }
  }
  const allConns = [
    ...directTraceConnections,
    ...connectionsFromNets,
    ...connectionsFromBreakoutPoints
  ];
  const pointIdToConn = /* @__PURE__ */ new Map();
  for (const conn of allConns) {
    for (const pt of conn.pointsToConnect) {
      if (pt.pointId) pointIdToConn.set(pt.pointId, conn);
    }
  }
  const existingTraces = db.pcb_trace.list().filter(
    (t) => !subcircuit_id || relevantSubcircuitIds?.has(t.subcircuit_id)
  );
  for (const tr of existingTraces) {
    const tracePortIds = /* @__PURE__ */ new Set();
    for (const seg of tr.route) {
      if (seg.start_pcb_port_id) tracePortIds.add(seg.start_pcb_port_id);
      if (seg.end_pcb_port_id) tracePortIds.add(seg.end_pcb_port_id);
    }
    if (tracePortIds.size < 2) continue;
    const firstId = tracePortIds.values().next().value;
    if (!firstId) continue;
    const conn = pointIdToConn.get(firstId);
    if (!conn) continue;
    if (![...tracePortIds].every((pid) => pointIdToConn.get(pid) === conn))
      continue;
    conn.externallyConnectedPointIds ??= [];
    conn.externallyConnectedPointIds.push([...tracePortIds]);
  }
  return {
    simpleRouteJson: {
      bounds,
      obstacles,
      connections: allConns,
      // TODO add traces so that we don't run into things routed by another
      // subcircuit
      layerCount: 2,
      minTraceWidth
    },
    connMap
  };
};

// lib/utils/render-events/getPhaseTimingsFromRenderEvents.ts
var getPhaseTimingsFromRenderEvents = (renderEvents) => {
  const phaseTimings = {};
  if (!renderEvents) return phaseTimings;
  for (const renderPhase of orderedRenderPhases) {
    phaseTimings[renderPhase] = 0;
  }
  const startEvents = /* @__PURE__ */ new Map();
  for (const event of renderEvents) {
    const [, , phase, eventType] = event.type.split(":");
    if (eventType === "start") {
      startEvents.set(`${phase}:${event.renderId}`, event);
      continue;
    }
    if (eventType === "end") {
      const startEvent = startEvents.get(`${phase}:${event.renderId}`);
      if (startEvent) {
        const duration = event.createdAt - startEvent.createdAt;
        phaseTimings[phase] = (phaseTimings[phase] || 0) + duration;
      }
    }
  }
  return phaseTimings;
};

// lib/utils/schematic/normalizePinLabels.ts
var normalizePinLabels = (inputPinLabels) => {
  const unqInputPinLabels = inputPinLabels.map((labels) => [...new Set(labels)]);
  const result = unqInputPinLabels.map(() => []);
  const desiredNumbers = unqInputPinLabels.map(() => null);
  for (let i = 0; i < unqInputPinLabels.length; i++) {
    for (const label of unqInputPinLabels[i]) {
      if (/^\d+$/.test(label)) {
        desiredNumbers[i] = Number.parseInt(label);
        break;
      }
    }
  }
  let highestPinNumber = 0;
  const alreadyAcceptedDesiredNumbers = /* @__PURE__ */ new Set();
  for (let i = 0; i < desiredNumbers.length; i++) {
    const desiredNumber = desiredNumbers[i];
    if (desiredNumber === null || desiredNumber < 1) {
      continue;
    }
    if (!alreadyAcceptedDesiredNumbers.has(desiredNumber)) {
      alreadyAcceptedDesiredNumbers.add(desiredNumber);
      result[i].push(`pin${desiredNumber}`);
      highestPinNumber = Math.max(highestPinNumber, desiredNumber);
      continue;
    }
    let existingAltsForPin = 0;
    for (const label of result[i]) {
      if (label.startsWith(`pin${desiredNumber}_alt`)) {
        existingAltsForPin++;
      }
    }
    result[i].push(`pin${desiredNumber}_alt${existingAltsForPin + 1}`);
  }
  for (let i = 0; i < result.length; i++) {
    const firstLabel = result[i][0];
    if (firstLabel?.includes("_alt")) {
      highestPinNumber++;
      result[i].unshift(`pin${highestPinNumber}`);
    }
  }
  for (let i = 0; i < result.length; i++) {
    if (result[i].length === 0) {
      highestPinNumber++;
      result[i].push(`pin${highestPinNumber}`);
    }
  }
  const totalLabelCounts = {};
  for (const inputLabels of unqInputPinLabels) {
    for (const label of inputLabels) {
      if (/^\d+$/.test(label)) {
        continue;
      }
      totalLabelCounts[label] = (totalLabelCounts[label] ?? 0) + 1;
    }
  }
  const incrementalLabelCounts = {};
  for (let i = 0; i < unqInputPinLabels.length; i++) {
    const inputLabels = unqInputPinLabels[i];
    for (const label of inputLabels) {
      if (/^\d+$/.test(label)) {
        continue;
      }
      if (totalLabelCounts[label] === 1) {
        result[i].push(label);
      } else {
        incrementalLabelCounts[label] = (incrementalLabelCounts[label] ?? 0) + 1;
        result[i].push(`${label}${incrementalLabelCounts[label]}`);
      }
    }
  }
  return result;
};

// lib/components/primitive-components/Group/Group_doInitialSchematicLayoutMatchAdapt.ts
import { corpusNoNetLabel } from "@tscircuit/schematic-corpus";
import { convertCircuitJsonToBpc } from "circuit-json-to-bpc";
import {
  getGraphicsForBpcGraph,
  layoutSchematicGraphVariants
} from "bpc-graph";
import Debug5 from "debug";
import { buildSubtree } from "@tscircuit/circuit-json-util";
var debug4 = Debug5("Group_doInitialSchematicLayoutMatchAdapt");
function Group_doInitialSchematicLayoutMatchAdapt(group) {
  const { db } = group.root;
  const subtreeCircuitJson = buildSubtree(db.toArray(), {
    source_group_id: group.source_group_id
  });
  const bpcGraphBeforeGeneratedNetLabels = convertCircuitJsonToBpc(subtreeCircuitJson);
  if (debug4.enabled) {
    global.debugGraphics?.push(
      getGraphicsForBpcGraph(bpcGraphBeforeGeneratedNetLabels, {
        title: `floatingBpcGraph-${group.name}`
      })
    );
  }
  const floatingGraph = convertCircuitJsonToBpc(
    subtreeCircuitJson
    // .concat(implicitNetLabels),
  );
  const floatingGraphNoNotConnected = {
    boxes: floatingGraph.boxes,
    pins: floatingGraph.pins.map((p) => ({
      ...p,
      color: p.color.replace("not_connected", "normal")
    }))
  };
  const { result: laidOutBpcGraph } = layoutSchematicGraphVariants(
    [
      { variantName: "default", floatingGraph },
      {
        variantName: "noNotConnected",
        floatingGraph: floatingGraphNoNotConnected
      }
    ],
    {
      singletonKeys: ["vcc/2", "gnd/2"],
      centerPinColors: ["netlabel_center", "component_center"],
      floatingBoxIdsWithMutablePinOffsets: new Set(
        floatingGraph.boxes.filter((box) => {
          const boxPins = floatingGraph.pins.filter(
            (p) => p.boxId === box.boxId
          );
          const nonCenterBoxPins = boxPins.filter(
            (bp) => !bp.color.includes("center")
          );
          if (nonCenterBoxPins.length <= 2) {
            return true;
          }
          return false;
        }).map((b) => b.boxId)
      ),
      corpus: corpusNoNetLabel
    }
  );
  if (debug4.enabled) {
    global.debugGraphics?.push(
      getGraphicsForBpcGraph(laidOutBpcGraph, {
        title: `laidOutBpcGraph-${group.name}`
      })
    );
  }
  const groupOffset = group._getGlobalSchematicPositionBeforeLayout();
  for (const box of laidOutBpcGraph.boxes) {
    if (!box.center) continue;
    const schematic_component2 = db.schematic_component.get(box.boxId);
    if (schematic_component2) {
      const newCenter = {
        x: box.center.x + groupOffset.x,
        y: box.center.y + groupOffset.y
      };
      const ports = db.schematic_port.list({
        schematic_component_id: schematic_component2.schematic_component_id
      });
      const texts = db.schematic_text.list({
        schematic_component_id: schematic_component2.schematic_component_id
      });
      const positionDelta = {
        x: newCenter.x - schematic_component2.center.x,
        y: newCenter.y - schematic_component2.center.y
      };
      for (const port of ports) {
        port.center.x += positionDelta.x;
        port.center.y += positionDelta.y;
      }
      for (const text of texts) {
        text.position.x += positionDelta.x;
        text.position.y += positionDelta.y;
      }
      schematic_component2.center = newCenter;
      continue;
    }
    const schematic_net_label = db.schematic_net_label.get(box.boxId);
    if (schematic_net_label) {
      const pin = laidOutBpcGraph.pins.find(
        (p) => p.boxId === box.boxId && p.color === "netlabel_center"
      );
      if (!pin) {
        throw new Error(`No pin found for net label: ${box.boxId}`);
      }
      const finalCenter = {
        x: box.center.x + groupOffset.x,
        y: box.center.y + groupOffset.y
      };
      schematic_net_label.center = finalCenter;
      schematic_net_label.anchor_position = {
        x: finalCenter.x + pin.offset.x,
        y: finalCenter.y + pin.offset.y
      };
      continue;
    }
    console.error(
      `No schematic element found for box: ${box.boxId}. This is a bug in the matchAdapt binding with @tscircuit/core`
    );
  }
}

// lib/components/primitive-components/Group/Group_doInitialSourceAddConnectivityMapKey.ts
import { ConnectivityMap as ConnectivityMap2 } from "circuit-json-to-connectivity-map";
function Group_doInitialSourceAddConnectivityMapKey(group) {
  if (!group.isSubcircuit) return;
  const { db } = group.root;
  const traces = group.selectAll("trace");
  const connMap = new ConnectivityMap2({});
  connMap.addConnections(
    traces.map((t) => {
      const source_trace = db.source_trace.get(
        t.source_trace_id
      );
      if (!source_trace) return null;
      return [
        source_trace.source_trace_id,
        ...source_trace.connected_source_port_ids,
        ...source_trace.connected_source_net_ids
      ];
    }).filter((c) => c !== null)
  );
  const { name: subcircuitName } = group._parsedProps;
  for (const trace of traces) {
    if (!trace.source_trace_id) continue;
    const connNetId = connMap.getNetConnectedToId(trace.source_trace_id);
    if (!connNetId) continue;
    trace.subcircuit_connectivity_map_key = `${subcircuitName ?? `unnamedsubcircuit${group._renderId}`}_${connNetId}`;
    db.source_trace.update(trace.source_trace_id, {
      subcircuit_connectivity_map_key: trace.subcircuit_connectivity_map_key
    });
  }
  const allSourcePortIds = /* @__PURE__ */ new Set();
  for (const trace of traces) {
    if (!trace.source_trace_id) continue;
    const source_trace = db.source_trace.get(
      trace.source_trace_id
    );
    if (!source_trace) continue;
    for (const id of source_trace.connected_source_port_ids) {
      allSourcePortIds.add(id);
    }
  }
  for (const portId of allSourcePortIds) {
    const connNetId = connMap.getNetConnectedToId(portId);
    if (!connNetId) continue;
    const connectivityMapKey = `${subcircuitName ?? `unnamedsubcircuit${group._renderId}`}_${connNetId}`;
    db.source_port.update(portId, {
      subcircuit_connectivity_map_key: connectivityMapKey
    });
  }
  const allSourceNetIds = /* @__PURE__ */ new Set();
  for (const trace of traces) {
    if (!trace.source_trace_id) continue;
    const source_trace = db.source_trace.get(
      trace.source_trace_id
    );
    if (!source_trace) continue;
    for (const source_net_id of source_trace.connected_source_net_ids) {
      allSourceNetIds.add(source_net_id);
    }
  }
  for (const netId of allSourceNetIds) {
    const connNetId = connMap.getNetConnectedToId(netId);
    if (!connNetId) continue;
    const connectivityMapKey = `${subcircuitName ?? `unnamedsubcircuit${group._renderId}`}_${connNetId}`;
    db.source_net.update(netId, {
      subcircuit_connectivity_map_key: connectivityMapKey
    });
  }
}

// lib/components/primitive-components/Group/Group_doInitialSchematicLayoutGrid.ts
function Group_doInitialSchematicLayoutGrid(group) {
  const { db } = group.root;
  const props = group._parsedProps;
  const schematicChildren = group.children.filter(
    (child) => child.schematic_component_id
  );
  if (schematicChildren.length === 0) return;
  let maxCellWidth = 0;
  let maxCellHeight = 0;
  for (const child of schematicChildren) {
    const schComp = db.schematic_component.get(child.schematic_component_id);
    if (schComp?.size) {
      maxCellWidth = Math.max(maxCellWidth, schComp.size.width);
      maxCellHeight = Math.max(maxCellHeight, schComp.size.height);
    }
  }
  if (maxCellWidth === 0 && schematicChildren.length > 0) maxCellWidth = 1;
  if (maxCellHeight === 0 && schematicChildren.length > 0) maxCellHeight = 1;
  let gridColsOption = props.gridCols;
  let gridRowsOption = void 0;
  let gridGapOption = props.gridGap;
  if (props.schLayout?.grid) {
    gridColsOption = props.schLayout.grid.cols ?? gridColsOption;
    gridRowsOption = props.schLayout.grid.rows;
    gridGapOption = props.schLayout.grid.gap ?? gridGapOption;
  }
  let numCols;
  let numRows;
  if (gridColsOption !== void 0 && gridRowsOption !== void 0) {
    numCols = gridColsOption;
    numRows = gridRowsOption;
  } else if (gridColsOption !== void 0) {
    numCols = gridColsOption;
    numRows = Math.ceil(schematicChildren.length / numCols);
  } else if (gridRowsOption !== void 0) {
    numRows = gridRowsOption;
    numCols = Math.ceil(schematicChildren.length / numRows);
  } else {
    numCols = Math.ceil(Math.sqrt(schematicChildren.length));
    numRows = Math.ceil(schematicChildren.length / numCols);
  }
  if (numCols === 0 && schematicChildren.length > 0) numCols = 1;
  if (numRows === 0 && schematicChildren.length > 0)
    numRows = schematicChildren.length;
  let gridGapX;
  let gridGapY;
  if (typeof gridGapOption === "number") {
    gridGapX = gridGapOption;
    gridGapY = gridGapOption;
  } else if (typeof gridGapOption === "object" && gridGapOption !== null) {
    gridGapX = gridGapOption.x;
    gridGapY = gridGapOption.y;
  } else {
    gridGapX = 1;
    gridGapY = 1;
  }
  const totalGridWidth = numCols * maxCellWidth + Math.max(0, numCols - 1) * gridGapX;
  const totalGridHeight = numRows * maxCellHeight + Math.max(0, numRows - 1) * gridGapY;
  const groupCenter = group._getGlobalSchematicPositionBeforeLayout();
  const firstCellCenterX = groupCenter.x - totalGridWidth / 2 + maxCellWidth / 2;
  const firstCellCenterY = groupCenter.y + totalGridHeight / 2 - maxCellHeight / 2;
  for (let i = 0; i < schematicChildren.length; i++) {
    const child = schematicChildren[i];
    if (!child.schematic_component_id) continue;
    const row = Math.floor(i / numCols);
    const col = i % numCols;
    if (row >= numRows || col >= numCols) {
      console.warn(
        `Schematic grid layout: Child ${child.getString()} at index ${i} (row ${row}, col ${col}) exceeds specified grid dimensions (${numRows}x${numCols}). Skipping placement.`
      );
      continue;
    }
    const targetCellCenterX = firstCellCenterX + col * (maxCellWidth + gridGapX);
    const targetCellCenterY = firstCellCenterY - row * (maxCellHeight + gridGapY);
    const schComp = db.schematic_component.get(child.schematic_component_id);
    if (schComp) {
      const oldChildCenter = schComp.center;
      const newChildCenter = { x: targetCellCenterX, y: targetCellCenterY };
      db.schematic_component.update(child.schematic_component_id, {
        center: newChildCenter
      });
      const deltaX = newChildCenter.x - oldChildCenter.x;
      const deltaY = newChildCenter.y - oldChildCenter.y;
      const schPorts = db.schematic_port.list({
        schematic_component_id: child.schematic_component_id
      });
      for (const port of schPorts) {
        db.schematic_port.update(port.schematic_port_id, {
          center: { x: port.center.x + deltaX, y: port.center.y + deltaY }
        });
      }
      const schTexts = db.schematic_text.list({
        schematic_component_id: child.schematic_component_id
      });
      for (const text of schTexts) {
        db.schematic_text.update(text.schematic_text_id, {
          position: {
            x: text.position.x + deltaX,
            y: text.position.y + deltaY
          }
        });
      }
    }
  }
  if (group.schematic_group_id) {
    db.schematic_group.update(group.schematic_group_id, {
      width: totalGridWidth,
      height: totalGridHeight,
      center: groupCenter
    });
  }
}

// lib/components/primitive-components/Group/Group_doInitialPcbLayoutGrid.ts
import { translate as translate5 } from "transformation-matrix";
import {
  transformPCBElements,
  getPrimaryId
} from "@tscircuit/circuit-json-util";
function Group_doInitialPcbLayoutGrid(group) {
  const { db } = group.root;
  const props = group._parsedProps;
  const pcbChildren = group.children.filter(
    (child) => child.pcb_component_id
  );
  if (pcbChildren.length === 0) return;
  let maxCellWidth = 0;
  let maxCellHeight = 0;
  for (const child of pcbChildren) {
    const pcbComp = db.pcb_component.get(child.pcb_component_id);
    if (pcbComp) {
      maxCellWidth = Math.max(maxCellWidth, pcbComp.width);
      maxCellHeight = Math.max(maxCellHeight, pcbComp.height);
    }
  }
  if (maxCellWidth === 0 && pcbChildren.length > 0) maxCellWidth = 1;
  if (maxCellHeight === 0 && pcbChildren.length > 0) maxCellHeight = 1;
  let gridColsOption = props.gridCols;
  let gridRowsOption = void 0;
  let gridGapOption = props.gridGap;
  if (props.pcbLayout?.grid) {
    gridColsOption = props.pcbLayout.grid.cols ?? gridColsOption;
    gridRowsOption = props.pcbLayout.grid.rows;
    gridGapOption = props.pcbLayout.grid.gap ?? gridGapOption;
  }
  let numCols;
  let numRows;
  if (gridColsOption !== void 0 && gridRowsOption !== void 0) {
    numCols = gridColsOption;
    numRows = gridRowsOption;
  } else if (gridColsOption !== void 0) {
    numCols = gridColsOption;
    numRows = Math.ceil(pcbChildren.length / numCols);
  } else if (gridRowsOption !== void 0) {
    numRows = gridRowsOption;
    numCols = Math.ceil(pcbChildren.length / numRows);
  } else {
    numCols = Math.ceil(Math.sqrt(pcbChildren.length));
    numRows = Math.ceil(pcbChildren.length / numCols);
  }
  if (numCols === 0 && pcbChildren.length > 0) numCols = 1;
  if (numRows === 0 && pcbChildren.length > 0) numRows = pcbChildren.length;
  let gridGapX;
  let gridGapY;
  if (typeof gridGapOption === "number") {
    gridGapX = gridGapOption;
    gridGapY = gridGapOption;
  } else if (typeof gridGapOption === "object" && gridGapOption !== null) {
    gridGapX = gridGapOption.x;
    gridGapY = gridGapOption.y;
  } else {
    gridGapX = 1;
    gridGapY = 1;
  }
  const totalGridWidth = numCols * maxCellWidth + Math.max(0, numCols - 1) * gridGapX;
  const totalGridHeight = numRows * maxCellHeight + Math.max(0, numRows - 1) * gridGapY;
  const groupCenter = group._getGlobalPcbPositionBeforeLayout();
  const firstCellCenterX = groupCenter.x - totalGridWidth / 2 + maxCellWidth / 2;
  const firstCellCenterY = groupCenter.y + totalGridHeight / 2 - maxCellHeight / 2;
  for (let i = 0; i < pcbChildren.length; i++) {
    const child = pcbChildren[i];
    if (!child.pcb_component_id) continue;
    const row = Math.floor(i / numCols);
    const col = i % numCols;
    if (row >= numRows || col >= numCols) {
      console.warn(
        `PCB grid layout: Child ${child.getString()} at index ${i} (row ${row}, col ${col}) exceeds grid dimensions (${numRows}x${numCols}). Skipping placement.`
      );
      continue;
    }
    const targetCellCenterX = firstCellCenterX + col * (maxCellWidth + gridGapX);
    const targetCellCenterY = firstCellCenterY - row * (maxCellHeight + gridGapY);
    const pcbComp = db.pcb_component.get(child.pcb_component_id);
    if (pcbComp) {
      const oldCenter = pcbComp.center;
      const newCenter = { x: targetCellCenterX, y: targetCellCenterY };
      const deltaX = newCenter.x - oldCenter.x;
      const deltaY = newCenter.y - oldCenter.y;
      const mat = translate5(deltaX, deltaY);
      const related = db.toArray().filter((e) => e.pcb_component_id === child.pcb_component_id);
      const moved = transformPCBElements(related, mat);
      for (const elm of moved) {
        const idProp = getPrimaryId(elm);
        db[elm.type].update(elm[idProp], elm);
      }
      db.pcb_component.update(child.pcb_component_id, {
        center: newCenter
      });
      child.setProps({
        ...child.props,
        pcbX: (child.props.pcbX ?? 0) + deltaX,
        pcbY: (child.props.pcbY ?? 0) + deltaY
      });
    }
  }
  if (group.pcb_group_id) {
    db.pcb_group.update(group.pcb_group_id, {
      width: props.width ?? totalGridWidth,
      height: props.height ?? totalGridHeight,
      center: groupCenter
    });
  }
}

// lib/utils/autorouting/getPresetAutoroutingConfig.ts
function getPresetAutoroutingConfig(autorouterConfig) {
  const defaults = {
    serverUrl: "https://registry-api.tscircuit.com",
    serverMode: "job",
    serverCacheEnabled: true
  };
  if (typeof autorouterConfig === "object" && !autorouterConfig.preset) {
    return {
      local: !(autorouterConfig.serverUrl || autorouterConfig.serverMode || autorouterConfig.serverCacheEnabled),
      ...defaults,
      ...autorouterConfig
    };
  }
  const preset = typeof autorouterConfig === "object" ? autorouterConfig.preset : autorouterConfig;
  switch (preset) {
    case "auto-local":
      return {
        local: true,
        groupMode: "subcircuit"
      };
    case "sequential-trace":
      return {
        local: true,
        groupMode: "sequential-trace"
      };
    case "subcircuit":
      return {
        local: true,
        groupMode: "subcircuit"
      };
    case "auto-cloud":
      return {
        local: false,
        groupMode: "subcircuit",
        serverUrl: defaults.serverUrl,
        serverMode: defaults.serverMode,
        serverCacheEnabled: true
      };
    default:
      return {
        local: true,
        groupMode: "subcircuit"
      };
  }
}

// lib/components/primitive-components/Group/Group_doInitialPcbLayoutPack.ts
import { buildSubtree as buildSubtree2 } from "@tscircuit/circuit-json-util";
import {
  pack,
  convertCircuitJsonToPackOutput,
  convertPackOutputToPackInput,
  getGraphicsFromPackOutput
} from "calculate-packing";
import { length } from "circuit-json";
import { transformPCBElements as transformPCBElements2 } from "@tscircuit/circuit-json-util";
import { translate as translate6, rotate as rotate2, compose as compose4 } from "transformation-matrix";
import Debug6 from "debug";
var debug5 = Debug6("Group_doInitialPcbLayoutPack");
var Group_doInitialPcbLayoutPack = (group) => {
  const { db } = group.root;
  const { _parsedProps: props } = group;
  const { packOrderStrategy, packPlacementStrategy, gap } = props;
  const subtreeCircuitJson = buildSubtree2(db.toArray(), {
    source_group_id: group.source_group_id
  });
  const gapMm = length.parse(gap ?? "0mm");
  const packInput = {
    ...convertPackOutputToPackInput(
      convertCircuitJsonToPackOutput(subtreeCircuitJson)
    ),
    orderStrategy: packOrderStrategy ?? "largest_to_smallest",
    placementStrategy: packPlacementStrategy ?? "shortest_connection_along_outline",
    minGap: gapMm
  };
  const packOutput = pack(packInput);
  if (debug5.enabled) {
    const graphics = getGraphicsFromPackOutput(packOutput);
    graphics.title = "packOutput";
    global.debugGraphics?.push(graphics);
  }
  for (const packedComponent of packOutput.components) {
    const { center, componentId, ccwRotationOffset } = packedComponent;
    const component = db.pcb_component.get(componentId);
    if (!component) continue;
    const originalCenter = component.center;
    const transformMatrix = compose4(
      translate6(center.x, center.y),
      rotate2(ccwRotationOffset || 0),
      translate6(-originalCenter.x, -originalCenter.y)
    );
    transformPCBElements2(
      subtreeCircuitJson.filter(
        (elm) => "pcb_component_id" in elm && elm.pcb_component_id === componentId
      ),
      transformMatrix
    );
  }
};

// lib/components/primitive-components/Group/Group_doInitialPcbLayoutFlex.ts
import { buildSubtree as buildSubtree3 } from "@tscircuit/circuit-json-util";
import { layoutCircuitJsonWithFlex } from "@tscircuit/circuit-json-flex";
var Group_doInitialPcbLayoutFlex = (group) => {
  const { db } = group.root;
  const { _parsedProps: props } = group;
  const circuitJson = group.lowercaseComponentName === "board" ? db.toArray() : buildSubtree3(db.toArray(), {
    source_group_id: group.source_group_id
  });
  const modifiedCircuitJson = layoutCircuitJsonWithFlex(circuitJson, {
    justifyContent: props.justifyContent === "start" ? "flex-start" : props.justifyContent === "end" ? "flex-end" : props.justifyContent === "stretch" ? "space-between" : props.justifyContent
  });
  const pcbSmtPads = db.pcb_smtpad.list();
  for (const smtpad of pcbSmtPads) {
    const modifiedElm = modifiedCircuitJson.find(
      (elm) => elm.type === "pcb_smtpad" && elm.pcb_smtpad_id === smtpad.pcb_smtpad_id
    );
    if (!modifiedElm) continue;
    db.pcb_smtpad.update(smtpad.pcb_smtpad_id, modifiedElm);
  }
  const pcbSilkScreenTexts = db.pcb_silkscreen_text.list();
  for (const silkscreenText of pcbSilkScreenTexts) {
    const modifiedElm = modifiedCircuitJson.find(
      (elm) => elm.type === "pcb_silkscreen_text" && elm.pcb_silkscreen_text_id === silkscreenText.pcb_silkscreen_text_id
    );
    if (!modifiedElm) continue;
    db.pcb_silkscreen_text.update(
      silkscreenText.pcb_silkscreen_text_id,
      modifiedElm
    );
  }
};

// lib/components/primitive-components/Group/Group.ts
import { convertSrjToGraphicsObject } from "@tscircuit/capacity-autorouter";
var Group = class extends NormalComponent {
  pcb_group_id = null;
  schematic_group_id = null;
  subcircuit_id = null;
  _hasStartedAsyncAutorouting = false;
  _asyncAutoroutingResult = null;
  get config() {
    return {
      zodProps: groupProps,
      componentName: "Group"
    };
  }
  doInitialSourceGroupRender() {
    const { db } = this.root;
    const source_group = db.source_group.insert({
      name: this.name,
      is_subcircuit: this.isSubcircuit
    });
    this.source_group_id = source_group.source_group_id;
    if (this.isSubcircuit) {
      this.subcircuit_id = `subcircuit_${source_group.source_group_id}`;
      db.source_group.update(source_group.source_group_id, {
        subcircuit_id: this.subcircuit_id
      });
    }
  }
  doInitialSourceRender() {
    const { db } = this.root;
    for (const child of this.children) {
      db.source_component.update(child.source_component_id, {
        source_group_id: this.source_group_id
      });
    }
  }
  doInitialSourceParentAttachment() {
    const { db } = this.root;
    const parentGroup = this.parent?.getGroup?.();
    if (parentGroup?.source_group_id) {
      db.source_group.update(this.source_group_id, {
        parent_source_group_id: parentGroup.source_group_id
      });
    }
    if (!this.isSubcircuit) return;
    const parent_subcircuit_id = this.parent?.getSubcircuit?.()?.subcircuit_id;
    if (!parent_subcircuit_id) return;
    db.source_group.update(this.source_group_id, {
      parent_subcircuit_id
    });
  }
  doInitialPcbComponentRender() {
    if (this.root?.pcbDisabled) return;
    const { db } = this.root;
    const { _parsedProps: props } = this;
    const pcb_group = db.pcb_group.insert({
      is_subcircuit: this.isSubcircuit,
      subcircuit_id: this.subcircuit_id,
      name: this.name,
      center: this._getGlobalPcbPositionBeforeLayout(),
      width: 0,
      height: 0,
      pcb_component_ids: [],
      source_group_id: this.source_group_id,
      autorouter_configuration: props.autorouter ? {
        trace_clearance: props.autorouter.traceClearance
      } : void 0
    });
    this.pcb_group_id = pcb_group.pcb_group_id;
    for (const child of this.children) {
      db.pcb_component.update(child.pcb_component_id, {
        pcb_group_id: pcb_group.pcb_group_id
      });
    }
  }
  doInitialPcbPrimitiveRender() {
    if (this.root?.pcbDisabled) return;
    const { db } = this.root;
    const props = this._parsedProps;
    const bounds = getBoundsOfPcbComponents(this.children);
    if (this.pcb_group_id) {
      let width = bounds.width;
      let height = bounds.height;
      let centerX = (bounds.minX + bounds.maxX) / 2;
      let centerY = (bounds.minY + bounds.maxY) / 2;
      if (this.isSubcircuit) {
        const { padLeft, padRight, padTop, padBottom } = this._resolvePcbPadding();
        width += padLeft + padRight;
        height += padTop + padBottom;
        centerX += (padRight - padLeft) / 2;
        centerY += (padTop - padBottom) / 2;
      }
      db.pcb_group.update(this.pcb_group_id, {
        width: Number(props.width ?? width),
        height: Number(props.height ?? height),
        center: {
          x: centerX,
          y: centerY
        }
      });
    }
  }
  _resolvePcbPadding() {
    const props = this._parsedProps;
    const layout = props.pcbLayout;
    const getPaddingValue = (key) => {
      const layoutValue = layout?.[key];
      const propsValue = props[key];
      if (typeof layoutValue === "number") return layoutValue;
      if (typeof propsValue === "number") return propsValue;
      return void 0;
    };
    const generalPadding = getPaddingValue("padding") ?? 0;
    const paddingX = getPaddingValue("paddingX");
    const paddingY = getPaddingValue("paddingY");
    const padLeft = getPaddingValue("paddingLeft") ?? paddingX ?? generalPadding;
    const padRight = getPaddingValue("paddingRight") ?? paddingX ?? generalPadding;
    const padTop = getPaddingValue("paddingTop") ?? paddingY ?? generalPadding;
    const padBottom = getPaddingValue("paddingBottom") ?? paddingY ?? generalPadding;
    return { padLeft, padRight, padTop, padBottom };
  }
  doInitialCreateTraceHintsFromProps() {
    const { _parsedProps: props } = this;
    const { db } = this.root;
    const groupProps2 = props;
    if (!this.isSubcircuit) return;
    const manualTraceHints = groupProps2.manualEdits?.manual_trace_hints;
    if (!manualTraceHints) return;
    for (const manualTraceHint of manualTraceHints) {
      this.add(
        new TraceHint({
          for: manualTraceHint.pcb_port_selector,
          offsets: manualTraceHint.offsets
        })
      );
    }
  }
  doInitialSourceAddConnectivityMapKey() {
    Group_doInitialSourceAddConnectivityMapKey(this);
  }
  _areChildSubcircuitsRouted() {
    const subcircuitChildren = this.selectAll("group").filter(
      (g) => g.isSubcircuit
    );
    for (const subcircuitChild of subcircuitChildren) {
      if (subcircuitChild._shouldRouteAsync() && !subcircuitChild._asyncAutoroutingResult) {
        return false;
      }
    }
    return true;
  }
  _shouldRouteAsync() {
    const autorouter = this._getAutorouterConfig();
    if (autorouter.groupMode === "sequential-trace") return false;
    if (autorouter.local && autorouter.groupMode === "subcircuit") return true;
    if (!autorouter.local) return true;
    return false;
  }
  _hasTracesToRoute() {
    const debug6 = Debug7("tscircuit:core:_hasTracesToRoute");
    const traces = this.selectAll("trace");
    debug6(`[${this.getString()}] has ${traces.length} traces to route`);
    return traces.length > 0;
  }
  async _runEffectMakeHttpAutoroutingRequest() {
    const { db } = this.root;
    const debug6 = Debug7("tscircuit:core:_runEffectMakeHttpAutoroutingRequest");
    const props = this._parsedProps;
    const autorouterConfig = this._getAutorouterConfig();
    const serverUrl = autorouterConfig.serverUrl;
    const serverMode = autorouterConfig.serverMode;
    const fetchWithDebug = (url, options) => {
      debug6("fetching", url);
      if (options.headers) {
        options.headers["Tscircuit-Core-Version"] = this.root?.getCoreVersion();
      }
      return fetch(url, options);
    };
    const pcbAndSourceCircuitJson = this.root.db.toArray().filter(
      (element) => {
        return element.type.startsWith("source_") || element.type.startsWith("pcb_");
      }
    );
    if (serverMode === "solve-endpoint") {
      if (this.props.autorouter?.inputFormat === "simplified") {
        const { autorouting_result: autorouting_result2 } = await fetchWithDebug(
          `${serverUrl}/autorouting/solve`,
          {
            method: "POST",
            body: JSON.stringify({
              input_simple_route_json: getSimpleRouteJsonFromCircuitJson({
                db,
                minTraceWidth: this.props.autorouter?.minTraceWidth ?? 0.15,
                subcircuit_id: this.subcircuit_id
              }).simpleRouteJson,
              subcircuit_id: this.subcircuit_id
            }),
            headers: {
              "Content-Type": "application/json"
            }
          }
        ).then((r) => r.json());
        this._asyncAutoroutingResult = autorouting_result2;
        this._markDirty("PcbTraceRender");
        return;
      }
      const { autorouting_result } = await fetchWithDebug(
        `${serverUrl}/autorouting/solve`,
        {
          method: "POST",
          body: JSON.stringify({
            input_circuit_json: pcbAndSourceCircuitJson,
            subcircuit_id: this.subcircuit_id
          }),
          headers: {
            "Content-Type": "application/json"
          }
        }
      ).then((r) => r.json());
      this._asyncAutoroutingResult = autorouting_result;
      this._markDirty("PcbTraceRender");
      return;
    }
    const { autorouting_job } = await fetchWithDebug(
      `${serverUrl}/autorouting/jobs/create`,
      {
        method: "POST",
        body: JSON.stringify({
          input_circuit_json: pcbAndSourceCircuitJson,
          provider: "freerouting",
          autostart: true,
          display_name: this.root?.name,
          subcircuit_id: this.subcircuit_id,
          server_cache_enabled: autorouterConfig.serverCacheEnabled
        }),
        headers: {
          "Content-Type": "application/json"
        }
      }
    ).then((r) => r.json());
    while (true) {
      const { autorouting_job: job } = await fetchWithDebug(
        `${serverUrl}/autorouting/jobs/get`,
        {
          method: "POST",
          body: JSON.stringify({
            autorouting_job_id: autorouting_job.autorouting_job_id
          }),
          headers: { "Content-Type": "application/json" }
        }
      ).then((r) => r.json());
      if (job.is_finished) {
        const { autorouting_job_output } = await fetchWithDebug(
          `${serverUrl}/autorouting/jobs/get_output`,
          {
            method: "POST",
            body: JSON.stringify({
              autorouting_job_id: autorouting_job.autorouting_job_id
            }),
            headers: { "Content-Type": "application/json" }
          }
        ).then((r) => r.json());
        this._asyncAutoroutingResult = {
          output_pcb_traces: autorouting_job_output.output_pcb_traces
        };
        this._markDirty("PcbTraceRender");
        break;
      }
      if (job.has_error) {
        const err = new AutorouterError(
          `Autorouting job failed: ${JSON.stringify(job.error)}`
        );
        db.pcb_autorouting_error.insert({
          pcb_error_id: autorouting_job.autorouting_job_id,
          error_type: "pcb_autorouting_error",
          message: err.message
        });
        throw err;
      }
      await new Promise((resolve) => setTimeout(resolve, 100));
    }
  }
  /**
   * Run local autorouting using the CapacityMeshAutorouter
   */
  async _runLocalAutorouting() {
    const { db } = this.root;
    const props = this._parsedProps;
    const debug6 = Debug7("tscircuit:core:_runLocalAutorouting");
    debug6(`[${this.getString()}] starting local autorouting`);
    const autorouterConfig = this._getAutorouterConfig();
    const { simpleRouteJson } = getSimpleRouteJsonFromCircuitJson({
      db,
      minTraceWidth: this.props.autorouter?.minTraceWidth ?? 0.15,
      subcircuit_id: this.subcircuit_id
    });
    if (debug6.enabled) {
      const graphicsObject = convertSrjToGraphicsObject(
        simpleRouteJson
      );
      graphicsObject.title = `autorouting-${this.props.name}`;
      global.debugGraphics?.push(graphicsObject);
    }
    this.root?.emit("autorouting:start", {
      subcircuit_id: this.subcircuit_id,
      componentDisplayName: this.getString(),
      simpleRouteJson
    });
    let autorouter;
    if (autorouterConfig.algorithmFn) {
      autorouter = await autorouterConfig.algorithmFn(simpleRouteJson);
    } else {
      autorouter = new CapacityMeshAutorouter(simpleRouteJson, {
        // Optional configuration parameters
        capacityDepth: this.props.autorouter?.capacityDepth,
        targetMinCapacity: this.props.autorouter?.targetMinCapacity
      });
    }
    const routingPromise = new Promise(
      (resolve, reject) => {
        autorouter.on("complete", (event) => {
          debug6(`[${this.getString()}] local autorouting complete`);
          resolve(event.traces);
        });
        autorouter.on("error", (event) => {
          debug6(
            `[${this.getString()}] local autorouting error: ${event.error.message}`
          );
          reject(event.error);
        });
      }
    );
    autorouter.on("progress", (event) => {
      this.root?.emit("autorouting:progress", {
        subcircuit_id: this.subcircuit_id,
        componentDisplayName: this.getString(),
        ...event
      });
    });
    autorouter.start();
    try {
      const traces = await routingPromise;
      this._asyncAutoroutingResult = {
        output_pcb_traces: traces
      };
      this._markDirty("PcbTraceRender");
    } catch (error) {
      const { db: db2 } = this.root;
      db2.pcb_autorouting_error.insert({
        pcb_error_id: `pcb_autorouter_error_subcircuit_${this.subcircuit_id}`,
        error_type: "pcb_autorouting_error",
        message: error instanceof Error ? error.message : String(error)
      });
      this.root?.emit("autorouting:error", {
        subcircuit_id: this.subcircuit_id,
        componentDisplayName: this.getString(),
        error: {
          message: error instanceof Error ? error.message : String(error)
        },
        simpleRouteJson
      });
      throw error;
    } finally {
      autorouter.stop();
    }
  }
  _startAsyncAutorouting() {
    if (this._hasStartedAsyncAutorouting) return;
    this._hasStartedAsyncAutorouting = true;
    if (this._getAutorouterConfig().local) {
      this._queueAsyncEffect(
        "capacity-mesh-autorouting",
        async () => this._runLocalAutorouting()
      );
    } else {
      this._queueAsyncEffect(
        "make-http-autorouting-request",
        async () => this._runEffectMakeHttpAutoroutingRequest()
      );
    }
  }
  doInitialPcbTraceRender() {
    const debug6 = Debug7("tscircuit:core:doInitialPcbTraceRender");
    if (!this.isSubcircuit) return;
    if (this.root?.pcbDisabled) return;
    if (this.getInheritedProperty("routingDisabled")) return;
    if (this._shouldUseTraceByTraceRouting()) return;
    if (!this._areChildSubcircuitsRouted()) {
      debug6(
        `[${this.getString()}] child subcircuits are not routed, skipping async autorouting until subcircuits routed`
      );
      return;
    }
    debug6(
      `[${this.getString()}] no child subcircuits to wait for, initiating async routing`
    );
    if (!this._hasTracesToRoute()) return;
    this._startAsyncAutorouting();
  }
  updatePcbTraceRender() {
    const debug6 = Debug7("tscircuit:core:updatePcbTraceRender");
    debug6(`[${this.getString()}] updating...`);
    if (!this.isSubcircuit) return;
    if (this._shouldRouteAsync() && this._hasTracesToRoute() && !this._hasStartedAsyncAutorouting) {
      if (this._areChildSubcircuitsRouted()) {
        debug6(
          `[${this.getString()}] child subcircuits are now routed, starting async autorouting`
        );
        this._startAsyncAutorouting();
      }
      return;
    }
    if (!this._asyncAutoroutingResult) return;
    if (this._shouldUseTraceByTraceRouting()) return;
    const { db } = this.root;
    if (this._asyncAutoroutingResult.output_simple_route_json) {
      debug6(
        `[${this.getString()}] updating PCB traces from simple route json (${this._asyncAutoroutingResult.output_simple_route_json.traces?.length} traces)`
      );
      this._updatePcbTraceRenderFromSimpleRouteJson();
      return;
    }
    if (this._asyncAutoroutingResult.output_pcb_traces) {
      debug6(
        `[${this.getString()}] updating PCB traces from ${this._asyncAutoroutingResult.output_pcb_traces.length} traces`
      );
      this._updatePcbTraceRenderFromPcbTraces();
      return;
    }
  }
  _updatePcbTraceRenderFromSimpleRouteJson() {
    const { db } = this.root;
    const { traces: routedTraces } = this._asyncAutoroutingResult.output_simple_route_json;
    if (!routedTraces) return;
    for (const routedTrace of routedTraces) {
      const pcb_trace = db.pcb_trace.insert({
        subcircuit_id: this.subcircuit_id,
        route: routedTrace.route
        // source_trace_id: circuitTrace.source_trace_id!,
      });
    }
  }
  _updatePcbTraceRenderFromPcbTraces() {
    const { output_pcb_traces } = this._asyncAutoroutingResult;
    if (!output_pcb_traces) return;
    const { db } = this.root;
    for (const pcb_trace of output_pcb_traces) {
      if (pcb_trace.type !== "pcb_trace") continue;
      pcb_trace.subcircuit_id = this.subcircuit_id;
      if (pcb_trace.connection_name) {
        const sourceTraceId = pcb_trace.connection_name;
        pcb_trace.source_trace_id = sourceTraceId;
      }
      db.pcb_trace.insert(pcb_trace);
    }
    for (const pcb_trace of output_pcb_traces) {
      if (pcb_trace.type === "pcb_via") {
        continue;
      }
      if (pcb_trace.type === "pcb_trace") {
        for (const point of pcb_trace.route) {
          if (point.route_type === "via") {
            db.pcb_via.insert({
              pcb_trace_id: pcb_trace.pcb_trace_id,
              x: point.x,
              y: point.y,
              hole_diameter: 0.3,
              outer_diameter: 0.6,
              layers: [
                point.from_layer,
                point.to_layer
              ],
              from_layer: point.from_layer,
              to_layer: point.to_layer
            });
          }
        }
      }
    }
  }
  doInitialSchematicComponentRender() {
    if (this.root?.schematicDisabled) return;
    const { db } = this.root;
    const { _parsedProps: props } = this;
    const schematic_group = db.schematic_group.insert({
      is_subcircuit: this.isSubcircuit,
      subcircuit_id: this.subcircuit_id,
      name: this.name,
      center: this._getGlobalSchematicPositionBeforeLayout(),
      width: 0,
      height: 0,
      schematic_component_ids: [],
      source_group_id: this.source_group_id
    });
    this.schematic_group_id = schematic_group.schematic_group_id;
    for (const child of this.children) {
      if (child.schematic_component_id) {
        db.schematic_component.update(child.schematic_component_id, {
          schematic_group_id: schematic_group.schematic_group_id
        });
      }
    }
  }
  _getSchematicLayoutMode() {
    const props = this._parsedProps;
    if (props.schLayout?.layoutMode === "none") return "relative";
    if (props.schLayout?.layoutMode === "relative") return "relative";
    if (props.schLayout?.matchAdapt) return "match-adapt";
    if (props.schLayout?.flex) return "flex";
    if (props.schLayout?.grid) return "grid";
    if (props.matchAdapt) return "match-adapt";
    if (props.flex) return "flex";
    if (props.grid) return "grid";
    if (props.relative) return "relative";
    if (props.schRelative) return "relative";
    const anyChildHasSchCoords = this.children.some((child) => {
      const cProps = child._parsedProps;
      return cProps?.schX !== void 0 || cProps?.schY !== void 0;
    });
    const anyChildIsGroup = this.children.some((child) => child.isGroup);
    const hasManualEdits = (props.manualEdits?.schematic_placements?.length ?? 0) > 0;
    if (!anyChildHasSchCoords && !hasManualEdits && !anyChildIsGroup)
      return "match-adapt";
    return "relative";
  }
  doInitialSchematicLayout() {
    const props = this._parsedProps;
    const schematicLayoutMode = this._getSchematicLayoutMode();
    if (schematicLayoutMode === "match-adapt") {
      this._doInitialSchematicLayoutMatchAdapt();
    }
    if (schematicLayoutMode === "grid") {
      this._doInitialSchematicLayoutGrid();
    }
    this._insertSchematicBorder();
  }
  _doInitialSchematicLayoutMatchAdapt() {
    Group_doInitialSchematicLayoutMatchAdapt(this);
  }
  _doInitialSchematicLayoutGrid() {
    Group_doInitialSchematicLayoutGrid(this);
  }
  _getPcbLayoutMode() {
    const props = this._parsedProps;
    if (props.pcbLayout?.matchAdapt) return "match-adapt";
    if (props.pcbLayout?.flex) return "flex";
    if (props.pcbLayout?.grid) return "grid";
    if (props.pcbLayout?.pack) return "pack";
    if (props.matchAdapt) return "match-adapt";
    if (props.flex) return "flex";
    if (props.grid) return "grid";
    if (props.pack) return "pack";
    return "none";
  }
  doInitialPcbLayout() {
    const pcbLayoutMode = this._getPcbLayoutMode();
    if (pcbLayoutMode === "grid") {
      this._doInitialPcbLayoutGrid();
    } else if (pcbLayoutMode === "pack") {
      this._doInitialPcbLayoutPack();
    } else if (pcbLayoutMode === "flex") {
      this._doInitialPcbLayoutFlex();
    }
  }
  _doInitialPcbLayoutGrid() {
    Group_doInitialPcbLayoutGrid(this);
  }
  _doInitialPcbLayoutPack() {
    Group_doInitialPcbLayoutPack(this);
  }
  _doInitialPcbLayoutFlex() {
    Group_doInitialPcbLayoutFlex(this);
  }
  _insertSchematicBorder() {
    if (this.root?.schematicDisabled) return;
    const { db } = this.root;
    const props = this._parsedProps;
    if (!props.border) return;
    let width = typeof props.schWidth === "number" ? props.schWidth : void 0;
    let height = typeof props.schHeight === "number" ? props.schHeight : void 0;
    const paddingGeneral = typeof props.schPadding === "number" ? props.schPadding : 0;
    const paddingLeft = typeof props.schPaddingLeft === "number" ? props.schPaddingLeft : paddingGeneral;
    const paddingRight = typeof props.schPaddingRight === "number" ? props.schPaddingRight : paddingGeneral;
    const paddingTop = typeof props.schPaddingTop === "number" ? props.schPaddingTop : paddingGeneral;
    const paddingBottom = typeof props.schPaddingBottom === "number" ? props.schPaddingBottom : paddingGeneral;
    const schematicGroup = this.schematic_group_id ? db.schematic_group.get(this.schematic_group_id) : null;
    if (schematicGroup) {
      if (width === void 0 && typeof schematicGroup.width === "number") {
        width = schematicGroup.width;
      }
      if (height === void 0 && typeof schematicGroup.height === "number") {
        height = schematicGroup.height;
      }
    }
    if (width === void 0 || height === void 0) return;
    const center = schematicGroup?.center ?? this._getGlobalSchematicPositionBeforeLayout();
    const left = center.x - width / 2 - paddingLeft;
    const bottom = center.y - height / 2 - paddingBottom;
    const finalWidth = width + paddingLeft + paddingRight;
    const finalHeight = height + paddingTop + paddingBottom;
    db.schematic_box.insert({
      width: finalWidth,
      height: finalHeight,
      x: left,
      y: bottom,
      is_dashed: props.border?.dashed ?? false
    });
  }
  _determineSideFromPosition(port, component) {
    if (!port.center || !component.center) return "left";
    const dx = port.center.x - component.center.x;
    const dy = port.center.y - component.center.y;
    if (Math.abs(dx) > Math.abs(dy)) {
      return dx > 0 ? "right" : "left";
    }
    return dy > 0 ? "bottom" : "top";
  }
  _calculateSchematicBounds(boxes) {
    if (boxes.length === 0) {
      return { minX: 0, maxX: 0, minY: 0, maxY: 0 };
    }
    let minX = Infinity;
    let maxX = -Infinity;
    let minY = Infinity;
    let maxY = -Infinity;
    for (const box of boxes) {
      minX = Math.min(minX, box.centerX);
      maxX = Math.max(maxX, box.centerX);
      minY = Math.min(minY, box.centerY);
      maxY = Math.max(maxY, box.centerY);
    }
    const padding = 2;
    return {
      minX: minX - padding,
      maxX: maxX + padding,
      minY: minY - padding,
      maxY: maxY + padding
    };
  }
  _getAutorouterConfig() {
    const autorouter = this._parsedProps.autorouter || this.getInheritedProperty("autorouter");
    return getPresetAutoroutingConfig(autorouter);
  }
  /**
   * Trace-by-trace autorouting is where each trace routes itself in a well-known
   * order. It's the most deterministic way to autoroute, because a new trace
   * is generally ordered last.
   *
   * This method will return false if using an external service for autorouting
   * or if using a "fullview" or "rip and replace" autorouting mode
   */
  _shouldUseTraceByTraceRouting() {
    const autorouter = this._getAutorouterConfig();
    return autorouter.groupMode === "sequential-trace";
  }
  doInitialPcbDesignRuleChecks() {
    if (this.root?.pcbDisabled) return;
    if (this.getInheritedProperty("routingDisabled")) return;
    const { db } = this.root;
    if (this.isSubcircuit) {
      const subcircuitComponentsByName = /* @__PURE__ */ new Map();
      for (const child of this.children) {
        if (child.isSubcircuit) continue;
        if (child._parsedProps.name) {
          const components = subcircuitComponentsByName.get(child._parsedProps.name) || [];
          components.push(child);
          subcircuitComponentsByName.set(child._parsedProps.name, components);
        }
      }
      for (const [name, components] of subcircuitComponentsByName.entries()) {
        if (components.length > 1) {
          db.pcb_trace_error.insert({
            error_type: "pcb_trace_error",
            message: `Multiple components found with name "${name}" in subcircuit "${this.name || "unnamed"}". Component names must be unique within a subcircuit.`,
            source_trace_id: "",
            pcb_trace_id: "",
            pcb_component_ids: components.map((c) => c.pcb_component_id).filter(Boolean),
            pcb_port_ids: []
          });
        }
      }
    }
  }
  doInitialSchematicReplaceNetLabelsWithSymbols() {
    if (this.root?.schematicDisabled) return;
    if (!this.isSubcircuit) return;
    const { db } = this.root;
    const subtree = db;
    for (const nl of subtree.schematic_net_label.list()) {
      const net = subtree.source_net.get(nl.source_net_id);
      const text = nl.text || net?.name || "";
      if (nl.anchor_side === "top" && /^gnd/i.test(text)) {
        subtree.schematic_net_label.update(nl.schematic_net_label_id, {
          symbol_name: "ground_down"
        });
        continue;
      }
      if (nl.anchor_side === "bottom" && /^v/i.test(text)) {
        subtree.schematic_net_label.update(nl.schematic_net_label_id, {
          symbol_name: "vcc_up"
        });
      }
    }
  }
};

// lib/components/normal-components/Board.ts
import { checkEachPcbTraceNonOverlapping } from "@tscircuit/checks";
var Board = class extends Group {
  pcb_board_id = null;
  _drcChecksComplete = false;
  _connectedSchematicPortPairs = /* @__PURE__ */ new Set();
  get isSubcircuit() {
    return true;
  }
  get isGroup() {
    return true;
  }
  get config() {
    return {
      componentName: "Board",
      zodProps: boardProps
    };
  }
  get boardThickness() {
    const { _parsedProps: props } = this;
    return 1.4;
  }
  /**
   * Get all available layers for the board
   */
  get allLayers() {
    return ["top", "bottom", "inner1", "inner2"];
  }
  doInitialPcbBoardAutoSize() {
    if (this.root?.pcbDisabled) return;
    if (!this.pcb_board_id) return;
    const { db } = this.root;
    const { _parsedProps: props } = this;
    if (props.width && props.height) return;
    let minX = Infinity;
    let minY = Infinity;
    let maxX = -Infinity;
    let maxY = -Infinity;
    const allPcbComponents = db.pcb_component.list();
    let hasComponents = false;
    for (const pcbComponent of allPcbComponents) {
      const { width, height, center: center2 } = pcbComponent;
      if (width === 0 || height === 0) continue;
      hasComponents = true;
      minX = Math.min(minX, center2.x - width / 2);
      minY = Math.min(minY, center2.y - height / 2);
      maxX = Math.max(maxX, center2.x + width / 2);
      maxY = Math.max(maxY, center2.y + height / 2);
    }
    const padding = 2;
    const computedWidth = hasComponents ? maxX - minX + padding * 2 : 0;
    const computedHeight = hasComponents ? maxY - minY + padding * 2 : 0;
    const center = {
      x: hasComponents ? (minX + maxX) / 2 + (props.outlineOffsetX ?? 0) : props.outlineOffsetX ?? 0,
      y: hasComponents ? (minY + maxY) / 2 + (props.outlineOffsetY ?? 0) : props.outlineOffsetY ?? 0
    };
    const finalWidth = props.width ?? computedWidth;
    const finalHeight = props.height ?? computedHeight;
    db.pcb_board.update(this.pcb_board_id, {
      width: finalWidth,
      height: finalHeight,
      center
    });
  }
  /**
   * Update the board information silkscreen text if platform config is set and
   * the project name, version, or url is set.
   */
  _addBoardInformationToSilkscreen() {
    const platform = this.root?.platform;
    if (!platform?.printBoardInformationToSilkscreen) return;
    const pcbBoard = this.root.db.pcb_board.get(this.pcb_board_id);
    if (!pcbBoard) return;
    const boardInformation = [];
    if (platform.projectName) boardInformation.push(platform.projectName);
    if (platform.version) boardInformation.push(`v${platform.version}`);
    if (platform.url) boardInformation.push(platform.url);
    if (boardInformation.length === 0) return;
    const text = boardInformation.join("\n");
    const marginX = 0.25;
    const marginY = 1;
    const position = {
      x: pcbBoard.center.x + pcbBoard.width / 2 - marginX,
      y: pcbBoard.center.y - pcbBoard.height / 2 + marginY
    };
    this.root.db.pcb_silkscreen_text.insert({
      pcb_component_id: this.pcb_board_id,
      layer: "top",
      font: "tscircuit2024",
      font_size: 0.45,
      text,
      ccw_rotation: 0,
      anchor_alignment: "bottom_right",
      anchor_position: position
    });
  }
  doInitialPcbComponentRender() {
    if (this.root?.pcbDisabled) return;
    const { db } = this.root;
    const { _parsedProps: props } = this;
    let computedWidth = props.width ?? 0;
    let computedHeight = props.height ?? 0;
    let center = {
      x: (props.pcbX ?? 0) + (props.outlineOffsetX ?? 0),
      y: (props.pcbY ?? 0) + (props.outlineOffsetY ?? 0)
    };
    if (props.outline) {
      const xValues = props.outline.map((point) => point.x);
      const yValues = props.outline.map((point) => point.y);
      const minX = Math.min(...xValues);
      const maxX = Math.max(...xValues);
      const minY = Math.min(...yValues);
      const maxY = Math.max(...yValues);
      computedWidth = maxX - minX;
      computedHeight = maxY - minY;
      center = {
        x: (minX + maxX) / 2 + (props.outlineOffsetX ?? 0),
        y: (minY + maxY) / 2 + (props.outlineOffsetY ?? 0)
      };
    }
    const pcb_board = db.pcb_board.insert({
      center,
      thickness: this.boardThickness,
      num_layers: this.allLayers.length,
      width: computedWidth,
      height: computedHeight,
      outline: props.outline?.map((point) => ({
        x: point.x + (props.outlineOffsetX ?? 0),
        y: point.y + (props.outlineOffsetY ?? 0)
      })),
      material: props.material
    });
    this.pcb_board_id = pcb_board.pcb_board_id;
    this._addBoardInformationToSilkscreen();
  }
  removePcbComponentRender() {
    const { db } = this.root;
    if (!this.pcb_board_id) return;
    db.pcb_board.delete(this.pcb_board_id);
    this.pcb_board_id = null;
  }
  _computePcbGlobalTransformBeforeLayout() {
    return identity3();
  }
  doInitialPcbDesignRuleChecks() {
    if (this.root?.pcbDisabled) return;
    if (this.getInheritedProperty("routingDisabled")) return;
    super.doInitialPcbDesignRuleChecks();
  }
  updatePcbDesignRuleChecks() {
    if (this.root?.pcbDisabled) return;
    if (this.getInheritedProperty("routingDisabled")) return;
    const { db } = this.root;
    if (!this._areChildSubcircuitsRouted()) return;
    if (this._drcChecksComplete) return;
    this._drcChecksComplete = true;
    const errors = checkEachPcbTraceNonOverlapping(db.toArray());
    for (const error of errors) {
      db.pcb_trace_error.insert(error);
    }
  }
  _emitRenderLifecycleEvent(phase, startOrEnd) {
    super._emitRenderLifecycleEvent(phase, startOrEnd);
    if (startOrEnd === "start") {
      this.root?.emit("board:renderPhaseStarted", {
        renderId: this._renderId,
        phase
      });
    }
  }
};

// lib/components/normal-components/Capacitor.ts
import { capacitorProps } from "@tscircuit/props";

// lib/utils/constants.ts
var stringProxy = new Proxy(
  {},
  {
    get: (target, prop) => prop
  }
);
var FTYPE = stringProxy;

// lib/components/normal-components/Capacitor.ts
import { formatSiUnit } from "format-si-unit";
var Capacitor = class extends NormalComponent {
  // @ts-ignore (cause the symbolName is string and not fixed)
  get config() {
    return {
      componentName: "Capacitor",
      schematicSymbolName: this.props.polarized ? "capacitor_polarized" : this.props.symbolName ?? "capacitor",
      zodProps: capacitorProps,
      sourceFtype: FTYPE.simple_capacitor
    };
  }
  _getSchematicSymbolDisplayValue() {
    const capacitanceDisplay = `${formatSiUnit(this._parsedProps.capacitance)}F`;
    if (this._parsedProps.schShowRatings && this._parsedProps.maxVoltageRating) {
      return `${capacitanceDisplay}/${formatSiUnit(this._parsedProps.maxVoltageRating)}V`;
    }
    return capacitanceDisplay;
  }
  doInitialCreateNetsFromProps() {
    this._createNetsFromProps([
      this.props.decouplingFor,
      this.props.decouplingTo,
      ...this._getNetsFromConnectionsProp()
    ]);
  }
  doInitialCreateTracesFromProps() {
    if (this.props.decouplingFor && this.props.decouplingTo) {
      this.add(
        new Trace3({
          from: `${this.getSubcircuitSelector()} > port.1`,
          to: this.props.decouplingFor
        })
      );
      this.add(
        new Trace3({
          from: `${this.getSubcircuitSelector()} > port.2`,
          to: this.props.decouplingTo
        })
      );
    }
    this._createTracesFromConnectionsProp();
  }
  doInitialSourceRender() {
    const { db } = this.root;
    const { _parsedProps: props } = this;
    const source_component = db.source_component.insert({
      ftype: "simple_capacitor",
      name: this.name,
      // @ts-ignore
      manufacturer_part_number: props.manufacturerPartNumber ?? props.mfn,
      supplier_part_numbers: props.supplierPartNumbers,
      capacitance: props.capacitance,
      max_voltage_rating: props.maxVoltageRating,
      max_decoupling_trace_length: props.maxDecouplingTraceLength,
      display_capacitance: this._getSchematicSymbolDisplayValue(),
      are_pins_interchangeable: !props.polarized
    });
    this.source_component_id = source_component.source_component_id;
  }
};

// lib/components/normal-components/Chip.ts
import { chipProps } from "@tscircuit/props";
var Chip = class extends NormalComponent {
  schematicBoxDimensions = null;
  get config() {
    return {
      componentName: "Chip",
      zodProps: chipProps,
      shouldRenderAsSchematicBox: true
    };
  }
  doInitialSchematicComponentRender() {
    const { _parsedProps: props } = this;
    if (props?.noSchematicRepresentation === true) return;
    super.doInitialSchematicComponentRender();
  }
  doInitialSourceRender() {
    const { db } = this.root;
    const { _parsedProps: props } = this;
    const source_component = db.source_component.insert({
      ftype: "simple_chip",
      name: this.name,
      manufacturer_part_number: props.manufacturerPartNumber,
      supplier_part_numbers: props.supplierPartNumbers
    });
    this.source_component_id = source_component.source_component_id;
  }
  doInitialPcbComponentRender() {
    if (this.root?.pcbDisabled) return;
    const { db } = this.root;
    const { _parsedProps: props } = this;
    const pcb_component = db.pcb_component.insert({
      center: { x: props.pcbX ?? 0, y: props.pcbY ?? 0 },
      width: 2,
      // Default width, adjust as needed
      height: 3,
      // Default height, adjust as needed
      layer: props.layer ?? "top",
      rotation: props.pcbRotation ?? 0,
      source_component_id: this.source_component_id,
      subcircuit_id: this.getSubcircuit().subcircuit_id ?? void 0
    });
    this.pcb_component_id = pcb_component.pcb_component_id;
  }
  doInitialCreateTracesFromProps() {
    const { _parsedProps: props } = this;
    if (props.externallyConnectedPins) {
      for (const [pin1, pin2] of props.externallyConnectedPins) {
        this.add(
          new Trace3({
            from: `${this.getSubcircuitSelector()} > port.${pin1}`,
            to: `${this.getSubcircuitSelector()} > port.${pin2}`
          })
        );
      }
    }
    this._createTracesFromConnectionsProp();
  }
};

// lib/components/normal-components/Diode.ts
import { diodeProps } from "@tscircuit/props";
var Diode = class extends NormalComponent {
  // @ts-ignore
  get config() {
    const symbolMap = {
      schottky: "schottky_diode",
      avalanche: "avalanche_diode",
      zener: "zener_diode",
      photodiode: "photodiode"
    };
    const variantSymbol = this.props.schottky ? "schottky" : this.props.avalanche ? "avalanche" : this.props.zener ? "zener" : this.props.photo ? "photodiode" : null;
    return {
      schematicSymbolName: variantSymbol ? symbolMap[variantSymbol] : this.props.symbolName ?? "diode",
      componentName: "Diode",
      zodProps: diodeProps,
      sourceFtype: "simple_diode"
    };
  }
  initPorts() {
    super.initPorts({
      additionalAliases: {
        pin1: ["anode", "pos", "left"],
        pin2: ["cathode", "neg", "right"]
      }
    });
  }
  doInitialSourceRender() {
    const { db } = this.root;
    const { _parsedProps: props } = this;
    const source_component = db.source_component.insert({
      ftype: "simple_diode",
      name: this.name,
      // @ts-ignore
      manufacturer_part_number: props.manufacturerPartNumber ?? props.mfn,
      supplier_part_numbers: props.supplierPartNumbers,
      are_pins_interchangeable: false
    });
    this.source_component_id = source_component.source_component_id;
  }
  pos = this.portMap.pin1;
  anode = this.portMap.pin1;
  neg = this.portMap.pin2;
  cathode = this.portMap.pin2;
};

// lib/components/normal-components/Fuse.ts
import { fuseProps } from "@tscircuit/props";
import { formatSiUnit as formatSiUnit2 } from "format-si-unit";
var Fuse = class extends NormalComponent {
  get config() {
    return {
      componentName: "fuse",
      schematicSymbolName: this.props.symbolName ?? "fuse",
      zodProps: fuseProps,
      sourceFtype: FTYPE.simple_fuse
    };
  }
  _getSchematicSymbolDisplayValue() {
    const rawCurrent = this._parsedProps.currentRating;
    const rawVoltage = this._parsedProps.voltageRating;
    const current = typeof rawCurrent === "string" ? parseFloat(rawCurrent) : rawCurrent;
    const voltage = typeof rawVoltage === "string" ? parseFloat(rawVoltage) : rawVoltage;
    return `${formatSiUnit2(current)}A / ${formatSiUnit2(voltage)}V`;
  }
  doInitialSourceRender() {
    const { db } = this.root;
    const { _parsedProps: props } = this;
    const currentRating = typeof props.currentRating === "string" ? parseFloat(props.currentRating) : props.currentRating;
    const voltageRating = typeof props.voltageRating === "string" ? parseFloat(props.voltageRating) : props.voltageRating;
    const source_component = db.source_component.insert({
      name: this.name,
      ftype: FTYPE.simple_fuse,
      current_rating_amps: currentRating,
      voltage_rating_volts: voltageRating,
      display_current_rating: `${formatSiUnit2(currentRating)}A`,
      display_voltage_rating: `${formatSiUnit2(voltageRating)}V`
    });
    this.source_component_id = source_component.source_component_id;
  }
};

// lib/components/normal-components/Jumper.ts
import { jumperProps } from "@tscircuit/props";
var Jumper = class extends NormalComponent {
  schematicDimensions = null;
  get config() {
    return {
      schematicSymbolName: void 0,
      componentName: "Jumper",
      zodProps: jumperProps,
      shouldRenderAsSchematicBox: true
    };
  }
  _getSchematicPortArrangement() {
    const arrangement = super._getSchematicPortArrangement();
    if (arrangement && Object.keys(arrangement).length > 0) return arrangement;
    const pinCount = this._parsedProps.pinCount ?? (Array.isArray(this._parsedProps.pinLabels) ? this._parsedProps.pinLabels.length : this._parsedProps.pinLabels ? Object.keys(this._parsedProps.pinLabels).length : this.getPortsFromFootprint().length);
    const direction = this._parsedProps.schDirection ?? "right";
    return {
      leftSize: direction === "left" ? pinCount : 0,
      rightSize: direction === "right" ? pinCount : 0
    };
  }
  doInitialSourceRender() {
    const { db } = this.root;
    const { _parsedProps: props } = this;
    const source_component = db.source_component.insert({
      ftype: "simple_chip",
      // TODO unknown or jumper
      name: this.name,
      manufacturer_part_number: props.manufacturerPartNumber,
      supplier_part_numbers: props.supplierPartNumbers,
      are_pins_interchangeable: true
    });
    this.source_component_id = source_component.source_component_id;
  }
  doInitialPcbComponentRender() {
    if (this.root?.pcbDisabled) return;
    const { db } = this.root;
    const { _parsedProps: props } = this;
    const pcb_component = db.pcb_component.insert({
      center: { x: props.pcbX ?? 0, y: props.pcbY ?? 0 },
      width: 2,
      // Default width, adjust as needed
      height: 3,
      // Default height, adjust as needed
      layer: props.layer ?? "top",
      rotation: props.pcbRotation ?? 0,
      source_component_id: this.source_component_id,
      subcircuit_id: this.getSubcircuit().subcircuit_id ?? void 0
    });
    this.pcb_component_id = pcb_component.pcb_component_id;
  }
  doInitialPcbTraceRender() {
    const { db } = this.root;
    const pcb_ports = db.pcb_port.list({
      pcb_component_id: this.pcb_component_id
    });
    const pinLabelToPortId = {};
    for (let i = 0; i < pcb_ports.length; i++) {
      const port = pcb_ports[i];
      const sourcePort = db.source_port.get(port.source_port_id);
      let pinLabel = "";
      if (typeof sourcePort?.pin_number === "number") {
        pinLabel = sourcePort.pin_number.toString();
      } else if (Array.isArray(sourcePort?.port_hints)) {
        let matchedHint = sourcePort.port_hints.find(
          (h) => /^(pin)?\d+$/.test(h)
        );
        if (matchedHint) {
          if (/^pin\d+$/.test(matchedHint)) {
            pinLabel = matchedHint.replace(/^pin/, "");
          } else {
            pinLabel = matchedHint;
          }
        }
      }
      pinLabelToPortId[pinLabel] = port.pcb_port_id;
    }
    const traces = db.pcb_trace.list({
      pcb_component_id: this.pcb_component_id
    });
    const updatePortId = (portId) => {
      if (portId && typeof portId === "string" && portId.startsWith("{PIN")) {
        const pin = portId.replace("{PIN", "").replace("}", "");
        return pinLabelToPortId[pin] || portId;
      }
      return portId;
    };
    for (const trace of traces) {
      if (!trace.route) continue;
      for (const segment of trace.route) {
        if (segment.route_type !== "wire") continue;
        segment.start_pcb_port_id = updatePortId(segment.start_pcb_port_id);
        segment.end_pcb_port_id = updatePortId(segment.end_pcb_port_id);
      }
    }
  }
};

// lib/components/normal-components/SolderJumper.ts
import { solderjumperProps } from "@tscircuit/props";
var SolderJumper = class extends NormalComponent {
  schematicDimensions = null;
  _getPinNumberFromBridgedPinName(pinName) {
    const port = this.selectOne(`port.${pinName}`, {
      type: "port"
    });
    return port?._parsedProps.pinNumber ?? null;
  }
  get defaultInternallyConnectedPinNames() {
    if (this._parsedProps.bridged) {
      const pins = this.children.filter((c) => c.componentName === "Port").map((p) => p.name);
      return pins.length > 0 ? [pins] : [];
    }
    return this._parsedProps.bridgedPins ?? [];
  }
  get config() {
    const props = this._parsedProps ?? this.props;
    let resolvedPinCount = props.pinCount;
    if (props.pinCount == null && !props.footprint) {
      resolvedPinCount = 2;
    }
    if (props.pinCount == null) {
      const nums = (props.bridgedPins ?? []).flat().map((p_str) => this._getPinNumberFromBridgedPinName(p_str)).filter((n) => n !== null);
      const maxPinFromBridged = nums.length > 0 ? Math.max(...nums) : 0;
      const pinCountFromLabels = props.pinLabels ? Object.keys(props.pinLabels).length : 0;
      const finalPinCount = Math.max(maxPinFromBridged, pinCountFromLabels);
      if (finalPinCount === 2 || finalPinCount === 3) {
        resolvedPinCount = finalPinCount;
      }
      if (resolvedPinCount == null && props.footprint && [2, 3].includes(this.getPortsFromFootprint().length)) {
        resolvedPinCount = this.getPortsFromFootprint().length;
      }
    }
    let symbolName = "";
    if (resolvedPinCount) {
      symbolName += `solderjumper${resolvedPinCount}`;
    } else {
      symbolName = "solderjumper";
    }
    let bridgedPinNumbers = [];
    if (Array.isArray(props.bridgedPins) && props.bridgedPins.length > 0) {
      bridgedPinNumbers = Array.from(
        new Set(
          props.bridgedPins.flat().map((pinName) => this._getPinNumberFromBridgedPinName(pinName)).filter((n) => n !== null)
        )
      ).sort((a, b) => a - b);
    } else if (props.bridged && resolvedPinCount) {
      bridgedPinNumbers = Array.from(
        { length: resolvedPinCount },
        (_, i) => i + 1
      );
    }
    if (bridgedPinNumbers.length > 0) {
      symbolName += `_bridged${bridgedPinNumbers.join("")}`;
    }
    return {
      schematicSymbolName: props.symbolName ?? symbolName,
      componentName: "SolderJumper",
      zodProps: solderjumperProps,
      shouldRenderAsSchematicBox: true
    };
  }
  _getSchematicPortArrangement() {
    const arrangement = super._getSchematicPortArrangement();
    if (arrangement && Object.keys(arrangement).length > 0) return arrangement;
    let pinCount = this._parsedProps.pinCount ?? (Array.isArray(this._parsedProps.pinLabels) ? this._parsedProps.pinLabels.length : this._parsedProps.pinLabels ? Object.keys(this._parsedProps.pinLabels).length : this.getPortsFromFootprint().length);
    if (pinCount == null && !this._parsedProps.footprint) {
      pinCount = 2;
    }
    const direction = this._parsedProps.schDirection ?? "right";
    return {
      leftSize: direction === "left" ? pinCount : 0,
      rightSize: direction === "right" ? pinCount : 0
    };
  }
  doInitialSourceRender() {
    const { db } = this.root;
    const { _parsedProps: props } = this;
    const source_component = db.source_component.insert({
      ftype: "simple_chip",
      // TODO unknown or jumper
      name: this.name,
      manufacturer_part_number: props.manufacturerPartNumber,
      supplier_part_numbers: props.supplierPartNumbers,
      are_pins_interchangeable: true
    });
    this.source_component_id = source_component.source_component_id;
  }
  doInitialPcbComponentRender() {
    if (this.root?.pcbDisabled) return;
    const { db } = this.root;
    const { _parsedProps: props } = this;
    const pcb_component = db.pcb_component.insert({
      center: { x: props.pcbX ?? 0, y: props.pcbY ?? 0 },
      width: 2,
      // Default width, adjust as needed
      height: 3,
      // Default height, adjust as needed
      layer: props.layer ?? "top",
      rotation: props.pcbRotation ?? 0,
      source_component_id: this.source_component_id,
      subcircuit_id: this.getSubcircuit().subcircuit_id ?? void 0
    });
    this.pcb_component_id = pcb_component.pcb_component_id;
  }
  doInitialPcbTraceRender() {
    const { db } = this.root;
    const pcb_ports = db.pcb_port.list({
      pcb_component_id: this.pcb_component_id
    });
    const pinLabelToPortId = {};
    for (let i = 0; i < pcb_ports.length; i++) {
      const port = pcb_ports[i];
      const sourcePort = db.source_port.get(port.source_port_id);
      let pinLabel = "";
      if (typeof sourcePort?.pin_number === "number") {
        pinLabel = sourcePort.pin_number.toString();
      } else if (Array.isArray(sourcePort?.port_hints)) {
        let matchedHint = sourcePort.port_hints.find(
          (h) => /^(pin)?\d+$/.test(h)
        );
        if (matchedHint) {
          if (/^pin\d+$/.test(matchedHint)) {
            pinLabel = matchedHint.replace(/^pin/, "");
          } else {
            pinLabel = matchedHint;
          }
        }
      }
      pinLabelToPortId[pinLabel] = port.pcb_port_id;
    }
    const traces = db.pcb_trace.list({
      pcb_component_id: this.pcb_component_id
    });
    const updatePortId = (portId) => {
      if (portId && typeof portId === "string" && portId.startsWith("{PIN")) {
        const pin = portId.replace("{PIN", "").replace("}", "");
        return pinLabelToPortId[pin] || portId;
      }
      return portId;
    };
    for (const trace of traces) {
      if (!trace.route) continue;
      for (const segment of trace.route) {
        if (segment.route_type !== "wire") continue;
        segment.start_pcb_port_id = updatePortId(segment.start_pcb_port_id);
        segment.end_pcb_port_id = updatePortId(segment.end_pcb_port_id);
      }
    }
  }
};

// lib/components/normal-components/Led.ts
import { ledProps } from "@tscircuit/props";
var Led = class extends NormalComponent {
  get config() {
    const symbolMap = {
      laser: "laser_diode"
    };
    const variantSymbol = this.props.laser ? "laser" : null;
    return {
      schematicSymbolName: variantSymbol ? symbolMap[variantSymbol] : this.props.symbolName ?? "led",
      componentName: "Led",
      zodProps: ledProps,
      sourceFtype: "simple_led"
    };
  }
  initPorts() {
    super.initPorts({
      additionalAliases: {
        pin1: ["anode", "pos", "left"],
        pin2: ["cathode", "neg", "right"]
      }
    });
  }
  _getSchematicSymbolDisplayValue() {
    return this._parsedProps.schDisplayValue || this._parsedProps.color || void 0;
  }
  doInitialSourceRender() {
    const { db } = this.root;
    const { _parsedProps: props } = this;
    const source_component = db.source_component.insert({
      ftype: "simple_led",
      name: this.name,
      wave_length: props.wavelength,
      color: props.color,
      symbol_display_value: this._getSchematicSymbolDisplayValue(),
      // @ts-ignore
      manufacturer_part_number: props.manufacturerPartNumber ?? props.mfn,
      supplier_part_numbers: props.supplierPartNumbers,
      are_pins_interchangeable: false
    });
    this.source_component_id = source_component.source_component_id;
  }
  pos = this.portMap.pin1;
  anode = this.portMap.pin1;
  neg = this.portMap.pin2;
  cathode = this.portMap.pin2;
};

// lib/components/normal-components/PowerSource.ts
import { powerSourceProps } from "@tscircuit/props";
var PowerSource = class extends NormalComponent {
  // @ts-ignore
  get config() {
    return {
      // TBD in schematic_symbol and replace then
      schematicSymbolName: this.props.symbolName ?? "power_factor_meter_horz",
      componentName: "PowerSource",
      zodProps: powerSourceProps,
      sourceFtype: "simple_power_source"
    };
  }
  initPorts() {
    this.add(
      new Port({ name: "pin1", pinNumber: 1, aliases: ["positive", "pos"] })
    );
    this.add(
      new Port({ name: "pin2", pinNumber: 2, aliases: ["negative", "neg"] })
    );
  }
  doInitialSourceRender() {
    const { db } = this.root;
    const { _parsedProps: props } = this;
    const source_component = db.source_component.insert({
      ftype: "simple_power_source",
      name: this.name,
      voltage: props.voltage,
      supplier_part_numbers: props.supplierPartNumbers,
      are_pins_interchangeable: false
    });
    this.source_component_id = source_component.source_component_id;
  }
  pos = this.portMap.pin1;
  positive = this.portMap.pin1;
  neg = this.portMap.pin2;
  negative = this.portMap.pin2;
};

// lib/components/normal-components/Resistor.ts
import { resistorProps } from "@tscircuit/props";
import { formatSiUnit as formatSiUnit3 } from "format-si-unit";
var Resistor = class extends NormalComponent {
  get config() {
    return {
      componentName: "Resistor",
      schematicSymbolName: this.props.symbolName ?? "boxresistor",
      zodProps: resistorProps,
      sourceFtype: "simple_resistor"
    };
  }
  initPorts() {
    super.initPorts({
      additionalAliases: {
        pin1: ["anode", "pos", "left"],
        pin2: ["cathode", "neg", "right"]
      }
    });
  }
  _getSchematicSymbolDisplayValue() {
    return `${formatSiUnit3(this._parsedProps.resistance)}\u03A9`;
  }
  doInitialCreateNetsFromProps() {
    this._createNetsFromProps([
      this.props.pullupFor,
      this.props.pullupTo,
      this.props.pulldownFor,
      this.props.pulldownTo,
      ...this._getNetsFromConnectionsProp()
    ]);
  }
  doInitialCreateTracesFromProps() {
    if (this.props.pullupFor && this.props.pullupTo) {
      this.add(
        new Trace3({
          from: `${this.getSubcircuitSelector()} > port.1`,
          to: this.props.pullupFor
        })
      );
      this.add(
        new Trace3({
          from: `${this.getSubcircuitSelector()} > port.2`,
          to: this.props.pullupTo
        })
      );
    }
    if (this.props.pulldownFor && this.props.pulldownTo) {
      this.add(
        new Trace3({
          from: `${this.getSubcircuitSelector()} > port.1`,
          to: this.props.pulldownFor
        })
      );
      this.add(
        new Trace3({
          from: `${this.getSubcircuitSelector()} > port.2`,
          to: this.props.pulldownTo
        })
      );
    }
    this._createTracesFromConnectionsProp();
  }
  doInitialSourceRender() {
    const { db } = this.root;
    const { _parsedProps: props } = this;
    const source_component = db.source_component.insert({
      ftype: "simple_resistor",
      name: this.name,
      // @ts-ignore
      manufacturer_part_number: props.manufacturerPartNumber ?? props.mfn,
      supplier_part_numbers: props.supplierPartNumbers,
      resistance: props.resistance,
      display_resistance: this._getSchematicSymbolDisplayValue(),
      are_pins_interchangeable: true
    });
    this.source_component_id = source_component.source_component_id;
  }
};

// lib/components/primitive-components/Constraint.ts
import { constraintProps } from "@tscircuit/props";
import "zod";
var edgeSpecifiers = [
  "leftedge",
  "rightedge",
  "topedge",
  "bottomedge",
  "center"
];
var Constraint2 = class extends PrimitiveComponent2 {
  get config() {
    return {
      componentName: "Constraint",
      zodProps: constraintProps
    };
  }
  constructor(props) {
    super(props);
    if ("xdist" in props || "ydist" in props) {
      if (!("edgeToEdge" in props) && !("centerToCenter" in props)) {
        throw new Error(
          `edgeToEdge, centerToCenter must be set for xDist or yDist for ${this}`
        );
      }
    }
    if ("for" in props && props.for.length < 2) {
      throw new Error(`"for" must have at least two selectors for ${this}`);
    }
  }
  _getAllReferencedComponents() {
    const componentsWithSelectors = [];
    const container = this.getPrimitiveContainer();
    function addComponentFromSelector(selector) {
      const maybeEdge = selector.split(" ").pop();
      const edge = edgeSpecifiers.includes(maybeEdge) ? maybeEdge : void 0;
      const componentSelector = edge ? selector.replace(` ${edge}`, "") : selector;
      const component = container.selectOne(componentSelector, {
        pcbPrimitive: true
      });
      if (component) {
        componentsWithSelectors.push({
          selector,
          component,
          componentSelector,
          edge
        });
      }
    }
    for (const key of ["left", "right", "top", "bottom"]) {
      if (key in this._parsedProps) {
        addComponentFromSelector(this._parsedProps[key]);
      }
    }
    if ("for" in this._parsedProps) {
      for (const selector of this._parsedProps.for) {
        addComponentFromSelector(selector);
      }
    }
    return { componentsWithSelectors };
  }
};

// lib/components/primitive-components/FabricationNotePath.ts
import { fabricationNotePathProps } from "@tscircuit/props";
import { applyToPoint as applyToPoint7 } from "transformation-matrix";
var FabricationNotePath = class extends PrimitiveComponent2 {
  fabrication_note_path_id = null;
  get config() {
    return {
      componentName: "FabricationNotePath",
      zodProps: fabricationNotePathProps
    };
  }
  doInitialPcbPrimitiveRender() {
    if (this.root?.pcbDisabled) return;
    const { db } = this.root;
    const subcircuit = this.getSubcircuit();
    const { _parsedProps: props } = this;
    const layer = props.layer ?? "top";
    if (layer !== "top" && layer !== "bottom") {
      throw new Error(
        `Invalid layer "${layer}" for SilkscreenPath. Must be "top" or "bottom".`
      );
    }
    const transform = this._computePcbGlobalTransformBeforeLayout();
    const fabrication_note_path = db.pcb_fabrication_note_path.insert({
      pcb_component_id: this.parent?.pcb_component_id,
      layer,
      color: props.color,
      route: props.route.map((p) => {
        const transformedPosition = applyToPoint7(transform, {
          x: p.x,
          y: p.y
        });
        return {
          ...p,
          x: transformedPosition.x,
          y: transformedPosition.y
        };
      }),
      stroke_width: props.strokeWidth ?? 0.1,
      subcircuit_id: subcircuit?.subcircuit_id ?? void 0
    });
    this.fabrication_note_path_id = fabrication_note_path.pcb_fabrication_note_path_id;
  }
};

// lib/components/primitive-components/FabricationNoteText.ts
import { fabricationNoteTextProps } from "@tscircuit/props";
var FabricationNoteText = class extends PrimitiveComponent2 {
  get config() {
    return {
      componentName: "FabricationNoteText",
      zodProps: fabricationNoteTextProps
    };
  }
  doInitialPcbPrimitiveRender() {
    if (this.root?.pcbDisabled) return;
    const { db } = this.root;
    const { _parsedProps: props } = this;
    const container = this.getPrimitiveContainer();
    const subcircuit = this.getSubcircuit();
    db.pcb_fabrication_note_text.insert({
      anchor_alignment: props.anchorAlignment,
      anchor_position: {
        x: props.pcbX ?? 0,
        y: props.pcbY ?? 0
      },
      font: props.font ?? "tscircuit2024",
      font_size: props.fontSize ?? 1,
      layer: "top",
      color: props.color,
      text: props.text ?? "",
      pcb_component_id: container.pcb_component_id,
      subcircuit_id: subcircuit?.subcircuit_id ?? void 0,
      pcb_group_id: this.getGroup()?.pcb_group_id ?? void 0
    });
  }
};

// lib/components/primitive-components/Group/Subcircuit.ts
import "@tscircuit/props";
var Subcircuit = class extends Group {
  constructor(props) {
    super({
      ...props,
      subcircuit: true
    });
  }
};

// lib/components/primitive-components/Breakout/Breakout.ts
import "@tscircuit/props";
var Breakout = class extends Group {
  constructor(props) {
    super({
      ...props,
      // @ts-ignore
      subcircuit: true
    });
  }
  doInitialPcbPrimitiveRender() {
    super.doInitialPcbPrimitiveRender();
    if (this.root?.pcbDisabled) return;
    const { db } = this.root;
    const props = this._parsedProps;
    if (!this.pcb_group_id) return;
    const pcb_group = db.pcb_group.get(this.pcb_group_id);
    const padLeft = props.paddingLeft ?? props.padding ?? 0;
    const padRight = props.paddingRight ?? props.padding ?? 0;
    const padTop = props.paddingTop ?? props.padding ?? 0;
    const padBottom = props.paddingBottom ?? props.padding ?? 0;
    db.pcb_group.update(this.pcb_group_id, {
      width: pcb_group.width + padLeft + padRight,
      height: pcb_group.height + padTop + padBottom,
      center: {
        x: pcb_group.center.x + (padRight - padLeft) / 2,
        y: pcb_group.center.y + (padTop - padBottom) / 2
      }
    });
  }
};

// lib/components/primitive-components/BreakoutPoint.ts
import { breakoutPointProps } from "@tscircuit/props";
var BreakoutPoint = class extends PrimitiveComponent2 {
  pcb_breakout_point_id = null;
  matchedPort = null;
  matchedNet = null;
  isPcbPrimitive = true;
  get config() {
    return {
      componentName: "BreakoutPoint",
      zodProps: breakoutPointProps
    };
  }
  _matchConnection() {
    const { connection } = this._parsedProps;
    const subcircuit = this.getSubcircuit();
    if (!subcircuit) return;
    this.matchedPort = subcircuit.selectOne(connection, {
      type: "port"
    });
    if (!this.matchedPort) {
      this.matchedNet = subcircuit.selectOne(connection, { type: "net" });
    }
    if (!this.matchedPort && !this.matchedNet) {
      this.renderError(`Could not find connection target "${connection}"`);
    }
  }
  _getSourceTraceIdForPort(port) {
    const { db } = this.root;
    const trace = db.source_trace.list().find((st) => st.connected_source_port_ids.includes(port.source_port_id));
    return trace?.source_trace_id;
  }
  _getSourceNetIdForPort(port) {
    const { db } = this.root;
    const trace = db.source_trace.list().find((st) => st.connected_source_port_ids.includes(port.source_port_id));
    return trace?.connected_source_net_ids[0];
  }
  doInitialPcbPrimitiveRender() {
    if (this.root?.pcbDisabled) return;
    const { db } = this.root;
    this._matchConnection();
    const { pcbX = 0, pcbY = 0 } = this._parsedProps;
    const group = this.parent?.getGroup();
    const subcircuit = this.getSubcircuit();
    if (!group || !group.pcb_group_id) return;
    const pcb_breakout_point = db.pcb_breakout_point.insert({
      pcb_group_id: group.pcb_group_id,
      subcircuit_id: subcircuit?.subcircuit_id ?? void 0,
      source_port_id: this.matchedPort?.source_port_id ?? void 0,
      source_trace_id: this.matchedPort ? this._getSourceTraceIdForPort(this.matchedPort) : void 0,
      source_net_id: this.matchedNet ? this.matchedNet.source_net_id : this.matchedPort ? this._getSourceNetIdForPort(this.matchedPort) : void 0,
      x: pcbX,
      y: pcbY
    });
    this.pcb_breakout_point_id = pcb_breakout_point.pcb_breakout_point_id;
  }
  _getPcbCircuitJsonBounds() {
    const { pcbX = 0, pcbY = 0 } = this._parsedProps;
    return {
      center: { x: pcbX, y: pcbY },
      bounds: { left: pcbX, top: pcbY, right: pcbX, bottom: pcbY },
      width: 0,
      height: 0
    };
  }
  _setPositionFromLayout(newCenter) {
    const { db } = this.root;
    if (!this.pcb_breakout_point_id) return;
    db.pcb_breakout_point.update(this.pcb_breakout_point_id, {
      x: newCenter.x,
      y: newCenter.y
    });
  }
  getPcbSize() {
    return { width: 0, height: 0 };
  }
};

// lib/components/primitive-components/NetLabel.ts
import { netLabelProps } from "@tscircuit/props";
import {
  applyToPoint as applyToPoint8,
  identity as identity4,
  translate as translate7
} from "transformation-matrix";
var NetLabel = class extends PrimitiveComponent2 {
  source_net_label_id;
  get config() {
    return {
      componentName: "NetLabel",
      zodProps: netLabelProps
    };
  }
  _getAnchorSide() {
    const { _parsedProps: props } = this;
    if (props.anchorSide) return props.anchorSide;
    const connectsTo = this._resolveConnectsTo();
    if (!connectsTo) return "right";
    const anchorPos = this._getGlobalSchematicPositionBeforeLayout();
    const connectedPorts = this._getConnectedPorts();
    if (connectedPorts.length === 0) return "right";
    const connectedPortPosition = connectedPorts[0]._getGlobalSchematicPositionBeforeLayout();
    const dx = connectedPortPosition.x - anchorPos.x;
    const dy = connectedPortPosition.y - anchorPos.y;
    if (Math.abs(dx) > Math.abs(dy)) {
      if (dx > 0) return "right";
      if (dx < 0) return "left";
    } else {
      if (dy > 0) return "top";
      if (dy < 0) return "bottom";
    }
    return "right";
  }
  _getConnectedPorts() {
    const connectsTo = this._resolveConnectsTo();
    if (!connectsTo) return [];
    const connectedPorts = [];
    for (const connection of connectsTo) {
      const port = this.getSubcircuit().selectOne(connection);
      if (port) {
        connectedPorts.push(port);
      }
    }
    return connectedPorts;
  }
  computeSchematicPropsTransform() {
    const { _parsedProps: props } = this;
    if (props.schX === void 0 && props.schY === void 0) {
      const connectedPorts = this._getConnectedPorts();
      if (connectedPorts.length > 0) {
        const portPos = connectedPorts[0]._getGlobalSchematicPositionBeforeLayout();
        const parentCenter = applyToPoint8(
          this.parent?.computeSchematicGlobalTransform?.() ?? identity4(),
          { x: 0, y: 0 }
        );
        return translate7(portPos.x - parentCenter.x, portPos.y - parentCenter.y);
      }
    }
    return super.computeSchematicPropsTransform();
  }
  doInitialSchematicPrimitiveRender() {
    if (this.root?.schematicDisabled) return;
    const { db } = this.root;
    const { _parsedProps: props } = this;
    const anchorPos = this._getGlobalSchematicPositionBeforeLayout();
    const net = this.getSubcircuit().selectOne(
      `net.${this._getNetName()}`
    );
    const anchorSide = props.anchorSide ?? "right";
    const center = computeSchematicNetLabelCenter({
      anchor_position: anchorPos,
      anchor_side: anchorSide,
      text: props.net
    });
    const netLabel = db.schematic_net_label.insert({
      text: props.net,
      source_net_id: net.source_net_id,
      anchor_position: anchorPos,
      center,
      anchor_side: this._getAnchorSide()
    });
    this.source_net_label_id = netLabel.source_net_id;
  }
  _resolveConnectsTo() {
    const { _parsedProps: props } = this;
    const connectsTo = props.connectsTo ?? props.connection;
    if (Array.isArray(connectsTo)) {
      return connectsTo;
    }
    if (typeof connectsTo === "string") {
      return [connectsTo];
    }
    return void 0;
  }
  _getNetName() {
    const { _parsedProps: props } = this;
    return props.net;
  }
  doInitialCreateNetsFromProps() {
    const { _parsedProps: props } = this;
    if (props.net) {
      createNetsFromProps(this, [`net.${props.net}`]);
    }
  }
  doInitialCreateTracesFromNetLabels() {
    if (this.root?.schematicDisabled) return;
    const connectsTo = this._resolveConnectsTo();
    if (!connectsTo) return;
    for (const connection of connectsTo) {
      this.add(
        new Trace3({
          from: connection,
          to: `net.${this._getNetName()}`
        })
      );
    }
  }
};

// lib/components/primitive-components/SilkscreenCircle.ts
import { silkscreenCircleProps } from "@tscircuit/props";
var SilkscreenCircle = class extends PrimitiveComponent2 {
  pcb_silkscreen_circle_id = null;
  isPcbPrimitive = true;
  get config() {
    return {
      componentName: "SilkscreenCircle",
      zodProps: silkscreenCircleProps
    };
  }
  doInitialPcbPrimitiveRender() {
    if (this.root?.pcbDisabled) return;
    const { db } = this.root;
    const { _parsedProps: props } = this;
    const { maybeFlipLayer } = this._getPcbPrimitiveFlippedHelpers();
    const layer = maybeFlipLayer(props.layer ?? "top");
    if (layer !== "top" && layer !== "bottom") {
      throw new Error(
        `Invalid layer "${layer}" for SilkscreenCircle. Must be "top" or "bottom".`
      );
    }
    const transform = this._computePcbGlobalTransformBeforeLayout();
    const subcircuit = this.getSubcircuit();
    const pcb_silkscreen_circle = db.pcb_silkscreen_circle.insert({
      pcb_component_id: this.parent?.pcb_component_id,
      layer,
      center: {
        x: props.pcbX ?? 0,
        y: props.pcbY ?? 0
      },
      radius: props.radius,
      subcircuit_id: subcircuit?.subcircuit_id ?? void 0,
      pcb_group_id: this.getGroup()?.pcb_group_id ?? void 0,
      stroke_width: props.strokeWidth ?? 0.1
    });
    this.pcb_silkscreen_circle_id = pcb_silkscreen_circle.pcb_silkscreen_circle_id;
  }
  getPcbSize() {
    const { _parsedProps: props } = this;
    const diameter = props.radius * 2;
    return { width: diameter, height: diameter };
  }
};

// lib/components/primitive-components/SilkscreenRect.ts
import { silkscreenRectProps } from "@tscircuit/props";
var SilkscreenRect = class extends PrimitiveComponent2 {
  pcb_silkscreen_rect_id = null;
  isPcbPrimitive = true;
  get config() {
    return {
      componentName: "SilkscreenRect",
      zodProps: silkscreenRectProps
    };
  }
  doInitialPcbPrimitiveRender() {
    if (this.root?.pcbDisabled) return;
    const { db } = this.root;
    const { _parsedProps: props } = this;
    const { maybeFlipLayer } = this._getPcbPrimitiveFlippedHelpers();
    const layer = maybeFlipLayer(props.layer ?? "top");
    if (layer !== "top" && layer !== "bottom") {
      throw new Error(
        `Invalid layer "${layer}" for SilkscreenRect. Must be "top" or "bottom".`
      );
    }
    const subcircuit = this.getSubcircuit();
    const pcb_silkscreen_rect = db.pcb_silkscreen_rect.insert({
      pcb_component_id: this.parent?.pcb_component_id,
      layer,
      center: {
        x: props.pcbX ?? 0,
        y: props.pcbY ?? 0
      },
      width: props.width,
      height: props.height,
      subcircuit_id: subcircuit?.subcircuit_id ?? void 0,
      pcb_group_id: this?.getGroup()?.pcb_group_id ?? void 0,
      stroke_width: props.strokeWidth ?? 0.1
    });
    this.pcb_silkscreen_rect_id = pcb_silkscreen_rect.pcb_silkscreen_rect_id;
  }
  getPcbSize() {
    const { _parsedProps: props } = this;
    return { width: props.width, height: props.height };
  }
};

// lib/components/primitive-components/SilkscreenLine.ts
import { silkscreenLineProps } from "@tscircuit/props";
var SilkscreenLine = class extends PrimitiveComponent2 {
  pcb_silkscreen_line_id = null;
  isPcbPrimitive = true;
  get config() {
    return {
      componentName: "SilkscreenLine",
      zodProps: silkscreenLineProps
    };
  }
  doInitialPcbPrimitiveRender() {
    if (this.root?.pcbDisabled) return;
    const { db } = this.root;
    const { _parsedProps: props } = this;
    const { maybeFlipLayer } = this._getPcbPrimitiveFlippedHelpers();
    const layer = maybeFlipLayer(props.layer ?? "top");
    if (layer !== "top" && layer !== "bottom") {
      throw new Error(
        `Invalid layer "${layer}" for SilkscreenLine. Must be "top" or "bottom".`
      );
    }
    const subcircuit = this.getSubcircuit();
    const pcb_silkscreen_line = db.pcb_silkscreen_line.insert({
      pcb_component_id: this.parent?.pcb_component_id,
      layer,
      x1: props.x1,
      y1: props.y1,
      x2: props.x2,
      y2: props.y2,
      stroke_width: props.strokeWidth ?? 0.1,
      subcircuit_id: subcircuit?.subcircuit_id ?? void 0,
      pcb_group_id: subcircuit?.getGroup()?.pcb_group_id ?? void 0
    });
    this.pcb_silkscreen_line_id = pcb_silkscreen_line.pcb_silkscreen_line_id;
  }
  getPcbSize() {
    const { _parsedProps: props } = this;
    const width = Math.abs(props.x2 - props.x1);
    const height = Math.abs(props.y2 - props.y1);
    return { width, height };
  }
};

// lib/components/primitive-components/Via.ts
import { viaProps } from "@tscircuit/props";
var Via = class extends PrimitiveComponent2 {
  pcb_via_id = null;
  matchedPort = null;
  isPcbPrimitive = true;
  get config() {
    return {
      componentName: "Via",
      zodProps: viaProps
    };
  }
  getAvailablePcbLayers() {
    return ["top", "inner1", "inner2", "bottom"];
  }
  getPcbSize() {
    const { _parsedProps: props } = this;
    return { width: props.outerDiameter, height: props.outerDiameter };
  }
  _getPcbCircuitJsonBounds() {
    const { db } = this.root;
    const via = db.pcb_via.get(this.pcb_via_id);
    const size = this.getPcbSize();
    return {
      center: { x: via.x, y: via.y },
      bounds: {
        left: via.x - size.width / 2,
        top: via.y - size.height / 2,
        right: via.x + size.width / 2,
        bottom: via.y + size.height / 2
      },
      width: size.width,
      height: size.height
    };
  }
  _setPositionFromLayout(newCenter) {
    const { db } = this.root;
    db.pcb_via.update(this.pcb_via_id, {
      x: newCenter.x,
      y: newCenter.y
    });
  }
  doInitialPcbPrimitiveRender() {
    if (this.root?.pcbDisabled) return;
    const { db } = this.root;
    const { _parsedProps: props } = this;
    const position = this._getGlobalPcbPositionBeforeLayout();
    const subcircuit = this.getSubcircuit();
    const pcb_via = db.pcb_via.insert({
      x: position.x,
      y: position.y,
      hole_diameter: props.holeDiameter,
      outer_diameter: props.outerDiameter,
      layers: ["bottom", "top"],
      from_layer: props.fromLayer || "bottom",
      to_layer: props.toLayer || "top",
      subcircuit_id: subcircuit?.subcircuit_id ?? void 0,
      pcb_group_id: this.getGroup()?.pcb_group_id ?? void 0
    });
    this.pcb_via_id = pcb_via.pcb_via_id;
  }
};

// lib/components/normal-components/Battery.ts
import { batteryProps } from "@tscircuit/props";
var Battery = class extends NormalComponent {
  get config() {
    return {
      componentName: "Battery",
      schematicSymbolName: this.props.symbolName ?? "battery",
      zodProps: batteryProps,
      sourceFtype: "simple_power_source"
    };
  }
  initPorts() {
    super.initPorts({
      additionalAliases: {
        pin1: ["anode", "pos", "left"],
        pin2: ["cathode", "neg", "right"]
      }
    });
  }
  doInitialSourceRender() {
    const { db } = this.root;
    const { _parsedProps: props } = this;
    const source_component = db.source_component.insert({
      name: this.name,
      ftype: "simple_power_source",
      capacity: props.capacity,
      supplier_part_numbers: props.supplierPartNumbers,
      are_pins_interchangeable: false
    });
    this.source_component_id = source_component.source_component_id;
  }
};

// lib/components/normal-components/PinHeader.ts
import { pinHeaderProps } from "@tscircuit/props";
var PinHeader = class extends NormalComponent {
  get config() {
    return {
      componentName: "PinHeader",
      zodProps: pinHeaderProps,
      shouldRenderAsSchematicBox: true
    };
  }
  _getImpliedFootprintString() {
    const pinCount = this._parsedProps.pinCount ?? this._parsedProps.pinLabels?.length ?? 0;
    const holeDiameter = this._parsedProps.holeDiameter;
    const platedDiameter = this._parsedProps.platedDiameter;
    const pitch = this._parsedProps.pitch;
    if (pinCount > 0 && pitch) {
      if (!holeDiameter && !platedDiameter) {
        return `pinrow${pinCount}_p${pitch}`;
      }
      return `pinrow${pinCount}_p${pitch}_id${holeDiameter}_od${platedDiameter}`;
    }
    return null;
  }
  initPorts() {
    const pinCount = this._parsedProps.pinCount ?? this._parsedProps.pinLabels?.length ?? 1;
    for (let i = 1; i <= pinCount; i++) {
      this.add(
        new Port({
          name: `pin${i}`,
          pinNumber: i,
          aliases: [this._parsedProps.pinLabels?.[i - 1]].filter(
            Boolean
          )
        })
      );
    }
  }
  _getSchematicPortArrangement() {
    const pinCount = this._parsedProps.pinCount ?? 1;
    const facingDirection = this._parsedProps.schFacingDirection ?? this._parsedProps.facingDirection ?? "right";
    const schPinArrangement = this._parsedProps.schPinArrangement;
    if (facingDirection === "left") {
      return {
        leftSide: {
          direction: schPinArrangement?.leftSide?.direction ?? "top-to-bottom",
          pins: schPinArrangement?.leftSide?.pins ?? Array.from({ length: pinCount }, (_, i) => `pin${i + 1}`)
        }
      };
    }
    return {
      rightSide: {
        direction: schPinArrangement?.rightSide?.direction ?? "top-to-bottom",
        pins: schPinArrangement?.rightSide?.pins ?? Array.from({ length: pinCount }, (_, i) => `pin${i + 1}`)
      }
    };
  }
  doInitialSourceRender() {
    const { db } = this.root;
    const { _parsedProps: props } = this;
    const source_component = db.source_component.insert({
      ftype: "simple_pin_header",
      name: this.name,
      supplier_part_numbers: props.supplierPartNumbers,
      pin_count: props.pinCount,
      gender: props.gender,
      are_pins_interchangeable: true
    });
    this.source_component_id = source_component.source_component_id;
  }
};

// lib/components/normal-components/Resonator.ts
import { resonatorProps } from "@tscircuit/props";
function getResonatorSymbolName(variant) {
  switch (variant) {
    case "two_ground_pins":
      return `crystal_4pin`;
    case "ground_pin":
      return "resonator";
    case "no_ground":
      return "crystal";
    default:
      return "crystal";
  }
}
var Resonator = class extends NormalComponent {
  get config() {
    return {
      componentName: "Resonator",
      schematicSymbolName: this.props.symbolName ?? getResonatorSymbolName(this.props.pinVariant),
      zodProps: resonatorProps,
      shouldRenderAsSchematicBox: false
    };
  }
  doInitialSourceRender() {
    const { db } = this.root;
    const { _parsedProps: props } = this;
    const pinVariant = props.pinVariant || "no_ground";
    const source_component = db.source_component.insert({
      ftype: "simple_resonator",
      name: this.name,
      frequency: props.frequency,
      load_capacitance: props.loadCapacitance,
      supplier_part_numbers: props.supplierPartNumbers,
      pin_variant: pinVariant,
      are_pins_interchangeable: pinVariant === "no_ground" || pinVariant === "ground_pin"
    });
    this.source_component_id = source_component.source_component_id;
  }
};

// lib/components/normal-components/Inductor.ts
import { inductorProps } from "@tscircuit/props";
import { formatSiUnit as formatSiUnit4 } from "format-si-unit";
var Inductor = class extends NormalComponent {
  get config() {
    return {
      componentName: "Inductor",
      schematicSymbolName: this.props.symbolName ?? "inductor",
      zodProps: inductorProps,
      sourceFtype: FTYPE.simple_inductor
    };
  }
  _getSchematicSymbolDisplayValue() {
    return `${formatSiUnit4(this._parsedProps.inductance)}H`;
  }
  initPorts() {
    super.initPorts({
      additionalAliases: {
        pin1: ["anode", "pos", "left"],
        pin2: ["cathode", "neg", "right"]
      }
    });
  }
  doInitialSourceRender() {
    const { db } = this.root;
    const { _parsedProps: props } = this;
    const source_component = db.source_component.insert({
      name: this.name,
      ftype: FTYPE.simple_inductor,
      inductance: props.inductance,
      supplier_part_numbers: props.supplierPartNumbers,
      are_pins_interchangeable: true
    });
    this.source_component_id = source_component.source_component_id;
  }
};

// lib/components/normal-components/Potentiometer.ts
import { potentiometerProps } from "@tscircuit/props";
import { formatSiUnit as formatSiUnit5 } from "format-si-unit";
function getPotentiometerSymbolName(variant) {
  switch (variant) {
    case "three_pin":
      return "potentiometer3";
    case "two_pin":
      return "potentiometer2";
    default:
      return "potentiometer2";
  }
}
var Potentiometer = class extends NormalComponent {
  get config() {
    return {
      componentName: "Potentiometer",
      schematicSymbolName: this.props.symbolName ?? getPotentiometerSymbolName(this.props.pinVariant),
      zodProps: potentiometerProps,
      shouldRenderAsSchematicBox: false
    };
  }
  _getSchematicSymbolDisplayValue() {
    return `${formatSiUnit5(this._parsedProps.maxResistance)}\u03A9`;
  }
  doInitialSourceRender() {
    const { db } = this.root;
    const { _parsedProps: props } = this;
    const pinVariant = props.pinVariant || "two_pin";
    const source_component = db.source_component.insert({
      ftype: "simple_potentiometer",
      name: this.name,
      max_resistance: props.maxResistance,
      pin_variant: pinVariant,
      are_pins_interchangeable: pinVariant === "two_pin"
    });
    this.source_component_id = source_component.source_component_id;
  }
};

// lib/components/normal-components/PushButton.ts
import { pushButtonProps } from "@tscircuit/props";
var PushButton = class extends NormalComponent {
  get config() {
    return {
      componentName: "PushButton",
      schematicSymbolName: this.props.symbolName ?? "push_button_normally_open_momentary",
      zodProps: pushButtonProps,
      sourceFtype: FTYPE.simple_push_button
    };
  }
  get defaultInternallyConnectedPinNames() {
    return [
      ["pin1", "pin4"],
      ["pin2", "pin3"]
    ];
  }
  initPorts() {
    super.initPorts({
      pinCount: 4,
      additionalAliases: {
        pin1: ["side1"],
        pin3: ["side2"]
      }
    });
  }
  doInitialSourceRender() {
    const { db } = this.root;
    const { _parsedProps: props } = this;
    const source_component = db.source_component.insert({
      name: this.name,
      ftype: FTYPE.simple_push_button,
      supplier_part_numbers: props.supplierPartNumbers,
      are_pins_interchangeable: true
    });
    this.source_component_id = source_component.source_component_id;
  }
};

// lib/components/normal-components/Crystal.ts
import { crystalProps } from "@tscircuit/props";
import { formatSiUnit as formatSiUnit6 } from "format-si-unit";
var Crystal = class extends NormalComponent {
  // @ts-ignore
  get config() {
    const symbolName = this.props.symbolName ?? (this.props.pinVariant === "four_pin" ? "crystal_4pin" : "crystal");
    return {
      schematicSymbolName: symbolName,
      componentName: "Crystal",
      zodProps: crystalProps,
      sourceFtype: "simple_crystal"
    };
  }
  initPorts() {
    const additionalAliases = this.props.pinVariant === "four_pin" ? {
      pin1: ["left1", "1"],
      pin2: ["top1", "2", "gnd1"],
      pin3: ["right1", "3"],
      pin4: ["bottom1", "4", "gnd2"]
    } : {
      pin1: ["pos", "left"],
      pin2: ["neg", "right"]
    };
    super.initPorts({
      additionalAliases
    });
  }
  _getSchematicSymbolDisplayValue() {
    const freqDisplay = `${formatSiUnit6(this._parsedProps.frequency)}Hz`;
    if (this._parsedProps.loadCapacitance) {
      return `${freqDisplay} / ${formatSiUnit6(
        this._parsedProps.loadCapacitance
      )}F`;
    }
    return freqDisplay;
  }
  doInitialSourceRender() {
    const { db } = this.root;
    const { _parsedProps: props } = this;
    const source_component = db.source_component.insert({
      name: this.name,
      ftype: "simple_crystal",
      frequency: props.frequency,
      load_capacitance: props.loadCapacitance,
      pin_variant: props.pinVariant || "two_pin",
      are_pins_interchangeable: (props.pinVariant || "two_pin") === "two_pin"
    });
    this.source_component_id = source_component.source_component_id;
  }
};

// lib/components/normal-components/Transistor.ts
import { transistorProps } from "@tscircuit/props";
var Transistor = class extends NormalComponent {
  get config() {
    const baseSymbolName = this.props.type === "npn" ? "npn_bipolar_transistor" : "pnp_bipolar_transistor";
    return {
      componentName: "Transistor",
      schematicSymbolName: baseSymbolName,
      zodProps: transistorProps,
      sourceFtype: "simple_transistor",
      shouldRenderAsSchematicBox: false
    };
  }
  initPorts() {
    const pinAliases = this.props.type === "npn" ? {
      pin1: ["emitter", "e"],
      pin2: ["collector", "c"],
      pin3: ["base", "b"]
    } : {
      pin1: ["collector", "c"],
      pin2: ["emitter", "e"],
      pin3: ["base", "b"]
    };
    super.initPorts({
      pinCount: 3,
      additionalAliases: pinAliases
    });
  }
  emitter = this.portMap.pin1;
  collector = this.portMap.pin2;
  base = this.portMap.pin3;
  doInitialCreateNetsFromProps() {
    this._createNetsFromProps([...this._getNetsFromConnectionsProp()]);
  }
  doInitialCreateTracesFromProps() {
    this._createTracesFromConnectionsProp();
  }
  doInitialSourceRender() {
    const { db } = this.root;
    const { _parsedProps: props } = this;
    const source_component = db.source_component.insert({
      ftype: "simple_transistor",
      name: this.name,
      transistor_type: props.type
    });
    this.source_component_id = source_component.source_component_id;
  }
};

// lib/components/normal-components/Mosfet.ts
import { mosfetProps } from "@tscircuit/props";
var Mosfet = class extends NormalComponent {
  get config() {
    const mosfetMode = this.props.mosfetMode === "depletion" ? "d" : "e";
    const channelType = this.props.channelType;
    const baseSymbolName = `${channelType}_channel_${mosfetMode}_mosfet_transistor`;
    return {
      componentName: "Mosfet",
      schematicSymbolName: baseSymbolName,
      zodProps: mosfetProps,
      shouldRenderAsSchematicBox: false
    };
  }
  doInitialSourceRender() {
    const { db } = this.root;
    const { _parsedProps: props } = this;
    const source_component = db.source_component.insert({
      ftype: "simple_mosfet",
      name: this.name,
      mosfet_mode: props.mosfetMode,
      channel_type: props.channelType
    });
    this.source_component_id = source_component.source_component_id;
  }
};

// lib/components/normal-components/Switch.ts
import { switchProps } from "@tscircuit/props";
var Switch = class extends NormalComponent {
  _getSwitchType() {
    const { spst, spdt, dpst, dpdt, type } = this._parsedProps ?? {};
    if (dpdt) return "dpdt";
    if (spst) return "spst";
    if (spdt) return "spdt";
    if (dpst) return "dpst";
    return type ?? "spst";
  }
  get config() {
    const switchType = this._getSwitchType();
    const { isNormallyClosed } = this._parsedProps ?? {};
    const baseSymbolNameMap = {
      spst: isNormallyClosed ? "spst_normally_closed_switch" : "spst_switch",
      spdt: isNormallyClosed ? "spdt_normally_closed_switch" : "spdt_switch",
      dpst: isNormallyClosed ? "dpst_normally_closed_switch" : "dpst_switch",
      dpdt: isNormallyClosed ? "dpdt_normally_closed_switch" : "dpdt_switch"
    };
    const symbolName = baseSymbolNameMap[switchType] ?? "spst_switch";
    return {
      componentName: "Switch",
      schematicSymbolName: symbolName,
      zodProps: switchProps,
      shouldRenderAsSchematicBox: false
    };
  }
  doInitialSourceRender() {
    const { db } = this.root;
    const { _parsedProps: props } = this;
    const source_component = db.source_component.insert({
      ftype: "simple_switch",
      name: this.name,
      switch_type: props.type,
      is_normally_closed: props.isNormallyClosed ?? false,
      are_pins_interchangeable: this._getSwitchType() === "spst"
    });
    this.source_component_id = source_component.source_component_id;
  }
};

// lib/components/normal-components/TestPoint.ts
import { testpointProps } from "@tscircuit/props";
var TESTPOINT_DEFAULTS = {
  HOLE_DIAMETER: 0.5,
  SMT_CIRCLE_DIAMETER: 1.2,
  SMT_RECT_SIZE: 2
};
var TestPoint = class extends NormalComponent {
  get config() {
    return {
      componentName: "TestPoint",
      schematicSymbolName: this.props.symbolName ?? "testpoint",
      zodProps: testpointProps,
      sourceFtype: FTYPE.simple_test_point
    };
  }
  _getPropsWithDefaults() {
    let {
      padShape,
      holeDiameter,
      footprintVariant,
      padDiameter,
      width,
      height
    } = this._parsedProps;
    if (!footprintVariant && holeDiameter) {
      footprintVariant = "through_hole";
    }
    footprintVariant ??= "through_hole";
    padShape ??= "circle";
    if (footprintVariant === "pad") {
      if (padShape === "circle") {
        padDiameter ??= TESTPOINT_DEFAULTS.SMT_CIRCLE_DIAMETER;
      } else if (padShape === "rect") {
        width ??= TESTPOINT_DEFAULTS.SMT_RECT_SIZE;
        height ??= width;
      }
    } else if (footprintVariant === "through_hole") {
      holeDiameter ??= TESTPOINT_DEFAULTS.HOLE_DIAMETER;
    }
    return {
      padShape,
      holeDiameter,
      footprintVariant,
      padDiameter,
      width,
      height
    };
  }
  _getImpliedFootprintString() {
    const {
      padShape,
      holeDiameter,
      footprintVariant,
      padDiameter,
      width,
      height
    } = this._getPropsWithDefaults();
    if (footprintVariant === "through_hole") {
      return `platedhole_d${holeDiameter}`;
    }
    if (footprintVariant === "pad") {
      if (padShape === "circle") {
        return `smtpad_circle_d${padDiameter}`;
      }
      if (padShape === "rect") {
        return `smtpad_rect_w${width}_h${height}`;
      }
    }
    throw new Error(
      `Footprint variant "${footprintVariant}" with pad shape "${padShape}" not implemented`
    );
  }
  doInitialSourceRender() {
    const { db } = this.root;
    const { _parsedProps: props } = this;
    const {
      padShape,
      holeDiameter,
      footprintVariant,
      padDiameter,
      width,
      height
    } = this._getPropsWithDefaults();
    const source_component = db.source_component.insert({
      ftype: FTYPE.simple_test_point,
      name: this.name,
      supplier_part_numbers: props.supplierPartNumbers,
      footprint_variant: footprintVariant,
      pad_shape: padShape,
      pad_diameter: padDiameter,
      hole_diameter: holeDiameter,
      width,
      height,
      are_pins_interchangeable: true
    });
    this.source_component_id = source_component.source_component_id;
  }
};

// lib/components/primitive-components/SchematicText.ts
import { schematicTextProps } from "@tscircuit/props";
var SchematicText = class extends PrimitiveComponent2 {
  isSchematicPrimitive = true;
  get config() {
    return {
      componentName: "SchematicText",
      zodProps: schematicTextProps
    };
  }
  doInitialSchematicPrimitiveRender() {
    if (this.root?.schematicDisabled) return;
    const { db } = this.root;
    const { _parsedProps: props } = this;
    const globalPos = this._getGlobalSchematicPositionBeforeLayout();
    db.schematic_text.insert({
      anchor: props.anchor ?? "center",
      text: props.text,
      font_size: props.fontSize,
      color: props.color || "#000000",
      position: {
        x: globalPos.x,
        y: globalPos.y
      },
      rotation: props.schRotation ?? 0
    });
  }
};

// lib/components/primitive-components/SchematicBox.ts
import { schematicBoxProps } from "@tscircuit/props";

// lib/components/primitive-components/getTitleAnchorAndPosition.ts
function getTitleAnchorAndPosition({
  anchor,
  x,
  y,
  width,
  height,
  isInside
}) {
  switch (anchor) {
    case "top_left":
      return {
        x,
        y: y + height,
        textAnchor: isInside ? "top_left" : "bottom_left"
      };
    case "top_center":
      return {
        x: x + width / 2,
        y: y + height,
        textAnchor: isInside ? "top_center" : "bottom_center"
      };
    case "top_right":
      return {
        x: x + width,
        y: y + height,
        textAnchor: isInside ? "top_right" : "bottom_right"
      };
    case "center_left":
      return {
        x,
        y: y + height / 2,
        textAnchor: isInside ? "center_left" : "center_right"
      };
    case "center":
      return {
        x: x + width / 2,
        y: y + height / 2,
        textAnchor: "center"
      };
    case "center_right":
      return {
        x: x + width,
        y: y + height / 2,
        textAnchor: isInside ? "center_right" : "center_left"
      };
    case "bottom_left":
      return {
        x,
        y,
        textAnchor: isInside ? "bottom_left" : "top_left"
      };
    case "bottom_center":
      return {
        x: x + width / 2,
        y,
        textAnchor: isInside ? "bottom_center" : "top_center"
      };
    case "bottom_right":
      return {
        x: x + width,
        y,
        textAnchor: isInside ? "bottom_right" : "top_right"
      };
    default:
      return {
        x: x + width / 2,
        y: y + height,
        textAnchor: "center"
      };
  }
}

// lib/components/primitive-components/SchematicBox.ts
var SchematicBox = class extends PrimitiveComponent2 {
  isSchematicPrimitive = true;
  get config() {
    return {
      componentName: "SchematicBox",
      zodProps: schematicBoxProps,
      shouldRenderAsSchematicBox: true
    };
  }
  doInitialSchematicPrimitiveRender() {
    if (this.root?.schematicDisabled) return;
    const { db } = this.root;
    const { _parsedProps: props } = this;
    const basePadding = 0.6;
    const generalPadding = typeof props.padding === "number" ? props.padding : 0;
    const paddingTop = typeof props.paddingTop === "number" ? props.paddingTop : generalPadding;
    const paddingBottom = typeof props.paddingBottom === "number" ? props.paddingBottom : generalPadding;
    const paddingLeft = typeof props.paddingLeft === "number" ? props.paddingLeft : generalPadding;
    const paddingRight = typeof props.paddingRight === "number" ? props.paddingRight : generalPadding;
    const hasOverlay = props.overlay && props.overlay.length > 0;
    const hasFixedSize = typeof props.width === "number" && typeof props.height === "number";
    let width;
    let height;
    let x;
    let y;
    let centerX;
    let centerY;
    if (hasOverlay) {
      const portsWithSelectors = props.overlay.map((selector) => ({
        selector,
        port: this.getSubcircuit().selectOne(selector, {
          type: "port"
        })
      })).filter(({ port }) => port != null);
      const portsWithPosition = portsWithSelectors.map(({ port }) => ({
        position: port._getGlobalSchematicPositionAfterLayout()
      }));
      if (portsWithPosition.length === 0) return;
      const xs = portsWithPosition.map((p) => p.position.x);
      const ys = portsWithPosition.map((p) => p.position.y);
      const minX = Math.min(...xs);
      const maxX = Math.max(...xs);
      const minY = Math.min(...ys);
      const maxY = Math.max(...ys);
      const rawWidth = maxX - minX;
      const rawHeight = maxY - minY;
      const defaultHorizontalPadding = rawWidth === 0 ? basePadding : 0;
      const defaultVerticalPadding = rawHeight === 0 ? basePadding : 0;
      const finalPaddingLeft = paddingLeft + defaultHorizontalPadding / 2;
      const finalPaddingRight = paddingRight + defaultHorizontalPadding / 2;
      const finalPaddingTop = paddingTop + defaultVerticalPadding / 2;
      const finalPaddingBottom = paddingBottom + defaultVerticalPadding / 2;
      const left = minX - finalPaddingLeft;
      const right = maxX + finalPaddingRight;
      const top = minY - finalPaddingBottom;
      const bottom = maxY + finalPaddingTop;
      width = right - left;
      height = bottom - top;
      x = left + (props.schX ?? 0);
      y = top + (props.schY ?? 0);
      centerX = x + width / 2;
      centerY = y + height / 2;
    } else if (hasFixedSize) {
      width = props.width;
      height = props.height;
      const center = this._getGlobalSchematicPositionBeforeLayout();
      centerX = center.x;
      centerY = center.y;
      x = centerX - width / 2;
      y = centerY - height / 2;
    } else {
      return;
    }
    db.schematic_box.insert({
      height,
      width,
      x,
      y,
      is_dashed: props.strokeStyle === "dashed"
    });
    if (props.title) {
      const isInside = props.titleInside;
      const TITLE_PADDING = 0.1;
      const anchor = props.titleAlignment;
      const anchorPos = getTitleAnchorAndPosition({
        anchor,
        x,
        y,
        width,
        height,
        isInside
      });
      let titleOffsetY;
      let titleOffsetX;
      const textAnchor = anchorPos.textAnchor;
      if (isInside) {
        titleOffsetY = anchor.includes("top") ? -TITLE_PADDING : anchor.includes("bottom") ? TITLE_PADDING : 0;
        titleOffsetX = anchor.includes("left") ? TITLE_PADDING : anchor.includes("right") ? -TITLE_PADDING : 0;
      } else {
        titleOffsetY = anchor.includes("top") ? TITLE_PADDING : anchor.includes("bottom") ? -TITLE_PADDING : 0;
        titleOffsetX = anchor.includes("center_left") ? -TITLE_PADDING : anchor.includes("center_right") ? TITLE_PADDING : 0;
      }
      const titleX = anchorPos.x + titleOffsetX;
      const titleY = anchorPos.y + titleOffsetY;
      db.schematic_text.insert({
        anchor: textAnchor,
        text: props.title,
        font_size: props.titleFontSize ?? 0.18,
        color: props.titleColor ?? "#000000",
        position: {
          x: titleX,
          y: titleY
        },
        rotation: 0
      });
    }
  }
};

// lib/components/primitive-components/SchematicTable.ts
import { schematicTableProps } from "@tscircuit/props";
var SchematicTable = class extends PrimitiveComponent2 {
  isSchematicPrimitive = true;
  schematic_table_id = null;
  get config() {
    return {
      componentName: "SchematicTable",
      zodProps: schematicTableProps
    };
  }
  doInitialSchematicPrimitiveRender() {
    if (this.root?.schematicDisabled) return;
    const { db } = this.root;
    const { _parsedProps: props } = this;
    const rows = this.children.filter(
      (c) => c.componentName === "SchematicRow"
    );
    if (rows.length === 0) return;
    const grid = [];
    let maxCols = 0;
    for (const row of rows) {
      const cells = row.children.filter(
        (c) => c.componentName === "SchematicCell"
      );
      maxCols = Math.max(maxCols, cells.length);
    }
    for (let i = 0; i < rows.length; i++) {
      grid[i] = [];
    }
    for (let i = 0; i < rows.length; i++) {
      const row = rows[i];
      const cells = row.children.filter(
        (c) => c.componentName === "SchematicCell"
      );
      let k = 0;
      for (let j = 0; j < cells.length; j++) {
        while (grid[i][k]) {
          k++;
        }
        const cell = cells[j];
        const colSpan = cell._parsedProps.colSpan ?? 1;
        const rowSpan = cell._parsedProps.rowSpan ?? 1;
        for (let r = 0; r < rowSpan; r++) {
          for (let c = 0; c < colSpan; c++) {
            if (!grid[i + r]) grid[i + r] = [];
            grid[i + r][k + c] = cell;
          }
        }
        k += colSpan;
      }
    }
    maxCols = Math.max(0, ...grid.map((r) => r.length));
    const rowHeights = rows.map(
      (row, i) => row._parsedProps.height ?? 1
    );
    const colWidths = Array.from({ length: maxCols }, (_, j) => {
      let maxWidth = 0;
      for (let i = 0; i < rows.length; i++) {
        const cell = grid[i]?.[j];
        if (cell) {
          const text = cell._parsedProps.text ?? cell._parsedProps.children;
          const cellWidth = cell._parsedProps.width ?? (text?.length ?? 2) * 0.5;
          if (cellWidth > maxWidth) {
            maxWidth = cellWidth;
          }
        }
      }
      return maxWidth || 10;
    });
    const anchorPos = this._getGlobalSchematicPositionBeforeLayout();
    const table = db.schematic_table.insert({
      anchor_position: anchorPos,
      column_widths: colWidths,
      row_heights: rowHeights,
      cell_padding: props.cellPadding,
      border_width: props.borderWidth,
      anchor: props.anchor,
      subcircuit_id: this.getSubcircuit()?.subcircuit_id || "",
      schematic_component_id: this.parent?.schematic_component_id || ""
    });
    this.schematic_table_id = table.schematic_table_id;
    const processedCells = /* @__PURE__ */ new Set();
    let yOffset = 0;
    for (let i = 0; i < rows.length; i++) {
      let xOffset = 0;
      for (let j = 0; j < maxCols; j++) {
        const cell = grid[i]?.[j];
        if (cell && !processedCells.has(cell)) {
          processedCells.add(cell);
          const cellProps = cell._parsedProps;
          const rowSpan = cellProps.rowSpan ?? 1;
          const colSpan = cellProps.colSpan ?? 1;
          let cellWidth = 0;
          for (let c = 0; c < colSpan; c++) {
            cellWidth += colWidths[j + c];
          }
          let cellHeight = 0;
          for (let r = 0; r < rowSpan; r++) {
            cellHeight += rowHeights[i + r];
          }
          db.schematic_table_cell.insert({
            schematic_table_id: this.schematic_table_id,
            start_row_index: i,
            end_row_index: i + rowSpan - 1,
            start_column_index: j,
            end_column_index: j + colSpan - 1,
            text: cellProps.text ?? cellProps.children,
            center: {
              x: anchorPos.x + xOffset + cellWidth / 2,
              y: anchorPos.y - yOffset - cellHeight / 2
            },
            width: cellWidth,
            height: cellHeight,
            horizontal_align: cellProps.horizontalAlign,
            vertical_align: cellProps.verticalAlign,
            font_size: cellProps.fontSize ?? props.fontSize,
            subcircuit_id: this.getSubcircuit()?.subcircuit_id || ""
          });
        }
        if (colWidths[j]) {
          xOffset += colWidths[j];
        }
      }
      yOffset += rowHeights[i];
    }
  }
};

// lib/components/primitive-components/SchematicRow.ts
import { schematicRowProps } from "@tscircuit/props";
var SchematicRow = class extends PrimitiveComponent2 {
  isSchematicPrimitive = true;
  get config() {
    return {
      componentName: "SchematicRow",
      zodProps: schematicRowProps
    };
  }
};

// lib/components/primitive-components/SchematicCell.ts
import { schematicCellProps } from "@tscircuit/props";
var SchematicCell = class extends PrimitiveComponent2 {
  isSchematicPrimitive = true;
  canHaveTextChildren = true;
  get config() {
    return {
      componentName: "SchematicCell",
      zodProps: schematicCellProps
    };
  }
};

// lib/RootCircuit.ts
import { su as su5 } from "@tscircuit/circuit-json-util";
import { isValidElement as isValidElement2 } from "react";
import { identity as identity5 } from "transformation-matrix";

// package.json
var package_default = {
  name: "@tscircuit/core",
  type: "module",
  version: "0.0.585",
  types: "dist/index.d.ts",
  main: "dist/index.js",
  module: "dist/index.js",
  files: [
    "dist"
  ],
  repository: {
    type: "git",
    url: "https://github.com/tscircuit/core"
  },
  scripts: {
    build: "tsup-node index.ts --format esm --dts",
    format: "biome format . --write",
    "measure-bundle": "howfat -r table .",
    "pkg-pr-new-release": "bunx pkg-pr-new publish --comment=off --peerDeps",
    "smoke-test:dist": "bun run scripts/smoke-tests/test-dist-simple-circuit.tsx",
    "build:benchmarking": "bun build --experimental-html ./benchmarking/website/index.html --outdir ./benchmarking-dist",
    "build:benchmarking:watch": `chokidar "./{benchmarking,lib}/**/*.{ts,tsx}" -c 'bun build --experimental-html ./benchmarking/website/index.html --outdir ./benchmarking-dist'`,
    "start:benchmarking": 'concurrently "bun run build:benchmarking:watch" "live-server ./benchmarking-dist"'
  },
  devDependencies: {
    "@biomejs/biome": "^1.8.3",
    "@tscircuit/capacity-autorouter": "^0.0.100",
    "@tscircuit/checks": "^0.0.56",
    "@tscircuit/circuit-json-flex": "^0.0.1",
    "@tscircuit/circuit-json-util": "^0.0.54",
    "@tscircuit/footprinter": "^0.0.204",
    "@tscircuit/import-snippet": "^0.0.4",
    "@tscircuit/infgrid-ijump-astar": "^0.0.33",
    "@tscircuit/log-soup": "^1.0.2",
    "@tscircuit/math-utils": "^0.0.18",
    "@tscircuit/props": "^0.0.268",
    "@tscircuit/schematic-autolayout": "^0.0.6",
    "@tscircuit/schematic-corpus": "^0.0.52",
    "@tscircuit/schematic-match-adapt": "^0.0.16",
    "@tscircuit/simple-3d-svg": "^0.0.6",
    "@types/bun": "^1.2.16",
    "@types/debug": "^4.1.12",
    "@types/react": "^19.1.8",
    "@types/react-dom": "^19.1.6",
    "@types/react-reconciler": "^0.28.9",
    "bpc-graph": "^0.0.57",
    "bun-match-svg": "0.0.12",
    "calculate-elbow": "^0.0.5",
    "chokidar-cli": "^3.0.0",
    "circuit-json": "^0.0.221",
    "circuit-json-to-bpc": "^0.0.13",
    "circuit-json-to-connectivity-map": "^0.0.22",
    "circuit-json-to-simple-3d": "^0.0.2",
    "circuit-to-svg": "^0.0.172",
    concurrently: "^9.1.2",
    debug: "^4.3.6",
    "graphics-debug": "^0.0.60",
    howfat: "^0.3.8",
    "live-server": "^1.2.2",
    "looks-same": "^9.0.1",
    "pkg-pr-new": "^0.0.37",
    react: "^19.1.0",
    "react-dom": "^19.1.0",
    "schematic-symbols": "^0.0.180",
    "ts-expect": "^1.3.0",
    tsup: "^8.2.4"
  },
  peerDependencies: {
    "@tscircuit/capacity-autorouter": "*",
    "@tscircuit/checks": "*",
    "@tscircuit/circuit-json-util": "*",
    "@tscircuit/footprinter": "*",
    "@tscircuit/infgrid-ijump-astar": "*",
    "@tscircuit/math-utils": "*",
    "@tscircuit/props": "*",
    "@tscircuit/schematic-autolayout": "*",
    "@tscircuit/schematic-match-adapt": "*",
    "@tscircuit/circuit-json-flex": "*",
    "@tscircuit/schematic-corpus": "*",
    "circuit-json-to-bpc": "*",
    "bpc-graph": "*",
    "circuit-json": "*",
    "circuit-json-to-connectivity-map": "*",
    "schematic-symbols": "*",
    typescript: "^5.0.0"
  },
  dependencies: {
    "@flatten-js/core": "^1.6.2",
    "@lume/kiwi": "^0.4.3",
    "calculate-packing": "0.0.5",
    "css-select": "5.1.0",
    "format-si-unit": "^0.0.3",
    nanoid: "^5.0.7",
    "performance-now": "^2.1.0",
    "react-reconciler": "^0.32.0",
    "react-reconciler-18": "npm:react-reconciler@0.29.2",
    "transformation-matrix": "^2.16.1",
    zod: "^3.25.67"
  }
};

// lib/RootCircuit.ts
var RootCircuit = class {
  firstChild = null;
  children;
  db;
  root = null;
  isRoot = true;
  schematicDisabled = false;
  pcbDisabled = false;
  pcbRoutingDisabled = false;
  /**
   * The RootCircuit name is usually set by the platform, it's not required but
   * if supplied can identify the circuit in certain effects, e.g. it is passed
   * as the display_name parameter for autorouting effects.
   */
  name;
  platform;
  /**
   * Optional URL pointing to where this project is hosted or documented.
   * When provided it is stored in the source_project_metadata.project_url field
   * of the generated Circuit JSON.
   */
  projectUrl;
  _hasRenderedAtleastOnce = false;
  constructor({
    platform,
    projectUrl
  } = {}) {
    this.children = [];
    this.db = su5([]);
    this.root = this;
    this.platform = platform;
    this.projectUrl = projectUrl;
    this.pcbDisabled = platform?.pcbDisabled ?? false;
  }
  add(componentOrElm) {
    let component;
    if (isValidElement2(componentOrElm)) {
      component = createInstanceFromReactElement(componentOrElm);
    } else {
      component = componentOrElm;
    }
    this.children.push(component);
  }
  /**
   * Get the main board for this Circuit.
   */
  _getBoard() {
    return this.children.find(
      (c) => c.componentName === "Board"
    );
  }
  _guessRootComponent() {
    if (this.firstChild) return;
    if (this.children.length === 0) {
      throw new Error(
        "Not able to guess root component: RootCircuit has no children (use circuit.add(...))"
      );
    }
    if (this.children.length === 1 && this.children[0].isGroup) {
      this.firstChild = this.children[0];
      return;
    }
    const group = new Group({ subcircuit: true });
    group.parent = this;
    group.addAll(this.children);
    this.children = [group];
    this.firstChild = group;
  }
  render() {
    if (!this.firstChild) {
      this._guessRootComponent();
    }
    const { firstChild, db } = this;
    if (!firstChild) throw new Error("RootCircuit has no root component");
    firstChild.parent = this;
    firstChild.runRenderCycle();
    this._hasRenderedAtleastOnce = true;
  }
  async renderUntilSettled() {
    const existing = this.db.source_project_metadata.list()?.[0];
    if (!existing) {
      this.db.source_project_metadata.insert({
        software_used_string: `@tscircuit/core@${this.getCoreVersion()}`,
        ...this.projectUrl ? { project_url: this.projectUrl } : {}
      });
    }
    this.render();
    while (this._hasIncompleteAsyncEffects()) {
      await new Promise((resolve) => setTimeout(resolve, 100));
      this.render();
    }
    this.emit("renderComplete");
  }
  _hasIncompleteAsyncEffects() {
    return this.children.some((child) => {
      if (child._hasIncompleteAsyncEffects()) return true;
      return child.children.some(
        (grandchild) => grandchild._hasIncompleteAsyncEffects()
      );
    });
  }
  getCircuitJson() {
    if (!this._hasRenderedAtleastOnce) this.render();
    return this.db.toArray();
  }
  toJson() {
    return this.getCircuitJson();
  }
  async getSvg(options) {
    const circuitToSvg = await import("circuit-to-svg").catch((e) => {
      throw new Error(
        `To use circuit.getSvg, you must install the "circuit-to-svg" package.

"${e.message}"`
      );
    });
    if (options.view === "pcb") {
      return circuitToSvg.convertCircuitJsonToPcbSvg(this.getCircuitJson());
    }
    if (options.view === "schematic") {
      return circuitToSvg.convertCircuitJsonToSchematicSvg(
        this.getCircuitJson()
      );
    }
    throw new Error(`Invalid view: ${options.view}`);
  }
  getCoreVersion() {
    const [major, minor, patch] = package_default.version.split(".").map(Number);
    return `${major}.${minor}.${patch + 1}`;
  }
  async preview(previewNameOrOpts) {
    const previewOpts = typeof previewNameOrOpts === "object" ? previewNameOrOpts : { previewName: previewNameOrOpts };
    throw new Error("project.preview is not yet implemented");
  }
  computeSchematicGlobalTransform() {
    return identity5();
  }
  _computePcbGlobalTransformBeforeLayout() {
    return identity5();
  }
  selectAll(selector) {
    this._guessRootComponent();
    return this.firstChild?.selectAll(selector) ?? [];
  }
  selectOne(selector, opts) {
    this._guessRootComponent();
    return this.firstChild?.selectOne(selector, opts) ?? null;
  }
  _eventListeners = {};
  emit(event, ...args) {
    if (!this._eventListeners[event]) return;
    for (const listener of this._eventListeners[event]) {
      listener(...args);
    }
  }
  on(event, listener) {
    if (!this._eventListeners[event]) {
      this._eventListeners[event] = [];
    }
    this._eventListeners[event].push(listener);
  }
  removeListener(event, listener) {
    if (!this._eventListeners[event]) return;
    this._eventListeners[event] = this._eventListeners[event].filter(
      (l) => l !== listener
    );
  }
  getClientOrigin() {
    if (typeof window !== "undefined") {
      return window.location.origin;
    }
    if (typeof self !== "undefined") {
      return self.origin;
    }
    return "";
  }
};
var Project = RootCircuit;
var Circuit = RootCircuit;

// lib/hooks/use-rendered-circuit.ts
import React2 from "react";
var useRenderedCircuit = (reactElements) => {
  const [isLoading, setIsLoading] = React2.useState(true);
  const [error, setError] = React2.useState(null);
  const [circuit, setCircuit] = React2.useState();
  const [circuitJson, setCircuitJson] = React2.useState();
  React2.useEffect(() => {
    setIsLoading(true);
    setError(null);
    if (reactElements) {
      setTimeout(() => {
        try {
          const circuit2 = new RootCircuit();
          circuit2.add(reactElements);
          setCircuit(circuit2);
          setCircuitJson(circuit2.toJson());
        } catch (error2) {
          setError(error2);
        }
        setIsLoading(false);
      }, 1);
    }
  }, [reactElements]);
  return { isLoading, error, circuit, circuitJson };
};

// lib/hooks/create-use-component.tsx
import "react";
import "zod";
import "@tscircuit/props";
import { Fragment, jsx, jsxs } from "react/jsx-runtime";
var createUseComponent = (Component2, pins) => {
  return (name, props) => {
    const pinLabelsFlatArray = [];
    if (Array.isArray(pins)) {
      pinLabelsFlatArray.push(...pins.flat());
    } else if (typeof pins === "object") {
      pinLabelsFlatArray.push(
        ...Object.values(pins).flat(),
        ...Object.keys(pins)
      );
    }
    const R = (props2) => {
      if (props2?.name && props2.name !== name) {
        throw new Error(
          `Component name mismatch. Hook name: ${name}, Component prop name: ${props2.name}`
        );
      }
      const combinedProps = { ...props, ...props2, name };
      const tracesToCreate = [];
      for (const portLabel of pinLabelsFlatArray) {
        if (combinedProps[portLabel]) {
          const from = `.${name} > .${portLabel}`;
          const to = combinedProps[portLabel];
          tracesToCreate.push({ from, to });
          delete combinedProps[portLabel];
        }
      }
      return /* @__PURE__ */ jsxs(Fragment, { children: [
        /* @__PURE__ */ jsx(Component2, { ...combinedProps }),
        tracesToCreate.map((trace, i) => (
          // biome-ignore lint/suspicious/noArrayIndexKey: <explanation>
          /* @__PURE__ */ jsx("trace", { ...trace }, i)
        ))
      ] });
    };
    for (const port of pinLabelsFlatArray) {
      R[port] = `.${name} > .${port}`;
    }
    return R;
  };
};

// lib/hooks/use-capacitor.tsx
import { capacitorPins } from "@tscircuit/props";
import { jsx as jsx2 } from "react/jsx-runtime";
var useCapacitor = createUseComponent(
  (props) => /* @__PURE__ */ jsx2("capacitor", { ...props }),
  capacitorPins
);

// lib/hooks/use-chip.tsx
import { jsx as jsx3 } from "react/jsx-runtime";
var useChip = (pinLabels) => createUseComponent(
  (props) => /* @__PURE__ */ jsx3("chip", { pinLabels, ...props }),
  pinLabels
);

// lib/hooks/use-diode.tsx
import { diodePins } from "@tscircuit/props";
import { jsx as jsx4 } from "react/jsx-runtime";
var useDiode = createUseComponent(
  (props) => /* @__PURE__ */ jsx4("diode", { ...props }),
  diodePins
);

// lib/hooks/use-led.tsx
import { ledPins } from "@tscircuit/props";
import { jsx as jsx5 } from "react/jsx-runtime";
var useLed = createUseComponent(
  (props) => /* @__PURE__ */ jsx5("led", { ...props }),
  ledPins
);

// lib/hooks/use-resistor.tsx
import { resistorPins as resistorPins2 } from "@tscircuit/props";
import { jsx as jsx6 } from "react/jsx-runtime";
var useResistor = createUseComponent(
  (props) => /* @__PURE__ */ jsx6("resistor", { ...props }),
  resistorPins2
);

// lib/sel/sel.ts
var sel = new Proxy(
  (refdes) => new Proxy(
    {},
    {
      get: (_, pin) => `.${refdes} > .${pin}`
    }
  ),
  {
    get: (_, prop1) => {
      const fn = (...args) => {
        const chipFnOrPinType = args[0];
        return new Proxy(
          {},
          {
            get: (_2, pinName) => {
              return `.${prop1} > .${pinName}`;
            }
          }
        );
      };
      return new Proxy(fn, {
        // This handles dot notation access like sel.U1.PIN
        get: (_2, prop2) => {
          if (prop1 === "net") {
            return `net.${prop2}`;
          }
          if (prop1 === "subcircuit") {
            return new Proxy(
              {},
              {
                get: (_3, prop3) => {
                  return new Proxy(
                    {},
                    {
                      get: (_4, prop4) => {
                        return `subcircuit.${prop2} > .${prop3} > .${prop4}`;
                      }
                    }
                  );
                }
              }
            );
          }
          return `.${prop1} > .${prop2}`;
        },
        // This handles function calls like...
        // - sel.U1(MyChip)
        // - sel.U1(({ selectors: { U1: { GND: "GND", VCC: "VCC" } } }) => ...)
        // - sel.U1(({ connections: { GND: "GND", VCC: "VCC" } }) => ...)
        apply: (target, _2, args) => {
          if (prop1 === "net") {
            return new Proxy(
              {},
              {
                get: (_3, netName) => `net.${netName}`
              }
            );
          }
          return new Proxy(
            {},
            {
              get: (_3, pinOrSubComponentName) => {
                const pinResult = `.${prop1} > .${pinOrSubComponentName}`;
                const chipPrefixes = ["U", "J", "CN"];
                if (chipPrefixes.some((p) => prop1.startsWith(p))) {
                  return pinResult;
                }
                return new Proxy(new String(pinResult), {
                  get: (_4, nestedProp) => {
                    if (typeof nestedProp === "symbol" || nestedProp === "toString") {
                      return () => pinResult;
                    }
                    return `.${prop1} > .${pinOrSubComponentName} > .${nestedProp}`;
                  }
                });
              }
            }
          );
        }
      });
    }
  }
);

// lib/index.ts
import { createElement } from "react";

// lib/register-catalogue.ts
extendCatalogue(components_exports);
extendCatalogue({
  Bug: Chip
});
export {
  Battery,
  Board,
  Breakout,
  BreakoutPoint,
  Capacitor,
  Chip,
  Circuit,
  Constraint2 as Constraint,
  Crystal,
  Cutout,
  Diode,
  FabricationNotePath,
  FabricationNoteText,
  Footprint,
  Fuse,
  Group,
  Hole,
  Inductor,
  Jumper,
  Keepout,
  Led,
  Mosfet,
  Net,
  NetLabel,
  NormalComponent,
  PcbTrace,
  PinHeader,
  PlatedHole,
  Port,
  Potentiometer,
  PowerSource,
  PrimitiveComponent2 as PrimitiveComponent,
  Project,
  PushButton,
  Renderable,
  Resistor,
  Resonator,
  RootCircuit,
  SchematicBox,
  SchematicCell,
  SchematicRow,
  SchematicTable,
  SchematicText,
  SilkscreenCircle,
  SilkscreenLine,
  SilkscreenPath,
  SilkscreenRect,
  SilkscreenText,
  SmtPad,
  SolderJumper,
  Subcircuit,
  Switch,
  TestPoint,
  Trace3 as Trace,
  TraceHint,
  Transistor,
  Via,
  applyEditEvents,
  applyEditEventsToManualEditsFile,
  applyPcbEditEventsToManualEditsFile,
  applySchematicEditEventsToManualEditsFile,
  createElement,
  createUseComponent,
  getPhaseTimingsFromRenderEvents,
  getSimpleRouteJsonFromCircuitJson,
  normalizePinLabels,
  orderedRenderPhases,
  sel,
  useCapacitor,
  useChip,
  useDiode,
  useLed,
  useRenderedCircuit,
  useResistor
};
