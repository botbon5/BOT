import { GraphicsObject } from 'graphics-debug';
import { CircuitJson } from 'circuit-json';

interface Box {
    leftPinCount: number;
    rightPinCount: number;
    topPinCount: number;
    bottomPinCount: number;
    boxId: string;
}
type Side = "left" | "right" | "top" | "bottom";
type NetReference = {
    boxId: string;
    pinNumber: number;
} | {
    netId: string;
};
interface Connection {
    connectedPorts: Array<NetReference>;
}
interface Net {
    netId: string;
    /** True if this net is a ground connection (e.g. GND, AGND) */
    isGround?: boolean;
    /** True if this net is a positive power rail (e.g. VCC, VDD, V5) */
    isPositivePower?: boolean;
}
interface InputNetlist {
    boxes: Array<Box>;
    connections: Array<Connection>;
    nets: Array<Net>;
}
/** Represents a reference to a connectable point (a pin on a box or a named net). */
type PortReference = {
    boxId: string;
    pinNumber: number;
} | {
    netId: string;
    netLabelId: string;
} | {
    junctionId: string;
};

type LayoutPointRef = PortReference;
interface LaidOutBox {
    boxId: string;
    leftPinCount: number;
    rightPinCount: number;
    topPinCount: number;
    bottomPinCount: number;
    centerX: number;
    centerY: number;
    pins: Array<{
        pinNumber: number;
        x: number;
        y: number;
        marginFromLastPin?: number;
    }>;
}
interface LaidOutPath {
    points: Array<{
        x: number;
        y: number;
    }>;
    from: LayoutPointRef;
    to: LayoutPointRef;
}
interface LaidOutNetLabel {
    netLabelId: string;
    netId: string;
    anchorPosition: "top" | "bottom" | "left" | "right";
    x: number;
    y: number;
}
interface CircuitLayoutJson {
    boxes: LaidOutBox[];
    netLabels: Array<LaidOutNetLabel>;
    paths: Array<LaidOutPath>;
    junctions: Array<{
        junctionId: string;
        x: number;
        y: number;
    }>;
}

declare class BaseSolver {
    MAX_ITERATIONS: number;
    solved: boolean;
    failed: boolean;
    iterations: number;
    progress: number;
    error: string | null;
    _activeSubSolver?: BaseSolver | null;
    usedSubSolvers: Array<BaseSolver>;
    failedSubSolvers?: BaseSolver[];
    timeToSolve?: number;
    stats: any;
    /** DO NOT OVERRIDE! Override _step() instead */
    step(): void;
    _step(): void;
    getStatsSummary(): string;
    get activeSubSolver(): BaseSolver | null | undefined;
    getConstructorParams(): void;
    clearActiveSubSolver(): void;
    setActiveSubSolver(subSolver: BaseSolver | null): void;
    visualize(): Array<{
        title: string;
        graphicsObject?: GraphicsObject;
        ascii?: string;
        table?: any[];
    }>;
    solve(): void;
}

interface Line {
    start: {
        x: number;
        y: number;
        ref: PortReference;
        fromJunctionId?: string;
    };
    end: {
        x: number;
        y: number;
        ref: PortReference;
        fromJunctionId?: string;
    };
    pathId?: string;
}

interface NetLabel {
    netLabelId: string;
    netId: string;
    x: number;
    y: number;
    anchorSide: Side;
    fromRef: PortReference;
}
interface ConnectionPoint {
    pinRef: PortReference;
    junctionId: string;
    x: number;
    y: number;
    showAsIntersection?: boolean;
}
interface Path {
    pathId: string;
}

interface PinConnectionState {
    x: number;
    y: number;
    lastConnected: PortReference | null;
    lastDx: number;
    lastDy: number;
}
declare class PinBuilder {
    private readonly chip;
    pinNumber: number;
    x: number;
    y: number;
    pathId: string | null;
    lastConnected: PortReference | null;
    lastCreatedLine: Line | null;
    lastDx: number;
    lastDy: number;
    fromJunctionId: string | null;
    constructor(chip: any, // TODO: Replace with proper ChipBuilder type
    pinNumber: number);
    private get circuit();
    line(dx: number, dy: number): this;
    lineAt(targetX: number, targetY: number): this;
    pathTo(targetX: number, targetY: number): this;
    private getPinDirection;
    get side(): Side;
    get ref(): PortReference;
    passive(name?: string): PinBuilder;
    label(text?: string): void;
    connect(): this;
    intersect(): this;
    intersectsAt(targetX: number, targetY: number): this;
    connectToMark(markName: string): this;
    intersectAtMark(markName: string): this;
    mark(name: string): this;
    getMarkableState(): PinConnectionState;
    applyMarkableState(state: PinConnectionState): void;
}

declare class ChipBuilder {
    readonly circuit: CircuitBuilder;
    readonly chipId: string;
    readonly isPassive: boolean;
    x: number;
    y: number;
    leftPins: PinBuilder[];
    rightPins: PinBuilder[];
    topPins: PinBuilder[];
    bottomPins: PinBuilder[];
    leftPinCount: number;
    rightPinCount: number;
    topPinCount: number;
    bottomPinCount: number;
    private pinMap;
    marks: Record<string, {
        pinBuilder: PinBuilder;
        state: any;
    }>;
    pinMargins: Record<number, {
        marginTop: number;
        marginLeft: number;
    }>;
    constructor(circuit: CircuitBuilder, chipId: string, isPassive?: boolean);
    at(x: number, y: number): this;
    private makePin;
    leftpins(count: number): this;
    rightpins(count: number): this;
    toppins(count: number): this;
    bottompins(count: number): this;
    getWidth(): number;
    getHeight(): number;
    getCenter(): {
        x: number;
        y: number;
    };
    get totalPinCount(): number;
    setPinPositions(): void;
    pinPositionsAreSet: boolean;
    private _getPin;
    pin(pinNumber: number): PinBuilder;
    getPinLocation(pinNumber: number): {
        x: number;
        y: number;
    };
    addMark(name: string, pinBuilder: PinBuilder): void;
    fromMark(name: string): PinBuilder;
    getPinNumberFromSideIndex(side: Side, indexOnSide: number): number;
}

declare class CircuitBuilder {
    chips: ChipBuilder[];
    netLabels: NetLabel[];
    lines: Line[];
    paths: Path[];
    connectionPoints: ConnectionPoint[];
    defaultChipWidth: number;
    defaultSingleSidedChipWidth: number;
    /** Width for chips with pins on both left and right sides */
    defaultLeftRightChipWidth: number;
    defaultPinSpacing: number;
    defaultPassiveWidth: number;
    defaultPassiveHeight: number;
    private autoLabelCounter;
    name: string;
    constructor(opts?: {
        name?: string;
    });
    clone(): CircuitBuilder;
    chip(id?: string): ChipBuilder;
    passive(name?: string): ChipBuilder;
    _pathCounter: number;
    addPath(): Path;
    _netLabelCounter: number;
    addNetLabel(params: Omit<NetLabel, "netLabelId">): NetLabel;
    _junctionCounter: number;
    addJunction({ x, y, pinRef, showAsIntersection, }: {
        x: number;
        y: number;
        showAsIntersection?: boolean;
        pinRef: PortReference;
    }): ConnectionPoint;
    toString(): string;
    getNetlist(): InputNetlist;
    getReadableNetlist(): string;
    flipX(): CircuitBuilder;
    generateAutoLabel(): string;
    getGrid(): any;
    getMark(name: string): {
        pinBuilder: PinBuilder;
        state: any;
    };
    getLayoutJson(): CircuitLayoutJson;
}

interface AddLabelToPinOp {
    type: "add_label_to_pin";
    pinNumber: number;
    chipId: string;
    netName?: string;
}
interface AddPinToSideOp {
    type: "add_pin_to_side";
    side: Side;
    chipId: string;
    betweenPinNumbers: [number, number];
}
interface RemovePinFromSideOp {
    type: "remove_pin_from_side";
    side: Side;
    chipId: string;
    pinNumber: number;
}
interface AddPassiveToPinOp {
    type: "add_passive_to_pin";
    pinNumber: number;
    chipId: string;
}
interface AddPassiveWithLabelToPinOp {
    type: "add_passive_with_label_to_pin";
    pinNumber: number;
    chipId: string;
    labelNetId: string;
}
interface ClearPinOp {
    type: "clear_pin";
    pinNumber: number;
    chipId: string;
}
interface RemoveChipOp {
    type: "remove_chip";
    chipId: string;
}
interface ChangePassiveOrientationOp {
    type: "change_passive_orientation";
    chipId: string;
    fromOrientation: "horizontal" | "vertical";
    toOrientation: "horizontal" | "vertical";
}
interface DrawLineBetweenPinsOp {
    type: "draw_line_between_pins";
    fromChipId: string;
    fromPinNumber: number;
    toChipId: string;
    toPinNumber: number;
    netName?: string;
}
type EditOperation = AddLabelToPinOp | AddPassiveToPinOp | AddPassiveWithLabelToPinOp | ClearPinOp | RemoveChipOp | AddPinToSideOp | RemovePinFromSideOp | ChangePassiveOrientationOp | DrawLineBetweenPinsOp;

interface MatchedBox {
    targetBoxIndex: number;
    candidateBoxIndex: number;
    _targetBoxId?: string;
    _candidateBoxId?: string;
    issues: MatchingIssue[];
    targetBoxRotationCcw: 0 | 90 | 180 | 270;
    score: number;
}

type PinShapeSummary = "not_connected" | "connected_to_label" | "connected_to_passive";
interface NoBoxMatchingPinCounts {
    type: "no_box_matching_pin_counts";
    candidateBoxIndex: number;
    targetBoxIndex: number;
}
interface MatchedBoxSideHasWrongPinCount {
    type: "matched_box_side_has_wrong_pin_count";
    candidateBoxIndex: number;
    targetBoxIndex: number;
}
/**
 * @deprecated Use MatchedBoxMissingPinShapeOnSide instead
 */
interface MatchedBoxMissingPinShape {
    type: "matched_box_missing_pin_shape";
    candidateBoxIndex: number;
    targetBoxIndex: number;
    targetPinNumber: number;
    targetPinShapeSignature?: string;
    targetPinShapeSummary?: PinShapeSummary;
}
interface MatchedBoxMissingPinShapeOnSide {
    type: "matched_box_missing_pin_shape_on_side";
    candidateBoxIndex: number;
    targetBoxIndex: number;
    side: Side;
    targetPinNumber: number;
    targetPinShapeSignature?: string;
    targetPinShapeSummary?: PinShapeSummary;
}
interface MatchedBoxMissingPinShapeBoxCountOnSide {
    type: "matched_box_missing_pin_shape_box_count_on_side";
    candidateBoxIndex: number;
    targetBoxIndex: number;
    side: Side;
    targetPinNumber: number;
    targetBoxCountSignature: string;
    candidateBoxCountSignatures: string[];
}
interface MatchedBoxPinShapeInWrongPosition {
    type: "matched_box_pin_shape_in_wrong_position";
    candidateBoxIndex: number;
    targetBoxIndex: number;
    targetPinNumber: number;
    hopsToCorrectPosition: number;
}
interface MissingConnectionBetweenBoxes {
    type: "missing_connection_between_boxes";
    candidateBoxIndex: number;
    targetBoxIndex: number;
    targetPinNumber: number;
    expectedConnectionWithTargetBoxIndex: number;
    expectedConnectionWithTargetBoxPinNumber: number;
}
type MatchingIssue = NoBoxMatchingPinCounts | MatchedBoxMissingPinShape | MatchedBoxSideHasWrongPinCount | MatchedBoxPinShapeInWrongPosition | MatchedBoxMissingPinShapeOnSide | MatchedBoxMissingPinShapeBoxCountOnSide | MissingConnectionBetweenBoxes;

interface MatchedBoxWithChipIds {
    candidateChipId: string | undefined;
    targetChipId: string | undefined;
    targetBoxIndex: number;
    candidateBoxIndex: number;
    issues: MatchingIssue[];
    score: number;
}

type AdaptationPhase = "transform-target" | "remove-unmatched-chips-1" | "fix-matched-box-pin-counts" | "fix-matched-box-pin-shapes" | "remove-unmatched-chips-2" | "draw-missing-connections" | "complete";
/**
 * Adapts a template to match a target netlist by applying edit operations step-by-step
 */
declare class AdaptTemplateToNetlistSolver extends BaseSolver {
    inputTemplate: CircuitBuilder;
    targetNetlist: InputNetlist;
    transformedTarget: InputNetlist | null;
    outputAdaptedTemplate: CircuitBuilder | null;
    outputAppliedOperations: EditOperation[];
    phase: AdaptationPhase;
    matchedBoxes: MatchedBoxWithChipIds[];
    stepCount: number;
    maxSteps: number;
    constructor(opts: {
        inputTemplate: CircuitBuilder;
        targetNetlist: InputNetlist;
    });
    getConstructorParams(): {
        inputTemplate: CircuitBuilder;
        targetNetlist: InputNetlist;
    };
    getStatsSummary(): string;
    _step(): void;
    visualize(): ({
        title: string;
        ascii: string;
        table?: undefined;
    } | {
        title: string;
        table: {
            operation_index: number;
            type: "add_label_to_pin" | "add_pin_to_side" | "remove_pin_from_side" | "add_passive_to_pin" | "add_passive_with_label_to_pin" | "clear_pin" | "remove_chip" | "change_passive_orientation" | "draw_line_between_pins";
            details: EditOperation;
        }[];
        ascii?: undefined;
    })[];
}

/**
 * Adapts matched templates to fit their target netlists by applying edit operations.
 */
declare class AdaptPhaseSolver extends BaseSolver {
    matchedTemplates: Array<{
        template: CircuitBuilder;
        netlist: InputNetlist;
    }>;
    adaptationSolvers: Array<AdaptTemplateToNetlistSolver>;
    currentAdaptationIndex: number;
    outputAdaptedTemplates: Array<{
        template: CircuitBuilder;
        netlist: InputNetlist;
        appliedOperations: EditOperation[];
    }>;
    constructor(opts: {
        matchedTemplates: Array<{
            template: CircuitBuilder;
            netlist: InputNetlist;
        }>;
    });
    getConstructorParams(): {
        matchedTemplates: {
            template: CircuitBuilder;
            netlist: InputNetlist;
        }[];
    };
    computeProgress(): number;
    _step(): void;
}

type CircuitTemplateFn = () => CircuitBuilder;

interface NormalizationTransform {
    boxIdToBoxIndex: Record<string, number>;
    netIdToNetIndex: Record<string, number>;
    boxIndexToBoxId: Record<number, string>;
    netIndexToNetId: Record<number, string>;
}

/**
 * Scores a single netlist-template pair, computing issues and similarity distance
 */
declare class ScoreNetlistTemplatePairSolver extends BaseSolver {
    inputNetlist: InputNetlist;
    template: CircuitBuilder;
    inputNetlistWithRotations: InputNetlist | null;
    outputIssues: Array<MatchingIssue>;
    outputSimilarityDistance: number;
    candidateTransform: NormalizationTransform | null;
    targetTransform: NormalizationTransform | null;
    matchedBoxes: MatchedBox[];
    constructor(opts: {
        inputNetlist: InputNetlist;
        template: CircuitBuilder;
    });
    getConstructorParams(): {
        inputNetlist: InputNetlist;
        template: CircuitBuilder;
    };
    getStatsSummary(): string;
    _step(): void;
    private getBoxNameFromIndex;
    private getAsciiForNetlistBoxHelper;
    private generateMatchedBoxesVisualization;
    visualize(): ({
        title: string;
        ascii: string;
        table: {
            issue_index: number;
            type: "no_box_matching_pin_counts" | "matched_box_side_has_wrong_pin_count" | "matched_box_missing_pin_shape" | "matched_box_missing_pin_shape_on_side" | "matched_box_missing_pin_shape_box_count_on_side" | "matched_box_pin_shape_in_wrong_position" | "missing_connection_between_boxes";
            target_box: string;
            candidate_box: string;
            details: MatchingIssue;
        }[];
    } | {
        title: string;
        table: {
            targetBoxIdPinNumber: string;
            candidateBoxIdPinNumber: string;
            targetPinShapeSignature: string;
            candidatePinShapeSignature: string;
        }[];
        ascii?: undefined;
    } | {
        title: string;
        ascii: string;
        table: {
            target_box: string;
            candidate_box: string;
            rotation: 0 | 90 | 180 | 270;
            issueCount: number;
            details: MatchedBox;
        }[];
    } | {
        title: string;
        ascii: string;
        table?: undefined;
    })[];
}

/**
 * Find the best match template for a netlist by scoring all templates
 */
declare class MatchNetlistToTemplateSolver extends BaseSolver {
    inputNetlist: InputNetlist;
    templates: Array<CircuitBuilder>;
    scoringSolvers: Array<ScoreNetlistTemplatePairSolver>;
    currentScoringIndex: number;
    outputBestMatchTemplate: CircuitBuilder | null;
    templateMatchResults: Array<{
        template: CircuitBuilder;
        issues: Array<MatchingIssue>;
        similarityDistance: number;
    }>;
    constructor(opts: {
        inputNetlist: InputNetlist;
        templateFns?: Array<CircuitTemplateFn>;
    });
    getConstructorParams(): {
        inputNetlist: InputNetlist;
    };
    computeProgress(): number;
    _step(): void;
    visualize(): ({
        title: string;
        ascii: string;
        table?: undefined;
    } | {
        title: string;
        table: {
            template_index: number;
            template_name: string;
            similarity_distance: number;
            issue_count: number;
            is_best_match: boolean;
        }[];
        ascii?: undefined;
    })[];
}

/**
 * For each input netlist, find the best match template.
 */
declare class MatchPhaseSolver extends BaseSolver {
    inputNetlists: InputNetlist[];
    currentInputNetlistIndex: number;
    templateFns?: CircuitTemplateFn[];
    outputMatchedTemplates: Array<{
        template: CircuitBuilder;
        netlist: InputNetlist;
    }>;
    get activeSubSolver(): MatchNetlistToTemplateSolver | null;
    constructor(opts: {
        inputNetlists: InputNetlist[];
        templateFns?: CircuitTemplateFn[];
    });
    _step(): void;
}

/**
 * Clones matched templates and rewrites chip IDs to use the IDs from the
 * matched target boxes. This ensures subsequent adaptation stages operate on
 * chip IDs that resemble the user's input.
 */
declare class RenameMatchedTemplateBoxIdsSolver extends BaseSolver {
    matchedTemplates: Array<{
        template: CircuitBuilder;
        netlist: InputNetlist;
    }>;
    outputRenamedTemplates: Array<{
        template: CircuitBuilder;
        netlist: InputNetlist;
    }>;
    constructor(opts: {
        matchedTemplates: Array<{
            template: CircuitBuilder;
            netlist: InputNetlist;
        }>;
    });
    getConstructorParams(): {
        matchedTemplates: {
            template: CircuitBuilder;
            netlist: InputNetlist;
        }[];
    };
    /** Compute mapping from candidate chip ids to target ids */
    private getChipIdMap;
    private cloneAndRename;
    _step(): void;
}

type PipelineStep<T extends new (...args: any[]) => BaseSolver> = {
    solverName: string;
    solverClass: T;
    getConstructorParams: (instance: SchematicLayoutPipelineSolver) => ConstructorParameters<T>;
    onSolved?: (instance: SchematicLayoutPipelineSolver) => void;
};
declare class SchematicLayoutPipelineSolver extends BaseSolver {
    inputNetlist: InputNetlist;
    templateFnsOverride?: CircuitTemplateFn[];
    matchPhaseSolver?: MatchPhaseSolver;
    renameMatchedTemplateBoxIdsSolver?: RenameMatchedTemplateBoxIdsSolver;
    adaptPhaseSolver?: AdaptPhaseSolver;
    startTimeOfPhase: Record<string, number>;
    endTimeOfPhase: Record<string, number>;
    timeSpentOnPhase: Record<string, number>;
    pipelineDef: (PipelineStep<typeof MatchPhaseSolver> | PipelineStep<typeof RenameMatchedTemplateBoxIdsSolver> | PipelineStep<typeof AdaptPhaseSolver>)[];
    constructor(opts: {
        inputNetlist: InputNetlist;
        templateFns?: CircuitTemplateFn[];
    });
    currentPipelineStepIndex: number;
    _step(): void;
    getLayout(): CircuitLayoutJson;
}

/**
 * Re-position/rotate schematic components in the circuit json to match the
 * layout of the circuit builder.
 */
declare const applyCircuitLayoutToCircuitJson: (circuitJson: CircuitJson, circuitJsonNetlist: InputNetlist, layout: CircuitBuilder) => CircuitJson;

/**
 * Converts a tscircuit `CircuitJson` object (array-of-records) into the very
 * small `InputNetlist` structure used by the scoring / ASCII rendering code.
 *
 * The algorithm is intentionally defensive: if we cannot confidently discover
 * a pin’s *side* we fall back to counting it as a **left** pin so that the
 * total-pin count for the box is still correct (this is good enough for every
 * current compatibility check).
 */
declare const convertCircuitJsonToInputNetlist: (circuitJson: CircuitJson) => InputNetlist;

/**
 * Reorders schematic ports to be in counter-clockwise order.
 *
 * Often, a user will specify an alternative order for ports in their tscircuit code,
 * we reorder them here so that matching logic doesn't need to worry about the placement
 * of pins.
 *
 * This requires the following steps:
 * 1. Get all the pins for each source component
 * 2. Identify if they're out of order considering SIDES_CCW and the pin_number of each schematic_port
 * 3. Sort the pins by their true_ccw_index
 * 4. Swap the pin positions to match the true_ccw_index+1
 * 5. Rewrite the pin numbers such that they match true_ccw_index+1
 */
declare const reorderChipPinsToCcw: (circuitJson: CircuitJson) => CircuitJson;

declare const getRefKey: (ref: PortReference) => string;
declare const parseRefKey: (refKey: string) => PortReference;

declare const CORPUS_TEMPLATE_FNS: CircuitTemplateFn[];

declare function circuitBuilderFromLayoutJson(layout: CircuitLayoutJson): CircuitBuilder;

export { type Box, CORPUS_TEMPLATE_FNS, type CircuitLayoutJson, type Connection, type InputNetlist, type LaidOutBox, type LaidOutNetLabel, type LaidOutPath, type LayoutPointRef, type Net, type NetReference, type PortReference, RenameMatchedTemplateBoxIdsSolver, SchematicLayoutPipelineSolver, type Side, applyCircuitLayoutToCircuitJson, circuitBuilderFromLayoutJson, convertCircuitJsonToInputNetlist, getRefKey, parseRefKey, reorderChipPinsToCcw };
