import * as graphics_debug from 'graphics-debug';
import { GraphicsObject, Rect, Circle, Line, Point as Point$3 } from 'graphics-debug';
import { ConnectivityMap } from 'circuit-json-to-connectivity-map';

type TraceId = string;
interface SimpleRouteJson {
    layerCount: number;
    minTraceWidth: number;
    obstacles: Obstacle[];
    connections: Array<SimpleRouteConnection>;
    bounds: {
        minX: number;
        maxX: number;
        minY: number;
        maxY: number;
    };
    traces?: SimplifiedPcbTraces;
}
interface Obstacle {
    type: "rect";
    layers: string[];
    zLayers?: number[];
    center: {
        x: number;
        y: number;
    };
    width: number;
    height: number;
    connectedTo: TraceId[];
}
interface SimpleRouteConnection {
    name: string;
    netConnectionName?: string;
    pointsToConnect: Array<{
        x: number;
        y: number;
        layer: string;
        pointId?: string;
        pcb_port_id?: string;
    }>;
    externallyConnectedPointIds?: string[][];
}
interface SimplifiedPcbTrace {
    type: "pcb_trace";
    pcb_trace_id: TraceId;
    connection_name: string;
    route: Array<{
        route_type: "wire";
        x: number;
        y: number;
        width: number;
        layer: string;
    } | {
        route_type: "via";
        x: number;
        y: number;
        to_layer: string;
        from_layer: string;
    }>;
}
type SimplifiedPcbTraces = Array<SimplifiedPcbTrace>;

type CapacityMeshNodeId = string;
interface CapacityMeshNode {
    capacityMeshNodeId: string;
    center: {
        x: number;
        y: number;
    };
    width: number;
    height: number;
    layer: string;
    availableZ: number[];
    _depth?: number;
    _completelyInsideObstacle?: boolean;
    _containsObstacle?: boolean;
    _containsTarget?: boolean;
    _targetConnectionName?: string;
    _strawNode?: boolean;
    _strawParentCapacityMeshNodeId?: CapacityMeshNodeId;
    _adjacentNodeIds?: CapacityMeshNodeId[];
    _parent?: CapacityMeshNode;
}
interface CapacityMeshEdge {
    capacityMeshEdgeId: string;
    nodeIds: [CapacityMeshNodeId, CapacityMeshNodeId];
}

type CapacityPathId = string;
interface CapacityPath {
    capacityPathId: CapacityPathId;
    connectionName: string;
    nodeIds: CapacityMeshNodeId[];
}

declare class BaseSolver {
    MAX_ITERATIONS: number;
    solved: boolean;
    failed: boolean;
    iterations: number;
    progress: number;
    error: string | null;
    activeSubSolver?: BaseSolver | null;
    failedSubSolvers?: BaseSolver[];
    timeToSolve?: number;
    stats: Record<string, any>;
    /**
     * For cached solvers
     **/
    cacheHit?: boolean;
    cacheKey?: string;
    cacheToSolveSpaceTransform?: any;
    /** DO NOT OVERRIDE! Override _step() instead */
    step(): void;
    _step(): void;
    getConstructorParams(): void;
    solve(): void;
    visualize(): GraphicsObject;
    /**
     * Called when the solver is about to fail, but we want to see if we have an
     * "acceptable" or "passable" solution. Mostly used for optimizers that
     * have an aggressive early stopping criterion.
     */
    tryFinalAcceptance(): void;
    /**
     * A lightweight version of the visualize method that can be used to stream
     * progress
     */
    preview(): GraphicsObject;
}

declare class CapacityMeshEdgeSolver extends BaseSolver {
    nodes: CapacityMeshNode[];
    edges: Array<CapacityMeshEdge>;
    /** Only used for visualization, dynamically instantiated if necessary */
    nodeMap?: Map<CapacityMeshNodeId, CapacityMeshNode>;
    constructor(nodes: CapacityMeshNode[]);
    getNextCapacityMeshEdgeId(): string;
    _step(): void;
    handleTargetNodes(): void;
    doNodesHaveSharedLayer(node1: CapacityMeshNode, node2: CapacityMeshNode): boolean;
    visualize(): GraphicsObject;
}

/**
 * ObstacleTree wraps different spatial index implementations:
 * - 'native': original spatial-hash grid
 * - 'rbush': dynamic R-tree via rbush
 * - 'flatbush': static index via flatbush
 */
declare class ObstacleSpatialHashIndex {
    private idx;
    private storage;
    constructor(implementation?: "native" | "rbush" | "flatbush", obstacles?: Obstacle[]);
    insert(o: Obstacle): void;
    search(bbox: {
        minX: number;
        minY: number;
        maxX: number;
        maxY: number;
    }): Obstacle[];
    searchArea(centerX: number, centerY: number, width: number, height: number): Obstacle[];
}

interface Target$1 {
    x: number;
    y: number;
    bounds: {
        minX: number;
        minY: number;
        maxX: number;
        maxY: number;
    };
    connectionName: string;
    availableZ: number[];
}
type BucketCoordinate = `${number}x${number}`;
declare class TargetTree {
    targets: Target$1[];
    buckets: Map<BucketCoordinate, [Target$1, number][]>;
    CELL_SIZE: number;
    constructor(targets: Target$1[]);
    getBucketKey(x: number, y: number): BucketCoordinate;
    getTargetsInArea(centerX: number, centerY: number, width: number, height: number): Target$1[];
}

interface CapacityMeshNodeSolverOptions$1 {
    capacityDepth?: number;
}
interface Target {
    x: number;
    y: number;
    bounds: {
        minX: number;
        minY: number;
        maxX: number;
        maxY: number;
    };
    connectionName: string;
    availableZ: number[];
}
declare class CapacityMeshNodeSolver extends BaseSolver {
    srj: SimpleRouteJson;
    opts: CapacityMeshNodeSolverOptions$1;
    unfinishedNodes: CapacityMeshNode[];
    finishedNodes: CapacityMeshNode[];
    nodeToXYOverlappingObstaclesMap: Map<CapacityMeshNodeId, Obstacle[]>;
    layerCount: number;
    MAX_DEPTH: number;
    targets: Target[];
    targetTree: TargetTree;
    obstacleTree: ObstacleSpatialHashIndex;
    constructor(srj: SimpleRouteJson, opts?: CapacityMeshNodeSolverOptions$1);
    computeTargets(): Target[];
    _nextNodeCounter: number;
    getNextNodeId(): string;
    getCapacityFromDepth(depth: number): number;
    getTargetIfNodeContainsTarget(node: CapacityMeshNode): Target | null;
    getXYOverlappingObstacles(node: CapacityMeshNode): Obstacle[];
    getXYZOverlappingObstacles(node: CapacityMeshNode): Obstacle[];
    /**
     * Checks if the given mesh node overlaps with any obstacle.
     * We treat both obstacles and nodes as axis‐aligned rectangles.
     */
    doesNodeOverlapObstacle(node: CapacityMeshNode): boolean;
    /**
     * Checks if the entire node is contained within any obstacle.
     */
    isNodeCompletelyInsideObstacle(node: CapacityMeshNode): boolean;
    getChildNodes(parent: CapacityMeshNode): CapacityMeshNode[];
    shouldNodeBeXYSubdivided(node: CapacityMeshNode): boolean;
    _step(): void;
    /**
     * Creates a GraphicsObject to visualize the mesh, its nodes, obstacles, and connection points.
     *
     * - Mesh nodes are rendered as rectangles.
     *   - Nodes that have an obstacle intersection are outlined in red.
     *   - Other nodes are outlined in green.
     * - Lines are drawn from a node to its parent.
     * - Obstacles are drawn as semi-transparent red rectangles.
     * - Points for each connection’s pointsToConnect are drawn in a unique color.
     */
    visualize(): GraphicsObject;
}

interface CapacityMeshNodeSolverOptions {
    capacityDepth?: number;
}
declare class CapacityMeshNodeSolver2_NodeUnderObstacle extends CapacityMeshNodeSolver {
    srj: SimpleRouteJson;
    opts: CapacityMeshNodeSolverOptions;
    VIA_DIAMETER: number;
    OBSTACLE_MARGIN: number;
    constructor(srj: SimpleRouteJson, opts?: CapacityMeshNodeSolverOptions);
    isNodeCompletelyOutsideBounds(node: CapacityMeshNode): boolean;
    isNodePartiallyOutsideBounds(node: CapacityMeshNode): boolean;
    createChildNodeAtPosition(parent: CapacityMeshNode, opts: {
        center: {
            x: number;
            y: number;
        };
        width: number;
        height: number;
        availableZ: number[];
        _depth?: number;
    }): CapacityMeshNode;
    getZSubdivisionChildNodes(node: CapacityMeshNode): CapacityMeshNode[];
    getChildNodes(parent: CapacityMeshNode): CapacityMeshNode[];
    shouldNodeBeXYSubdivided(node: CapacityMeshNode): boolean;
    _step(): void;
}

interface NodePortSegment {
    capacityMeshNodeId: string;
    nodePortSegmentId?: string;
    start: {
        x: number;
        y: number;
    };
    end: {
        x: number;
        y: number;
    };
    availableZ: number[];
    connectionNames: string[];
}

/**
 * Each Node is a square. The capacity paths indicate the nodes the trace will
 * travel through. We want to find the "Port Segment" that each capacity path
 * will take for each node.
 */
declare class CapacityEdgeToPortSegmentSolver extends BaseSolver {
    nodes: CapacityMeshNode[];
    edges: CapacityMeshEdge[];
    capacityPaths: CapacityPath[];
    nodeMap: Map<CapacityMeshNodeId, CapacityMeshNode>;
    nodeEdgeMap: Map<CapacityMeshNodeId, CapacityMeshEdge[]>;
    unprocessedNodeIds: CapacityMeshNodeId[];
    nodePortSegments: Map<CapacityMeshNodeId, NodePortSegment[]>;
    colorMap: Record<string, string>;
    constructor({ nodes, edges, capacityPaths, colorMap, }: {
        nodes: CapacityMeshNode[];
        edges: CapacityMeshEdge[];
        capacityPaths: CapacityPath[];
        colorMap?: Record<string, string>;
    });
    step(): void;
    visualize(): GraphicsObject;
}

type PortPoint = {
    connectionName: string;
    x: number;
    y: number;
    z: number;
};
type NodeWithPortPoints = {
    capacityMeshNodeId: string;
    center: {
        x: number;
        y: number;
    };
    width: number;
    height: number;
    portPoints: PortPoint[];
    availableZ?: number[];
};
/**
 * A path for a wire in high-density intra-node routing.
 *
 * Wires travel along a route, and are placed to avoid other
 * wires at the same z-level. Any time a z level is changed,
 * you must place a via.
 *
 * z is an integer corresponding to the layer index
 *
 * z=0: top layer for 2 layer boards
 * z=1: bottom layer for 2 layer boards
 *
 * z must be an integer
 */
type HighDensityIntraNodeRoute$1 = {
    connectionName: string;
    traceThickness: number;
    viaDiameter: number;
    route: Array<{
        x: number;
        y: number;
        z: number;
    }>;
    vias: Array<{
        x: number;
        y: number;
    }>;
};
type HighDensityRoute$1 = HighDensityIntraNodeRoute$1;

interface SegmentWithAssignedPoints extends NodePortSegment {
    assignedPoints?: {
        connectionName: string;
        point: {
            x: number;
            y: number;
            z: number;
        };
    }[];
}
/**
 * CapacitySegmentToPointSolver:
 *
 * In each step, the solver iterates over all unsolved segments (segments
 * without points assigned for each connection). For each segment:
 *
 * - If there is only one connection, it assigns the center as the point.
 * - If there are two connections, it attempts to determine the ordering using
 *   other segments within the node. If no ordering can be determined, it does nothing.
 *
 * If an iteration produces no new assignments, the solver picks the segment with
 * the fewest connections and assigns points evenly spaced along the segment,
 * ordering them alphabetically.
 */
declare class CapacitySegmentToPointSolver extends BaseSolver {
    unsolvedSegments: SegmentWithAssignedPoints[];
    solvedSegments: (NodePortSegment & {
        assignedPoints: {
            connectionName: string;
            point: {
                x: number;
                y: number;
                z: number;
            };
        }[];
    })[];
    nodeMap: Record<string, CapacityMeshNode>;
    colorMap: Record<string, string>;
    constructor({ segments, colorMap, nodes, }: {
        segments: NodePortSegment[];
        colorMap?: Record<string, string>;
        /**
         * This isn't used by the algorithm, but allows associating metadata
         * for the result datatype (the center, width, height of the node)
         */
        nodes: CapacityMeshNode[];
    });
    /**
     * Perform one iteration step.
     */
    _step(): void;
    /**
     * Return the assigned points for each segment.
     */
    getNodesWithPortPoints(): NodeWithPortPoints[];
    /**
     * Return a GraphicsObject that visualizes the segments with assigned points.
     */
    visualize(): GraphicsObject;
}

interface HighDensityHyperParameters {
    FUTURE_CONNECTION_PROX_TRACE_PENALTY_FACTOR: number;
    FUTURE_CONNECTION_PROX_VIA_PENALTY_FACTOR: number;
    FUTURE_CONNECTION_PROXIMITY_VD: number;
    MISALIGNED_DIST_PENALTY_FACTOR: number;
    VIA_PENALTY_FACTOR_2: number;
    SHUFFLE_SEED: number;
    CELL_SIZE_FACTOR: number;
    FLIP_TRACE_ALIGNMENT_DIRECTION: boolean;
    MULTI_HEAD_POLYLINE_SOLVER: boolean;
    SEGMENTS_PER_POLYLINE: number;
    BOUNDARY_PADDING: number;
    ITERATION_PENALTY: number;
    MINIMUM_FINAL_ACCEPTANCE_GAP?: number;
}

type Node = {
    x: number;
    y: number;
    z: number;
    g: number;
    h: number;
    f: number;
    parent: Node | null;
};
declare class SingleRouteCandidatePriorityQueue<T extends Node = Node> {
    private heap;
    constructor(nodes: T[]);
    private getLeftChildIndex;
    private getRightChildIndex;
    private getParentIndex;
    private hasLeftChild;
    private hasRightChild;
    private hasParent;
    private leftChild;
    private rightChild;
    private parent;
    private swap;
    dequeue(): T | null;
    peek(): T | null;
    enqueue(item: T): void;
    heapifyUp(): void;
    heapifyDown(): void;
}

type FutureConnection = {
    connectionName: string;
    points: {
        x: number;
        y: number;
        z: number;
    }[];
};
declare class SingleHighDensityRouteSolver extends BaseSolver {
    obstacleRoutes: HighDensityIntraNodeRoute$1[];
    bounds: {
        minX: number;
        maxX: number;
        minY: number;
        maxY: number;
    };
    boundsSize: {
        width: number;
        height: number;
    };
    boundsCenter: {
        x: number;
        y: number;
    };
    A: {
        x: number;
        y: number;
        z: number;
    };
    B: {
        x: number;
        y: number;
        z: number;
    };
    straightLineDistance: number;
    viaDiameter: number;
    traceThickness: number;
    obstacleMargin: number;
    layerCount: number;
    minCellSize: number;
    cellStep: number;
    GREEDY_MULTIPLER: number;
    numRoutes: number;
    VIA_PENALTY_FACTOR: number;
    CELL_SIZE_FACTOR: number;
    exploredNodes: Set<string>;
    candidates: SingleRouteCandidatePriorityQueue;
    connectionName: string;
    solvedPath: HighDensityIntraNodeRoute$1 | null;
    futureConnections: FutureConnection[];
    hyperParameters: Partial<HighDensityHyperParameters>;
    connMap?: ConnectivityMap;
    /** For debugging/animating the exploration */
    debug_exploredNodesOrdered: string[];
    debug_nodesTooCloseToObstacle: Set<string>;
    debug_nodePathToParentIntersectsObstacle: Set<string>;
    debugEnabled: boolean;
    initialNodeGridOffset: {
        x: number;
        y: number;
    };
    constructor(opts: {
        connectionName: string;
        obstacleRoutes: HighDensityIntraNodeRoute$1[];
        minDistBetweenEnteringPoints: number;
        bounds: {
            minX: number;
            maxX: number;
            minY: number;
            maxY: number;
        };
        A: {
            x: number;
            y: number;
            z: number;
        };
        B: {
            x: number;
            y: number;
            z: number;
        };
        viaDiameter?: number;
        traceThickness?: number;
        obstacleMargin?: number;
        layerCount?: number;
        futureConnections?: FutureConnection[];
        hyperParameters?: Partial<HighDensityHyperParameters>;
        connMap?: ConnectivityMap;
    });
    handleSimpleCases(): void;
    get viaPenaltyDistance(): number;
    isNodeTooCloseToObstacle(node: Node, margin?: number, isVia?: boolean): boolean;
    isNodeTooCloseToEdge(node: Node, isVia?: boolean): boolean;
    doesPathToParentIntersectObstacle(node: Node): boolean;
    computeH(node: Node): number;
    computeG(node: Node): number;
    computeF(g: number, h: number): number;
    getNodeKey(node: Node): string;
    getNeighbors(node: Node): Node[];
    getNodePath(node: Node): Node[];
    getViasInNodePath(node: Node): {
        x: number;
        y: number;
    }[];
    setSolvedPath(node: Node): void;
    computeProgress(currentNode: Node, goalDist: number, isOnLayer: boolean): number;
    _step(): void;
    visualize(): GraphicsObject;
}

declare class IntraNodeRouteSolver extends BaseSolver {
    nodeWithPortPoints: NodeWithPortPoints;
    colorMap: Record<string, string>;
    unsolvedConnections: {
        connectionName: string;
        points: {
            x: number;
            y: number;
            z: number;
        }[];
    }[];
    totalConnections: number;
    solvedRoutes: HighDensityIntraNodeRoute$1[];
    failedSubSolvers: SingleHighDensityRouteSolver[];
    hyperParameters: Partial<HighDensityHyperParameters>;
    minDistBetweenEnteringPoints: number;
    activeSubSolver: SingleHighDensityRouteSolver | null;
    connMap?: ConnectivityMap;
    get failedSolvers(): SingleHighDensityRouteSolver[];
    get activeSolver(): SingleHighDensityRouteSolver | null;
    constructor(params: {
        nodeWithPortPoints: NodeWithPortPoints;
        colorMap?: Record<string, string>;
        hyperParameters?: Partial<HighDensityHyperParameters>;
        connMap?: ConnectivityMap;
    });
    computeProgress(): number;
    _step(): void;
    visualize(): GraphicsObject;
}

type SupervisedSolver<T extends BaseSolver> = {
    hyperParameters: any;
    solver: T;
    h: number;
    g: number;
    f: number;
};
type HyperParameterDef = {
    name: string;
    possibleValues: Array<any>;
};
/**
 * The HyperParameterSupervisorSolver is a solver that solves a problem by
 * running competing solvers with different hyperparameters.
 *
 * As solvers make progress, the supervisor will allow the best solvers to run
 * for more iterations, prioritizing the solvers that are working the best.
 */
declare class HyperParameterSupervisorSolver<T extends BaseSolver> extends BaseSolver {
    GREEDY_MULTIPLIER: number;
    MIN_SUBSTEPS: number;
    supervisedSolvers?: Array<SupervisedSolver<T>>;
    winningSolver?: T;
    getHyperParameterDefs(): Array<HyperParameterDef>;
    getCombinationDefs(): Array<Array<string>> | null;
    getHyperParameterCombinations(hyperParameterDefs?: Array<HyperParameterDef>): Array<Record<string, any>>;
    initializeSolvers(): void;
    generateSolver(hyperParameters: any): T;
    computeG(solver: T): number;
    computeH(solver: T): number;
    computeF(g: number, h: number): number;
    getSupervisedSolverWithBestFitness(): SupervisedSolver<T> | null;
    getFailureMessage(): string;
    _step(): void;
    onSolve(solver: SupervisedSolver<T>): void;
    visualize(): GraphicsObject;
}

type Point$2 = {
    x: number;
    y: number;
    z?: number;
};
type Route = {
    startPort: Point$2;
    endPort: Point$2;
    connectionName: string;
};
declare class TwoCrossingRoutesHighDensitySolver extends BaseSolver {
    nodeWithPortPoints: NodeWithPortPoints;
    routes: Route[];
    viaDiameter: number;
    traceThickness: number;
    obstacleMargin: number;
    layerCount: number;
    debugViaPositions: {
        via1: Point$2;
        via2: Point$2;
    }[];
    escapeLayer: number;
    solvedRoutes: HighDensityIntraNodeRoute$1[];
    bounds: {
        minX: number;
        maxX: number;
        minY: number;
        maxY: number;
    };
    constructor(params: {
        nodeWithPortPoints: NodeWithPortPoints;
        viaDiameter?: number;
        traceThickness?: number;
        obstacleMargin?: number;
        layerCount?: number;
    });
    /**
     * Extract routes that need to be connected from the node data
     */
    private extractRoutesFromNode;
    /**
     * Calculate the bounding box of the node
     */
    private calculateBounds;
    /**
     * Check if two routes are crossing
     */
    private doRoutesCross;
    private calculateViaPositions;
    /**
     * Try to solve with routeA going over and routeB staying on layer 0
     */
    private trySolveAOverB;
    private pushViasFromEndpoints;
    private getMinDistanceBetweenViaCenters;
    private moveViasAsCloseAsPossible;
    handleRoutesDontCross(): void;
    /**
     * Main step method that attempts to solve the two crossing routes
     */
    _step(): void;
    /**
     * Visualization for debugging
     */
    visualize(): GraphicsObject;
    /**
     * Get the solved routes
     */
    getSolvedRoutes(): HighDensityIntraNodeRoute$1[];
}

declare class HyperSingleIntraNodeSolver extends HyperParameterSupervisorSolver<IntraNodeRouteSolver | TwoCrossingRoutesHighDensitySolver> {
    constructorParams: ConstructorParameters<typeof IntraNodeRouteSolver>[0];
    solvedRoutes: HighDensityIntraNodeRoute$1[];
    nodeWithPortPoints: NodeWithPortPoints;
    connMap?: ConnectivityMap;
    constructor(opts: ConstructorParameters<typeof IntraNodeRouteSolver>[0]);
    getCombinationDefs(): string[][];
    getHyperParameterDefs(): ({
        name: string;
        possibleValues: ({
            FUTURE_CONNECTION_PROX_TRACE_PENALTY_FACTOR: number;
            FUTURE_CONNECTION_PROX_VIA_PENALTY_FACTOR: number;
            FUTURE_CONNECTION_PROXIMITY_VD: number;
            MISALIGNED_DIST_PENALTY_FACTOR: number;
            VIA_PENALTY_FACTOR_2?: undefined;
        } | {
            FUTURE_CONNECTION_PROX_TRACE_PENALTY_FACTOR: number;
            FUTURE_CONNECTION_PROX_VIA_PENALTY_FACTOR: number;
            FUTURE_CONNECTION_PROXIMITY_VD: number;
            MISALIGNED_DIST_PENALTY_FACTOR: number;
            VIA_PENALTY_FACTOR_2: number;
        })[];
    } | {
        name: string;
        possibleValues: {
            SHUFFLE_SEED: number;
        }[];
    } | {
        name: string;
        possibleValues: {
            CELL_SIZE_FACTOR: number;
        }[];
    } | {
        name: string;
        possibleValues: {
            FLIP_TRACE_ALIGNMENT_DIRECTION: boolean;
        }[];
    } | {
        name: string;
        possibleValues: {
            CELL_SIZE_FACTOR: number;
            VIA_PENALTY_FACTOR_2: number;
        }[];
    } | {
        name: string;
        possibleValues: ({
            CLOSED_FORM_TWO_TRACE_SAME_LAYER: boolean;
            CLOSED_FORM_TWO_TRACE_TRANSITION_CROSSING?: undefined;
        } | {
            CLOSED_FORM_TWO_TRACE_TRANSITION_CROSSING: boolean;
            CLOSED_FORM_TWO_TRACE_SAME_LAYER?: undefined;
        })[];
    } | {
        name: string;
        possibleValues: ({
            MULTI_HEAD_POLYLINE_SOLVER: boolean;
            SEGMENTS_PER_POLYLINE: number;
            BOUNDARY_PADDING: number;
            ITERATION_PENALTY?: undefined;
            MINIMUM_FINAL_ACCEPTANCE_GAP?: undefined;
        } | {
            MULTI_HEAD_POLYLINE_SOLVER: boolean;
            SEGMENTS_PER_POLYLINE: number;
            BOUNDARY_PADDING: number;
            ITERATION_PENALTY: number;
            MINIMUM_FINAL_ACCEPTANCE_GAP: number;
        })[];
    })[];
    computeG(solver: IntraNodeRouteSolver): number;
    computeH(solver: IntraNodeRouteSolver): number;
    generateSolver(hyperParameters: any): IntraNodeRouteSolver;
    onSolve(solver: SupervisedSolver<IntraNodeRouteSolver>): void;
}

declare class HighDensitySolver extends BaseSolver {
    unsolvedNodePortPoints: NodeWithPortPoints[];
    routes: HighDensityIntraNodeRoute$1[];
    colorMap: Record<string, string>;
    readonly defaultViaDiameter = 0.6;
    readonly defaultTraceThickness = 0.15;
    failedSolvers: (IntraNodeRouteSolver | HyperSingleIntraNodeSolver)[];
    activeSubSolver: IntraNodeRouteSolver | HyperSingleIntraNodeSolver | null;
    connMap?: ConnectivityMap;
    constructor({ nodePortPoints, colorMap, connMap, }: {
        nodePortPoints: NodeWithPortPoints[];
        colorMap?: Record<string, string>;
        connMap?: ConnectivityMap;
    });
    /**
     * Each iteration, pop an unsolved node and attempt to find the routes inside
     * of it.
     */
    _step(): void;
    visualize(): GraphicsObject;
}

/**
 * Merge targets that are close to each other into a single target
 */
declare class CapacityNodeTargetMerger extends BaseSolver {
    nodes: CapacityMeshNode[];
    connMap: ConnectivityMap;
    unprocessedObstacles: Obstacle[];
    newNodes: CapacityMeshNode[];
    removedNodeIds: Set<string>;
    constructor(nodes: CapacityMeshNode[], obstacles: Obstacle[], connMap: ConnectivityMap);
    _step(): void;
    visualize(): GraphicsObject;
}

type NodePortSegmentId = string;
interface ChangeLayerOperation {
    op: "changeLayer";
    segmentId: string;
    pointIndex: number;
    newLayer: number;
    /** Operation is mutated and oldLayer is added to allow reversal */
    oldLayer?: number;
    cost?: number;
}
interface SwitchOperation {
    op: "switch";
    segmentId: string;
    point1Index: number;
    point2Index: number;
    cost?: number;
}
interface CombinedOperation {
    op: "combined";
    subOperations: Array<SwitchOperation | ChangeLayerOperation>;
    cost?: number;
}
type Operation = ChangeLayerOperation | SwitchOperation | CombinedOperation;
/**
 * Use simulated annealing to try to improve the placement of points (via
 * swapping with points on the same segment) or changing the layer.
 *
 * We have the following pieces of information:
 * - NodePortSegment with nodePortSegmentId
 * - A "neighbor" NodePortSegmentWithAssignedPoints has one change
 *    - A change can be flipping a point to the opposite layer
 *    - A change can also be switching the position of two points
 * - We represent the operations used to change from an original scene
 *   with a list of operations [SEG1_CL(1, 1), SEG1_SW(1, 2), SEG2_CL(2, 0)]
 *    - CN indicates the capacity node to edit
 *    - The SW operation "switches" the x/y location of two points
 *    - The CL operation changes the layer of the point
 * - When choosing edits to make, we are biased to operate on nodes that have a
 *   high cost and biased against operating on nodes we've operated on a lot
 * - Each step, we generate an operation and use the standard simulated
 *   annealing function to determine if we should perform the operation
 */
declare class CapacitySegmentPointOptimizer extends BaseSolver {
    assignedSegments: SegmentWithAssignedPoints[];
    colorMap: Record<string, string>;
    nodeMap: Map<CapacityMeshNodeId, CapacityMeshNode>;
    nodeIdToSegmentIds: Map<string, string[]>;
    segmentIdToNodeIds: Map<string, string[]>;
    currentMutatedSegments: Map<NodePortSegmentId, SegmentWithAssignedPoints>;
    allSegmentIds: string[];
    lastAppliedOperation: Operation | null;
    lastCreatedOperation: Operation | null;
    currentNodeCosts: Map<CapacityMeshNodeId, number>;
    lastAcceptedIteration: number;
    currentCost: number;
    randomSeed: number;
    numNodes: number;
    probabilityOfFailure: number;
    nodesThatCantFitVias: Set<CapacityMeshNodeId>;
    mutableSegments: Set<NodePortSegmentId>;
    VIA_DIAMETER: number;
    OBSTACLE_MARGIN: number;
    MAX_OPERATIONS_PER_MUTATION: number;
    MAX_NODE_CHAIN_PER_MUTATION: number;
    NOOP_ITERATIONS_BEFORE_EARLY_STOP: number;
    constructor({ assignedSegments, colorMap, nodes, }: {
        assignedSegments: NodePortSegment[];
        colorMap?: Record<string, string>;
        /**
         * This isn't used by the algorithm, but allows associating metadata
         * for the result datatype (the center, width, height of the node)
         */
        nodes: CapacityMeshNode[];
    });
    random(): number;
    /**
     * The cost is the "probability of failure" of the node.
     */
    computeNodeCost(nodeId: CapacityMeshNodeId): number;
    /**
     * Number of traces that can go through this node if they are completely
     * straight without crossings
     */
    getUsedTraceCapacity(nodeId: CapacityMeshNodeId): number;
    /**
     * Granular via capacity is a consideration of capacity that includes...
     * - The number of traces
     * - The number of trace crossings (0-2 vias per trace crossing)
     *   - Empirically, each crossing typically results in 0.82 vias
     *   - e.g. 17 traces would typically have 51 crossings & 42 vias
     * - The number of layer changes (at least 1 via per layer change)
     *   - We don't know how a entry/exit being on separated layers effects
     *     the capacity/number of vias yet
     *
     * - Generally minimizing the number of crossings is pretty good, if there
     *   is no trace crossing you basically don't have any used capacity
     * - If the entry/exit layer is different, you're guaranteed to have at least
     *   one via
     *
     * - Total capacity is computed by estimating the number of vias that could
     *   be created using the formula (viaFitAcross / 2) ** 1.1
     */
    getUsedViaCapacity(nodeId: CapacityMeshNodeId): number;
    getRandomWeightedNodeId(): CapacityMeshNodeId;
    getRandomWeightedSegmentId(): string;
    getMutableSegments(): Set<string>;
    isSegmentMutable(segmentId: string): boolean;
    getRandomOperationForSegment(randomSegmentId: string): SwitchOperation | ChangeLayerOperation | null;
    getNodesNearNode(nodeId: CapacityMeshNodeId, hops?: number): CapacityMeshNodeId[];
    getRandomCombinedOperationNearNode(nodeId: CapacityMeshNodeId): CombinedOperation;
    /**
     * A combined operation can perform multiple operations on a single node, this
     * allows it to reach outcomes that may not be beneficial with since
     * operations
     */
    getRandomCombinedOperationOnSingleNode(max?: number): CombinedOperation;
    getRandomOperation(): Operation;
    /**
     * We compute "overall probability of failure" as our overall cost, then
     * linearize it to make it easier to work with
     */
    computeCurrentCost(): {
        cost: number;
        nodeCosts: Map<CapacityMeshNodeId, number>;
        probabilityOfFailure: number;
        linearizedCost: number;
    };
    applyOperation(op: Operation): void;
    reverseOperation(op: Operation): void;
    isNewCostAcceptable(oldPf: number, newPf: number): boolean;
    /**
     * FOR OUTPUT: Return the assigned points for each segment.
     */
    getNodesWithPortPoints(): NodeWithPortPoints[];
    _step(): void;
    visualize(): GraphicsObject;
}

/**
 * Converts a net containing many points to connect into an array of point pair
 * connections.
 *
 * For example, a connection with 3 pointsToConnect could be turned into 2
 * connections of 2 points each.
 *
 * Where we create the minimum number of pairs, we're using a minimum spanning
 * tree (MST).
 *
 * Sometimes it can be used to add additional traces to help make sure we
 * distribute load effectively. In this version we don't do that!
 */
declare class NetToPointPairsSolver extends BaseSolver {
    ogSrj: SimpleRouteJson;
    colorMap: Record<string, string>;
    unprocessedConnections: Array<SimpleRouteConnection>;
    newConnections: Array<SimpleRouteConnection>;
    constructor(ogSrj: SimpleRouteJson, colorMap?: Record<string, string>);
    _step(): void;
    getNewSimpleRouteJson(): SimpleRouteJson;
    visualize(): GraphicsObject;
}

declare class SingleHighDensityRouteStitchSolver extends BaseSolver {
    mergedHdRoute: HighDensityIntraNodeRoute$1;
    remainingHdRoutes: HighDensityIntraNodeRoute$1[];
    start: {
        x: number;
        y: number;
        z: number;
    };
    end: {
        x: number;
        y: number;
        z: number;
    };
    colorMap: Record<string, string>;
    constructor(opts: {
        connectionName: string;
        hdRoutes: HighDensityIntraNodeRoute$1[];
        start: {
            x: number;
            y: number;
            z: number;
        };
        end: {
            x: number;
            y: number;
            z: number;
        };
        colorMap?: Record<string, string>;
        defaultTraceThickness?: number;
        defaultViaDiameter?: number;
    });
    /**
     * Scan `remainingHdRoutes` and find a route that has **one** end that is not
     * within `5e-6` of the start or end of any other route on the same layer.
     * That “lonely” end marks one extremity of the whole chain, which we use as
     * our starting segment. If no such route exists (e.g., the data form a loop),
     * we simply return the first route so the solver can proceed.
     */
    getDisjointedRoute(): {
        firstRoute: HighDensityIntraNodeRoute$1;
    };
    _step(): void;
    visualize(): GraphicsObject;
}

type UnsolvedRoute = {
    connectionName: string;
    hdRoutes: HighDensityIntraNodeRoute$1[];
    start: {
        x: number;
        y: number;
        z: number;
    };
    end: {
        x: number;
        y: number;
        z: number;
    };
};
declare class MultipleHighDensityRouteStitchSolver extends BaseSolver {
    unsolvedRoutes: UnsolvedRoute[];
    activeSolver: SingleHighDensityRouteStitchSolver | null;
    mergedHdRoutes: HighDensityIntraNodeRoute$1[];
    colorMap: Record<string, string>;
    defaultTraceThickness: number;
    defaultViaDiameter: number;
    constructor(opts: {
        connections: SimpleRouteConnection[];
        hdRoutes: HighDensityIntraNodeRoute$1[];
        colorMap?: Record<string, string>;
        layerCount: number;
    });
    _step(): void;
    visualize(): GraphicsObject;
}

type SegmentPointId = string;
type SegmentId = string;
interface BaseUnravelIssue {
    probabilityOfFailure: number;
}
interface UnravelTransitionViaIssue extends BaseUnravelIssue {
    type: "transition_via";
    capacityMeshNodeId: CapacityMeshNodeId;
    segmentPoints: SegmentPointId[];
}
interface UnravelSameLayerCrossingIssue extends BaseUnravelIssue {
    type: "same_layer_crossing";
    capacityMeshNodeId: CapacityMeshNodeId;
    crossingLine1: [SegmentPointId, SegmentPointId];
    crossingLine2: [SegmentPointId, SegmentPointId];
}
interface UnravelSingleTransitionCrossingIssue extends BaseUnravelIssue {
    type: "single_transition_crossing";
    capacityMeshNodeId: CapacityMeshNodeId;
    sameLayerCrossingLine: [SegmentPointId, SegmentPointId];
    transitionCrossingLine: [SegmentPointId, SegmentPointId];
}
interface UnravelDoubleTransitionCrossingIssue extends BaseUnravelIssue {
    type: "double_transition_crossing";
    capacityMeshNodeId: CapacityMeshNodeId;
    crossingLine1: [SegmentPointId, SegmentPointId];
    crossingLine2: [SegmentPointId, SegmentPointId];
}
interface UnravelTraceCapacityIssue extends BaseUnravelIssue {
    type: "same_layer_trace_imbalance_with_low_capacity";
    capacityMeshNodeId: CapacityMeshNodeId;
    z: number;
    tracesOnLayer: Array<{
        A: SegmentPointId;
        B: SegmentPointId;
    }>;
}
interface SegmentPoint {
    segmentPointId: SegmentPointId;
    directlyConnectedSegmentPointIds: SegmentPointId[];
    connectionName: string;
    segmentId: string;
    capacityMeshNodeIds: CapacityMeshNodeId[];
    x: number;
    y: number;
    z: number;
}
type SegmentPointMap = Map<SegmentPointId, SegmentPoint>;
type UnravelIssue = UnravelTransitionViaIssue | UnravelSameLayerCrossingIssue | UnravelSingleTransitionCrossingIssue | UnravelDoubleTransitionCrossingIssue | UnravelTraceCapacityIssue;
interface UnravelSection {
    allNodeIds: CapacityMeshNodeId[];
    mutableNodeIds: CapacityMeshNodeId[];
    mutableSegmentIds: Set<string>;
    immutableNodeIds: CapacityMeshNodeId[];
    segmentPointMap: SegmentPointMap;
    mutableSegmentPointIds: Set<SegmentPointId>;
    segmentPairsInNode: Map<CapacityMeshNodeId, Array<[SegmentPointId, SegmentPointId]>>;
    segmentPointsInNode: Map<CapacityMeshNodeId, SegmentPointId[]>;
    segmentPointsInSegment: Map<SegmentId, SegmentPointId[]>;
    originalPointMap: Map<SegmentPointId, {
        x: number;
        y: number;
        z: number;
    }>;
}
interface UnravelChangeLayerOperation {
    type: "change_layer";
    newZ: number;
    segmentPointIds: SegmentPointId[];
}
interface UnravelSwapPositionOnSegmentOperation {
    type: "swap_position_on_segment";
    segmentPointIds: SegmentPointId[];
}
interface UnravelCombinedOperation {
    type: "combined";
    operations: Array<UnravelChangeLayerOperation | UnravelSwapPositionOnSegmentOperation>;
}
type UnravelOperation = UnravelChangeLayerOperation | UnravelSwapPositionOnSegmentOperation | UnravelCombinedOperation;
type UnravelCandidate = {
    operationsPerformed: number;
    /**
     * A hash of the pointModifications to know if this candidate has already been
     * explored
     */
    candidateHash: string;
    /**
     * More expensive hash that includes original positions
     */
    candidateFullHash?: string;
    pointModifications: Map<SegmentPointId, {
        x?: number;
        y?: number;
        z?: number;
    }>;
    issues: UnravelIssue[];
    /**
     * The cost of this candidate (log probability of failure) considering all of
     * the point modifications
     */
    g: number;
    /**
     * The estimated cost of this candidate (log probability of failure). We don't
     * currently know how to compute this so it's always 0.
     */
    h: number;
    /**
     * Candidate cost ~(g + h)
     */
    f: number;
};

type SegmentPointMapAndReverseMaps = {
    segmentPointMap: SegmentPointMap;
    nodeToSegmentPointMap: Map<CapacityMeshNodeId, SegmentPointId[]>;
    segmentToSegmentPointMap: Map<SegmentId, SegmentPointId[]>;
};

interface UnravelSectionHyperParameters {
    MAX_ITERATIONS_WITHOUT_IMPROVEMENT: number;
}
interface UnravelSectionSolverParams {
    rootNodeId: CapacityMeshNodeId;
    colorMap?: Record<string, string>;
    MUTABLE_HOPS?: number;
    nodeMap: Map<CapacityMeshNodeId, CapacityMeshNode>;
    dedupedSegments: SegmentWithAssignedPoints[];
    dedupedSegmentMap?: Map<SegmentId, SegmentWithAssignedPoints>;
    nodeIdToSegmentIds: Map<CapacityMeshNodeId, CapacityMeshNodeId[]>;
    segmentIdToNodeIds: Map<CapacityMeshNodeId, CapacityMeshNodeId[]>;
    segmentPointMap?: SegmentPointMap;
    nodeToSegmentPointMap?: Map<CapacityMeshNodeId, SegmentPointId[]>;
    segmentToSegmentPointMap?: Map<SegmentId, SegmentPointId[]>;
    hyperParameters?: Partial<UnravelSectionHyperParameters>;
}
/**
 * The UntangleSectionSolver optimizes a section of connected capacity nodes
 * with their deduplicated segments.
 *
 * The section always has a "root" node. From the root node, MUTABLE_HOPS are
 * taken to reach other nodes that are mutable. One additional hop is taken to
 * have all the impacted nodes in section. So a section is composed of mutable
 * and immutable nodes.
 *
 * The goal of the solver is to perform operations on the mutable nodes of the
 * section to lower the overall cost of the section.
 *
 * The untangle phase will perform "operations" on segments based on "issues"
 *
 * An "issue" is anything that increases the cost of the node:
 * - Anything that causes a via (e.g. layer transition)
 * - Any time two traces cross on the same layer
 *
 * An operation is a change to a segment. There are two main operations:
 * - Change layer
 * - Change point order on segment
 *
 * This solver works by exploring different paths of operations. When an
 * operation is performed, new issues are created. Each path has a cost, and
 * a set of neighbors representing next operations to perform.
 *
 */
declare class UnravelSectionSolver extends BaseSolver {
    nodeMap: Map<CapacityMeshNodeId, CapacityMeshNode>;
    dedupedSegments: SegmentWithAssignedPoints[];
    dedupedSegmentMap: Map<SegmentId, SegmentWithAssignedPoints>;
    MUTABLE_HOPS: number;
    unravelSection: UnravelSection;
    candidates: UnravelCandidate[];
    lastProcessedCandidate: UnravelCandidate | null;
    bestCandidate: UnravelCandidate | null;
    originalCandidate: UnravelCandidate;
    rootNodeId: CapacityMeshNodeId;
    nodeIdToSegmentIds: Map<CapacityMeshNodeId, CapacityMeshNodeId[]>;
    segmentIdToNodeIds: Map<CapacityMeshNodeId, CapacityMeshNodeId[]>;
    colorMap: Record<string, string>;
    tunedNodeCapacityMap: Map<CapacityMeshNodeId, number>;
    MAX_CANDIDATES: number;
    iterationsSinceImprovement: number;
    hyperParameters: UnravelSectionHyperParameters;
    selectedCandidateIndex: number | "best" | "original" | null;
    queuedOrExploredCandidatePointModificationHashes: Set<string>;
    constructorParams: UnravelSectionSolverParams;
    constructor(params: UnravelSectionSolverParams);
    getConstructorParams(): UnravelSectionSolverParams;
    createUnravelSection(largeSpMaps?: SegmentPointMapAndReverseMaps): UnravelSection;
    createInitialCandidate(): UnravelCandidate;
    get nextCandidate(): UnravelCandidate | null;
    getPointInCandidate(candidate: UnravelCandidate, segmentPointId: SegmentPointId): {
        x: number;
        y: number;
        z: number;
        segmentId: string;
    };
    getOperationsForIssue(candidate: UnravelCandidate, issue: UnravelIssue): UnravelOperation[];
    computeG(params: {
        issues: UnravelIssue[];
        originalCandidate: UnravelCandidate;
        operationsPerformed: number;
        operation: UnravelOperation;
    }): number;
    getUnexploredNeighborByApplyingOperation(currentCandidate: UnravelCandidate, operation: UnravelOperation): UnravelCandidate | null;
    getNeighborOperationsForCandidate(candidate: UnravelCandidate): UnravelOperation[];
    getNeighbors(candidate: UnravelCandidate): UnravelCandidate[];
    _step(): void;
    visualize(): GraphicsObject;
}

interface CacheProvider {
    isSyncCache: boolean;
    cacheHits: number;
    cacheMisses: number;
    cacheHitsByPrefix: Record<string, number>;
    cacheMissesByPrefix: Record<string, number>;
    getCachedSolutionSync(cacheKey: string): any;
    getCachedSolution(cacheKey: string): Promise<any>;
    setCachedSolutionSync(cacheKey: string, cachedSolution: any): void;
    setCachedSolution(cacheKey: string, cachedSolution: any): Promise<void>;
    getAllCacheKeys(): string[];
    clearCache(): void;
}
interface CachableSolver<CacheToSolveSpaceTransform = any, CachedSolution = any> {
    cacheHit: boolean;
    hasAttemptedToUseCache: boolean;
    cacheProvider: CacheProvider | null;
    cacheKey?: string;
    cacheToSolveSpaceTransform?: CacheToSolveSpaceTransform;
    /**
     * Processes solver inputs and constructs a cacheKey and a cacheToSolveSpaceTransform
     * which gives the necessary information to convert a cached solution into a valid
     * solution for this solver. For example, the cacheKey may be translation-invariant, so
     * any cachedSolution would not be translated properly for this solver. The cacheToSolveSpaceTransform
     * tells you how to convert from the cache space (translation-invarant) to the correct
     * space for this solver. It can also contain information about how cache ids map to
     * ids for the solver
     **/
    computeCacheKeyAndTransform(): {
        cacheKey: string;
        cacheToSolveSpaceTransform: CacheToSolveSpaceTransform;
    };
    applyCachedSolution(cachedSolution: CachedSolution): void;
    attemptToUseCacheSync(): boolean;
    saveToCacheSync(): void;
}

declare class UnravelMultiSectionSolver extends BaseSolver {
    nodeMap: Map<CapacityMeshNodeId, CapacityMeshNode>;
    dedupedSegmentMap: Map<SegmentId, SegmentWithAssignedPoints>;
    dedupedSegments: SegmentWithAssignedPoints[];
    nodeIdToSegmentIds: Map<CapacityMeshNodeId, CapacityMeshNodeId[]>;
    segmentIdToNodeIds: Map<CapacityMeshNodeId, CapacityMeshNodeId[]>;
    nodeToSegmentPointMap: Map<CapacityMeshNodeId, SegmentPointId[]>;
    segmentToSegmentPointMap: Map<SegmentId, SegmentPointId[]>;
    colorMap: Record<string, string>;
    tunedNodeCapacityMap: Map<CapacityMeshNodeId, number>;
    MAX_NODE_ATTEMPTS: number;
    MUTABLE_HOPS: number;
    ACCEPTABLE_PF: number;
    MAX_ITERATIONS_WITHOUT_IMPROVEMENT: number;
    /**
     * Probability of failure for each node
     */
    nodePfMap: Map<CapacityMeshNodeId, number>;
    attemptsToFixNode: Map<CapacityMeshNodeId, number>;
    activeSubSolver: UnravelSectionSolver | null;
    segmentPointMap: SegmentPointMap;
    cacheProvider: CacheProvider | null;
    constructor({ assignedSegments, colorMap, nodes, cacheProvider, }: {
        assignedSegments: NodePortSegment[];
        colorMap?: Record<string, string>;
        /**
         * This isn't used by the algorithm, but allows associating metadata
         * for the result datatype (the center, width, height of the node)
         */
        nodes: CapacityMeshNode[];
        cacheProvider?: CacheProvider | null;
    });
    computeInitialPfMap(): Map<string, number>;
    computeNodePf(node: CapacityMeshNode): number;
    _step(): void;
    visualize(): GraphicsObject;
    getNodesWithPortPoints(): NodeWithPortPoints[];
}

interface CapacityHyperParameters {
    VIA_DIAMETER: number;
    TRACE_WIDTH: number;
    MAX_CAPACITY_FACTOR: number;
}

type Candidate$1 = {
    prevCandidate: Candidate$1 | null;
    node: CapacityMeshNode;
    f: number;
    g: number;
    h: number;
};
type ConnectionPathWithNodes = {
    connection: SimpleRouteConnection;
    nodes: CapacityMeshNode[];
    path?: CapacityMeshNode[];
    straightLineDistance: number;
};
declare class CapacityPathingSolver extends BaseSolver {
    connectionsWithNodes: Array<ConnectionPathWithNodes>;
    usedNodeCapacityMap: Map<CapacityMeshNodeId, number>;
    simpleRouteJson: SimpleRouteJson;
    nodes: CapacityMeshNode[];
    edges: CapacityMeshEdge[];
    GREEDY_MULTIPLIER: number;
    MAX_CANDIDATES_IN_MEMORY: number;
    nodeMap: Map<CapacityMeshNodeId, CapacityMeshNode>;
    nodeEdgeMap: Map<CapacityMeshNodeId, CapacityMeshEdge[]>;
    connectionNameToGoalNodeIds: Map<string, CapacityMeshNodeId[]>;
    colorMap: Record<string, string>;
    maxDepthOfNodes: number;
    activeCandidateStraightLineDistance?: number;
    debug_lastNodeCostMap: Map<CapacityMeshNodeId, {
        g: number;
        h: number;
        f: number;
    }>;
    hyperParameters: Partial<CapacityHyperParameters>;
    constructor({ simpleRouteJson, nodes, edges, colorMap, MAX_ITERATIONS, hyperParameters, }: {
        simpleRouteJson: SimpleRouteJson;
        nodes: CapacityMeshNode[];
        edges: CapacityMeshEdge[];
        colorMap?: Record<string, string>;
        MAX_ITERATIONS?: number;
        hyperParameters?: Partial<CapacityHyperParameters>;
    });
    getTotalCapacity(node: CapacityMeshNode): number;
    getConnectionsWithNodes(): {
        connectionsWithNodes: {
            connection: SimpleRouteConnection;
            nodes: CapacityMeshNode[];
            pathFound: boolean;
            straightLineDistance: number;
        }[];
        connectionNameToGoalNodeIds: Map<string, string[]>;
    };
    currentConnectionIndex: number;
    candidates?: Array<Candidate$1> | null;
    visitedNodes?: Set<CapacityMeshNodeId> | null;
    computeG(prevCandidate: Candidate$1, node: CapacityMeshNode, endGoal: CapacityMeshNode): number;
    computeH(prevCandidate: Candidate$1, node: CapacityMeshNode, endGoal: CapacityMeshNode): number;
    getBacktrackedPath(candidate: Candidate$1): CapacityMeshNode[];
    getNeighboringNodes(node: CapacityMeshNode): CapacityMeshNode[];
    getCapacityPaths(): CapacityPath[];
    doesNodeHaveCapacityForTrace(node: CapacityMeshNode, prevNode: CapacityMeshNode): boolean;
    canTravelThroughObstacle(node: CapacityMeshNode, connectionName: string): boolean;
    getDistanceBetweenNodes(A: CapacityMeshNode, B: CapacityMeshNode): number;
    reduceCapacityAlongPath(nextConnection: {
        path?: CapacityMeshNode[];
    }): void;
    isConnectedToEndGoal(node: CapacityMeshNode, endGoal: CapacityMeshNode): boolean;
    _step(): void;
    visualize(): GraphicsObject;
}

declare class CapacityPathingSolver5 extends CapacityPathingSolver {
    NEGATIVE_CAPACITY_PENALTY_FACTOR: number;
    REDUCED_CAPACITY_PENALTY_FACTOR: number;
    constructor(...args: ConstructorParameters<typeof CapacityPathingSolver>);
    get maxCapacityFactor(): number;
    getTotalCapacity(node: CapacityMeshNode): number;
    /**
     * Penalty you pay for using this node
     */
    getNodeCapacityPenalty(node: CapacityMeshNode): number;
    /**
     * We're rewarding travel into big nodes.
     *
     * To minimize shortest path, you'd want to comment this out.
     */
    getDistanceBetweenNodes(A: CapacityMeshNode, B: CapacityMeshNode): number;
    computeG(prevCandidate: Candidate$1, node: CapacityMeshNode, endGoal: CapacityMeshNode): number;
    computeH(prevCandidate: Candidate$1, node: CapacityMeshNode, endGoal: CapacityMeshNode): number;
}

declare class CapacityPathingGreedySolver extends CapacityPathingSolver5 {
    doesNodeHaveCapacityForTrace(node: CapacityMeshNode, prevNode: CapacityMeshNode): boolean;
    getNodeCapacityPenalty(node: CapacityMeshNode): number;
}

type Candidate = {
    prevCandidate: Candidate | null;
    node: CapacityMeshNode;
    f: number;
    g: number;
    h: number;
};
interface CpssPathingSolverHyperParameters {
    SHUFFLE_SEED?: number;
    EXPANSION_DEGREES?: number;
}
interface CapacityPathingSingleSectionPathingSolverParams {
    sectionNodes: CapacityMeshNode[];
    sectionEdges: CapacityMeshEdge[];
    sectionConnectionTerminals: Array<{
        connectionName: string;
        startNodeId: CapacityMeshNodeId;
        endNodeId: CapacityMeshNodeId;
    }>;
    colorMap?: Record<string, string>;
    centerNodeId: string;
    nodeMap?: Map<CapacityMeshNodeId, CapacityMeshNode>;
    nodeEdgeMap?: Map<CapacityMeshNodeId, CapacityMeshEdge[]>;
    hyperParameters?: CpssPathingSolverHyperParameters;
}
declare class CapacityPathingSingleSectionSolver extends BaseSolver {
    GREEDY_MULTIPLIER: number;
    sectionNodes: CapacityMeshNode[];
    sectionEdges: CapacityMeshEdge[];
    sectionConnectionTerminals: Array<{
        connectionName: string;
        startNodeId: CapacityMeshNodeId;
        endNodeId: CapacityMeshNodeId;
        path?: CapacityMeshNode[];
    }>;
    nodeMap: Map<CapacityMeshNodeId, CapacityMeshNode>;
    nodeEdgeMap: Map<CapacityMeshNodeId, CapacityMeshEdge[]>;
    colorMap: Record<string, string>;
    usedNodeCapacityMap: Map<CapacityMeshNodeId, number>;
    totalNodeCapacityMap: Map<CapacityMeshNodeId, number>;
    centerNodeId: string;
    private currentSectionScore;
    MAX_CANDIDATES_IN_MEMORY: number;
    currentConnectionIndex: number;
    candidates?: Array<Candidate> | null;
    visitedNodes?: Set<CapacityMeshNodeId> | null;
    queuedNodes?: Set<CapacityMeshNodeId> | null;
    activeCandidateStraightLineDistance?: number;
    debug_lastNodeCostMap: Map<CapacityMeshNodeId, {
        g: number;
        h: number;
        f: number;
    }>;
    maxCapacityFactor: number;
    constructor(params: CapacityPathingSingleSectionPathingSolverParams);
    getTotalCapacity(node: CapacityMeshNode): number;
    getNodeCapacityPenalty(node: CapacityMeshNode): number;
    getDistanceBetweenNodes(A: CapacityMeshNode, B: CapacityMeshNode): number;
    computeG(prevCandidate: Candidate, node: CapacityMeshNode, endGoal: CapacityMeshNode): number;
    computeH(prevCandidate: Candidate, // prevCandidate not strictly needed here
    node: CapacityMeshNode, endGoal: CapacityMeshNode): number;
    getBacktrackedPath(candidate: Candidate): CapacityMeshNode[];
    getNeighboringNodes(node: CapacityMeshNode): CapacityMeshNode[];
    isConnectedToEndGoal(node: CapacityMeshNode, endGoal: CapacityMeshNode): boolean;
    doesNodeHaveCapacityForTrace(node: CapacityMeshNode, prevNode: CapacityMeshNode | null): boolean;
    reduceCapacityAlongPath(path: CapacityMeshNode[]): void;
    getSolvedSectionScore(): number;
    _step(): void;
    computeProgress(): number;
    private _setupAStar;
    private _handleCandidatesExhausted;
    private _handleGoalReached;
    visualize(): GraphicsObject;
}
declare const CapacityPathingSingleSectionPathingSolver: typeof CapacityPathingSingleSectionSolver;
type CapacityPathingSingleSectionPathingSolver = InstanceType<typeof CapacityPathingSingleSectionSolver>;

declare class HyperCapacityPathingSingleSectionSolver extends HyperParameterSupervisorSolver<CapacityPathingSingleSectionPathingSolver> {
    constructorParams: CapacityPathingSingleSectionPathingSolverParams;
    winningSolver?: CapacityPathingSingleSectionPathingSolver;
    constructor(params: ConstructorParameters<typeof CapacityPathingSingleSectionPathingSolver>[0]);
    computeG(solver: CapacityPathingSingleSectionPathingSolver): number;
    computeH(solver: CapacityPathingSingleSectionPathingSolver): number;
    getCombinationDefs(): Array<Array<string>> | null;
    getFailureMessage(): string;
    getHyperParameterDefs(): Array<HyperParameterDef>;
    generateSolver(hyperParameters: any): CapacityPathingSingleSectionPathingSolver;
    onSolve({ solver, }: SupervisedSolver<CapacityPathingSingleSectionPathingSolver>): void;
    get centerNodeId(): string;
    get sectionNodes(): CapacityMeshNode[];
    get sectionConnectionTerminals(): {
        connectionName: string;
        startNodeId: CapacityMeshNodeId;
        endNodeId: CapacityMeshNodeId;
        path?: CapacityMeshNode[];
    }[] | undefined;
}

interface SectionConnectionTerminal {
    connectionName: string;
    startNodeId: CapacityMeshNodeId;
    endNodeId: CapacityMeshNodeId;
    path?: CapacityMeshNode[];
}
interface CapacityPathingSection {
    centerNodeId: string;
    sectionConnectionTerminals: SectionConnectionTerminal[];
    sectionNodes: CapacityMeshNode[];
    sectionEdges: CapacityMeshEdge[];
}

type CapacityMeshEdgeId = string;
/**
 * This solver solves for capacity paths by first solving with negative
 * capacities allowed, then re-solving problematic sections with a section
 * solver.
 */
declare class CapacityPathingMultiSectionSolver extends BaseSolver {
    simpleRouteJson: SimpleRouteJson;
    nodes: CapacityMeshNode[];
    edges: CapacityMeshEdge[];
    nodeEdgeMap: Map<CapacityMeshEdgeId, CapacityMeshEdge[]>;
    connectionsWithNodes: Array<ConnectionPathWithNodes>;
    colorMap: Record<string, string>;
    initialSolver: CapacityPathingGreedySolver;
    cacheProvider?: CacheProvider | null;
    stage: "initialization" | "section-optimization";
    nodeMap: Map<CapacityMeshNodeId, CapacityMeshNode>;
    allNodeIdsSet: Set<CapacityMeshNodeId>;
    usedNodeCapacityMap: Map<CapacityMeshNodeId, number>;
    totalNodeCapacityMap: Map<CapacityMeshNodeId, number>;
    nodeCapacityPercentMap: Map<CapacityMeshNodeId, number>;
    nodeOptimizationAttemptCountMap: Map<CapacityMeshNodeId, number>;
    currentSection: CapacityPathingSection | null;
    sectionSolver?: CapacityPathingSingleSectionSolver | HyperCapacityPathingSingleSectionSolver | null;
    currentScheduleIndex: number;
    stats: {
        successfulOptimizations: number;
        failedOptimizations: number;
        failedSectionSolvers: number;
        startingScore: number;
        scheduleScores: Array<{
            maxExpansionDegrees: number;
            sectionAttempts: number;
            endingScore: number;
            endingHighestNodePf: number;
        }>;
        cacheHits: number;
        cacheMisses: number;
    };
    OPTIMIZATION_SCHEDULE: {
        MAX_ATTEMPTS_PER_NODE: number;
        MAX_EXPANSION_DEGREES: number;
        MINIMUM_PROBABILITY_OF_FAILURE_TO_OPTIMIZE: number;
    }[];
    get currentSchedule(): {
        MAX_ATTEMPTS_PER_NODE: number;
        MAX_EXPANSION_DEGREES: number;
        MINIMUM_PROBABILITY_OF_FAILURE_TO_OPTIMIZE: number;
    };
    constructor(params: ConstructorParameters<typeof CapacityPathingSolver>[0] & {
        initialPathingSolver?: CapacityPathingGreedySolver;
        cacheProvider?: CacheProvider | null;
    });
    _stepInitialization(): void;
    _getNextNodeToOptimize(): CapacityMeshNodeId | null;
    getOverallScore(): {
        highestNodePf: number;
        score: number;
    };
    _stepSectionOptimization(): void;
    /**
     * Merges the paths found by a successful section solver back into the main
     * connectionsWithNodes list.
     */
    private _mergeSolvedSectionPaths;
    /**
     * Recalculates node capacity usage based on the current connectionsWithNodes
     * and updates the nodeCapacityPercentMap.
     */
    private _recalculateNodeCapacityUsage;
    getCapacityPaths(): CapacityPath[];
    _step(): void;
    visualize(): graphics_debug.GraphicsObject;
}

declare class StrawSolver extends BaseSolver {
    multiLayerNodes: CapacityMeshNode[];
    strawNodes: CapacityMeshNode[];
    skippedNodes: CapacityMeshNode[];
    unprocessedNodes: CapacityMeshNode[];
    strawSize: number;
    nodeIdCounter: number;
    constructor(params: {
        nodes: CapacityMeshNode[];
        strawSize?: number;
    });
    getCapacityOfMultiLayerNodesWithinBounds(bounds: {
        minX: number;
        maxX: number;
        minY: number;
        maxY: number;
    }): number;
    getSurroundingCapacities(node: CapacityMeshNode): {
        leftSurroundingCapacity: number;
        rightSurroundingCapacity: number;
        topSurroundingCapacity: number;
        bottomSurroundingCapacity: number;
    };
    /**
     * Creates straw nodes from a single-layer node based on surrounding capacities
     */
    createStrawsForNode(node: CapacityMeshNode): CapacityMeshNode[];
    getResultNodes(): CapacityMeshNode[];
    _step(): void;
    visualize(): GraphicsObject;
}

/**
 * Merges same layer nodes into larger nodes. Pre-processing stage necessary
 * for "strawing".
 */
declare class SingleLayerNodeMergerSolver extends BaseSolver {
    nodeMap: Map<CapacityMeshNodeId, CapacityMeshNode>;
    currentBatchNodeIds: CapacityMeshNodeId[];
    absorbedNodeIds: Set<CapacityMeshNodeId>;
    nextBatchNodeIds: CapacityMeshNodeId[];
    batchHadModifications: boolean;
    hasComputedAdjacentNodeIds: boolean;
    newNodes: CapacityMeshNode[];
    constructor(nodes: CapacityMeshNode[]);
    computeAdjacentNodeIdsForFirstBatch(nodes: CapacityMeshNode[]): void;
    getAdjacentSameLayerUnprocessedNodes(rootNode: CapacityMeshNode): CapacityMeshNode[];
    getAdjacentSameLayerUnprocessedNodes2(rootNode: CapacityMeshNode): CapacityMeshNode[];
    _step(): void;
    visualize(): GraphicsObject;
}

interface Point$1 {
    x: number;
    y: number;
    z: number;
}
declare class SingleSimplifiedPathSolver extends BaseSolver {
    newRoute: HighDensityIntraNodeRoute$1["route"];
    newVias: HighDensityIntraNodeRoute$1["vias"];
    headIndex: number;
    tailIndex: number;
    inputRoute: HighDensityIntraNodeRoute$1;
    otherHdRoutes: HighDensityIntraNodeRoute$1[];
    obstacles: Obstacle[];
    connMap: ConnectivityMap;
    colorMap: Record<string, string>;
    constructor(params: {
        inputRoute: HighDensityIntraNodeRoute$1;
        otherHdRoutes: HighDensityIntraNodeRoute$1[];
        obstacles: Obstacle[];
        connMap: ConnectivityMap;
        colorMap: Record<string, string>;
    });
    getConstructorParams(): {
        inputRoute: HighDensityIntraNodeRoute$1;
        otherHdRoutes: HighDensityIntraNodeRoute$1[];
        obstacles: Obstacle[];
        connMap: Record<string, string[]>;
        colorMap: Record<string, string>;
    };
    get simplifiedRoute(): HighDensityIntraNodeRoute$1;
    isValidPath(pointsInRoute: Point$1[]): boolean;
    _step(): void;
    getVisualsForNewRouteAndObstacles(): Required<GraphicsObject>;
}

declare class MultiSimplifiedPathSolver extends BaseSolver {
    simplifiedHdRoutes: HighDensityIntraNodeRoute$1[];
    currentUnsimplifiedHdRouteIndex: number;
    activeSubSolver: SingleSimplifiedPathSolver | null;
    unsimplifiedHdRoutes: HighDensityIntraNodeRoute$1[];
    obstacles: Obstacle[];
    connMap: ConnectivityMap;
    colorMap: Record<string, string>;
    constructor(params: {
        unsimplifiedHdRoutes: HighDensityIntraNodeRoute$1[];
        obstacles: Obstacle[];
        connMap?: ConnectivityMap;
        colorMap?: Record<string, string>;
    });
    _step(): void;
    visualize(): GraphicsObject;
}

declare class CapacityMeshEdgeSolver2_NodeTreeOptimization extends CapacityMeshEdgeSolver {
    nodes: CapacityMeshNode[];
    private nodeTree;
    private currentNodeIndex;
    private edgeSet;
    constructor(nodes: CapacityMeshNode[]);
    _step(): void;
}

declare class DeadEndSolver extends BaseSolver {
    removedNodeIds: Set<string>;
    private targetNodeIds;
    private leaves;
    private leavesIndex;
    private adjacencyList;
    /** Only used for visualization, dynamically instantiated if necessary */
    nodeMap?: Map<CapacityMeshNodeId, CapacityMeshNode>;
    private nodes;
    private edges;
    constructor({ nodes, edges, }: {
        nodes: CapacityMeshNode[];
        edges: CapacityMeshEdge[];
    });
    _step(): void;
    visualize(): GraphicsObject;
}

interface Point {
    x: number;
    y: number;
    z: number;
}
type Point2D = {
    x: number;
    y: number;
};
type HighDensityIntraNodeRoute = {
    connectionName: string;
    traceThickness: number;
    viaDiameter: number;
    route: Array<{
        x: number;
        y: number;
        z: number;
    }>;
    vias: Array<{
        x: number;
        y: number;
    }>;
};
type HighDensityRoute = HighDensityIntraNodeRoute;
declare class HighDensityRouteSpatialIndex {
    private segmentBuckets;
    private viaBuckets;
    private routes;
    private CELL_SIZE;
    constructor(routes: HighDensityRoute[], cellSize?: number);
    /**
     * Finds routes that potentially conflict with a given line segment within a margin.
     * Checks both segments and vias.
     * @param segmentStart Start point of the query segment.
     * @param segmentEnd End point of the query segment.
     * @param margin The minimum required clearance distance from the query segment's centerline.
     * @returns An array of conflicting routes and their minimum distance to the segment.
     */
    getConflictingRoutesForSegment(segmentStart: Point, // Keep Point for original Z data if needed elsewhere
    segmentEnd: Point, margin: number): Array<{
        conflictingRoute: HighDensityRoute;
        distance: number;
    }>;
    /**
     * Finds routes that pass near a given point within a margin.
     * Checks both segments and vias.
     * @param point The query point {x, y}. Z is ignored.
     * @param margin The minimum required clearance distance from the query point.
     * @returns An array of conflicting routes and their minimum distance to the point.
     */
    getConflictingRoutesNearPoint(point: Point2D, margin: number): Array<{
        conflictingRoute: HighDensityRoute;
        distance: number;
    }>;
}

interface RouteSection {
    startIndex: number;
    endIndex: number;
    z: number;
    points: HighDensityRoute["route"];
}
declare class SingleRouteUselessViaRemovalSolver extends BaseSolver {
    obstacleSHI: ObstacleSpatialHashIndex;
    hdRouteSHI: HighDensityRouteSpatialIndex;
    unsimplifiedRoute: HighDensityRoute;
    routeSections: Array<RouteSection>;
    currentSectionIndex: number;
    TRACE_THICKNESS: number;
    OBSTACLE_MARGIN: number;
    constructor(params: {
        obstacleSHI: ObstacleSpatialHashIndex;
        hdRouteSHI: HighDensityRouteSpatialIndex;
        unsimplifiedRoute: HighDensityRoute;
    });
    breakRouteIntoSections(route: HighDensityRoute): never[] | this["routeSections"];
    _step(): void;
    canSectionMoveToLayer({ currentSection, targetZ, }: {
        currentSection: RouteSection;
        targetZ: number;
    }): boolean;
    getConstructorParams(): {
        obstacleSHI: ObstacleSpatialHashIndex;
        hdRouteSHI: HighDensityRouteSpatialIndex;
        unsimplifiedRoute: HighDensityIntraNodeRoute;
    };
    getOptimizedHdRoute(): HighDensityRoute;
    visualize(): GraphicsObject;
}

interface UselessViaRemovalSolverInput {
    unsimplifiedHdRoutes: HighDensityRoute$1[];
    obstacles: Obstacle[];
    colorMap: Record<string, string>;
    layerCount: number;
}
declare class UselessViaRemovalSolver extends BaseSolver {
    private input;
    unsimplifiedHdRoutes: HighDensityRoute$1[];
    optimizedHdRoutes: HighDensityRoute$1[];
    unprocessedRoutes: HighDensityRoute$1[];
    activeSubSolver?: SingleRouteUselessViaRemovalSolver | null | undefined;
    obstacleSHI: ObstacleSpatialHashIndex | null;
    hdRouteSHI: HighDensityRouteSpatialIndex | null;
    constructor(input: UselessViaRemovalSolverInput);
    _step(): void;
    getOptimizedHdRoutes(): HighDensityRoute$1[] | null;
    visualize(): GraphicsObject;
}

interface CapacityMeshSolverOptions {
    capacityDepth?: number;
    targetMinCapacity?: number;
    cacheProvider?: CacheProvider | null;
}
type PipelineStep<T extends new (...args: any[]) => BaseSolver> = {
    solverName: string;
    solverClass: T;
    getConstructorParams: (instance: AutoroutingPipelineSolver) => ConstructorParameters<T>;
    onSolved?: (instance: AutoroutingPipelineSolver) => void;
};
declare class AutoroutingPipelineSolver extends BaseSolver {
    srj: SimpleRouteJson;
    opts: CapacityMeshSolverOptions;
    netToPointPairsSolver?: NetToPointPairsSolver;
    nodeSolver?: CapacityMeshNodeSolver;
    nodeTargetMerger?: CapacityNodeTargetMerger;
    edgeSolver?: CapacityMeshEdgeSolver;
    initialPathingSolver?: CapacityPathingGreedySolver;
    pathingOptimizer?: CapacityPathingMultiSectionSolver;
    edgeToPortSegmentSolver?: CapacityEdgeToPortSegmentSolver;
    colorMap: Record<string, string>;
    segmentToPointSolver?: CapacitySegmentToPointSolver;
    unravelMultiSectionSolver?: UnravelMultiSectionSolver;
    segmentToPointOptimizer?: CapacitySegmentPointOptimizer;
    highDensityRouteSolver?: HighDensitySolver;
    highDensityStitchSolver?: MultipleHighDensityRouteStitchSolver;
    singleLayerNodeMerger?: SingleLayerNodeMergerSolver;
    strawSolver?: StrawSolver;
    deadEndSolver?: DeadEndSolver;
    uselessViaRemovalSolver1?: UselessViaRemovalSolver;
    uselessViaRemovalSolver2?: UselessViaRemovalSolver;
    multiSimplifiedPathSolver1?: MultiSimplifiedPathSolver;
    multiSimplifiedPathSolver2?: MultiSimplifiedPathSolver;
    startTimeOfPhase: Record<string, number>;
    endTimeOfPhase: Record<string, number>;
    timeSpentOnPhase: Record<string, number>;
    activeSubSolver?: BaseSolver | null;
    connMap: ConnectivityMap;
    srjWithPointPairs?: SimpleRouteJson;
    capacityNodes: CapacityMeshNode[] | null;
    capacityEdges: CapacityMeshEdge[] | null;
    cacheProvider: CacheProvider | null;
    pipelineDef: (PipelineStep<typeof NetToPointPairsSolver> | PipelineStep<typeof CapacityMeshNodeSolver2_NodeUnderObstacle> | PipelineStep<typeof SingleLayerNodeMergerSolver> | PipelineStep<typeof StrawSolver> | PipelineStep<typeof CapacityMeshEdgeSolver2_NodeTreeOptimization> | PipelineStep<typeof DeadEndSolver> | PipelineStep<typeof CapacityPathingGreedySolver> | PipelineStep<typeof CapacityPathingMultiSectionSolver> | PipelineStep<typeof CapacityEdgeToPortSegmentSolver> | PipelineStep<typeof CapacitySegmentToPointSolver> | PipelineStep<typeof UnravelMultiSectionSolver> | PipelineStep<typeof HighDensitySolver> | PipelineStep<typeof MultipleHighDensityRouteStitchSolver> | PipelineStep<typeof UselessViaRemovalSolver> | PipelineStep<typeof MultiSimplifiedPathSolver>)[];
    constructor(srj: SimpleRouteJson, opts?: CapacityMeshSolverOptions);
    currentPipelineStepIndex: number;
    _step(): void;
    solveUntilPhase(phase: string): void;
    getCurrentPhase(): string;
    visualize(): GraphicsObject;
    /**
     * A lightweight version of the visualize method that can be used to stream
     * progress
     *
     * We return the most relevant graphic for the stage:
     * 1. netToPointPairs output
     * 2. Capacity Planning Output
     * 3. High Density Route Solver Output, max 200 lines
     */
    preview(): GraphicsObject;
    /**
     * Get original connection name from connection name with MST suffix
     * @param mstConnectionName The MST-suffixed connection name (e.g. "connection1_mst0")
     * @returns The original connection name (e.g. "connection1")
     */
    private getOriginalConnectionName;
    _getOutputHdRoutes(): HighDensityRoute$1[];
    /**
     * Returns the SimpleRouteJson with routes converted to SimplifiedPcbTraces
     */
    getOutputSimplifiedPcbTraces(): SimplifiedPcbTraces;
    getOutputSimpleRouteJson(): SimpleRouteJson;
}
/** @deprecated Use AutoroutingPipelineSolver instead */
declare const CapacityMeshSolver: typeof AutoroutingPipelineSolver;
type CapacityMeshSolver = AutoroutingPipelineSolver;

/**
 * Calculate the capacity of a node based on its width
 *
 * This capacity corresponds to how many vias the node can fit, tuned for two
 * layers.
 *
 * @param nodeOrWidth The node or width to calculate capacity for
 * @param maxCapacityFactor Optional multiplier to adjust capacity
 * @returns The calculated capacity
 */
declare const getTunedTotalCapacity1: (nodeOrWidth: CapacityMeshNode | {
    width: number;
    availableZ?: number[];
}, maxCapacityFactor?: number) => number;
/**
 * Calculate the optimal subdivision depth to reach a target minimum capacity
 * @param initialWidth The initial width of the top-level node
 * @param targetMinCapacity The minimum capacity target (default 0.5)
 * @param maxDepth Maximum allowed depth (default 10)
 * @returns The optimal capacity depth
 */
declare const calculateOptimalCapacityDepth: (initialWidth: number, targetMinCapacity?: number, maxDepth?: number) => number;

/**
 * An in-memory implementation of the CacheProvider interface.
 * Useful for testing or scenarios where persistence is not required.
 */
declare class InMemoryCache implements CacheProvider {
    cacheHitsByPrefix: Record<string, number>;
    cacheMissesByPrefix: Record<string, number>;
    isSyncCache: boolean;
    cacheHits: number;
    cacheMisses: number;
    cache: Map<string, any>;
    /**
     * Retrieves a cached solution synchronously based on the cache key.
     * Increments cache hit/miss counters.
     * @param cacheKey The key to look up in the cache.
     * @returns The cached solution if found, otherwise undefined.
     */
    getCachedSolutionSync(cacheKey: string): any;
    /**
     * Retrieves a cached solution asynchronously. Wraps the synchronous method.
     * @param cacheKey The key to look up in the cache.
     * @returns A promise that resolves with the cached solution or undefined.
     */
    getCachedSolution(cacheKey: string): Promise<any>;
    /**
     * Stores a solution in the cache synchronously.
     * Uses structured cloning to store a copy, preventing external modifications.
     * @param cacheKey The key under which to store the solution.
     * @param cachedSolution The solution data to cache.
     */
    setCachedSolutionSync(cacheKey: string, cachedSolution: any): void;
    /**
     * Stores a solution in the cache asynchronously. Wraps the synchronous method.
     * @param cacheKey The key under which to store the solution.
     * @param cachedSolution The solution data to cache.
     * @returns A promise that resolves when the solution is cached.
     */
    setCachedSolution(cacheKey: string, cachedSolution: any): Promise<void>;
    /**
     * Clears the entire cache and resets hit/miss counters.
     */
    clearCache(): void;
    getAllCacheKeys(): string[];
}

/**
 * A CacheProvider implementation using the browser's localStorage.
 * Note: localStorage has size limits (typically 5-10MB) and stores data as strings.
 * Complex objects will be JSON serialized/deserialized.
 */
declare class LocalStorageCache implements CacheProvider {
    isSyncCache: boolean;
    cacheHits: number;
    cacheMisses: number;
    cacheHitsByPrefix: Record<string, number>;
    cacheMissesByPrefix: Record<string, number>;
    constructor();
    private getKey;
    /**
     * Retrieves a cached solution synchronously from localStorage.
     * Increments cache hit/miss counters.
     * @param cacheKey The key to look up in the cache.
     * @returns The cached solution if found and parsed correctly, otherwise undefined.
     */
    getCachedSolutionSync(cacheKey: string): any;
    /**
     * Retrieves a cached solution asynchronously. Wraps the synchronous method.
     * @param cacheKey The key to look up in the cache.
     * @returns A promise that resolves with the cached solution or undefined.
     */
    getCachedSolution(cacheKey: string): Promise<any>;
    /**
     * Stores a solution in localStorage synchronously.
     * The solution is JSON stringified before storing.
     * @param cacheKey The key under which to store the solution.
     * @param cachedSolution The solution data to cache.
     */
    setCachedSolutionSync(cacheKey: string, cachedSolution: any): void;
    /**
     * Stores a solution in the cache asynchronously. Wraps the synchronous method.
     * @param cacheKey The key under which to store the solution.
     * @param cachedSolution The solution data to cache.
     * @returns A promise that resolves when the solution is cached.
     */
    setCachedSolution(cacheKey: string, cachedSolution: any): Promise<void>;
    /**
     * Clears all cache entries created by this instance from localStorage
     * and resets hit/miss counters.
     */
    clearCache(): void;
    getAllCacheKeys(): string[];
}

declare global {
    var TSCIRCUIT_AUTOROUTER_LOCAL_STORAGE_CACHE: LocalStorageCache;
    var TSCIRCUIT_AUTOROUTER_IN_MEMORY_CACHE: InMemoryCache;
}
declare function getGlobalLocalStorageCache(): LocalStorageCache;
declare function getGlobalInMemoryCache(): InMemoryCache;
declare function setupGlobalCaches(): void;

declare const convertSrjToGraphicsObject: (srj: SimpleRouteJson) => {
    rects: Rect[];
    circles: Circle[];
    lines: Line[];
    points: Point$3[];
};

export { type CachableSolver, type CacheProvider, CapacityMeshSolver, InMemoryCache, LocalStorageCache, calculateOptimalCapacityDepth, convertSrjToGraphicsObject, getGlobalInMemoryCache, getGlobalLocalStorageCache, getTunedTotalCapacity1, setupGlobalCaches };
