{"version":3,"sources":["../lib/utils/combineVisualizations.ts","../lib/solvers/BaseSolver.ts","../node_modules/@babel/runtime/helpers/esm/extends.js","../node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js","../node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js","../node_modules/@babel/runtime/helpers/esm/inheritsLoose.js","../node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js","../node_modules/@babel/runtime/helpers/esm/isNativeFunction.js","../node_modules/@babel/runtime/helpers/esm/isNativeReflectConstruct.js","../node_modules/@babel/runtime/helpers/esm/construct.js","../node_modules/@babel/runtime/helpers/esm/wrapNativeSuper.js","../node_modules/polished/dist/polished.esm.js","../lib/solvers/colors.ts","../lib/utils/mapLayerNameToZ.ts","../lib/utils/getTunedTotalCapacity1.ts","../node_modules/quickselect/index.js","../node_modules/rbush/index.js","../lib/data-structures/RbushIndex.ts","../node_modules/flatqueue/index.js","../node_modules/flatbush/index.js","../lib/data-structures/FlatbushIndex.ts","../lib/data-structures/ObstacleTree.ts","../lib/data-structures/TargetTree.ts","../lib/solvers/CapacityMeshSolver/CapacityMeshNodeSolver1.ts","../lib/solvers/CapacityMeshSolver/CapacityMeshNodeSolver2_NodesUnderObstacles.ts","../lib/solvers/CapacityMeshSolver/getNodeEdgeMap.ts","../lib/solvers/CapacityMeshSolver/CapacityEdgeToPortSegmentSolver.ts","../lib/solvers/CapacityMeshSolver/CapacitySegmentToPointSolver.ts","../node_modules/@tscircuit/math-utils/src/line-intersections.ts","../node_modules/@tscircuit/math-utils/src/nearest-box.ts","../node_modules/@tscircuit/math-utils/src/segment-distance.ts","../node_modules/@tscircuit/math-utils/src/point-distance.ts","../lib/data-structures/SingleRouteCandidatePriorityQueue.ts","../lib/solvers/HighDensitySolver/SingleHighDensityRouteSolver.ts","../lib/solvers/HighDensitySolver/SingleHighDensityRouteSolver6_VertHorzLayer_FutureCost.ts","../lib/utils/cloneAndShuffleArray.ts","../lib/utils/getBoundsFromNodeWithPortPoints.ts","../lib/utils/getMinDistBetweenEnteringPoints.ts","../lib/solvers/HighDensitySolver/IntraNodeSolver.ts","../lib/solvers/HyperParameterSupervisorSolver.ts","../lib/solvers/HighDensitySolver/TwoRouteHighDensitySolver/findCircleLineIntersections.ts","../lib/solvers/HighDensitySolver/TwoRouteHighDensitySolver/computeDumbbellPaths.ts","../lib/solvers/HighDensitySolver/TwoRouteHighDensitySolver/TwoCrossingRoutesHighDensitySolver.ts","../lib/utils/findClosestPointToABCWithinBounds.ts","../lib/utils/findPointToGetAroundCircle.ts","../lib/solvers/HighDensitySolver/TwoRouteHighDensitySolver/calculateSideTraversal.ts","../lib/solvers/HighDensitySolver/TwoRouteHighDensitySolver/computeTurnDirection.ts","../lib/solvers/HighDensitySolver/TwoRouteHighDensitySolver/SingleTransitionCrossingRouteSolver.ts","../lib/utils/getPortPairs.ts","../lib/utils/generateColorMapFromNodeWithPortPoints.ts","../lib/solvers/ViaPossibilitiesSolver/ViaPossibilitiesSolver2.ts","../lib/utils/getIntraNodeCrossings.ts","../lib/solvers/HighDensitySolver/MultiHeadPolyLineIntraNodeSolver/getCentroidsFromInnerBoxIntersections.ts","../lib/solvers/HighDensitySolver/MultiHeadPolyLineIntraNodeSolver/generateBinaryCombinations.ts","../lib/solvers/HighDensitySolver/MultiHeadPolyLineIntraNodeSolver/getPossibleInitialViaPositions.ts","../lib/solvers/HighDensitySolver/MultiHeadPolyLineIntraNodeSolver/getEveryPossibleOrdering.ts","../lib/solvers/HighDensitySolver/MultiHeadPolyLineIntraNodeSolver/createSymmetricArray.ts","../lib/solvers/HighDensitySolver/MultiHeadPolyLineIntraNodeSolver/constructMiddlePointsWithViaPositions.ts","../lib/solvers/HighDensitySolver/MultiHeadPolyLineIntraNodeSolver/getEveryCombinationFromChoiceArray.ts","../lib/solvers/HighDensitySolver/MultiHeadPolyLineIntraNodeSolver/computeViaCountVariants.ts","../lib/solvers/HighDensitySolver/MultiHeadPolyLineIntraNodeSolver/withinBounds.ts","../lib/solvers/HighDensitySolver/MultiHeadPolyLineIntraNodeSolver/detectMultiConnectionClosedFacesWithoutVias.ts","../lib/solvers/HighDensitySolver/MultiHeadPolyLineIntraNodeSolver/MultiHeadPolyLineIntraNodeSolver.ts","../lib/solvers/HighDensitySolver/MultiHeadPolyLineIntraNodeSolver/MultiHeadPolyLineIntraNodeSolver2_Optimized.ts","../lib/solvers/HighDensitySolver/MultiHeadPolyLineIntraNodeSolver/MultiHeadPolyLineIntraNodeSolver3_ViaPossibilitiesSolverIntegration.ts","../lib/solvers/HyperHighDensitySolver/HyperSingleIntraNodeSolver.ts","../lib/utils/mergeRouteSegments.ts","../lib/solvers/HighDensitySolver/HighDensitySolver.ts","../node_modules/circuit-json-to-connectivity-map/src/findConnectedNetworks.ts","../node_modules/circuit-json-to-connectivity-map/src/ConnectivityMap.ts","../node_modules/circuit-json-to-connectivity-map/src/getSourcePortConnectivityMapFromCircuitJson.ts","../node_modules/circuit-json-to-connectivity-map/src/getFullConnectivityMapFromCircuitJson.ts","../node_modules/circuit-json-to-connectivity-map/src/PcbConnectivityMap.ts","../lib/utils/getConnectivityMapFromSimpleRouteJson.ts","../lib/solvers/NetToPointPairsSolver/buildMinimumSpanningTree.ts","../lib/solvers/NetToPointPairsSolver/NetToPointPairsSolver.ts","../lib/utils/mapZToLayerName.ts","../lib/utils/convertHdRouteToSimplifiedRoute.ts","../lib/solvers/RouteStitchingSolver/SingleHighDensityRouteStitchSolver.ts","../lib/solvers/RouteStitchingSolver/MultipleHighDensityRouteStitchSolver.ts","../lib/utils/convertSrjToGraphicsObject.ts","../lib/solvers/UnravelSolver/getNodesNearNode.ts","../lib/solvers/UnravelSolver/createPointModificationsHash.ts","../lib/solvers/UnravelSolver/hasZRangeOverlap.ts","../lib/solvers/UnravelSolver/getIssuesInSection.ts","../lib/solvers/UnravelSolver/applyOperationToPointModifications.ts","../lib/solvers/UnravelSolver/createSegmentPointMap.ts","../lib/solvers/UnravelSolver/calculateCrossingProbabilityOfFailure.ts","../lib/solvers/UnravelSolver/UnravelSectionSolver.ts","../lib/solvers/UnravelSolver/CachedUnravelSectionSolver.ts","../lib/cache/InMemoryCache.ts","../lib/cache/LocalStorageCache.ts","../lib/cache/setupGlobalCaches.ts","../node_modules/transformation-matrix/src/applyToPoint.js","../node_modules/transformation-matrix/src/translate.js","../node_modules/transformation-matrix/src/rotate.js","../node_modules/transformation-matrix/src/skew.js","../node_modules/transformation-matrix/src/fromTransformAttribute.autogenerated.js","../lib/solvers/UnravelSolver/getDedupedSegments.ts","../lib/utils/getIntraNodeCrossingsFromSegmentPoints.ts","../lib/solvers/UnravelSolver/UnravelMultiSectionSolver.ts","../lib/utils/createRectFromCapacityNode.ts","../lib/solvers/CapacityPathingSolver/CapacityPathingSolver.ts","../lib/solvers/CapacityPathingSolver/CapacityPathingSolver5.ts","../lib/solvers/CapacityPathingSectionSolver/CapacityPathingGreedySolver.ts","../lib/utils/getLinesBetweenNodes.ts","../lib/solvers/CapacityPathingSectionSolver/computeSectionScore.ts","../lib/solvers/CapacityPathingSectionSolver/visualizeSection.ts","../lib/solvers/CapacityPathingSectionSolver/computeSectionNodesTerminalsAndEdges.ts","../lib/solvers/CapacityPathingSectionSolver/CapacityPathingSingleSectionSolver.ts","../lib/solvers/CapacityPathingSectionSolver/HyperCapacityPathingSingleSectionSolver.ts","../lib/solvers/CapacityPathingSectionSolver/CachedHyperCapacityPathingSingleSectionSolver.ts","../lib/solvers/CapacityPathingSectionSolver/CapacityPathingMultiSectionSolver.ts","../lib/solvers/StrawSolver/StrawSolver.ts","../lib/utils/areNodesBordering.ts","../lib/data-structures/CapacityNodeTree.ts","../lib/solvers/SingleLayerNodeMerger/SingleLayerNodeMergerSolver.ts","../lib/solvers/SimplifiedPathSolver/SingleSimplifiedPathSolver.ts","../lib/utils/calculate45DegreePaths.ts","../lib/utils/minimumDistanceBetweenSegments.ts","../lib/data-structures/SegmentTree.ts","../lib/solvers/SimplifiedPathSolver/SingleSimplifiedPathSolver5_Deg45.ts","../lib/solvers/SimplifiedPathSolver/MultiSimplifiedPathSolver.ts","../lib/solvers/CapacityMeshSolver/CapacityMeshEdgeSolver.ts","../lib/solvers/CapacityMeshSolver/CapacityMeshEdgeSolver2_NodeTreeOptimization.ts","../lib/solvers/DeadEndSolver/DeadEndSolver.ts","../lib/data-structures/HighDensityRouteSpatialIndex.ts","../lib/solvers/UselessViaRemovalSolver/SingleRouteUselessViaRemovalSolver.ts","../lib/solvers/UselessViaRemovalSolver/UselessViaRemovalSolver.ts","../lib/solvers/AutoroutingPipelineSolver.ts"],"sourcesContent":["import type { GraphicsObject } from \"graphics-debug\"\n\nexport const combineVisualizations = (\n  ...visualizations: GraphicsObject[]\n): GraphicsObject => {\n  const combined: GraphicsObject = {\n    points: [],\n    lines: [],\n    circles: [],\n    rects: [],\n  }\n\n  visualizations.forEach((viz, i) => {\n    if (!viz) return\n    if (viz.lines) {\n      combined.lines = [\n        ...(combined.lines || []),\n        ...viz.lines.map((l) => ({ ...l, step: i })),\n      ]\n    }\n    if (viz.points) {\n      combined.points = [\n        ...(combined.points || []),\n        ...viz.points.map((p) => ({ ...p, step: i })),\n      ]\n    }\n    if (viz.circles) {\n      combined.circles = [\n        ...(combined.circles || []),\n        ...viz.circles.map((c) => ({ ...c, step: i })),\n      ]\n    }\n    if (viz.rects) {\n      combined.rects = [\n        ...(combined.rects || []),\n        ...viz.rects.map((r) => ({ ...r, step: i })),\n      ]\n    }\n  })\n\n  return combined\n}\n","import type { GraphicsObject } from \"graphics-debug\"\nimport { CachableSolver, CacheProvider } from \"lib/cache/types\"\n\nexport class BaseSolver {\n  MAX_ITERATIONS = 1000\n  solved = false\n  failed = false\n  iterations = 0\n  progress = 0\n  error: string | null = null\n  activeSubSolver?: BaseSolver | null\n  failedSubSolvers?: BaseSolver[]\n  timeToSolve?: number\n  stats: Record<string, any> = {}\n\n  /**\n   * For cached solvers\n   **/\n  cacheHit?: boolean\n  cacheKey?: string\n  cacheToSolveSpaceTransform?: any\n\n  /** DO NOT OVERRIDE! Override _step() instead */\n  step() {\n    if (this.solved) return\n    if (this.failed) return\n    this.iterations++\n    try {\n      this._step()\n    } catch (e) {\n      this.error = `${this.constructor.name} error: ${e}`\n      console.error(this.error)\n      this.failed = true\n      throw e\n    }\n    if (!this.solved && this.iterations > this.MAX_ITERATIONS) {\n      this.tryFinalAcceptance()\n    }\n    if (!this.solved && this.iterations > this.MAX_ITERATIONS) {\n      this.error = `${this.constructor.name} ran out of iterations`\n      console.error(this.error)\n      this.failed = true\n    }\n    if (\"computeProgress\" in this) {\n      // @ts-ignore\n      this.progress = this.computeProgress() as number\n    }\n  }\n\n  _step() {}\n\n  getConstructorParams() {\n    throw new Error(\"getConstructorParams not implemented\")\n  }\n\n  solve() {\n    const startTime = Date.now()\n    while (!this.solved && !this.failed) {\n      this.step()\n    }\n    const endTime = Date.now()\n    this.timeToSolve = endTime - startTime\n  }\n\n  visualize(): GraphicsObject {\n    return {\n      lines: [],\n      points: [],\n      rects: [],\n      circles: [],\n    }\n  }\n\n  /**\n   * Called when the solver is about to fail, but we want to see if we have an\n   * \"acceptable\" or \"passable\" solution. Mostly used for optimizers that\n   * have an aggressive early stopping criterion.\n   */\n  tryFinalAcceptance() {}\n\n  /**\n   * A lightweight version of the visualize method that can be used to stream\n   * progress\n   */\n  preview(): GraphicsObject {\n    return {\n      lines: [],\n      points: [],\n      rects: [],\n      circles: [],\n    }\n  }\n}\n","function _extends() {\n  return _extends = Object.assign ? Object.assign.bind() : function (n) {\n    for (var e = 1; e < arguments.length; e++) {\n      var t = arguments[e];\n      for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);\n    }\n    return n;\n  }, _extends.apply(null, arguments);\n}\nexport { _extends as default };","function _assertThisInitialized(e) {\n  if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  return e;\n}\nexport { _assertThisInitialized as default };","function _setPrototypeOf(t, e) {\n  return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) {\n    return t.__proto__ = e, t;\n  }, _setPrototypeOf(t, e);\n}\nexport { _setPrototypeOf as default };","import setPrototypeOf from \"./setPrototypeOf.js\";\nfunction _inheritsLoose(t, o) {\n  t.prototype = Object.create(o.prototype), t.prototype.constructor = t, setPrototypeOf(t, o);\n}\nexport { _inheritsLoose as default };","function _getPrototypeOf(t) {\n  return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) {\n    return t.__proto__ || Object.getPrototypeOf(t);\n  }, _getPrototypeOf(t);\n}\nexport { _getPrototypeOf as default };","function _isNativeFunction(t) {\n  try {\n    return -1 !== Function.toString.call(t).indexOf(\"[native code]\");\n  } catch (n) {\n    return \"function\" == typeof t;\n  }\n}\nexport { _isNativeFunction as default };","function _isNativeReflectConstruct() {\n  try {\n    var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));\n  } catch (t) {}\n  return (_isNativeReflectConstruct = function _isNativeReflectConstruct() {\n    return !!t;\n  })();\n}\nexport { _isNativeReflectConstruct as default };","import isNativeReflectConstruct from \"./isNativeReflectConstruct.js\";\nimport setPrototypeOf from \"./setPrototypeOf.js\";\nfunction _construct(t, e, r) {\n  if (isNativeReflectConstruct()) return Reflect.construct.apply(null, arguments);\n  var o = [null];\n  o.push.apply(o, e);\n  var p = new (t.bind.apply(t, o))();\n  return r && setPrototypeOf(p, r.prototype), p;\n}\nexport { _construct as default };","import getPrototypeOf from \"./getPrototypeOf.js\";\nimport setPrototypeOf from \"./setPrototypeOf.js\";\nimport isNativeFunction from \"./isNativeFunction.js\";\nimport construct from \"./construct.js\";\nfunction _wrapNativeSuper(t) {\n  var r = \"function\" == typeof Map ? new Map() : void 0;\n  return _wrapNativeSuper = function _wrapNativeSuper(t) {\n    if (null === t || !isNativeFunction(t)) return t;\n    if (\"function\" != typeof t) throw new TypeError(\"Super expression must either be null or a function\");\n    if (void 0 !== r) {\n      if (r.has(t)) return r.get(t);\n      r.set(t, Wrapper);\n    }\n    function Wrapper() {\n      return construct(t, arguments, getPrototypeOf(this).constructor);\n    }\n    return Wrapper.prototype = Object.create(t.prototype, {\n      constructor: {\n        value: Wrapper,\n        enumerable: !1,\n        writable: !0,\n        configurable: !0\n      }\n    }), setPrototypeOf(Wrapper, t);\n  }, _wrapNativeSuper(t);\n}\nexport { _wrapNativeSuper as default };","import _extends from '@babel/runtime/helpers/esm/extends';\nimport _assertThisInitialized from '@babel/runtime/helpers/esm/assertThisInitialized';\nimport _inheritsLoose from '@babel/runtime/helpers/esm/inheritsLoose';\nimport _wrapNativeSuper from '@babel/runtime/helpers/esm/wrapNativeSuper';\nimport _taggedTemplateLiteralLoose from '@babel/runtime/helpers/esm/taggedTemplateLiteralLoose';\n\nfunction last() {\n  var _ref;\n  return _ref = arguments.length - 1, _ref < 0 || arguments.length <= _ref ? undefined : arguments[_ref];\n}\nfunction negation(a) {\n  return -a;\n}\nfunction addition(a, b) {\n  return a + b;\n}\nfunction subtraction(a, b) {\n  return a - b;\n}\nfunction multiplication(a, b) {\n  return a * b;\n}\nfunction division(a, b) {\n  return a / b;\n}\nfunction max() {\n  return Math.max.apply(Math, arguments);\n}\nfunction min() {\n  return Math.min.apply(Math, arguments);\n}\nfunction comma() {\n  return Array.of.apply(Array, arguments);\n}\nvar defaultSymbols = {\n  symbols: {\n    '*': {\n      infix: {\n        symbol: '*',\n        f: multiplication,\n        notation: 'infix',\n        precedence: 4,\n        rightToLeft: 0,\n        argCount: 2\n      },\n      symbol: '*',\n      regSymbol: '\\\\*'\n    },\n    '/': {\n      infix: {\n        symbol: '/',\n        f: division,\n        notation: 'infix',\n        precedence: 4,\n        rightToLeft: 0,\n        argCount: 2\n      },\n      symbol: '/',\n      regSymbol: '/'\n    },\n    '+': {\n      infix: {\n        symbol: '+',\n        f: addition,\n        notation: 'infix',\n        precedence: 2,\n        rightToLeft: 0,\n        argCount: 2\n      },\n      prefix: {\n        symbol: '+',\n        f: last,\n        notation: 'prefix',\n        precedence: 3,\n        rightToLeft: 0,\n        argCount: 1\n      },\n      symbol: '+',\n      regSymbol: '\\\\+'\n    },\n    '-': {\n      infix: {\n        symbol: '-',\n        f: subtraction,\n        notation: 'infix',\n        precedence: 2,\n        rightToLeft: 0,\n        argCount: 2\n      },\n      prefix: {\n        symbol: '-',\n        f: negation,\n        notation: 'prefix',\n        precedence: 3,\n        rightToLeft: 0,\n        argCount: 1\n      },\n      symbol: '-',\n      regSymbol: '-'\n    },\n    ',': {\n      infix: {\n        symbol: ',',\n        f: comma,\n        notation: 'infix',\n        precedence: 1,\n        rightToLeft: 0,\n        argCount: 2\n      },\n      symbol: ',',\n      regSymbol: ','\n    },\n    '(': {\n      prefix: {\n        symbol: '(',\n        f: last,\n        notation: 'prefix',\n        precedence: 0,\n        rightToLeft: 0,\n        argCount: 1\n      },\n      symbol: '(',\n      regSymbol: '\\\\('\n    },\n    ')': {\n      postfix: {\n        symbol: ')',\n        f: undefined,\n        notation: 'postfix',\n        precedence: 0,\n        rightToLeft: 0,\n        argCount: 1\n      },\n      symbol: ')',\n      regSymbol: '\\\\)'\n    },\n    min: {\n      func: {\n        symbol: 'min',\n        f: min,\n        notation: 'func',\n        precedence: 0,\n        rightToLeft: 0,\n        argCount: 1\n      },\n      symbol: 'min',\n      regSymbol: 'min\\\\b'\n    },\n    max: {\n      func: {\n        symbol: 'max',\n        f: max,\n        notation: 'func',\n        precedence: 0,\n        rightToLeft: 0,\n        argCount: 1\n      },\n      symbol: 'max',\n      regSymbol: 'max\\\\b'\n    }\n  }\n};\nvar defaultSymbolMap = defaultSymbols;\n\n// based on https://github.com/styled-components/styled-components/blob/fcf6f3804c57a14dd7984dfab7bc06ee2edca044/src/utils/error.js\n/**\n * Parse errors.md and turn it into a simple hash of code: message\n * @private\n */\nvar ERRORS = {\n  \"1\": \"Passed invalid arguments to hsl, please pass multiple numbers e.g. hsl(360, 0.75, 0.4) or an object e.g. rgb({ hue: 255, saturation: 0.4, lightness: 0.75 }).\\n\\n\",\n  \"2\": \"Passed invalid arguments to hsla, please pass multiple numbers e.g. hsla(360, 0.75, 0.4, 0.7) or an object e.g. rgb({ hue: 255, saturation: 0.4, lightness: 0.75, alpha: 0.7 }).\\n\\n\",\n  \"3\": \"Passed an incorrect argument to a color function, please pass a string representation of a color.\\n\\n\",\n  \"4\": \"Couldn't generate valid rgb string from %s, it returned %s.\\n\\n\",\n  \"5\": \"Couldn't parse the color string. Please provide the color as a string in hex, rgb, rgba, hsl or hsla notation.\\n\\n\",\n  \"6\": \"Passed invalid arguments to rgb, please pass multiple numbers e.g. rgb(255, 205, 100) or an object e.g. rgb({ red: 255, green: 205, blue: 100 }).\\n\\n\",\n  \"7\": \"Passed invalid arguments to rgba, please pass multiple numbers e.g. rgb(255, 205, 100, 0.75) or an object e.g. rgb({ red: 255, green: 205, blue: 100, alpha: 0.75 }).\\n\\n\",\n  \"8\": \"Passed invalid argument to toColorString, please pass a RgbColor, RgbaColor, HslColor or HslaColor object.\\n\\n\",\n  \"9\": \"Please provide a number of steps to the modularScale helper.\\n\\n\",\n  \"10\": \"Please pass a number or one of the predefined scales to the modularScale helper as the ratio.\\n\\n\",\n  \"11\": \"Invalid value passed as base to modularScale, expected number or em string but got \\\"%s\\\"\\n\\n\",\n  \"12\": \"Expected a string ending in \\\"px\\\" or a number passed as the first argument to %s(), got \\\"%s\\\" instead.\\n\\n\",\n  \"13\": \"Expected a string ending in \\\"px\\\" or a number passed as the second argument to %s(), got \\\"%s\\\" instead.\\n\\n\",\n  \"14\": \"Passed invalid pixel value (\\\"%s\\\") to %s(), please pass a value like \\\"12px\\\" or 12.\\n\\n\",\n  \"15\": \"Passed invalid base value (\\\"%s\\\") to %s(), please pass a value like \\\"12px\\\" or 12.\\n\\n\",\n  \"16\": \"You must provide a template to this method.\\n\\n\",\n  \"17\": \"You passed an unsupported selector state to this method.\\n\\n\",\n  \"18\": \"minScreen and maxScreen must be provided as stringified numbers with the same units.\\n\\n\",\n  \"19\": \"fromSize and toSize must be provided as stringified numbers with the same units.\\n\\n\",\n  \"20\": \"expects either an array of objects or a single object with the properties prop, fromSize, and toSize.\\n\\n\",\n  \"21\": \"expects the objects in the first argument array to have the properties `prop`, `fromSize`, and `toSize`.\\n\\n\",\n  \"22\": \"expects the first argument object to have the properties `prop`, `fromSize`, and `toSize`.\\n\\n\",\n  \"23\": \"fontFace expects a name of a font-family.\\n\\n\",\n  \"24\": \"fontFace expects either the path to the font file(s) or a name of a local copy.\\n\\n\",\n  \"25\": \"fontFace expects localFonts to be an array.\\n\\n\",\n  \"26\": \"fontFace expects fileFormats to be an array.\\n\\n\",\n  \"27\": \"radialGradient requries at least 2 color-stops to properly render.\\n\\n\",\n  \"28\": \"Please supply a filename to retinaImage() as the first argument.\\n\\n\",\n  \"29\": \"Passed invalid argument to triangle, please pass correct pointingDirection e.g. 'right'.\\n\\n\",\n  \"30\": \"Passed an invalid value to `height` or `width`. Please provide a pixel based unit.\\n\\n\",\n  \"31\": \"The animation shorthand only takes 8 arguments. See the specification for more information: http://mdn.io/animation\\n\\n\",\n  \"32\": \"To pass multiple animations please supply them in arrays, e.g. animation(['rotate', '2s'], ['move', '1s'])\\nTo pass a single animation please supply them in simple values, e.g. animation('rotate', '2s')\\n\\n\",\n  \"33\": \"The animation shorthand arrays can only have 8 elements. See the specification for more information: http://mdn.io/animation\\n\\n\",\n  \"34\": \"borderRadius expects a radius value as a string or number as the second argument.\\n\\n\",\n  \"35\": \"borderRadius expects one of \\\"top\\\", \\\"bottom\\\", \\\"left\\\" or \\\"right\\\" as the first argument.\\n\\n\",\n  \"36\": \"Property must be a string value.\\n\\n\",\n  \"37\": \"Syntax Error at %s.\\n\\n\",\n  \"38\": \"Formula contains a function that needs parentheses at %s.\\n\\n\",\n  \"39\": \"Formula is missing closing parenthesis at %s.\\n\\n\",\n  \"40\": \"Formula has too many closing parentheses at %s.\\n\\n\",\n  \"41\": \"All values in a formula must have the same unit or be unitless.\\n\\n\",\n  \"42\": \"Please provide a number of steps to the modularScale helper.\\n\\n\",\n  \"43\": \"Please pass a number or one of the predefined scales to the modularScale helper as the ratio.\\n\\n\",\n  \"44\": \"Invalid value passed as base to modularScale, expected number or em/rem string but got %s.\\n\\n\",\n  \"45\": \"Passed invalid argument to hslToColorString, please pass a HslColor or HslaColor object.\\n\\n\",\n  \"46\": \"Passed invalid argument to rgbToColorString, please pass a RgbColor or RgbaColor object.\\n\\n\",\n  \"47\": \"minScreen and maxScreen must be provided as stringified numbers with the same units.\\n\\n\",\n  \"48\": \"fromSize and toSize must be provided as stringified numbers with the same units.\\n\\n\",\n  \"49\": \"Expects either an array of objects or a single object with the properties prop, fromSize, and toSize.\\n\\n\",\n  \"50\": \"Expects the objects in the first argument array to have the properties prop, fromSize, and toSize.\\n\\n\",\n  \"51\": \"Expects the first argument object to have the properties prop, fromSize, and toSize.\\n\\n\",\n  \"52\": \"fontFace expects either the path to the font file(s) or a name of a local copy.\\n\\n\",\n  \"53\": \"fontFace expects localFonts to be an array.\\n\\n\",\n  \"54\": \"fontFace expects fileFormats to be an array.\\n\\n\",\n  \"55\": \"fontFace expects a name of a font-family.\\n\\n\",\n  \"56\": \"linearGradient requries at least 2 color-stops to properly render.\\n\\n\",\n  \"57\": \"radialGradient requries at least 2 color-stops to properly render.\\n\\n\",\n  \"58\": \"Please supply a filename to retinaImage() as the first argument.\\n\\n\",\n  \"59\": \"Passed invalid argument to triangle, please pass correct pointingDirection e.g. 'right'.\\n\\n\",\n  \"60\": \"Passed an invalid value to `height` or `width`. Please provide a pixel based unit.\\n\\n\",\n  \"61\": \"Property must be a string value.\\n\\n\",\n  \"62\": \"borderRadius expects a radius value as a string or number as the second argument.\\n\\n\",\n  \"63\": \"borderRadius expects one of \\\"top\\\", \\\"bottom\\\", \\\"left\\\" or \\\"right\\\" as the first argument.\\n\\n\",\n  \"64\": \"The animation shorthand only takes 8 arguments. See the specification for more information: http://mdn.io/animation.\\n\\n\",\n  \"65\": \"To pass multiple animations please supply them in arrays, e.g. animation(['rotate', '2s'], ['move', '1s'])\\\\nTo pass a single animation please supply them in simple values, e.g. animation('rotate', '2s').\\n\\n\",\n  \"66\": \"The animation shorthand arrays can only have 8 elements. See the specification for more information: http://mdn.io/animation.\\n\\n\",\n  \"67\": \"You must provide a template to this method.\\n\\n\",\n  \"68\": \"You passed an unsupported selector state to this method.\\n\\n\",\n  \"69\": \"Expected a string ending in \\\"px\\\" or a number passed as the first argument to %s(), got %s instead.\\n\\n\",\n  \"70\": \"Expected a string ending in \\\"px\\\" or a number passed as the second argument to %s(), got %s instead.\\n\\n\",\n  \"71\": \"Passed invalid pixel value %s to %s(), please pass a value like \\\"12px\\\" or 12.\\n\\n\",\n  \"72\": \"Passed invalid base value %s to %s(), please pass a value like \\\"12px\\\" or 12.\\n\\n\",\n  \"73\": \"Please provide a valid CSS variable.\\n\\n\",\n  \"74\": \"CSS variable not found and no default was provided.\\n\\n\",\n  \"75\": \"important requires a valid style object, got a %s instead.\\n\\n\",\n  \"76\": \"fromSize and toSize must be provided as stringified numbers with the same units as minScreen and maxScreen.\\n\\n\",\n  \"77\": \"remToPx expects a value in \\\"rem\\\" but you provided it in \\\"%s\\\".\\n\\n\",\n  \"78\": \"base must be set in \\\"px\\\" or \\\"%\\\" but you set it in \\\"%s\\\".\\n\"\n};\n\n/**\n * super basic version of sprintf\n * @private\n */\nfunction format() {\n  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n    args[_key] = arguments[_key];\n  }\n  var a = args[0];\n  var b = [];\n  var c;\n  for (c = 1; c < args.length; c += 1) {\n    b.push(args[c]);\n  }\n  b.forEach(function (d) {\n    a = a.replace(/%[a-z]/, d);\n  });\n  return a;\n}\n\n/**\n * Create an error file out of errors.md for development and a simple web link to the full errors\n * in production mode.\n * @private\n */\nvar PolishedError = /*#__PURE__*/function (_Error) {\n  _inheritsLoose(PolishedError, _Error);\n  function PolishedError(code) {\n    var _this;\n    if (process.env.NODE_ENV === 'production') {\n      _this = _Error.call(this, \"An error occurred. See https://github.com/styled-components/polished/blob/main/src/internalHelpers/errors.md#\" + code + \" for more information.\") || this;\n    } else {\n      for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n        args[_key2 - 1] = arguments[_key2];\n      }\n      _this = _Error.call(this, format.apply(void 0, [ERRORS[code]].concat(args))) || this;\n    }\n    return _assertThisInitialized(_this);\n  }\n  return PolishedError;\n}( /*#__PURE__*/_wrapNativeSuper(Error));\n\nvar unitRegExp = /((?!\\w)a|na|hc|mc|dg|me[r]?|xe|ni(?![a-zA-Z])|mm|cp|tp|xp|q(?!s)|hv|xamv|nimv|wv|sm|s(?!\\D|$)|ged|darg?|nrut)/g;\n\n// Merges additional math functionality into the defaults.\nfunction mergeSymbolMaps(additionalSymbols) {\n  var symbolMap = {};\n  symbolMap.symbols = additionalSymbols ? _extends({}, defaultSymbolMap.symbols, additionalSymbols.symbols) : _extends({}, defaultSymbolMap.symbols);\n  return symbolMap;\n}\nfunction exec(operators, values) {\n  var _ref;\n  var op = operators.pop();\n  values.push(op.f.apply(op, (_ref = []).concat.apply(_ref, values.splice(-op.argCount))));\n  return op.precedence;\n}\nfunction calculate(expression, additionalSymbols) {\n  var symbolMap = mergeSymbolMaps(additionalSymbols);\n  var match;\n  var operators = [symbolMap.symbols['('].prefix];\n  var values = [];\n  var pattern = new RegExp( // Pattern for numbers\n  \"\\\\d+(?:\\\\.\\\\d+)?|\" +\n  // ...and patterns for individual operators/function names\n  Object.keys(symbolMap.symbols).map(function (key) {\n    return symbolMap.symbols[key];\n  })\n  // longer symbols should be listed first\n  // $FlowFixMe\n  .sort(function (a, b) {\n    return b.symbol.length - a.symbol.length;\n  })\n  // $FlowFixMe\n  .map(function (val) {\n    return val.regSymbol;\n  }).join('|') + \"|(\\\\S)\", 'g');\n  pattern.lastIndex = 0; // Reset regular expression object\n\n  var afterValue = false;\n  do {\n    match = pattern.exec(expression);\n    var _ref2 = match || [')', undefined],\n      token = _ref2[0],\n      bad = _ref2[1];\n    var notNumber = symbolMap.symbols[token];\n    var notNewValue = notNumber && !notNumber.prefix && !notNumber.func;\n    var notAfterValue = !notNumber || !notNumber.postfix && !notNumber.infix;\n\n    // Check for syntax errors:\n    if (bad || (afterValue ? notAfterValue : notNewValue)) {\n      throw new PolishedError(37, match ? match.index : expression.length, expression);\n    }\n    if (afterValue) {\n      // We either have an infix or postfix operator (they should be mutually exclusive)\n      var curr = notNumber.postfix || notNumber.infix;\n      do {\n        var prev = operators[operators.length - 1];\n        if ((curr.precedence - prev.precedence || prev.rightToLeft) > 0) break;\n        // Apply previous operator, since it has precedence over current one\n      } while (exec(operators, values)); // Exit loop after executing an opening parenthesis or function\n      afterValue = curr.notation === 'postfix';\n      if (curr.symbol !== ')') {\n        operators.push(curr);\n        // Postfix always has precedence over any operator that follows after it\n        if (afterValue) exec(operators, values);\n      }\n    } else if (notNumber) {\n      // prefix operator or function\n      operators.push(notNumber.prefix || notNumber.func);\n      if (notNumber.func) {\n        // Require an opening parenthesis\n        match = pattern.exec(expression);\n        if (!match || match[0] !== '(') {\n          throw new PolishedError(38, match ? match.index : expression.length, expression);\n        }\n      }\n    } else {\n      // number\n      values.push(+token);\n      afterValue = true;\n    }\n  } while (match && operators.length);\n  if (operators.length) {\n    throw new PolishedError(39, match ? match.index : expression.length, expression);\n  } else if (match) {\n    throw new PolishedError(40, match ? match.index : expression.length, expression);\n  } else {\n    return values.pop();\n  }\n}\nfunction reverseString(str) {\n  return str.split('').reverse().join('');\n}\n\n/**\n * Helper for doing math with CSS Units. Accepts a formula as a string. All values in the formula must have the same unit (or be unitless). Supports complex formulas utliziing addition, subtraction, multiplication, division, square root, powers, factorial, min, max, as well as parentheses for order of operation.\n *\n *In cases where you need to do calculations with mixed units where one unit is a [relative length unit](https://developer.mozilla.org/en-US/docs/Web/CSS/length#Relative_length_units), you will want to use [CSS Calc](https://developer.mozilla.org/en-US/docs/Web/CSS/calc).\n *\n * *warning* While we've done everything possible to ensure math safely evalutes formulas expressed as strings, you should always use extreme caution when passing `math` user provided values.\n * @example\n * // Styles as object usage\n * const styles = {\n *   fontSize: math('12rem + 8rem'),\n *   fontSize: math('(12px + 2px) * 3'),\n *   fontSize: math('3px^2 + sqrt(4)'),\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   fontSize: ${math('12rem + 8rem')};\n *   fontSize: ${math('(12px + 2px) * 3')};\n *   fontSize: ${math('3px^2 + sqrt(4)')};\n * `\n *\n * // CSS as JS Output\n *\n * div: {\n *   fontSize: '20rem',\n *   fontSize: '42px',\n *   fontSize: '11px',\n * }\n */\nfunction math(formula, additionalSymbols) {\n  var reversedFormula = reverseString(formula);\n  var formulaMatch = reversedFormula.match(unitRegExp);\n\n  // Check that all units are the same\n  if (formulaMatch && !formulaMatch.every(function (unit) {\n    return unit === formulaMatch[0];\n  })) {\n    throw new PolishedError(41);\n  }\n  var cleanFormula = reverseString(reversedFormula.replace(unitRegExp, ''));\n  return \"\" + calculate(cleanFormula, additionalSymbols) + (formulaMatch ? reverseString(formulaMatch[0]) : '');\n}\n\nvar cssVariableRegex = /--[\\S]*/g;\n\n/**\n * Fetches the value of a passed CSS Variable in the :root scope, or otherwise returns a defaultValue if provided.\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   'background': cssVar('--background-color'),\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   background: ${cssVar('--background-color')};\n * `\n *\n * // CSS in JS Output\n *\n * element {\n *   'background': 'red'\n * }\n */\nfunction cssVar(cssVariable, defaultValue) {\n  if (!cssVariable || !cssVariable.match(cssVariableRegex)) {\n    throw new PolishedError(73);\n  }\n  var variableValue;\n\n  /* eslint-disable */\n  /* istanbul ignore next */\n  if (typeof document !== 'undefined' && document.documentElement !== null) {\n    variableValue = getComputedStyle(document.documentElement).getPropertyValue(cssVariable);\n  }\n  /* eslint-enable */\n\n  if (variableValue) {\n    return variableValue.trim();\n  } else if (defaultValue) {\n    return defaultValue;\n  }\n  throw new PolishedError(74);\n}\n\n// @private\nfunction capitalizeString(string) {\n  return string.charAt(0).toUpperCase() + string.slice(1);\n}\n\nvar positionMap$1 = ['Top', 'Right', 'Bottom', 'Left'];\nfunction generateProperty(property, position) {\n  if (!property) return position.toLowerCase();\n  var splitProperty = property.split('-');\n  if (splitProperty.length > 1) {\n    splitProperty.splice(1, 0, position);\n    return splitProperty.reduce(function (acc, val) {\n      return \"\" + acc + capitalizeString(val);\n    });\n  }\n  var joinedProperty = property.replace(/([a-z])([A-Z])/g, \"$1\" + position + \"$2\");\n  return property === joinedProperty ? \"\" + property + position : joinedProperty;\n}\nfunction generateStyles(property, valuesWithDefaults) {\n  var styles = {};\n  for (var i = 0; i < valuesWithDefaults.length; i += 1) {\n    if (valuesWithDefaults[i] || valuesWithDefaults[i] === 0) {\n      styles[generateProperty(property, positionMap$1[i])] = valuesWithDefaults[i];\n    }\n  }\n  return styles;\n}\n\n/**\n * Enables shorthand for direction-based properties. It accepts a property (hyphenated or camelCased) and up to four values that map to top, right, bottom, and left, respectively. You can optionally pass an empty string to get only the directional values as properties. You can also optionally pass a null argument for a directional value to ignore it.\n * @example\n * // Styles as object usage\n * const styles = {\n *   ...directionalProperty('padding', '12px', '24px', '36px', '48px')\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   ${directionalProperty('padding', '12px', '24px', '36px', '48px')}\n * `\n *\n * // CSS as JS Output\n *\n * div {\n *   'paddingTop': '12px',\n *   'paddingRight': '24px',\n *   'paddingBottom': '36px',\n *   'paddingLeft': '48px'\n * }\n */\nfunction directionalProperty(property) {\n  for (var _len = arguments.length, values = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    values[_key - 1] = arguments[_key];\n  }\n  //  prettier-ignore\n  var firstValue = values[0],\n    _values$ = values[1],\n    secondValue = _values$ === void 0 ? firstValue : _values$,\n    _values$2 = values[2],\n    thirdValue = _values$2 === void 0 ? firstValue : _values$2,\n    _values$3 = values[3],\n    fourthValue = _values$3 === void 0 ? secondValue : _values$3;\n  var valuesWithDefaults = [firstValue, secondValue, thirdValue, fourthValue];\n  return generateStyles(property, valuesWithDefaults);\n}\n\n/**\n * Check if a string ends with something\n * @private\n */\nfunction endsWith(string, suffix) {\n  return string.substr(-suffix.length) === suffix;\n}\n\nvar cssRegex$1 = /^([+-]?(?:\\d+|\\d*\\.\\d+))([a-z]*|%)$/;\n\n/**\n * Returns a given CSS value minus its unit of measure.\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   '--dimension': stripUnit('100px')\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   --dimension: ${stripUnit('100px')};\n * `\n *\n * // CSS in JS Output\n *\n * element {\n *   '--dimension': 100\n * }\n */\nfunction stripUnit(value) {\n  if (typeof value !== 'string') return value;\n  var matchedValue = value.match(cssRegex$1);\n  return matchedValue ? parseFloat(value) : value;\n}\n\n/**\n * Factory function that creates pixel-to-x converters\n * @private\n */\nvar pxtoFactory = function pxtoFactory(to) {\n  return function (pxval, base) {\n    if (base === void 0) {\n      base = '16px';\n    }\n    var newPxval = pxval;\n    var newBase = base;\n    if (typeof pxval === 'string') {\n      if (!endsWith(pxval, 'px')) {\n        throw new PolishedError(69, to, pxval);\n      }\n      newPxval = stripUnit(pxval);\n    }\n    if (typeof base === 'string') {\n      if (!endsWith(base, 'px')) {\n        throw new PolishedError(70, to, base);\n      }\n      newBase = stripUnit(base);\n    }\n    if (typeof newPxval === 'string') {\n      throw new PolishedError(71, pxval, to);\n    }\n    if (typeof newBase === 'string') {\n      throw new PolishedError(72, base, to);\n    }\n    return \"\" + newPxval / newBase + to;\n  };\n};\nvar pixelsto = pxtoFactory;\n\n/**\n * Convert pixel value to ems. The default base value is 16px, but can be changed by passing a\n * second argument to the function.\n * @function\n * @param {string|number} pxval\n * @param {string|number} [base='16px']\n * @example\n * // Styles as object usage\n * const styles = {\n *   'height': em('16px')\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   height: ${em('16px')}\n * `\n *\n * // CSS in JS Output\n *\n * element {\n *   'height': '1em'\n * }\n */\nvar em = pixelsto('em');\nvar em$1 = em;\n\nvar cssRegex = /^([+-]?(?:\\d+|\\d*\\.\\d+))([a-z]*|%)$/;\n\n/**\n * Returns a given CSS value and its unit as elements of an array.\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   '--dimension': getValueAndUnit('100px')[0],\n *   '--unit': getValueAndUnit('100px')[1],\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   --dimension: ${getValueAndUnit('100px')[0]};\n *   --unit: ${getValueAndUnit('100px')[1]};\n * `\n *\n * // CSS in JS Output\n *\n * element {\n *   '--dimension': 100,\n *   '--unit': 'px',\n * }\n */\nfunction getValueAndUnit(value) {\n  if (typeof value !== 'string') return [value, ''];\n  var matchedValue = value.match(cssRegex);\n  if (matchedValue) return [parseFloat(value), matchedValue[2]];\n  return [value, undefined];\n}\n\n/**\n * Helper for targeting rules in a style block generated by polished modules that need !important-level specificity. Can optionally specify a rule (or rules) to target specific rules.\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   ...important(cover())\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   ${important(cover())}\n * `\n *\n * // CSS as JS Output\n *\n * div: {\n *   'position': 'absolute !important',\n *   'top': '0 !important',\n *   'right: '0 !important',\n *   'bottom': '0 !important',\n *   'left: '0 !important'\n * }\n */\nfunction important(styleBlock, rules) {\n  if (typeof styleBlock !== 'object' || styleBlock === null) {\n    throw new PolishedError(75, typeof styleBlock);\n  }\n  var newStyleBlock = {};\n  Object.keys(styleBlock).forEach(function (key) {\n    if (typeof styleBlock[key] === 'object' && styleBlock[key] !== null) {\n      newStyleBlock[key] = important(styleBlock[key], rules);\n    } else if (!rules || rules && (rules === key || rules.indexOf(key) >= 0)) {\n      newStyleBlock[key] = styleBlock[key] + \" !important\";\n    } else {\n      newStyleBlock[key] = styleBlock[key];\n    }\n  });\n  return newStyleBlock;\n}\n\nvar ratioNames = {\n  minorSecond: 1.067,\n  majorSecond: 1.125,\n  minorThird: 1.2,\n  majorThird: 1.25,\n  perfectFourth: 1.333,\n  augFourth: 1.414,\n  perfectFifth: 1.5,\n  minorSixth: 1.6,\n  goldenSection: 1.618,\n  majorSixth: 1.667,\n  minorSeventh: 1.778,\n  majorSeventh: 1.875,\n  octave: 2,\n  majorTenth: 2.5,\n  majorEleventh: 2.667,\n  majorTwelfth: 3,\n  doubleOctave: 4\n};\nfunction getRatio(ratioName) {\n  return ratioNames[ratioName];\n}\n\n/**\n * Establish consistent measurements and spacial relationships throughout your projects by incrementing an em or rem value up or down a defined scale. We provide a list of commonly used scales as pre-defined variables.\n * @example\n * // Styles as object usage\n * const styles = {\n *    // Increment two steps up the default scale\n *   'fontSize': modularScale(2)\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *    // Increment two steps up the default scale\n *   fontSize: ${modularScale(2)}\n * `\n *\n * // CSS in JS Output\n *\n * element {\n *   'fontSize': '1.77689em'\n * }\n */\nfunction modularScale(steps, base, ratio) {\n  if (base === void 0) {\n    base = '1em';\n  }\n  if (ratio === void 0) {\n    ratio = 1.333;\n  }\n  if (typeof steps !== 'number') {\n    throw new PolishedError(42);\n  }\n  if (typeof ratio === 'string' && !ratioNames[ratio]) {\n    throw new PolishedError(43);\n  }\n  var _ref = typeof base === 'string' ? getValueAndUnit(base) : [base, ''],\n    realBase = _ref[0],\n    unit = _ref[1];\n  var realRatio = typeof ratio === 'string' ? getRatio(ratio) : ratio;\n  if (typeof realBase === 'string') {\n    throw new PolishedError(44, base);\n  }\n  return \"\" + realBase * Math.pow(realRatio, steps) + (unit || '');\n}\n\n/**\n * Convert pixel value to rems. The default base value is 16px, but can be changed by passing a\n * second argument to the function.\n * @function\n * @param {string|number} pxval\n * @param {string|number} [base='16px']\n * @example\n * // Styles as object usage\n * const styles = {\n *   'height': rem('16px')\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   height: ${rem('16px')}\n * `\n *\n * // CSS in JS Output\n *\n * element {\n *   'height': '1rem'\n * }\n */\nvar rem = pixelsto('rem');\nvar rem$1 = rem;\n\nvar defaultFontSize = 16;\nfunction convertBase(base) {\n  var deconstructedValue = getValueAndUnit(base);\n  if (deconstructedValue[1] === 'px') {\n    return parseFloat(base);\n  }\n  if (deconstructedValue[1] === '%') {\n    return parseFloat(base) / 100 * defaultFontSize;\n  }\n  throw new PolishedError(78, deconstructedValue[1]);\n}\nfunction getBaseFromDoc() {\n  /* eslint-disable */\n  /* istanbul ignore next */\n  if (typeof document !== 'undefined' && document.documentElement !== null) {\n    var rootFontSize = getComputedStyle(document.documentElement).fontSize;\n    return rootFontSize ? convertBase(rootFontSize) : defaultFontSize;\n  }\n  /* eslint-enable */\n  /* istanbul ignore next */\n  return defaultFontSize;\n}\n\n/**\n * Convert rem values to px. By default, the base value is pulled from the font-size property on the root element (if it is set in % or px). It defaults to 16px if not found on the root. You can also override the base value by providing your own base in % or px.\n * @example\n * // Styles as object usage\n * const styles = {\n *   'height': remToPx('1.6rem')\n *   'height': remToPx('1.6rem', '10px')\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   height: ${remToPx('1.6rem')}\n *   height: ${remToPx('1.6rem', '10px')}\n * `\n *\n * // CSS in JS Output\n *\n * element {\n *   'height': '25.6px',\n *   'height': '16px',\n * }\n */\nfunction remToPx(value, base) {\n  var deconstructedValue = getValueAndUnit(value);\n  if (deconstructedValue[1] !== 'rem' && deconstructedValue[1] !== '') {\n    throw new PolishedError(77, deconstructedValue[1]);\n  }\n  var newBase = base ? convertBase(base) : getBaseFromDoc();\n  return deconstructedValue[0] * newBase + \"px\";\n}\n\nvar functionsMap$3 = {\n  back: 'cubic-bezier(0.600, -0.280, 0.735, 0.045)',\n  circ: 'cubic-bezier(0.600,  0.040, 0.980, 0.335)',\n  cubic: 'cubic-bezier(0.550,  0.055, 0.675, 0.190)',\n  expo: 'cubic-bezier(0.950,  0.050, 0.795, 0.035)',\n  quad: 'cubic-bezier(0.550,  0.085, 0.680, 0.530)',\n  quart: 'cubic-bezier(0.895,  0.030, 0.685, 0.220)',\n  quint: 'cubic-bezier(0.755,  0.050, 0.855, 0.060)',\n  sine: 'cubic-bezier(0.470,  0.000, 0.745, 0.715)'\n};\n\n/**\n * String to represent common easing functions as demonstrated here: (github.com/jaukia/easie).\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   'transitionTimingFunction': easeIn('quad')\n * }\n *\n * // styled-components usage\n *  const div = styled.div`\n *   transitionTimingFunction: ${easeIn('quad')};\n * `\n *\n * // CSS as JS Output\n *\n * 'div': {\n *   'transitionTimingFunction': 'cubic-bezier(0.550,  0.085, 0.680, 0.530)',\n * }\n */\nfunction easeIn(functionName) {\n  return functionsMap$3[functionName.toLowerCase().trim()];\n}\n\nvar functionsMap$2 = {\n  back: 'cubic-bezier(0.680, -0.550, 0.265, 1.550)',\n  circ: 'cubic-bezier(0.785,  0.135, 0.150, 0.860)',\n  cubic: 'cubic-bezier(0.645,  0.045, 0.355, 1.000)',\n  expo: 'cubic-bezier(1.000,  0.000, 0.000, 1.000)',\n  quad: 'cubic-bezier(0.455,  0.030, 0.515, 0.955)',\n  quart: 'cubic-bezier(0.770,  0.000, 0.175, 1.000)',\n  quint: 'cubic-bezier(0.860,  0.000, 0.070, 1.000)',\n  sine: 'cubic-bezier(0.445,  0.050, 0.550, 0.950)'\n};\n\n/**\n * String to represent common easing functions as demonstrated here: (github.com/jaukia/easie).\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   'transitionTimingFunction': easeInOut('quad')\n * }\n *\n * // styled-components usage\n *  const div = styled.div`\n *   transitionTimingFunction: ${easeInOut('quad')};\n * `\n *\n * // CSS as JS Output\n *\n * 'div': {\n *   'transitionTimingFunction': 'cubic-bezier(0.455,  0.030, 0.515, 0.955)',\n * }\n */\nfunction easeInOut(functionName) {\n  return functionsMap$2[functionName.toLowerCase().trim()];\n}\n\nvar functionsMap$1 = {\n  back: 'cubic-bezier(0.175,  0.885, 0.320, 1.275)',\n  cubic: 'cubic-bezier(0.215,  0.610, 0.355, 1.000)',\n  circ: 'cubic-bezier(0.075,  0.820, 0.165, 1.000)',\n  expo: 'cubic-bezier(0.190,  1.000, 0.220, 1.000)',\n  quad: 'cubic-bezier(0.250,  0.460, 0.450, 0.940)',\n  quart: 'cubic-bezier(0.165,  0.840, 0.440, 1.000)',\n  quint: 'cubic-bezier(0.230,  1.000, 0.320, 1.000)',\n  sine: 'cubic-bezier(0.390,  0.575, 0.565, 1.000)'\n};\n\n/**\n * String to represent common easing functions as demonstrated here: (github.com/jaukia/easie).\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   'transitionTimingFunction': easeOut('quad')\n * }\n *\n * // styled-components usage\n *  const div = styled.div`\n *   transitionTimingFunction: ${easeOut('quad')};\n * `\n *\n * // CSS as JS Output\n *\n * 'div': {\n *   'transitionTimingFunction': 'cubic-bezier(0.250,  0.460, 0.450, 0.940)',\n * }\n */\nfunction easeOut(functionName) {\n  return functionsMap$1[functionName.toLowerCase().trim()];\n}\n\n/**\n * Returns a CSS calc formula for linear interpolation of a property between two values. Accepts optional minScreen (defaults to '320px') and maxScreen (defaults to '1200px').\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   fontSize: between('20px', '100px', '400px', '1000px'),\n *   fontSize: between('20px', '100px')\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   fontSize: ${between('20px', '100px', '400px', '1000px')};\n *   fontSize: ${between('20px', '100px')}\n * `\n *\n * // CSS as JS Output\n *\n * h1: {\n *   'fontSize': 'calc(-33.33333333333334px + 13.333333333333334vw)',\n *   'fontSize': 'calc(-9.090909090909093px + 9.090909090909092vw)'\n * }\n */\nfunction between(fromSize, toSize, minScreen, maxScreen) {\n  if (minScreen === void 0) {\n    minScreen = '320px';\n  }\n  if (maxScreen === void 0) {\n    maxScreen = '1200px';\n  }\n  var _getValueAndUnit = getValueAndUnit(fromSize),\n    unitlessFromSize = _getValueAndUnit[0],\n    fromSizeUnit = _getValueAndUnit[1];\n  var _getValueAndUnit2 = getValueAndUnit(toSize),\n    unitlessToSize = _getValueAndUnit2[0],\n    toSizeUnit = _getValueAndUnit2[1];\n  var _getValueAndUnit3 = getValueAndUnit(minScreen),\n    unitlessMinScreen = _getValueAndUnit3[0],\n    minScreenUnit = _getValueAndUnit3[1];\n  var _getValueAndUnit4 = getValueAndUnit(maxScreen),\n    unitlessMaxScreen = _getValueAndUnit4[0],\n    maxScreenUnit = _getValueAndUnit4[1];\n  if (typeof unitlessMinScreen !== 'number' || typeof unitlessMaxScreen !== 'number' || !minScreenUnit || !maxScreenUnit || minScreenUnit !== maxScreenUnit) {\n    throw new PolishedError(47);\n  }\n  if (typeof unitlessFromSize !== 'number' || typeof unitlessToSize !== 'number' || fromSizeUnit !== toSizeUnit) {\n    throw new PolishedError(48);\n  }\n  if (fromSizeUnit !== minScreenUnit || toSizeUnit !== maxScreenUnit) {\n    throw new PolishedError(76);\n  }\n  var slope = (unitlessFromSize - unitlessToSize) / (unitlessMinScreen - unitlessMaxScreen);\n  var base = unitlessToSize - slope * unitlessMaxScreen;\n  return \"calc(\" + base.toFixed(2) + (fromSizeUnit || '') + \" + \" + (100 * slope).toFixed(2) + \"vw)\";\n}\n\n/**\n * CSS to contain a float (credit to CSSMojo).\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *    ...clearFix(),\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   ${clearFix()}\n * `\n *\n * // CSS as JS Output\n *\n * '&::after': {\n *   'clear': 'both',\n *   'content': '\"\"',\n *   'display': 'table'\n * }\n */\nfunction clearFix(parent) {\n  var _ref;\n  if (parent === void 0) {\n    parent = '&';\n  }\n  var pseudoSelector = parent + \"::after\";\n  return _ref = {}, _ref[pseudoSelector] = {\n    clear: 'both',\n    content: '\"\"',\n    display: 'table'\n  }, _ref;\n}\n\n/**\n * CSS to fully cover an area. Can optionally be passed an offset to act as a \"padding\".\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   ...cover()\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   ${cover()}\n * `\n *\n * // CSS as JS Output\n *\n * div: {\n *   'position': 'absolute',\n *   'top': '0',\n *   'right: '0',\n *   'bottom': '0',\n *   'left: '0'\n * }\n */\nfunction cover(offset) {\n  if (offset === void 0) {\n    offset = 0;\n  }\n  return {\n    position: 'absolute',\n    top: offset,\n    right: offset,\n    bottom: offset,\n    left: offset\n  };\n}\n\n/**\n * CSS to represent truncated text with an ellipsis. You can optionally pass a max-width and number of lines before truncating.\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   ...ellipsis('250px')\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   ${ellipsis('250px')}\n * `\n *\n * // CSS as JS Output\n *\n * div: {\n *   'display': 'inline-block',\n *   'maxWidth': '250px',\n *   'overflow': 'hidden',\n *   'textOverflow': 'ellipsis',\n *   'whiteSpace': 'nowrap',\n *   'wordWrap': 'normal'\n * }\n */\nfunction ellipsis(width, lines) {\n  if (lines === void 0) {\n    lines = 1;\n  }\n  var styles = {\n    display: 'inline-block',\n    maxWidth: width || '100%',\n    overflow: 'hidden',\n    textOverflow: 'ellipsis',\n    whiteSpace: 'nowrap',\n    wordWrap: 'normal'\n  };\n  return lines > 1 ? _extends({}, styles, {\n    WebkitBoxOrient: 'vertical',\n    WebkitLineClamp: lines,\n    display: '-webkit-box',\n    whiteSpace: 'normal'\n  }) : styles;\n}\n\nfunction _createForOfIteratorHelperLoose(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (it) return (it = it.call(o)).next.bind(it); if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\n/**\n * Returns a set of media queries that resizes a property (or set of properties) between a provided fromSize and toSize. Accepts optional minScreen (defaults to '320px') and maxScreen (defaults to '1200px') to constrain the interpolation.\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   ...fluidRange(\n *    {\n *        prop: 'padding',\n *        fromSize: '20px',\n *        toSize: '100px',\n *      },\n *      '400px',\n *      '1000px',\n *    )\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   ${fluidRange(\n *      {\n *        prop: 'padding',\n *        fromSize: '20px',\n *        toSize: '100px',\n *      },\n *      '400px',\n *      '1000px',\n *    )}\n * `\n *\n * // CSS as JS Output\n *\n * div: {\n *   \"@media (min-width: 1000px)\": Object {\n *     \"padding\": \"100px\",\n *   },\n *   \"@media (min-width: 400px)\": Object {\n *     \"padding\": \"calc(-33.33333333333334px + 13.333333333333334vw)\",\n *   },\n *   \"padding\": \"20px\",\n * }\n */\nfunction fluidRange(cssProp, minScreen, maxScreen) {\n  if (minScreen === void 0) {\n    minScreen = '320px';\n  }\n  if (maxScreen === void 0) {\n    maxScreen = '1200px';\n  }\n  if (!Array.isArray(cssProp) && typeof cssProp !== 'object' || cssProp === null) {\n    throw new PolishedError(49);\n  }\n  if (Array.isArray(cssProp)) {\n    var mediaQueries = {};\n    var fallbacks = {};\n    for (var _iterator = _createForOfIteratorHelperLoose(cssProp), _step; !(_step = _iterator()).done;) {\n      var _extends2, _extends3;\n      var obj = _step.value;\n      if (!obj.prop || !obj.fromSize || !obj.toSize) {\n        throw new PolishedError(50);\n      }\n      fallbacks[obj.prop] = obj.fromSize;\n      mediaQueries[\"@media (min-width: \" + minScreen + \")\"] = _extends({}, mediaQueries[\"@media (min-width: \" + minScreen + \")\"], (_extends2 = {}, _extends2[obj.prop] = between(obj.fromSize, obj.toSize, minScreen, maxScreen), _extends2));\n      mediaQueries[\"@media (min-width: \" + maxScreen + \")\"] = _extends({}, mediaQueries[\"@media (min-width: \" + maxScreen + \")\"], (_extends3 = {}, _extends3[obj.prop] = obj.toSize, _extends3));\n    }\n    return _extends({}, fallbacks, mediaQueries);\n  } else {\n    var _ref, _ref2, _ref3;\n    if (!cssProp.prop || !cssProp.fromSize || !cssProp.toSize) {\n      throw new PolishedError(51);\n    }\n    return _ref3 = {}, _ref3[cssProp.prop] = cssProp.fromSize, _ref3[\"@media (min-width: \" + minScreen + \")\"] = (_ref = {}, _ref[cssProp.prop] = between(cssProp.fromSize, cssProp.toSize, minScreen, maxScreen), _ref), _ref3[\"@media (min-width: \" + maxScreen + \")\"] = (_ref2 = {}, _ref2[cssProp.prop] = cssProp.toSize, _ref2), _ref3;\n  }\n}\n\nvar dataURIRegex = /^\\s*data:([a-z]+\\/[a-z-]+(;[a-z-]+=[a-z-]+)?)?(;charset=[a-z0-9-]+)?(;base64)?,[a-z0-9!$&',()*+,;=\\-._~:@/?%\\s]*\\s*$/i;\nvar formatHintMap = {\n  woff: 'woff',\n  woff2: 'woff2',\n  ttf: 'truetype',\n  otf: 'opentype',\n  eot: 'embedded-opentype',\n  svg: 'svg',\n  svgz: 'svg'\n};\nfunction generateFormatHint(format, formatHint) {\n  if (!formatHint) return '';\n  return \" format(\\\"\" + formatHintMap[format] + \"\\\")\";\n}\nfunction isDataURI(fontFilePath) {\n  return !!fontFilePath.replace(/\\s+/g, ' ').match(dataURIRegex);\n}\nfunction generateFileReferences(fontFilePath, fileFormats, formatHint) {\n  if (isDataURI(fontFilePath)) {\n    return \"url(\\\"\" + fontFilePath + \"\\\")\" + generateFormatHint(fileFormats[0], formatHint);\n  }\n  var fileFontReferences = fileFormats.map(function (format) {\n    return \"url(\\\"\" + fontFilePath + \".\" + format + \"\\\")\" + generateFormatHint(format, formatHint);\n  });\n  return fileFontReferences.join(', ');\n}\nfunction generateLocalReferences(localFonts) {\n  var localFontReferences = localFonts.map(function (font) {\n    return \"local(\\\"\" + font + \"\\\")\";\n  });\n  return localFontReferences.join(', ');\n}\nfunction generateSources(fontFilePath, localFonts, fileFormats, formatHint) {\n  var fontReferences = [];\n  if (localFonts) fontReferences.push(generateLocalReferences(localFonts));\n  if (fontFilePath) {\n    fontReferences.push(generateFileReferences(fontFilePath, fileFormats, formatHint));\n  }\n  return fontReferences.join(', ');\n}\n\n/**\n * CSS for a @font-face declaration. Defaults to check for local copies of the font on the user's machine. You can disable this by passing `null` to localFonts.\n *\n * @example\n * // Styles as object basic usage\n * const styles = {\n *    ...fontFace({\n *      'fontFamily': 'Sans-Pro',\n *      'fontFilePath': 'path/to/file'\n *    })\n * }\n *\n * // styled-components basic usage\n * const GlobalStyle = createGlobalStyle`${\n *   fontFace({\n *     'fontFamily': 'Sans-Pro',\n *     'fontFilePath': 'path/to/file'\n *   }\n * )}`\n *\n * // CSS as JS Output\n *\n * '@font-face': {\n *   'fontFamily': 'Sans-Pro',\n *   'src': 'url(\"path/to/file.eot\"), url(\"path/to/file.woff2\"), url(\"path/to/file.woff\"), url(\"path/to/file.ttf\"), url(\"path/to/file.svg\")',\n * }\n */\n\nfunction fontFace(_ref) {\n  var fontFamily = _ref.fontFamily,\n    fontFilePath = _ref.fontFilePath,\n    fontStretch = _ref.fontStretch,\n    fontStyle = _ref.fontStyle,\n    fontVariant = _ref.fontVariant,\n    fontWeight = _ref.fontWeight,\n    _ref$fileFormats = _ref.fileFormats,\n    fileFormats = _ref$fileFormats === void 0 ? ['eot', 'woff2', 'woff', 'ttf', 'svg'] : _ref$fileFormats,\n    _ref$formatHint = _ref.formatHint,\n    formatHint = _ref$formatHint === void 0 ? false : _ref$formatHint,\n    _ref$localFonts = _ref.localFonts,\n    localFonts = _ref$localFonts === void 0 ? [fontFamily] : _ref$localFonts,\n    unicodeRange = _ref.unicodeRange,\n    fontDisplay = _ref.fontDisplay,\n    fontVariationSettings = _ref.fontVariationSettings,\n    fontFeatureSettings = _ref.fontFeatureSettings;\n  // Error Handling\n  if (!fontFamily) throw new PolishedError(55);\n  if (!fontFilePath && !localFonts) {\n    throw new PolishedError(52);\n  }\n  if (localFonts && !Array.isArray(localFonts)) {\n    throw new PolishedError(53);\n  }\n  if (!Array.isArray(fileFormats)) {\n    throw new PolishedError(54);\n  }\n  var fontFaceDeclaration = {\n    '@font-face': {\n      fontFamily: fontFamily,\n      src: generateSources(fontFilePath, localFonts, fileFormats, formatHint),\n      unicodeRange: unicodeRange,\n      fontStretch: fontStretch,\n      fontStyle: fontStyle,\n      fontVariant: fontVariant,\n      fontWeight: fontWeight,\n      fontDisplay: fontDisplay,\n      fontVariationSettings: fontVariationSettings,\n      fontFeatureSettings: fontFeatureSettings\n    }\n  };\n\n  // Removes undefined fields for cleaner css object.\n  return JSON.parse(JSON.stringify(fontFaceDeclaration));\n}\n\n/**\n * CSS to hide text to show a background image in a SEO-friendly way.\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   'backgroundImage': 'url(logo.png)',\n *   ...hideText(),\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   backgroundImage: url(logo.png);\n *   ${hideText()};\n * `\n *\n * // CSS as JS Output\n *\n * 'div': {\n *   'backgroundImage': 'url(logo.png)',\n *   'textIndent': '101%',\n *   'overflow': 'hidden',\n *   'whiteSpace': 'nowrap',\n * }\n */\nfunction hideText() {\n  return {\n    textIndent: '101%',\n    overflow: 'hidden',\n    whiteSpace: 'nowrap'\n  };\n}\n\n/**\n * CSS to hide content visually but remain accessible to screen readers.\n * from [HTML5 Boilerplate](https://github.com/h5bp/html5-boilerplate/blob/9a176f57af1cfe8ec70300da4621fb9b07e5fa31/src/css/main.css#L121)\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   ...hideVisually(),\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   ${hideVisually()};\n * `\n *\n * // CSS as JS Output\n *\n * 'div': {\n *   'border': '0',\n *   'clip': 'rect(0 0 0 0)',\n *   'height': '1px',\n *   'margin': '-1px',\n *   'overflow': 'hidden',\n *   'padding': '0',\n *   'position': 'absolute',\n *   'whiteSpace': 'nowrap',\n *   'width': '1px',\n * }\n */\nfunction hideVisually() {\n  return {\n    border: '0',\n    clip: 'rect(0 0 0 0)',\n    height: '1px',\n    margin: '-1px',\n    overflow: 'hidden',\n    padding: '0',\n    position: 'absolute',\n    whiteSpace: 'nowrap',\n    width: '1px'\n  };\n}\n\n/**\n * Generates a media query to target HiDPI devices.\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *  [hiDPI(1.5)]: {\n *    width: 200px;\n *  }\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   ${hiDPI(1.5)} {\n *     width: 200px;\n *   }\n * `\n *\n * // CSS as JS Output\n *\n * '@media only screen and (-webkit-min-device-pixel-ratio: 1.5),\n *  only screen and (min--moz-device-pixel-ratio: 1.5),\n *  only screen and (-o-min-device-pixel-ratio: 1.5/1),\n *  only screen and (min-resolution: 144dpi),\n *  only screen and (min-resolution: 1.5dppx)': {\n *   'width': '200px',\n * }\n */\nfunction hiDPI(ratio) {\n  if (ratio === void 0) {\n    ratio = 1.3;\n  }\n  return \"\\n    @media only screen and (-webkit-min-device-pixel-ratio: \" + ratio + \"),\\n    only screen and (min--moz-device-pixel-ratio: \" + ratio + \"),\\n    only screen and (-o-min-device-pixel-ratio: \" + ratio + \"/1),\\n    only screen and (min-resolution: \" + Math.round(ratio * 96) + \"dpi),\\n    only screen and (min-resolution: \" + ratio + \"dppx)\\n  \";\n}\n\nfunction constructGradientValue(literals) {\n  var template = '';\n  for (var _len = arguments.length, substitutions = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    substitutions[_key - 1] = arguments[_key];\n  }\n  for (var i = 0; i < literals.length; i += 1) {\n    template += literals[i];\n    if (i === substitutions.length - 1 && substitutions[i]) {\n      var definedValues = substitutions.filter(function (substitute) {\n        return !!substitute;\n      });\n      // Adds leading coma if properties preceed color-stops\n      if (definedValues.length > 1) {\n        template = template.slice(0, -1);\n        template += \", \" + substitutions[i];\n        // No trailing space if color-stops is the only param provided\n      } else if (definedValues.length === 1) {\n        template += \"\" + substitutions[i];\n      }\n    } else if (substitutions[i]) {\n      template += substitutions[i] + \" \";\n    }\n  }\n  return template.trim();\n}\n\nvar _templateObject$1;\n/**\n * CSS for declaring a linear gradient, including a fallback background-color. The fallback is either the first color-stop or an explicitly passed fallback color.\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   ...linearGradient({\n        colorStops: ['#00FFFF 0%', 'rgba(0, 0, 255, 0) 50%', '#0000FF 95%'],\n        toDirection: 'to top right',\n        fallback: '#FFF',\n      })\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   ${linearGradient({\n        colorStops: ['#00FFFF 0%', 'rgba(0, 0, 255, 0) 50%', '#0000FF 95%'],\n        toDirection: 'to top right',\n        fallback: '#FFF',\n      })}\n *`\n *\n * // CSS as JS Output\n *\n * div: {\n *   'backgroundColor': '#FFF',\n *   'backgroundImage': 'linear-gradient(to top right, #00FFFF 0%, rgba(0, 0, 255, 0) 50%, #0000FF 95%)',\n * }\n */\nfunction linearGradient(_ref) {\n  var colorStops = _ref.colorStops,\n    fallback = _ref.fallback,\n    _ref$toDirection = _ref.toDirection,\n    toDirection = _ref$toDirection === void 0 ? '' : _ref$toDirection;\n  if (!colorStops || colorStops.length < 2) {\n    throw new PolishedError(56);\n  }\n  return {\n    backgroundColor: fallback || colorStops[0].replace(/,\\s+/g, ',').split(' ')[0].replace(/,(?=\\S)/g, ', '),\n    backgroundImage: constructGradientValue(_templateObject$1 || (_templateObject$1 = _taggedTemplateLiteralLoose([\"linear-gradient(\", \"\", \")\"])), toDirection, colorStops.join(', ').replace(/,(?=\\S)/g, ', '))\n  };\n}\n\n/**\n * CSS to normalize abnormalities across browsers (normalize.css v8.0.1 | MIT License | github.com/necolas/normalize.css)\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *    ...normalize(),\n * }\n *\n * // styled-components usage\n * const GlobalStyle = createGlobalStyle`${normalize()}`\n *\n * // CSS as JS Output\n *\n * html {\n *   lineHeight: 1.15,\n *   textSizeAdjust: 100%,\n * } ...\n */\nfunction normalize() {\n  var _ref;\n  return [(_ref = {\n    html: {\n      lineHeight: '1.15',\n      textSizeAdjust: '100%'\n    },\n    body: {\n      margin: '0'\n    },\n    main: {\n      display: 'block'\n    },\n    h1: {\n      fontSize: '2em',\n      margin: '0.67em 0'\n    },\n    hr: {\n      boxSizing: 'content-box',\n      height: '0',\n      overflow: 'visible'\n    },\n    pre: {\n      fontFamily: 'monospace, monospace',\n      fontSize: '1em'\n    },\n    a: {\n      backgroundColor: 'transparent'\n    },\n    'abbr[title]': {\n      borderBottom: 'none',\n      textDecoration: 'underline'\n    }\n  }, _ref[\"b,\\n    strong\"] = {\n    fontWeight: 'bolder'\n  }, _ref[\"code,\\n    kbd,\\n    samp\"] = {\n    fontFamily: 'monospace, monospace',\n    fontSize: '1em'\n  }, _ref.small = {\n    fontSize: '80%'\n  }, _ref[\"sub,\\n    sup\"] = {\n    fontSize: '75%',\n    lineHeight: '0',\n    position: 'relative',\n    verticalAlign: 'baseline'\n  }, _ref.sub = {\n    bottom: '-0.25em'\n  }, _ref.sup = {\n    top: '-0.5em'\n  }, _ref.img = {\n    borderStyle: 'none'\n  }, _ref[\"button,\\n    input,\\n    optgroup,\\n    select,\\n    textarea\"] = {\n    fontFamily: 'inherit',\n    fontSize: '100%',\n    lineHeight: '1.15',\n    margin: '0'\n  }, _ref[\"button,\\n    input\"] = {\n    overflow: 'visible'\n  }, _ref[\"button,\\n    select\"] = {\n    textTransform: 'none'\n  }, _ref[\"button,\\n    html [type=\\\"button\\\"],\\n    [type=\\\"reset\\\"],\\n    [type=\\\"submit\\\"]\"] = {\n    WebkitAppearance: 'button'\n  }, _ref[\"button::-moz-focus-inner,\\n    [type=\\\"button\\\"]::-moz-focus-inner,\\n    [type=\\\"reset\\\"]::-moz-focus-inner,\\n    [type=\\\"submit\\\"]::-moz-focus-inner\"] = {\n    borderStyle: 'none',\n    padding: '0'\n  }, _ref[\"button:-moz-focusring,\\n    [type=\\\"button\\\"]:-moz-focusring,\\n    [type=\\\"reset\\\"]:-moz-focusring,\\n    [type=\\\"submit\\\"]:-moz-focusring\"] = {\n    outline: '1px dotted ButtonText'\n  }, _ref.fieldset = {\n    padding: '0.35em 0.625em 0.75em'\n  }, _ref.legend = {\n    boxSizing: 'border-box',\n    color: 'inherit',\n    display: 'table',\n    maxWidth: '100%',\n    padding: '0',\n    whiteSpace: 'normal'\n  }, _ref.progress = {\n    verticalAlign: 'baseline'\n  }, _ref.textarea = {\n    overflow: 'auto'\n  }, _ref[\"[type=\\\"checkbox\\\"],\\n    [type=\\\"radio\\\"]\"] = {\n    boxSizing: 'border-box',\n    padding: '0'\n  }, _ref[\"[type=\\\"number\\\"]::-webkit-inner-spin-button,\\n    [type=\\\"number\\\"]::-webkit-outer-spin-button\"] = {\n    height: 'auto'\n  }, _ref['[type=\"search\"]'] = {\n    WebkitAppearance: 'textfield',\n    outlineOffset: '-2px'\n  }, _ref['[type=\"search\"]::-webkit-search-decoration'] = {\n    WebkitAppearance: 'none'\n  }, _ref['::-webkit-file-upload-button'] = {\n    WebkitAppearance: 'button',\n    font: 'inherit'\n  }, _ref.details = {\n    display: 'block'\n  }, _ref.summary = {\n    display: 'list-item'\n  }, _ref.template = {\n    display: 'none'\n  }, _ref['[hidden]'] = {\n    display: 'none'\n  }, _ref), {\n    'abbr[title]': {\n      textDecoration: 'underline dotted'\n    }\n  }];\n}\n\nvar _templateObject;\n/**\n * CSS for declaring a radial gradient, including a fallback background-color. The fallback is either the first color-stop or an explicitly passed fallback color.\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   ...radialGradient({\n *     colorStops: ['#00FFFF 0%', 'rgba(0, 0, 255, 0) 50%', '#0000FF 95%'],\n *     extent: 'farthest-corner at 45px 45px',\n *     position: 'center',\n *     shape: 'ellipse',\n *   })\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   ${radialGradient({\n *     colorStops: ['#00FFFF 0%', 'rgba(0, 0, 255, 0) 50%', '#0000FF 95%'],\n *     extent: 'farthest-corner at 45px 45px',\n *     position: 'center',\n *     shape: 'ellipse',\n *   })}\n *`\n *\n * // CSS as JS Output\n *\n * div: {\n *   'backgroundColor': '#00FFFF',\n *   'backgroundImage': 'radial-gradient(center ellipse farthest-corner at 45px 45px, #00FFFF 0%, rgba(0, 0, 255, 0) 50%, #0000FF 95%)',\n * }\n */\nfunction radialGradient(_ref) {\n  var colorStops = _ref.colorStops,\n    _ref$extent = _ref.extent,\n    extent = _ref$extent === void 0 ? '' : _ref$extent,\n    fallback = _ref.fallback,\n    _ref$position = _ref.position,\n    position = _ref$position === void 0 ? '' : _ref$position,\n    _ref$shape = _ref.shape,\n    shape = _ref$shape === void 0 ? '' : _ref$shape;\n  if (!colorStops || colorStops.length < 2) {\n    throw new PolishedError(57);\n  }\n  return {\n    backgroundColor: fallback || colorStops[0].split(' ')[0],\n    backgroundImage: constructGradientValue(_templateObject || (_templateObject = _taggedTemplateLiteralLoose([\"radial-gradient(\", \"\", \"\", \"\", \")\"])), position, shape, extent, colorStops.join(', '))\n  };\n}\n\n/**\n * A helper to generate a retina background image and non-retina\n * background image. The retina background image will output to a HiDPI media query. The mixin uses\n * a _2x.png filename suffix by default.\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *  ...retinaImage('my-img')\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   ${retinaImage('my-img')}\n * `\n *\n * // CSS as JS Output\n * div {\n *   backgroundImage: 'url(my-img.png)',\n *   '@media only screen and (-webkit-min-device-pixel-ratio: 1.3),\n *    only screen and (min--moz-device-pixel-ratio: 1.3),\n *    only screen and (-o-min-device-pixel-ratio: 1.3/1),\n *    only screen and (min-resolution: 144dpi),\n *    only screen and (min-resolution: 1.5dppx)': {\n *     backgroundImage: 'url(my-img_2x.png)',\n *   }\n * }\n */\nfunction retinaImage(filename, backgroundSize, extension, retinaFilename, retinaSuffix) {\n  var _ref;\n  if (extension === void 0) {\n    extension = 'png';\n  }\n  if (retinaSuffix === void 0) {\n    retinaSuffix = '_2x';\n  }\n  if (!filename) {\n    throw new PolishedError(58);\n  }\n  // Replace the dot at the beginning of the passed extension if one exists\n  var ext = extension.replace(/^\\./, '');\n  var rFilename = retinaFilename ? retinaFilename + \".\" + ext : \"\" + filename + retinaSuffix + \".\" + ext;\n  return _ref = {\n    backgroundImage: \"url(\" + filename + \".\" + ext + \")\"\n  }, _ref[hiDPI()] = _extends({\n    backgroundImage: \"url(\" + rFilename + \")\"\n  }, backgroundSize ? {\n    backgroundSize: backgroundSize\n  } : {}), _ref;\n}\n\n/* eslint-disable key-spacing */\nvar functionsMap = {\n  easeInBack: 'cubic-bezier(0.600, -0.280, 0.735, 0.045)',\n  easeInCirc: 'cubic-bezier(0.600,  0.040, 0.980, 0.335)',\n  easeInCubic: 'cubic-bezier(0.550,  0.055, 0.675, 0.190)',\n  easeInExpo: 'cubic-bezier(0.950,  0.050, 0.795, 0.035)',\n  easeInQuad: 'cubic-bezier(0.550,  0.085, 0.680, 0.530)',\n  easeInQuart: 'cubic-bezier(0.895,  0.030, 0.685, 0.220)',\n  easeInQuint: 'cubic-bezier(0.755,  0.050, 0.855, 0.060)',\n  easeInSine: 'cubic-bezier(0.470,  0.000, 0.745, 0.715)',\n  easeOutBack: 'cubic-bezier(0.175,  0.885, 0.320, 1.275)',\n  easeOutCubic: 'cubic-bezier(0.215,  0.610, 0.355, 1.000)',\n  easeOutCirc: 'cubic-bezier(0.075,  0.820, 0.165, 1.000)',\n  easeOutExpo: 'cubic-bezier(0.190,  1.000, 0.220, 1.000)',\n  easeOutQuad: 'cubic-bezier(0.250,  0.460, 0.450, 0.940)',\n  easeOutQuart: 'cubic-bezier(0.165,  0.840, 0.440, 1.000)',\n  easeOutQuint: 'cubic-bezier(0.230,  1.000, 0.320, 1.000)',\n  easeOutSine: 'cubic-bezier(0.390,  0.575, 0.565, 1.000)',\n  easeInOutBack: 'cubic-bezier(0.680, -0.550, 0.265, 1.550)',\n  easeInOutCirc: 'cubic-bezier(0.785,  0.135, 0.150, 0.860)',\n  easeInOutCubic: 'cubic-bezier(0.645,  0.045, 0.355, 1.000)',\n  easeInOutExpo: 'cubic-bezier(1.000,  0.000, 0.000, 1.000)',\n  easeInOutQuad: 'cubic-bezier(0.455,  0.030, 0.515, 0.955)',\n  easeInOutQuart: 'cubic-bezier(0.770,  0.000, 0.175, 1.000)',\n  easeInOutQuint: 'cubic-bezier(0.860,  0.000, 0.070, 1.000)',\n  easeInOutSine: 'cubic-bezier(0.445,  0.050, 0.550, 0.950)'\n};\n/* eslint-enable key-spacing */\n\nfunction getTimingFunction(functionName) {\n  return functionsMap[functionName];\n}\n\n/**\n * String to represent common easing functions as demonstrated here: (github.com/jaukia/easie).\n *\n * @deprecated - This will be deprecated in v5 in favor of `easeIn`, `easeOut`, `easeInOut`.\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   'transitionTimingFunction': timingFunctions('easeInQuad')\n * }\n *\n * // styled-components usage\n *  const div = styled.div`\n *   transitionTimingFunction: ${timingFunctions('easeInQuad')};\n * `\n *\n * // CSS as JS Output\n *\n * 'div': {\n *   'transitionTimingFunction': 'cubic-bezier(0.550,  0.085, 0.680, 0.530)',\n * }\n */\n\nfunction timingFunctions(timingFunction) {\n  return getTimingFunction(timingFunction);\n}\n\nvar getBorderWidth = function getBorderWidth(pointingDirection, height, width) {\n  var fullWidth = \"\" + width[0] + (width[1] || '');\n  var halfWidth = \"\" + width[0] / 2 + (width[1] || '');\n  var fullHeight = \"\" + height[0] + (height[1] || '');\n  var halfHeight = \"\" + height[0] / 2 + (height[1] || '');\n  switch (pointingDirection) {\n    case 'top':\n      return \"0 \" + halfWidth + \" \" + fullHeight + \" \" + halfWidth;\n    case 'topLeft':\n      return fullWidth + \" \" + fullHeight + \" 0 0\";\n    case 'left':\n      return halfHeight + \" \" + fullWidth + \" \" + halfHeight + \" 0\";\n    case 'bottomLeft':\n      return fullWidth + \" 0 0 \" + fullHeight;\n    case 'bottom':\n      return fullHeight + \" \" + halfWidth + \" 0 \" + halfWidth;\n    case 'bottomRight':\n      return \"0 0 \" + fullWidth + \" \" + fullHeight;\n    case 'right':\n      return halfHeight + \" 0 \" + halfHeight + \" \" + fullWidth;\n    case 'topRight':\n    default:\n      return \"0 \" + fullWidth + \" \" + fullHeight + \" 0\";\n  }\n};\nvar getBorderColor = function getBorderColor(pointingDirection, foregroundColor) {\n  switch (pointingDirection) {\n    case 'top':\n    case 'bottomRight':\n      return {\n        borderBottomColor: foregroundColor\n      };\n    case 'right':\n    case 'bottomLeft':\n      return {\n        borderLeftColor: foregroundColor\n      };\n    case 'bottom':\n    case 'topLeft':\n      return {\n        borderTopColor: foregroundColor\n      };\n    case 'left':\n    case 'topRight':\n      return {\n        borderRightColor: foregroundColor\n      };\n    default:\n      throw new PolishedError(59);\n  }\n};\n\n/**\n * CSS to represent triangle with any pointing direction with an optional background color.\n *\n * @example\n * // Styles as object usage\n *\n * const styles = {\n *   ...triangle({ pointingDirection: 'right', width: '100px', height: '100px', foregroundColor: 'red' })\n * }\n *\n *\n * // styled-components usage\n * const div = styled.div`\n *   ${triangle({ pointingDirection: 'right', width: '100px', height: '100px', foregroundColor: 'red' })}\n *\n *\n * // CSS as JS Output\n *\n * div: {\n *  'borderColor': 'transparent transparent transparent red',\n *  'borderStyle': 'solid',\n *  'borderWidth': '50px 0 50px 100px',\n *  'height': '0',\n *  'width': '0',\n * }\n */\nfunction triangle(_ref) {\n  var pointingDirection = _ref.pointingDirection,\n    height = _ref.height,\n    width = _ref.width,\n    foregroundColor = _ref.foregroundColor,\n    _ref$backgroundColor = _ref.backgroundColor,\n    backgroundColor = _ref$backgroundColor === void 0 ? 'transparent' : _ref$backgroundColor;\n  var widthAndUnit = getValueAndUnit(width);\n  var heightAndUnit = getValueAndUnit(height);\n  if (isNaN(heightAndUnit[0]) || isNaN(widthAndUnit[0])) {\n    throw new PolishedError(60);\n  }\n  return _extends({\n    width: '0',\n    height: '0',\n    borderColor: backgroundColor\n  }, getBorderColor(pointingDirection, foregroundColor), {\n    borderStyle: 'solid',\n    borderWidth: getBorderWidth(pointingDirection, heightAndUnit, widthAndUnit)\n  });\n}\n\n/**\n * Provides an easy way to change the `wordWrap` property.\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   ...wordWrap('break-word')\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   ${wordWrap('break-word')}\n * `\n *\n * // CSS as JS Output\n *\n * const styles = {\n *   overflowWrap: 'break-word',\n *   wordWrap: 'break-word',\n *   wordBreak: 'break-all',\n * }\n */\nfunction wordWrap(wrap) {\n  if (wrap === void 0) {\n    wrap = 'break-word';\n  }\n  var wordBreak = wrap === 'break-word' ? 'break-all' : wrap;\n  return {\n    overflowWrap: wrap,\n    wordWrap: wrap,\n    wordBreak: wordBreak\n  };\n}\n\nfunction colorToInt(color) {\n  return Math.round(color * 255);\n}\nfunction convertToInt(red, green, blue) {\n  return colorToInt(red) + \",\" + colorToInt(green) + \",\" + colorToInt(blue);\n}\nfunction hslToRgb(hue, saturation, lightness, convert) {\n  if (convert === void 0) {\n    convert = convertToInt;\n  }\n  if (saturation === 0) {\n    // achromatic\n    return convert(lightness, lightness, lightness);\n  }\n\n  // formulae from https://en.wikipedia.org/wiki/HSL_and_HSV\n  var huePrime = (hue % 360 + 360) % 360 / 60;\n  var chroma = (1 - Math.abs(2 * lightness - 1)) * saturation;\n  var secondComponent = chroma * (1 - Math.abs(huePrime % 2 - 1));\n  var red = 0;\n  var green = 0;\n  var blue = 0;\n  if (huePrime >= 0 && huePrime < 1) {\n    red = chroma;\n    green = secondComponent;\n  } else if (huePrime >= 1 && huePrime < 2) {\n    red = secondComponent;\n    green = chroma;\n  } else if (huePrime >= 2 && huePrime < 3) {\n    green = chroma;\n    blue = secondComponent;\n  } else if (huePrime >= 3 && huePrime < 4) {\n    green = secondComponent;\n    blue = chroma;\n  } else if (huePrime >= 4 && huePrime < 5) {\n    red = secondComponent;\n    blue = chroma;\n  } else if (huePrime >= 5 && huePrime < 6) {\n    red = chroma;\n    blue = secondComponent;\n  }\n  var lightnessModification = lightness - chroma / 2;\n  var finalRed = red + lightnessModification;\n  var finalGreen = green + lightnessModification;\n  var finalBlue = blue + lightnessModification;\n  return convert(finalRed, finalGreen, finalBlue);\n}\n\nvar namedColorMap = {\n  aliceblue: 'f0f8ff',\n  antiquewhite: 'faebd7',\n  aqua: '00ffff',\n  aquamarine: '7fffd4',\n  azure: 'f0ffff',\n  beige: 'f5f5dc',\n  bisque: 'ffe4c4',\n  black: '000',\n  blanchedalmond: 'ffebcd',\n  blue: '0000ff',\n  blueviolet: '8a2be2',\n  brown: 'a52a2a',\n  burlywood: 'deb887',\n  cadetblue: '5f9ea0',\n  chartreuse: '7fff00',\n  chocolate: 'd2691e',\n  coral: 'ff7f50',\n  cornflowerblue: '6495ed',\n  cornsilk: 'fff8dc',\n  crimson: 'dc143c',\n  cyan: '00ffff',\n  darkblue: '00008b',\n  darkcyan: '008b8b',\n  darkgoldenrod: 'b8860b',\n  darkgray: 'a9a9a9',\n  darkgreen: '006400',\n  darkgrey: 'a9a9a9',\n  darkkhaki: 'bdb76b',\n  darkmagenta: '8b008b',\n  darkolivegreen: '556b2f',\n  darkorange: 'ff8c00',\n  darkorchid: '9932cc',\n  darkred: '8b0000',\n  darksalmon: 'e9967a',\n  darkseagreen: '8fbc8f',\n  darkslateblue: '483d8b',\n  darkslategray: '2f4f4f',\n  darkslategrey: '2f4f4f',\n  darkturquoise: '00ced1',\n  darkviolet: '9400d3',\n  deeppink: 'ff1493',\n  deepskyblue: '00bfff',\n  dimgray: '696969',\n  dimgrey: '696969',\n  dodgerblue: '1e90ff',\n  firebrick: 'b22222',\n  floralwhite: 'fffaf0',\n  forestgreen: '228b22',\n  fuchsia: 'ff00ff',\n  gainsboro: 'dcdcdc',\n  ghostwhite: 'f8f8ff',\n  gold: 'ffd700',\n  goldenrod: 'daa520',\n  gray: '808080',\n  green: '008000',\n  greenyellow: 'adff2f',\n  grey: '808080',\n  honeydew: 'f0fff0',\n  hotpink: 'ff69b4',\n  indianred: 'cd5c5c',\n  indigo: '4b0082',\n  ivory: 'fffff0',\n  khaki: 'f0e68c',\n  lavender: 'e6e6fa',\n  lavenderblush: 'fff0f5',\n  lawngreen: '7cfc00',\n  lemonchiffon: 'fffacd',\n  lightblue: 'add8e6',\n  lightcoral: 'f08080',\n  lightcyan: 'e0ffff',\n  lightgoldenrodyellow: 'fafad2',\n  lightgray: 'd3d3d3',\n  lightgreen: '90ee90',\n  lightgrey: 'd3d3d3',\n  lightpink: 'ffb6c1',\n  lightsalmon: 'ffa07a',\n  lightseagreen: '20b2aa',\n  lightskyblue: '87cefa',\n  lightslategray: '789',\n  lightslategrey: '789',\n  lightsteelblue: 'b0c4de',\n  lightyellow: 'ffffe0',\n  lime: '0f0',\n  limegreen: '32cd32',\n  linen: 'faf0e6',\n  magenta: 'f0f',\n  maroon: '800000',\n  mediumaquamarine: '66cdaa',\n  mediumblue: '0000cd',\n  mediumorchid: 'ba55d3',\n  mediumpurple: '9370db',\n  mediumseagreen: '3cb371',\n  mediumslateblue: '7b68ee',\n  mediumspringgreen: '00fa9a',\n  mediumturquoise: '48d1cc',\n  mediumvioletred: 'c71585',\n  midnightblue: '191970',\n  mintcream: 'f5fffa',\n  mistyrose: 'ffe4e1',\n  moccasin: 'ffe4b5',\n  navajowhite: 'ffdead',\n  navy: '000080',\n  oldlace: 'fdf5e6',\n  olive: '808000',\n  olivedrab: '6b8e23',\n  orange: 'ffa500',\n  orangered: 'ff4500',\n  orchid: 'da70d6',\n  palegoldenrod: 'eee8aa',\n  palegreen: '98fb98',\n  paleturquoise: 'afeeee',\n  palevioletred: 'db7093',\n  papayawhip: 'ffefd5',\n  peachpuff: 'ffdab9',\n  peru: 'cd853f',\n  pink: 'ffc0cb',\n  plum: 'dda0dd',\n  powderblue: 'b0e0e6',\n  purple: '800080',\n  rebeccapurple: '639',\n  red: 'f00',\n  rosybrown: 'bc8f8f',\n  royalblue: '4169e1',\n  saddlebrown: '8b4513',\n  salmon: 'fa8072',\n  sandybrown: 'f4a460',\n  seagreen: '2e8b57',\n  seashell: 'fff5ee',\n  sienna: 'a0522d',\n  silver: 'c0c0c0',\n  skyblue: '87ceeb',\n  slateblue: '6a5acd',\n  slategray: '708090',\n  slategrey: '708090',\n  snow: 'fffafa',\n  springgreen: '00ff7f',\n  steelblue: '4682b4',\n  tan: 'd2b48c',\n  teal: '008080',\n  thistle: 'd8bfd8',\n  tomato: 'ff6347',\n  turquoise: '40e0d0',\n  violet: 'ee82ee',\n  wheat: 'f5deb3',\n  white: 'fff',\n  whitesmoke: 'f5f5f5',\n  yellow: 'ff0',\n  yellowgreen: '9acd32'\n};\n\n/**\n * Checks if a string is a CSS named color and returns its equivalent hex value, otherwise returns the original color.\n * @private\n */\nfunction nameToHex(color) {\n  if (typeof color !== 'string') return color;\n  var normalizedColorName = color.toLowerCase();\n  return namedColorMap[normalizedColorName] ? \"#\" + namedColorMap[normalizedColorName] : color;\n}\n\nvar hexRegex = /^#[a-fA-F0-9]{6}$/;\nvar hexRgbaRegex = /^#[a-fA-F0-9]{8}$/;\nvar reducedHexRegex = /^#[a-fA-F0-9]{3}$/;\nvar reducedRgbaHexRegex = /^#[a-fA-F0-9]{4}$/;\nvar rgbRegex = /^rgb\\(\\s*(\\d{1,3})\\s*(?:,)?\\s*(\\d{1,3})\\s*(?:,)?\\s*(\\d{1,3})\\s*\\)$/i;\nvar rgbaRegex = /^rgb(?:a)?\\(\\s*(\\d{1,3})\\s*(?:,)?\\s*(\\d{1,3})\\s*(?:,)?\\s*(\\d{1,3})\\s*(?:,|\\/)\\s*([-+]?\\d*[.]?\\d+[%]?)\\s*\\)$/i;\nvar hslRegex = /^hsl\\(\\s*(\\d{0,3}[.]?[0-9]+(?:deg)?)\\s*(?:,)?\\s*(\\d{1,3}[.]?[0-9]?)%\\s*(?:,)?\\s*(\\d{1,3}[.]?[0-9]?)%\\s*\\)$/i;\nvar hslaRegex = /^hsl(?:a)?\\(\\s*(\\d{0,3}[.]?[0-9]+(?:deg)?)\\s*(?:,)?\\s*(\\d{1,3}[.]?[0-9]?)%\\s*(?:,)?\\s*(\\d{1,3}[.]?[0-9]?)%\\s*(?:,|\\/)\\s*([-+]?\\d*[.]?\\d+[%]?)\\s*\\)$/i;\n\n/**\n * Returns an RgbColor or RgbaColor object. This utility function is only useful\n * if want to extract a color component. With the color util `toColorString` you\n * can convert a RgbColor or RgbaColor object back to a string.\n *\n * @example\n * // Assigns `{ red: 255, green: 0, blue: 0 }` to color1\n * const color1 = parseToRgb('rgb(255, 0, 0)');\n * // Assigns `{ red: 92, green: 102, blue: 112, alpha: 0.75 }` to color2\n * const color2 = parseToRgb('hsla(210, 10%, 40%, 0.75)');\n */\nfunction parseToRgb(color) {\n  if (typeof color !== 'string') {\n    throw new PolishedError(3);\n  }\n  var normalizedColor = nameToHex(color);\n  if (normalizedColor.match(hexRegex)) {\n    return {\n      red: parseInt(\"\" + normalizedColor[1] + normalizedColor[2], 16),\n      green: parseInt(\"\" + normalizedColor[3] + normalizedColor[4], 16),\n      blue: parseInt(\"\" + normalizedColor[5] + normalizedColor[6], 16)\n    };\n  }\n  if (normalizedColor.match(hexRgbaRegex)) {\n    var alpha = parseFloat((parseInt(\"\" + normalizedColor[7] + normalizedColor[8], 16) / 255).toFixed(2));\n    return {\n      red: parseInt(\"\" + normalizedColor[1] + normalizedColor[2], 16),\n      green: parseInt(\"\" + normalizedColor[3] + normalizedColor[4], 16),\n      blue: parseInt(\"\" + normalizedColor[5] + normalizedColor[6], 16),\n      alpha: alpha\n    };\n  }\n  if (normalizedColor.match(reducedHexRegex)) {\n    return {\n      red: parseInt(\"\" + normalizedColor[1] + normalizedColor[1], 16),\n      green: parseInt(\"\" + normalizedColor[2] + normalizedColor[2], 16),\n      blue: parseInt(\"\" + normalizedColor[3] + normalizedColor[3], 16)\n    };\n  }\n  if (normalizedColor.match(reducedRgbaHexRegex)) {\n    var _alpha = parseFloat((parseInt(\"\" + normalizedColor[4] + normalizedColor[4], 16) / 255).toFixed(2));\n    return {\n      red: parseInt(\"\" + normalizedColor[1] + normalizedColor[1], 16),\n      green: parseInt(\"\" + normalizedColor[2] + normalizedColor[2], 16),\n      blue: parseInt(\"\" + normalizedColor[3] + normalizedColor[3], 16),\n      alpha: _alpha\n    };\n  }\n  var rgbMatched = rgbRegex.exec(normalizedColor);\n  if (rgbMatched) {\n    return {\n      red: parseInt(\"\" + rgbMatched[1], 10),\n      green: parseInt(\"\" + rgbMatched[2], 10),\n      blue: parseInt(\"\" + rgbMatched[3], 10)\n    };\n  }\n  var rgbaMatched = rgbaRegex.exec(normalizedColor.substring(0, 50));\n  if (rgbaMatched) {\n    return {\n      red: parseInt(\"\" + rgbaMatched[1], 10),\n      green: parseInt(\"\" + rgbaMatched[2], 10),\n      blue: parseInt(\"\" + rgbaMatched[3], 10),\n      alpha: parseFloat(\"\" + rgbaMatched[4]) > 1 ? parseFloat(\"\" + rgbaMatched[4]) / 100 : parseFloat(\"\" + rgbaMatched[4])\n    };\n  }\n  var hslMatched = hslRegex.exec(normalizedColor);\n  if (hslMatched) {\n    var hue = parseInt(\"\" + hslMatched[1], 10);\n    var saturation = parseInt(\"\" + hslMatched[2], 10) / 100;\n    var lightness = parseInt(\"\" + hslMatched[3], 10) / 100;\n    var rgbColorString = \"rgb(\" + hslToRgb(hue, saturation, lightness) + \")\";\n    var hslRgbMatched = rgbRegex.exec(rgbColorString);\n    if (!hslRgbMatched) {\n      throw new PolishedError(4, normalizedColor, rgbColorString);\n    }\n    return {\n      red: parseInt(\"\" + hslRgbMatched[1], 10),\n      green: parseInt(\"\" + hslRgbMatched[2], 10),\n      blue: parseInt(\"\" + hslRgbMatched[3], 10)\n    };\n  }\n  var hslaMatched = hslaRegex.exec(normalizedColor.substring(0, 50));\n  if (hslaMatched) {\n    var _hue = parseInt(\"\" + hslaMatched[1], 10);\n    var _saturation = parseInt(\"\" + hslaMatched[2], 10) / 100;\n    var _lightness = parseInt(\"\" + hslaMatched[3], 10) / 100;\n    var _rgbColorString = \"rgb(\" + hslToRgb(_hue, _saturation, _lightness) + \")\";\n    var _hslRgbMatched = rgbRegex.exec(_rgbColorString);\n    if (!_hslRgbMatched) {\n      throw new PolishedError(4, normalizedColor, _rgbColorString);\n    }\n    return {\n      red: parseInt(\"\" + _hslRgbMatched[1], 10),\n      green: parseInt(\"\" + _hslRgbMatched[2], 10),\n      blue: parseInt(\"\" + _hslRgbMatched[3], 10),\n      alpha: parseFloat(\"\" + hslaMatched[4]) > 1 ? parseFloat(\"\" + hslaMatched[4]) / 100 : parseFloat(\"\" + hslaMatched[4])\n    };\n  }\n  throw new PolishedError(5);\n}\n\nfunction rgbToHsl(color) {\n  // make sure rgb are contained in a set of [0, 255]\n  var red = color.red / 255;\n  var green = color.green / 255;\n  var blue = color.blue / 255;\n  var max = Math.max(red, green, blue);\n  var min = Math.min(red, green, blue);\n  var lightness = (max + min) / 2;\n  if (max === min) {\n    // achromatic\n    if (color.alpha !== undefined) {\n      return {\n        hue: 0,\n        saturation: 0,\n        lightness: lightness,\n        alpha: color.alpha\n      };\n    } else {\n      return {\n        hue: 0,\n        saturation: 0,\n        lightness: lightness\n      };\n    }\n  }\n  var hue;\n  var delta = max - min;\n  var saturation = lightness > 0.5 ? delta / (2 - max - min) : delta / (max + min);\n  switch (max) {\n    case red:\n      hue = (green - blue) / delta + (green < blue ? 6 : 0);\n      break;\n    case green:\n      hue = (blue - red) / delta + 2;\n      break;\n    default:\n      // blue case\n      hue = (red - green) / delta + 4;\n      break;\n  }\n  hue *= 60;\n  if (color.alpha !== undefined) {\n    return {\n      hue: hue,\n      saturation: saturation,\n      lightness: lightness,\n      alpha: color.alpha\n    };\n  }\n  return {\n    hue: hue,\n    saturation: saturation,\n    lightness: lightness\n  };\n}\n\n/**\n * Returns an HslColor or HslaColor object. This utility function is only useful\n * if want to extract a color component. With the color util `toColorString` you\n * can convert a HslColor or HslaColor object back to a string.\n *\n * @example\n * // Assigns `{ hue: 0, saturation: 1, lightness: 0.5 }` to color1\n * const color1 = parseToHsl('rgb(255, 0, 0)');\n * // Assigns `{ hue: 128, saturation: 1, lightness: 0.5, alpha: 0.75 }` to color2\n * const color2 = parseToHsl('hsla(128, 100%, 50%, 0.75)');\n */\nfunction parseToHsl(color) {\n  // Note: At a later stage we can optimize this function as right now a hsl\n  // color would be parsed converted to rgb values and converted back to hsl.\n  return rgbToHsl(parseToRgb(color));\n}\n\n/**\n * Reduces hex values if possible e.g. #ff8866 to #f86\n * @private\n */\nvar reduceHexValue = function reduceHexValue(value) {\n  if (value.length === 7 && value[1] === value[2] && value[3] === value[4] && value[5] === value[6]) {\n    return \"#\" + value[1] + value[3] + value[5];\n  }\n  return value;\n};\nvar reduceHexValue$1 = reduceHexValue;\n\nfunction numberToHex(value) {\n  var hex = value.toString(16);\n  return hex.length === 1 ? \"0\" + hex : hex;\n}\n\nfunction colorToHex(color) {\n  return numberToHex(Math.round(color * 255));\n}\nfunction convertToHex(red, green, blue) {\n  return reduceHexValue$1(\"#\" + colorToHex(red) + colorToHex(green) + colorToHex(blue));\n}\nfunction hslToHex(hue, saturation, lightness) {\n  return hslToRgb(hue, saturation, lightness, convertToHex);\n}\n\n/**\n * Returns a string value for the color. The returned result is the smallest possible hex notation.\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   background: hsl(359, 0.75, 0.4),\n *   background: hsl({ hue: 360, saturation: 0.75, lightness: 0.4 }),\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   background: ${hsl(359, 0.75, 0.4)};\n *   background: ${hsl({ hue: 360, saturation: 0.75, lightness: 0.4 })};\n * `\n *\n * // CSS in JS Output\n *\n * element {\n *   background: \"#b3191c\";\n *   background: \"#b3191c\";\n * }\n */\nfunction hsl(value, saturation, lightness) {\n  if (typeof value === 'number' && typeof saturation === 'number' && typeof lightness === 'number') {\n    return hslToHex(value, saturation, lightness);\n  } else if (typeof value === 'object' && saturation === undefined && lightness === undefined) {\n    return hslToHex(value.hue, value.saturation, value.lightness);\n  }\n  throw new PolishedError(1);\n}\n\n/**\n * Returns a string value for the color. The returned result is the smallest possible rgba or hex notation.\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   background: hsla(359, 0.75, 0.4, 0.7),\n *   background: hsla({ hue: 360, saturation: 0.75, lightness: 0.4, alpha: 0,7 }),\n *   background: hsla(359, 0.75, 0.4, 1),\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   background: ${hsla(359, 0.75, 0.4, 0.7)};\n *   background: ${hsla({ hue: 360, saturation: 0.75, lightness: 0.4, alpha: 0,7 })};\n *   background: ${hsla(359, 0.75, 0.4, 1)};\n * `\n *\n * // CSS in JS Output\n *\n * element {\n *   background: \"rgba(179,25,28,0.7)\";\n *   background: \"rgba(179,25,28,0.7)\";\n *   background: \"#b3191c\";\n * }\n */\nfunction hsla(value, saturation, lightness, alpha) {\n  if (typeof value === 'number' && typeof saturation === 'number' && typeof lightness === 'number' && typeof alpha === 'number') {\n    return alpha >= 1 ? hslToHex(value, saturation, lightness) : \"rgba(\" + hslToRgb(value, saturation, lightness) + \",\" + alpha + \")\";\n  } else if (typeof value === 'object' && saturation === undefined && lightness === undefined && alpha === undefined) {\n    return value.alpha >= 1 ? hslToHex(value.hue, value.saturation, value.lightness) : \"rgba(\" + hslToRgb(value.hue, value.saturation, value.lightness) + \",\" + value.alpha + \")\";\n  }\n  throw new PolishedError(2);\n}\n\n/**\n * Returns a string value for the color. The returned result is the smallest possible hex notation.\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   background: rgb(255, 205, 100),\n *   background: rgb({ red: 255, green: 205, blue: 100 }),\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   background: ${rgb(255, 205, 100)};\n *   background: ${rgb({ red: 255, green: 205, blue: 100 })};\n * `\n *\n * // CSS in JS Output\n *\n * element {\n *   background: \"#ffcd64\";\n *   background: \"#ffcd64\";\n * }\n */\nfunction rgb(value, green, blue) {\n  if (typeof value === 'number' && typeof green === 'number' && typeof blue === 'number') {\n    return reduceHexValue$1(\"#\" + numberToHex(value) + numberToHex(green) + numberToHex(blue));\n  } else if (typeof value === 'object' && green === undefined && blue === undefined) {\n    return reduceHexValue$1(\"#\" + numberToHex(value.red) + numberToHex(value.green) + numberToHex(value.blue));\n  }\n  throw new PolishedError(6);\n}\n\n/**\n * Returns a string value for the color. The returned result is the smallest possible rgba or hex notation.\n *\n * Can also be used to fade a color by passing a hex value or named CSS color along with an alpha value.\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   background: rgba(255, 205, 100, 0.7),\n *   background: rgba({ red: 255, green: 205, blue: 100, alpha: 0.7 }),\n *   background: rgba(255, 205, 100, 1),\n *   background: rgba('#ffffff', 0.4),\n *   background: rgba('black', 0.7),\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   background: ${rgba(255, 205, 100, 0.7)};\n *   background: ${rgba({ red: 255, green: 205, blue: 100, alpha: 0.7 })};\n *   background: ${rgba(255, 205, 100, 1)};\n *   background: ${rgba('#ffffff', 0.4)};\n *   background: ${rgba('black', 0.7)};\n * `\n *\n * // CSS in JS Output\n *\n * element {\n *   background: \"rgba(255,205,100,0.7)\";\n *   background: \"rgba(255,205,100,0.7)\";\n *   background: \"#ffcd64\";\n *   background: \"rgba(255,255,255,0.4)\";\n *   background: \"rgba(0,0,0,0.7)\";\n * }\n */\nfunction rgba(firstValue, secondValue, thirdValue, fourthValue) {\n  if (typeof firstValue === 'string' && typeof secondValue === 'number') {\n    var rgbValue = parseToRgb(firstValue);\n    return \"rgba(\" + rgbValue.red + \",\" + rgbValue.green + \",\" + rgbValue.blue + \",\" + secondValue + \")\";\n  } else if (typeof firstValue === 'number' && typeof secondValue === 'number' && typeof thirdValue === 'number' && typeof fourthValue === 'number') {\n    return fourthValue >= 1 ? rgb(firstValue, secondValue, thirdValue) : \"rgba(\" + firstValue + \",\" + secondValue + \",\" + thirdValue + \",\" + fourthValue + \")\";\n  } else if (typeof firstValue === 'object' && secondValue === undefined && thirdValue === undefined && fourthValue === undefined) {\n    return firstValue.alpha >= 1 ? rgb(firstValue.red, firstValue.green, firstValue.blue) : \"rgba(\" + firstValue.red + \",\" + firstValue.green + \",\" + firstValue.blue + \",\" + firstValue.alpha + \")\";\n  }\n  throw new PolishedError(7);\n}\n\nvar isRgb = function isRgb(color) {\n  return typeof color.red === 'number' && typeof color.green === 'number' && typeof color.blue === 'number' && (typeof color.alpha !== 'number' || typeof color.alpha === 'undefined');\n};\nvar isRgba = function isRgba(color) {\n  return typeof color.red === 'number' && typeof color.green === 'number' && typeof color.blue === 'number' && typeof color.alpha === 'number';\n};\nvar isHsl = function isHsl(color) {\n  return typeof color.hue === 'number' && typeof color.saturation === 'number' && typeof color.lightness === 'number' && (typeof color.alpha !== 'number' || typeof color.alpha === 'undefined');\n};\nvar isHsla = function isHsla(color) {\n  return typeof color.hue === 'number' && typeof color.saturation === 'number' && typeof color.lightness === 'number' && typeof color.alpha === 'number';\n};\n\n/**\n * Converts a RgbColor, RgbaColor, HslColor or HslaColor object to a color string.\n * This util is useful in case you only know on runtime which color object is\n * used. Otherwise we recommend to rely on `rgb`, `rgba`, `hsl` or `hsla`.\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   background: toColorString({ red: 255, green: 205, blue: 100 }),\n *   background: toColorString({ red: 255, green: 205, blue: 100, alpha: 0.72 }),\n *   background: toColorString({ hue: 240, saturation: 1, lightness: 0.5 }),\n *   background: toColorString({ hue: 360, saturation: 0.75, lightness: 0.4, alpha: 0.72 }),\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   background: ${toColorString({ red: 255, green: 205, blue: 100 })};\n *   background: ${toColorString({ red: 255, green: 205, blue: 100, alpha: 0.72 })};\n *   background: ${toColorString({ hue: 240, saturation: 1, lightness: 0.5 })};\n *   background: ${toColorString({ hue: 360, saturation: 0.75, lightness: 0.4, alpha: 0.72 })};\n * `\n *\n * // CSS in JS Output\n * element {\n *   background: \"#ffcd64\";\n *   background: \"rgba(255,205,100,0.72)\";\n *   background: \"#00f\";\n *   background: \"rgba(179,25,25,0.72)\";\n * }\n */\n\nfunction toColorString(color) {\n  if (typeof color !== 'object') throw new PolishedError(8);\n  if (isRgba(color)) return rgba(color);\n  if (isRgb(color)) return rgb(color);\n  if (isHsla(color)) return hsla(color);\n  if (isHsl(color)) return hsl(color);\n  throw new PolishedError(8);\n}\n\n// Type definitions taken from https://github.com/gcanti/flow-static-land/blob/master/src/Fun.js\n// eslint-disable-next-line no-unused-vars\n// eslint-disable-next-line no-unused-vars\n// eslint-disable-next-line no-redeclare\nfunction curried(f, length, acc) {\n  return function fn() {\n    // eslint-disable-next-line prefer-rest-params\n    var combined = acc.concat(Array.prototype.slice.call(arguments));\n    return combined.length >= length ? f.apply(this, combined) : curried(f, length, combined);\n  };\n}\n\n// eslint-disable-next-line no-redeclare\nfunction curry(f) {\n  // eslint-disable-line no-redeclare\n  return curried(f, f.length, []);\n}\n\n/**\n * Changes the hue of the color. Hue is a number between 0 to 360. The first\n * argument for adjustHue is the amount of degrees the color is rotated around\n * the color wheel, always producing a positive hue value.\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   background: adjustHue(180, '#448'),\n *   background: adjustHue('180', 'rgba(101,100,205,0.7)'),\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   background: ${adjustHue(180, '#448')};\n *   background: ${adjustHue('180', 'rgba(101,100,205,0.7)')};\n * `\n *\n * // CSS in JS Output\n * element {\n *   background: \"#888844\";\n *   background: \"rgba(136,136,68,0.7)\";\n * }\n */\nfunction adjustHue(degree, color) {\n  if (color === 'transparent') return color;\n  var hslColor = parseToHsl(color);\n  return toColorString(_extends({}, hslColor, {\n    hue: hslColor.hue + parseFloat(degree)\n  }));\n}\n\n// prettier-ignore\nvar curriedAdjustHue = curry /* ::<number | string, string, string> */(adjustHue);\nvar curriedAdjustHue$1 = curriedAdjustHue;\n\n/**\n * Returns the complement of the provided color. This is identical to adjustHue(180, <color>).\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   background: complement('#448'),\n *   background: complement('rgba(204,205,100,0.7)'),\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   background: ${complement('#448')};\n *   background: ${complement('rgba(204,205,100,0.7)')};\n * `\n *\n * // CSS in JS Output\n * element {\n *   background: \"#884\";\n *   background: \"rgba(153,153,153,0.7)\";\n * }\n */\nfunction complement(color) {\n  if (color === 'transparent') return color;\n  var hslColor = parseToHsl(color);\n  return toColorString(_extends({}, hslColor, {\n    hue: (hslColor.hue + 180) % 360\n  }));\n}\n\nfunction guard(lowerBoundary, upperBoundary, value) {\n  return Math.max(lowerBoundary, Math.min(upperBoundary, value));\n}\n\n/**\n * Returns a string value for the darkened color.\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   background: darken(0.2, '#FFCD64'),\n *   background: darken('0.2', 'rgba(255,205,100,0.7)'),\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   background: ${darken(0.2, '#FFCD64')};\n *   background: ${darken('0.2', 'rgba(255,205,100,0.7)')};\n * `\n *\n * // CSS in JS Output\n *\n * element {\n *   background: \"#ffbd31\";\n *   background: \"rgba(255,189,49,0.7)\";\n * }\n */\nfunction darken(amount, color) {\n  if (color === 'transparent') return color;\n  var hslColor = parseToHsl(color);\n  return toColorString(_extends({}, hslColor, {\n    lightness: guard(0, 1, hslColor.lightness - parseFloat(amount))\n  }));\n}\n\n// prettier-ignore\nvar curriedDarken = curry /* ::<number | string, string, string> */(darken);\nvar curriedDarken$1 = curriedDarken;\n\n/**\n * Decreases the intensity of a color. Its range is between 0 to 1. The first\n * argument of the desaturate function is the amount by how much the color\n * intensity should be decreased.\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   background: desaturate(0.2, '#CCCD64'),\n *   background: desaturate('0.2', 'rgba(204,205,100,0.7)'),\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   background: ${desaturate(0.2, '#CCCD64')};\n *   background: ${desaturate('0.2', 'rgba(204,205,100,0.7)')};\n * `\n *\n * // CSS in JS Output\n * element {\n *   background: \"#b8b979\";\n *   background: \"rgba(184,185,121,0.7)\";\n * }\n */\nfunction desaturate(amount, color) {\n  if (color === 'transparent') return color;\n  var hslColor = parseToHsl(color);\n  return toColorString(_extends({}, hslColor, {\n    saturation: guard(0, 1, hslColor.saturation - parseFloat(amount))\n  }));\n}\n\n// prettier-ignore\nvar curriedDesaturate = curry /* ::<number | string, string, string> */(desaturate);\nvar curriedDesaturate$1 = curriedDesaturate;\n\n/**\n * Returns a number (float) representing the luminance of a color.\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   background: getLuminance('#CCCD64') >= getLuminance('#0000ff') ? '#CCCD64' : '#0000ff',\n *   background: getLuminance('rgba(58, 133, 255, 1)') >= getLuminance('rgba(255, 57, 149, 1)') ?\n *                             'rgba(58, 133, 255, 1)' :\n *                             'rgba(255, 57, 149, 1)',\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   background: ${getLuminance('#CCCD64') >= getLuminance('#0000ff') ? '#CCCD64' : '#0000ff'};\n *   background: ${getLuminance('rgba(58, 133, 255, 1)') >= getLuminance('rgba(255, 57, 149, 1)') ?\n *                             'rgba(58, 133, 255, 1)' :\n *                             'rgba(255, 57, 149, 1)'};\n *\n * // CSS in JS Output\n *\n * div {\n *   background: \"#CCCD64\";\n *   background: \"rgba(58, 133, 255, 1)\";\n * }\n */\nfunction getLuminance(color) {\n  if (color === 'transparent') return 0;\n  var rgbColor = parseToRgb(color);\n  var _Object$keys$map = Object.keys(rgbColor).map(function (key) {\n      var channel = rgbColor[key] / 255;\n      return channel <= 0.03928 ? channel / 12.92 : Math.pow((channel + 0.055) / 1.055, 2.4);\n    }),\n    r = _Object$keys$map[0],\n    g = _Object$keys$map[1],\n    b = _Object$keys$map[2];\n  return parseFloat((0.2126 * r + 0.7152 * g + 0.0722 * b).toFixed(3));\n}\n\n/**\n * Returns the contrast ratio between two colors based on\n * [W3's recommended equation for calculating contrast](http://www.w3.org/TR/WCAG20/#contrast-ratiodef).\n *\n * @example\n * const contrastRatio = getContrast('#444', '#fff');\n */\nfunction getContrast(color1, color2) {\n  var luminance1 = getLuminance(color1);\n  var luminance2 = getLuminance(color2);\n  return parseFloat((luminance1 > luminance2 ? (luminance1 + 0.05) / (luminance2 + 0.05) : (luminance2 + 0.05) / (luminance1 + 0.05)).toFixed(2));\n}\n\n/**\n * Converts the color to a grayscale, by reducing its saturation to 0.\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   background: grayscale('#CCCD64'),\n *   background: grayscale('rgba(204,205,100,0.7)'),\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   background: ${grayscale('#CCCD64')};\n *   background: ${grayscale('rgba(204,205,100,0.7)')};\n * `\n *\n * // CSS in JS Output\n * element {\n *   background: \"#999\";\n *   background: \"rgba(153,153,153,0.7)\";\n * }\n */\nfunction grayscale(color) {\n  if (color === 'transparent') return color;\n  return toColorString(_extends({}, parseToHsl(color), {\n    saturation: 0\n  }));\n}\n\n/**\n * Converts a HslColor or HslaColor object to a color string.\n * This util is useful in case you only know on runtime which color object is\n * used. Otherwise we recommend to rely on `hsl` or `hsla`.\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   background: hslToColorString({ hue: 240, saturation: 1, lightness: 0.5 }),\n *   background: hslToColorString({ hue: 360, saturation: 0.75, lightness: 0.4, alpha: 0.72 }),\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   background: ${hslToColorString({ hue: 240, saturation: 1, lightness: 0.5 })};\n *   background: ${hslToColorString({ hue: 360, saturation: 0.75, lightness: 0.4, alpha: 0.72 })};\n * `\n *\n * // CSS in JS Output\n * element {\n *   background: \"#00f\";\n *   background: \"rgba(179,25,25,0.72)\";\n * }\n */\nfunction hslToColorString(color) {\n  if (typeof color === 'object' && typeof color.hue === 'number' && typeof color.saturation === 'number' && typeof color.lightness === 'number') {\n    if (color.alpha && typeof color.alpha === 'number') {\n      return hsla({\n        hue: color.hue,\n        saturation: color.saturation,\n        lightness: color.lightness,\n        alpha: color.alpha\n      });\n    }\n    return hsl({\n      hue: color.hue,\n      saturation: color.saturation,\n      lightness: color.lightness\n    });\n  }\n  throw new PolishedError(45);\n}\n\n/**\n * Inverts the red, green and blue values of a color.\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   background: invert('#CCCD64'),\n *   background: invert('rgba(101,100,205,0.7)'),\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   background: ${invert('#CCCD64')};\n *   background: ${invert('rgba(101,100,205,0.7)')};\n * `\n *\n * // CSS in JS Output\n *\n * element {\n *   background: \"#33329b\";\n *   background: \"rgba(154,155,50,0.7)\";\n * }\n */\nfunction invert(color) {\n  if (color === 'transparent') return color;\n  // parse color string to rgb\n  var value = parseToRgb(color);\n  return toColorString(_extends({}, value, {\n    red: 255 - value.red,\n    green: 255 - value.green,\n    blue: 255 - value.blue\n  }));\n}\n\n/**\n * Returns a string value for the lightened color.\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   background: lighten(0.2, '#CCCD64'),\n *   background: lighten('0.2', 'rgba(204,205,100,0.7)'),\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   background: ${lighten(0.2, '#FFCD64')};\n *   background: ${lighten('0.2', 'rgba(204,205,100,0.7)')};\n * `\n *\n * // CSS in JS Output\n *\n * element {\n *   background: \"#e5e6b1\";\n *   background: \"rgba(229,230,177,0.7)\";\n * }\n */\nfunction lighten(amount, color) {\n  if (color === 'transparent') return color;\n  var hslColor = parseToHsl(color);\n  return toColorString(_extends({}, hslColor, {\n    lightness: guard(0, 1, hslColor.lightness + parseFloat(amount))\n  }));\n}\n\n// prettier-ignore\nvar curriedLighten = curry /* ::<number | string, string, string> */(lighten);\nvar curriedLighten$1 = curriedLighten;\n\n/**\n * Determines which contrast guidelines have been met for two colors.\n * Based on the [contrast calculations recommended by W3](https://www.w3.org/WAI/WCAG21/Understanding/contrast-enhanced.html).\n *\n * @example\n * const scores = meetsContrastGuidelines('#444', '#fff');\n */\nfunction meetsContrastGuidelines(color1, color2) {\n  var contrastRatio = getContrast(color1, color2);\n  return {\n    AA: contrastRatio >= 4.5,\n    AALarge: contrastRatio >= 3,\n    AAA: contrastRatio >= 7,\n    AAALarge: contrastRatio >= 4.5\n  };\n}\n\n/**\n * Mixes the two provided colors together by calculating the average of each of the RGB components weighted to the first color by the provided weight.\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   background: mix(0.5, '#f00', '#00f')\n *   background: mix(0.25, '#f00', '#00f')\n *   background: mix('0.5', 'rgba(255, 0, 0, 0.5)', '#00f')\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   background: ${mix(0.5, '#f00', '#00f')};\n *   background: ${mix(0.25, '#f00', '#00f')};\n *   background: ${mix('0.5', 'rgba(255, 0, 0, 0.5)', '#00f')};\n * `\n *\n * // CSS in JS Output\n *\n * element {\n *   background: \"#7f007f\";\n *   background: \"#3f00bf\";\n *   background: \"rgba(63, 0, 191, 0.75)\";\n * }\n */\nfunction mix(weight, color, otherColor) {\n  if (color === 'transparent') return otherColor;\n  if (otherColor === 'transparent') return color;\n  if (weight === 0) return otherColor;\n  var parsedColor1 = parseToRgb(color);\n  var color1 = _extends({}, parsedColor1, {\n    alpha: typeof parsedColor1.alpha === 'number' ? parsedColor1.alpha : 1\n  });\n  var parsedColor2 = parseToRgb(otherColor);\n  var color2 = _extends({}, parsedColor2, {\n    alpha: typeof parsedColor2.alpha === 'number' ? parsedColor2.alpha : 1\n  });\n\n  // The formula is copied from the original Sass implementation:\n  // http://sass-lang.com/documentation/Sass/Script/Functions.html#mix-instance_method\n  var alphaDelta = color1.alpha - color2.alpha;\n  var x = parseFloat(weight) * 2 - 1;\n  var y = x * alphaDelta === -1 ? x : x + alphaDelta;\n  var z = 1 + x * alphaDelta;\n  var weight1 = (y / z + 1) / 2.0;\n  var weight2 = 1 - weight1;\n  var mixedColor = {\n    red: Math.floor(color1.red * weight1 + color2.red * weight2),\n    green: Math.floor(color1.green * weight1 + color2.green * weight2),\n    blue: Math.floor(color1.blue * weight1 + color2.blue * weight2),\n    alpha: color1.alpha * parseFloat(weight) + color2.alpha * (1 - parseFloat(weight))\n  };\n  return rgba(mixedColor);\n}\n\n// prettier-ignore\nvar curriedMix = curry /* ::<number | string, string, string, string> */(mix);\nvar mix$1 = curriedMix;\n\n/**\n * Increases the opacity of a color. Its range for the amount is between 0 to 1.\n *\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   background: opacify(0.1, 'rgba(255, 255, 255, 0.9)');\n *   background: opacify(0.2, 'hsla(0, 0%, 100%, 0.5)'),\n *   background: opacify('0.5', 'rgba(255, 0, 0, 0.2)'),\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   background: ${opacify(0.1, 'rgba(255, 255, 255, 0.9)')};\n *   background: ${opacify(0.2, 'hsla(0, 0%, 100%, 0.5)')},\n *   background: ${opacify('0.5', 'rgba(255, 0, 0, 0.2)')},\n * `\n *\n * // CSS in JS Output\n *\n * element {\n *   background: \"#fff\";\n *   background: \"rgba(255,255,255,0.7)\";\n *   background: \"rgba(255,0,0,0.7)\";\n * }\n */\nfunction opacify(amount, color) {\n  if (color === 'transparent') return color;\n  var parsedColor = parseToRgb(color);\n  var alpha = typeof parsedColor.alpha === 'number' ? parsedColor.alpha : 1;\n  var colorWithAlpha = _extends({}, parsedColor, {\n    alpha: guard(0, 1, (alpha * 100 + parseFloat(amount) * 100) / 100)\n  });\n  return rgba(colorWithAlpha);\n}\n\n// prettier-ignore\nvar curriedOpacify = curry /* ::<number | string, string, string> */(opacify);\nvar curriedOpacify$1 = curriedOpacify;\n\nvar defaultReturnIfLightColor = '#000';\nvar defaultReturnIfDarkColor = '#fff';\n\n/**\n * Returns black or white (or optional passed colors) for best\n * contrast depending on the luminosity of the given color.\n * When passing custom return colors, strict mode ensures that the\n * return color always meets or exceeds WCAG level AA or greater. If this test\n * fails, the default return color (black or white) is returned in place of the\n * custom return color. You can optionally turn off strict mode.\n *\n * Follows [W3C specs for readability](https://www.w3.org/TR/WCAG20-TECHS/G18.html).\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   color: readableColor('#000'),\n *   color: readableColor('black', '#001', '#ff8'),\n *   color: readableColor('white', '#001', '#ff8'),\n *   color: readableColor('red', '#333', '#ddd', true)\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   color: ${readableColor('#000')};\n *   color: ${readableColor('black', '#001', '#ff8')};\n *   color: ${readableColor('white', '#001', '#ff8')};\n *   color: ${readableColor('red', '#333', '#ddd', true)};\n * `\n *\n * // CSS in JS Output\n * element {\n *   color: \"#fff\";\n *   color: \"#ff8\";\n *   color: \"#001\";\n *   color: \"#000\";\n * }\n */\nfunction readableColor(color, returnIfLightColor, returnIfDarkColor, strict) {\n  if (returnIfLightColor === void 0) {\n    returnIfLightColor = defaultReturnIfLightColor;\n  }\n  if (returnIfDarkColor === void 0) {\n    returnIfDarkColor = defaultReturnIfDarkColor;\n  }\n  if (strict === void 0) {\n    strict = true;\n  }\n  var isColorLight = getLuminance(color) > 0.179;\n  var preferredReturnColor = isColorLight ? returnIfLightColor : returnIfDarkColor;\n  if (!strict || getContrast(color, preferredReturnColor) >= 4.5) {\n    return preferredReturnColor;\n  }\n  return isColorLight ? defaultReturnIfLightColor : defaultReturnIfDarkColor;\n}\n\n/**\n * Converts a RgbColor or RgbaColor object to a color string.\n * This util is useful in case you only know on runtime which color object is\n * used. Otherwise we recommend to rely on `rgb` or `rgba`.\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   background: rgbToColorString({ red: 255, green: 205, blue: 100 }),\n *   background: rgbToColorString({ red: 255, green: 205, blue: 100, alpha: 0.72 }),\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   background: ${rgbToColorString({ red: 255, green: 205, blue: 100 })};\n *   background: ${rgbToColorString({ red: 255, green: 205, blue: 100, alpha: 0.72 })};\n * `\n *\n * // CSS in JS Output\n * element {\n *   background: \"#ffcd64\";\n *   background: \"rgba(255,205,100,0.72)\";\n * }\n */\nfunction rgbToColorString(color) {\n  if (typeof color === 'object' && typeof color.red === 'number' && typeof color.green === 'number' && typeof color.blue === 'number') {\n    if (typeof color.alpha === 'number') {\n      return rgba({\n        red: color.red,\n        green: color.green,\n        blue: color.blue,\n        alpha: color.alpha\n      });\n    }\n    return rgb({\n      red: color.red,\n      green: color.green,\n      blue: color.blue\n    });\n  }\n  throw new PolishedError(46);\n}\n\n/**\n * Increases the intensity of a color. Its range is between 0 to 1. The first\n * argument of the saturate function is the amount by how much the color\n * intensity should be increased.\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   background: saturate(0.2, '#CCCD64'),\n *   background: saturate('0.2', 'rgba(204,205,100,0.7)'),\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   background: ${saturate(0.2, '#FFCD64')};\n *   background: ${saturate('0.2', 'rgba(204,205,100,0.7)')};\n * `\n *\n * // CSS in JS Output\n *\n * element {\n *   background: \"#e0e250\";\n *   background: \"rgba(224,226,80,0.7)\";\n * }\n */\nfunction saturate(amount, color) {\n  if (color === 'transparent') return color;\n  var hslColor = parseToHsl(color);\n  return toColorString(_extends({}, hslColor, {\n    saturation: guard(0, 1, hslColor.saturation + parseFloat(amount))\n  }));\n}\n\n// prettier-ignore\nvar curriedSaturate = curry /* ::<number | string, string, string> */(saturate);\nvar curriedSaturate$1 = curriedSaturate;\n\n/**\n * Sets the hue of a color to the provided value. The hue range can be\n * from 0 and 359.\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   background: setHue(42, '#CCCD64'),\n *   background: setHue('244', 'rgba(204,205,100,0.7)'),\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   background: ${setHue(42, '#CCCD64')};\n *   background: ${setHue('244', 'rgba(204,205,100,0.7)')};\n * `\n *\n * // CSS in JS Output\n * element {\n *   background: \"#cdae64\";\n *   background: \"rgba(107,100,205,0.7)\";\n * }\n */\nfunction setHue(hue, color) {\n  if (color === 'transparent') return color;\n  return toColorString(_extends({}, parseToHsl(color), {\n    hue: parseFloat(hue)\n  }));\n}\n\n// prettier-ignore\nvar curriedSetHue = curry /* ::<number | string, string, string> */(setHue);\nvar curriedSetHue$1 = curriedSetHue;\n\n/**\n * Sets the lightness of a color to the provided value. The lightness range can be\n * from 0 and 1.\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   background: setLightness(0.2, '#CCCD64'),\n *   background: setLightness('0.75', 'rgba(204,205,100,0.7)'),\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   background: ${setLightness(0.2, '#CCCD64')};\n *   background: ${setLightness('0.75', 'rgba(204,205,100,0.7)')};\n * `\n *\n * // CSS in JS Output\n * element {\n *   background: \"#4d4d19\";\n *   background: \"rgba(223,224,159,0.7)\";\n * }\n */\nfunction setLightness(lightness, color) {\n  if (color === 'transparent') return color;\n  return toColorString(_extends({}, parseToHsl(color), {\n    lightness: parseFloat(lightness)\n  }));\n}\n\n// prettier-ignore\nvar curriedSetLightness = curry /* ::<number | string, string, string> */(setLightness);\nvar curriedSetLightness$1 = curriedSetLightness;\n\n/**\n * Sets the saturation of a color to the provided value. The saturation range can be\n * from 0 and 1.\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   background: setSaturation(0.2, '#CCCD64'),\n *   background: setSaturation('0.75', 'rgba(204,205,100,0.7)'),\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   background: ${setSaturation(0.2, '#CCCD64')};\n *   background: ${setSaturation('0.75', 'rgba(204,205,100,0.7)')};\n * `\n *\n * // CSS in JS Output\n * element {\n *   background: \"#adad84\";\n *   background: \"rgba(228,229,76,0.7)\";\n * }\n */\nfunction setSaturation(saturation, color) {\n  if (color === 'transparent') return color;\n  return toColorString(_extends({}, parseToHsl(color), {\n    saturation: parseFloat(saturation)\n  }));\n}\n\n// prettier-ignore\nvar curriedSetSaturation = curry /* ::<number | string, string, string> */(setSaturation);\nvar curriedSetSaturation$1 = curriedSetSaturation;\n\n/**\n * Shades a color by mixing it with black. `shade` can produce\n * hue shifts, where as `darken` manipulates the luminance channel and therefore\n * doesn't produce hue shifts.\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   background: shade(0.25, '#00f')\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   background: ${shade(0.25, '#00f')};\n * `\n *\n * // CSS in JS Output\n *\n * element {\n *   background: \"#00003f\";\n * }\n */\n\nfunction shade(percentage, color) {\n  if (color === 'transparent') return color;\n  return mix$1(parseFloat(percentage), 'rgb(0, 0, 0)', color);\n}\n\n// prettier-ignore\nvar curriedShade = curry /* ::<number | string, string, string> */(shade);\nvar curriedShade$1 = curriedShade;\n\n/**\n * Tints a color by mixing it with white. `tint` can produce\n * hue shifts, where as `lighten` manipulates the luminance channel and therefore\n * doesn't produce hue shifts.\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   background: tint(0.25, '#00f')\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   background: ${tint(0.25, '#00f')};\n * `\n *\n * // CSS in JS Output\n *\n * element {\n *   background: \"#bfbfff\";\n * }\n */\n\nfunction tint(percentage, color) {\n  if (color === 'transparent') return color;\n  return mix$1(parseFloat(percentage), 'rgb(255, 255, 255)', color);\n}\n\n// prettier-ignore\nvar curriedTint = curry /* ::<number | string, string, string> */(tint);\nvar curriedTint$1 = curriedTint;\n\n/**\n * Decreases the opacity of a color. Its range for the amount is between 0 to 1.\n *\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   background: transparentize(0.1, '#fff'),\n *   background: transparentize(0.2, 'hsl(0, 0%, 100%)'),\n *   background: transparentize('0.5', 'rgba(255, 0, 0, 0.8)'),\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   background: ${transparentize(0.1, '#fff')};\n *   background: ${transparentize(0.2, 'hsl(0, 0%, 100%)')};\n *   background: ${transparentize('0.5', 'rgba(255, 0, 0, 0.8)')};\n * `\n *\n * // CSS in JS Output\n *\n * element {\n *   background: \"rgba(255,255,255,0.9)\";\n *   background: \"rgba(255,255,255,0.8)\";\n *   background: \"rgba(255,0,0,0.3)\";\n * }\n */\nfunction transparentize(amount, color) {\n  if (color === 'transparent') return color;\n  var parsedColor = parseToRgb(color);\n  var alpha = typeof parsedColor.alpha === 'number' ? parsedColor.alpha : 1;\n  var colorWithAlpha = _extends({}, parsedColor, {\n    alpha: guard(0, 1, +(alpha * 100 - parseFloat(amount) * 100).toFixed(2) / 100)\n  });\n  return rgba(colorWithAlpha);\n}\n\n// prettier-ignore\nvar curriedTransparentize = curry /* ::<number | string, string, string> */(transparentize);\nvar curriedTransparentize$1 = curriedTransparentize;\n\n/**\n * Shorthand for easily setting the animation property. Allows either multiple arrays with animations\n * or a single animation spread over the arguments.\n * @example\n * // Styles as object usage\n * const styles = {\n *   ...animation(['rotate', '1s', 'ease-in-out'], ['colorchange', '2s'])\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   ${animation(['rotate', '1s', 'ease-in-out'], ['colorchange', '2s'])}\n * `\n *\n * // CSS as JS Output\n *\n * div {\n *   'animation': 'rotate 1s ease-in-out, colorchange 2s'\n * }\n * @example\n * // Styles as object usage\n * const styles = {\n *   ...animation('rotate', '1s', 'ease-in-out')\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   ${animation('rotate', '1s', 'ease-in-out')}\n * `\n *\n * // CSS as JS Output\n *\n * div {\n *   'animation': 'rotate 1s ease-in-out'\n * }\n */\nfunction animation() {\n  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n    args[_key] = arguments[_key];\n  }\n  // Allow single or multiple animations passed\n  var multiMode = Array.isArray(args[0]);\n  if (!multiMode && args.length > 8) {\n    throw new PolishedError(64);\n  }\n  var code = args.map(function (arg) {\n    if (multiMode && !Array.isArray(arg) || !multiMode && Array.isArray(arg)) {\n      throw new PolishedError(65);\n    }\n    if (Array.isArray(arg) && arg.length > 8) {\n      throw new PolishedError(66);\n    }\n    return Array.isArray(arg) ? arg.join(' ') : arg;\n  }).join(', ');\n  return {\n    animation: code\n  };\n}\n\n/**\n * Shorthand that accepts any number of backgroundImage values as parameters for creating a single background statement.\n * @example\n * // Styles as object usage\n * const styles = {\n *   ...backgroundImages('url(\"/image/background.jpg\")', 'linear-gradient(red, green)')\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   ${backgroundImages('url(\"/image/background.jpg\")', 'linear-gradient(red, green)')}\n * `\n *\n * // CSS as JS Output\n *\n * div {\n *   'backgroundImage': 'url(\"/image/background.jpg\"), linear-gradient(red, green)'\n * }\n */\nfunction backgroundImages() {\n  for (var _len = arguments.length, properties = new Array(_len), _key = 0; _key < _len; _key++) {\n    properties[_key] = arguments[_key];\n  }\n  return {\n    backgroundImage: properties.join(', ')\n  };\n}\n\n/**\n * Shorthand that accepts any number of background values as parameters for creating a single background statement.\n * @example\n * // Styles as object usage\n * const styles = {\n *   ...backgrounds('url(\"/image/background.jpg\")', 'linear-gradient(red, green)', 'center no-repeat')\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   ${backgrounds('url(\"/image/background.jpg\")', 'linear-gradient(red, green)', 'center no-repeat')}\n * `\n *\n * // CSS as JS Output\n *\n * div {\n *   'background': 'url(\"/image/background.jpg\"), linear-gradient(red, green), center no-repeat'\n * }\n */\nfunction backgrounds() {\n  for (var _len = arguments.length, properties = new Array(_len), _key = 0; _key < _len; _key++) {\n    properties[_key] = arguments[_key];\n  }\n  return {\n    background: properties.join(', ')\n  };\n}\n\nvar sideMap = ['top', 'right', 'bottom', 'left'];\n\n/**\n * Shorthand for the border property that splits out individual properties for use with tools like Fela and Styletron. A side keyword can optionally be passed to target only one side's border properties.\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   ...border('1px', 'solid', 'red')\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   ${border('1px', 'solid', 'red')}\n * `\n *\n * // CSS as JS Output\n *\n * div {\n *   'borderColor': 'red',\n *   'borderStyle': 'solid',\n *   'borderWidth': `1px`,\n * }\n *\n * // Styles as object usage\n * const styles = {\n *   ...border('top', '1px', 'solid', 'red')\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   ${border('top', '1px', 'solid', 'red')}\n * `\n *\n * // CSS as JS Output\n *\n * div {\n *   'borderTopColor': 'red',\n *   'borderTopStyle': 'solid',\n *   'borderTopWidth': `1px`,\n * }\n */\n\nfunction border(sideKeyword) {\n  for (var _len = arguments.length, values = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    values[_key - 1] = arguments[_key];\n  }\n  if (typeof sideKeyword === 'string' && sideMap.indexOf(sideKeyword) >= 0) {\n    var _ref;\n    return _ref = {}, _ref[\"border\" + capitalizeString(sideKeyword) + \"Width\"] = values[0], _ref[\"border\" + capitalizeString(sideKeyword) + \"Style\"] = values[1], _ref[\"border\" + capitalizeString(sideKeyword) + \"Color\"] = values[2], _ref;\n  } else {\n    values.unshift(sideKeyword);\n    return {\n      borderWidth: values[0],\n      borderStyle: values[1],\n      borderColor: values[2]\n    };\n  }\n}\n\n/**\n * Shorthand that accepts up to four values, including null to skip a value, and maps them to their respective directions.\n * @example\n * // Styles as object usage\n * const styles = {\n *   ...borderColor('red', 'green', 'blue', 'yellow')\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   ${borderColor('red', 'green', 'blue', 'yellow')}\n * `\n *\n * // CSS as JS Output\n *\n * div {\n *   'borderTopColor': 'red',\n *   'borderRightColor': 'green',\n *   'borderBottomColor': 'blue',\n *   'borderLeftColor': 'yellow'\n * }\n */\nfunction borderColor() {\n  for (var _len = arguments.length, values = new Array(_len), _key = 0; _key < _len; _key++) {\n    values[_key] = arguments[_key];\n  }\n  return directionalProperty.apply(void 0, ['borderColor'].concat(values));\n}\n\n/**\n * Shorthand that accepts a value for side and a value for radius and applies the radius value to both corners of the side.\n * @example\n * // Styles as object usage\n * const styles = {\n *   ...borderRadius('top', '5px')\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   ${borderRadius('top', '5px')}\n * `\n *\n * // CSS as JS Output\n *\n * div {\n *   'borderTopRightRadius': '5px',\n *   'borderTopLeftRadius': '5px',\n * }\n */\nfunction borderRadius(side, radius) {\n  var uppercaseSide = capitalizeString(side);\n  if (!radius && radius !== 0) {\n    throw new PolishedError(62);\n  }\n  if (uppercaseSide === 'Top' || uppercaseSide === 'Bottom') {\n    var _ref;\n    return _ref = {}, _ref[\"border\" + uppercaseSide + \"RightRadius\"] = radius, _ref[\"border\" + uppercaseSide + \"LeftRadius\"] = radius, _ref;\n  }\n  if (uppercaseSide === 'Left' || uppercaseSide === 'Right') {\n    var _ref2;\n    return _ref2 = {}, _ref2[\"borderTop\" + uppercaseSide + \"Radius\"] = radius, _ref2[\"borderBottom\" + uppercaseSide + \"Radius\"] = radius, _ref2;\n  }\n  throw new PolishedError(63);\n}\n\n/**\n * Shorthand that accepts up to four values, including null to skip a value, and maps them to their respective directions.\n * @example\n * // Styles as object usage\n * const styles = {\n *   ...borderStyle('solid', 'dashed', 'dotted', 'double')\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   ${borderStyle('solid', 'dashed', 'dotted', 'double')}\n * `\n *\n * // CSS as JS Output\n *\n * div {\n *   'borderTopStyle': 'solid',\n *   'borderRightStyle': 'dashed',\n *   'borderBottomStyle': 'dotted',\n *   'borderLeftStyle': 'double'\n * }\n */\nfunction borderStyle() {\n  for (var _len = arguments.length, values = new Array(_len), _key = 0; _key < _len; _key++) {\n    values[_key] = arguments[_key];\n  }\n  return directionalProperty.apply(void 0, ['borderStyle'].concat(values));\n}\n\n/**\n * Shorthand that accepts up to four values, including null to skip a value, and maps them to their respective directions.\n * @example\n * // Styles as object usage\n * const styles = {\n *   ...borderWidth('12px', '24px', '36px', '48px')\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   ${borderWidth('12px', '24px', '36px', '48px')}\n * `\n *\n * // CSS as JS Output\n *\n * div {\n *   'borderTopWidth': '12px',\n *   'borderRightWidth': '24px',\n *   'borderBottomWidth': '36px',\n *   'borderLeftWidth': '48px'\n * }\n */\nfunction borderWidth() {\n  for (var _len = arguments.length, values = new Array(_len), _key = 0; _key < _len; _key++) {\n    values[_key] = arguments[_key];\n  }\n  return directionalProperty.apply(void 0, ['borderWidth'].concat(values));\n}\n\nfunction generateSelectors(template, state) {\n  var stateSuffix = state ? \":\" + state : '';\n  return template(stateSuffix);\n}\n\n/**\n * Function helper that adds an array of states to a template of selectors. Used in textInputs and buttons.\n * @private\n */\nfunction statefulSelectors(states, template, stateMap) {\n  if (!template) throw new PolishedError(67);\n  if (states.length === 0) return generateSelectors(template, null);\n  var selectors = [];\n  for (var i = 0; i < states.length; i += 1) {\n    if (stateMap && stateMap.indexOf(states[i]) < 0) {\n      throw new PolishedError(68);\n    }\n    selectors.push(generateSelectors(template, states[i]));\n  }\n  selectors = selectors.join(',');\n  return selectors;\n}\n\nvar stateMap$1 = [undefined, null, 'active', 'focus', 'hover'];\nfunction template$1(state) {\n  return \"button\" + state + \",\\n  input[type=\\\"button\\\"]\" + state + \",\\n  input[type=\\\"reset\\\"]\" + state + \",\\n  input[type=\\\"submit\\\"]\" + state;\n}\n\n/**\n * Populates selectors that target all buttons. You can pass optional states to append to the selectors.\n * @example\n * // Styles as object usage\n * const styles = {\n *   [buttons('active')]: {\n *     'border': 'none'\n *   }\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   > ${buttons('active')} {\n *     border: none;\n *   }\n * `\n *\n * // CSS in JS Output\n *\n *  'button:active,\n *  'input[type=\"button\"]:active,\n *  'input[type=\\\"reset\\\"]:active,\n *  'input[type=\\\"submit\\\"]:active: {\n *   'border': 'none'\n * }\n */\nfunction buttons() {\n  for (var _len = arguments.length, states = new Array(_len), _key = 0; _key < _len; _key++) {\n    states[_key] = arguments[_key];\n  }\n  return statefulSelectors(states, template$1, stateMap$1);\n}\n\n/**\n * Shorthand that accepts up to four values, including null to skip a value, and maps them to their respective directions.\n * @example\n * // Styles as object usage\n * const styles = {\n *   ...margin('12px', '24px', '36px', '48px')\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   ${margin('12px', '24px', '36px', '48px')}\n * `\n *\n * // CSS as JS Output\n *\n * div {\n *   'marginTop': '12px',\n *   'marginRight': '24px',\n *   'marginBottom': '36px',\n *   'marginLeft': '48px'\n * }\n */\nfunction margin() {\n  for (var _len = arguments.length, values = new Array(_len), _key = 0; _key < _len; _key++) {\n    values[_key] = arguments[_key];\n  }\n  return directionalProperty.apply(void 0, ['margin'].concat(values));\n}\n\n/**\n * Shorthand that accepts up to four values, including null to skip a value, and maps them to their respective directions.\n * @example\n * // Styles as object usage\n * const styles = {\n *   ...padding('12px', '24px', '36px', '48px')\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   ${padding('12px', '24px', '36px', '48px')}\n * `\n *\n * // CSS as JS Output\n *\n * div {\n *   'paddingTop': '12px',\n *   'paddingRight': '24px',\n *   'paddingBottom': '36px',\n *   'paddingLeft': '48px'\n * }\n */\nfunction padding() {\n  for (var _len = arguments.length, values = new Array(_len), _key = 0; _key < _len; _key++) {\n    values[_key] = arguments[_key];\n  }\n  return directionalProperty.apply(void 0, ['padding'].concat(values));\n}\n\nvar positionMap = ['absolute', 'fixed', 'relative', 'static', 'sticky'];\n\n/**\n * Shorthand accepts up to five values, including null to skip a value, and maps them to their respective directions. The first value can optionally be a position keyword.\n * @example\n * // Styles as object usage\n * const styles = {\n *   ...position('12px', '24px', '36px', '48px')\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   ${position('12px', '24px', '36px', '48px')}\n * `\n *\n * // CSS as JS Output\n *\n * div {\n *   'top': '12px',\n *   'right': '24px',\n *   'bottom': '36px',\n *   'left': '48px'\n * }\n *\n * // Styles as object usage\n * const styles = {\n *   ...position('absolute', '12px', '24px', '36px', '48px')\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   ${position('absolute', '12px', '24px', '36px', '48px')}\n * `\n *\n * // CSS as JS Output\n *\n * div {\n *   'position': 'absolute',\n *   'top': '12px',\n *   'right': '24px',\n *   'bottom': '36px',\n *   'left': '48px'\n * }\n */\nfunction position(firstValue) {\n  for (var _len = arguments.length, values = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    values[_key - 1] = arguments[_key];\n  }\n  if (positionMap.indexOf(firstValue) >= 0 && firstValue) {\n    return _extends({}, directionalProperty.apply(void 0, [''].concat(values)), {\n      position: firstValue\n    });\n  } else {\n    return directionalProperty.apply(void 0, ['', firstValue].concat(values));\n  }\n}\n\n/**\n * Shorthand to set the height and width properties in a single statement.\n * @example\n * // Styles as object usage\n * const styles = {\n *   ...size('300px', '250px')\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   ${size('300px', '250px')}\n * `\n *\n * // CSS as JS Output\n *\n * div {\n *   'height': '300px',\n *   'width': '250px',\n * }\n */\nfunction size(height, width) {\n  if (width === void 0) {\n    width = height;\n  }\n  return {\n    height: height,\n    width: width\n  };\n}\n\nvar stateMap = [undefined, null, 'active', 'focus', 'hover'];\nfunction template(state) {\n  return \"input[type=\\\"color\\\"]\" + state + \",\\n    input[type=\\\"date\\\"]\" + state + \",\\n    input[type=\\\"datetime\\\"]\" + state + \",\\n    input[type=\\\"datetime-local\\\"]\" + state + \",\\n    input[type=\\\"email\\\"]\" + state + \",\\n    input[type=\\\"month\\\"]\" + state + \",\\n    input[type=\\\"number\\\"]\" + state + \",\\n    input[type=\\\"password\\\"]\" + state + \",\\n    input[type=\\\"search\\\"]\" + state + \",\\n    input[type=\\\"tel\\\"]\" + state + \",\\n    input[type=\\\"text\\\"]\" + state + \",\\n    input[type=\\\"time\\\"]\" + state + \",\\n    input[type=\\\"url\\\"]\" + state + \",\\n    input[type=\\\"week\\\"]\" + state + \",\\n    input:not([type])\" + state + \",\\n    textarea\" + state;\n}\n\n/**\n * Populates selectors that target all text inputs. You can pass optional states to append to the selectors.\n * @example\n * // Styles as object usage\n * const styles = {\n *   [textInputs('active')]: {\n *     'border': 'none'\n *   }\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   > ${textInputs('active')} {\n *     border: none;\n *   }\n * `\n *\n * // CSS in JS Output\n *\n *  'input[type=\"color\"]:active,\n *  input[type=\"date\"]:active,\n *  input[type=\"datetime\"]:active,\n *  input[type=\"datetime-local\"]:active,\n *  input[type=\"email\"]:active,\n *  input[type=\"month\"]:active,\n *  input[type=\"number\"]:active,\n *  input[type=\"password\"]:active,\n *  input[type=\"search\"]:active,\n *  input[type=\"tel\"]:active,\n *  input[type=\"text\"]:active,\n *  input[type=\"time\"]:active,\n *  input[type=\"url\"]:active,\n *  input[type=\"week\"]:active,\n *  input:not([type]):active,\n *  textarea:active': {\n *   'border': 'none'\n * }\n */\nfunction textInputs() {\n  for (var _len = arguments.length, states = new Array(_len), _key = 0; _key < _len; _key++) {\n    states[_key] = arguments[_key];\n  }\n  return statefulSelectors(states, template, stateMap);\n}\n\n/**\n * Accepts any number of transition values as parameters for creating a single transition statement. You may also pass an array of properties as the first parameter that you would like to apply the same transition values to (second parameter).\n * @example\n * // Styles as object usage\n * const styles = {\n *   ...transitions('opacity 1.0s ease-in 0s', 'width 2.0s ease-in 2s'),\n *   ...transitions(['color', 'background-color'], '2.0s ease-in 2s')\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   ${transitions('opacity 1.0s ease-in 0s', 'width 2.0s ease-in 2s')};\n *   ${transitions(['color', 'background-color'], '2.0s ease-in 2s'),};\n * `\n *\n * // CSS as JS Output\n *\n * div {\n *   'transition': 'opacity 1.0s ease-in 0s, width 2.0s ease-in 2s'\n *   'transition': 'color 2.0s ease-in 2s, background-color 2.0s ease-in 2s',\n * }\n */\nfunction transitions() {\n  for (var _len = arguments.length, properties = new Array(_len), _key = 0; _key < _len; _key++) {\n    properties[_key] = arguments[_key];\n  }\n  if (Array.isArray(properties[0]) && properties.length === 2) {\n    var value = properties[1];\n    if (typeof value !== 'string') {\n      throw new PolishedError(61);\n    }\n    var transitionsString = properties[0].map(function (property) {\n      return property + \" \" + value;\n    }).join(', ');\n    return {\n      transition: transitionsString\n    };\n  } else {\n    return {\n      transition: properties.join(', ')\n    };\n  }\n}\n\nexport { curriedAdjustHue$1 as adjustHue, animation, backgroundImages, backgrounds, between, border, borderColor, borderRadius, borderStyle, borderWidth, buttons, clearFix, complement, cover, cssVar, curriedDarken$1 as darken, curriedDesaturate$1 as desaturate, directionalProperty, easeIn, easeInOut, easeOut, ellipsis, em$1 as em, fluidRange, fontFace, getContrast, getLuminance, getValueAndUnit, grayscale, hiDPI, hideText, hideVisually, hsl, hslToColorString, hsla, important, invert, curriedLighten$1 as lighten, linearGradient, margin, math, meetsContrastGuidelines, mix$1 as mix, modularScale, normalize, curriedOpacify$1 as opacify, padding, parseToHsl, parseToRgb, position, radialGradient, readableColor, rem$1 as rem, remToPx, retinaImage, rgb, rgbToColorString, rgba, curriedSaturate$1 as saturate, curriedSetHue$1 as setHue, curriedSetLightness$1 as setLightness, curriedSetSaturation$1 as setSaturation, curriedShade$1 as shade, size, stripUnit, textInputs, timingFunctions, curriedTint$1 as tint, toColorString, transitions, curriedTransparentize$1 as transparentize, triangle, wordWrap };\n","import { ConnectivityMap } from \"circuit-json-to-connectivity-map\"\nimport type { SimpleRouteJson } from \"../types\"\nimport { transparentize } from \"polished\"\n\nexport const COLORS = [\n  \"blue\",\n  \"orange\",\n  \"purple\",\n  \"cyan\",\n  \"magenta\",\n  \"yellowgreen\",\n  \"darkgoldenrod\",\n  \"deeppink\",\n]\n\nexport const getColorMap = (\n  srj: SimpleRouteJson,\n  connMap?: ConnectivityMap,\n) => {\n  const colorMap: Record<string, string> = {}\n  for (let i = 0; i < srj.connections.length; i++) {\n    const connection = srj.connections[i]\n    const netName = connMap?.getNetConnectedToId(connection.name)\n\n    if (netName && !colorMap[netName]) {\n      colorMap[netName] =\n        `hsl(${(i * 300) / srj.connections.length}, 100%, 50%)`\n    }\n\n    colorMap[connection.name] =\n      (netName ? colorMap[netName] : null) ??\n      `hsl(${(i * 340) / srj.connections.length}, 100%, 50%)`\n  }\n  return colorMap\n}\n\nexport const safeTransparentize = (color: string, amount: number) => {\n  try {\n    return transparentize(amount, color)\n  } catch (e) {\n    console.error(e)\n    return color\n  }\n}\n\nexport const createColorMapFromStrings = (strings: string[]) => {\n  const colorMap: Record<string, string> = {}\n  for (let i = 0; i < strings.length; i++) {\n    colorMap[strings[i]] = `hsl(${(i * 300) / strings.length}, 100%, 50%)`\n  }\n  return colorMap\n}\n","export const mapLayerNameToZ = (layerName: string, layerCount: number) => {\n  if (layerName === \"top\") return 0\n  if (layerName === \"bottom\") return layerCount - 1\n  return parseInt(layerName.slice(5))\n}\n","import { CapacityMeshNode } from \"lib/types/capacity-mesh-types\"\n\n/**\n * Calculate the capacity of a node based on its width\n *\n * This capacity corresponds to how many vias the node can fit, tuned for two\n * layers.\n *\n * @param nodeOrWidth The node or width to calculate capacity for\n * @param maxCapacityFactor Optional multiplier to adjust capacity\n * @returns The calculated capacity\n */\nexport const getTunedTotalCapacity1 = (\n  nodeOrWidth: CapacityMeshNode | { width: number; availableZ?: number[] },\n  maxCapacityFactor = 1,\n) => {\n  const VIA_DIAMETER = 0.6\n  const TRACE_WIDTH = 0.15\n  const obstacleMargin = 0.2\n\n  const width = \"width\" in nodeOrWidth ? nodeOrWidth.width : nodeOrWidth\n  const viaLengthAcross = width / (VIA_DIAMETER / 2 + obstacleMargin)\n\n  const tunedTotalCapacity = (viaLengthAcross / 2) ** 1.1 * maxCapacityFactor\n\n  if (nodeOrWidth.availableZ?.length === 1 && tunedTotalCapacity > 1) {\n    return 1\n  }\n\n  return tunedTotalCapacity\n}\n\n/**\n * Calculate the optimal subdivision depth to reach a target minimum capacity\n * @param initialWidth The initial width of the top-level node\n * @param targetMinCapacity The minimum capacity target (default 0.5)\n * @param maxDepth Maximum allowed depth (default 10)\n * @returns The optimal capacity depth\n */\nexport const calculateOptimalCapacityDepth = (\n  initialWidth: number,\n  targetMinCapacity = 0.5,\n  maxDepth = 16,\n): number => {\n  let depth = 0\n  let width = initialWidth\n\n  // Calculate capacity at each subdivision level until we reach target or max depth\n  while (depth < maxDepth) {\n    const capacity = getTunedTotalCapacity1({ width })\n\n    // If capacity is below target, we've gone far enough\n    if (capacity <= targetMinCapacity) {\n      break\n    }\n\n    // Move to next subdivision level (each level divides width by 2)\n    width /= 2\n    depth++\n  }\n\n  // Return depth + 1 to account for the fact that we want to subdivide\n  // until the smallest nodes have capacity <= targetMinCapacity\n  return Math.max(1, depth)\n}\n","\n/**\n * Rearranges items so that all items in the [left, k] are the smallest.\n * The k-th element will have the (k - left + 1)-th smallest value in [left, right].\n *\n * @template T\n * @param {T[]} arr the array to partially sort (in place)\n * @param {number} k middle index for partial sorting (as defined above)\n * @param {number} [left=0] left index of the range to sort\n * @param {number} [right=arr.length-1] right index\n * @param {(a: T, b: T) => number} [compare = (a, b) => a - b] compare function\n */\nexport default function quickselect(arr, k, left = 0, right = arr.length - 1, compare = defaultCompare) {\n\n    while (right > left) {\n        if (right - left > 600) {\n            const n = right - left + 1;\n            const m = k - left + 1;\n            const z = Math.log(n);\n            const s = 0.5 * Math.exp(2 * z / 3);\n            const sd = 0.5 * Math.sqrt(z * s * (n - s) / n) * (m - n / 2 < 0 ? -1 : 1);\n            const newLeft = Math.max(left, Math.floor(k - m * s / n + sd));\n            const newRight = Math.min(right, Math.floor(k + (n - m) * s / n + sd));\n            quickselect(arr, k, newLeft, newRight, compare);\n        }\n\n        const t = arr[k];\n        let i = left;\n        /** @type {number} */\n        let j = right;\n\n        swap(arr, left, k);\n        if (compare(arr[right], t) > 0) swap(arr, left, right);\n\n        while (i < j) {\n            swap(arr, i, j);\n            i++;\n            j--;\n            while (compare(arr[i], t) < 0) i++;\n            while (compare(arr[j], t) > 0) j--;\n        }\n\n        if (compare(arr[left], t) === 0) swap(arr, left, j);\n        else {\n            j++;\n            swap(arr, j, right);\n        }\n\n        if (j <= k) left = j + 1;\n        if (k <= j) right = j - 1;\n    }\n}\n\n/**\n * @template T\n * @param {T[]} arr\n * @param {number} i\n * @param {number} j\n */\nfunction swap(arr, i, j) {\n    const tmp = arr[i];\n    arr[i] = arr[j];\n    arr[j] = tmp;\n}\n\n/**\n * @template T\n * @param {T} a\n * @param {T} b\n * @returns {number}\n */\nfunction defaultCompare(a, b) {\n    return a < b ? -1 : a > b ? 1 : 0;\n}\n","import quickselect from 'quickselect';\n\nexport default class RBush {\n    constructor(maxEntries = 9) {\n        // max entries in a node is 9 by default; min node fill is 40% for best performance\n        this._maxEntries = Math.max(4, maxEntries);\n        this._minEntries = Math.max(2, Math.ceil(this._maxEntries * 0.4));\n        this.clear();\n    }\n\n    all() {\n        return this._all(this.data, []);\n    }\n\n    search(bbox) {\n        let node = this.data;\n        const result = [];\n\n        if (!intersects(bbox, node)) return result;\n\n        const toBBox = this.toBBox;\n        const nodesToSearch = [];\n\n        while (node) {\n            for (let i = 0; i < node.children.length; i++) {\n                const child = node.children[i];\n                const childBBox = node.leaf ? toBBox(child) : child;\n\n                if (intersects(bbox, childBBox)) {\n                    if (node.leaf) result.push(child);\n                    else if (contains(bbox, childBBox)) this._all(child, result);\n                    else nodesToSearch.push(child);\n                }\n            }\n            node = nodesToSearch.pop();\n        }\n\n        return result;\n    }\n\n    collides(bbox) {\n        let node = this.data;\n\n        if (!intersects(bbox, node)) return false;\n\n        const nodesToSearch = [];\n        while (node) {\n            for (let i = 0; i < node.children.length; i++) {\n                const child = node.children[i];\n                const childBBox = node.leaf ? this.toBBox(child) : child;\n\n                if (intersects(bbox, childBBox)) {\n                    if (node.leaf || contains(bbox, childBBox)) return true;\n                    nodesToSearch.push(child);\n                }\n            }\n            node = nodesToSearch.pop();\n        }\n\n        return false;\n    }\n\n    load(data) {\n        if (!(data && data.length)) return this;\n\n        if (data.length < this._minEntries) {\n            for (let i = 0; i < data.length; i++) {\n                this.insert(data[i]);\n            }\n            return this;\n        }\n\n        // recursively build the tree with the given data from scratch using OMT algorithm\n        let node = this._build(data.slice(), 0, data.length - 1, 0);\n\n        if (!this.data.children.length) {\n            // save as is if tree is empty\n            this.data = node;\n\n        } else if (this.data.height === node.height) {\n            // split root if trees have the same height\n            this._splitRoot(this.data, node);\n\n        } else {\n            if (this.data.height < node.height) {\n                // swap trees if inserted one is bigger\n                const tmpNode = this.data;\n                this.data = node;\n                node = tmpNode;\n            }\n\n            // insert the small tree into the large tree at appropriate level\n            this._insert(node, this.data.height - node.height - 1, true);\n        }\n\n        return this;\n    }\n\n    insert(item) {\n        if (item) this._insert(item, this.data.height - 1);\n        return this;\n    }\n\n    clear() {\n        this.data = createNode([]);\n        return this;\n    }\n\n    remove(item, equalsFn) {\n        if (!item) return this;\n\n        let node = this.data;\n        const bbox = this.toBBox(item);\n        const path = [];\n        const indexes = [];\n        let i, parent, goingUp;\n\n        // depth-first iterative tree traversal\n        while (node || path.length) {\n\n            if (!node) { // go up\n                node = path.pop();\n                parent = path[path.length - 1];\n                i = indexes.pop();\n                goingUp = true;\n            }\n\n            if (node.leaf) { // check current node\n                const index = findItem(item, node.children, equalsFn);\n\n                if (index !== -1) {\n                    // item found, remove the item and condense tree upwards\n                    node.children.splice(index, 1);\n                    path.push(node);\n                    this._condense(path);\n                    return this;\n                }\n            }\n\n            if (!goingUp && !node.leaf && contains(node, bbox)) { // go down\n                path.push(node);\n                indexes.push(i);\n                i = 0;\n                parent = node;\n                node = node.children[0];\n\n            } else if (parent) { // go right\n                i++;\n                node = parent.children[i];\n                goingUp = false;\n\n            } else node = null; // nothing found\n        }\n\n        return this;\n    }\n\n    toBBox(item) { return item; }\n\n    compareMinX(a, b) { return a.minX - b.minX; }\n    compareMinY(a, b) { return a.minY - b.minY; }\n\n    toJSON() { return this.data; }\n\n    fromJSON(data) {\n        this.data = data;\n        return this;\n    }\n\n    _all(node, result) {\n        const nodesToSearch = [];\n        while (node) {\n            if (node.leaf) result.push(...node.children);\n            else nodesToSearch.push(...node.children);\n\n            node = nodesToSearch.pop();\n        }\n        return result;\n    }\n\n    _build(items, left, right, height) {\n\n        const N = right - left + 1;\n        let M = this._maxEntries;\n        let node;\n\n        if (N <= M) {\n            // reached leaf level; return leaf\n            node = createNode(items.slice(left, right + 1));\n            calcBBox(node, this.toBBox);\n            return node;\n        }\n\n        if (!height) {\n            // target height of the bulk-loaded tree\n            height = Math.ceil(Math.log(N) / Math.log(M));\n\n            // target number of root entries to maximize storage utilization\n            M = Math.ceil(N / Math.pow(M, height - 1));\n        }\n\n        node = createNode([]);\n        node.leaf = false;\n        node.height = height;\n\n        // split the items into M mostly square tiles\n\n        const N2 = Math.ceil(N / M);\n        const N1 = N2 * Math.ceil(Math.sqrt(M));\n\n        multiSelect(items, left, right, N1, this.compareMinX);\n\n        for (let i = left; i <= right; i += N1) {\n\n            const right2 = Math.min(i + N1 - 1, right);\n\n            multiSelect(items, i, right2, N2, this.compareMinY);\n\n            for (let j = i; j <= right2; j += N2) {\n\n                const right3 = Math.min(j + N2 - 1, right2);\n\n                // pack each entry recursively\n                node.children.push(this._build(items, j, right3, height - 1));\n            }\n        }\n\n        calcBBox(node, this.toBBox);\n\n        return node;\n    }\n\n    _chooseSubtree(bbox, node, level, path) {\n        while (true) {\n            path.push(node);\n\n            if (node.leaf || path.length - 1 === level) break;\n\n            let minArea = Infinity;\n            let minEnlargement = Infinity;\n            let targetNode;\n\n            for (let i = 0; i < node.children.length; i++) {\n                const child = node.children[i];\n                const area = bboxArea(child);\n                const enlargement = enlargedArea(bbox, child) - area;\n\n                // choose entry with the least area enlargement\n                if (enlargement < minEnlargement) {\n                    minEnlargement = enlargement;\n                    minArea = area < minArea ? area : minArea;\n                    targetNode = child;\n\n                } else if (enlargement === minEnlargement) {\n                    // otherwise choose one with the smallest area\n                    if (area < minArea) {\n                        minArea = area;\n                        targetNode = child;\n                    }\n                }\n            }\n\n            node = targetNode || node.children[0];\n        }\n\n        return node;\n    }\n\n    _insert(item, level, isNode) {\n        const bbox = isNode ? item : this.toBBox(item);\n        const insertPath = [];\n\n        // find the best node for accommodating the item, saving all nodes along the path too\n        const node = this._chooseSubtree(bbox, this.data, level, insertPath);\n\n        // put the item into the node\n        node.children.push(item);\n        extend(node, bbox);\n\n        // split on node overflow; propagate upwards if necessary\n        while (level >= 0) {\n            if (insertPath[level].children.length > this._maxEntries) {\n                this._split(insertPath, level);\n                level--;\n            } else break;\n        }\n\n        // adjust bboxes along the insertion path\n        this._adjustParentBBoxes(bbox, insertPath, level);\n    }\n\n    // split overflowed node into two\n    _split(insertPath, level) {\n        const node = insertPath[level];\n        const M = node.children.length;\n        const m = this._minEntries;\n\n        this._chooseSplitAxis(node, m, M);\n\n        const splitIndex = this._chooseSplitIndex(node, m, M);\n\n        const newNode = createNode(node.children.splice(splitIndex, node.children.length - splitIndex));\n        newNode.height = node.height;\n        newNode.leaf = node.leaf;\n\n        calcBBox(node, this.toBBox);\n        calcBBox(newNode, this.toBBox);\n\n        if (level) insertPath[level - 1].children.push(newNode);\n        else this._splitRoot(node, newNode);\n    }\n\n    _splitRoot(node, newNode) {\n        // split root node\n        this.data = createNode([node, newNode]);\n        this.data.height = node.height + 1;\n        this.data.leaf = false;\n        calcBBox(this.data, this.toBBox);\n    }\n\n    _chooseSplitIndex(node, m, M) {\n        let index;\n        let minOverlap = Infinity;\n        let minArea = Infinity;\n\n        for (let i = m; i <= M - m; i++) {\n            const bbox1 = distBBox(node, 0, i, this.toBBox);\n            const bbox2 = distBBox(node, i, M, this.toBBox);\n\n            const overlap = intersectionArea(bbox1, bbox2);\n            const area = bboxArea(bbox1) + bboxArea(bbox2);\n\n            // choose distribution with minimum overlap\n            if (overlap < minOverlap) {\n                minOverlap = overlap;\n                index = i;\n\n                minArea = area < minArea ? area : minArea;\n\n            } else if (overlap === minOverlap) {\n                // otherwise choose distribution with minimum area\n                if (area < minArea) {\n                    minArea = area;\n                    index = i;\n                }\n            }\n        }\n\n        return index || M - m;\n    }\n\n    // sorts node children by the best axis for split\n    _chooseSplitAxis(node, m, M) {\n        const compareMinX = node.leaf ? this.compareMinX : compareNodeMinX;\n        const compareMinY = node.leaf ? this.compareMinY : compareNodeMinY;\n        const xMargin = this._allDistMargin(node, m, M, compareMinX);\n        const yMargin = this._allDistMargin(node, m, M, compareMinY);\n\n        // if total distributions margin value is minimal for x, sort by minX,\n        // otherwise it's already sorted by minY\n        if (xMargin < yMargin) node.children.sort(compareMinX);\n    }\n\n    // total margin of all possible split distributions where each node is at least m full\n    _allDistMargin(node, m, M, compare) {\n        node.children.sort(compare);\n\n        const toBBox = this.toBBox;\n        const leftBBox = distBBox(node, 0, m, toBBox);\n        const rightBBox = distBBox(node, M - m, M, toBBox);\n        let margin = bboxMargin(leftBBox) + bboxMargin(rightBBox);\n\n        for (let i = m; i < M - m; i++) {\n            const child = node.children[i];\n            extend(leftBBox, node.leaf ? toBBox(child) : child);\n            margin += bboxMargin(leftBBox);\n        }\n\n        for (let i = M - m - 1; i >= m; i--) {\n            const child = node.children[i];\n            extend(rightBBox, node.leaf ? toBBox(child) : child);\n            margin += bboxMargin(rightBBox);\n        }\n\n        return margin;\n    }\n\n    _adjustParentBBoxes(bbox, path, level) {\n        // adjust bboxes along the given tree path\n        for (let i = level; i >= 0; i--) {\n            extend(path[i], bbox);\n        }\n    }\n\n    _condense(path) {\n        // go through the path, removing empty nodes and updating bboxes\n        for (let i = path.length - 1, siblings; i >= 0; i--) {\n            if (path[i].children.length === 0) {\n                if (i > 0) {\n                    siblings = path[i - 1].children;\n                    siblings.splice(siblings.indexOf(path[i]), 1);\n\n                } else this.clear();\n\n            } else calcBBox(path[i], this.toBBox);\n        }\n    }\n}\n\nfunction findItem(item, items, equalsFn) {\n    if (!equalsFn) return items.indexOf(item);\n\n    for (let i = 0; i < items.length; i++) {\n        if (equalsFn(item, items[i])) return i;\n    }\n    return -1;\n}\n\n// calculate node's bbox from bboxes of its children\nfunction calcBBox(node, toBBox) {\n    distBBox(node, 0, node.children.length, toBBox, node);\n}\n\n// min bounding rectangle of node children from k to p-1\nfunction distBBox(node, k, p, toBBox, destNode) {\n    if (!destNode) destNode = createNode(null);\n    destNode.minX = Infinity;\n    destNode.minY = Infinity;\n    destNode.maxX = -Infinity;\n    destNode.maxY = -Infinity;\n\n    for (let i = k; i < p; i++) {\n        const child = node.children[i];\n        extend(destNode, node.leaf ? toBBox(child) : child);\n    }\n\n    return destNode;\n}\n\nfunction extend(a, b) {\n    a.minX = Math.min(a.minX, b.minX);\n    a.minY = Math.min(a.minY, b.minY);\n    a.maxX = Math.max(a.maxX, b.maxX);\n    a.maxY = Math.max(a.maxY, b.maxY);\n    return a;\n}\n\nfunction compareNodeMinX(a, b) { return a.minX - b.minX; }\nfunction compareNodeMinY(a, b) { return a.minY - b.minY; }\n\nfunction bboxArea(a)   { return (a.maxX - a.minX) * (a.maxY - a.minY); }\nfunction bboxMargin(a) { return (a.maxX - a.minX) + (a.maxY - a.minY); }\n\nfunction enlargedArea(a, b) {\n    return (Math.max(b.maxX, a.maxX) - Math.min(b.minX, a.minX)) *\n           (Math.max(b.maxY, a.maxY) - Math.min(b.minY, a.minY));\n}\n\nfunction intersectionArea(a, b) {\n    const minX = Math.max(a.minX, b.minX);\n    const minY = Math.max(a.minY, b.minY);\n    const maxX = Math.min(a.maxX, b.maxX);\n    const maxY = Math.min(a.maxY, b.maxY);\n\n    return Math.max(0, maxX - minX) *\n           Math.max(0, maxY - minY);\n}\n\nfunction contains(a, b) {\n    return a.minX <= b.minX &&\n           a.minY <= b.minY &&\n           b.maxX <= a.maxX &&\n           b.maxY <= a.maxY;\n}\n\nfunction intersects(a, b) {\n    return b.minX <= a.maxX &&\n           b.minY <= a.maxY &&\n           b.maxX >= a.minX &&\n           b.maxY >= a.minY;\n}\n\nfunction createNode(children) {\n    return {\n        children,\n        height: 1,\n        leaf: true,\n        minX: Infinity,\n        minY: Infinity,\n        maxX: -Infinity,\n        maxY: -Infinity\n    };\n}\n\n// sort an array so that items come in groups of n unsorted items, with groups sorted between each other;\n// combines selection algorithm with binary divide & conquer approach\n\nfunction multiSelect(arr, left, right, n, compare) {\n    const stack = [left, right];\n\n    while (stack.length) {\n        right = stack.pop();\n        left = stack.pop();\n\n        if (right - left <= n) continue;\n\n        const mid = left + Math.ceil((right - left) / n / 2) * n;\n        quickselect(arr, mid, left, right, compare);\n\n        stack.push(left, mid, mid, right);\n    }\n}\n","import RBush from \"rbush\"\nimport { ISpatialIndex } from \"./SpatialIndex\"\n\nexport class RbushIndex<T> implements ISpatialIndex<T> {\n  private tree: RBush<{\n    minX: number\n    minY: number\n    maxX: number\n    maxY: number\n    data: T\n  }>\n\n  constructor(maxEntries = 9) {\n    this.tree = new RBush(maxEntries)\n  }\n\n  insert(item: T, minX: number, minY: number, maxX: number, maxY: number) {\n    this.tree.insert({ minX, minY, maxX, maxY, data: item })\n  }\n\n  bulkLoad(\n    items: Array<{\n      item: T\n      minX: number\n      minY: number\n      maxX: number\n      maxY: number\n    }>,\n  ) {\n    const nodes = items.map(({ item, minX, minY, maxX, maxY }) => ({\n      minX,\n      minY,\n      maxX,\n      maxY,\n      data: item,\n    }))\n    this.tree.load(nodes)\n  }\n\n  search(minX: number, minY: number, maxX: number, maxY: number): T[] {\n    return this.tree.search({ minX, minY, maxX, maxY }).map((n) => n.data)\n  }\n\n  clear() {\n    this.tree.clear()\n  }\n}\n","\nexport default class FlatQueue {\n\n    constructor() {\n        this.ids = [];\n        this.values = [];\n        this.length = 0;\n    }\n\n    clear() {\n        this.length = 0;\n    }\n\n    push(id, value) {\n        let pos = this.length++;\n\n        while (pos > 0) {\n            const parent = (pos - 1) >> 1;\n            const parentValue = this.values[parent];\n            if (value >= parentValue) break;\n            this.ids[pos] = this.ids[parent];\n            this.values[pos] = parentValue;\n            pos = parent;\n        }\n\n        this.ids[pos] = id;\n        this.values[pos] = value;\n    }\n\n    pop() {\n        if (this.length === 0) return undefined;\n\n        const top = this.ids[0];\n        this.length--;\n\n        if (this.length > 0) {\n            const id = this.ids[0] = this.ids[this.length];\n            const value = this.values[0] = this.values[this.length];\n            const halfLength = this.length >> 1;\n            let pos = 0;\n\n            while (pos < halfLength) {\n                let left = (pos << 1) + 1;\n                const right = left + 1;\n                let bestIndex = this.ids[left];\n                let bestValue = this.values[left];\n                const rightValue = this.values[right];\n\n                if (right < this.length && rightValue < bestValue) {\n                    left = right;\n                    bestIndex = this.ids[right];\n                    bestValue = rightValue;\n                }\n                if (bestValue >= value) break;\n\n                this.ids[pos] = bestIndex;\n                this.values[pos] = bestValue;\n                pos = left;\n            }\n\n            this.ids[pos] = id;\n            this.values[pos] = value;\n        }\n\n        return top;\n    }\n\n    peek() {\n        if (this.length === 0) return undefined;\n        return this.ids[0];\n    }\n\n    peekValue() {\n        if (this.length === 0) return undefined;\n        return this.values[0];\n    }\n\n    shrink() {\n        this.ids.length = this.values.length = this.length;\n    }\n}\n","import FlatQueue from 'flatqueue';\n\nconst ARRAY_TYPES = [Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array];\nconst VERSION = 3; // serialized format version\n\n/** @typedef {Int8ArrayConstructor | Uint8ArrayConstructor | Uint8ClampedArrayConstructor | Int16ArrayConstructor | Uint16ArrayConstructor | Int32ArrayConstructor | Uint32ArrayConstructor | Float32ArrayConstructor | Float64ArrayConstructor} TypedArrayConstructor */\n\nexport default class Flatbush {\n\n    /**\n     * Recreate a Flatbush index from raw `ArrayBuffer` or `SharedArrayBuffer` data.\n     * @param {ArrayBuffer | SharedArrayBuffer} data\n     * @param {number} [byteOffset=0] byte offset to the start of the Flatbush buffer in the referenced ArrayBuffer.\n     * @returns {Flatbush} index\n     */\n    static from(data, byteOffset = 0) {\n        if (byteOffset % 8 !== 0) {\n            throw new Error('byteOffset must be 8-byte aligned.');\n        }\n\n        // @ts-expect-error duck typing array buffers\n        if (!data || data.byteLength === undefined || data.buffer) {\n            throw new Error('Data must be an instance of ArrayBuffer or SharedArrayBuffer.');\n        }\n\n        const [magic, versionAndType] = new Uint8Array(data, byteOffset + 0, 2);\n        if (magic !== 0xfb) {\n            throw new Error('Data does not appear to be in a Flatbush format.');\n        }\n        const version = versionAndType >> 4;\n        if (version !== VERSION) {\n            throw new Error(`Got v${version} data when expected v${VERSION}.`);\n        }\n        const ArrayType = ARRAY_TYPES[versionAndType & 0x0f];\n        if (!ArrayType) {\n            throw new Error('Unrecognized array type.');\n        }\n        const [nodeSize] = new Uint16Array(data, byteOffset + 2, 1);\n        const [numItems] = new Uint32Array(data, byteOffset + 4, 1);\n\n        return new Flatbush(numItems, nodeSize, ArrayType, undefined, data, byteOffset);\n    }\n\n    /**\n     * Create a Flatbush index that will hold a given number of items.\n     * @param {number} numItems\n     * @param {number} [nodeSize=16] Size of the tree node (16 by default).\n     * @param {TypedArrayConstructor} [ArrayType=Float64Array] The array type used for coordinates storage (`Float64Array` by default).\n     * @param {ArrayBufferConstructor | SharedArrayBufferConstructor} [ArrayBufferType=ArrayBuffer] The array buffer type used to store data (`ArrayBuffer` by default).\n     * @param {ArrayBuffer | SharedArrayBuffer} [data] (Only used internally)\n     * @param {number} [byteOffset=0] (Only used internally)\n     */\n    constructor(numItems, nodeSize = 16, ArrayType = Float64Array, ArrayBufferType = ArrayBuffer, data, byteOffset = 0) {\n        if (numItems === undefined) throw new Error('Missing required argument: numItems.');\n        if (isNaN(numItems) || numItems <= 0) throw new Error(`Unexpected numItems value: ${numItems}.`);\n\n        this.numItems = +numItems;\n        this.nodeSize = Math.min(Math.max(+nodeSize, 2), 65535);\n        this.byteOffset = byteOffset;\n\n        // calculate the total number of nodes in the R-tree to allocate space for\n        // and the index of each tree level (used in search later)\n        let n = numItems;\n        let numNodes = n;\n        this._levelBounds = [n * 4];\n        do {\n            n = Math.ceil(n / this.nodeSize);\n            numNodes += n;\n            this._levelBounds.push(numNodes * 4);\n        } while (n !== 1);\n\n        this.ArrayType = ArrayType;\n        this.IndexArrayType = numNodes < 16384 ? Uint16Array : Uint32Array;\n\n        const arrayTypeIndex = ARRAY_TYPES.indexOf(this.ArrayType);\n        const nodesByteSize = numNodes * 4 * this.ArrayType.BYTES_PER_ELEMENT;\n\n        if (arrayTypeIndex < 0) {\n            throw new Error(`Unexpected typed array class: ${ArrayType}.`);\n        }\n\n        // @ts-expect-error duck typing array buffers\n        if (data && data.byteLength !== undefined && !data.buffer) {\n            this.data = data;\n            this._boxes = new this.ArrayType(this.data, byteOffset + 8, numNodes * 4);\n            this._indices = new this.IndexArrayType(this.data, byteOffset + 8 + nodesByteSize, numNodes);\n\n            this._pos = numNodes * 4;\n            this.minX = this._boxes[this._pos - 4];\n            this.minY = this._boxes[this._pos - 3];\n            this.maxX = this._boxes[this._pos - 2];\n            this.maxY = this._boxes[this._pos - 1];\n\n        } else {\n            this.data = new ArrayBufferType(8 + nodesByteSize + numNodes * this.IndexArrayType.BYTES_PER_ELEMENT);\n            this._boxes = new this.ArrayType(this.data, 8, numNodes * 4);\n            this._indices = new this.IndexArrayType(this.data, 8 + nodesByteSize, numNodes);\n            this._pos = 0;\n            this.minX = Infinity;\n            this.minY = Infinity;\n            this.maxX = -Infinity;\n            this.maxY = -Infinity;\n\n            new Uint8Array(this.data, 0, 2).set([0xfb, (VERSION << 4) + arrayTypeIndex]);\n            new Uint16Array(this.data, 2, 1)[0] = nodeSize;\n            new Uint32Array(this.data, 4, 1)[0] = numItems;\n        }\n\n        // a priority queue for k-nearest-neighbors queries\n        /** @type FlatQueue<number> */\n        this._queue = new FlatQueue();\n    }\n\n    /**\n     * Add a given rectangle to the index.\n     * @param {number} minX\n     * @param {number} minY\n     * @param {number} maxX\n     * @param {number} maxY\n     * @returns {number} A zero-based, incremental number that represents the newly added rectangle.\n     */\n    add(minX, minY, maxX = minX, maxY = minY) {\n        const index = this._pos >> 2;\n        const boxes = this._boxes;\n        this._indices[index] = index;\n        boxes[this._pos++] = minX;\n        boxes[this._pos++] = minY;\n        boxes[this._pos++] = maxX;\n        boxes[this._pos++] = maxY;\n\n        if (minX < this.minX) this.minX = minX;\n        if (minY < this.minY) this.minY = minY;\n        if (maxX > this.maxX) this.maxX = maxX;\n        if (maxY > this.maxY) this.maxY = maxY;\n\n        return index;\n    }\n\n    /** Perform indexing of the added rectangles. */\n    finish() {\n        if (this._pos >> 2 !== this.numItems) {\n            throw new Error(`Added ${this._pos >> 2} items when expected ${this.numItems}.`);\n        }\n        const boxes = this._boxes;\n\n        if (this.numItems <= this.nodeSize) {\n            // only one node, skip sorting and just fill the root box\n            boxes[this._pos++] = this.minX;\n            boxes[this._pos++] = this.minY;\n            boxes[this._pos++] = this.maxX;\n            boxes[this._pos++] = this.maxY;\n            return;\n        }\n\n        const width = (this.maxX - this.minX) || 1;\n        const height = (this.maxY - this.minY) || 1;\n        const hilbertValues = new Uint32Array(this.numItems);\n        const hilbertMax = (1 << 16) - 1;\n\n        // map item centers into Hilbert coordinate space and calculate Hilbert values\n        for (let i = 0, pos = 0; i < this.numItems; i++) {\n            const minX = boxes[pos++];\n            const minY = boxes[pos++];\n            const maxX = boxes[pos++];\n            const maxY = boxes[pos++];\n            const x = Math.floor(hilbertMax * ((minX + maxX) / 2 - this.minX) / width);\n            const y = Math.floor(hilbertMax * ((minY + maxY) / 2 - this.minY) / height);\n            hilbertValues[i] = hilbert(x, y);\n        }\n\n        // sort items by their Hilbert value (for packing later)\n        sort(hilbertValues, boxes, this._indices, 0, this.numItems - 1, this.nodeSize);\n\n        // generate nodes at each tree level, bottom-up\n        for (let i = 0, pos = 0; i < this._levelBounds.length - 1; i++) {\n            const end = this._levelBounds[i];\n\n            // generate a parent node for each block of consecutive <nodeSize> nodes\n            while (pos < end) {\n                const nodeIndex = pos;\n\n                // calculate bbox for the new node\n                let nodeMinX = boxes[pos++];\n                let nodeMinY = boxes[pos++];\n                let nodeMaxX = boxes[pos++];\n                let nodeMaxY = boxes[pos++];\n                for (let j = 1; j < this.nodeSize && pos < end; j++) {\n                    nodeMinX = Math.min(nodeMinX, boxes[pos++]);\n                    nodeMinY = Math.min(nodeMinY, boxes[pos++]);\n                    nodeMaxX = Math.max(nodeMaxX, boxes[pos++]);\n                    nodeMaxY = Math.max(nodeMaxY, boxes[pos++]);\n                }\n\n                // add the new node to the tree data\n                this._indices[this._pos >> 2] = nodeIndex;\n                boxes[this._pos++] = nodeMinX;\n                boxes[this._pos++] = nodeMinY;\n                boxes[this._pos++] = nodeMaxX;\n                boxes[this._pos++] = nodeMaxY;\n            }\n        }\n    }\n\n    /**\n     * Search the index by a bounding box.\n     * @param {number} minX\n     * @param {number} minY\n     * @param {number} maxX\n     * @param {number} maxY\n     * @param {(index: number) => boolean} [filterFn] An optional function for filtering the results.\n     * @returns {number[]} An array of indices of items intersecting or touching the given bounding box.\n     */\n    search(minX, minY, maxX, maxY, filterFn) {\n        if (this._pos !== this._boxes.length) {\n            throw new Error('Data not yet indexed - call index.finish().');\n        }\n\n        /** @type number | undefined */\n        let nodeIndex = this._boxes.length - 4;\n        const queue = [];\n        const results = [];\n\n        while (nodeIndex !== undefined) {\n            // find the end index of the node\n            const end = Math.min(nodeIndex + this.nodeSize * 4, upperBound(nodeIndex, this._levelBounds));\n\n            // search through child nodes\n            for (let /** @type number */ pos = nodeIndex; pos < end; pos += 4) {\n                // check if node bbox intersects with query bbox\n                if (maxX < this._boxes[pos]) continue; // maxX < nodeMinX\n                if (maxY < this._boxes[pos + 1]) continue; // maxY < nodeMinY\n                if (minX > this._boxes[pos + 2]) continue; // minX > nodeMaxX\n                if (minY > this._boxes[pos + 3]) continue; // minY > nodeMaxY\n\n                const index = this._indices[pos >> 2] | 0;\n\n                if (nodeIndex >= this.numItems * 4) {\n                    queue.push(index); // node; add it to the search queue\n\n                } else if (filterFn === undefined || filterFn(index)) {\n                    results.push(index); // leaf item\n                }\n            }\n\n            nodeIndex = queue.pop();\n        }\n\n        return results;\n    }\n\n    /**\n     * Search items in order of distance from the given point.\n     * @param {number} x\n     * @param {number} y\n     * @param {number} [maxResults=Infinity]\n     * @param {number} [maxDistance=Infinity]\n     * @param {(index: number) => boolean} [filterFn] An optional function for filtering the results.\n     * @returns {number[]} An array of indices of items found.\n     */\n    neighbors(x, y, maxResults = Infinity, maxDistance = Infinity, filterFn) {\n        if (this._pos !== this._boxes.length) {\n            throw new Error('Data not yet indexed - call index.finish().');\n        }\n\n        /** @type number | undefined */\n        let nodeIndex = this._boxes.length - 4;\n        const q = this._queue;\n        const results = [];\n        const maxDistSquared = maxDistance * maxDistance;\n\n        outer: while (nodeIndex !== undefined) {\n            // find the end index of the node\n            const end = Math.min(nodeIndex + this.nodeSize * 4, upperBound(nodeIndex, this._levelBounds));\n\n            // add child nodes to the queue\n            for (let pos = nodeIndex; pos < end; pos += 4) {\n                const index = this._indices[pos >> 2] | 0;\n\n                const dx = axisDist(x, this._boxes[pos], this._boxes[pos + 2]);\n                const dy = axisDist(y, this._boxes[pos + 1], this._boxes[pos + 3]);\n                const dist = dx * dx + dy * dy;\n                if (dist > maxDistSquared) continue;\n\n                if (nodeIndex >= this.numItems * 4) {\n                    q.push(index << 1, dist); // node (use even id)\n\n                } else if (filterFn === undefined || filterFn(index)) {\n                    q.push((index << 1) + 1, dist); // leaf item (use odd id)\n                }\n            }\n\n            // pop items from the queue\n            // @ts-expect-error q.length check eliminates undefined values\n            while (q.length && (q.peek() & 1)) {\n                const dist = q.peekValue();\n                // @ts-expect-error\n                if (dist > maxDistSquared) break outer;\n                // @ts-expect-error\n                results.push(q.pop() >> 1);\n                if (results.length === maxResults) break outer;\n            }\n\n            // @ts-expect-error\n            nodeIndex = q.length ? q.pop() >> 1 : undefined;\n        }\n\n        q.clear();\n        return results;\n    }\n}\n\n/**\n * 1D distance from a value to a range.\n * @param {number} k\n * @param {number} min\n * @param {number} max\n */\nfunction axisDist(k, min, max) {\n    return k < min ? min - k : k <= max ? 0 : k - max;\n}\n\n/**\n * Binary search for the first value in the array bigger than the given.\n * @param {number} value\n * @param {number[]} arr\n */\nfunction upperBound(value, arr) {\n    let i = 0;\n    let j = arr.length - 1;\n    while (i < j) {\n        const m = (i + j) >> 1;\n        if (arr[m] > value) {\n            j = m;\n        } else {\n            i = m + 1;\n        }\n    }\n    return arr[i];\n}\n\n/**\n * Custom quicksort that partially sorts bbox data alongside the hilbert values.\n * @param {Uint32Array} values\n * @param {InstanceType<TypedArrayConstructor>} boxes\n * @param {Uint16Array | Uint32Array} indices\n * @param {number} left\n * @param {number} right\n * @param {number} nodeSize\n */\nfunction sort(values, boxes, indices, left, right, nodeSize) {\n    if (Math.floor(left / nodeSize) >= Math.floor(right / nodeSize)) return;\n\n    const pivot = values[(left + right) >> 1];\n    let i = left - 1;\n    let j = right + 1;\n\n    while (true) {\n        do i++; while (values[i] < pivot);\n        do j--; while (values[j] > pivot);\n        if (i >= j) break;\n        swap(values, boxes, indices, i, j);\n    }\n\n    sort(values, boxes, indices, left, j, nodeSize);\n    sort(values, boxes, indices, j + 1, right, nodeSize);\n}\n\n/**\n * Swap two values and two corresponding boxes.\n * @param {Uint32Array} values\n * @param {InstanceType<TypedArrayConstructor>} boxes\n * @param {Uint16Array | Uint32Array} indices\n * @param {number} i\n * @param {number} j\n */\nfunction swap(values, boxes, indices, i, j) {\n    const temp = values[i];\n    values[i] = values[j];\n    values[j] = temp;\n\n    const k = 4 * i;\n    const m = 4 * j;\n\n    const a = boxes[k];\n    const b = boxes[k + 1];\n    const c = boxes[k + 2];\n    const d = boxes[k + 3];\n    boxes[k] = boxes[m];\n    boxes[k + 1] = boxes[m + 1];\n    boxes[k + 2] = boxes[m + 2];\n    boxes[k + 3] = boxes[m + 3];\n    boxes[m] = a;\n    boxes[m + 1] = b;\n    boxes[m + 2] = c;\n    boxes[m + 3] = d;\n\n    const e = indices[i];\n    indices[i] = indices[j];\n    indices[j] = e;\n}\n\n/**\n * Fast Hilbert curve algorithm by http://threadlocalmutex.com/\n * Ported from C++ https://github.com/rawrunprotected/hilbert_curves (public domain)\n * @param {number} x\n * @param {number} y\n */\nfunction hilbert(x, y) {\n    let a = x ^ y;\n    let b = 0xFFFF ^ a;\n    let c = 0xFFFF ^ (x | y);\n    let d = x & (y ^ 0xFFFF);\n\n    let A = a | (b >> 1);\n    let B = (a >> 1) ^ a;\n    let C = ((c >> 1) ^ (b & (d >> 1))) ^ c;\n    let D = ((a & (c >> 1)) ^ (d >> 1)) ^ d;\n\n    a = A; b = B; c = C; d = D;\n    A = ((a & (a >> 2)) ^ (b & (b >> 2)));\n    B = ((a & (b >> 2)) ^ (b & ((a ^ b) >> 2)));\n    C ^= ((a & (c >> 2)) ^ (b & (d >> 2)));\n    D ^= ((b & (c >> 2)) ^ ((a ^ b) & (d >> 2)));\n\n    a = A; b = B; c = C; d = D;\n    A = ((a & (a >> 4)) ^ (b & (b >> 4)));\n    B = ((a & (b >> 4)) ^ (b & ((a ^ b) >> 4)));\n    C ^= ((a & (c >> 4)) ^ (b & (d >> 4)));\n    D ^= ((b & (c >> 4)) ^ ((a ^ b) & (d >> 4)));\n\n    a = A; b = B; c = C; d = D;\n    C ^= ((a & (c >> 8)) ^ (b & (d >> 8)));\n    D ^= ((b & (c >> 8)) ^ ((a ^ b) & (d >> 8)));\n\n    a = C ^ (C >> 1);\n    b = D ^ (D >> 1);\n\n    let i0 = x ^ y;\n    let i1 = b | (0xFFFF ^ (i0 | a));\n\n    i0 = (i0 | (i0 << 8)) & 0x00FF00FF;\n    i0 = (i0 | (i0 << 4)) & 0x0F0F0F0F;\n    i0 = (i0 | (i0 << 2)) & 0x33333333;\n    i0 = (i0 | (i0 << 1)) & 0x55555555;\n\n    i1 = (i1 | (i1 << 8)) & 0x00FF00FF;\n    i1 = (i1 | (i1 << 4)) & 0x0F0F0F0F;\n    i1 = (i1 | (i1 << 2)) & 0x33333333;\n    i1 = (i1 | (i1 << 1)) & 0x55555555;\n\n    return ((i1 << 1) | i0) >>> 0;\n}\n","import Flatbush from \"flatbush\"\nimport { ISpatialIndex } from \"./SpatialIndex\"\n\nexport class FlatbushIndex<T> implements ISpatialIndex<T> {\n  private index: Flatbush\n  private items: T[] = []\n  private currentIndex = 0\n\n  constructor(numItems: number) {\n    this.index = new Flatbush(numItems)\n  }\n\n  insert(item: T, minX: number, minY: number, maxX: number, maxY: number) {\n    if (this.currentIndex >= this.index.numItems) {\n      throw new Error(\"Exceeded initial capacity\")\n    }\n    this.items[this.currentIndex] = item\n    this.index.add(minX, minY, maxX, maxY)\n    this.currentIndex++\n  }\n\n  finish() {\n    this.index.finish()\n  }\n\n  search(minX: number, minY: number, maxX: number, maxY: number): T[] {\n    const ids = this.index.search(minX, minY, maxX, maxY)\n    return ids.map((id) => this.items[id] || null).filter(Boolean) as T[]\n  }\n\n  clear() {\n    this.items = []\n    this.index = new Flatbush(0)\n  }\n}\n","import { Obstacle } from \"lib/types\"\nimport { ISpatialIndex } from \"./SpatialIndex\"\nimport { RbushIndex } from \"./RbushIndex\"\nimport { FlatbushIndex } from \"./FlatbushIndex\"\n\nexport type BucketCoordinate = `${number}x${number}`\n\n/**\n * ObstacleTree wraps different spatial index implementations:\n * - 'native': original spatial-hash grid\n * - 'rbush': dynamic R-tree via rbush\n * - 'flatbush': static index via flatbush\n */\nexport class ObstacleSpatialHashIndex {\n  private idx: ISpatialIndex<Obstacle>\n  private storage: Obstacle[] = []\n\n  constructor(\n    implementation: \"native\" | \"rbush\" | \"flatbush\" = \"native\",\n    obstacles: Obstacle[] = [],\n  ) {\n    if (implementation === \"flatbush\") {\n      this.idx = new FlatbushIndex<Obstacle>(obstacles.length)\n    } else if (implementation === \"rbush\") {\n      this.idx = new RbushIndex<Obstacle>()\n    } else {\n      // fallback to native spatial-hash\n      this.idx = new (class implements ISpatialIndex<Obstacle> {\n        private shi = new NativeObstacleTree(obstacles)\n        insert(item: Obstacle): void {\n          /* no-op */\n        }\n        search(\n          minX: number,\n          minY: number,\n          maxX: number,\n          maxY: number,\n        ): Obstacle[] {\n          const centerX = (minX + maxX) / 2\n          const centerY = (minY + maxY) / 2\n          const width = maxX - minX\n          const height = maxY - minY\n          return this.shi.getNodesInArea(centerX, centerY, width, height)\n        }\n        clear(): void {\n          /* no-op */\n        }\n      })()\n    }\n\n    // bulk-load initial obstacles\n    obstacles.forEach((o) => this.insert(o))\n    if (implementation === \"flatbush\") this.idx.finish?.()\n  }\n\n  insert(o: Obstacle) {\n    this.storage.push(o)\n    this.idx.insert(\n      o,\n      o.center.x - o.width / 2,\n      o.center.y - o.height / 2,\n      o.center.x + o.width / 2,\n      o.center.y + o.height / 2,\n    )\n  }\n\n  search(bbox: {\n    minX: number\n    minY: number\n    maxX: number\n    maxY: number\n  }): Obstacle[] {\n    return this.idx.search(bbox.minX, bbox.minY, bbox.maxX, bbox.maxY)\n  }\n\n  searchArea(\n    centerX: number,\n    centerY: number,\n    width: number,\n    height: number,\n  ): Obstacle[] {\n    return this.search({\n      minX: centerX - width / 2,\n      minY: centerY - height / 2,\n      maxX: centerX + width / 2,\n      maxY: centerY + height / 2,\n    })\n  }\n}\n\nexport class NativeObstacleTree {\n  buckets: Map<BucketCoordinate, [Obstacle, number][]>\n  CELL_SIZE = 0.4\n\n  constructor(public obstacles: Obstacle[]) {\n    // console.log(\n    //   `[ObstacleSHI] Initializing with ${obstacles.length} obstacles. CELL_SIZE: ${this.CELL_SIZE}`,\n    // )\n    this.buckets = new Map()\n    let bucketEntriesCount = 0\n    // for (const obstacle of obstacles) {\n    for (let i = 0; i < obstacles.length; i++) {\n      const obstacle = obstacles[i]\n      const nodeMinX = obstacle.center.x - obstacle.width / 2\n      const nodeMinY = obstacle.center.y - obstacle.height / 2\n      const nodeMaxX = obstacle.center.x + obstacle.width / 2\n      const nodeMaxY = obstacle.center.y + obstacle.height / 2\n      for (let x = nodeMinX; x <= nodeMaxX; x += this.CELL_SIZE) {\n        for (let y = nodeMinY; y <= nodeMaxY; y += this.CELL_SIZE) {\n          const bucketKey = this.getBucketKey(x, y)\n          const bucket = this.buckets.get(bucketKey)\n          if (!bucket) {\n            this.buckets.set(bucketKey, [[obstacle, i]])\n          } else {\n            bucket.push([obstacle, i])\n            bucketEntriesCount++\n          }\n        }\n      }\n    }\n    // console.log(\n    //   `[ObstacleSHI] Initialization complete. Populated ${this.buckets.size} buckets with ${bucketEntriesCount} total entries.`,\n    // )\n  }\n\n  getBucketKey(x: number, y: number): BucketCoordinate {\n    return `${Math.floor(x / this.CELL_SIZE)}x${Math.floor(y / this.CELL_SIZE)}`\n  }\n\n  getNodesInArea(\n    centerX: number,\n    centerY: number,\n    width: number,\n    height: number,\n  ): Obstacle[] {\n    const obstacles: Obstacle[] = []\n    const alreadyAddedObstacles = new Set<number>()\n    const minX = centerX - width / 2\n    const minY = centerY - height / 2\n    const maxX = centerX + width / 2\n    const maxY = centerY + height / 2\n    for (let x = minX; x <= maxX; x += this.CELL_SIZE) {\n      for (let y = minY; y <= maxY; y += this.CELL_SIZE) {\n        const bucketKey = this.getBucketKey(x, y)\n        const bucket = this.buckets.get(bucketKey) || []\n        for (const obstacleWithIndex of bucket) {\n          if (alreadyAddedObstacles.has(obstacleWithIndex[1])) continue\n          alreadyAddedObstacles.add(obstacleWithIndex[1])\n          obstacles.push(obstacleWithIndex[0])\n        }\n      }\n    }\n    return obstacles\n  }\n}\n","interface Target {\n  x: number\n  y: number\n  bounds: {\n    minX: number\n    minY: number\n    maxX: number\n    maxY: number\n  }\n  connectionName: string\n  availableZ: number[]\n}\n\nexport type BucketCoordinate = `${number}x${number}`\n\nexport class TargetTree {\n  buckets: Map<BucketCoordinate, [Target, number][]>\n  CELL_SIZE = 5\n\n  constructor(public targets: Target[]) {\n    this.buckets = new Map()\n    for (let i = 0; i < targets.length; i++) {\n      const target = targets[i]\n      const targetBucketMinX =\n        Math.floor(target.bounds.minX / this.CELL_SIZE) * this.CELL_SIZE\n      const targetBucketMinY =\n        Math.floor(target.bounds.minY / this.CELL_SIZE) * this.CELL_SIZE\n      const targetMaxX = target.bounds.maxX\n      const targetMaxY = target.bounds.maxY\n      for (let x = targetBucketMinX; x <= targetMaxX; x += this.CELL_SIZE) {\n        for (let y = targetBucketMinY; y <= targetMaxY; y += this.CELL_SIZE) {\n          const bucketKey = this.getBucketKey(x, y)\n          const bucket = this.buckets.get(bucketKey)\n          if (!bucket) {\n            this.buckets.set(bucketKey, [[target, i]])\n          } else {\n            bucket.push([target, i])\n          }\n        }\n      }\n    }\n  }\n\n  getBucketKey(x: number, y: number): BucketCoordinate {\n    return `${Math.floor(x / this.CELL_SIZE)}x${Math.floor(y / this.CELL_SIZE)}`\n  }\n\n  getTargetsInArea(\n    centerX: number,\n    centerY: number,\n    width: number,\n    height: number,\n  ): Target[] {\n    const targets: Target[] = []\n    const alreadyAddedTargets = new Set<number>()\n    const minX =\n      Math.floor((centerX - width / 2) / this.CELL_SIZE) * this.CELL_SIZE\n    const minY =\n      Math.floor((centerY - height / 2) / this.CELL_SIZE) * this.CELL_SIZE\n    const maxX = centerX + width / 2\n    const maxY = centerY + height / 2\n    for (let x = minX; x <= maxX; x += this.CELL_SIZE) {\n      for (let y = minY; y <= maxY; y += this.CELL_SIZE) {\n        const bucketKey = this.getBucketKey(x, y)\n        const bucket = this.buckets.get(bucketKey) || []\n        for (const targetWithIndex of bucket) {\n          if (alreadyAddedTargets.has(targetWithIndex[1])) continue\n          alreadyAddedTargets.add(targetWithIndex[1])\n          targets.push(targetWithIndex[0])\n        }\n      }\n    }\n    return targets\n  }\n}\n","import type { GraphicsObject } from \"graphics-debug\"\nimport { BaseSolver } from \"../BaseSolver\"\nimport type {\n  CapacityMeshEdge,\n  CapacityMeshNode,\n  CapacityMeshNodeId,\n  Obstacle,\n  SimpleRouteJson,\n} from \"../../types\"\nimport { COLORS } from \"../colors\"\nimport { isPointInRect } from \"lib/utils/isPointInRect\"\nimport { doRectsOverlap } from \"lib/utils/doRectsOverlap\"\nimport { mapLayerNameToZ } from \"lib/utils/mapLayerNameToZ\"\nimport { getTunedTotalCapacity1 } from \"lib/utils/getTunedTotalCapacity1\"\nimport { ObstacleSpatialHashIndex } from \"lib/data-structures/ObstacleTree\"\nimport { TargetTree } from \"lib/data-structures/TargetTree\"\n\ninterface CapacityMeshNodeSolverOptions {\n  capacityDepth?: number\n}\n\ninterface Target {\n  x: number\n  y: number\n  bounds: {\n    minX: number\n    minY: number\n    maxX: number\n    maxY: number\n  }\n  connectionName: string\n  availableZ: number[]\n}\n\nexport class CapacityMeshNodeSolver extends BaseSolver {\n  unfinishedNodes: CapacityMeshNode[]\n  finishedNodes: CapacityMeshNode[]\n\n  nodeToXYOverlappingObstaclesMap: Map<CapacityMeshNodeId, Obstacle[]>\n  layerCount: number\n\n  // targetObstacleMap: Record<string, { obstacle: Obstacle, node: CapacityMeshNode }>\n\n  MAX_DEPTH = 4\n\n  targets: Target[]\n  targetTree: TargetTree\n  obstacleTree: ObstacleSpatialHashIndex\n\n  constructor(\n    public srj: SimpleRouteJson,\n    public opts: CapacityMeshNodeSolverOptions = {},\n  ) {\n    super()\n    this.MAX_DEPTH = opts?.capacityDepth ?? this.MAX_DEPTH\n    this.MAX_ITERATIONS = 100_000\n    this.layerCount = srj.layerCount ?? 2\n\n    for (const obstacle of srj.obstacles) {\n      if (!obstacle.zLayers) {\n        const zLayers: number[] = []\n        for (const layer of obstacle.layers) {\n          zLayers.push(mapLayerNameToZ(layer, srj.layerCount))\n        }\n        obstacle.zLayers = zLayers\n      }\n    }\n\n    const boundsCenter = {\n      x: (srj.bounds.minX + srj.bounds.maxX) / 2,\n      y: (srj.bounds.minY + srj.bounds.maxY) / 2,\n    }\n    const boundsSize = {\n      width: srj.bounds.maxX - srj.bounds.minX,\n      height: srj.bounds.maxY - srj.bounds.minY,\n    }\n    const maxWidthHeight = Math.max(boundsSize.width, boundsSize.height)\n    this.unfinishedNodes = [\n      {\n        capacityMeshNodeId: this.getNextNodeId(),\n        center: boundsCenter,\n        width: maxWidthHeight,\n        height: maxWidthHeight,\n        layer: \"top\",\n        availableZ: [0, 1],\n        _depth: 0,\n        _containsTarget: true,\n        _containsObstacle: true,\n        _completelyInsideObstacle: false,\n      },\n    ]\n    this.finishedNodes = []\n    this.nodeToXYOverlappingObstaclesMap = new Map()\n    this.obstacleTree = new ObstacleSpatialHashIndex(\n      \"flatbush\",\n      this.srj.obstacles,\n    )\n    this.targets = this.computeTargets()\n    this.targetTree = new TargetTree(this.targets)\n  }\n\n  computeTargets(): Target[] {\n    const targets: Target[] = []\n    for (const conn of this.srj.connections) {\n      for (const ptc of conn.pointsToConnect) {\n        const obstacles = this.obstacleTree\n          .searchArea(ptc.x, ptc.y, 0.01, 0.01)\n          .filter((o) =>\n            o.zLayers!.some((z) => (ptc.layer === \"top\" ? z === 0 : z === 1)),\n          )\n\n        let bounds: {\n          minX: number\n          minY: number\n          maxX: number\n          maxY: number\n        } = {\n          minX: ptc.x - 0.005,\n          minY: ptc.y - 0.005,\n          maxX: ptc.x + 0.005,\n          maxY: ptc.y + 0.005,\n        }\n        if (obstacles.length > 0) {\n          bounds = {\n            minX: Math.min(...obstacles.map((o) => o.center.x - o.width / 2)),\n            minY: Math.min(...obstacles.map((o) => o.center.y - o.height / 2)),\n            maxX: Math.max(...obstacles.map((o) => o.center.x + o.width / 2)),\n            maxY: Math.max(...obstacles.map((o) => o.center.y + o.height / 2)),\n          }\n        }\n        const target = {\n          ...ptc,\n          connectionName: conn.name,\n          availableZ: ptc.layer === \"top\" ? [0] : [1],\n          bounds,\n        }\n        targets.push(target)\n      }\n    }\n    return targets\n  }\n\n  _nextNodeCounter = 0\n  getNextNodeId(): string {\n    return `cn${this._nextNodeCounter++}`\n  }\n\n  getCapacityFromDepth(depth: number): number {\n    return (this.MAX_DEPTH - depth + 1) ** 2\n  }\n\n  getTargetIfNodeContainsTarget(node: CapacityMeshNode): Target | null {\n    const nearbyTargets =\n      node.width > this.targetTree.CELL_SIZE * 4\n        ? this.targets\n        : this.targetTree.getTargetsInArea(\n            node.center.x,\n            node.center.y,\n            node.width,\n            node.height,\n          )\n    for (const target of nearbyTargets) {\n      if (\n        // Check if the node and target bounds overlap\n        target.bounds.minX <= node.center.x + node.width / 2 &&\n        target.bounds.maxX >= node.center.x - node.width / 2 &&\n        target.bounds.minY <= node.center.y + node.height / 2 &&\n        target.bounds.maxY >= node.center.y - node.height / 2 &&\n        target.availableZ.some((z) => node.availableZ.includes(z))\n      ) {\n        return target\n      }\n    }\n    return null\n  }\n\n  getXYOverlappingObstacles(node: CapacityMeshNode): Obstacle[] {\n    const cachedObstacles = this.nodeToXYOverlappingObstaclesMap.get(\n      node.capacityMeshNodeId,\n    )\n    if (cachedObstacles) {\n      return cachedObstacles\n    }\n    const overlappingObstacles: Obstacle[] = []\n\n    // Compute node bounds\n    const nodeLeft = node.center.x - node.width / 2\n    const nodeRight = node.center.x + node.width / 2\n    const nodeTop = node.center.y - node.height / 2\n    const nodeBottom = node.center.y + node.height / 2\n\n    const obstacles = node._parent\n      ? this.getXYOverlappingObstacles(node._parent)\n      : this.srj.obstacles\n    for (const obstacle of obstacles) {\n      const obsLeft = obstacle.center.x - obstacle.width / 2\n      const obsRight = obstacle.center.x + obstacle.width / 2\n      const obsTop = obstacle.center.y - obstacle.height / 2\n      const obsBottom = obstacle.center.y + obstacle.height / 2\n\n      // Check for intersection.\n      if (\n        nodeRight >= obsLeft &&\n        nodeLeft <= obsRight &&\n        nodeBottom >= obsTop &&\n        nodeTop <= obsBottom\n      ) {\n        overlappingObstacles.push(obstacle)\n        continue\n      }\n\n      // Check if the node is completely within the obstacle\n      if (\n        nodeLeft >= obsLeft &&\n        nodeRight <= obsRight &&\n        nodeTop >= obsTop &&\n        nodeBottom <= obsBottom\n      ) {\n        // Node is completely inside the obstacle\n        overlappingObstacles.push(obstacle)\n        continue\n      }\n\n      // Check if obstacle is completely within node\n      if (\n        obsLeft >= nodeLeft &&\n        obsRight <= nodeRight &&\n        obsTop >= nodeTop &&\n        obsBottom <= nodeBottom\n      ) {\n        overlappingObstacles.push(obstacle)\n      }\n    }\n\n    this.nodeToXYOverlappingObstaclesMap.set(\n      node.capacityMeshNodeId,\n      overlappingObstacles,\n    )\n\n    return overlappingObstacles\n  }\n\n  getXYZOverlappingObstacles(node: CapacityMeshNode): Obstacle[] {\n    const xyOverlappingObstacles = this.getXYOverlappingObstacles(node)\n\n    // For each obstacle, check if it has any overlap in the z-axis\n    const xyzOverlappingObstacles: Obstacle[] = []\n    for (const obstacle of xyOverlappingObstacles) {\n      if (node.availableZ.some((z) => obstacle.zLayers!.includes(z))) {\n        xyzOverlappingObstacles.push(obstacle)\n      }\n    }\n\n    return xyzOverlappingObstacles\n  }\n\n  /**\n   * Checks if the given mesh node overlaps with any obstacle.\n   * We treat both obstacles and nodes as axisaligned rectangles.\n   */\n  doesNodeOverlapObstacle(node: CapacityMeshNode): boolean {\n    const overlappingObstacles = this.getXYZOverlappingObstacles(node)\n\n    if (overlappingObstacles.length > 0) {\n      return true\n    }\n\n    // Compute node bounds\n    const nodeLeft = node.center.x - node.width / 2\n    const nodeRight = node.center.x + node.width / 2\n    const nodeTop = node.center.y - node.height / 2\n    const nodeBottom = node.center.y + node.height / 2\n\n    // If node is outside the bounds, we consider it to contain an obstacle\n    if (\n      nodeLeft < this.srj.bounds.minX ||\n      nodeRight > this.srj.bounds.maxX ||\n      nodeTop < this.srj.bounds.minY ||\n      nodeBottom > this.srj.bounds.maxY\n    ) {\n      return true\n    }\n    return false\n  }\n\n  /**\n   * Checks if the entire node is contained within any obstacle.\n   */\n  isNodeCompletelyInsideObstacle(node: CapacityMeshNode): boolean {\n    const overlappingObstacles = this.getXYZOverlappingObstacles(node)\n\n    // Compute node bounds\n    const nodeLeft = node.center.x - node.width / 2\n    const nodeRight = node.center.x + node.width / 2\n    const nodeTop = node.center.y - node.height / 2\n    const nodeBottom = node.center.y + node.height / 2\n\n    for (const obstacle of overlappingObstacles) {\n      const obsLeft = obstacle.center.x - obstacle.width / 2\n      const obsRight = obstacle.center.x + obstacle.width / 2\n      const obsTop = obstacle.center.y - obstacle.height / 2\n      const obsBottom = obstacle.center.y + obstacle.height / 2\n\n      // Check if the node's bounds are completely inside the obstacle's bounds.\n      if (\n        nodeLeft >= obsLeft &&\n        nodeRight <= obsRight &&\n        nodeTop >= obsTop &&\n        nodeBottom <= obsBottom\n      ) {\n        return true\n      }\n    }\n\n    // if (\n    //   nodeRight < this.srj.bounds.minX ||\n    //   nodeLeft > this.srj.bounds.maxX ||\n    //   nodeBottom < this.srj.bounds.minY ||\n    //   nodeTop > this.srj.bounds.maxY\n    // ) {\n    //   return true\n    // }\n\n    return false\n  }\n\n  getChildNodes(parent: CapacityMeshNode): CapacityMeshNode[] {\n    if (parent._depth === this.MAX_DEPTH) return []\n    const childNodes: CapacityMeshNode[] = []\n\n    const childNodeSize = { width: parent.width / 2, height: parent.height / 2 }\n\n    const childNodePositions = [\n      {\n        x: parent.center.x - childNodeSize.width / 2,\n        y: parent.center.y - childNodeSize.height / 2,\n      },\n      {\n        x: parent.center.x + childNodeSize.width / 2,\n        y: parent.center.y - childNodeSize.height / 2,\n      },\n      {\n        x: parent.center.x - childNodeSize.width / 2,\n        y: parent.center.y + childNodeSize.height / 2,\n      },\n      {\n        x: parent.center.x + childNodeSize.width / 2,\n        y: parent.center.y + childNodeSize.height / 2,\n      },\n    ]\n\n    for (const position of childNodePositions) {\n      const childNode: CapacityMeshNode = {\n        capacityMeshNodeId: this.getNextNodeId(),\n        center: position,\n        width: childNodeSize.width,\n        height: childNodeSize.height,\n        layer: parent.layer,\n        availableZ: [0, 1],\n        _depth: (parent._depth ?? 0) + 1,\n        _parent: parent,\n      }\n      childNode._containsObstacle = this.doesNodeOverlapObstacle(childNode)\n\n      const target = this.getTargetIfNodeContainsTarget(childNode)\n\n      if (target) {\n        childNode._targetConnectionName = target.connectionName\n        childNode.availableZ = target.availableZ\n        childNode._containsTarget = true\n      }\n\n      if (childNode._containsObstacle) {\n        childNode._completelyInsideObstacle =\n          this.isNodeCompletelyInsideObstacle(childNode)\n      }\n      if (childNode._completelyInsideObstacle && !childNode._containsTarget)\n        continue\n      childNodes.push(childNode)\n    }\n\n    return childNodes\n  }\n\n  shouldNodeBeXYSubdivided(node: CapacityMeshNode) {\n    if (node._depth! >= this.MAX_DEPTH) return false\n    if (node._containsTarget) return true\n    if (node._containsObstacle && !node._completelyInsideObstacle) return true\n    return false\n  }\n\n  _step() {\n    const nextNode = this.unfinishedNodes.pop()\n    if (!nextNode) {\n      this.solved = true\n      return\n    }\n\n    const newNodes = this.getChildNodes(nextNode)\n\n    const finishedNewNodes: CapacityMeshNode[] = []\n    const unfinishedNewNodes: CapacityMeshNode[] = []\n\n    for (const newNode of newNodes) {\n      const shouldBeSubdivided = this.shouldNodeBeXYSubdivided(newNode)\n      if (shouldBeSubdivided) {\n        unfinishedNewNodes.push(newNode)\n      } else if (!shouldBeSubdivided && !newNode._containsObstacle) {\n        finishedNewNodes.push(newNode)\n      } else if (!shouldBeSubdivided && newNode._containsTarget) {\n        finishedNewNodes.push(newNode)\n      }\n    }\n\n    this.unfinishedNodes.push(...unfinishedNewNodes)\n    this.finishedNodes.push(...finishedNewNodes)\n  }\n\n  /**\n   * Creates a GraphicsObject to visualize the mesh, its nodes, obstacles, and connection points.\n   *\n   * - Mesh nodes are rendered as rectangles.\n   *   - Nodes that have an obstacle intersection are outlined in red.\n   *   - Other nodes are outlined in green.\n   * - Lines are drawn from a node to its parent.\n   * - Obstacles are drawn as semi-transparent red rectangles.\n   * - Points for each connections pointsToConnect are drawn in a unique color.\n   */\n  visualize(): GraphicsObject {\n    const graphics: GraphicsObject = {\n      lines: [],\n      points: [],\n      rects: [],\n      circles: [],\n      coordinateSystem: \"cartesian\",\n      title: \"Capacity Mesh Visualization\",\n    }\n\n    // Draw obstacles\n    for (const obstacle of this.srj.obstacles) {\n      graphics.rects!.push({\n        center: obstacle.center,\n        width: obstacle.width,\n        height: obstacle.height,\n        fill:\n          obstacle.zLayers?.length === 1 && obstacle.zLayers?.includes(1)\n            ? \"rgba(0,0,255,0.3)\"\n            : \"rgba(255,0,0,0.3)\",\n        stroke: \"red\",\n        label: [\"obstacle\", `z: ${obstacle.zLayers!.join(\",\")}`].join(\"\\n\"),\n      })\n    }\n\n    // Draw mesh nodes (both finished and unfinished)\n    const allNodes = [...this.finishedNodes, ...this.unfinishedNodes]\n    for (const node of allNodes) {\n      const lowestZ = Math.min(...node.availableZ)\n      const isNextToBeProcessed =\n        this.unfinishedNodes.length > 0 &&\n        node === this.unfinishedNodes[this.unfinishedNodes.length - 1]\n\n      graphics.rects!.push({\n        center: {\n          x: node.center.x + lowestZ * node.width * 0.05,\n          y: node.center.y - lowestZ * node.width * 0.05,\n        },\n        width: Math.max(node.width - 2, node.width * 0.8),\n        height: Math.max(node.height - 2, node.height * 0.8),\n        fill: node._containsObstacle\n          ? \"rgba(255,0,0,0.1)\"\n          : ({\n              \"0,1\": \"rgba(0,0,0,0.1)\",\n              \"0\": \"rgba(0,200,200, 0.1)\",\n              \"1\": \"rgba(0,0,200, 0.1)\",\n            }[node.availableZ.join(\",\")] ?? \"rgba(0,200,200,0.1)\"),\n        stroke: isNextToBeProcessed ? \"rgba(255,165,0,0.5)\" : undefined,\n        label: [\n          node.capacityMeshNodeId,\n          `availableZ: ${node.availableZ.join(\",\")}`,\n          `target? ${node._containsTarget ?? false}`,\n          `obs? ${node._containsObstacle ?? false}`,\n          `${node.width.toFixed(2)}x${node.height.toFixed(2)}`,\n          `capacity: ${getTunedTotalCapacity1(node).toFixed(2)}`,\n        ].join(\"\\n\"),\n      })\n    }\n    graphics.rects!.sort((a, b) => a.center.y - b.center.y)\n\n    // Draw connection points (each connection gets a unique color).\n    this.srj.connections.forEach((connection, index) => {\n      const color = COLORS[index % COLORS.length]\n      for (const pt of connection.pointsToConnect) {\n        graphics.points!.push({\n          x: pt.x,\n          y: pt.y,\n          label: `conn-${index} (${pt.layer})`,\n          color,\n        })\n      }\n    })\n\n    return graphics\n  }\n}\n","import type { GraphicsObject } from \"graphics-debug\"\nimport { BaseSolver } from \"../BaseSolver\"\nimport type {\n  CapacityMeshEdge,\n  CapacityMeshNode,\n  CapacityMeshNodeId,\n  Obstacle,\n  SimpleRouteJson,\n} from \"../../types\"\nimport { COLORS } from \"../colors\"\nimport { isPointInRect } from \"lib/utils/isPointInRect\"\nimport { doRectsOverlap } from \"lib/utils/doRectsOverlap\"\nimport { CapacityMeshNodeSolver } from \"./CapacityMeshNodeSolver1\"\nimport { mapLayerNameToZ } from \"lib/utils/mapLayerNameToZ\"\n\ninterface CapacityMeshNodeSolverOptions {\n  capacityDepth?: number\n}\n\ninterface Target {\n  x: number\n  y: number\n  connectionName: string\n  availableZ: number[]\n}\n\nexport class CapacityMeshNodeSolver2_NodeUnderObstacle extends CapacityMeshNodeSolver {\n  VIA_DIAMETER = 0.6\n  OBSTACLE_MARGIN = 0.1\n\n  constructor(\n    public srj: SimpleRouteJson,\n    public opts: CapacityMeshNodeSolverOptions = {},\n  ) {\n    super(srj, opts)\n  }\n\n  isNodeCompletelyOutsideBounds(node: CapacityMeshNode): boolean {\n    return (\n      node.center.x + node.width / 2 < this.srj.bounds.minX ||\n      node.center.x - node.width / 2 > this.srj.bounds.maxX ||\n      node.center.y + node.height / 2 < this.srj.bounds.minY ||\n      node.center.y - node.height / 2 > this.srj.bounds.maxY\n    )\n  }\n\n  isNodePartiallyOutsideBounds(node: CapacityMeshNode): boolean {\n    return (\n      node.center.x - node.width / 2 < this.srj.bounds.minX ||\n      node.center.x + node.width / 2 > this.srj.bounds.maxX ||\n      node.center.y - node.height / 2 < this.srj.bounds.minY ||\n      node.center.y + node.height / 2 > this.srj.bounds.maxY\n    )\n  }\n  createChildNodeAtPosition(\n    parent: CapacityMeshNode,\n    opts: {\n      center: { x: number; y: number }\n      width: number\n      height: number\n      availableZ: number[]\n      _depth?: number\n    },\n  ): CapacityMeshNode {\n    const childNode: CapacityMeshNode = {\n      capacityMeshNodeId: this.getNextNodeId(),\n      center: opts.center,\n      width: opts.width,\n      height: opts.height,\n      layer: parent.layer,\n      availableZ: opts.availableZ,\n      _depth: opts._depth ?? (parent._depth ?? 0) + 1,\n      _parent: parent,\n    }\n\n    const overlappingObstacles = this.getXYZOverlappingObstacles(childNode)\n\n    childNode._containsObstacle =\n      overlappingObstacles.length > 0 ||\n      this.isNodePartiallyOutsideBounds(childNode)\n\n    const target = this.getTargetIfNodeContainsTarget(childNode)\n\n    if (target) {\n      childNode._targetConnectionName = target.connectionName\n      childNode._containsTarget = true\n    }\n\n    if (childNode._containsObstacle) {\n      childNode._completelyInsideObstacle =\n        this.isNodeCompletelyInsideObstacle(childNode)\n    }\n    // childNode._shouldBeInGraph =\n    //   (!isOutsideBounds && !childNode._completelyInsideObstacle) || childNode._\n\n    return childNode\n  }\n\n  getZSubdivisionChildNodes(node: CapacityMeshNode): CapacityMeshNode[] {\n    if (node.availableZ.length === 1) return []\n\n    const childNodes: CapacityMeshNode[] = []\n\n    // TODO when we have more than 2 layers, we need to handle other\n    // variations, you always want to prioritize having larger contiguous\n    // z-blocks\n    const otherZBlocks = [[0], [1]]\n\n    for (const zBlock of otherZBlocks) {\n      const childNode = this.createChildNodeAtPosition(node, {\n        center: { ...node.center },\n        width: node.width,\n        height: node.height,\n        availableZ: zBlock,\n        // z-subdivision doesn't count towards depth, should be same as parent\n        _depth: node._depth!,\n      })\n\n      if (this.isNodeCompletelyOutsideBounds(childNode)) {\n        continue\n      }\n\n      childNodes.push(childNode)\n    }\n\n    return childNodes\n  }\n\n  getChildNodes(parent: CapacityMeshNode): CapacityMeshNode[] {\n    if (parent._depth! >= this.MAX_DEPTH) return []\n    const childNodes: CapacityMeshNode[] = []\n\n    const childNodeSize = { width: parent.width / 2, height: parent.height / 2 }\n\n    const childNodePositions = [\n      {\n        x: parent.center.x - childNodeSize.width / 2,\n        y: parent.center.y - childNodeSize.height / 2,\n      },\n      {\n        x: parent.center.x + childNodeSize.width / 2,\n        y: parent.center.y - childNodeSize.height / 2,\n      },\n      {\n        x: parent.center.x - childNodeSize.width / 2,\n        y: parent.center.y + childNodeSize.height / 2,\n      },\n      {\n        x: parent.center.x + childNodeSize.width / 2,\n        y: parent.center.y + childNodeSize.height / 2,\n      },\n    ]\n\n    for (const position of childNodePositions) {\n      const childNode = this.createChildNodeAtPosition(parent, {\n        center: position,\n        width: childNodeSize.width,\n        height: childNodeSize.height,\n        availableZ: parent.availableZ,\n      })\n      if (this.isNodeCompletelyOutsideBounds(childNode)) {\n        continue\n      }\n      childNodes.push(childNode)\n    }\n\n    return childNodes\n  }\n\n  shouldNodeBeXYSubdivided(node: CapacityMeshNode) {\n    if (node._depth! >= this.MAX_DEPTH) return false\n    if (node._containsTarget) return true\n    if (node.availableZ.length === 1 && node._depth! <= this.MAX_DEPTH)\n      return true\n    if (node._containsObstacle && !node._completelyInsideObstacle) return true\n    return false\n  }\n\n  _step() {\n    const nextNode = this.unfinishedNodes.pop()\n    if (!nextNode) {\n      this.solved = true\n      return\n    }\n\n    const childNodes = this.getChildNodes(nextNode)\n\n    const finishedNewNodes: CapacityMeshNode[] = []\n    const unfinishedNewNodes: CapacityMeshNode[] = []\n\n    for (const childNode of childNodes) {\n      const shouldBeXYSubdivided = this.shouldNodeBeXYSubdivided(childNode)\n      const shouldBeZSubdivided =\n        childNode.availableZ.length > 1 &&\n        !shouldBeXYSubdivided &&\n        (childNode._containsObstacle ||\n          childNode.width < this.VIA_DIAMETER + this.OBSTACLE_MARGIN)\n      if (shouldBeXYSubdivided) {\n        unfinishedNewNodes.push(childNode)\n      } else if (\n        !shouldBeXYSubdivided &&\n        !childNode._containsObstacle &&\n        !shouldBeZSubdivided\n      ) {\n        finishedNewNodes.push(childNode)\n      } else if (!shouldBeXYSubdivided && childNode._containsTarget) {\n        if (shouldBeZSubdivided) {\n          const zSubNodes = this.getZSubdivisionChildNodes(childNode)\n          finishedNewNodes.push(\n            ...zSubNodes.filter(\n              (n) => n._containsTarget || !n._containsObstacle,\n            ),\n          )\n        } else {\n          finishedNewNodes.push(childNode)\n        }\n      } else if (shouldBeZSubdivided) {\n        finishedNewNodes.push(\n          ...this.getZSubdivisionChildNodes(childNode).filter(\n            (zSubNode) => !zSubNode._containsObstacle,\n          ),\n        )\n      }\n    }\n\n    this.unfinishedNodes.push(...unfinishedNewNodes)\n    this.finishedNodes.push(...finishedNewNodes)\n  }\n}\n","import type { CapacityMeshEdge, CapacityMeshNodeId } from \"../../types\"\n\nexport function getNodeEdgeMap(\n  edges: CapacityMeshEdge[],\n): Map<CapacityMeshNodeId, CapacityMeshEdge[]> {\n  const nodeEdgeMap = new Map<CapacityMeshNodeId, CapacityMeshEdge[]>()\n\n  for (const edge of edges) {\n    for (const nodeId of edge.nodeIds) {\n      nodeEdgeMap.set(nodeId, [...(nodeEdgeMap.get(nodeId) ?? []), edge])\n    }\n  }\n\n  return nodeEdgeMap\n}\n","import type { GraphicsObject } from \"graphics-debug\"\nimport type {\n  CapacityMeshEdge,\n  CapacityMeshNode,\n  CapacityMeshNodeId,\n  CapacityPath,\n} from \"../../types\"\nimport type { NodePortSegment } from \"../../types/capacity-edges-to-port-segments-types\"\nimport { BaseSolver } from \"../BaseSolver\"\nimport { getNodeEdgeMap } from \"./getNodeEdgeMap\"\nimport { safeTransparentize } from \"../colors\"\n\n/**\n * Each Node is a square. The capacity paths indicate the nodes the trace will\n * travel through. We want to find the \"Port Segment\" that each capacity path\n * will take for each node.\n */\nexport class CapacityEdgeToPortSegmentSolver extends BaseSolver {\n  nodes: CapacityMeshNode[]\n  edges: CapacityMeshEdge[]\n  capacityPaths: CapacityPath[]\n\n  nodeMap: Map<CapacityMeshNodeId, CapacityMeshNode>\n  nodeEdgeMap: Map<CapacityMeshNodeId, CapacityMeshEdge[]>\n\n  unprocessedNodeIds: CapacityMeshNodeId[]\n\n  nodePortSegments: Map<CapacityMeshNodeId, NodePortSegment[]>\n  colorMap: Record<string, string>\n\n  constructor({\n    nodes,\n    edges,\n    capacityPaths,\n    colorMap,\n  }: {\n    nodes: CapacityMeshNode[]\n    edges: CapacityMeshEdge[]\n    capacityPaths: CapacityPath[]\n    colorMap?: Record<string, string>\n  }) {\n    super()\n    this.nodes = nodes\n    this.edges = edges\n    this.nodeMap = new Map(nodes.map((node) => [node.capacityMeshNodeId, node]))\n    this.nodeEdgeMap = getNodeEdgeMap(edges)\n    this.capacityPaths = capacityPaths\n    this.colorMap = colorMap ?? {}\n\n    // We will be evaluating capacity paths\n    this.unprocessedNodeIds = [\n      ...new Set(capacityPaths.flatMap((path) => path.nodeIds)),\n    ]\n    this.nodePortSegments = new Map()\n  }\n\n  step() {\n    const nodeId = this.unprocessedNodeIds.pop()\n    if (!nodeId) {\n      this.solved = true\n      return\n    }\n\n    const pathsGoingThroughNode: Array<{\n      path: CapacityPath\n      indexOfNodeInPath: number\n    }> = []\n    for (const path of this.capacityPaths) {\n      const indexOfNodeInPath = path.nodeIds.indexOf(nodeId)\n      if (indexOfNodeInPath !== -1) {\n        pathsGoingThroughNode.push({ path, indexOfNodeInPath })\n      }\n    }\n\n    const node = this.nodeMap.get(nodeId)!\n    const nodePortSegments: NodePortSegment[] = []\n\n    for (const { path, indexOfNodeInPath } of pathsGoingThroughNode) {\n      const entryNodeId = path.nodeIds[indexOfNodeInPath - 1]\n      const exitNodeId = path.nodeIds[indexOfNodeInPath + 1]\n\n      for (const adjNodeId of [entryNodeId, exitNodeId]) {\n        const adjNode = this.nodeMap.get(adjNodeId)!\n        if (!adjNode) continue\n        const segment = findOverlappingSegment(node, adjNode)\n\n        const mutuallyAvailableZ = adjNode.availableZ.filter((z) =>\n          node.availableZ.includes(z),\n        )\n\n        if (mutuallyAvailableZ.length === 0) continue\n\n        const portSegment: NodePortSegment = {\n          capacityMeshNodeId: nodeId,\n          start: segment.start,\n          end: segment.end,\n          connectionNames: [path.connectionName],\n          availableZ: mutuallyAvailableZ,\n        }\n\n        nodePortSegments.push(portSegment)\n      }\n    }\n\n    // Combine overlapping or adjacent segments on the same edge.\n    const combinedSegments = combineSegments(nodePortSegments)\n    this.nodePortSegments.set(nodeId, combinedSegments)\n  }\n\n  visualize(): GraphicsObject {\n    const graphics: GraphicsObject = {\n      lines: [],\n      points: [],\n      rects: [],\n      circles: [],\n    }\n    this.nodePortSegments.forEach((segments, nodeId) => {\n      const node = this.nodeMap.get(nodeId)!\n      segments.forEach((segment) => {\n        const isVertical = segment.start.x === segment.end.x\n        const THICKNESS = 0.05\n        for (let i = 0; i < segment.connectionNames.length; i++) {\n          const offset = {\n            x: 0.05 * Math.max(...segment.availableZ),\n            y: 0.05 * Math.max(...segment.availableZ),\n          }\n          const trueSegmentCenter = {\n            x: (segment.start.x + segment.end.x) / 2,\n            y: (segment.start.y + segment.end.y) / 2,\n          }\n          const segmentCenter = {\n            x: trueSegmentCenter.x + offset.x,\n            y: trueSegmentCenter.y + offset.y,\n          }\n          if (offset.x > 0) {\n            // small dashed line to show the true center\n            graphics.lines!.push({\n              points: [trueSegmentCenter, segmentCenter],\n              strokeColor: \"rgba(0, 0, 0, 0.25)\",\n              strokeDash: \"5 5\",\n            })\n          }\n          graphics.points!.push({\n            x: segmentCenter.x,\n            y: segmentCenter.y,\n            label: `${nodeId}: ${segment.connectionNames.join(\", \")}\\navailableZ: ${segment.availableZ.join(\",\")}\\nnodePortSegmentId: ${segment.nodePortSegmentId!}`,\n          })\n          graphics.lines!.push({\n            points: [segment.start, segment.end],\n            strokeColor: safeTransparentize(\n              this.colorMap[segment.connectionNames[i]],\n              0.6,\n            ),\n          })\n        }\n      })\n    })\n    return graphics\n  }\n}\n\nfunction findOverlappingSegment(\n  node: CapacityMeshNode,\n  adjNode: CapacityMeshNode,\n): { start: { x: number; y: number }; end: { x: number; y: number } } {\n  // Find overlapping ranges in x and y dimensions\n  const xOverlap = {\n    start: Math.max(\n      node.center.x - node.width / 2,\n      adjNode.center.x - adjNode.width / 2,\n    ),\n    end: Math.min(\n      node.center.x + node.width / 2,\n      adjNode.center.x + adjNode.width / 2,\n    ),\n  }\n\n  const yOverlap = {\n    start: Math.max(\n      node.center.y - node.height / 2,\n      adjNode.center.y - adjNode.height / 2,\n    ),\n    end: Math.min(\n      node.center.y + node.height / 2,\n      adjNode.center.y + adjNode.height / 2,\n    ),\n  }\n\n  const xRange = xOverlap.end - xOverlap.start\n  const yRange = yOverlap.end - yOverlap.start\n\n  // If the x-range is smaller then the nodes touch vertically (common vertical edge).\n  if (xRange < yRange) {\n    // They are horizontally adjacent: shared vertical edge.\n    const x = (xOverlap.start + xOverlap.end) / 2\n    return {\n      start: { x, y: yOverlap.start },\n      end: { x, y: yOverlap.end },\n    }\n  } else {\n    // Otherwise, they are vertically adjacent: shared horizontal edge.\n    const y = (yOverlap.start + yOverlap.end) / 2\n    return {\n      start: { x: xOverlap.start, y },\n      end: { x: xOverlap.end, y },\n    }\n  }\n}\n\nconst EPSILON = 1e-9 // Adjust threshold as needed\n\nfunction coordsAreEqual(\n  p1: { x: number; y: number },\n  p2: { x: number; y: number },\n): boolean {\n  return Math.abs(p1.x - p2.x) < EPSILON && Math.abs(p1.y - p2.y) < EPSILON\n}\n\n// Helper to compare availableZ arrays (order matters for equality check here)\nfunction availableZAreEqual(zA1: number[], zA2: number[]): boolean {\n  if (zA1.length !== zA2.length) {\n    return false\n  }\n  // Assuming they are sorted or order matters for distinction\n  for (let i = 0; i < zA1.length; i++) {\n    if (zA1[i] !== zA2[i]) {\n      return false\n    }\n  }\n  return true\n}\n\n/**\n * Given a list of segments on a node, merge segments that are geometrically\n * identical (same start/end points, potentially swapped) AND share the exact\n * same availableZ list. Combines only their connection names.\n */\nfunction combineSegments(segments: NodePortSegment[]): NodePortSegment[] {\n  const mergedSegments: NodePortSegment[] = []\n  // Create copies to avoid modifying the original array during iteration\n  // Sort availableZ consistently within each segment copy first\n  const remainingSegments = segments.map((s) => ({\n    ...s,\n    connectionNames: [...s.connectionNames],\n    availableZ: [...s.availableZ].sort((a, b) => a - b), // Ensure Z is sorted for comparison\n  }))\n\n  while (remainingSegments.length > 0) {\n    const segmentUnderTest = remainingSegments.pop()!\n    let foundMatch = false\n\n    for (let i = 0; i < mergedSegments.length; i++) {\n      const mergedSegment = mergedSegments[i]\n\n      // Check 1: Geometric match (allowing for start/end swap)\n      const geometryMatch =\n        (coordsAreEqual(mergedSegment.start, segmentUnderTest.start) &&\n          coordsAreEqual(mergedSegment.end, segmentUnderTest.end)) ||\n        (coordsAreEqual(mergedSegment.start, segmentUnderTest.end) &&\n          coordsAreEqual(mergedSegment.end, segmentUnderTest.start))\n\n      // Check 2: availableZ match\n      const zMatch = availableZAreEqual(\n        mergedSegment.availableZ,\n        segmentUnderTest.availableZ,\n      )\n\n      if (geometryMatch && zMatch) {\n        // --- Merge Logic ---\n        // Combine connection names (ensuring uniqueness)\n        const currentConnections = new Set(mergedSegment.connectionNames)\n        segmentUnderTest.connectionNames.forEach((cn) =>\n          currentConnections.add(cn),\n        )\n        mergedSegment.connectionNames = Array.from(currentConnections)\n\n        // DO NOT merge availableZ - they must be identical to reach here.\n\n        foundMatch = true\n        break // Found a match for segmentUnderTest, move to next remaining\n      }\n    }\n\n    if (!foundMatch) {\n      // If no suitable match was found (different geometry OR different availableZ),\n      // add the segmentUnderTest as a new distinct merged segment.\n      mergedSegments.push(segmentUnderTest)\n    }\n  }\n  return mergedSegments\n}\n","import { BaseSolver } from \"../BaseSolver\"\nimport type { NodePortSegment } from \"../../types/capacity-edges-to-port-segments-types\"\nimport type { GraphicsObject, Line } from \"graphics-debug\"\nimport type { NodeWithPortPoints } from \"../../types/high-density-types\"\nimport type { CapacityMeshNode, CapacityMeshNodeId } from \"lib/types\"\n\nexport interface SegmentWithAssignedPoints extends NodePortSegment {\n  assignedPoints?: {\n    connectionName: string\n    point: { x: number; y: number; z: number }\n  }[]\n}\n\n/**\n * CapacitySegmentToPointSolver:\n *\n * In each step, the solver iterates over all unsolved segments (segments\n * without points assigned for each connection). For each segment:\n *\n * - If there is only one connection, it assigns the center as the point.\n * - If there are two connections, it attempts to determine the ordering using\n *   other segments within the node. If no ordering can be determined, it does nothing.\n *\n * If an iteration produces no new assignments, the solver picks the segment with\n * the fewest connections and assigns points evenly spaced along the segment,\n * ordering them alphabetically.\n */\nexport class CapacitySegmentToPointSolver extends BaseSolver {\n  unsolvedSegments: SegmentWithAssignedPoints[]\n  solvedSegments: (NodePortSegment & {\n    assignedPoints: {\n      connectionName: string\n      point: { x: number; y: number; z: number }\n    }[]\n  })[]\n  nodeMap: Record<string, CapacityMeshNode>\n  colorMap: Record<string, string>\n\n  // We use an extra property on segments to remember assigned points.\n  // Each segment will get an added property \"assignedPoints\" which is an array of:\n  // { connectionName: string, point: {x: number, y: number } }\n  // This is a temporary extension used by the solver.\n  constructor({\n    segments,\n    colorMap,\n    nodes,\n  }: {\n    segments: NodePortSegment[]\n    colorMap?: Record<string, string>\n    /**\n     * This isn't used by the algorithm, but allows associating metadata\n     * for the result datatype (the center, width, height of the node)\n     */\n    nodes: CapacityMeshNode[]\n  }) {\n    super()\n    this.MAX_ITERATIONS = 100_000\n    this.unsolvedSegments = segments\n    this.solvedSegments = []\n    this.colorMap = colorMap ?? {}\n    this.nodeMap = Object.fromEntries(\n      nodes.map((node) => [node.capacityMeshNodeId, node]),\n    )\n  }\n\n  /**\n   * Perform one iteration step.\n   */\n  _step() {\n    let updated = false\n    // unsolved segments: segments without complete assignments.\n    const unsolved = [...this.unsolvedSegments]\n\n    // Iterate over unsolved segments.\n    for (const seg of unsolved) {\n      const n = seg.connectionNames.length\n      // Already processed? Skip if assignedPoints exists for all connections.\n      if (\"assignedPoints\" in seg && seg.assignedPoints?.length === n) continue\n\n      if (n === 1) {\n        // For a single connection, assign the center of the segment.\n        const center = {\n          x: (seg.start.x + seg.end.x) / 2,\n          y: (seg.start.y + seg.end.y) / 2,\n          z: seg.availableZ[0],\n        }\n        ;(seg as any).assignedPoints = [\n          { connectionName: seg.connectionNames[0], point: center },\n        ]\n        // Move seg from unsolvedSegments to solvedSegments.\n        this.unsolvedSegments.splice(this.unsolvedSegments.indexOf(seg), 1)\n        this.solvedSegments.push(seg as any)\n        updated = true\n      }\n    }\n\n    // If no segments were updated in this iteration, perform a fallback.\n    if (!updated && unsolved.length > 0) {\n      // Choose the unsolved segment with the fewest connections.\n      let candidate = unsolved[0]\n      for (const seg of unsolved) {\n        if (seg.connectionNames.length < candidate.connectionNames.length) {\n          candidate = seg\n        }\n      }\n      // Fallback: assign points evenly spaced along the segment,\n      // after sorting connection names alphabetically.\n      const sortedConnections = [...candidate.connectionNames].sort()\n      const dx = candidate.end.x - candidate.start.x\n      const dy = candidate.end.y - candidate.start.y\n      const n = sortedConnections.length\n      const points: { x: number; y: number; z: number }[] = []\n      // Evenly space positions using fractions of the segment distance.\n      for (let i = 1; i <= n; i++) {\n        const fraction = i / (n + 1)\n        points.push({\n          x: candidate.start.x + dx * fraction,\n          y: candidate.start.y + dy * fraction,\n          z: candidate.availableZ[0],\n        })\n      }\n      ;(candidate as any).assignedPoints = sortedConnections.map(\n        (conn, idx) => ({\n          connectionName: conn,\n          point: points[idx],\n        }),\n      )\n      // Move candidate from unsolvedSegments to solvedSegments.\n      this.unsolvedSegments.splice(this.unsolvedSegments.indexOf(candidate), 1)\n      this.solvedSegments.push(candidate as any)\n      updated = true\n    }\n\n    // If all segments have been assigned points, mark solved.\n    if (this.unsolvedSegments.length === 0) {\n      this.solved = true\n    }\n  }\n\n  /**\n   * Return the assigned points for each segment.\n   */\n  getNodesWithPortPoints(): NodeWithPortPoints[] {\n    if (!this.solved) {\n      throw new Error(\n        \"CapacitySegmentToPointSolver not solved, can't give port points yet\",\n      )\n    }\n    const map = new Map<string, NodeWithPortPoints>()\n    for (const seg of this.solvedSegments) {\n      const nodeId = seg.capacityMeshNodeId\n      const node = this.nodeMap[nodeId]\n      if (!map.has(nodeId)) {\n        map.set(nodeId, {\n          capacityMeshNodeId: nodeId,\n          portPoints: [],\n          center: node.center,\n          width: node.width,\n          height: node.height,\n        })\n      }\n      map.get(nodeId)!.portPoints.push(\n        ...seg.assignedPoints.map((ap) => ({\n          ...ap.point,\n          connectionName: ap.connectionName,\n        })),\n      )\n    }\n    return Array.from(map.values())\n  }\n\n  /**\n   * Return a GraphicsObject that visualizes the segments with assigned points.\n   */\n  visualize(): GraphicsObject {\n    const graphics: Required<GraphicsObject> = {\n      points: [],\n      lines: this.solvedSegments.map((seg) => ({\n        points: [seg.start, seg.end],\n        step: 4,\n      })),\n      rects: [],\n      circles: [],\n      coordinateSystem: \"cartesian\",\n      title: \"Capacity Segment to Point Solver\",\n    }\n\n    // Add points for each assigned point on solved segments\n    for (let i = 0; i < this.solvedSegments.length; i++) {\n      const seg = this.solvedSegments[i]\n      for (let j = 0; j < seg.assignedPoints.length; j++) {\n        const ap = seg.assignedPoints[j]\n\n        // Calculate the true position and the offset position (if z != 0)\n        const truePoint = {\n          x: ap.point.x,\n          y: ap.point.y,\n        }\n\n        const offsetPoint = {\n          x: ap.point.x + ap.point.z * 0.05,\n          y: ap.point.y + ap.point.z * 0.05,\n        }\n\n        // Add a dashed line to show the true position if there's an offset\n        if (ap.point.z !== 0) {\n          graphics.lines.push({\n            points: [truePoint, offsetPoint],\n            strokeColor: \"rgba(0, 0, 0, 0.25)\",\n            strokeDash: \"5 5\",\n            step: 4,\n          })\n        }\n\n        // Add the point with label\n        graphics.points.push({\n          x: offsetPoint.x,\n          y: offsetPoint.y,\n          label: [\n            `${seg.capacityMeshNodeId}-${ap.connectionName}`,\n            `z: ${seg.availableZ.join(\",\")}`,\n            `nodePortSegmentId: ${seg.nodePortSegmentId}`,\n          ].join(\"\\n\"),\n          color: this.colorMap[ap.connectionName],\n          step: 4,\n        })\n      }\n    }\n\n    // Add a dashed line connecting the assignment points with the same\n    // connection name within the same node\n    const dashedLines: Line[] = []\n    const nodeConnections: Record<\n      CapacityMeshNodeId,\n      Record<string, { x: number; y: number }[]>\n    > = {}\n    for (const seg of this.solvedSegments) {\n      const nodeId = seg.capacityMeshNodeId\n      if (!nodeConnections[nodeId]) {\n        nodeConnections[nodeId] = {}\n      }\n      for (const ap of seg.assignedPoints) {\n        if (!nodeConnections[nodeId][ap.connectionName]) {\n          nodeConnections[nodeId][ap.connectionName] = []\n        }\n        nodeConnections[nodeId][ap.connectionName].push({\n          x: ap.point.x,\n          y: ap.point.y,\n        })\n      }\n    }\n    for (const nodeId in nodeConnections) {\n      for (const conn in nodeConnections[nodeId]) {\n        const points = nodeConnections[nodeId][conn]\n        if (points.length > 1) {\n          dashedLines.push({\n            points,\n            step: 4,\n            strokeDash: \"5 5\",\n            strokeColor: this.colorMap[conn] || \"#000\",\n          } as Line)\n        }\n      }\n    }\n    graphics.lines.push(...(dashedLines as any))\n\n    return graphics\n  }\n}\n","import type { Point } from \"./common\"\n\n/**\n * Returns true if the two lines intersect.\n */\nexport function doesLineIntersectLine(\n  [a1, a2]: [Point, Point],\n  [b1, b2]: [Point, Point],\n  {\n    lineThickness = 0,\n  }: {\n    lineThickness?: number\n  } = {},\n): boolean {\n  if (lineThickness === 0) {\n    return doSegmentsIntersect(a1, a2, b1, b2)\n  }\n  const minDist = segmentsDistance(a1, a2, b1, b2)\n  return minDist <= lineThickness\n}\n\n/**\n * Returns true if the two segments intersect.\n */\nexport function doSegmentsIntersect(\n  p1: Point,\n  q1: Point,\n  p2: Point,\n  q2: Point,\n): boolean {\n  const o1 = orientation(p1, q1, p2)\n  const o2 = orientation(p1, q1, q2)\n  const o3 = orientation(p2, q2, p1)\n  const o4 = orientation(p2, q2, q1)\n\n  // General case\n  if (o1 !== o2 && o3 !== o4) {\n    return true\n  }\n\n  // Special Cases\n  if (o1 === 0 && onSegment(p1, p2, q1)) return true\n  if (o2 === 0 && onSegment(p1, q2, q1)) return true\n  if (o3 === 0 && onSegment(p2, p1, q2)) return true\n  if (o4 === 0 && onSegment(p2, q1, q2)) return true\n\n  return false\n}\n\n/**\n * Returns 0 if the points are colinear, 1 if they are clockwise, and 2 if they are counterclockwise.\n */\nexport function orientation(p: Point, q: Point, r: Point): number {\n  const val = (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y)\n  if (val === 0) return 0 // colinear\n  return val > 0 ? 1 : 2 // clock or counterclock wise\n}\n\n/**\n * Returns true if q is on the segment p->r.\n */\nexport function onSegment(p: Point, q: Point, r: Point): boolean {\n  return (\n    q.x <= Math.max(p.x, r.x) &&\n    q.x >= Math.min(p.x, r.x) &&\n    q.y <= Math.max(p.y, r.y) &&\n    q.y >= Math.min(p.y, r.y)\n  )\n}\n\n/**\n * Returns the minimum distance between two segments.\n */\nfunction segmentsDistance(a1: Point, a2: Point, b1: Point, b2: Point): number {\n  // Handle degenerate cases: segments of zero length\n  if (a1.x === a2.x && a1.y === a2.y) {\n    return pointToSegmentDistance(a1, b1, b2)\n  }\n  if (b1.x === b2.x && b1.y === b2.y) {\n    return pointToSegmentDistance(b1, a1, a2)\n  }\n\n  // Check if segments intersect\n  if (doSegmentsIntersect(a1, a2, b1, b2)) {\n    return 0\n  }\n\n  // Compute the minimum distance between the segments\n  const distances = [\n    pointToSegmentDistance(a1, b1, b2),\n    pointToSegmentDistance(a2, b1, b2),\n    pointToSegmentDistance(b1, a1, a2),\n    pointToSegmentDistance(b2, a1, a2),\n  ]\n\n  return Math.min(...distances)\n}\n\n/**\n * Returns the minimum distance between a point and a segment.\n */\nexport function pointToSegmentDistance(p: Point, v: Point, w: Point): number {\n  const l2 = (w.x - v.x) ** 2 + (w.y - v.y) ** 2\n  if (l2 === 0) return distance(p, v)\n\n  let t = ((p.x - v.x) * (w.x - v.x) + (p.y - v.y) * (w.y - v.y)) / l2\n  t = Math.max(0, Math.min(1, t))\n\n  const projection = {\n    x: v.x + t * (w.x - v.x),\n    y: v.y + t * (w.y - v.y),\n  }\n\n  return distance(p, projection)\n}\n\n/**\n * Returns the distance between two points.\n */\nexport function distance(p1: Point, p2: Point): number {\n  const dx = p1.x - p2.x\n  const dy = p1.y - p2.y\n  return Math.sqrt(dx * dx + dy * dy)\n}\n\n/**\n * Calculates the intersection point of two line segments.\n * Returns the intersection point {x, y} if the segments intersect, otherwise returns null.\n */\nexport function getSegmentIntersection(\n  a: Point,\n  b: Point,\n  u: Point,\n  v: Point,\n): Point | null {\n  const dx1 = b.x - a.x\n  const dy1 = b.y - a.y\n  const dx2 = v.x - u.x\n  const dy2 = v.y - u.y\n  const dx3 = a.x - u.x\n  const dy3 = a.y - u.y\n\n  const denominator = dx1 * dy2 - dy1 * dx2\n\n  // Check if lines are parallel or collinear\n  if (Math.abs(denominator) < 1e-10) {\n    // Lines are parallel or collinear\n    // We could add checks for collinear overlapping segments if needed,\n    // but for now, we return null as a single intersection point doesn't exist.\n    // The doSegmentsIntersect function handles collinearity checks if only a boolean is needed.\n    return null\n  }\n\n  // Correct formula for t (parameter for segment ab)\n  // t = (dy3 * dx2 - dx3 * dy2) / denominator\n  // The formula previously used was -(dy3 * dx2 - dx3 * dy2) / denominator\n  const t = (dy3 * dx2 - dx3 * dy2) / denominator\n  // Correct formula for s (parameter for segment uv)\n  // s = (dx1 * dy3 - dy1 * dx3) / denominator\n  // The formula previously used was incorrect.\n  const s = (dx1 * dy3 - dy1 * dx3) / denominator\n\n  // Check if the intersection point lies within both segments\n  // Use a small epsilon for floating point comparisons near 0 and 1\n  const epsilon = 1e-9\n  if (t >= -epsilon && t <= 1 + epsilon && s >= -epsilon && s <= 1 + epsilon) {\n    const intersectionX = a.x + t * dx1\n    const intersectionY = a.y + t * dy1\n    return { x: intersectionX, y: intersectionY }\n  }\n\n  // Segments do not intersect within their bounds\n  return null\n}\n","import type { Point } from \"./common\"\n\nexport type Box = { center: Point; width: number; height: number }\nexport type BoxSet = Box[]\n\nexport type GridCell = { boxes: Box[] }\n\nexport function getBoundingBox(box: Box) {\n  const halfWidth = box.width / 2\n  const halfHeight = box.height / 2\n  return {\n    minX: box.center.x - halfWidth,\n    maxX: box.center.x + halfWidth,\n    minY: box.center.y - halfHeight,\n    maxY: box.center.y + halfHeight,\n  }\n}\n\nexport function computeDistanceBetweenBoxes(\n  boxA: Box,\n  boxB: Box,\n): { distance: number; pointA: Point; pointB: Point } {\n  const a = getBoundingBox(boxA)\n  const b = getBoundingBox(boxB)\n\n  const dx = Math.max(a.minX - b.maxX, b.minX - a.maxX, 0)\n  const dy = Math.max(a.minY - b.maxY, b.minY - a.maxY, 0)\n\n  const pointA: Point = { x: 0, y: 0 }\n  const pointB: Point = { x: 0, y: 0 }\n\n  if (dx === 0 && dy === 0) {\n    // Boxes overlap\n    return { distance: 0, pointA: boxA.center, pointB: boxB.center }\n  }\n\n  // Compute the closest points on the edges\n  pointA.x = clamp(boxA.center.x, b.minX, b.maxX)\n  pointA.y = clamp(boxA.center.y, b.minY, b.maxY)\n\n  pointB.x = clamp(boxB.center.x, a.minX, a.maxX)\n  pointB.y = clamp(boxB.center.y, a.minY, a.maxY)\n\n  const distance = Math.hypot(pointA.x - pointB.x, pointA.y - pointB.y)\n  return { distance, pointA, pointB }\n}\n\nexport function clamp(value: number, min: number, max: number): number {\n  return Math.max(min, Math.min(max, value))\n}\n\nexport function findNearestPointsBetweenBoxSets(\n  boxSetA: BoxSet,\n  boxSetB: BoxSet,\n): { pointA: Point; pointB: Point; distance: number } {\n  let minDistance = Number.POSITIVE_INFINITY\n  let nearestPointA: Point = { x: 0, y: 0 }\n  let nearestPointB: Point = { x: 0, y: 0 }\n\n  for (const boxA of boxSetA) {\n    for (const boxB of boxSetB) {\n      const { distance, pointA, pointB } = computeDistanceBetweenBoxes(\n        boxA,\n        boxB,\n      )\n      if (distance < minDistance) {\n        minDistance = distance\n        nearestPointA = pointA\n        nearestPointB = pointB\n      }\n    }\n  }\n\n  return {\n    pointA: nearestPointA,\n    pointB: nearestPointB,\n    distance: minDistance,\n  }\n}\n","import type { Point } from \"./common\"\nimport {\n  distance,\n  doSegmentsIntersect,\n  pointToSegmentDistance,\n} from \"./line-intersections\"\nimport { clamp } from \"./nearest-box\"\n\n/**\n * Returns the minimum distance between two line segments.\n */\nexport function segmentToSegmentMinDistance(\n  a: Point,\n  b: Point,\n  u: Point,\n  v: Point,\n): number {\n  // Handle degenerate cases: segments of zero length\n  if (a.x === b.x && a.y === b.y) {\n    return pointToSegmentDistance(a, u, v)\n  }\n  if (u.x === v.x && u.y === v.y) {\n    return pointToSegmentDistance(u, a, b)\n  }\n\n  // Check if segments intersect\n  if (doSegmentsIntersect(a, b, u, v)) {\n    return 0\n  }\n\n  // Compute the minimum distance between the segments\n  const distances = [\n    pointToSegmentDistance(a, u, v),\n    pointToSegmentDistance(b, u, v),\n    pointToSegmentDistance(u, a, b),\n    pointToSegmentDistance(v, a, b),\n  ]\n\n  return Math.min(...distances)\n}\n\n/**\n * Returns the minimum distance from a line segment to a bounding box.\n */\nexport function segmentToBoundsMinDistance(\n  a: Point,\n  b: Point,\n  bounds: { minX: number; minY: number; maxX: number; maxY: number },\n): number {\n  // Check if segment intersects with the bounds\n  // Create the four edges of the bounds\n  const topLeft = { x: bounds.minX, y: bounds.minY }\n  const topRight = { x: bounds.maxX, y: bounds.minY }\n  const bottomLeft = { x: bounds.minX, y: bounds.maxY }\n  const bottomRight = { x: bounds.maxX, y: bounds.maxY }\n\n  // Check if segment intersects with any of the bounds edges\n  if (\n    doSegmentsIntersect(a, b, topLeft, topRight) ||\n    doSegmentsIntersect(a, b, topRight, bottomRight) ||\n    doSegmentsIntersect(a, b, bottomRight, bottomLeft) ||\n    doSegmentsIntersect(a, b, bottomLeft, topLeft)\n  ) {\n    return 0\n  }\n\n  // Check if segment is entirely inside the bounds\n  if (\n    a.x >= bounds.minX &&\n    a.x <= bounds.maxX &&\n    a.y >= bounds.minY &&\n    a.y <= bounds.maxY &&\n    b.x >= bounds.minX &&\n    b.x <= bounds.maxX &&\n    b.y >= bounds.minY &&\n    b.y <= bounds.maxY\n  ) {\n    return 0\n  }\n\n  // If not intersecting, calculate the minimum distance\n  const distances = [\n    pointToSegmentDistance(topLeft, a, b),\n    pointToSegmentDistance(topRight, a, b),\n    pointToSegmentDistance(bottomLeft, a, b),\n    pointToSegmentDistance(bottomRight, a, b),\n  ]\n\n  // If one of the segment endpoints is inside the bounds, we need to consider its distance to the bounds as 0\n  if (\n    a.x >= bounds.minX &&\n    a.x <= bounds.maxX &&\n    a.y >= bounds.minY &&\n    a.y <= bounds.maxY\n  ) {\n    return 0\n  }\n\n  if (\n    b.x >= bounds.minX &&\n    b.x <= bounds.maxX &&\n    b.y >= bounds.minY &&\n    b.y <= bounds.maxY\n  ) {\n    return 0\n  }\n\n  // Calculate distances from segment endpoints to bounds if outside\n  if (\n    a.x < bounds.minX ||\n    a.x > bounds.maxX ||\n    a.y < bounds.minY ||\n    a.y > bounds.maxY\n  ) {\n    const closestX = clamp(a.x, bounds.minX, bounds.maxX)\n    const closestY = clamp(a.y, bounds.minY, bounds.maxY)\n    distances.push(distance(a, { x: closestX, y: closestY }))\n  }\n\n  if (\n    b.x < bounds.minX ||\n    b.x > bounds.maxX ||\n    b.y < bounds.minY ||\n    b.y > bounds.maxY\n  ) {\n    const closestX = clamp(b.x, bounds.minX, bounds.maxX)\n    const closestY = clamp(b.y, bounds.minY, bounds.maxY)\n    distances.push(distance(b, { x: closestX, y: closestY }))\n  }\n\n  return Math.min(...distances)\n}\n\n/**\n * Returns the minimum distance from a line segment to a box.\n */\nexport function segmentToBoxMinDistance(\n  a: Point,\n  b: Point,\n  box: { center: Point; width: number; height: number },\n): number {\n  const halfWidth = box.width / 2\n  const halfHeight = box.height / 2\n  const bounds = {\n    minX: box.center.x - halfWidth,\n    maxX: box.center.x + halfWidth,\n    minY: box.center.y - halfHeight,\n    maxY: box.center.y + halfHeight,\n  }\n\n  return segmentToBoundsMinDistance(a, b, bounds)\n}\n\n/**\n * Returns the minimum distance from a line segment to a circle.\n */\nexport function segmentToCircleMinDistance(\n  a: Point,\n  b: Point,\n  circle: { x: number; y: number; radius: number },\n): number {\n  // Calculate the distance from the circle center to the line segment\n  const circleCenter = { x: circle.x, y: circle.y }\n\n  // Handle degenerate case: segment of zero length (point to circle)\n  if (a.x === b.x && a.y === b.y) {\n    return Math.max(0, distance(a, circleCenter) - circle.radius)\n  }\n\n  // Vector from a to b\n  const ab = { x: b.x - a.x, y: b.y - a.y }\n  // Vector from a to circle center\n  const ac = { x: circleCenter.x - a.x, y: circleCenter.y - a.y }\n\n  // Length of segment ab squared\n  const abLengthSq = ab.x * ab.x + ab.y * ab.y\n\n  // Calculate projection of ac onto ab, normalized by the length of ab\n  const t = Math.max(0, Math.min(1, (ab.x * ac.x + ab.y * ac.y) / abLengthSq))\n\n  // Find the closest point on the segment to the circle center\n  const closestPoint = {\n    x: a.x + t * ab.x,\n    y: a.y + t * ab.y,\n  }\n\n  // Calculate distance from closest point to circle center\n  const distToCenter = distance(closestPoint, circleCenter)\n\n  // Return the distance to the circle (subtract radius from distance to center)\n  return Math.max(0, distToCenter - circle.radius)\n}\n\nexport function pointToSegmentClosestPoint(\n  p: Point,\n  a: Point,\n  b: Point,\n): Point {\n  const dx_ab = b.x - a.x\n  const dy_ab = b.y - a.y\n  const l2 = dx_ab * dx_ab + dy_ab * dy_ab\n\n  if (l2 === 0) return { x: a.x, y: a.y } // Segment is a point\n\n  // Project p onto the line defined by a, b\n  // t = [(p - a) . (b - a)] / |b - a|^2\n  let t = ((p.x - a.x) * dx_ab + (p.y - a.y) * dy_ab) / l2\n\n  // Clamp t to the range [0, 1] to stay on the segment\n  t = Math.max(0, Math.min(1, t))\n\n  // Calculate the projection point\n  const closestPoint = {\n    x: a.x + t * dx_ab,\n    y: a.y + t * dy_ab,\n  }\n\n  return closestPoint\n}\n","import type { Point, Bounds } from \"./common\"\nimport { distance } from \"./line-intersections\"\nimport { clamp } from \"./nearest-box\"\nimport type { Box } from \"./nearest-box\"\n\n/**\n * Returns the minimum distance from a point to a box.\n * If the point is inside the box, the distance is 0.\n */\nexport function pointToBoxDistance(p: Point, box: Box): number {\n  const halfWidth = box.width / 2\n  const halfHeight = box.height / 2\n  const minX = box.center.x - halfWidth\n  const maxX = box.center.x + halfWidth\n  const minY = box.center.y - halfHeight\n  const maxY = box.center.y + halfHeight\n\n  // Check if the point is inside the box\n  if (p.x >= minX && p.x <= maxX && p.y >= minY && p.y <= maxY) {\n    return 0\n  }\n\n  // Find the closest point on the box boundary\n  const closestX = clamp(p.x, minX, maxX)\n  const closestY = clamp(p.y, minY, maxY)\n\n  // Calculate the distance to the closest point\n  return distance(p, { x: closestX, y: closestY })\n}\n\n/**\n * Returns the minimum distance from a point to a bounds rectangle.\n * If the point is inside the bounds, the distance is 0.\n */\nexport function pointToBoundsDistance(p: Point, bounds: Bounds): number {\n  // Check if the point is inside the bounds\n  if (\n    p.x >= bounds.minX &&\n    p.x <= bounds.maxX &&\n    p.y >= bounds.minY &&\n    p.y <= bounds.maxY\n  ) {\n    return 0\n  }\n\n  // Find the closest point on the bounds boundary\n  const closestX = clamp(p.x, bounds.minX, bounds.maxX)\n  const closestY = clamp(p.y, bounds.minY, bounds.maxY)\n\n  // Calculate the distance to the closest point\n  return distance(p, { x: closestX, y: closestY })\n}\n\nexport function midpoint(p1: Point, p2: Point): Point {\n  return {\n    x: (p1.x + p2.x) / 2,\n    y: (p1.y + p2.y) / 2,\n  }\n}\n\nexport function distSq(p1: Point, p2: Point): number {\n  const dx = p1.x - p2.x\n  const dy = p1.y - p2.y\n  return dx * dx + dy * dy\n}\n","export type Node = {\n  x: number\n  y: number\n  z: number\n\n  g: number\n  h: number\n  f: number\n\n  parent: Node | null\n}\n\nexport class SingleRouteCandidatePriorityQueue<T extends Node = Node> {\n  private heap: T[] = []\n\n  constructor(nodes: T[]) {\n    this.heap = []\n\n    for (const node of nodes) {\n      this.enqueue(node)\n    }\n  }\n\n  private getLeftChildIndex(parentIndex: number): number {\n    return 2 * parentIndex + 1\n  }\n\n  private getRightChildIndex(parentIndex: number): number {\n    return 2 * parentIndex + 2\n  }\n\n  private getParentIndex(childIndex: number) {\n    return Math.floor((childIndex - 1) / 2)\n  }\n\n  private hasLeftChild(index: number): boolean {\n    return this.getLeftChildIndex(index) < this.heap.length\n  }\n\n  private hasRightChild(index: number): boolean {\n    return this.getRightChildIndex(index) < this.heap.length\n  }\n\n  private hasParent(index: number): boolean {\n    return this.getParentIndex(index) >= 0\n  }\n\n  private leftChild(index: number): T {\n    return this.heap[this.getLeftChildIndex(index)]\n  }\n\n  private rightChild(index: number): T {\n    return this.heap[this.getRightChildIndex(index)]\n  }\n\n  private parent(index: number): T {\n    return this.heap[this.getParentIndex(index)]\n  }\n\n  private swap(i: number, j: number) {\n    const temp = this.heap[i]\n    this.heap[i] = this.heap[j]\n    this.heap[j] = temp\n  }\n\n  // Removing an element will remove the\n  // top element with highest priority then\n  // heapifyDown will be called\n  dequeue(): T | null {\n    if (this.heap.length === 0) {\n      return null\n    }\n    const item = this.heap[0]\n    this.heap[0] = this.heap[this.heap.length - 1]\n    this.heap.pop()\n    this.heapifyDown()\n    return item\n  }\n\n  peek(): T | null {\n    if (this.heap.length === 0) {\n      return null\n    }\n    return this.heap[0]\n  }\n\n  enqueue(item: T) {\n    this.heap.push(item)\n    this.heapifyUp()\n  }\n\n  heapifyUp() {\n    let index = this.heap.length - 1\n    while (this.hasParent(index) && this.parent(index).f > this.heap[index].f) {\n      this.swap(this.getParentIndex(index), index)\n      index = this.getParentIndex(index)\n    }\n  }\n\n  heapifyDown() {\n    let index = 0\n    while (this.hasLeftChild(index)) {\n      let smallerChildIndex = this.getLeftChildIndex(index)\n      if (\n        this.hasRightChild(index) &&\n        this.rightChild(index).f < this.leftChild(index).f\n      ) {\n        smallerChildIndex = this.getRightChildIndex(index)\n      }\n      if (this.heap[index].f < this.heap[smallerChildIndex].f) {\n        break\n      } else {\n        this.swap(index, smallerChildIndex)\n      }\n      index = smallerChildIndex\n    }\n  }\n}\n","import { BaseSolver } from \"../BaseSolver\"\nimport type { HighDensityIntraNodeRoute } from \"lib/types/high-density-types\"\nimport {\n  distance,\n  pointToSegmentDistance,\n  doSegmentsIntersect,\n} from \"@tscircuit/math-utils\"\nimport type { GraphicsObject } from \"graphics-debug\"\nimport { HighDensityHyperParameters } from \"./HighDensityHyperParameters\"\nimport { ConnectivityMap } from \"circuit-json-to-connectivity-map\"\nimport {\n  Node,\n  SingleRouteCandidatePriorityQueue,\n} from \"lib/data-structures/SingleRouteCandidatePriorityQueue\"\n\nexport type FutureConnection = {\n  connectionName: string\n  points: { x: number; y: number; z: number }[]\n}\n\nexport class SingleHighDensityRouteSolver extends BaseSolver {\n  obstacleRoutes: HighDensityIntraNodeRoute[]\n  bounds: { minX: number; maxX: number; minY: number; maxY: number }\n  boundsSize: { width: number; height: number }\n  boundsCenter: { x: number; y: number }\n  A: { x: number; y: number; z: number }\n  B: { x: number; y: number; z: number }\n  straightLineDistance: number\n\n  viaDiameter: number\n  traceThickness: number\n  obstacleMargin: number\n  layerCount: number\n  minCellSize = 0.05\n  cellStep = 0.05\n  GREEDY_MULTIPLER = 1.1\n  numRoutes: number\n\n  VIA_PENALTY_FACTOR = 0.3\n  CELL_SIZE_FACTOR: number\n\n  exploredNodes: Set<string>\n\n  candidates: SingleRouteCandidatePriorityQueue\n\n  connectionName: string\n  solvedPath: HighDensityIntraNodeRoute | null = null\n\n  futureConnections: FutureConnection[]\n  hyperParameters: Partial<HighDensityHyperParameters>\n\n  connMap?: ConnectivityMap\n\n  /** For debugging/animating the exploration */\n  debug_exploredNodesOrdered: string[]\n  debug_nodesTooCloseToObstacle: Set<string>\n  debug_nodePathToParentIntersectsObstacle: Set<string>\n\n  debugEnabled = true\n\n  initialNodeGridOffset: { x: number; y: number }\n\n  constructor(opts: {\n    connectionName: string\n    obstacleRoutes: HighDensityIntraNodeRoute[]\n    minDistBetweenEnteringPoints: number\n    bounds: { minX: number; maxX: number; minY: number; maxY: number }\n    A: { x: number; y: number; z: number }\n    B: { x: number; y: number; z: number }\n    viaDiameter?: number\n    traceThickness?: number\n    obstacleMargin?: number\n    layerCount?: number\n    futureConnections?: FutureConnection[]\n    hyperParameters?: Partial<HighDensityHyperParameters>\n    connMap?: ConnectivityMap\n  }) {\n    super()\n    this.bounds = opts.bounds\n    this.connMap = opts.connMap\n    this.hyperParameters = opts.hyperParameters ?? {}\n    this.CELL_SIZE_FACTOR = this.hyperParameters.CELL_SIZE_FACTOR ?? 1\n    this.boundsSize = {\n      width: this.bounds.maxX - this.bounds.minX,\n      height: this.bounds.maxY - this.bounds.minY,\n    }\n    this.boundsCenter = {\n      x: (this.bounds.minX + this.bounds.maxX) / 2,\n      y: (this.bounds.minY + this.bounds.maxY) / 2,\n    }\n    this.connectionName = opts.connectionName\n    this.obstacleRoutes = opts.obstacleRoutes\n    this.A = opts.A\n    this.B = opts.B\n    this.viaDiameter = opts.viaDiameter ?? 0.6\n    this.traceThickness = opts.traceThickness ?? 0.15\n    this.obstacleMargin = opts.obstacleMargin ?? 0.2\n    this.layerCount = opts.layerCount ?? 2\n    this.exploredNodes = new Set()\n    this.straightLineDistance = distance(this.A, this.B)\n    this.futureConnections = opts.futureConnections ?? []\n    this.MAX_ITERATIONS = 5000\n\n    this.debug_exploredNodesOrdered = []\n    this.debug_nodesTooCloseToObstacle = new Set()\n    this.debug_nodePathToParentIntersectsObstacle = new Set()\n    this.numRoutes = this.obstacleRoutes.length + this.futureConnections.length\n    const bestRowOrColumnCount = Math.ceil(5 * (this.numRoutes + 1))\n    let numXCells = this.boundsSize.width / this.cellStep\n    let numYCells = this.boundsSize.height / this.cellStep\n\n    while (numXCells * numYCells > bestRowOrColumnCount ** 2) {\n      if (this.cellStep * 2 > opts.minDistBetweenEnteringPoints) {\n        break\n      }\n      this.cellStep *= 2\n      numXCells = this.boundsSize.width / this.cellStep\n      numYCells = this.boundsSize.height / this.cellStep\n    }\n\n    this.cellStep *= this.CELL_SIZE_FACTOR\n\n    if (\n      this.futureConnections &&\n      this.futureConnections.length === 0 &&\n      this.obstacleRoutes.length === 0\n    ) {\n      this.handleSimpleCases()\n    }\n\n    const initialNodePosition = {\n      x: Math.round(opts.A.x / (this.cellStep / 2)) * (this.cellStep / 2),\n      y: Math.round(opts.A.y / (this.cellStep / 2)) * (this.cellStep / 2),\n    }\n    this.initialNodeGridOffset = {\n      x:\n        initialNodePosition.x -\n        Math.round(opts.A.x / this.cellStep) * this.cellStep,\n      y:\n        initialNodePosition.y -\n        Math.round(opts.A.y / this.cellStep) * this.cellStep,\n    }\n    this.candidates = new SingleRouteCandidatePriorityQueue([\n      {\n        ...opts.A,\n        ...initialNodePosition,\n        z: opts.A.z ?? 0,\n        g: 0,\n        h: 0,\n        f: 0,\n        parent: {\n          ...opts.A,\n          z: opts.A.z ?? 0,\n          g: 0,\n          h: 0,\n          f: 0,\n          parent: null,\n        },\n      },\n    ])\n  }\n\n  handleSimpleCases() {\n    this.solved = true\n    const { A, B } = this\n    const route =\n      A.z === B.z\n        ? [A, B]\n        : [\n            A,\n            { ...this.boundsCenter, z: this.A.z },\n            {\n              ...this.boundsCenter,\n              z: B.z,\n            },\n            B,\n          ]\n    this.solvedPath = {\n      connectionName: this.connectionName,\n      route,\n      traceThickness: this.traceThickness,\n      viaDiameter: this.viaDiameter,\n      vias: this.A.z === this.B.z ? [] : [this.boundsCenter],\n    }\n  }\n\n  get viaPenaltyDistance() {\n    return this.cellStep + this.straightLineDistance * this.VIA_PENALTY_FACTOR\n  }\n\n  isNodeTooCloseToObstacle(node: Node, margin?: number, isVia?: boolean) {\n    margin ??= this.obstacleMargin\n\n    if (isVia && node.parent) {\n      const viasInMyRoute = this.getViasInNodePath(node.parent)\n      for (const via of viasInMyRoute) {\n        if (distance(node, via) < this.viaDiameter / 2 + margin) {\n          return true\n        }\n      }\n    }\n\n    for (const route of this.obstacleRoutes) {\n      const connectedToObstacle = this.connMap?.areIdsConnected?.(\n        this.connectionName,\n        route.connectionName,\n      )\n\n      if (!connectedToObstacle) {\n        const pointPairs = getSameLayerPointPairs(route)\n        for (const pointPair of pointPairs) {\n          if (\n            (isVia || pointPair.z === node.z) &&\n            pointToSegmentDistance(node, pointPair.A, pointPair.B) <\n              this.traceThickness + margin\n          ) {\n            return true\n          }\n        }\n      }\n      for (const via of route.vias) {\n        if (\n          distance(node, via) <\n          this.viaDiameter / 2 + this.traceThickness / 2 + margin\n        ) {\n          return true\n        }\n      }\n    }\n\n    return false\n  }\n\n  isNodeTooCloseToEdge(node: Node, isVia?: boolean) {\n    const margin = isVia\n      ? this.viaDiameter / 2 + this.obstacleMargin / 2\n      : this.obstacleMargin / 2\n    const tooClose =\n      node.x < this.bounds.minX + margin ||\n      node.x > this.bounds.maxX - margin ||\n      node.y < this.bounds.minY + margin ||\n      node.y > this.bounds.maxY - margin\n    if (tooClose && !isVia) {\n      // If it's close to B or A it's an exception\n      if (\n        distance(node, this.B) < margin * 2 ||\n        distance(node, this.A) < margin * 2\n      ) {\n        return false\n      }\n    }\n    return tooClose\n  }\n\n  doesPathToParentIntersectObstacle(node: Node) {\n    const parent = node.parent\n    if (!parent) return false\n    for (const route of this.obstacleRoutes) {\n      const obstacleIsConnectedToNewPath = this.connMap?.areIdsConnected?.(\n        this.connectionName,\n        route.connectionName,\n      )\n      if (obstacleIsConnectedToNewPath) continue\n      for (const pointPair of getSameLayerPointPairs(route)) {\n        if (pointPair.z !== node.z) continue\n        if (doSegmentsIntersect(node, parent, pointPair.A, pointPair.B)) {\n          return true\n        }\n      }\n    }\n    return false\n  }\n\n  computeH(node: Node) {\n    return (\n      distance(node, this.B) +\n      // via penalty\n      Math.abs(node.z - this.B.z) * this.viaPenaltyDistance\n    )\n  }\n\n  computeG(node: Node) {\n    return (\n      (node.parent?.g ?? 0) +\n      (node.z === 0 ? 0 : this.viaPenaltyDistance) +\n      distance(node, node.parent!)\n    )\n  }\n\n  computeF(g: number, h: number) {\n    return g + h * this.GREEDY_MULTIPLER\n  }\n\n  getNodeKey(node: Node) {\n    return `${Math.round(node.x / this.cellStep) * this.cellStep},${Math.round(node.y / this.cellStep) * this.cellStep},${node.z}`\n  }\n\n  getNeighbors(node: Node) {\n    const neighbors: Node[] = []\n\n    const { maxX, minX, maxY, minY } = this.bounds\n\n    for (let x = -1; x <= 1; x++) {\n      for (let y = -1; y <= 1; y++) {\n        if (x === 0 && y === 0) continue\n\n        const neighbor = {\n          ...node,\n          parent: node,\n          x: clamp(node.x + x * this.cellStep, minX, maxX),\n          y: clamp(node.y + y * this.cellStep, minY, maxY),\n        }\n\n        const neighborKey = this.getNodeKey(neighbor)\n\n        if (this.exploredNodes.has(neighborKey)) {\n          continue\n        }\n\n        if (this.isNodeTooCloseToObstacle(neighbor)) {\n          this.debug_nodesTooCloseToObstacle.add(neighborKey)\n          this.exploredNodes.add(neighborKey)\n          continue\n        }\n\n        if (this.isNodeTooCloseToEdge(neighbor, false)) {\n          this.exploredNodes.add(neighborKey)\n          continue\n        }\n\n        if (this.doesPathToParentIntersectObstacle(neighbor)) {\n          this.debug_nodePathToParentIntersectsObstacle.add(neighborKey)\n          this.exploredNodes.add(neighborKey)\n          continue\n        }\n\n        neighbor.g = this.computeG(neighbor)\n        neighbor.h = this.computeH(neighbor)\n        neighbor.f = this.computeF(neighbor.g, neighbor.h)\n\n        neighbors.push(neighbor)\n      }\n    }\n\n    const viaNeighbor = {\n      ...node,\n      parent: node,\n      z: node.z === 0 ? this.layerCount - 1 : 0,\n    }\n\n    if (\n      !this.exploredNodes.has(this.getNodeKey(viaNeighbor)) &&\n      !this.isNodeTooCloseToObstacle(\n        viaNeighbor,\n        this.viaDiameter / 2 + this.obstacleMargin / 2,\n        true,\n      ) &&\n      !this.isNodeTooCloseToEdge(viaNeighbor, true)\n    ) {\n      viaNeighbor.g = this.computeG(viaNeighbor)\n      viaNeighbor.h = this.computeH(viaNeighbor)\n      viaNeighbor.f = this.computeF(viaNeighbor.g, viaNeighbor.h)\n\n      neighbors.push(viaNeighbor)\n    }\n\n    return neighbors\n  }\n\n  getNodePath(node: Node) {\n    const path: Node[] = []\n    while (node) {\n      path.push(node)\n      node = node.parent!\n    }\n    return path\n  }\n\n  getViasInNodePath(node: Node) {\n    const path = this.getNodePath(node)\n    const vias: { x: number; y: number }[] = []\n    for (let i = 0; i < path.length - 1; i++) {\n      if (path[i].z !== path[i + 1].z) {\n        vias.push({ x: path[i].x, y: path[i].y })\n      }\n    }\n    return vias\n  }\n\n  setSolvedPath(node: Node) {\n    const path = this.getNodePath(node)\n    path.reverse()\n\n    const vias: { x: number; y: number }[] = []\n    for (let i = 0; i < path.length - 1; i++) {\n      if (path[i].z !== path[i + 1].z) {\n        vias.push({ x: path[i].x, y: path[i].y })\n      }\n    }\n\n    this.solvedPath = {\n      connectionName: this.connectionName,\n      traceThickness: this.traceThickness,\n      viaDiameter: this.viaDiameter,\n      route: path\n        .map((node) => ({ x: node.x, y: node.y, z: node.z }))\n        .concat([this.B]),\n      vias,\n    }\n  }\n\n  computeProgress(currentNode: Node, goalDist: number, isOnLayer: boolean) {\n    if (!isOnLayer) goalDist += this.viaPenaltyDistance\n    const goalDistPercent = 1 - goalDist / this.straightLineDistance\n\n    // This is a perfectly acceptable progress metric\n    // return Math.max(this.progress || 0, goalDistPercent)\n\n    // Linearize because it typically gets harder towards the end\n    return Math.max(\n      this.progress || 0,\n      // 0.112 = ~90% -> 50%\n      //         ~25% -> 2%\n      //         ~99% -> 94%\n      //         ~95% -> 72%\n      (2 / Math.PI) *\n        Math.atan((0.112 * goalDistPercent) / (1 - goalDistPercent)),\n    )\n  }\n\n  _step() {\n    let currentNode = this.candidates.dequeue()\n    let currentNodeKey = currentNode ? this.getNodeKey(currentNode) : undefined\n\n    while (\n      currentNode &&\n      currentNodeKey &&\n      this.exploredNodes.has(currentNodeKey)\n    ) {\n      currentNode = this.candidates.dequeue()\n      currentNodeKey = currentNode ? this.getNodeKey(currentNode) : undefined\n    }\n\n    if (!currentNode || !currentNodeKey) {\n      this.failed = true\n      return\n    }\n    this.exploredNodes.add(currentNodeKey)\n    this.debug_exploredNodesOrdered.push(currentNodeKey)\n\n    const goalDist = distance(currentNode, this.B)\n\n    this.progress = this.computeProgress(\n      currentNode,\n      goalDist,\n      currentNode.z === this.B.z,\n    )\n\n    if (\n      goalDist <= this.cellStep * Math.SQRT2 &&\n      currentNode.z === this.B.z &&\n      // Make sure the last segment doesn't intersect an obstacle\n      !this.doesPathToParentIntersectObstacle({\n        ...currentNode,\n        parent: currentNode,\n        x: this.B.x,\n        y: this.B.y,\n      })\n    ) {\n      this.solved = true\n      this.setSolvedPath(currentNode)\n    }\n\n    const neighbors = this.getNeighbors(currentNode)\n    for (const neighbor of neighbors) {\n      this.candidates.enqueue(neighbor)\n    }\n  }\n\n  visualize(): GraphicsObject {\n    const graphics: GraphicsObject = {\n      lines: [],\n      points: [],\n      rects: [],\n      circles: [],\n    }\n\n    // Display the input port points (from nodeWithPortPoints via A and B)\n    graphics.points!.push({\n      x: this.A.x,\n      y: this.A.y,\n      label: `Input A\\nz: ${this.A.z}`,\n      color: \"orange\",\n    })\n    graphics.points!.push({\n      x: this.B.x,\n      y: this.B.y,\n      label: `Input B\\nz: ${this.B.z}`,\n      color: \"orange\",\n    })\n\n    // Draw circles at future connection points\n    // if (\"FUTURE_CONNECTION_PROXIMITY_VD\" in this) {\n    //   for (const futureConnection of this.futureConnections) {\n    //     for (const point of futureConnection.points) {\n    //       graphics.circles!.push({\n    //         center: point,\n    //         radius:\n    //           (this.viaDiameter *\n    //             (this.FUTURE_CONNECTION_PROXIMITY_VD as number)) /\n    //           2,\n    //         // strokeColor: \"rgba(0, 255, 0, 0.3)\",\n    //         stroke: \"rgba(0,255,0,0.1)\",\n    //         label: `Future Connection: ${futureConnection.connectionName}`,\n    //       })\n    //     }\n    //   }\n    //   // Draw circles around obstacle route points\n    //   for (const route of this.obstacleRoutes) {\n    //     for (const point of [\n    //       route.route[0],\n    //       route.route[route.route.length - 1],\n    //     ]) {\n    //       graphics.circles!.push({\n    //         center: point,\n    //         radius:\n    //           (this.viaDiameter *\n    //             (this.FUTURE_CONNECTION_PROXIMITY_VD as number)) /\n    //           2,\n    //         stroke: \"rgba(255,0,0,0.1)\",\n    //         label: \"Obstacle Route Point\",\n    //       })\n    //     }\n    //   }\n    // }\n\n    // Draw a line representing the direct connection between the input port points\n    graphics.lines!.push({\n      points: [this.A, this.B],\n      strokeColor: \"rgba(255, 0, 0, 0.5)\",\n      label: \"Direct Input Connection\",\n    })\n\n    // Show any obstacle routes as background references\n    for (\n      let routeIndex = 0;\n      routeIndex < this.obstacleRoutes.length;\n      routeIndex++\n    ) {\n      const route = this.obstacleRoutes[routeIndex]\n      for (let i = 0; i < route.route.length - 1; i++) {\n        const z = route.route[i].z\n        graphics.lines!.push({\n          points: [route.route[i], route.route[i + 1]],\n          strokeColor:\n            z === 0 ? \"rgba(255, 0, 0, 0.75)\" : \"rgba(255, 128, 0, 0.25)\",\n          strokeWidth: route.traceThickness,\n          label: \"Obstacle Route\",\n          layer: `obstacle${routeIndex.toString()}`,\n        })\n      }\n    }\n\n    // Optionally, visualize explored nodes for debugging purposes\n    for (let i = 0; i < this.debug_exploredNodesOrdered.length; i++) {\n      const nodeKey = this.debug_exploredNodesOrdered[i]\n      const [x, y, z] = nodeKey.split(\",\").map(Number)\n      if (this.debug_nodesTooCloseToObstacle.has(nodeKey)) continue\n      if (this.debug_nodePathToParentIntersectsObstacle.has(nodeKey)) continue\n      graphics.rects!.push({\n        center: {\n          x: x + this.initialNodeGridOffset.x + (z * this.cellStep) / 20,\n          y: y + this.initialNodeGridOffset.y + (z * this.cellStep) / 20,\n        },\n        fill:\n          z === 0\n            ? `rgba(255,0,255,${0.3 - (i / this.debug_exploredNodesOrdered.length) * 0.2})`\n            : `rgba(0,0,255,${0.3 - (i / this.debug_exploredNodesOrdered.length) * 0.2})`,\n        width: this.cellStep * 0.9,\n        height: this.cellStep * 0.9,\n        label: `Explored (z=${z})`,\n      })\n    }\n\n    // Visualize the next node to be explored\n    if (this.candidates.peek()) {\n      const nextNode = this.candidates.peek()!\n      graphics.rects!.push({\n        center: {\n          x: nextNode.x + (nextNode.z * this.cellStep) / 20,\n          y: nextNode.y + (nextNode.z * this.cellStep) / 20,\n        },\n        fill: \"rgba(0, 255, 0, 0.8)\",\n        width: this.cellStep * 0.9,\n        height: this.cellStep * 0.9,\n        label: `Next (z=${nextNode.z})`,\n      })\n    }\n\n    // Visualize vias from obstacle routes\n    for (const route of this.obstacleRoutes) {\n      for (const via of route.vias) {\n        graphics.circles!.push({\n          center: {\n            x: via.x,\n            y: via.y,\n          },\n          radius: this.viaDiameter / 2,\n          fill: \"rgba(255, 0, 0, 0.5)\",\n          label: \"Via\",\n        })\n      }\n    }\n    // If a solved route exists, display it along with via markers\n    if (this.solvedPath) {\n      graphics.lines!.push({\n        points: this.solvedPath.route,\n        strokeColor: \"green\",\n        label: \"Solved Route\",\n      })\n      for (const via of this.solvedPath.vias) {\n        graphics.circles!.push({\n          center: via,\n          radius: this.viaDiameter / 2,\n          fill: \"green\",\n          label: \"Via\",\n        })\n      }\n    }\n\n    return graphics\n  }\n}\n\nfunction getSameLayerPointPairs(route: HighDensityIntraNodeRoute) {\n  const pointPairs: {\n    z: number\n    A: { x: number; y: number; z: number }\n    B: { x: number; y: number; z: number }\n  }[] = []\n\n  for (let i = 0; i < route.route.length - 1; i++) {\n    if (route.route[i].z === route.route[i + 1].z) {\n      pointPairs.push({\n        z: route.route[i].z,\n        A: route.route[i],\n        B: route.route[i + 1],\n      })\n    }\n  }\n\n  return pointPairs\n}\n\nfunction clamp(value: number, min: number, max: number) {\n  return Math.max(min, Math.min(value, max))\n}\n","import { distance } from \"@tscircuit/math-utils\"\nimport { SingleHighDensityRouteSolver } from \"./SingleHighDensityRouteSolver\"\nimport { Node } from \"lib/data-structures/SingleRouteCandidatePriorityQueue\"\n\nexport class SingleHighDensityRouteSolver6_VertHorzLayer_FutureCost extends SingleHighDensityRouteSolver {\n  FUTURE_CONNECTION_PROX_TRACE_PENALTY_FACTOR = 2\n  FUTURE_CONNECTION_PROX_VIA_PENALTY_FACTOR = 1\n  FUTURE_CONNECTION_PROXIMITY_VD = 10\n  MISALIGNED_DIST_PENALTY_FACTOR = 5\n  VIA_PENALTY_FACTOR_2 = 1\n  FLIP_TRACE_ALIGNMENT_DIRECTION = false\n\n  constructor(\n    opts: ConstructorParameters<typeof SingleHighDensityRouteSolver>[0],\n  ) {\n    super(opts)\n    for (const key in opts.hyperParameters) {\n      // @ts-ignore\n      this[key] = opts.hyperParameters[key]\n    }\n\n    // Ratio of available space determines via penalty\n    const viasThatCanFitHorz = this.boundsSize.width / this.viaDiameter\n    this.VIA_PENALTY_FACTOR =\n      0.3 * (viasThatCanFitHorz / this.numRoutes) * this.VIA_PENALTY_FACTOR_2\n  }\n\n  getClosestFutureConnectionPoint(node: Node) {\n    let minDist = Infinity\n    let closestPoint = null\n\n    for (const futureConnection of this.futureConnections) {\n      for (const point of futureConnection.points) {\n        const dist =\n          distance(node, point) +\n          (node.z !== point.z ? this.viaPenaltyDistance : 0)\n        if (dist < minDist) {\n          minDist = dist\n          closestPoint = point\n        }\n      }\n    }\n\n    return closestPoint\n  }\n\n  /**\n   * Rapidly approaches 0 as the goal distance approaches 0\n   */\n  diminishCloseToGoal(node: Node) {\n    const goalDist = distance(node, this.B)\n    return 1 - Math.exp((-goalDist / this.straightLineDistance) * 5)\n  }\n\n  getFutureConnectionPenalty(node: Node, isVia: boolean) {\n    let futureConnectionPenalty = 0\n    const closestFuturePoint = this.getClosestFutureConnectionPoint(node)\n    const goalDist = distance(node, this.B)\n    if (closestFuturePoint) {\n      const distToFuturePoint = distance(node, closestFuturePoint)\n      if (goalDist <= distToFuturePoint) return 0\n      const maxDist = this.viaDiameter * this.FUTURE_CONNECTION_PROXIMITY_VD\n      const distRatio = distToFuturePoint / maxDist\n      const maxPenalty = isVia\n        ? this.straightLineDistance *\n          this.FUTURE_CONNECTION_PROX_VIA_PENALTY_FACTOR\n        : this.straightLineDistance *\n          this.FUTURE_CONNECTION_PROX_TRACE_PENALTY_FACTOR\n      futureConnectionPenalty = maxPenalty * Math.exp(-distRatio * 5)\n    }\n    return futureConnectionPenalty\n  }\n\n  computeH(node: Node) {\n    const goalDist = distance(node, this.B) ** 1.6\n    const goalDistRatio = goalDist / this.straightLineDistance\n\n    // Base cost from original function\n    const baseCost =\n      goalDist + (node.z !== this.B.z ? this.viaPenaltyDistance : 0)\n\n    return (\n      baseCost +\n      this.getFutureConnectionPenalty(node, node.z !== node.parent?.z)\n    )\n  }\n\n  computeG(node: Node) {\n    const dx = Math.abs(node.x - node.parent!.x)\n    const dy = Math.abs(node.y - node.parent!.y)\n    const dist = Math.sqrt(dx ** 2 + dy ** 2)\n\n    const misalignedDist = !this.FLIP_TRACE_ALIGNMENT_DIRECTION\n      ? node.z === 0\n        ? dy\n        : dx\n      : node.z === 0\n        ? dx\n        : dy\n\n    // Base cost from original function\n    const baseCost =\n      (node.parent?.g ?? 0) +\n      (node.z === node.parent?.z ? 0 : this.viaPenaltyDistance) +\n      dist +\n      misalignedDist * this.MISALIGNED_DIST_PENALTY_FACTOR\n\n    return (\n      baseCost +\n      this.getFutureConnectionPenalty(node, node.z !== node.parent?.z)\n    )\n  }\n}\n","export function seededRandom(seed: number) {\n  // Use a simple hash to initialize both state variables\n  let s = seed\n  for (let i = 0; i < 10; i++) {\n    s = (s * 16807) % 2147483647\n  }\n  let state0 = s\n\n  // Use a different hash for the second state\n  s = (seed * 69069 + 1) % 2147483647\n  for (let i = 0; i < 10; i++) {\n    s = (s * 48271) % 2147483647\n  }\n  let state1 = s\n\n  // Return the function that generates random numbers\n  return () => {\n    // xorshift128+ algorithm produces much better randomness than LCG\n    let s1 = state0\n    const s0 = state1\n\n    state0 = s0\n    s1 ^= s1 << 23\n    s1 ^= s1 >>> 17\n    s1 ^= s0\n    s1 ^= s0 >>> 26\n    state1 = s1\n\n    // Generate a number between 0 and 1\n    const result = (state0 + state1) / 4294967296\n    return result - Math.floor(result)\n  }\n}\n\n// We have preshuffled cases because for small arrays, there's very few possible\n// orderings, and the shuffle seed often starts at 0 and increments by 1. So we\n// want to ensure for simple cases we're definitely hitting all the cases.\nconst PRESHUFFLED_CASES = {\n  1: [[0]],\n  2: [\n    [0, 1],\n    [1, 0],\n  ],\n  3: [\n    [0, 1, 2],\n    [2, 0, 1],\n    [1, 0, 2],\n    [0, 2, 1],\n    [1, 2, 0],\n    [2, 1, 0],\n  ],\n  4: [\n    [0, 1, 2, 3],\n    [2, 0, 1, 3],\n    [1, 3, 2, 0],\n    [3, 0, 1, 2],\n    [0, 2, 1, 3],\n    [2, 1, 3, 0],\n    [3, 0, 2, 1],\n    [1, 2, 0, 3],\n    [3, 1, 0, 2],\n    [0, 3, 2, 1],\n    [2, 3, 0, 1],\n    [2, 3, 1, 0],\n    [1, 2, 3, 0],\n    [3, 1, 2, 0],\n    [0, 1, 3, 2],\n    [0, 2, 3, 1],\n    [0, 3, 1, 2],\n    [1, 0, 2, 3],\n    [1, 0, 3, 2],\n    [1, 3, 0, 2],\n    [2, 0, 3, 1],\n    [2, 1, 0, 3],\n    [3, 2, 0, 1],\n    [3, 2, 1, 0],\n  ],\n}\n\nexport function cloneAndShuffleArray<T>(arr: T[], seed: number): T[] {\n  if (seed === 0) return arr\n\n  if (arr.length <= 4) {\n    const preshuffledOptions =\n      PRESHUFFLED_CASES[arr.length as keyof typeof PRESHUFFLED_CASES]\n    const preshuffledCase = preshuffledOptions[seed % preshuffledOptions.length]\n\n    return preshuffledCase.map((orderIndex) => arr[orderIndex])\n  }\n\n  const random = seededRandom(seed)\n  // if (arr.length === 2) {\n  //   console.log(random(), seed)\n  //   if (random() > 0.5) return arr.slice()\n  //   return [arr[1], arr[0]]\n  // }\n  const shuffled = arr.slice() // Copy the array\n  for (let i = 0; i < shuffled.length; i++) {\n    const i1 = Math.floor(random() * shuffled.length)\n    const i2 = Math.floor(random() * (i + 1))\n    ;[shuffled[i1], shuffled[i2]] = [shuffled[i2], shuffled[i1]]\n  }\n  return shuffled\n}\n","import { NodeWithPortPoints } from \"lib/types/high-density-types\"\n\nexport function getBoundsFromNodeWithPortPoints(\n  nodeWithPortPoints: NodeWithPortPoints,\n): { minX: number; maxX: number; minY: number; maxY: number } {\n  const bounds = {\n    minX: nodeWithPortPoints.center.x - nodeWithPortPoints.width / 2,\n    maxX: nodeWithPortPoints.center.x + nodeWithPortPoints.width / 2,\n    minY: nodeWithPortPoints.center.y - nodeWithPortPoints.height / 2,\n    maxY: nodeWithPortPoints.center.y + nodeWithPortPoints.height / 2,\n  }\n\n  // Sometimes port points may be outside the node- this happens when there's\n  // a \"leap\" to the final target or at the end or beginning of a trace when\n  // we're wrapping up\n  for (const pt of nodeWithPortPoints.portPoints) {\n    if (pt.x < bounds.minX) {\n      bounds.minX = pt.x\n    }\n    if (pt.x > bounds.maxX) {\n      bounds.maxX = pt.x\n    }\n    if (pt.y < bounds.minY) {\n      bounds.minY = pt.y\n    }\n    if (pt.y > bounds.maxY) {\n      bounds.maxY = pt.y\n    }\n  }\n\n  return bounds\n}\n","import { NodeWithPortPoints } from \"lib/types/high-density-types\"\n\nexport const getMinDistBetweenEnteringPoints = (node: NodeWithPortPoints) => {\n  let minDist = Infinity\n  const points = node.portPoints\n\n  // Compare each point with every other point\n  for (let i = 0; i < points.length; i++) {\n    for (let j = i + 1; j < points.length; j++) {\n      if (points[i].z !== points[j].z) {\n        continue\n      }\n      const p1 = points[i]\n      const p2 = points[j]\n\n      // Calculate Euclidean distance between points\n      const dist = Math.sqrt((p1.x - p2.x) ** 2 + (p1.y - p2.y) ** 2)\n\n      minDist = Math.min(minDist, dist)\n    }\n  }\n\n  return minDist === Infinity ? 0 : minDist\n}\n","import type { GraphicsObject } from \"graphics-debug\"\nimport type {\n  HighDensityIntraNodeRoute,\n  NodeWithPortPoints,\n} from \"../../types/high-density-types\"\nimport { BaseSolver } from \"../BaseSolver\"\nimport { SingleHighDensityRouteSolver } from \"./SingleHighDensityRouteSolver\"\nimport { safeTransparentize } from \"../colors\"\nimport { SingleHighDensityRouteSolver6_VertHorzLayer_FutureCost } from \"./SingleHighDensityRouteSolver6_VertHorzLayer_FutureCost\"\nimport { HighDensityHyperParameters } from \"./HighDensityHyperParameters\"\nimport { cloneAndShuffleArray } from \"lib/utils/cloneAndShuffleArray\"\nimport { ConnectivityMap } from \"circuit-json-to-connectivity-map\"\nimport { getBoundsFromNodeWithPortPoints } from \"lib/utils/getBoundsFromNodeWithPortPoints\"\nimport { getMinDistBetweenEnteringPoints } from \"lib/utils/getMinDistBetweenEnteringPoints\"\n\nexport class IntraNodeRouteSolver extends BaseSolver {\n  nodeWithPortPoints: NodeWithPortPoints\n  colorMap: Record<string, string>\n  unsolvedConnections: {\n    connectionName: string\n    points: { x: number; y: number; z: number }[]\n  }[]\n\n  totalConnections: number\n  solvedRoutes: HighDensityIntraNodeRoute[]\n  failedSubSolvers: SingleHighDensityRouteSolver[]\n  hyperParameters: Partial<HighDensityHyperParameters>\n  minDistBetweenEnteringPoints: number\n\n  activeSubSolver: SingleHighDensityRouteSolver | null = null\n  connMap?: ConnectivityMap\n\n  // Legacy compat\n  get failedSolvers() {\n    return this.failedSubSolvers\n  }\n\n  // Legacy compat\n  get activeSolver() {\n    return this.activeSubSolver\n  }\n\n  constructor(params: {\n    nodeWithPortPoints: NodeWithPortPoints\n    colorMap?: Record<string, string>\n    hyperParameters?: Partial<HighDensityHyperParameters>\n    connMap?: ConnectivityMap\n  }) {\n    const { nodeWithPortPoints, colorMap } = params\n    super()\n    this.nodeWithPortPoints = nodeWithPortPoints\n    this.colorMap = colorMap ?? {}\n    this.solvedRoutes = []\n    this.hyperParameters = params.hyperParameters ?? {}\n    this.failedSubSolvers = []\n    this.connMap = params.connMap\n    const unsolvedConnectionsMap: Map<\n      string,\n      { x: number; y: number; z: number }[]\n    > = new Map()\n    for (const { connectionName, x, y, z } of nodeWithPortPoints.portPoints) {\n      unsolvedConnectionsMap.set(connectionName, [\n        ...(unsolvedConnectionsMap.get(connectionName) ?? []),\n        { x, y, z: z ?? 0 },\n      ])\n    }\n    this.unsolvedConnections = Array.from(\n      unsolvedConnectionsMap.entries().map(([connectionName, points]) => ({\n        connectionName,\n        points,\n      })),\n    )\n\n    if (this.hyperParameters.SHUFFLE_SEED) {\n      this.unsolvedConnections = cloneAndShuffleArray(\n        this.unsolvedConnections,\n        this.hyperParameters.SHUFFLE_SEED ?? 0,\n      )\n\n      // Shuffle the starting and ending points of each connection (some\n      // algorithms are biased towards the start or end of a trace)\n      this.unsolvedConnections = this.unsolvedConnections.map(\n        ({ points, ...rest }, i) => ({\n          ...rest,\n          points: cloneAndShuffleArray(\n            points,\n            i * 7117 + (this.hyperParameters.SHUFFLE_SEED ?? 0),\n          ),\n        }),\n      )\n    }\n\n    this.totalConnections = this.unsolvedConnections.length\n    this.MAX_ITERATIONS = 1_000 * this.totalConnections ** 1.5\n\n    this.minDistBetweenEnteringPoints = getMinDistBetweenEnteringPoints(\n      this.nodeWithPortPoints,\n    )\n\n    // const {\n    //   numEntryExitLayerChanges,\n    //   numSameLayerCrossings,\n    //   numTransitionPairCrossings,\n    //   numTransitions,\n    // } = getIntraNodeCrossings(this.nodeWithPortPoints)\n\n    // if (this.nodeWithPortPoints.portPoints.length === 4) {\n\n    // }\n\n    // if (\n    //   numSameLayerCrossings === 0 &&\n    //   numTransitions === 0 &&\n    //   numEntryExitLayerChanges === 0\n    // ) {\n    //   this.handleSimpleNoCrossingsCase()\n    // }\n  }\n\n  // handleSimpleNoCrossingsCase() {\n  //   // TODO check to make sure there are no crossings due to trace width\n  //   this.solved = true\n  //   this.solvedRoutes = this.unsolvedConnections.map(\n  //     ({ connectionName, points }) => ({\n  //       connectionName,\n  //       route: points,\n  //       traceThickness: 0.1, // TODO load from hyperParameters\n  //       viaDiameter: 0.6,\n  //       vias: [],\n  //     }),\n  //   )\n  //   this.unsolvedConnections = []\n  // }\n\n  computeProgress() {\n    return (\n      (this.solvedRoutes.length + (this.activeSubSolver?.progress || 0)) /\n      this.totalConnections\n    )\n  }\n\n  _step() {\n    if (this.activeSubSolver) {\n      this.activeSubSolver.step()\n      this.progress = this.computeProgress()\n      if (this.activeSubSolver.solved) {\n        this.solvedRoutes.push(this.activeSubSolver.solvedPath!)\n        this.activeSubSolver = null\n      } else if (this.activeSubSolver.failed) {\n        this.failedSubSolvers.push(this.activeSubSolver)\n        this.activeSubSolver = null\n        this.error = this.failedSubSolvers.map((s) => s.error).join(\"\\n\")\n        this.failed = true\n      }\n      return\n    }\n\n    const unsolvedConnection = this.unsolvedConnections.pop()\n    this.progress = this.computeProgress()\n    if (!unsolvedConnection) {\n      this.solved = this.failedSubSolvers.length === 0\n      return\n    }\n    if (unsolvedConnection.points.length === 1) {\n      return\n    }\n    if (unsolvedConnection.points.length === 2) {\n      const [A, B] = unsolvedConnection.points\n      if (A.x === B.x && A.y === B.y && A.z === B.z) {\n        return\n      }\n    }\n    const { connectionName, points } = unsolvedConnection\n    this.activeSubSolver =\n      new SingleHighDensityRouteSolver6_VertHorzLayer_FutureCost({\n        connectionName,\n        minDistBetweenEnteringPoints: this.minDistBetweenEnteringPoints,\n        bounds: getBoundsFromNodeWithPortPoints(this.nodeWithPortPoints),\n        A: { x: points[0].x, y: points[0].y, z: points[0].z },\n        B: {\n          x: points[points.length - 1].x,\n          y: points[points.length - 1].y,\n          z: points[points.length - 1].z,\n        },\n        obstacleRoutes: this.connMap\n          ? this.solvedRoutes.filter(\n              (sr) =>\n                !this.connMap!.areIdsConnected(\n                  sr.connectionName,\n                  connectionName,\n                ),\n            )\n          : this.solvedRoutes,\n        futureConnections: this.unsolvedConnections,\n        layerCount: 2,\n        hyperParameters: this.hyperParameters,\n        connMap: this.connMap,\n      })\n  }\n\n  visualize(): GraphicsObject {\n    const graphics: GraphicsObject = {\n      lines: [],\n      points: [],\n      rects: [],\n      circles: [],\n    }\n\n    // Draw node bounds\n    // graphics.rects!.push({\n    //   center: {\n    //     x: this.nodeWithPortPoints.center.x,\n    //     y: this.nodeWithPortPoints.center.y,\n    //   },\n    //   width: this.nodeWithPortPoints.width,\n    //   height: this.nodeWithPortPoints.height,\n    //   stroke: \"gray\",\n    //   fill: \"transparent\",\n    // })\n\n    // Visualize input nodeWithPortPoints\n    for (const pt of this.nodeWithPortPoints.portPoints) {\n      graphics.points!.push({\n        x: pt.x,\n        y: pt.y,\n        label: [pt.connectionName, `layer: ${pt.z}`].join(\"\\n\"),\n        color: this.colorMap[pt.connectionName] ?? \"blue\",\n      })\n    }\n\n    // Visualize solvedRoutes\n    for (\n      let routeIndex = 0;\n      routeIndex < this.solvedRoutes.length;\n      routeIndex++\n    ) {\n      const route = this.solvedRoutes[routeIndex]\n      if (route.route.length > 0) {\n        const routeColor = this.colorMap[route.connectionName] ?? \"blue\"\n\n        // Draw route segments between points\n        for (let i = 0; i < route.route.length - 1; i++) {\n          const p1 = route.route[i]\n          const p2 = route.route[i + 1]\n\n          graphics.lines!.push({\n            points: [p1, p2],\n            strokeColor:\n              p1.z === 0\n                ? safeTransparentize(routeColor, 0.2)\n                : safeTransparentize(routeColor, 0.8),\n            layer: `route-layer-${p1.z}`,\n            step: routeIndex,\n            strokeWidth: route.traceThickness,\n          })\n        }\n\n        // Draw vias\n        for (const via of route.vias) {\n          graphics.circles!.push({\n            center: { x: via.x, y: via.y },\n            radius: route.viaDiameter / 2,\n            fill: safeTransparentize(routeColor, 0.5),\n            layer: \"via\",\n            step: routeIndex,\n          })\n        }\n      }\n    }\n\n    // Draw border around the node\n    const bounds = getBoundsFromNodeWithPortPoints(this.nodeWithPortPoints)\n    const { minX, minY, maxX, maxY } = bounds\n\n    // Draw the four sides of the border with thin red lines\n    graphics.lines!.push({\n      points: [\n        { x: minX, y: minY },\n        { x: maxX, y: minY },\n        { x: maxX, y: maxY },\n        { x: minX, y: maxY },\n        { x: minX, y: minY },\n      ],\n      strokeColor: \"rgba(255, 0, 0, 0.25)\",\n      strokeDash: \"4 4\",\n      layer: \"border\",\n    })\n\n    return graphics\n  }\n}\n","import { GraphicsObject } from \"graphics-debug\"\nimport { BaseSolver } from \"./BaseSolver\"\n\nexport type SupervisedSolver<T extends BaseSolver> = {\n  hyperParameters: any\n  solver: T\n  h: number\n  g: number\n  f: number\n}\n\nexport type HyperParameterDef = {\n  name: string\n  possibleValues: Array<any>\n}\n\n/**\n * The HyperParameterSupervisorSolver is a solver that solves a problem by\n * running competing solvers with different hyperparameters.\n *\n * As solvers make progress, the supervisor will allow the best solvers to run\n * for more iterations, prioritizing the solvers that are working the best.\n */\nexport class HyperParameterSupervisorSolver<\n  T extends BaseSolver,\n> extends BaseSolver {\n  GREEDY_MULTIPLIER = 1.2\n  MIN_SUBSTEPS = 1\n\n  supervisedSolvers?: Array<SupervisedSolver<T>>\n  winningSolver?: T\n\n  getHyperParameterDefs(): Array<HyperParameterDef> {\n    throw new Error(\"Not implemented\")\n  }\n\n  getCombinationDefs(): Array<Array<string>> | null {\n    return null\n  }\n\n  getHyperParameterCombinations(\n    hyperParameterDefs?: Array<HyperParameterDef>,\n  ): Array<Record<string, any>> {\n    if (!hyperParameterDefs) {\n      hyperParameterDefs = this.getHyperParameterDefs()\n    }\n    const combinations: Array<Record<string, any>> = []\n    // Base case - no more hyperparameters to combine\n    if (hyperParameterDefs.length === 0) {\n      return [{}]\n    }\n\n    // Take first hyperparameter definition\n    const [currentDef, ...remainingDefs] = hyperParameterDefs\n\n    // Get combinations for remaining hyperparameters\n    const subCombinations = this.getHyperParameterCombinations(remainingDefs)\n\n    // For each possible value of current hyperparameter,\n    // combine with all sub-combinations\n    currentDef.possibleValues.forEach((value) => {\n      subCombinations.forEach((subCombo) => {\n        combinations.push({\n          ...subCombo,\n          ...value,\n        })\n      })\n    })\n\n    return combinations\n  }\n\n  initializeSolvers() {\n    const hyperParameterDefs = this.getHyperParameterDefs()\n\n    const combinationDefs = this.getCombinationDefs() ?? [\n      hyperParameterDefs.map((def) => def.name),\n    ]\n\n    this.supervisedSolvers = []\n    for (const combinationDef of combinationDefs) {\n      const hyperParameterCombinations = this.getHyperParameterCombinations(\n        hyperParameterDefs.filter((hpd) => combinationDef.includes(hpd.name)),\n      )\n\n      for (const hyperParameters of hyperParameterCombinations) {\n        const solver = this.generateSolver(hyperParameters)\n        const g = this.computeG(solver)\n        this.supervisedSolvers.push({\n          hyperParameters,\n          solver,\n          h: 0,\n          g,\n          f: g,\n        })\n      }\n    }\n  }\n\n  generateSolver(hyperParameters: any): T {\n    throw new Error(\"Not implemented\")\n  }\n\n  computeG(solver: T) {\n    return solver.iterations / solver.MAX_ITERATIONS\n  }\n\n  computeH(solver: T) {\n    return 1 - (solver.progress || 0)\n  }\n\n  computeF(g: number, h: number) {\n    return g + h * this.GREEDY_MULTIPLIER\n  }\n\n  getSupervisedSolverWithBestFitness(): SupervisedSolver<T> | null {\n    let bestFitness = Infinity\n    let bestSolver: SupervisedSolver<T> | null = null\n    for (const supervisedSolver of this.supervisedSolvers ?? []) {\n      if (supervisedSolver.solver.solved) {\n        return supervisedSolver\n      }\n      if (supervisedSolver.solver.failed) {\n        continue\n      }\n      const fitness = supervisedSolver.f\n      if (fitness < bestFitness) {\n        bestFitness = fitness\n        bestSolver = supervisedSolver\n      }\n    }\n    return bestSolver\n  }\n\n  getFailureMessage() {\n    return \"All solvers failed in hyper solver.\"\n  }\n\n  _step() {\n    if (!this.supervisedSolvers) this.initializeSolvers()\n\n    const supervisedSolver = this.getSupervisedSolverWithBestFitness()\n\n    if (!supervisedSolver) {\n      this.failed = true\n      this.error = this.getFailureMessage()\n      return\n    }\n\n    for (let i = 0; i < this.MIN_SUBSTEPS; i++) {\n      supervisedSolver.solver.step()\n    }\n\n    supervisedSolver.g = this.computeG(supervisedSolver.solver)\n    supervisedSolver.h = this.computeH(supervisedSolver.solver)\n    supervisedSolver.f = this.computeF(supervisedSolver.g, supervisedSolver.h)\n\n    if (supervisedSolver.solver.solved) {\n      this.solved = true\n      this.winningSolver = supervisedSolver.solver\n      this.onSolve?.(supervisedSolver)\n    }\n  }\n\n  onSolve(solver: SupervisedSolver<T>) {}\n\n  visualize(): GraphicsObject {\n    const bestSupervisedSolver = this.getSupervisedSolverWithBestFitness()\n    let graphics: GraphicsObject = {\n      lines: [],\n      circles: [],\n      points: [],\n      rects: [],\n    }\n\n    if (bestSupervisedSolver) {\n      graphics = bestSupervisedSolver.solver.visualize()\n    }\n    return graphics\n  }\n}\n","interface Point {\n  x: number\n  y: number\n}\n\nexport const findCircleLineIntersections = (\n  circle: Point & { r: number },\n  line: { p1: Point; p2: Point },\n) => {\n  const cx = circle.x\n  const cy = circle.y\n  const r = circle.r\n\n  const x1 = line.p1.x\n  const y1 = line.p1.y\n  const x2 = line.p2.x\n  const y2 = line.p2.y\n\n  // Check if line is vertical\n  if (Math.abs(x2 - x1) < 0.001) {\n    const x = x1\n\n    // Calculate discriminant\n    const a = r * r - (x - cx) ** 2\n\n    if (a < 0) return [] // No intersection\n\n    if (Math.abs(a) < 0.001) {\n      // One intersection\n      const y = cy\n      // Check if this point is within the line segment\n      if (y >= Math.min(y1, y2) && y <= Math.max(y1, y2)) {\n        return [{ x, y }]\n      }\n      return []\n    }\n\n    // Two intersections\n    const y_1 = cy + Math.sqrt(a)\n    const y_2 = cy - Math.sqrt(a)\n\n    const points: Point[] = []\n    if (y_1 >= Math.min(y1, y2) && y_1 <= Math.max(y1, y2)) {\n      points.push({ x, y: y_1 })\n    }\n    if (y_2 >= Math.min(y1, y2) && y_2 <= Math.max(y1, y2)) {\n      points.push({ x, y: y_2 })\n    }\n\n    return points\n  }\n\n  // Line is not vertical\n  const m = (y2 - y1) / (x2 - x1)\n  const b = y1 - m * x1\n\n  // Substitute line equation into circle equation\n  const A = 1 + m * m\n  const B = 2 * (m * b - m * cy - cx)\n  const C = cx * cx + (b - cy) * (b - cy) - r * r\n\n  // Calculate discriminant\n  const discriminant = B * B - 4 * A * C\n\n  if (discriminant < 0) return [] // No intersection\n\n  if (Math.abs(discriminant) < 0.001) {\n    // One intersection\n    const x = -B / (2 * A)\n    const y = m * x + b\n\n    // Check if this point is within the line segment\n    if (\n      x >= Math.min(x1, x2) &&\n      x <= Math.max(x1, x2) &&\n      y >= Math.min(y1, y2) &&\n      y <= Math.max(y1, y2)\n    ) {\n      return [{ x, y }]\n    }\n    return []\n  }\n\n  // Two intersections\n  const x_1 = (-B + Math.sqrt(discriminant)) / (2 * A)\n  const x_2 = (-B - Math.sqrt(discriminant)) / (2 * A)\n  const y_1 = m * x_1 + b\n  const y_2 = m * x_2 + b\n\n  const points: Point[] = []\n  if (\n    x_1 >= Math.min(x1, x2) &&\n    x_1 <= Math.max(x1, x2) &&\n    y_1 >= Math.min(y1, y2) &&\n    y_1 <= Math.max(y1, y2)\n  ) {\n    points.push({ x: x_1, y: y_1 })\n  }\n  if (\n    x_2 >= Math.min(x1, x2) &&\n    x_2 <= Math.max(x1, x2) &&\n    y_2 >= Math.min(y1, y2) &&\n    y_2 <= Math.max(y1, y2)\n  ) {\n    points.push({ x: x_2, y: y_2 })\n  }\n\n  return points\n}\n","import { useState, useRef, useEffect } from \"react\"\nimport { distance, pointToSegmentDistance } from \"@tscircuit/math-utils\"\n\ntype Point = { x: number; y: number }\ntype Segment = { start: Point; end: Point }\ntype JLine = {\n  index: number\n  startsAt: \"C\" | \"D\"\n  goesTo: \"A\" | \"B\"\n  points: Point[]\n}\n\n/**\n * Compute optimal paths for the dumbbell visualization\n * @param {Object} config - Configuration object\n * @param {Object} config.A - Point A coordinates {x, y}\n * @param {Object} config.B - Point B coordinates {x, y}\n * @param {Object} config.C - Point C coordinates {x, y}\n * @param {Object} config.D - Point D coordinates {x, y}\n * @param {Object} config.E - Point E coordinates {x, y}\n * @param {Object} config.F - Point F coordinates {x, y}\n * @param {number} config.radius - Circle radius\n * @param {number} config.margin - Margin around circles\n * @param {number} config.subdivisions - Number of subdivisions (default: 0)\n * @returns {Object} - Result containing jPair and optimalPath\n *\n * https://claude.ai/artifacts/f1f6dbc8-02f9-46be-8dff-7a60709a5011\n */\nexport function computeDumbbellPaths({\n  A,\n  B,\n  C,\n  D,\n  E,\n  F,\n  radius,\n  margin,\n  subdivisions = 0,\n}: {\n  A: { x: number; y: number }\n  B: { x: number; y: number }\n  C: { x: number; y: number }\n  D: { x: number; y: number }\n  E: { x: number; y: number }\n  F: { x: number; y: number }\n  radius: number\n  margin: number\n  subdivisions: number\n}): {\n  jPair: {\n    line1: JLine\n    line2: JLine\n  } | null\n  optimalPath: {\n    startsAt: \"C\" | \"D\"\n    goesTo: \"C\" | \"D\"\n    points: { x: number; y: number }[]\n  }\n} {\n  // Basic types\n  // Point and Segment types are assumed to be defined like this:\n  // interface Point { x: number; y: number; }\n  // interface Segment { start: Point; end: Point; }\n\n  // Helper functions\n\n  // Calculate midpoint between two points\n  const midpoint = (p1: Point, p2: Point): Point => ({\n    x: (p1.x + p2.x) / 2,\n    y: (p1.y + p2.y) / 2,\n  })\n\n  // Calculate all dumbbell points\n  const calculatePoints = (\n    a: Point,\n    b: Point,\n    r: number,\n  ): {\n    midpoint: Point\n    A_Opp: Point\n    A_Right: Point\n    A_Left: Point\n    B_Opp: Point\n    B_Right: Point\n    B_Left: Point\n  } => {\n    // Vector from A to B\n    const dx = b.x - a.x\n    const dy = b.y - a.y\n    const len = Math.sqrt(dx * dx + dy * dy)\n\n    // Unit vectors\n    const ux = dx / len\n    const uy = dy / len\n    const px = -uy\n    const py = ux // Perpendicular unit vector\n\n    return {\n      midpoint: { x: (a.x + b.x) / 2, y: (a.y + b.y) / 2 },\n      A_Opp: { x: a.x - ux * r, y: a.y - uy * r },\n      A_Right: { x: a.x + px * r, y: a.y + py * r },\n      A_Left: { x: a.x - px * r, y: a.y - py * r },\n      B_Opp: { x: b.x + ux * r, y: b.y + uy * r },\n      B_Right: { x: b.x + px * r, y: b.y + py * r },\n      B_Left: { x: b.x - px * r, y: b.y - py * r },\n    }\n  }\n\n  // Check if a point is on a line segment\n  const isPointOnSegment = (point: Point, segment: Segment): boolean => {\n    // Calculate distance from point to segment endpoints\n    const d1 = distance(point, segment.start)\n    const d2 = distance(point, segment.end)\n    // Calculate segment length\n    const segmentLength = distance(segment.start, segment.end)\n    // Allow a small tolerance for floating-point errors\n    const tolerance = 0.0001\n    // Check if point is on segment (d1 + d2 should approximately equal segmentLength)\n    return Math.abs(d1 + d2 - segmentLength) < tolerance\n  }\n\n  // Line intersection check\n  const intersect = (l1: Segment, l2: Segment): boolean => {\n    const { start: p1, end: p2 } = l1\n    const { start: p3, end: p4 } = l2\n\n    // Check if any endpoint of one segment is on the other segment\n    if (\n      isPointOnSegment(p1, l2) ||\n      isPointOnSegment(p2, l2) ||\n      isPointOnSegment(p3, l1) ||\n      isPointOnSegment(p4, l1)\n    ) {\n      return true\n    }\n\n    const d1x = p2.x - p1.x\n    const d1y = p2.y - p1.y\n    const d2x = p4.x - p3.x\n    const d2y = p4.y - p3.y\n\n    const det = d1x * d2y - d1y * d2x\n    if (Math.abs(det) < 0.0001) return false // Parallel or collinear\n\n    const dx = p3.x - p1.x\n    const dy = p3.y - p1.y\n    const t = (dx * d2y - dy * d2x) / det\n    const u = (dx * d1y - dy * d1x) / det\n\n    return t > 0 && t < 1 && u > 0 && u < 1\n  }\n\n  // Check if path1 intersects with path2\n  const doPathsIntersect = (path1: Point[], path2: Point[]): boolean => {\n    // Create segments from path1\n    const segments1 = []\n    for (let i = 0; i < path1.length - 1; i++) {\n      segments1.push({ start: path1[i], end: path1[i + 1] })\n    }\n\n    // Create segments from path2\n    const segments2 = []\n    for (let i = 0; i < path2.length - 1; i++) {\n      segments2.push({ start: path2[i], end: path2[i + 1] })\n    }\n\n    // Check if any segment from path1 intersects with any segment from path2\n    for (const seg1 of segments1) {\n      for (const seg2 of segments2) {\n        if (intersect(seg1, seg2)) {\n          return true\n        }\n      }\n    }\n\n    return false\n  }\n\n  // Path length calculation\n  const pathLength = (points: Point[]): number => {\n    let len = 0\n    for (let i = 1; i < points.length; i++) {\n      const dx = points[i].x - points[i - 1].x\n      const dy = points[i].y - points[i - 1].y\n      len += Math.sqrt(dx * dx + dy * dy)\n    }\n    return len\n  }\n\n  // Find closest point on segment to circle center\n  const closestPointOnSegment = (\n    segment: Segment,\n    circleCenter: Point,\n  ): { x: number; y: number; t: number } => {\n    const { start, end } = segment\n    const dx = end.x - start.x\n    const dy = end.y - start.y\n    const segmentLengthSquared = dx * dx + dy * dy\n\n    if (segmentLengthSquared === 0) return { ...start, t: 0 } // Segment is a point\n\n    // Calculate projection scalar\n    const t = Math.max(\n      0,\n      Math.min(\n        1,\n        ((circleCenter.x - start.x) * dx + (circleCenter.y - start.y) * dy) /\n          segmentLengthSquared,\n      ),\n    )\n\n    // Calculate closest point\n    return {\n      x: start.x + t * dx,\n      y: start.y + t * dy,\n      t: t, // Keep track of the parameter for later use\n    }\n  }\n\n  // Find the point at radius distance from circle center, moving away from the closest point\n  const getSubdivisionPoint = (\n    segment: Segment,\n    circleCenter: Point,\n    r: number,\n  ): {\n    x: number\n    y: number\n    t: number\n    isSpecial?: boolean\n    specialType?: \"A\" | \"B\"\n  } => {\n    const closestPoint = closestPointOnSegment(segment, circleCenter)\n\n    // Calculate distance from closest point to circle center\n    const dist = distance(closestPoint, circleCenter)\n\n    // If distance is greater than radius, no need to adjust\n    if (dist >= r) return closestPoint\n\n    // Calculate direction vector from circle center to closest point\n    const dirX = closestPoint.x - circleCenter.x\n    const dirY = closestPoint.y - circleCenter.y\n\n    // Normalize direction vector\n    const norm = Math.sqrt(dirX * dirX + dirY * dirY)\n    if (norm === 0) {\n      // If closest point is the circle center, use segment direction\n      const segDirX = segment.end.x - segment.start.x\n      const segDirY = segment.end.y - segment.start.y\n      const segNorm = Math.sqrt(segDirX * segDirX + segDirY * segDirY)\n\n      return {\n        x: circleCenter.x + (r * segDirX) / segNorm,\n        y: circleCenter.y + (r * segDirY) / segNorm,\n        t: closestPoint.t,\n        isSpecial: true,\n        specialType: circleCenter === A ? \"A\" : \"B\",\n      }\n    }\n\n    // Calculate point at radius distance from circle center\n    return {\n      x: circleCenter.x + (r * dirX) / norm,\n      y: circleCenter.y + (r * dirY) / norm,\n      t: closestPoint.t,\n      isSpecial: true,\n      specialType: circleCenter === A ? \"A\" : \"B\",\n    }\n  }\n\n  // Subdivide path based on proximity to A and B\n  const subdivideOptimalPath = (\n    path: Point[],\n    numSubdivisions: number,\n  ): Point[] => {\n    if (path.length < 2) return path\n\n    const result = [path[0]] // Start with the first point\n\n    // Process each segment\n    for (let i = 0; i < path.length - 1; i++) {\n      const segment = { start: path[i], end: path[i + 1] }\n\n      // Calculate midpoint of segment\n      const segmentMidpoint = {\n        x: (segment.start.x + segment.end.x) / 2,\n        y: (segment.start.y + segment.end.y) / 2,\n      }\n\n      // Check if midpoint is within radius of A or B\n      const midpointDistToA = distance(segmentMidpoint, A)\n      const midpointDistToB = distance(segmentMidpoint, B)\n\n      // Only subdivide if midpoint is within radius of A or B\n      const shouldSubdivide =\n        (midpointDistToA <= radius || midpointDistToB <= radius) &&\n        Math.abs(midpointDistToA - midpointDistToB) > 0.0001\n\n      if (shouldSubdivide) {\n        // Calculate closest points to A and B on this segment\n        const closestPointA = closestPointOnSegment(segment, A)\n        const closestPointB = closestPointOnSegment(segment, B)\n\n        // Calculate distances\n        const distToA = distance(closestPointA, A)\n        const distToB = distance(closestPointB, B)\n\n        // Check if we need to create radius points\n        const needsRadiusPointA = distToA < radius\n        const needsRadiusPointB = distToB < radius\n\n        // Create adjusted points at radius distance if needed\n        const adjustedPointA = needsRadiusPointA\n          ? getSubdivisionPoint(segment, A, radius)\n          : null\n        const adjustedPointB = needsRadiusPointB\n          ? getSubdivisionPoint(segment, B, radius)\n          : null\n\n        // Create regular subdivisions\n        let subdivisionPoints = []\n\n        // Only add regular subdivisions if segment isn't too short\n        const segmentLength = distance(segment.start, segment.end)\n        if (segmentLength > radius / 2 && numSubdivisions > 0) {\n          for (let j = 1; j <= numSubdivisions; j++) {\n            const t = j / (numSubdivisions + 1)\n\n            // Create the subdivision point\n            const subPoint = {\n              x: segment.start.x + t * (segment.end.x - segment.start.x),\n              y: segment.start.y + t * (segment.end.y - segment.start.y),\n              t: t,\n              isSpecial: false,\n            }\n\n            // Check if this subdivision point is too close to A or B centers\n            const subDistToA = distance(subPoint, A)\n            const subDistToB = distance(subPoint, B)\n\n            // Skip points that are inside the circles or too close to special points\n            if (subDistToA < radius || subDistToB < radius) {\n              // Skip this point\n              continue\n            }\n\n            // Skip if too close to the special points we'll add later\n            if (\n              adjustedPointA &&\n              Math.abs(subPoint.t - adjustedPointA.t) < 0.1\n            ) {\n              continue\n            }\n\n            if (\n              adjustedPointB &&\n              Math.abs(subPoint.t - adjustedPointB.t) < 0.1\n            ) {\n              continue\n            }\n\n            // This point is good, add it\n            subdivisionPoints.push(subPoint)\n          }\n        }\n\n        // Add the adjusted points if needed\n        if (adjustedPointA) {\n          subdivisionPoints.push(adjustedPointA)\n        }\n\n        if (adjustedPointB) {\n          subdivisionPoints.push(adjustedPointB)\n        }\n\n        // Sort all points by t parameter (distance along segment)\n        subdivisionPoints.sort((a, b) => a.t - b.t)\n\n        // Filter out any duplicate or very close points\n        if (subdivisionPoints.length > 1) {\n          const filteredPoints = [subdivisionPoints[0]]\n\n          for (let j = 1; j < subdivisionPoints.length; j++) {\n            const prev = filteredPoints[filteredPoints.length - 1]\n            const curr = subdivisionPoints[j]\n\n            // Only add points that are at least a bit apart\n            if (distance(prev, curr) > radius / 10) {\n              filteredPoints.push(curr)\n            }\n          }\n\n          subdivisionPoints = filteredPoints\n        }\n\n        // Add all subdivision points to the result\n        subdivisionPoints.forEach((p) => result.push(p))\n      }\n\n      // Add end point\n      result.push(path[i + 1])\n    }\n\n    // Filter duplicate or very close consecutive points\n    if (result.length > 1) {\n      const filteredResult = [result[0]]\n\n      for (let i = 1; i < result.length; i++) {\n        const prev = filteredResult[filteredResult.length - 1]\n        const curr = result[i]\n\n        // Only add points that are at least a bit apart\n        if (distance(prev, curr) > radius / 10) {\n          filteredResult.push(curr)\n        }\n      }\n\n      return filteredResult\n    }\n\n    return result\n  }\n\n  // Calculate points for inner and outer dumbbells\n  const innerPoints = calculatePoints(A, B, radius)\n  const outerPoints = calculatePoints(A, B, radius + margin)\n\n  // Define the four S-shape paths\n  const getPaths = () => [\n    // Path 1: CB_LeftB_OppB_RightMidA_LeftA_OppA_RightD\n    [\n      C,\n      innerPoints.B_Left,\n      innerPoints.B_Opp,\n      innerPoints.B_Right,\n      midpoint(\n        innerPoints.midpoint,\n        midpoint(innerPoints.B_Right, innerPoints.A_Right),\n      ),\n      midpoint(\n        innerPoints.midpoint,\n        midpoint(innerPoints.A_Left, innerPoints.B_Left),\n      ),\n      innerPoints.A_Left,\n      innerPoints.A_Opp,\n      innerPoints.A_Right,\n      D,\n    ],\n    // Path 2: CB_RightB_OppB_LeftMidA_RightA_OppA_LeftD\n    [\n      C,\n      innerPoints.B_Right,\n      innerPoints.B_Opp,\n      innerPoints.B_Left,\n      midpoint(\n        innerPoints.midpoint,\n        midpoint(innerPoints.A_Left, innerPoints.B_Left),\n      ),\n      midpoint(\n        innerPoints.midpoint,\n        midpoint(innerPoints.A_Right, innerPoints.B_Right),\n      ),\n      innerPoints.A_Right,\n      innerPoints.A_Opp,\n      innerPoints.A_Left,\n      D,\n    ],\n    // Path 3: DB_LeftB_OppB_RightMidA_LeftA_OppA_RightC\n    [\n      D,\n      innerPoints.B_Left,\n      innerPoints.B_Opp,\n      innerPoints.B_Right,\n      midpoint(\n        innerPoints.midpoint,\n        midpoint(innerPoints.A_Right, innerPoints.B_Right),\n      ),\n      midpoint(\n        innerPoints.midpoint,\n        midpoint(innerPoints.A_Left, innerPoints.B_Left),\n      ),\n      innerPoints.A_Left,\n      innerPoints.A_Opp,\n      innerPoints.A_Right,\n      C,\n    ],\n    // Path 4: DB_RightB_OppB_LeftMidA_RightA_OppA_LeftC\n    [\n      D,\n      innerPoints.B_Right,\n      innerPoints.B_Opp,\n      innerPoints.B_Left,\n      midpoint(\n        innerPoints.midpoint,\n        midpoint(innerPoints.A_Left, innerPoints.B_Left),\n      ),\n      midpoint(\n        innerPoints.midpoint,\n        midpoint(innerPoints.A_Right, innerPoints.B_Right),\n      ),\n      innerPoints.A_Right,\n      innerPoints.A_Opp,\n      innerPoints.A_Left,\n      C,\n    ],\n  ]\n\n  // Define the J-lines\n  const getJLines = () => {\n    const mid_AR_BR = midpoint(innerPoints.A_Right, innerPoints.B_Right)\n    const mid_AL_BL = midpoint(innerPoints.B_Left, innerPoints.A_Left)\n\n    return [\n      /*  Shortest (straight)  */\n      { startsAt: \"E\", goesTo: \"B\", points: [E, B] },\n      { startsAt: \"E\", goesTo: \"A\", points: [E, A] },\n      { startsAt: \"F\", goesTo: \"B\", points: [F, B] },\n      { startsAt: \"F\", goesTo: \"A\", points: [F, A] },\n\n      /*  Onebend variants  */\n      // via the (ARBR) rightside midpoint\n      { startsAt: \"E\", goesTo: \"B\", points: [E, mid_AR_BR, B] },\n      { startsAt: \"E\", goesTo: \"A\", points: [E, mid_AR_BR, A] },\n      { startsAt: \"F\", goesTo: \"B\", points: [F, mid_AR_BR, B] },\n      { startsAt: \"F\", goesTo: \"A\", points: [F, mid_AR_BR, A] },\n\n      // via the (ALBL) leftside midpoint\n      { startsAt: \"E\", goesTo: \"B\", points: [E, mid_AL_BL, B] },\n      { startsAt: \"E\", goesTo: \"A\", points: [E, mid_AL_BL, A] },\n      { startsAt: \"F\", goesTo: \"B\", points: [F, mid_AL_BL, B] },\n      { startsAt: \"F\", goesTo: \"A\", points: [F, mid_AL_BL, A] },\n\n      /*  Medium (one outer waypoint)  */\n      // rightside outer arc\n      {\n        startsAt: \"E\",\n        goesTo: \"B\",\n        points: [E, outerPoints.A_Right, mid_AR_BR, B],\n      },\n      {\n        startsAt: \"F\",\n        goesTo: \"B\",\n        points: [F, outerPoints.B_Right, mid_AR_BR, B],\n      },\n\n      // leftside outer arc\n      {\n        startsAt: \"E\",\n        goesTo: \"A\",\n        points: [E, outerPoints.B_Left, mid_AL_BL, A],\n      },\n      {\n        startsAt: \"F\",\n        goesTo: \"A\",\n        points: [F, outerPoints.A_Left, mid_AL_BL, A],\n      },\n\n      // crisscross outer arc\n      {\n        startsAt: \"E\",\n        goesTo: \"B\",\n        points: [E, outerPoints.A_Left, mid_AL_BL, B],\n      },\n      {\n        startsAt: \"E\",\n        goesTo: \"A\",\n        points: [E, outerPoints.B_Right, mid_AR_BR, A],\n      },\n\n      /*  Long (two outer waypoints)  */\n      {\n        startsAt: \"E\",\n        goesTo: \"B\",\n        points: [E, outerPoints.A_Opp, outerPoints.A_Right, mid_AR_BR, B],\n      },\n      {\n        startsAt: \"E\",\n        goesTo: \"A\",\n        points: [E, outerPoints.B_Opp, outerPoints.B_Left, mid_AL_BL, A],\n      },\n\n      {\n        startsAt: \"F\",\n        goesTo: \"B\",\n        points: [F, outerPoints.A_Opp, outerPoints.A_Left, mid_AL_BL, B],\n      },\n      {\n        startsAt: \"F\",\n        goesTo: \"A\",\n        points: [F, outerPoints.B_Opp, outerPoints.B_Right, mid_AR_BR, A],\n      },\n      {\n        startsAt: \"F\",\n        goesTo: \"A\" /* altroute  */,\n        points: [F, outerPoints.B_Opp, outerPoints.B_Left, mid_AL_BL, A],\n      },\n\n      {\n        startsAt: \"E\",\n        goesTo: \"B\",\n        points: [E, outerPoints.A_Opp, outerPoints.A_Left, mid_AL_BL, B],\n      },\n      {\n        startsAt: \"E\",\n        goesTo: \"A\",\n        points: [E, outerPoints.B_Opp, outerPoints.B_Right, mid_AR_BR, A],\n      },\n\n      /*  Longest (three outer waypoints)  */\n      {\n        startsAt: \"E\",\n        goesTo: \"B\",\n        points: [\n          E,\n          outerPoints.A_Left,\n          outerPoints.A_Opp,\n          outerPoints.A_Right,\n          mid_AR_BR,\n          B,\n        ],\n      },\n\n      {\n        startsAt: \"E\",\n        goesTo: \"A\",\n        points: [\n          E,\n          outerPoints.B_Right,\n          outerPoints.B_Opp,\n          outerPoints.B_Left,\n          mid_AL_BL,\n          A,\n        ],\n      },\n\n      {\n        startsAt: \"F\",\n        goesTo: \"B\",\n        points: [\n          F,\n          outerPoints.A_Right,\n          outerPoints.A_Opp,\n          outerPoints.A_Left,\n          mid_AL_BL,\n          B,\n        ],\n      },\n\n      {\n        startsAt: \"F\",\n        goesTo: \"A\",\n        points: [\n          F,\n          outerPoints.B_Left,\n          outerPoints.B_Opp,\n          outerPoints.B_Right,\n          mid_AR_BR,\n          A,\n        ],\n      },\n\n      {\n        startsAt: \"F\",\n        goesTo: \"A\" /* altroute  */,\n        points: [\n          F,\n          outerPoints.B_Right,\n          outerPoints.B_Opp,\n          outerPoints.B_Left,\n          mid_AL_BL,\n          A,\n        ],\n      },\n\n      {\n        startsAt: \"E\",\n        goesTo: \"B\",\n        points: [\n          E,\n          outerPoints.A_Right,\n          outerPoints.A_Opp,\n          outerPoints.A_Left,\n          mid_AL_BL,\n          B,\n        ],\n      },\n\n      {\n        startsAt: \"E\",\n        goesTo: \"A\",\n        points: [\n          E,\n          outerPoints.B_Left,\n          outerPoints.B_Opp,\n          outerPoints.B_Right,\n          mid_AR_BR,\n          A,\n        ],\n      },\n    ].map((l, index) => ({ ...l, index }))\n  }\n\n  // Subdivide a J-line path if segments are too close to the opposite point (A or B)\n  const subdivideJLinePath = (\n    jLine: JLine,\n    oppositePoint: Point,\n    r: number,\n    m: number,\n    numSubdivisions: number, // Keep consistent with optimal path subdivision\n  ): Point[] => {\n    const path = jLine.points\n    if (path.length < 2) return path\n\n    const minDistThreshold = r + m\n    const result: Point[] = [path[0]] // Start with the first point\n\n    for (let i = 0; i < path.length - 1; i++) {\n      const segment = { start: path[i], end: path[i + 1] }\n\n      // Calculate the distance from the segment to the opposite point\n      const distToOpposite = pointToSegmentDistance(\n        oppositePoint,\n        segment.start,\n        segment.end,\n      )\n\n      if (distToOpposite < minDistThreshold) {\n        // Segment is too close, need to subdivide/adjust\n\n        // Find the point on the segment closest to the opposite point\n        const closestPt = closestPointOnSegment(segment, oppositePoint)\n\n        // Calculate the direction vector from the opposite point to the closest point\n        const dirX = closestPt.x - oppositePoint.x\n        const dirY = closestPt.y - oppositePoint.y\n        const norm = Math.sqrt(dirX * dirX + dirY * dirY)\n\n        let adjustedPoint: Point | null = null\n        if (norm > 1e-6) {\n          // Calculate the point pushed away to the minimum distance threshold\n          adjustedPoint = {\n            x: oppositePoint.x + (minDistThreshold * dirX) / norm,\n            y: oppositePoint.y + (minDistThreshold * dirY) / norm,\n            // We might need 't' if combining with regular subdivisions,\n            // but for now, just the adjusted point is needed.\n            // t: closestPt.t\n          }\n        } else {\n          // Closest point is the opposite point itself (unlikely for segments, but handle)\n          // Push away in the segment's direction\n          const segDirX = segment.end.x - segment.start.x\n          const segDirY = segment.end.y - segment.start.y\n          const segNorm = Math.sqrt(segDirX * segDirX + segDirY * segDirY)\n          if (segNorm > 1e-6) {\n            adjustedPoint = {\n              x: oppositePoint.x + (minDistThreshold * segDirX) / segNorm,\n              y: oppositePoint.y + (minDistThreshold * segDirY) / segNorm,\n            }\n          } else {\n            // Segment is a point at the opposite point - keep original? Or push arbitrarily?\n            // Let's just keep the start point for now.\n            // adjustedPoint = { ...segment.start };\n            // Or maybe push radially from opposite point? Needs a defined direction.\n            // For simplicity, we'll just add the adjusted point if calculable.\n          }\n        }\n\n        // Add the adjusted point if it was calculated\n        // We need to decide where to insert it. Inserting at the 't' position\n        // like in the optimal path subdivision might be complex.\n        // A simpler approach for now: insert it between start and end.\n        // This might create sharp turns, but ensures clearance.\n        if (adjustedPoint) {\n          // Check distance to avoid adding points too close to start/end\n          if (distance(segment.start, adjustedPoint) > radius / 10) {\n            result.push(adjustedPoint)\n          }\n        }\n      }\n\n      // Add the original end point of the segment\n      // Ensure no duplicates or very close points are added\n      const lastPointInResult = result[result.length - 1]\n      if (distance(lastPointInResult, segment.end) > radius / 10) {\n        result.push(segment.end)\n      }\n    }\n\n    // Final filter for close points\n    if (result.length > 1) {\n      const filteredResult = [result[0]]\n      for (let i = 1; i < result.length; i++) {\n        if (\n          distance(filteredResult[filteredResult.length - 1], result[i]) >\n          radius / 10\n        ) {\n          filteredResult.push(result[i])\n        }\n      }\n      return filteredResult\n    }\n\n    return result\n  }\n\n  // Find the optimal path based on constraints\n  const findOptimalPath = () => {\n    const paths = getPaths()\n    const validPaths = []\n\n    for (let i = 0; i < paths.length; i++) {\n      const path = paths[i]\n      const firstSeg = { start: path[0], end: path[1] }\n      const lastSeg = {\n        start: path[path.length - 2],\n        end: path[path.length - 1],\n      }\n      const midSeg = { start: path[3], end: path[4] }\n\n      // Check constraints\n      if (\n        !intersect(firstSeg, lastSeg) &&\n        !intersect(firstSeg, midSeg) &&\n        !intersect(lastSeg, midSeg)\n      ) {\n        validPaths.push({\n          index: i + 1,\n          path,\n          length: pathLength(path),\n        })\n      }\n    }\n\n    // Return shortest valid path or empty result\n    if (validPaths.length === 0) {\n      return { index: 0, path: [] }\n    }\n\n    const optimalPath = validPaths.sort((a, b) => a.length - b.length)[0]\n\n    // Post-process the optimal path\n    const path = [...optimalPath.path] // Create a copy of the path\n\n    // Check if first point is closer to 3rd or 4th point\n    const firstPoint = path[0]\n    const dist3 = distance(firstPoint, path[2])\n    const dist4 = distance(firstPoint, path[3])\n    const closerIdx = dist3 < dist4 ? 2 : 3\n\n    if (\n      dist3 < distance(firstPoint, path[1]) ||\n      dist4 < distance(firstPoint, path[1])\n    ) {\n      // Remove segments between first point and closer point\n      path.splice(1, closerIdx - 1)\n    }\n\n    // Check if last point is closer to -3rd or -4th point\n    const lastPoint = path[path.length - 1]\n    const distM3 = distance(lastPoint, path[path.length - 3])\n    const distM4 = distance(lastPoint, path[path.length - 4])\n    const closerLastIdx = distM3 < distM4 ? path.length - 3 : path.length - 4\n\n    if (\n      distM3 < distance(lastPoint, path[path.length - 2]) ||\n      distM4 < distance(lastPoint, path[path.length - 2])\n    ) {\n      // Remove segments between last point and closer point\n      path.splice(closerLastIdx + 1, path.length - closerLastIdx - 2)\n    }\n\n    return {\n      index: optimalPath.index,\n      path,\n      startsAt: path[0] === C ? \"C\" : \"D\",\n      goesTo: path[path.length - 1] === C ? \"C\" : \"D\",\n    }\n  }\n\n  // Find the optimal S-path\n  const optimalPath = findOptimalPath()\n\n  // Apply subdivisions if requested\n  const subdivided =\n    subdivisions > 0\n      ? subdivideOptimalPath(optimalPath.path, subdivisions)\n      : optimalPath.path\n\n  // Find the J-pair that doesn't intersect with the optimal path and isn't too close to A or B\n  const findJPair = (): { line1: JLine; line2: JLine } | null => {\n    if (optimalPath.path.length === 0) return null\n\n    const jLines = getJLines()\n    const minDistFromAB = radius + margin / 2\n\n    // Separate J-lines into those starting with E and those starting with F\n    const eLines = jLines.filter((line) => line.startsAt === \"E\")\n    const fLines = jLines.filter((line) => line.startsAt === \"F\")\n\n    const nonIntersectingELines: JLine[] = []\n    const nonIntersectingFLines: JLine[] = []\n\n    // Check each E J-line for proximity and intersection with optimal path\n    for (const jLine of eLines) {\n      if (doPathsIntersect(jLine.points, optimalPath.path)) continue\n      nonIntersectingELines.push(jLine as JLine)\n      break\n    }\n\n    // Check each F J-line for proximity and intersection with optimal path\n    for (const jLine of fLines) {\n      if (doPathsIntersect(jLine.points, optimalPath.path)) continue\n      nonIntersectingFLines.push(jLine as JLine)\n      break\n    }\n\n    // If we don't have at least one E line and one F line, return an empty pair\n    if (\n      nonIntersectingELines.length === 0 ||\n      nonIntersectingFLines.length === 0\n    ) {\n      return null\n    }\n\n    // Return the first non-intersecting E line and F line as the J-pair\n    return {\n      line1: nonIntersectingELines[0],\n      line2: nonIntersectingFLines[0],\n    }\n  }\n\n  // Find the J-pair\n  let jPair = findJPair()\n\n  // If a J-pair was found, check and subdivide its lines if they are too close\n  // to the opposite A/B point.\n  if (jPair) {\n    const oppositePoint1 = jPair.line1.goesTo === \"A\" ? B : A\n    const oppositePoint2 = jPair.line2.goesTo === \"A\" ? B : A\n\n    const subdividedPoints1 = subdivideJLinePath(\n      jPair.line1,\n      oppositePoint1,\n      radius,\n      margin,\n      subdivisions, // Use same subdivision count for consistency? Or 0? Let's use 0 for now.\n    )\n\n    const subdividedPoints2 = subdivideJLinePath(\n      jPair.line2,\n      oppositePoint2,\n      radius,\n      margin,\n      subdivisions, // Use same subdivision count for consistency? Or 0? Let's use 0 for now.\n    )\n\n    // Update the jPair with the subdivided points\n    jPair = {\n      line1: { ...jPair.line1, points: subdividedPoints1 },\n      line2: { ...jPair.line2, points: subdividedPoints2 },\n    }\n\n    // Optional: Re-check intersection between the *new* jPair lines and the optimal path?\n    // This could lead to cycles if subdivision causes new intersections.\n    // For now, we assume the subdivision primarily pushes points away and doesn't create new intersections.\n    // if (doPathsIntersect(jPair.line1.points, optimalPath.path) || doPathsIntersect(jPair.line2.points, optimalPath.path)) {\n    //   console.warn(\"Subdivision of J-lines caused intersection with optimal path.\");\n    //   // Potentially invalidate jPair here or try alternative J-lines?\n    //   // jPair = null;\n    // }\n  }\n\n  // Return the final result\n  return {\n    jPair,\n    optimalPath: {\n      startsAt: optimalPath.startsAt! as \"C\" | \"D\",\n      goesTo: optimalPath.goesTo! as \"C\" | \"D\",\n      points: subdivided,\n    },\n  }\n}\n","import { BaseSolver } from \"lib/solvers/BaseSolver\"\nimport {\n  NodeWithPortPoints,\n  HighDensityIntraNodeRoute,\n} from \"lib/types/high-density-types\"\nimport {\n  distance,\n  pointToSegmentDistance,\n  doSegmentsIntersect,\n} from \"@tscircuit/math-utils\"\nimport type { GraphicsObject } from \"graphics-debug\"\nimport { getIntraNodeCrossings } from \"lib/utils/getIntraNodeCrossings\"\nimport { findCircleLineIntersections } from \"./findCircleLineIntersections\"\nimport { computeDumbbellPaths } from \"./computeDumbbellPaths\"\n\ntype Point = { x: number; y: number; z?: number }\ntype Route = {\n  startPort: Point\n  endPort: Point\n  connectionName: string\n}\n\nexport class TwoCrossingRoutesHighDensitySolver extends BaseSolver {\n  // Input parameters\n  nodeWithPortPoints: NodeWithPortPoints\n  routes: Route[]\n\n  // Configuration parameters\n  viaDiameter: number\n  traceThickness: number\n  obstacleMargin: number\n  layerCount: number = 2\n\n  debugViaPositions: {\n    via1: Point\n    via2: Point\n  }[]\n\n  escapeLayer: number = 1\n\n  // Solution state\n  solvedRoutes: HighDensityIntraNodeRoute[] = []\n\n  // Bounds\n  bounds: { minX: number; maxX: number; minY: number; maxY: number }\n\n  constructor(params: {\n    nodeWithPortPoints: NodeWithPortPoints\n    viaDiameter?: number\n    traceThickness?: number\n    obstacleMargin?: number\n    layerCount?: number\n  }) {\n    super()\n\n    this.nodeWithPortPoints = params.nodeWithPortPoints\n    this.viaDiameter = params?.viaDiameter ?? 0.6\n    this.traceThickness = params?.traceThickness ?? 0.15\n    this.obstacleMargin = params?.obstacleMargin ?? 0.1\n    this.layerCount = params?.layerCount ?? 2\n    this.debugViaPositions = []\n\n    // Extract routes from the node data\n    this.routes = this.extractRoutesFromNode()\n\n    // Calculate bounds\n    this.bounds = this.calculateBounds()\n\n    if (this.routes.length !== 2) {\n      this.failed = true\n      return\n    }\n\n    const [routeA, routeB] = this.routes\n    const routeAStartsAndEndsOnSameLayer =\n      routeA.startPort.z === routeA.endPort.z\n    if (!routeAStartsAndEndsOnSameLayer) {\n      this.failed = true\n      return\n    }\n\n    const routeBStartsAndEndsOnSameLayer =\n      routeB.startPort.z === routeB.endPort.z\n    if (!routeBStartsAndEndsOnSameLayer) {\n      this.failed = true\n      return\n    }\n\n    const routesAreSameLayer = routeA.startPort.z === routeB.startPort.z\n    if (!routesAreSameLayer) {\n      this.failed = true\n      return\n    }\n    // TODO check to make sure the lines cross\n\n    // TODO support more layers, use availableZLayers when it's provided\n    if (routeA.startPort.z === 0) {\n      this.escapeLayer = 1\n    } else {\n      this.escapeLayer = 0\n    }\n  }\n\n  /**\n   * Extract routes that need to be connected from the node data\n   */\n  private extractRoutesFromNode(): Route[] {\n    const routes: Route[] = []\n    const connectedPorts = this.nodeWithPortPoints.portPoints!\n\n    // Group ports by connection name\n    const connectionGroups = new Map<string, Point[]>()\n\n    for (const connectedPort of connectedPorts) {\n      const { connectionName } = connectedPort\n      if (!connectionGroups.has(connectionName)) {\n        connectionGroups.set(connectionName, [])\n      }\n      connectionGroups.get(connectionName)?.push(connectedPort)\n    }\n\n    // Create routes for each connection (assuming each connection has exactly 2 points)\n    for (const [connectionName, points] of connectionGroups.entries()) {\n      if (points.length === 2) {\n        routes.push({\n          startPort: { ...points[0], z: points[0].z ?? 0 },\n          endPort: { ...points[1], z: points[1].z ?? 0 },\n          connectionName,\n        })\n      }\n    }\n\n    return routes\n  }\n\n  /**\n   * Calculate the bounding box of the node\n   */\n  private calculateBounds() {\n    return {\n      minX:\n        this.nodeWithPortPoints.center.x - this.nodeWithPortPoints.width / 2,\n      maxX:\n        this.nodeWithPortPoints.center.x + this.nodeWithPortPoints.width / 2,\n      minY:\n        this.nodeWithPortPoints.center.y - this.nodeWithPortPoints.height / 2,\n      maxY:\n        this.nodeWithPortPoints.center.y + this.nodeWithPortPoints.height / 2,\n    }\n  }\n\n  /**\n   * Check if two routes are crossing\n   */\n  private doRoutesCross(routeA: Route, routeB: Route): boolean {\n    return doSegmentsIntersect(\n      routeA.startPort,\n      routeA.endPort,\n      routeB.startPort,\n      routeB.endPort,\n    )\n  }\n\n  private calculateViaPositions(\n    routeA: Route,\n    routeB: Route,\n  ): {\n    via1: Point\n    via2: Point\n  } | null {\n    // Define outer box as the bounds where all points lie\n    const outerBox = {\n      width: this.bounds.maxX - this.bounds.minX,\n      height: this.bounds.maxY - this.bounds.minY,\n      x: this.bounds.minX,\n      y: this.bounds.minY,\n    }\n\n    // Define inner box with padding of obstacleMargin\n    const innerBox = {\n      width: outerBox.width - 2 * this.obstacleMargin - this.viaDiameter,\n      height: outerBox.height - 2 * this.obstacleMargin - this.viaDiameter,\n      x: outerBox.x + this.obstacleMargin + this.viaDiameter / 2,\n      y: outerBox.y + this.obstacleMargin + this.viaDiameter / 2,\n    }\n\n    // Define the K1 parameter (minimum distance from A/B to C/D)\n    // We'll use viaDiameter + obstacleMargin as the minimum distance\n    const K1 = this.viaDiameter + this.obstacleMargin\n\n    // Get points A and B from the routeB\n    const pointA = routeB.startPort\n    const pointB = routeB.endPort\n\n    // Get the inner box corners\n    const corners = [\n      { x: innerBox.x, y: innerBox.y }, // Top-left (0)\n      { x: innerBox.x + innerBox.width, y: innerBox.y }, // Top-right (1)\n      { x: innerBox.x + innerBox.width, y: innerBox.y + innerBox.height }, // Bottom-right (2)\n      { x: innerBox.x, y: innerBox.y + innerBox.height }, // Bottom-left (3)\n    ]\n\n    // Calculate distance between two points\n    const distanceBetween = (p1: Point, p2: Point): number => {\n      return distance(p1, p2)\n    }\n\n    // Find all valid candidate points\n    const candidatePoints: Array<\n      Point & { type: string; index?: number; circle?: number; edge?: number }\n    > = []\n\n    // 1. First check which corners are valid (outside both K1 circles)\n    corners.forEach((corner, index) => {\n      if (\n        distanceBetween(corner, pointA) >= K1 &&\n        distanceBetween(corner, pointB) >= K1\n      ) {\n        candidatePoints.push({ ...corner, type: \"corner\", index })\n      }\n    })\n\n    // 2. Find intersections of K1 circles with the inner box edges\n    // Define the 4 edges of the inner box\n    const edges = [\n      { p1: corners[0], p2: corners[1] }, // top\n      { p1: corners[1], p2: corners[2] }, // right\n      { p1: corners[2], p2: corners[3] }, // bottom\n      { p1: corners[3], p2: corners[0] }, // left\n    ]\n\n    // Find intersections for both circles with all edges\n    ;[pointA, pointB].forEach((circleCenter, circleIndex) => {\n      edges.forEach((edge, edgeIndex) => {\n        const intersections = findCircleLineIntersections(\n          { ...circleCenter, r: K1 },\n          edge,\n        )\n\n        // For each intersection, check if it's also outside the other circle\n        intersections.forEach((point) => {\n          const otherCircle = circleIndex === 0 ? pointB : pointA\n          if (distanceBetween(point, otherCircle) >= K1) {\n            candidatePoints.push({\n              ...point,\n              type: \"intersection\",\n              circle: circleIndex,\n              edge: edgeIndex,\n            })\n          }\n        })\n      })\n    })\n\n    // If we have fewer than 2 candidate points, relax the constraints\n    if (candidatePoints.length < 2) {\n      // Try with smaller K1\n      const relaxedK1 = K1 * 0.8 // Reduce by 20%\n      corners.forEach((corner, index) => {\n        if (\n          distanceBetween(corner, pointA) >= relaxedK1 &&\n          distanceBetween(corner, pointB) >= relaxedK1 &&\n          !candidatePoints.some((p) => p.x === corner.x && p.y === corner.y)\n        ) {\n          candidatePoints.push({ ...corner, type: \"relaxed_corner\", index })\n        }\n      })\n\n      // If still not enough, add corners sorted by distance\n      if (candidatePoints.length < 2) {\n        // Sort corners by their distance from A and B\n        const sortedCorners = [...corners].sort((a, b) => {\n          const aMinDist = Math.min(\n            distanceBetween(a, pointA),\n            distanceBetween(a, pointB),\n          )\n          const bMinDist = Math.min(\n            distanceBetween(b, pointA),\n            distanceBetween(b, pointB),\n          )\n          return bMinDist - aMinDist // Larger distances first\n        })\n\n        // Add corners not already in candidatePoints\n        for (const corner of sortedCorners) {\n          if (\n            !candidatePoints.some((p) => p.x === corner.x && p.y === corner.y)\n          ) {\n            candidatePoints.push({ ...corner, type: \"forced_corner\" })\n            if (candidatePoints.length >= 2) break\n          }\n        }\n      }\n    }\n\n    // If still fewer than 2 candidates, return null\n    if (candidatePoints.length < 2) {\n      return null\n    }\n\n    // Find the pair of points with maximum distance between them\n    let maxDist = 0\n    let optimalPair = [\n      candidatePoints[0],\n      candidatePoints[candidatePoints.length > 1 ? 1 : 0],\n    ]\n\n    for (let i = 0; i < candidatePoints.length; i++) {\n      for (let j = i + 1; j < candidatePoints.length; j++) {\n        const dist = distanceBetween(candidatePoints[i], candidatePoints[j])\n        if (dist > maxDist) {\n          maxDist = dist\n          optimalPair = [candidatePoints[i], candidatePoints[j]]\n        }\n      }\n    }\n\n    let via1 = { x: optimalPair[0].x, y: optimalPair[0].y }\n    let via2 = { x: optimalPair[1].x, y: optimalPair[1].y }\n\n    const via1DistToStart = distance(via1, routeA.startPort)\n    const via2DistToStart = distance(via2, routeA.startPort)\n\n    if (via2DistToStart < via1DistToStart) {\n      ;[via1, via2] = [via2, via1]\n    }\n\n    return {\n      via1,\n      via2,\n    }\n  }\n\n  /**\n   * Try to solve with routeA going over and routeB staying on layer 0\n   */\n  private trySolveAOverB(\n    routeA: Route,\n    routeB: Route,\n    swapVias = false,\n  ): boolean {\n    const viaPositions = swapVias\n      ? this.calculateViaPositions(routeA, routeB)\n      : this.calculateViaPositions(routeB, routeA)\n    if (viaPositions) {\n      this.debugViaPositions.push(viaPositions)\n    } else {\n      return false\n    }\n\n    // Move vias away from endpoints first, then ensure minimum spacing\n    const { via1, via2 } = this.pushViasFromEndpoints(\n      this.moveViasAsCloseAsPossible(viaPositions),\n    )\n    this.debugViaPositions.push({ via1, via2 })\n\n    const NOT_CIRCULAR_PENALTY_TC = 1.5\n    const { jPair, optimalPath } = computeDumbbellPaths({\n      A: via1,\n      B: via2,\n      C: routeA.startPort,\n      D: routeA.endPort,\n      E: routeB.startPort,\n      F: routeB.endPort,\n      // NOTE: Should be traceThickness /2, but we don't currently subdivide\n      // enough to make a round enough circle, so we have to add additional margin\n      radius:\n        this.viaDiameter / 2 +\n        this.obstacleMargin +\n        (this.traceThickness / 2) * NOT_CIRCULAR_PENALTY_TC,\n      margin:\n        this.obstacleMargin * 2 +\n        (this.traceThickness / 2) * NOT_CIRCULAR_PENALTY_TC,\n      subdivisions: 1,\n    })\n\n    if (!jPair) return false\n\n    const routeASolution: HighDensityIntraNodeRoute = {\n      connectionName: routeA.connectionName,\n      route: optimalPath.points.map((p) => ({\n        x: p.x,\n        y: p.y,\n        z: routeA.startPort.z ?? 0,\n      })),\n      traceThickness: this.traceThickness,\n      viaDiameter: this.viaDiameter,\n      vias: [],\n    }\n    jPair.line2.points.reverse()\n    const routeBSolution: HighDensityIntraNodeRoute = {\n      connectionName: routeB.connectionName,\n      route: [\n        ...jPair.line1.points.map((p) => ({\n          x: p.x,\n          y: p.y,\n          z: routeB.startPort.z ?? 0,\n        })),\n        {\n          ...jPair.line1.points[jPair.line1.points.length - 1],\n          z: this.escapeLayer,\n        },\n        { ...jPair.line2.points[0], z: this.escapeLayer },\n        ...jPair.line2.points.map((p) => ({\n          x: p.x,\n          y: p.y,\n          z: routeB.startPort.z ?? 0,\n        })),\n      ],\n      traceThickness: this.traceThickness,\n      viaDiameter: this.viaDiameter,\n      vias: [via1, via2],\n    }\n\n    this.solvedRoutes.push(routeASolution, routeBSolution)\n    return true\n  }\n\n  private pushViasFromEndpoints(viaPositions: {\n    via1: Point\n    via2: Point\n  }): {\n    via1: Point\n    via2: Point\n  } {\n    const currentVia1 = { ...viaPositions.via1 }\n    const currentVia2 = { ...viaPositions.via2 }\n\n    const endpoints = [\n      this.routes[0].startPort,\n      this.routes[0].endPort,\n      this.routes[1].startPort,\n      this.routes[1].endPort,\n    ]\n\n    const optimalDistBtwViaCenters = this.getMinDistanceBetweenViaCenters()\n    // Required clearance: via radius + trace thickness + obstacle margin\n    const minDistanceBtwViaAndEndpoint =\n      this.viaDiameter / 2 + this.traceThickness * 2 + this.obstacleMargin * 2\n\n    const MAX_ITERS = 10\n    const PUSH_DECAY = 0.9 // Decay push force over iterations\n\n    for (let iter = 0; iter < MAX_ITERS; iter++) {\n      let via1Moved = false\n      let via2Moved = false\n      const pushDecayFactor = PUSH_DECAY ** iter\n\n      // --- Push from Endpoints ---\n      for (const endpoint of endpoints) {\n        // Check Via 1\n        const dist1 = distance(currentVia1, endpoint)\n        if (dist1 < minDistanceBtwViaAndEndpoint) {\n          const overlap = minDistanceBtwViaAndEndpoint - dist1\n          const pushAmount = overlap * pushDecayFactor\n          const dx = currentVia1.x - endpoint.x\n          const dy = currentVia1.y - endpoint.y\n          const norm = Math.sqrt(dx * dx + dy * dy)\n          if (norm > 1e-6) {\n            // Avoid division by zero if via is exactly on endpoint\n            currentVia1.x += (dx / norm) * pushAmount\n            currentVia1.y += (dy / norm) * pushAmount\n            via1Moved = true\n          }\n        }\n\n        // Check Via 2\n        const dist2 = distance(currentVia2, endpoint)\n        if (dist2 < minDistanceBtwViaAndEndpoint) {\n          const overlap = minDistanceBtwViaAndEndpoint - dist2\n          const pushAmount = overlap * pushDecayFactor\n          const dx = currentVia2.x - endpoint.x\n          const dy = currentVia2.y - endpoint.y\n          const norm = Math.sqrt(dx * dx + dy * dy)\n          if (norm > 1e-6) {\n            currentVia2.x += (dx / norm) * pushAmount\n            currentVia2.y += (dy / norm) * pushAmount\n            via2Moved = true\n          }\n        }\n      }\n\n      // --- Ensure Minimum Distance Between Vias ---\n      const distBetweenVias = distance(currentVia1, currentVia2)\n      if (distBetweenVias < optimalDistBtwViaCenters) {\n        const overlap = optimalDistBtwViaCenters - distBetweenVias\n        const pushAmount = overlap / 2 // Push each via half the distance\n\n        const dx = currentVia2.x - currentVia1.x\n        const dy = currentVia2.y - currentVia1.y\n        const norm = Math.sqrt(dx * dx + dy * dy)\n\n        if (norm > 1e-6) {\n          // Push via1 away from via2\n          currentVia1.x -= (dx / norm) * pushAmount\n          currentVia1.y -= (dy / norm) * pushAmount\n          // Push via2 away from via1\n          currentVia2.x += (dx / norm) * pushAmount\n          currentVia2.y += (dy / norm) * pushAmount\n          via1Moved = true\n          via2Moved = true\n        } else {\n          // Vias are coincident, push them apart arbitrarily (e.g., horizontally)\n          currentVia1.x -= pushAmount\n          currentVia2.x += pushAmount\n          via1Moved = true\n          via2Moved = true\n        }\n      }\n\n      // If neither via moved in this iteration, we've reached stability\n      if (!via1Moved && !via2Moved) {\n        break\n      }\n    }\n\n    // Final check: ensure vias are not too close after all adjustments\n    const finalDist = distance(currentVia1, currentVia2)\n    if (finalDist < optimalDistBtwViaCenters) {\n      const overlap = optimalDistBtwViaCenters - finalDist\n      const pushAmount = overlap / 2\n      const dx = currentVia2.x - currentVia1.x\n      const dy = currentVia2.y - currentVia1.y\n      const norm = Math.sqrt(dx * dx + dy * dy)\n      if (norm > 1e-6) {\n        currentVia1.x -= (dx / norm) * pushAmount\n        currentVia1.y -= (dy / norm) * pushAmount\n        currentVia2.x += (dx / norm) * pushAmount\n        currentVia2.y += (dy / norm) * pushAmount\n      } else {\n        currentVia1.x -= pushAmount\n        currentVia2.x += pushAmount\n      }\n    }\n\n    return { via1: currentVia1, via2: currentVia2 }\n  }\n\n  private getMinDistanceBetweenViaCenters(): number {\n    return this.viaDiameter + this.traceThickness + this.obstacleMargin * 2\n  }\n\n  private moveViasAsCloseAsPossible(viaPositions: {\n    via1: Point\n    via2: Point\n  }): {\n    via1: Point\n    via2: Point\n  } {\n    const { via1, via2 } = viaPositions\n\n    // Calculate the minimum required distance between vias\n    const minRequiredDistance = this.getMinDistanceBetweenViaCenters()\n\n    // Calculate current distance between vias\n    const currentDistance = distance(via1, via2)\n\n    // If vias are already closer than or equal to the minimum required distance, return as is\n    if (currentDistance <= minRequiredDistance) {\n      return viaPositions\n    }\n\n    // Calculate the direction vector from viaA to viaB\n    const dirX = via2.x - via1.x\n    const dirY = via2.y - via1.y\n\n    // Normalize the direction vector\n    const dirLength = Math.sqrt(dirX * dirX + dirY * dirY)\n    const normDirX = dirX / dirLength\n    const normDirY = dirY / dirLength\n\n    // Calculate the midpoint of the current vias\n    const midpointX = (via1.x + via2.x) / 2\n    const midpointY = (via1.y + via2.y) / 2\n\n    // Calculate new positions that are minRequiredDistance apart\n    // Move each via half the distance towards the midpoint\n    const moveDistance = (currentDistance - minRequiredDistance) / 2\n\n    const newVia1 = {\n      x: via1.x + normDirX * moveDistance,\n      y: via1.y + normDirY * moveDistance,\n    }\n\n    const newVia2 = {\n      x: via2.x - normDirX * moveDistance,\n      y: via2.y - normDirY * moveDistance,\n    }\n\n    return {\n      via1: newVia1,\n      via2: newVia2,\n    }\n  }\n\n  handleRoutesDontCross() {\n    const [routeA, routeB] = this.routes\n    // Routes don't cross, create simple direct connections\n    const routeASolution: HighDensityIntraNodeRoute = {\n      connectionName: routeA.connectionName,\n      route: [\n        {\n          x: routeA.startPort.x,\n          y: routeA.startPort.y,\n          z: routeA.startPort.z ?? 0,\n        },\n        {\n          x: routeA.endPort.x,\n          y: routeA.endPort.y,\n          z: routeA.endPort.z ?? 0,\n        },\n      ],\n      traceThickness: this.traceThickness,\n      viaDiameter: this.viaDiameter,\n      vias: [],\n    }\n\n    const routeBSolution: HighDensityIntraNodeRoute = {\n      connectionName: routeB.connectionName,\n      route: [\n        {\n          x: routeB.startPort.x,\n          y: routeB.startPort.y,\n          z: routeB.startPort.z ?? 0,\n        },\n        {\n          x: routeB.endPort.x,\n          y: routeB.endPort.y,\n          z: routeB.endPort.z ?? 0,\n        },\n      ],\n      traceThickness: this.traceThickness,\n      viaDiameter: this.viaDiameter,\n      vias: [],\n    }\n\n    this.solvedRoutes.push(routeASolution, routeBSolution)\n    this.solved = true\n    return\n  }\n\n  /**\n   * Main step method that attempts to solve the two crossing routes\n   */\n  _step() {\n    // Check if we have exactly two routes\n    if (this.routes.length !== 2) {\n      this.failed = true\n      return\n    }\n\n    const [routeA, routeB] = this.routes\n\n    // Check if routes are actually crossing\n    if (!this.doRoutesCross(routeA, routeB)) {\n      this.handleRoutesDontCross()\n      return\n    }\n\n    // Try having route A go over route B\n    if (this.trySolveAOverB(routeA, routeB)) {\n      this.solved = true\n      return\n    }\n    // If that fails, try having route B go over route A\n    if (this.trySolveAOverB(routeB, routeA)) {\n      this.solved = true\n      return\n    }\n\n    // HACK: Via calculation is not great, so we'll also try swapping their\n    // locations and trying again\n    // Try having route A go over route B\n    if (this.trySolveAOverB(routeA, routeB, true)) {\n      this.solved = true\n      return\n    }\n    // If that fails, try having route B go over route A\n    if (this.trySolveAOverB(routeB, routeA, true)) {\n      this.solved = true\n      return\n    }\n\n    // If both approaches fail, mark as failed\n    this.failed = true\n  }\n\n  /**\n   * Visualization for debugging\n   */\n  visualize(): GraphicsObject {\n    const graphics: GraphicsObject = {\n      lines: [],\n      points: [],\n      rects: [],\n      circles: [],\n    }\n\n    // Draw PCB bounds\n    graphics.rects!.push({\n      center: {\n        x: (this.bounds.minX + this.bounds.maxX) / 2,\n        y: (this.bounds.minY + this.bounds.maxY) / 2,\n      },\n      width: this.bounds.maxX - this.bounds.minX,\n      height: this.bounds.maxY - this.bounds.minY,\n      stroke: \"rgba(0, 0, 0, 0.5)\",\n      fill: \"rgba(240, 240, 240, 0.1)\",\n    })\n\n    // Draw original routes\n    for (const [routeName, route] of [\n      [\"Route A\", this.routes[0]],\n      [\"Route B\", this.routes[1]],\n    ] as const) {\n      // Draw endpoints\n      graphics.points!.push({\n        x: route.startPort.x,\n        y: route.startPort.y,\n        label: `${routeName}\\n${route.connectionName} start`,\n        color: \"orange\",\n      })\n\n      graphics.points!.push({\n        x: route.endPort.x,\n        y: route.endPort.y,\n        label: `${routeName}\\n${route.connectionName} end`,\n        color: \"orange\",\n      })\n\n      // Draw direct connection line\n      graphics.lines!.push({\n        points: [route.startPort, route.endPort],\n        strokeColor: \"rgba(255, 0, 0, 0.5)\",\n        label: `${routeName}\\n${route.connectionName} direct`,\n      })\n    }\n\n    // Draw debug via positions (even if solution failed)\n    for (let i = 0; i < this.debugViaPositions.length; i++) {\n      const { via1, via2 } = this.debugViaPositions[i]\n\n      // Draw computed vias (using different colors for different attempts)\n      const colors = [\"rgba(255, 165, 0, 0.3)\", \"rgba(128, 0, 128, 0.3)\"] // orange, purple\n      const color = colors[i % colors.length]\n\n      graphics.circles!.push({\n        center: via1,\n        radius: this.viaDiameter / 2,\n        fill: color,\n        stroke: \"rgba(0, 0, 0, 0.3)\",\n        label: `Computed Via A (attempt ${i + 1})`,\n      })\n\n      graphics.circles!.push({\n        center: via2,\n        radius: this.viaDiameter / 2,\n        fill: color,\n        stroke: \"rgba(0, 0, 0, 0.3)\",\n        label: `Computed Via B (attempt ${i + 1})`,\n      })\n\n      // Draw safety margins around vias\n      const safetyMargin = this.viaDiameter / 2 + this.obstacleMargin\n      graphics.circles!.push({\n        center: via1,\n        radius: safetyMargin,\n        stroke: color,\n        fill: \"rgba(0, 0, 0, 0)\",\n        label: `Debug Via 1 Safety Margin (attempt ${i + 1})`,\n      })\n\n      graphics.circles!.push({\n        center: via2,\n        radius: safetyMargin,\n        stroke: color,\n        fill: \"rgba(0, 0, 0, 0)\",\n        label: `Debug Via 2 Safety Margin (attempt ${i + 1})`,\n      })\n\n      // Draw potential route through vias\n      graphics.lines!.push({\n        points: [\n          this.routes[i % 2].startPort,\n          via1,\n          via2,\n          this.routes[i % 2].endPort,\n        ],\n        strokeColor: `${color.substring(0, color.lastIndexOf(\",\"))}, 0.3)`,\n        strokeDash: [5, 5],\n        label: `Potential Route (attempt ${i + 1})`,\n      })\n    }\n\n    // Draw solved routes if available\n    for (let si = 0; si < this.solvedRoutes.length; si++) {\n      const route = this.solvedRoutes[si]\n      const routeColor =\n        si % 2 === 0 ? \"rgba(0, 255, 0, 0.75)\" : \"rgba(255, 0, 255, 0.75)\"\n      for (let i = 0; i < route.route.length - 1; i++) {\n        const pointA = route.route[i]\n        const pointB = route.route[i + 1]\n\n        graphics.lines!.push({\n          points: [pointA, pointB],\n          strokeColor: routeColor,\n          strokeDash: pointA.z === 1 ? [0.2, 0.2] : undefined,\n          strokeWidth: route.traceThickness,\n          label: `${route.connectionName} z=${pointA.z}`,\n        })\n\n        if ((pointA as any)._label) {\n          graphics.points!.push({\n            x: pointA.x,\n            y: pointA.y,\n            label: (pointA as any)._label,\n          })\n        }\n      }\n\n      // Draw vias in solved routes\n      for (const via of route.vias) {\n        graphics.circles!.push({\n          center: via,\n          radius: this.viaDiameter / 2,\n          fill: \"rgba(0, 0, 255, 0.8)\",\n          stroke: \"black\",\n          label: \"Solved Via\",\n        })\n        graphics.circles!.push({\n          center: via,\n          radius: this.viaDiameter / 2 + this.obstacleMargin,\n          fill: \"rgba(0, 0, 255, 0.3)\",\n          stroke: \"black\",\n          label: \"Solved Via Margin\",\n        })\n      }\n    }\n\n    return graphics\n  }\n\n  /**\n   * Get the solved routes\n   */\n  getSolvedRoutes(): HighDensityIntraNodeRoute[] {\n    return this.solvedRoutes\n  }\n}\n","interface Point {\n  x: number\n  y: number\n}\n\n/**\n * Finds the optimal position that is closest to the average of points A, B, and C,\n * while maintaining a minimum distance of radius from each point and staying within bounds.\n *\n * https://claude.ai/artifacts/b61d2619-0d39-45e7-b02b-ebdcb645f07e\n */\nexport function findClosestPointToABCWithinBounds(\n  A: Point,\n  B: Point,\n  C: Point,\n  radius: number,\n  bounds: { minX: number; minY: number; maxX: number; maxY: number },\n) {\n  // Calculate the average point (center of mass)\n  const avgPoint = {\n    x: (A.x + B.x + C.x) / 3,\n    y: (A.y + B.y + C.y) / 3,\n  }\n\n  // Function to calculate distance between two points\n  const distance = (p1: Point, p2: Point) => {\n    return Math.sqrt((p2.x - p1.x) ** 2 + (p2.y - p1.y) ** 2)\n  }\n\n  // Function to check if a point satisfies all constraints\n  const isValidPoint = (point: Point) => {\n    // Check distance constraints\n    const distToA = distance(point, A)\n    const distToB = distance(point, B)\n    const distToC = distance(point, C)\n\n    // Check bounds constraints\n    const withinBounds =\n      point.x >= bounds.minX &&\n      point.x <= bounds.maxX &&\n      point.y >= bounds.minY &&\n      point.y <= bounds.maxY\n\n    return (\n      distToA >= radius &&\n      distToB >= radius &&\n      distToC >= radius &&\n      withinBounds\n    )\n  }\n\n  // Function to check if a point is on the boundary\n  const isOnBoundary = (point: Point) => {\n    const epsilon = 1e-6\n    return (\n      Math.abs(point.x - bounds.minX) < epsilon ||\n      Math.abs(point.x - bounds.maxX) < epsilon ||\n      Math.abs(point.y - bounds.minY) < epsilon ||\n      Math.abs(point.y - bounds.maxY) < epsilon\n    )\n  }\n\n  // First check if average point satisfies all constraints\n  if (isValidPoint(avgPoint)) {\n    return avgPoint\n  }\n\n  // Next, check all the standard candidates based on circles and intersections\n  const pointOnCircle = (center: Point, constraint: Point, r: number) => {\n    const vx = center.x - constraint.x\n    const vy = center.y - constraint.y\n    const dist = Math.sqrt(vx * vx + vy * vy)\n\n    if (dist < 1e-10) {\n      return { x: constraint.x + r, y: constraint.y }\n    }\n\n    return {\n      x: constraint.x + (vx / dist) * r,\n      y: constraint.y + (vy / dist) * r,\n    }\n  }\n\n  const findCircleIntersections = (c1: Point, c2: Point, r: number) => {\n    const dx = c2.x - c1.x\n    const dy = c2.y - c1.y\n    const dist = Math.sqrt(dx * dx + dy * dy)\n\n    if (dist > 2 * r - 1e-10 || dist < 1e-10) {\n      return []\n    }\n\n    const a = (dist * dist) / (2 * dist)\n    const h = Math.sqrt(Math.max(0, r * r - a * a))\n\n    const midX = c1.x + (dx * a) / dist\n    const midY = c1.y + (dy * a) / dist\n\n    const intersection1 = {\n      x: midX + (h * dy) / dist,\n      y: midY - (h * dx) / dist,\n    }\n\n    const intersection2 = {\n      x: midX - (h * dy) / dist,\n      y: midY + (h * dx) / dist,\n    }\n\n    const result = []\n    const epsilon = 1e-6\n\n    if (\n      Math.abs(distance(intersection1, c1) - r) < epsilon &&\n      Math.abs(distance(intersection1, c2) - r) < epsilon\n    ) {\n      result.push(intersection1)\n    }\n\n    if (\n      Math.abs(distance(intersection2, c1) - r) < epsilon &&\n      Math.abs(distance(intersection2, c2) - r) < epsilon\n    ) {\n      result.push(intersection2)\n    }\n\n    return result\n  }\n\n  // Get all standard candidates\n  const candidateA = pointOnCircle(avgPoint, A, radius)\n  const candidateB = pointOnCircle(avgPoint, B, radius)\n  const candidateC = pointOnCircle(avgPoint, C, radius)\n\n  const intersectionsAB = findCircleIntersections(A, B, radius)\n  const intersectionsBC = findCircleIntersections(B, C, radius)\n  const intersectionsCA = findCircleIntersections(C, A, radius)\n\n  const allCandidates = [\n    candidateA,\n    candidateB,\n    candidateC,\n    ...intersectionsAB,\n    ...intersectionsBC,\n    ...intersectionsCA,\n  ]\n\n  // Filter to valid candidates\n  const validCandidates = allCandidates.filter(isValidPoint)\n\n  // If we have valid interior candidates, use them\n  if (validCandidates.length > 0) {\n    // Separate interior and boundary points\n    const interiorCandidates = validCandidates.filter((p) => !isOnBoundary(p))\n\n    if (interiorCandidates.length > 0) {\n      // Sort by distance to average\n      interiorCandidates.sort(\n        (a, b) => distance(a, avgPoint) - distance(b, avgPoint),\n      )\n      return interiorCandidates[0]\n    }\n  }\n\n  // No valid interior candidates from standard points, now do a grid search\n  // We'll do a systematic grid search to find interior points\n  const gridStep = 5 // 5px grid\n  let bestPoint = null\n  let bestDistance = Infinity\n\n  for (let x = bounds.minX + 1; x < bounds.maxX; x += gridStep) {\n    for (let y = bounds.minY + 1; y < bounds.maxY; y += gridStep) {\n      const point = { x, y }\n      if (isValidPoint(point)) {\n        const dist = distance(point, avgPoint)\n        if (dist < bestDistance) {\n          bestDistance = dist\n          bestPoint = point\n        }\n      }\n    }\n  }\n\n  // If we found a valid interior point in the grid search, return it\n  if (bestPoint !== null) {\n    return bestPoint\n  }\n\n  // If all interior methods failed, check boundary points\n  // Sample points along the boundary\n  const numSamples = 100 // More samples for better accuracy\n  const boundaryPoints = []\n\n  for (let i = 0; i <= numSamples; i++) {\n    const t = i / numSamples\n\n    // Top edge\n    boundaryPoints.push({\n      x: bounds.minX + t * (bounds.maxX - bounds.minX),\n      y: bounds.minY,\n    })\n\n    // Right edge\n    boundaryPoints.push({\n      x: bounds.maxX,\n      y: bounds.minY + t * (bounds.maxY - bounds.minY),\n    })\n\n    // Bottom edge\n    boundaryPoints.push({\n      x: bounds.maxX - t * (bounds.maxX - bounds.minX),\n      y: bounds.maxY,\n    })\n\n    // Left edge\n    boundaryPoints.push({\n      x: bounds.minX,\n      y: bounds.maxY - t * (bounds.maxY - bounds.minY),\n    })\n  }\n\n  // Find valid boundary points\n  const validBoundaryPoints = boundaryPoints.filter(isValidPoint)\n\n  if (validBoundaryPoints.length > 0) {\n    // Sort by distance to average\n    validBoundaryPoints.sort(\n      (a, b) => distance(a, avgPoint) - distance(b, avgPoint),\n    )\n    return validBoundaryPoints[0]\n  }\n\n  // If we get here, no valid point exists that satisfies all constraints\n  // Find the point that minimizes constraint violations\n  let minViolation = Infinity\n  let leastBadPoint = { x: bounds.minX, y: bounds.minY }\n\n  for (const point of [...allCandidates, ...boundaryPoints]) {\n    // Only consider points within bounds\n    if (\n      point.x >= bounds.minX &&\n      point.x <= bounds.maxX &&\n      point.y >= bounds.minY &&\n      point.y <= bounds.maxY\n    ) {\n      const violationA = Math.max(0, radius - distance(point, A))\n      const violationB = Math.max(0, radius - distance(point, B))\n      const violationC = Math.max(0, radius - distance(point, C))\n\n      const totalViolation = violationA + violationB + violationC\n\n      if (totalViolation < minViolation) {\n        minViolation = totalViolation\n        leastBadPoint = point\n      }\n    }\n  }\n\n  return leastBadPoint\n}\n","interface Point {\n  x: number\n  y: number\n}\n\ninterface Circle {\n  center: Point\n  radius: number\n}\n\n/**\n * Finds the tangent points and their intersection for the shortest path from C to A\n * that touches the circle Q at points B and D.\n *\n * E is the point where you're guaranteed to be able to get around the circle\n * without intersecting it if you travel from A to E to C\n *\n * @param A First observation point\n * @param C Second observation point\n * @param Q Circle definition with center and radius\n * @returns Object containing points B, D, and E\n */\nexport function findPointToGetAroundCircle(\n  A: Point,\n  C: Point,\n  Q: Circle,\n): { B: Point; D: Point; E: Point } {\n  // Compute point B (tangent from C to circle Q)\n  const B = computeTangentPoint(C, A, Q.center, Q.radius)\n\n  // Compute point D (tangent from A to circle Q)\n  const D = computeTangentPoint(A, C, Q.center, Q.radius)\n\n  // Check if B and D are valid (not too close to C and A respectively)\n  const distBC = distance(B, C)\n  const distAD = distance(A, D)\n  const minDistThreshold = 1e-6\n\n  const BIsValid = distBC > minDistThreshold\n  const DIsValid = distAD > minDistThreshold\n\n  // Compute point E using a robust approach\n  let E: Point\n\n  if (!BIsValid || !DIsValid) {\n    // Fallback: Use the midpoint between A and C but ensure it's outside the circle\n    const midAC = {\n      x: (A.x + C.x) / 2,\n      y: (A.y + C.y) / 2,\n    }\n\n    const distFromCenter = distance(midAC, Q.center)\n    if (distFromCenter < Q.radius * 1.1) {\n      // Too close to circle, move away from center\n      const dirFromCenter = {\n        x: (midAC.x - Q.center.x) / distFromCenter,\n        y: (midAC.y - Q.center.y) / distFromCenter,\n      }\n\n      E = {\n        x: Q.center.x + dirFromCenter.x * Q.radius * 1.2,\n        y: Q.center.y + dirFromCenter.y * Q.radius * 1.2,\n      }\n    } else {\n      // Midpoint is far enough from circle\n      E = midAC\n    }\n  } else {\n    // B and D are valid, use midpoint between B and D as a robust solution\n    E = {\n      x: (B.x + D.x) / 2,\n      y: (B.y + D.y) / 2,\n    }\n\n    // Check if the midpoint is a reasonable solution\n    const distBE = distance(B, E)\n    const distDE = distance(D, E)\n\n    if (Math.abs(distBE - distDE) > Math.min(distBE, distDE) * 0.5) {\n      // The midpoint is significantly closer to one point than the other\n      // Use a weighted average instead\n      const distAB = distance(A, B)\n      const distCD = distance(C, D)\n      const totalDist = distAB + distCD\n\n      if (totalDist > minDistThreshold) {\n        // Weight based on distances from A to B and C to D\n        const weightB = distCD / totalDist\n        const weightD = distAB / totalDist\n\n        E = {\n          x: B.x * weightB + D.x * weightD,\n          y: B.y * weightB + D.y * weightD,\n        }\n      }\n    }\n\n    // Final safety check: make sure E is outside the circle\n    const distEToCenter = distance(E, Q.center)\n    if (distEToCenter < Q.radius * 1.05) {\n      // E is too close to the circle, adjust it\n      const dirFromCenter = {\n        x: (E.x - Q.center.x) / distEToCenter,\n        y: (E.y - Q.center.y) / distEToCenter,\n      }\n\n      E = {\n        x: Q.center.x + dirFromCenter.x * Q.radius * 1.2,\n        y: Q.center.y + dirFromCenter.y * Q.radius * 1.2,\n      }\n    }\n  }\n\n  return { B, D, E }\n}\n\n/**\n * Computes the tangent point from an observation point to a circle\n *\n * @param observationPoint The point from which the tangent is drawn\n * @param referencePoint A reference point that helps determine which side of the circle to choose\n * @param circleCenter The center of the circle\n * @param radius The radius of the circle\n * @returns The tangent point on the circle\n */\nfunction computeTangentPoint(\n  observationPoint: Point,\n  referencePoint: Point,\n  circleCenter: Point,\n  radius: number,\n): Point {\n  // Vector from observation point to circle center\n  const CQ = [\n    circleCenter.x - observationPoint.x,\n    circleCenter.y - observationPoint.y,\n  ]\n  const CQLength = Math.sqrt(CQ[0] * CQ[0] + CQ[1] * CQ[1])\n\n  // Check if tangent is possible (point is inside or on the circle)\n  if (CQLength <= radius) {\n    // Instead of returning the observation point, find a point on the circle\n    // in the direction away from the circle center\n    if (CQLength < 1e-8) {\n      // If observation point is at circle center, move in direction of reference point\n      const refVec = [\n        referencePoint.x - observationPoint.x,\n        referencePoint.y - observationPoint.y,\n      ]\n      const refLength = Math.sqrt(refVec[0] * refVec[0] + refVec[1] * refVec[1])\n\n      if (refLength < 1e-8) {\n        // If reference point is also at circle center, use arbitrary direction\n        return {\n          x: circleCenter.x + radius,\n          y: circleCenter.y,\n        }\n      }\n\n      return {\n        x: circleCenter.x + (refVec[0] / refLength) * radius,\n        y: circleCenter.y + (refVec[1] / refLength) * radius,\n      }\n    }\n\n    // Move away from circle center along the same line\n    const CQUnit = [CQ[0] / CQLength, CQ[1] / CQLength]\n    return {\n      x: circleCenter.x - CQUnit[0] * radius,\n      y: circleCenter.y - CQUnit[1] * radius,\n    }\n  }\n\n  // Vector from observation point to reference point (to determine which side of the circle)\n  const CR = [\n    referencePoint.x - observationPoint.x,\n    referencePoint.y - observationPoint.y,\n  ]\n\n  // Calculate the distance from observation point to the tangent point\n  const d = Math.sqrt(CQLength * CQLength - radius * radius)\n\n  // Normalize CQ to get the unit vector in that direction\n  const CQUnit = [CQ[0] / CQLength, CQ[1] / CQLength]\n\n  // Calculate two possible perpendicular unit vectors\n  const perp1 = [-CQUnit[1], CQUnit[0]]\n  const perp2 = [CQUnit[1], -CQUnit[0]]\n\n  // Choose the perpendicular that forms an angle closer to CR\n  const dot1 = CR[0] * perp1[0] + CR[1] * perp1[1]\n  const dot2 = CR[0] * perp2[0] + CR[1] * perp2[1]\n  const perp = dot1 > dot2 ? perp1 : perp2\n\n  // Calculate the sine and cosine of the angle from CQ to the tangent line\n  const sinTheta = radius / CQLength\n  const cosTheta = d / CQLength\n\n  // Unit vector in the direction of the tangent point\n  const unitToTangent = [\n    CQUnit[0] * cosTheta + perp[0] * sinTheta,\n    CQUnit[1] * cosTheta + perp[1] * sinTheta,\n  ]\n\n  // Calculate the tangent point\n  return {\n    x: observationPoint.x + d * unitToTangent[0],\n    y: observationPoint.y + d * unitToTangent[1],\n  }\n}\n\n/**\n * Helper function to calculate the Euclidean distance between two points\n */\nfunction distance(p1: Point, p2: Point): number {\n  const dx = p2.x - p1.x\n  const dy = p2.y - p1.y\n  return Math.sqrt(dx * dx + dy * dy)\n}\n","interface Point {\n  x: number\n  y: number\n}\n\ninterface Bounds {\n  minX: number\n  maxX: number\n  minY: number\n  maxY: number\n}\n\ninterface SidePercentages {\n  left: number\n  top: number\n  right: number\n  bottom: number\n}\n\n// Keep a small epsilon for floating point comparisons\nconst EPSILON = 1e-9 // Using a slightly smaller epsilon can sometimes help precision\n\n/**\n * Calculates the percentage of each side traversed when going from point A to point B\n * along the rectangle boundary, following the specified turn direction.\n */\nfunction calculateSegmentTraversal(\n  startPoint: Point,\n  endPoint: Point,\n  bounds: Bounds,\n  turnDirection: \"cw\" | \"ccw\" = \"cw\", // Default to clockwise\n): SidePercentages {\n  const startAngle = pointToAngle(startPoint, bounds)\n  const endAngle = pointToAngle(endPoint, bounds)\n\n  // Check if start and end points map to the same angle (within epsilon)\n  // Note: This doesn't necessarily mean the points are identical if the bounds are degenerate.\n  if (Math.abs(endAngle - startAngle) < EPSILON) {\n    // A more robust check might compare the points directly if needed:\n    // if (Math.abs(startPoint.x - endPoint.x) < EPSILON && Math.abs(startPoint.y - endPoint.y) < EPSILON)\n    return { left: 0, top: 0, right: 0, bottom: 0 } // No significant angular movement\n  }\n\n  // Pass raw angles and direction to the main calculation function\n  return calculateSidePercentages(startAngle, endAngle, bounds, turnDirection)\n}\n\n/**\n * Calculates the total percentage of each side traversed when going sequentially\n * from A to B, and then from B to C along a rectangle boundary.\n */\nexport function calculateTraversalPercentages(\n  A: Point,\n  B: Point,\n  C: Point,\n  bounds: Bounds,\n  turnDirection?: \"cw\" | \"ccw\",\n): SidePercentages {\n  // Calculate traversal percentages for the segment A -> B\n  const percentagesAB = calculateSegmentTraversal(A, B, bounds, turnDirection)\n\n  // Calculate traversal percentages for the segment B -> C\n  const percentagesBC = calculateSegmentTraversal(B, C, bounds, turnDirection)\n\n  // Sum the percentages from both segments\n  // Use Math.min to cap at 1.0 in case of tiny floating point overflows\n  const totalPercentages: SidePercentages = {\n    left: Math.min(1.0, percentagesAB.left + percentagesBC.left),\n    top: Math.min(1.0, percentagesAB.top + percentagesBC.top),\n    right: Math.min(1.0, percentagesAB.right + percentagesBC.right),\n    bottom: Math.min(1.0, percentagesAB.bottom + percentagesBC.bottom),\n  }\n\n  // Optional: Clean up near-zero values resulting from floating point inaccuracies\n  for (const key in totalPercentages) {\n    if (Math.abs(totalPercentages[key as keyof SidePercentages]) < EPSILON) {\n      totalPercentages[key as keyof SidePercentages] = 0\n    }\n  }\n\n  return totalPercentages\n}\n\n/**\n * Converts a point on the rectangle boundary to an angle (0 to 2, clockwise from top-left).\n * Updated to be slightly more robust with epsilon checks.\n */\nexport function pointToAngle(point: Point, bounds: Bounds): number {\n  const width = bounds.maxX - bounds.minX\n  const height = bounds.maxY - bounds.minY\n  // Avoid division by zero if width or height is zero\n  if (width < EPSILON && height < EPSILON) return 0\n  const perimeter = 2 * (width + height)\n  if (perimeter < EPSILON) return 0 // Avoid division by zero for degenerate rectangles\n\n  let distance = 0\n\n  // Check sides using epsilon comparisons\n  if (\n    Math.abs(point.y - bounds.maxY) < EPSILON &&\n    point.x >= bounds.minX - EPSILON &&\n    point.x <= bounds.maxX + EPSILON\n  ) {\n    // Top side (y is maxY)\n    // Ensure x is clamped within bounds for distance calculation robustness\n    distance = Math.max(0, Math.min(width, point.x - bounds.minX))\n  } else if (\n    Math.abs(point.x - bounds.maxX) < EPSILON &&\n    point.y >= bounds.minY - EPSILON &&\n    point.y <= bounds.maxY + EPSILON\n  ) {\n    // Right side (x is maxX)\n    // Ensure y is clamped within bounds\n    distance = width + Math.max(0, Math.min(height, bounds.maxY - point.y))\n  } else if (\n    Math.abs(point.y - bounds.minY) < EPSILON &&\n    point.x >= bounds.minX - EPSILON &&\n    point.x <= bounds.maxX + EPSILON\n  ) {\n    // Bottom side (y is minY)\n    // Ensure x is clamped within bounds\n    distance =\n      width + height + Math.max(0, Math.min(width, bounds.maxX - point.x))\n  } else if (\n    Math.abs(point.x - bounds.minX) < EPSILON &&\n    point.y >= bounds.minY - EPSILON &&\n    point.y <= bounds.maxY + EPSILON\n  ) {\n    // Left side (x is minX)\n    // Ensure y is clamped within bounds\n    distance =\n      width +\n      height +\n      width +\n      Math.max(0, Math.min(height, point.y - bounds.minY))\n  } else {\n    // Point might be slightly off boundary due to precision, try snapping it?\n    // Or throw error as before. For now, let's log a warning and try snapping.\n    // console.warn(\n    //   \"Point does not lie exactly on the boundary, attempting to snap.\",\n    //   { point, bounds },\n    // )\n    // Simple snap: Find closest side point (more complex logic could be added here)\n    // For simplicity, we'll re-call with snapped points if needed, or just throw.\n    // Let's stick to the original error for now if it's significantly off.\n    throw new Error(\n      `Point (${point.x}, ${point.y}) does not lie on the boundary defined by ${JSON.stringify(bounds)}`,\n    )\n    // Alternative: Add logic here to find the closest point on the boundary and use that.\n  }\n\n  // Ensure distance doesn't exceed perimeter due to float issues\n  distance = Math.max(0, Math.min(perimeter, distance))\n\n  // Convert distance to angle (0 to 2)\n  // Handle perimeter being zero\n  return perimeter > EPSILON ? (distance / perimeter) * (2 * Math.PI) : 0\n}\n\n/**\n * Calculate percentages of each side traversed based on start and end angles,\n * respecting the specified turn direction.\n */\nfunction calculateSidePercentages(\n  startAngle: number, // Raw angle [0, 2)\n  endAngle: number, // Raw angle [0, 2)\n  bounds: Bounds,\n  turnDirection: \"cw\" | \"ccw\",\n): SidePercentages {\n  const width = bounds.maxX - bounds.minX\n  const height = bounds.maxY - bounds.minY\n  // Avoid division by zero if width or height is zero\n  if (width < EPSILON && height < EPSILON)\n    return { left: 0, top: 0, right: 0, bottom: 0 }\n  const perimeter = 2 * (width + height)\n  if (perimeter < EPSILON) return { left: 0, top: 0, right: 0, bottom: 0 }\n\n  // Define angle ranges for each side (clockwise from top-left = 0)\n  // Ensure denominator is non-zero\n  const angleTopEnd = (width / perimeter) * (2 * Math.PI)\n  const angleRightEnd = ((width + height) / perimeter) * (2 * Math.PI)\n  const angleBottomEnd = ((width + width + height) / perimeter) * (2 * Math.PI)\n  const angleLeftEnd = 2 * Math.PI // Full circle\n\n  const sides = [\n    { name: \"top\", start: 0, end: angleTopEnd, length: width },\n    { name: \"right\", start: angleTopEnd, end: angleRightEnd, length: height },\n    {\n      name: \"bottom\",\n      start: angleRightEnd,\n      end: angleBottomEnd,\n      length: width,\n    },\n    { name: \"left\", start: angleBottomEnd, end: angleLeftEnd, length: height }, // Ends at 2PI\n  ]\n\n  const result: SidePercentages = { left: 0, top: 0, right: 0, bottom: 0 }\n\n  // Helper to calculate the total angle length of the intersection between\n  // a side's angle range [sStart, sEnd) and a traversal range.\n  // The traversal range is defined from tStart to tEnd in clockwise direction,\n  // potentially wrapping around 2 if wrapsAround is true.\n  const calculateTraversalOverlap = (\n    sStart: number,\n    sEnd: number, // Side range [sStart, sEnd)\n    tStart: number,\n    tEnd: number, // Traversal range (clockwise)\n    wrapsAround: boolean, // Does the traversal range wrap around 2?\n  ): number => {\n    // Ensure side range is valid (adjust end slightly if it's 2PI to handle interval logic)\n    const effectiveSEnd = sEnd > 2 * Math.PI - EPSILON ? 2 * Math.PI : sEnd\n    if (effectiveSEnd <= sStart + EPSILON) return 0\n\n    if (!wrapsAround) {\n      // Simple case: traversal is [tStart, tEnd)\n      const overlapStart = Math.max(sStart, tStart)\n      const overlapEnd = Math.min(effectiveSEnd, tEnd)\n      return Math.max(0, overlapEnd - overlapStart)\n    } else {\n      // Wrap-around case: traversal is [tStart, 2) U [0, tEnd)\n      // Overlap with first part: [tStart, 2)\n      const overlap1Start = Math.max(sStart, tStart)\n      const overlap1End = Math.min(effectiveSEnd, 2 * Math.PI)\n      const overlap1 = Math.max(0, overlap1End - overlap1Start)\n\n      // Overlap with second part: [0, tEnd)\n      const overlap2Start = Math.max(sStart, 0)\n      const overlap2End = Math.min(effectiveSEnd, tEnd)\n      const overlap2 = Math.max(0, overlap2End - overlap2Start)\n\n      return overlap1 + overlap2\n    }\n  }\n\n  for (const side of sides) {\n    // Use side.end directly for range calculation, helper handles 2PI case\n    const sideAngleRange = side.end - side.start\n    if (sideAngleRange < EPSILON || side.length < EPSILON) continue\n\n    let traversedAngleOnSide = 0\n    if (turnDirection === \"cw\") {\n      // Clockwise: Traverse from startAngle to endAngle\n      const wraps = startAngle > endAngle + EPSILON // Check if CW traversal wraps past 2PI\n      traversedAngleOnSide = calculateTraversalOverlap(\n        side.start,\n        side.end,\n        startAngle,\n        endAngle,\n        wraps,\n      )\n    } else {\n      // turnDirection === \"ccw\"\n      // Counter-clockwise: Traverse from startAngle *backwards* to endAngle\n      // This is equivalent to traversing clockwise from endAngle to startAngle.\n      const wraps = endAngle > startAngle + EPSILON // Check if equivalent CW traversal wraps past 2PI\n      traversedAngleOnSide = calculateTraversalOverlap(\n        side.start,\n        side.end,\n        endAngle, // Start of equivalent CW traversal\n        startAngle, // End of equivalent CW traversal\n        wraps,\n      )\n    }\n\n    if (traversedAngleOnSide > EPSILON) {\n      // Percentage calculation: (traversed angle on side) / (total angle range of side)\n      const percentage = traversedAngleOnSide / sideAngleRange\n      // Add percentage, ensuring it's non-negative and handles potential division by zero if sideAngleRange is tiny\n      result[side.name as keyof SidePercentages] += Math.max(\n        0,\n        Number.isFinite(percentage) ? percentage : 0,\n      )\n    }\n  }\n\n  // Normalize results slightly in case of FP inaccuracies summing up\n  for (const key in result) {\n    result[key as keyof SidePercentages] = Math.max(\n      0,\n      Math.min(1.0, result[key as keyof SidePercentages]),\n    )\n  }\n\n  return result\n}\n","import { Point } from \"@tscircuit/math-utils\"\nimport { pointToAngle } from \"./calculateSideTraversal\"\n\ninterface Bounds {\n  minX: number\n  maxX: number\n  minY: number\n  maxY: number\n}\n\ntype AngleTriplet = {\n  angleA: number\n  angleB: number\n  angleC: number\n}\n\nexport function triangleDirection({\n  angleA,\n  angleB,\n  angleC,\n}: AngleTriplet): \"cw\" | \"ccw\" {\n  // Convert angles to Cartesian coordinates on unit circle\n  const Ax = Math.cos(angleA)\n  const Ay = Math.sin(angleA)\n  const Bx = Math.cos(angleB)\n  const By = Math.sin(angleB)\n  const Cx = Math.cos(angleC)\n  const Cy = Math.sin(angleC)\n\n  // Compute the signed area of the triangle (A  B  C)\n  const signedArea = (Bx - Ax) * (Cy - Ay) - (By - Ay) * (Cx - Ax)\n\n  return signedArea < 0 ? \"ccw\" : \"cw\"\n}\n\n/**\n * Determines the turn direction when moving from A to B to C along the boundary.\n */\nexport function computeTurnDirection(\n  A: Point,\n  B: Point,\n  C: Point,\n  bounds: Bounds,\n): \"cw\" | \"ccw\" {\n  const angleA = pointToAngle(A, bounds)\n  const angleB = pointToAngle(B, bounds)\n  const angleC = pointToAngle(C, bounds)\n\n  return triangleDirection({ angleA, angleB, angleC })\n}\n","import { BaseSolver } from \"lib/solvers/BaseSolver\"\nimport {\n  NodeWithPortPoints,\n  HighDensityIntraNodeRoute,\n} from \"lib/types/high-density-types\"\nimport {\n  distance,\n  pointToSegmentDistance,\n  doSegmentsIntersect,\n  clamp,\n} from \"@tscircuit/math-utils\"\nimport type { GraphicsObject } from \"graphics-debug\"\nimport { getIntraNodeCrossings } from \"lib/utils/getIntraNodeCrossings\"\nimport { findCircleLineIntersections } from \"./findCircleLineIntersections\"\nimport { findClosestPointToABCWithinBounds } from \"lib/utils/findClosestPointToABCWithinBounds\"\nimport { calculatePerpendicularPointsAtDistance } from \"lib/utils/calculatePointsAtDistance\"\nimport { snapToNearestBound } from \"lib/utils/snapToNearestBound\"\nimport { findPointToGetAroundCircle } from \"lib/utils/findPointToGetAroundCircle\"\nimport {\n  calculateTraversalPercentages,\n  pointToAngle,\n} from \"./calculateSideTraversal\"\nimport { computeTurnDirection } from \"./computeTurnDirection\"\n\ntype Point = { x: number; y: number; z?: number }\ntype Route = {\n  A: Point\n  B: Point\n  connectionName: string\n}\n\nexport class SingleTransitionCrossingRouteSolver extends BaseSolver {\n  // Input parameters\n  nodeWithPortPoints: NodeWithPortPoints\n  routes: Route[]\n\n  // Configuration parameters\n  viaDiameter: number\n  traceThickness: number\n  obstacleMargin: number\n  layerCount: number = 2\n\n  debugViaPositions: {\n    via: Point\n  }[]\n\n  // Solution state\n  solvedRoutes: HighDensityIntraNodeRoute[] = []\n\n  // Bounds\n  bounds: { minX: number; maxX: number; minY: number; maxY: number }\n\n  constructor(params: {\n    nodeWithPortPoints: NodeWithPortPoints\n    viaDiameter?: number\n    traceThickness?: number\n    obstacleMargin?: number\n    layerCount?: number\n  }) {\n    super()\n\n    this.nodeWithPortPoints = params.nodeWithPortPoints\n    this.viaDiameter = params?.viaDiameter ?? 0.6\n    this.traceThickness = params?.traceThickness ?? 0.15\n    this.obstacleMargin = params?.obstacleMargin ?? 0.1\n    this.layerCount = params?.layerCount ?? 2\n    this.debugViaPositions = []\n\n    // Extract routes from the node data\n    this.routes = this.extractRoutesFromNode()\n\n    // Calculate bounds\n    this.bounds = this.calculateBounds()\n\n    if (this.routes.length !== 2) {\n      this.failed = true\n      return\n    }\n\n    const [routeA, routeB] = this.routes\n\n    // Check if one route has a layer transition and the other doesn't\n    const routeAHasTransition = routeA.A.z !== routeA.B.z\n    const routeBHasTransition = routeB.A.z !== routeB.B.z\n\n    // We need exactly one route with a transition\n    if (\n      (routeAHasTransition && routeBHasTransition) ||\n      (!routeAHasTransition && !routeBHasTransition)\n    ) {\n      this.failed = true\n      return\n    }\n  }\n\n  /**\n   * Extract routes that need to be connected from the node data\n   */\n  private extractRoutesFromNode(): Route[] {\n    const routes: Route[] = []\n    const connectedPorts = this.nodeWithPortPoints.portPoints!\n\n    // Group ports by connection name\n    const connectionGroups = new Map<string, Point[]>()\n\n    for (const connectedPort of connectedPorts) {\n      const { connectionName } = connectedPort\n      if (!connectionGroups.has(connectionName)) {\n        connectionGroups.set(connectionName, [])\n      }\n      connectionGroups.get(connectionName)?.push(connectedPort)\n    }\n\n    // Create routes for each connection (assuming each connection has exactly 2 points)\n    for (const [connectionName, points] of connectionGroups.entries()) {\n      if (points.length === 2) {\n        routes.push({\n          A: { ...points[0], z: points[0].z ?? 0 },\n          B: { ...points[1], z: points[1].z ?? 0 },\n          connectionName,\n        })\n      }\n    }\n\n    return routes\n  }\n\n  /**\n   * Calculate the bounding box of the node\n   */\n  private calculateBounds() {\n    return {\n      minX:\n        this.nodeWithPortPoints.center.x - this.nodeWithPortPoints.width / 2,\n      maxX:\n        this.nodeWithPortPoints.center.x + this.nodeWithPortPoints.width / 2,\n      minY:\n        this.nodeWithPortPoints.center.y - this.nodeWithPortPoints.height / 2,\n      maxY:\n        this.nodeWithPortPoints.center.y + this.nodeWithPortPoints.height / 2,\n    }\n  }\n\n  /**\n   * Check if two routes are crossing\n   */\n  private doRoutesCross(routeA: Route, routeB: Route): boolean {\n    // For this specific solver, we want to check if the 2D projections intersect\n    // (ignoring z values)\n    return doSegmentsIntersect(routeA.A, routeA.B, routeB.A, routeB.B)\n  }\n\n  private calculateViaPosition(\n    transitionRoute: Route,\n    flatRoute: Route,\n  ): Point | null {\n    const flatRouteZ = flatRoute.A.z\n    const ntrP1 =\n      transitionRoute.A.z !== flatRouteZ ? transitionRoute.A : transitionRoute.B\n\n    // ntrP1 is always on the opposite layer as the flat route, the trace must always\n    // weave between ntrP1 and the via\n    // The via must also be far enough from the flat route\n    const marginFromBorderWithTrace =\n      this.obstacleMargin * 2 + this.viaDiameter / 2 + this.traceThickness\n    const marginFromBorderWithoutTrace =\n      this.obstacleMargin + this.viaDiameter / 2\n\n    const A = flatRoute.A\n    const B = ntrP1\n    const C = flatRoute.B\n\n    const turnDirection = computeTurnDirection(A, B, C, this.bounds)\n    const sideTraversal = calculateTraversalPercentages(\n      A,\n      B,\n      C,\n      this.bounds,\n      turnDirection,\n    )\n\n    const viaBounds = {\n      minX:\n        this.bounds.minX +\n        (sideTraversal.left > 0.5\n          ? marginFromBorderWithTrace\n          : marginFromBorderWithoutTrace),\n      minY:\n        this.bounds.minY +\n        (sideTraversal.bottom > 0.5\n          ? marginFromBorderWithTrace\n          : marginFromBorderWithoutTrace),\n      maxX:\n        this.bounds.maxX -\n        (sideTraversal.right > 0.5\n          ? marginFromBorderWithTrace\n          : marginFromBorderWithoutTrace),\n      maxY:\n        this.bounds.maxY -\n        (sideTraversal.top > 0.5\n          ? marginFromBorderWithTrace\n          : marginFromBorderWithoutTrace),\n    }\n\n    if (viaBounds.maxY < viaBounds.minY) {\n      viaBounds.minY = (viaBounds.minY + viaBounds.maxY) / 2\n      viaBounds.maxY = viaBounds.minY\n    }\n\n    if (viaBounds.maxX < viaBounds.minX) {\n      viaBounds.minX = (viaBounds.minX + viaBounds.maxX) / 2\n      viaBounds.maxX = viaBounds.minX\n    }\n\n    return findClosestPointToABCWithinBounds(\n      A,\n      B,\n      C,\n      marginFromBorderWithTrace,\n      viaBounds,\n    )\n  }\n  /**\n   * Create a single transition route with properly placed via\n   */\n  private createTransitionRoute(\n    start: Point,\n    end: Point,\n    via: Point,\n    connectionName: string,\n  ): HighDensityIntraNodeRoute {\n    // Create the route path with layer transition at the via\n    const route = [\n      { x: start.x, y: start.y, z: start.z ?? 0 },\n      { x: via.x, y: via.y, z: start.z ?? 0 },\n      { x: via.x, y: via.y, z: end.z ?? 0 },\n      { x: end.x, y: end.y, z: end.z ?? 0 },\n    ]\n\n    return {\n      connectionName,\n      route,\n      traceThickness: this.traceThickness,\n      viaDiameter: this.viaDiameter,\n      vias: [via],\n    }\n  }\n\n  /**\n   * Create the non-transition route\n   */\n  private createFlatRoute(\n    flatStart: Point,\n    flatEnd: Point,\n    via: Point,\n    otherRouteStart: Point,\n    otherRouteEnd: Point,\n    flatRouteConnectionName: string,\n  ): HighDensityIntraNodeRoute {\n    const ntrP1 =\n      otherRouteStart.z !== flatStart.z ? otherRouteStart : otherRouteEnd\n    // We need to navigate around the via\n\n    const middle = (a: Point, b: Point) => {\n      return {\n        x: (a.x + b.x) / 2,\n        y: (a.y + b.y) / 2,\n      }\n    }\n\n    const middleWithMargin = (\n      a: Point,\n      aMargin: number,\n      b: Point,\n      bMargin: number,\n    ) => {\n      const dx = b.x - a.x\n      const dy = b.y - a.y\n\n      const effectiveA = {\n        x: a.x + dx * aMargin,\n        y: a.y + dy * aMargin,\n      }\n\n      const effectiveB = {\n        x: b.x - dx * bMargin,\n        y: b.y - dy * bMargin,\n      }\n\n      return middle(effectiveA, effectiveB)\n    }\n\n    const minDistFromViaToTrace =\n      this.viaDiameter / 2 + this.traceThickness / 2 + this.obstacleMargin\n    const p2 = middleWithMargin(\n      via,\n      this.viaDiameter,\n      otherRouteStart.z !== flatStart.z ? otherRouteStart : otherRouteEnd,\n      this.traceThickness,\n    )\n    const viaCircle = {\n      center: { x: via.x, y: via.y },\n      radius: minDistFromViaToTrace,\n    }\n    const p1 = findPointToGetAroundCircle(flatStart, p2, viaCircle).E\n    const p3 = findPointToGetAroundCircle(p2, flatEnd, viaCircle).E\n\n    // Determine if we need p1 or if we can just go from flatStart to p2 without\n    // intersecting the via\n    // const p1IsNeeded =\n    //   pointToSegmentDistance(via, flatStart, p2) < minDistFromViaToTrace\n    // const p3IsNeeded = pointToSegmentDistance(via, p2, flatEnd) < minDistFromViaToTrace\n\n    // flatStart -> p0_5 -> p1 -> p1_5 -> p2 -> p2_5 -> p3 -> p3_5 -> flatEnd\n    const p0_5 = findPointToGetAroundCircle(flatStart, p1, viaCircle).E\n    const p1_5 = findPointToGetAroundCircle(p1, p2, viaCircle).E\n    const p2_5 = findPointToGetAroundCircle(p2, p3, viaCircle).E\n    const p3_5 = findPointToGetAroundCircle(p3, flatEnd, viaCircle).E\n\n    const p2_better = findPointToGetAroundCircle(p1_5, p2_5, viaCircle).E\n\n    // We need to navigate around the via\n    return {\n      connectionName: flatRouteConnectionName,\n      route: [\n        { x: flatStart.x, y: flatStart.y, z: flatStart.z ?? 0 },\n        { x: p0_5.x, y: p0_5.y, z: flatStart.z ?? 0 },\n        { x: p1.x, y: p1.y, z: flatStart.z ?? 0 },\n        { x: p1_5.x, y: p1_5.y, z: flatStart.z ?? 0 },\n        // { x: p2.x, y: p2.y, z: flatStart.z ?? 0 },\n        { x: p2_better.x, y: p2_better.y, z: flatStart.z ?? 0 },\n        { x: p2_5.x, y: p2_5.y, z: flatStart.z ?? 0 },\n        { x: p3.x, y: p3.y, z: flatStart.z ?? 0 },\n        { x: p3_5.x, y: p3_5.y, z: flatStart.z ?? 0 },\n        { x: flatEnd.x, y: flatEnd.y, z: flatEnd.z ?? 0 },\n      ],\n      traceThickness: this.traceThickness,\n      viaDiameter: this.viaDiameter,\n      vias: [],\n    }\n  }\n\n  /**\n   * Try to solve with one route having a transition and the other staying flat\n   */\n  private trySolve(): boolean {\n    const [routeA, routeB] = this.routes\n\n    // Determine which route has the transition\n    const routeAHasTransition = routeA.A.z !== routeA.B.z\n\n    const transitionRoute = routeAHasTransition ? routeA : routeB\n    const flatRoute = routeAHasTransition ? routeB : routeA\n\n    const viaPosition = this.calculateViaPosition(transitionRoute, flatRoute)\n    if (viaPosition) {\n      this.debugViaPositions.push({ via: viaPosition })\n    } else {\n      return false\n    }\n\n    // Create transition route with via\n    const transitionRouteSolution = this.createTransitionRoute(\n      transitionRoute.A,\n      transitionRoute.B,\n      viaPosition,\n      transitionRoute.connectionName,\n    )\n\n    // Create flat route\n    const flatRouteSolution = this.createFlatRoute(\n      flatRoute.A,\n      flatRoute.B,\n      viaPosition,\n      transitionRoute.A,\n      transitionRoute.B,\n      flatRoute.connectionName,\n    )\n\n    this.solvedRoutes.push(transitionRouteSolution, flatRouteSolution)\n    return true\n  }\n\n  /**\n   * Main step method that attempts to solve the routes\n   */\n  _step() {\n    // Check if routes are actually crossing\n    if (!this.doRoutesCross(this.routes[0], this.routes[1])) {\n      this.failed = true\n      this.error =\n        \"Can only solve routes that have a single transition crossing\"\n      return\n    }\n\n    // Try to solve\n    if (this.trySolve()) {\n      this.solved = true\n      return\n    }\n\n    // If approach fails, mark as failed\n    this.failed = true\n  }\n\n  /**\n   * Visualization for debugging\n   */\n  visualize(): GraphicsObject {\n    const graphics: GraphicsObject = {\n      lines: [],\n      points: [],\n      rects: [],\n      circles: [],\n    }\n\n    // Draw PCB bounds\n    graphics.rects!.push({\n      center: {\n        x: (this.bounds.minX + this.bounds.maxX) / 2,\n        y: (this.bounds.minY + this.bounds.maxY) / 2,\n      },\n      width: this.bounds.maxX - this.bounds.minX,\n      height: this.bounds.maxY - this.bounds.minY,\n      stroke: \"rgba(0, 0, 0, 0.5)\",\n      fill: \"rgba(240, 240, 240, 0.1)\",\n      label: \"PCB Bounds\",\n    })\n\n    // Draw original routes\n    for (const route of this.routes) {\n      // Draw endpoints\n      graphics.points!.push({\n        x: route.A.x,\n        y: route.A.y,\n        label: `${route.connectionName} start (z=${route.A.z})`,\n        color: \"orange\",\n      })\n\n      graphics.points!.push({\n        x: route.B.x,\n        y: route.B.y,\n        label: `${route.connectionName} end (z=${route.B.z})`,\n        color: \"orange\",\n      })\n\n      // Draw direct connection line\n      graphics.lines!.push({\n        points: [route.A, route.B],\n        strokeColor: \"rgba(255, 0, 0, 0.5)\",\n        label: `${route.connectionName} direct`,\n      })\n    }\n\n    // Draw debug via positions (even if solution failed)\n    for (let i = 0; i < this.debugViaPositions.length; i++) {\n      const { via } = this.debugViaPositions[i]\n\n      // Draw computed via\n      graphics.circles!.push({\n        center: via,\n        radius: this.viaDiameter / 2,\n        fill: \"rgba(255, 165, 0, 0.7)\",\n        stroke: \"rgba(0, 0, 0, 0.5)\",\n        label: `Computed Via (attempt ${i + 1})`,\n      })\n\n      // Draw safety margin around via\n      const safetyMargin = this.viaDiameter / 2 + this.obstacleMargin\n      graphics.circles!.push({\n        center: via,\n        radius: safetyMargin,\n        stroke: \"rgba(255, 165, 0, 0.7)\",\n        fill: \"rgba(0, 0, 0, 0)\",\n        label: \"Safety Margin\",\n      })\n    }\n\n    // Draw solved routes if available\n    for (let si = 0; si < this.solvedRoutes.length; si++) {\n      const route = this.solvedRoutes[si]\n      const routeColor =\n        si % 2 === 0 ? \"rgba(0, 255, 0, 0.75)\" : \"rgba(255, 0, 255, 0.75)\"\n      for (let i = 0; i < route.route.length - 1; i++) {\n        const pointA = route.route[i]\n        const pointB = route.route[i + 1]\n\n        graphics.lines!.push({\n          points: [pointA, pointB],\n          strokeColor: routeColor,\n          strokeDash: pointA.z !== route.route[0].z ? [0.2, 0.2] : undefined,\n          strokeWidth: route.traceThickness,\n          label: `${route.connectionName} z=${pointA.z}`,\n        })\n      }\n\n      // Draw vias in solved routes\n      for (const via of route.vias) {\n        graphics.circles!.push({\n          center: via,\n          radius: this.viaDiameter / 2,\n          fill: \"rgba(0, 0, 255, 0.8)\",\n          stroke: \"black\",\n          label: \"Solved Via\",\n        })\n        graphics.circles!.push({\n          center: via,\n          radius: this.viaDiameter / 2 + this.obstacleMargin,\n          fill: \"rgba(0, 0, 255, 0.3)\",\n          stroke: \"black\",\n          label: \"Via Margin\",\n        })\n      }\n    }\n\n    return graphics\n  }\n\n  /**\n   * Get the solved routes\n   */\n  getSolvedRoutes(): HighDensityIntraNodeRoute[] {\n    return this.solvedRoutes\n  }\n}\n","import { NodeWithPortPoints } from \"lib/types/high-density-types\"\nimport type { Point3 } from \"@tscircuit/math-utils\"\n\nexport type PortPairMap = Map<\n  string,\n  { start: Point3; end: Point3; connectionName: string }\n>\n\nexport const getPortPairMap = (\n  nodeWithPortPoints: NodeWithPortPoints,\n): PortPairMap => {\n  const portPairMap: PortPairMap = new Map()\n  nodeWithPortPoints.portPoints.forEach((portPoint) => {\n    if (!portPairMap.has(portPoint.connectionName)) {\n      portPairMap.set(portPoint.connectionName, {\n        start: portPoint,\n        end: null as any,\n        connectionName: portPoint.connectionName,\n      })\n    } else {\n      portPairMap.get(portPoint.connectionName)!.end = portPoint\n    }\n  })\n  return portPairMap\n}\n","import { NodeWithPortPoints } from \"lib/types/high-density-types\"\nimport { ConnectivityMap } from \"circuit-json-to-connectivity-map\"\nexport const generateColorMapFromNodeWithPortPoints = (\n  nodeWithPortPoints: NodeWithPortPoints,\n  connMap?: ConnectivityMap,\n) => {\n  const colorMap: Record<string, string> = {}\n  nodeWithPortPoints.portPoints.forEach((portPoint, i) => {\n    colorMap[portPoint.connectionName] =\n      `hsl(${(i * 360) / nodeWithPortPoints.portPoints.length}, 100%, 50%)`\n  })\n  return colorMap\n}\n","import { NodeWithPortPoints } from \"lib/types/high-density-types\"\nimport { BaseSolver } from \"../BaseSolver\"\nimport { GraphicsObject } from \"graphics-debug\"\nimport { getBoundsFromNodeWithPortPoints } from \"lib/utils/getBoundsFromNodeWithPortPoints\"\nimport {\n  Bounds,\n  distance,\n  midpoint,\n  Point,\n  Point3,\n  pointToSegmentDistance,\n  getSegmentIntersection,\n  segmentToSegmentMinDistance,\n  clamp,\n} from \"@tscircuit/math-utils\"\nimport { getPortPairMap, PortPairMap } from \"lib/utils/getPortPairs\"\nimport { generateColorMapFromNodeWithPortPoints } from \"lib/utils/generateColorMapFromNodeWithPortPoints\"\nimport { cloneAndShuffleArray } from \"lib/utils/cloneAndShuffleArray\"\nimport { safeTransparentize } from \"../colors\"\n\nexport type ConnectionName = string\n\nexport interface Segment {\n  start: Point3\n  end: Point3\n  connectionName: string\n}\n\nexport interface ViaPossibilities2HyperParameters {\n  SHUFFLE_SEED?: number\n} /**\nThis solver uses an intersection-based approach. Here's how it works:\n0. Prepare placeholderPaths\n- Placeholder paths go from (start, end) if the z is the same\n- For placeholder paths, if the Z is different between the start and the end, then we create two segments, (start, mid) with start.z and (mid,end) with end.z. This means the placeholder path has four points, the second and third point are both a the mid XY but have a different z\n1. We cycle through each port pair, we start by setting currentHead = start for the first pair\n2. We have a currentHead, currentPath and currentConnectionName\nSTEP LOOP:\n3. We always try to move the currentHead to the end. We try to create a line from currentHead to the end\n4. If the currentHead does any of the following:\n   - Intersects a previously created path\n   - Intersects a placeholder path\n   - (check last) is not on the same z as the end\n   Then we must insert a via (2 points with a z change). Insert this via at the midpoint of currentHead and the intersection point (or the end if the \"is not same z as end\" condition applies)\n   In the next iteration of the step function we'll go back to step 3\n5. After the currentPath reaches the end for the connection, we delete the placeholder path and select the next currentHead by popping the unprocessedConnections, reset currentPath and set currentConnectionName\n6. When there are no more unprocessed connections, we set this.solved = true\n*/\nexport class ViaPossibilitiesSolver2 extends BaseSolver {\n  bounds: Bounds\n  maxViaCount: number\n  portPairMap: PortPairMap\n  colorMap: Record<string, string>\n  nodeWidth: number\n  availableZ: number[]\n  hyperParameters: ViaPossibilities2HyperParameters\n  VIA_INTERSECTION_BUFFER_DISTANCE = 0.05\n  PLACEHOLDER_WALL_BUFFER_DISTANCE = 0.1\n  NEW_HEAD_WALL_BUFFER_DISTANCE = 0.05\n\n  unprocessedConnections: ConnectionName[]\n\n  completedPaths: Map<ConnectionName, Point3[]> = new Map()\n  placeholderPaths: Map<ConnectionName, Point3[]> = new Map()\n\n  currentHead: Point3\n  currentConnectionName: ConnectionName\n  currentPath: Point3[]\n  currentViaCount: number\n\n  constructor({\n    nodeWithPortPoints,\n    colorMap,\n    hyperParameters,\n  }: {\n    nodeWithPortPoints: NodeWithPortPoints\n    colorMap?: Record<string, string>\n    hyperParameters?: ViaPossibilities2HyperParameters\n  }) {\n    super()\n    this.MAX_ITERATIONS = 100e3\n    this.colorMap =\n      colorMap ?? generateColorMapFromNodeWithPortPoints(nodeWithPortPoints)\n    this.maxViaCount = 5\n    this.bounds = getBoundsFromNodeWithPortPoints(nodeWithPortPoints)\n    this.nodeWidth = this.bounds.maxX - this.bounds.minX\n    this.portPairMap = getPortPairMap(nodeWithPortPoints)\n    this.stats.solutionsFound = 0\n    this.availableZ = nodeWithPortPoints.availableZ ?? [0, 1]\n    this.hyperParameters = hyperParameters ?? {\n      SHUFFLE_SEED: 0,\n    }\n\n    this.unprocessedConnections = Array.from(this.portPairMap.keys()).sort()\n    if (hyperParameters?.SHUFFLE_SEED) {\n      this.unprocessedConnections = cloneAndShuffleArray(\n        this.unprocessedConnections,\n        hyperParameters.SHUFFLE_SEED,\n      )\n    }\n\n    // Generate placeholder paths\n    for (const [connectionName, { start, end }] of this.portPairMap.entries()) {\n      if (start.z === end.z) {\n        const isVertical = Math.abs(start.x - end.x) < 1e-9 // Use tolerance for float comparison\n        const isHorizontal = Math.abs(start.y - end.y) < 1e-9\n\n        if (isVertical || isHorizontal) {\n          this.placeholderPaths.set(connectionName, [\n            start,\n            this._padByPlaceholderWallBuffer(start),\n            this._padByPlaceholderWallBuffer(end),\n            end,\n          ])\n        } else {\n          // Diagonal line on the same Z plane\n          this.placeholderPaths.set(connectionName, [start, end])\n        }\n      } else {\n        // Create a path with a Z change at the midpoint for different Z levels\n        const midX = (start.x + end.x) / 2\n        const midY = (start.y + end.y) / 2\n\n        // Use the (potentially offset) midpoint XY for the Z change points\n        const midStart: Point3 = this._padByPlaceholderWallBuffer({\n          x: midX,\n          y: midY,\n          z: start.z,\n        })\n        const midEnd: Point3 = this._padByPlaceholderWallBuffer({\n          x: midX,\n          y: midY,\n          z: end.z,\n        })\n        this.placeholderPaths.set(connectionName, [\n          start,\n          this._padByPlaceholderWallBuffer(start),\n          midStart,\n          midEnd,\n          this._padByPlaceholderWallBuffer(end),\n          end,\n        ])\n      }\n    }\n\n    this.currentConnectionName = this.unprocessedConnections.pop()!\n    const start = this.portPairMap.get(this.currentConnectionName)!.start\n    this.currentHead = this._padByNewHeadWallBuffer(start)\n    this.currentPath = [start, this.currentHead]\n    this.currentViaCount = 0\n    this.placeholderPaths.delete(this.currentConnectionName) // Delete placeholder when we start processing\n  }\n\n  _padByNewHeadWallBuffer(point: Point3) {\n    return {\n      x: clamp(\n        point.x,\n        this.bounds.minX + this.NEW_HEAD_WALL_BUFFER_DISTANCE,\n        this.bounds.maxX - this.NEW_HEAD_WALL_BUFFER_DISTANCE,\n      ),\n      y: clamp(\n        point.y,\n        this.bounds.minY + this.NEW_HEAD_WALL_BUFFER_DISTANCE,\n        this.bounds.maxY - this.NEW_HEAD_WALL_BUFFER_DISTANCE,\n      ),\n      z: point.z,\n    }\n  }\n\n  _padByPlaceholderWallBuffer(point: Point3) {\n    return {\n      x: clamp(\n        point.x,\n        this.bounds.minX + this.PLACEHOLDER_WALL_BUFFER_DISTANCE,\n        this.bounds.maxX - this.PLACEHOLDER_WALL_BUFFER_DISTANCE,\n      ),\n      y: clamp(\n        point.y,\n        this.bounds.minY + this.PLACEHOLDER_WALL_BUFFER_DISTANCE,\n        this.bounds.maxY - this.PLACEHOLDER_WALL_BUFFER_DISTANCE,\n      ),\n      z: point.z,\n    }\n  }\n\n  _step() {\n    if (this.solved) return\n\n    const targetEnd = this.portPairMap.get(this.currentConnectionName)!.end\n    const proposedSegment: [Point3, Point3] = [this.currentHead, targetEnd]\n\n    let closestIntersection: any = null\n    let intersectedSegmentZ: number | null = null\n\n    const checkIntersectionsWithPathMap = (\n      pathMap: Map<ConnectionName, Point3[]>,\n    ) => {\n      for (const path of pathMap.values()) {\n        for (let i = 0; i < path.length - 1; i++) {\n          const segment: [Point3, Point3] = [path[i], path[i + 1]]\n          // Skip checking intersection if segment is just a via (z change)\n          if (segment[0].x === segment[1].x && segment[0].y === segment[1].y) {\n            continue\n          }\n          // Only check intersections on the same Z plane as the proposed move start\n          // Or if the proposed move itself involves a Z change (handled later)\n          if (segment[0].z !== this.currentHead.z) {\n            continue\n          }\n\n          const intersection = getSegmentIntersection(\n            proposedSegment[0],\n            proposedSegment[1],\n            segment[0],\n            segment[1],\n          )\n          if (intersection) {\n            // Ignore intersection if it's exactly at the start point (currentHead)\n            const distToIntersection = distance(this.currentHead, intersection)\n            if (distToIntersection < 1e-6) continue // Tolerance for floating point\n\n            if (\n              !closestIntersection ||\n              distToIntersection < closestIntersection.dist\n            ) {\n              closestIntersection = {\n                point: intersection,\n                dist: distToIntersection,\n              }\n              intersectedSegmentZ = segment[0].z // Z level of the segment we hit\n            }\n          }\n        }\n      }\n    }\n\n    // Check intersections against completed and placeholder paths\n    checkIntersectionsWithPathMap(this.completedPaths)\n    checkIntersectionsWithPathMap(this.placeholderPaths)\n\n    const needsZChange = this.currentHead.z !== targetEnd.z\n\n    if (closestIntersection || needsZChange) {\n      this.currentViaCount++\n\n      // Check if adding this via would exceed the limit\n      if (this.currentViaCount >= this.maxViaCount) {\n        this.failed = true\n        return\n      }\n    }\n\n    if (closestIntersection) {\n      // --- Intersection Found ---\n      let viaXY: Point\n      const distToIntersection = closestIntersection.dist\n\n      if (distToIntersection <= this.VIA_INTERSECTION_BUFFER_DISTANCE + 1e-6) {\n        // If intersection is too close, place via at midpoint\n        viaXY = midpoint(this.currentHead, closestIntersection.point)\n      } else {\n        // Otherwise, place via VIA_INTERSECTION_BUFFER_DISTANCE before the intersection point\n        const intersectionPoint = closestIntersection.point\n        const vectorX = intersectionPoint.x - this.currentHead.x\n        const vectorY = intersectionPoint.y - this.currentHead.y\n        // Calculate the point VIA_INTERSECTION_BUFFER_DISTANCE away from the intersection towards the current head\n        const ratio =\n          (distToIntersection - this.VIA_INTERSECTION_BUFFER_DISTANCE) /\n          distToIntersection\n        viaXY = {\n          x: this.currentHead.x + vectorX * ratio,\n          y: this.currentHead.y + vectorY * ratio,\n        }\n      }\n\n      // Determine the Z level to switch to (the one NOT occupied by the intersected segment)\n      const nextZ = this.availableZ.find((z) => z !== intersectedSegmentZ)!\n      if (nextZ === undefined) {\n        console.error(\"Could not determine next Z level for via placement!\")\n        this.failed = true // Mark as failed if Z logic breaks\n        return\n      }\n\n      const viaPoint1: Point3 = { ...viaXY, z: this.currentHead.z }\n      const viaPoint2: Point3 = { ...viaXY, z: nextZ }\n\n      this.currentPath.push(viaPoint1, viaPoint2)\n      this.currentHead = viaPoint2\n    } else if (needsZChange) {\n      // --- No Intersection, but Z Mismatch ---\n      let viaXY: Point\n      const distToTarget = distance(this.currentHead, targetEnd)\n\n      if (distToTarget < this.VIA_INTERSECTION_BUFFER_DISTANCE) {\n        // If target is too close, place via at midpoint\n        viaXY = midpoint(this.currentHead, targetEnd)\n      } else {\n        // Otherwise, place via VIA_INTERSECTION_BUFFER_DISTANCE before the target end point\n        const vectorX = targetEnd.x - this.currentHead.x\n        const vectorY = targetEnd.y - this.currentHead.y\n        // Calculate the point VIA_INTERSECTION_BUFFER_DISTANCE away from the target towards the current head\n        const ratio =\n          (distToTarget - this.VIA_INTERSECTION_BUFFER_DISTANCE) / distToTarget\n        viaXY = {\n          x: this.currentHead.x + vectorX * ratio,\n          y: this.currentHead.y + vectorY * ratio,\n        }\n      }\n\n      const nextZ = targetEnd.z // Target the destination Z\n\n      const viaPoint1: Point3 = { ...viaXY, z: this.currentHead.z }\n      const viaPoint2: Point3 = { ...viaXY, z: nextZ }\n\n      this.currentPath.push(viaPoint1, viaPoint2)\n      this.currentHead = viaPoint2\n    } else {\n      // --- No Intersection, Z Matches: Path Clear ---\n      this.currentPath.push(targetEnd)\n      this.completedPaths.set(this.currentConnectionName, this.currentPath)\n\n      if (this.unprocessedConnections.length === 0) {\n        // All connections processed\n        this.solved = true\n        this.stats.solutionsFound = 1 // Mark as solved\n      } else {\n        // Start next connection\n        this.currentConnectionName = this.unprocessedConnections.pop()!\n        const { start } = this.portPairMap.get(this.currentConnectionName)!\n        this.currentHead = this._padByNewHeadWallBuffer(start)\n        this.currentPath = [start, this.currentHead]\n        this.currentViaCount = 0\n        this.placeholderPaths.delete(this.currentConnectionName) // Remove placeholder\n      }\n    }\n  }\n\n  visualize(): GraphicsObject {\n    const graphics: Required<GraphicsObject> = {\n      points: [],\n      lines: [],\n      circles: [],\n      rects: [],\n      title: \"Via Possibilities Solver State\",\n      coordinateSystem: \"cartesian\",\n    }\n\n    // Generate a simple color map\n    const colorMap = this.colorMap\n\n    // 1. Draw Node Bounds\n    graphics.lines!.push({\n      points: [\n        { x: this.bounds.minX, y: this.bounds.minY },\n        { x: this.bounds.maxX, y: this.bounds.minY },\n        { x: this.bounds.maxX, y: this.bounds.maxY },\n        { x: this.bounds.minX, y: this.bounds.maxY },\n        { x: this.bounds.minX, y: this.bounds.minY },\n      ],\n      strokeColor: \"gray\",\n      strokeWidth: 0.01,\n    })\n\n    // Draw Start/End points from portPairMap\n    for (const [connectionName, { start, end }] of this.portPairMap.entries()) {\n      const color = this.colorMap[connectionName] ?? \"black\"\n      graphics.points!.push({\n        x: start.x,\n        y: start.y,\n        color: color,\n        label: `Port: ${connectionName} Start (z${start.z})`,\n      })\n      graphics.points!.push({\n        x: end.x,\n        y: end.y,\n        color: color,\n        label: `Port: ${connectionName} End (z${end.z})`,\n      })\n    }\n\n    const drawPath = (\n      pathMap: Map<ConnectionName, Point3[]>,\n      labelPrefix: string,\n    ) => {\n      for (const [connectionName, path] of pathMap.entries()) {\n        const color = colorMap[connectionName] ?? \"black\"\n        for (let i = 0; i < path.length - 1; i++) {\n          const p1 = path[i]\n          const p2 = path[i + 1]\n\n          if (p1.x === p2.x && p1.y === p2.y && p1.z !== p2.z) {\n            // Draw Via for Z change\n            graphics.circles!.push({\n              center: { x: p1.x, y: p1.y },\n              radius: 0.3, // Diameter 0.6\n              fill: safeTransparentize(color, 0.5),\n              label: `${labelPrefix}: ${connectionName} Via (z${p1.z}->z${p2.z})`,\n            })\n          } else {\n            // Draw Line Segment\n            graphics.lines!.push({\n              points: [p1, p2],\n              strokeColor: safeTransparentize(color, 0.5),\n              strokeDash: p1.z === 0 ? undefined : [0.1, 0.1],\n              strokeWidth: 0.1,\n              label: `${labelPrefix}: ${connectionName} (z${p1.z})`,\n            })\n          }\n        }\n      }\n    }\n\n    // 2. Draw Placeholder Paths\n    drawPath(this.placeholderPaths, \"Placeholder\")\n\n    // 3. Draw Completed Paths\n    drawPath(this.completedPaths, \"Completed\")\n\n    // 4. Draw Current Path (if any)\n    if (this.currentPath && this.currentPath.length > 0) {\n      const color = colorMap[this.currentConnectionName] ?? \"orange\" // Use a distinct color\n      for (let i = 0; i < this.currentPath.length - 1; i++) {\n        const p1 = this.currentPath[i]\n        const p2 = this.currentPath[i + 1]\n        if (p1.x === p2.x && p1.y === p2.y && p1.z !== p2.z) {\n          graphics.circles!.push({\n            center: { x: p1.x, y: p1.y },\n            radius: 0.3,\n            fill: safeTransparentize(color, 0.5),\n            label: `Current: ${this.currentConnectionName} Via (z${p1.z}->z${p2.z})`,\n          })\n        } else {\n          graphics.lines!.push({\n            points: [p1, p2],\n            strokeColor: safeTransparentize(color, 0.5),\n            strokeWidth: 0.15, // Thicker\n            strokeDash: \"2,2\", // Dashed\n            label: `Current: ${this.currentConnectionName} (z${p1.z})`,\n          })\n        }\n      }\n      // Highlight current head\n      graphics.points!.push({\n        x: this.currentHead.x,\n        y: this.currentHead.y,\n        color: \"green\",\n        label: `Current Head: ${this.currentConnectionName} (z${this.currentHead.z})`,\n      })\n    }\n\n    return graphics\n  }\n}\n","import { doSegmentsIntersect } from \"@tscircuit/math-utils\"\nimport { NodeWithPortPoints } from \"lib/types/high-density-types\"\n\nexport const getIntraNodeCrossings = (node: NodeWithPortPoints) => {\n  // Count the number of crossings\n  let numSameLayerCrossings = 0\n  let pointPairs: {\n    points: { x: number; y: number; z: number }[]\n    z: number\n    connectionName: string\n  }[] = []\n\n  const transitionPairPoints: {\n    points: { x: number; y: number; z: number }[]\n    connectionName: string\n  }[] = []\n\n  let numEntryExitLayerChanges = 0\n\n  for (const A of node.portPoints) {\n    if (pointPairs.some((p) => p.connectionName === A.connectionName)) {\n      continue\n    }\n    if (\n      transitionPairPoints.some((p) => p.connectionName === A.connectionName)\n    ) {\n      continue\n    }\n    const pointPair = {\n      connectionName: A.connectionName,\n      z: A.z,\n      points: [{ x: A.x, y: A.y, z: A.z }],\n    }\n    for (const B of node.portPoints) {\n      if (A.connectionName !== B.connectionName) continue\n      if (A.x === B.x && A.y === B.y) continue\n      pointPair.points.push({ x: B.x, y: B.y, z: B.z })\n    }\n    if (pointPair.points.some((p) => p.z !== pointPair.z)) {\n      numEntryExitLayerChanges++\n      transitionPairPoints.push(pointPair)\n      continue\n    }\n    pointPairs.push(pointPair)\n  }\n\n  // TODO maybe these should be returned as \"number of non-crossing connections\"\n  pointPairs = pointPairs.filter((p) => p.points.length > 1)\n\n  for (let i = 0; i < pointPairs.length; i++) {\n    for (let j = i + 1; j < pointPairs.length; j++) {\n      const pair1 = pointPairs[i]\n      const pair2 = pointPairs[j]\n      if (\n        pair1.z === pair2.z &&\n        doSegmentsIntersect(\n          pair1.points[0],\n          pair1.points[1],\n          pair2.points[0],\n          pair2.points[1],\n        )\n      ) {\n        numSameLayerCrossings++\n      }\n    }\n  }\n\n  let numTransitionPairCrossings = 0\n  for (let i = 0; i < transitionPairPoints.length; i++) {\n    for (let j = i + 1; j < transitionPairPoints.length; j++) {\n      const pair1 = transitionPairPoints[i]\n      const pair2 = transitionPairPoints[j]\n\n      if (\n        doSegmentsIntersect(\n          pair1.points[0],\n          pair1.points[1],\n          pair2.points[0],\n          pair2.points[1],\n        )\n      ) {\n        numTransitionPairCrossings++\n      }\n    }\n  }\n\n  return {\n    numSameLayerCrossings,\n    numEntryExitLayerChanges,\n    numTransitionPairCrossings,\n    numTransitions: transitionPairPoints.length,\n  }\n}\n","import type { Bounds } from \"@tscircuit/math-utils\"\n\n// Define basic types\ninterface Point {\n  x: number\n  y: number\n}\n\nexport interface Segment {\n  start: Point\n  end: Point\n  connectionName?: string\n}\n\n// EPS is used for floating point comparisons\nconst EPS = 1e-9\n\nexport function almostEqual(a: number, b: number, eps: number = EPS): boolean {\n  return Math.abs(a - b) < eps\n}\n\nexport function pointKey(p: Point, eps: number = EPS): string {\n  // Hashable key for deduplication\n  return `${Math.round(p.x / eps)}:${Math.round(p.y / eps)}`\n}\n\nexport function cross(ax: number, ay: number, bx: number, by: number): number {\n  return ax * by - ay * bx\n}\n\nexport function segmentIntersection(\n  p: Point,\n  p2: Point,\n  q: Point,\n  q2: Point,\n): Point | null {\n  // Returns intersection point of segments pp2 and qq2 or null if none\n  const r = { x: p2.x - p.x, y: p2.y - p.y }\n  const s = { x: q2.x - q.x, y: q2.y - q.y }\n  const denom = cross(r.x, r.y, s.x, s.y)\n  if (almostEqual(denom, 0)) return null // Parallel or collinear\n  const qp = { x: q.x - p.x, y: q.y - p.y }\n  const t = cross(qp.x, qp.y, s.x, s.y) / denom\n  const u = cross(qp.x, qp.y, r.x, r.y) / denom\n  if (t < -EPS || t > 1 + EPS || u < -EPS || u > 1 + EPS) return null // Outside\n  return { x: p.x + t * r.x, y: p.y + t * r.y }\n}\n\nexport function polygonArea(points: Point[]): number {\n  let a = 0\n  for (let i = 0, n = points.length; i < n; ++i) {\n    const j = (i + 1) % n\n    a += points[i].x * points[j].y - points[j].x * points[i].y\n  }\n  return 0.5 * a\n}\n\nexport function polygonCentroid(points: Point[]): Point | null {\n  let a = 0\n  let cx = 0\n  let cy = 0\n  for (let i = 0, n = points.length; i < n; ++i) {\n    const j = (i + 1) % n\n    const crossVal = points[i].x * points[j].y - points[j].x * points[i].y\n    a += crossVal\n    cx += (points[i].x + points[j].x) * crossVal\n    cy += (points[i].y + points[j].y) * crossVal\n  }\n  a *= 0.5\n  if (almostEqual(a, 0)) return null\n  cx /= 6 * a\n  cy /= 6 * a\n  return { x: cx, y: cy }\n}\n\n// DCEL structures\nexport class Vertex implements Point {\n  x: number\n  y: number\n  out: number[] // Outgoing half-edge indices\n  connectionNames: Set<string> // Names of connections passing through this vertex\n\n  constructor(x: number, y: number) {\n    this.x = x\n    this.y = y\n    this.out = []\n    this.connectionNames = new Set()\n  }\n}\n\nexport class HalfEdge {\n  orig: number // Vertex index\n  dest: number // Vertex index\n  twin: number | null // Half-edge index\n  next: number | null // Half-edge index (around left face)\n  visited: boolean\n\n  constructor(orig: number, dest: number) {\n    this.orig = orig\n    this.dest = dest\n    this.twin = null\n    this.next = null\n    this.visited = false\n  }\n}\n\ninterface FaceVertex extends Point {\n  connectionNames?: Set<string>\n}\n\nexport interface Face {\n  vertices: FaceVertex[]\n  centroid: Point\n}\n\ninterface ComputeRegionCentroidsResult {\n  centroids: Point[]\n  faces: Face[]\n  allVertices: Vertex[] // These vertices now include connectionNames\n}\n\nexport function getCentroidsFromInnerBoxIntersections(\n  rectangle: Bounds,\n  userSegments: Segment[],\n): ComputeRegionCentroidsResult {\n  // 1. Build full segment list (user + rectangle perimeter)\n  const rectEdges: Segment[] = [\n    {\n      start: { x: rectangle.minX, y: rectangle.minY },\n      end: { x: rectangle.maxX, y: rectangle.minY },\n    },\n    {\n      start: { x: rectangle.maxX, y: rectangle.minY },\n      end: { x: rectangle.maxX, y: rectangle.maxY },\n    },\n    {\n      start: { x: rectangle.maxX, y: rectangle.maxY },\n      end: { x: rectangle.minX, y: rectangle.maxY },\n    },\n    {\n      start: { x: rectangle.minX, y: rectangle.maxY },\n      end: { x: rectangle.minX, y: rectangle.minY },\n    },\n  ]\n  const segments: Segment[] = [...userSegments, ...rectEdges]\n\n  // 2. Collect breakpoints on each segment (endpoints + intersections)\n  const breakMap: Point[][] = segments.map(() => []) // Array of arrays of points per segment\n\n  // Add endpoints\n  for (let i = 0; i < segments.length; ++i) {\n    const s = segments[i]\n    breakMap[i].push(s.start, s.end)\n  }\n\n  // Intersections between segments\n  for (let i = 0; i < segments.length; ++i) {\n    for (let j = i + 1; j < segments.length; ++j) {\n      const p: Point | null = segmentIntersection(\n        segments[i].start,\n        segments[i].end,\n        segments[j].start,\n        segments[j].end,\n      )\n      if (p) {\n        breakMap[i].push(p)\n        breakMap[j].push(p)\n      }\n    }\n  }\n\n  // 3. Deduplicate global vertices, assign ids\n  const vertexId = new Map<string, number>()\n  const vertices: Vertex[] = []\n\n  function getVertexId(p: Point): number {\n    const key = pointKey(p)\n    if (!vertexId.has(key)) {\n      const id = vertices.length\n      vertexId.set(key, id)\n      vertices.push(new Vertex(p.x, p.y))\n      return id\n    }\n    return vertexId.get(key)!\n  }\n\n  // Sort breakpoint lists along each segment and create sub-edges\n  const undirectedEdges: [number, number][] = []\n  for (let i = 0; i < segments.length; ++i) {\n    const s = segments[i]\n    const list: Point[] = breakMap[i].slice()\n    // Parametric position t along segment\n    list.sort((p1: Point, p2: Point) => {\n      const dx = s.end.x - s.start.x\n      const dy = s.end.y - s.start.y\n      const t1 = almostEqual(Math.abs(dx), 0)\n        ? (p1.y - s.start.y) / dy\n        : (p1.x - s.start.x) / dx\n      const t2 = almostEqual(Math.abs(dx), 0)\n        ? (p2.y - s.start.y) / dy\n        : (p2.x - s.start.x) / dx\n      return t1 - t2\n    })\n    for (let k = 0; k < list.length - 1; ++k) {\n      const p1 = list[k]\n      const p2 = list[k + 1]\n      const v1 = getVertexId(p1)\n      const v2 = getVertexId(p2)\n\n      if (v1 !== v2) {\n        undirectedEdges.push([v1, v2])\n        // Associate connectionName with the vertices of this sub-segment\n        if (s.connectionName) {\n          vertices[v1].connectionNames.add(s.connectionName)\n          vertices[v2].connectionNames.add(s.connectionName)\n        }\n      }\n    }\n  }\n\n  // 4. Build half-edges\n  const halfEdges: HalfEdge[] = []\n  for (const [v1, v2] of undirectedEdges) {\n    const he1 = new HalfEdge(v1, v2)\n    const he2 = new HalfEdge(v2, v1)\n    he1.twin = halfEdges.length + 1\n    he2.twin = halfEdges.length\n    const id1 = halfEdges.length\n    halfEdges.push(he1, he2)\n    // Push to vertex outgoing\n    vertices[v1].out.push(id1)\n    vertices[v2].out.push(id1 + 1)\n  }\n\n  // 5. Sort outgoing edges CCW around each vertex & set next pointers\n  for (let vid = 0; vid < vertices.length; ++vid) {\n    const v = vertices[vid]\n    v.out.sort((e1Idx: number, e2Idx: number) => {\n      const e1 = halfEdges[e1Idx]\n      const e2 = halfEdges[e2Idx]\n      const d1 = vertices[e1.dest]\n      const d2 = vertices[e2.dest]\n      const a1 = Math.atan2(d1.y - v.y, d1.x - v.x)\n      const a2 = Math.atan2(d2.y - v.y, d2.x - v.x)\n      return a1 - a2\n    })\n    const m = v.out.length\n    for (let i = 0; i < m; ++i) {\n      const heOutIdx = v.out[i]\n      const hePrevIdx = v.out[(i - 1 + m) % m] // CW predecessor\n      const heOut = halfEdges[heOutIdx]\n      if (heOut.twin !== null) {\n        halfEdges[heOut.twin].next = hePrevIdx // twin.next = CW-prev to keep left face on our left\n      }\n    }\n  }\n\n  // 6. Walk faces and compute centroids\n  const centroids: Point[] = []\n  const faces: Face[] = []\n\n  for (let h = 0; h < halfEdges.length; ++h) {\n    if (halfEdges[h].visited) continue\n    let walk: number | null = h\n    const poly: Vertex[] = []\n    const faceEdges: number[] = []\n\n    do {\n      if (walk === null) break // Should not happen in a well-formed DCEL\n      const currentEdge: any = halfEdges[walk]\n      currentEdge.visited = true\n      poly.push(vertices[currentEdge.orig])\n      faceEdges.push(walk)\n      walk = currentEdge.next\n    } while (walk !== null && walk !== h && !halfEdges[walk].visited)\n\n    if (poly.length < 3) continue\n\n    const area = polygonArea(poly)\n    if (area > EPS) {\n      const c = polygonCentroid(poly)\n      if (c) {\n        centroids.push(c)\n        faces.push({\n          vertices: poly.map((v) => ({\n            x: v.x,\n            y: v.y,\n            connectionNames:\n              v.connectionNames.size > 0 ? v.connectionNames : undefined,\n          })),\n          centroid: c,\n        })\n      }\n    }\n  }\n\n  return { centroids, faces, allVertices: vertices }\n}\n","/**\n * Generates all possible combinations of a binary array with a specific number of 1s and a given length\n * @param {number} oneCount - The number of 1s to include in each combination\n * @param {number} length - The total length of each combination array\n * @returns {Array<Array<number>>} - All possible combinations\n */\nexport function generateBinaryCombinations(oneCount: number, length: number) {\n  // Validate inputs\n  if (oneCount > length) {\n    throw new Error(\"oneCount cannot be greater than length\")\n  }\n\n  if (oneCount < 0 || length < 0) {\n    throw new Error(\"oneCount and length must be non-negative\")\n  }\n\n  const result: number[][] = []\n\n  // Helper function to generate combinations recursively\n  function generateCombinations(\n    current: number[],\n    onesLeft: number,\n    position: number,\n  ) {\n    // Base case: if we've filled the array up to the required length\n    if (position === length) {\n      // If we've used exactly the required number of 1s, add this combination to the result\n      if (onesLeft === 0) {\n        result.push([...current])\n      }\n      return\n    }\n\n    // Option 1: Place a 0 at the current position\n    current[position] = 0\n    generateCombinations(current, onesLeft, position + 1)\n\n    // Option 2: Place a 1 at the current position (if we still have 1s to place)\n    if (onesLeft > 0) {\n      current[position] = 1\n      generateCombinations(current, onesLeft - 1, position + 1)\n    }\n  }\n\n  // Start recursive generation with an empty array\n  generateCombinations(Array(length).fill(0), oneCount, 0)\n\n  return result\n}\n","import type { Bounds, Point } from \"@tscircuit/math-utils\"\nimport { getCentroidsFromInnerBoxIntersections } from \"./getCentroidsFromInnerBoxIntersections\"\nimport { generateBinaryCombinations } from \"./generateBinaryCombinations\"\nimport { MHPoint } from \"./types1\"\n\ntype ViaPositionVariantForLinesViaCountVariant = {\n  viaPositions: Point[]\n  viaCountVariant: number[]\n}\n\n/**\n * Get the all possible via positions if you consider the centroids of shapes\n * created by all the intersections that divide the bounding box of the node\n *\n * We iterate over the via count variants, for each variant we generate each\n * possible via position.\n * Remember: The viaCountVariants specifies the number of vias for each connection,\n * so that's how we know how many points to return\n */\nexport const getPossibleInitialViaPositions = (params: {\n  portPairsEntries: Array<\n    [\n      connectionName: string,\n      {\n        start: Omit<MHPoint, \"xMoves\" | \"yMoves\">\n        end: Omit<MHPoint, \"xMoves\" | \"yMoves\">\n      },\n    ]\n  >\n  bounds: Bounds\n  viaCountVariants: Array<number[]>\n}): Array<ViaPositionVariantForLinesViaCountVariant> => {\n  const { bounds, portPairsEntries, viaCountVariants } = params\n\n  const { centroids } = getCentroidsFromInnerBoxIntersections(\n    bounds,\n    portPairsEntries.map(([_, portPair]) => portPair),\n  )\n\n  const result: ViaPositionVariantForLinesViaCountVariant[] = []\n\n  for (const viaCountVariant of viaCountVariants) {\n    const viaCount = viaCountVariant.reduce((acc, count) => acc + count, 0)\n\n    let viaPositionSource: Array<{ x: number; y: number }> = centroids\n\n    if (centroids.length < viaCount) {\n      // There aren't enough centroids (might not be a very hard problem)\n      // we can just space the vias evenly within the node\n      viaPositionSource = []\n      const rows = Math.ceil(Math.sqrt(viaCount))\n      const cols = rows\n      for (let r = 0; r < rows; r++) {\n        for (let c = 0; c < cols; c++) {\n          viaPositionSource.push({\n            x:\n              bounds.minX +\n              ((c + 1) / (cols + 1)) * (bounds.maxX - bounds.minX),\n            y:\n              bounds.minY +\n              ((r + 1) / (rows + 1)) * (bounds.maxY - bounds.minY),\n          })\n        }\n      }\n    }\n\n    const viaPositionVariants = generateBinaryCombinations(\n      viaCount,\n      viaPositionSource.length,\n    )\n\n    for (const viaPositionVariant of viaPositionVariants) {\n      const viaPositions: Point[] = []\n      for (let i = 0; i < viaPositionVariant.length; i++) {\n        if (viaPositionVariant[i] === 1) {\n          viaPositions.push(viaPositionSource[i])\n        }\n      }\n      result.push({\n        viaPositions,\n        viaCountVariant,\n      })\n    }\n  }\n\n  return result\n}\n","export const getEveryPossibleOrdering = <T extends Array<any>>(ar: T): T[] => {\n  if (ar.length === 0) {\n    return [[] as unknown as T] // Base case: empty array has one permutation (empty array)\n  }\n\n  const result: T[] = []\n\n  for (let i = 0; i < ar.length; i++) {\n    const firstElement = ar[i]\n    const rest = [...ar.slice(0, i), ...ar.slice(i + 1)] as T\n    const permutationsOfRest = getEveryPossibleOrdering(rest)\n\n    for (const perm of permutationsOfRest) {\n      result.push([firstElement, ...perm] as T)\n    }\n  }\n\n  return result\n}\n","export function createSymmetricArray(\n  length: number,\n  oneCount: number,\n): number[] {\n  // Initialize array with all zeros\n  const result: number[] = new Array(length).fill(0)\n\n  // If oneCount is 0, return array of all zeros\n  if (oneCount === 0) return result\n\n  // If oneCount equals length, return array of all ones\n  if (oneCount === length) return result.fill(1)\n\n  // Determine whether to place 1s or 0s (whichever is fewer)\n  if (oneCount <= length / 2) {\n    // Place 1s symmetrically\n    const gap = Math.floor(length / oneCount)\n    const start = Math.floor((length - (gap * (oneCount - 1) + 1)) / 2)\n\n    for (let i = 0; i < oneCount; i++) {\n      result[start + i * gap] = 1\n    }\n  } else {\n    // Place 0s symmetrically (since there are fewer 0s than 1s)\n    const zeroCount = length - oneCount\n    const gap = Math.floor(length / zeroCount)\n    const start = Math.floor((length - (gap * (zeroCount - 1) + 1)) / 2)\n\n    // Fill array with 1s first\n    result.fill(1)\n\n    // Place 0s symmetrically\n    for (let i = 0; i < zeroCount; i++) {\n      result[start + i * gap] = 0\n    }\n  }\n\n  return result\n}\n","import { MHPoint2 } from \"./types2\"\nimport { createSymmetricArray } from \"./createSymmetricArray\"\n\nexport const constructMiddlePointsWithViaPositions = (params: {\n  start: MHPoint2\n  end: MHPoint2\n  segmentsPerPolyline: number\n  viaCount: number\n  availableZ: number[]\n  viaPositions: Array<{ x: number; y: number }>\n}) => {\n  const {\n    start,\n    end,\n    segmentsPerPolyline,\n    viaPositions,\n    viaCount,\n    availableZ,\n  } = params\n\n  const viaIndices = createSymmetricArray(segmentsPerPolyline, viaCount)\n  const middlePoints: (MHPoint2 | null)[] = viaIndices.map(() => null)\n\n  let viasAdded = 0\n  let lastZ = start.z1\n  const availableZOffset = availableZ.indexOf(start.z1)\n  for (let i = 0; i < viaIndices.length; i++) {\n    if (viaIndices[i] === 1) {\n      const nextZ =\n        availableZ[(availableZOffset + viasAdded + 1) % availableZ.length]\n      middlePoints[i] = {\n        ...viaPositions[viasAdded],\n        z1: lastZ,\n        z2: nextZ,\n      }\n      lastZ = nextZ\n      viasAdded++\n    }\n  }\n\n  let left: MHPoint2 = start\n  for (let i = 0; i < middlePoints.length; i++) {\n    if (middlePoints[i]) {\n      left = middlePoints[i]!\n      continue\n    }\n    let right: MHPoint2 = end\n    let rightIndex: number = middlePoints.length\n    for (let u = i + 1; u < middlePoints.length; u++) {\n      if (middlePoints[u]) {\n        right = middlePoints[u]!\n        rightIndex = u\n        break\n      }\n    }\n\n    const N = rightIndex - i\n    const dx = right.x - left.x\n    const dy = right.y - left.y\n    for (let t = 1 / (N + 1), ti = 0; ; t += 1 / (N + 1), ti++) {\n      if (i + ti === rightIndex) break\n      middlePoints[i + ti] = {\n        x: left.x + dx * t,\n        y: left.y + dy * t,\n        z1: left.z2,\n        z2: left.z2,\n      }\n    }\n  }\n\n  return middlePoints as unknown as MHPoint2[]\n}\n","/**\n * Get every combination from a choice array\n *\n * getEveryCombinationFromChoiceArray([[1, 2], [3, 4], [5, 6]])\n *\n * Returns:\n * [\n *  [1, 3, 5],\n *  [1, 3, 6],\n *  [1, 4, 5],\n *  [1, 4, 6],\n *  [2, 3, 5],\n *  [2, 3, 6],\n *  [2, 4, 5],\n *  [2, 4, 6],\n * ]\n */\nexport const getEveryCombinationFromChoiceArray = <T>(\n  choiceArray: T[][],\n): T[][] => {\n  if (!choiceArray || choiceArray.length === 0) {\n    return [[]] // Return an array with one empty combination if input is empty\n  }\n\n  let results: T[][] = [[]]\n\n  for (const choiceSet of choiceArray) {\n    const newResults: T[][] = []\n    for (const combination of results) {\n      for (const choice of choiceSet) {\n        newResults.push([...combination, choice])\n      }\n    }\n    results = newResults\n  }\n\n  return results\n}\n","import { MHPoint2 } from \"./types2\"\nimport { getEveryCombinationFromChoiceArray } from \"./getEveryCombinationFromChoiceArray\"\nimport { doSegmentsIntersect } from \"@tscircuit/math-utils\"\n\n/**\n * Each item in viaCountVariants is an array specifying the number of vias\n * for each polyline. If a polyline has a layer change, it will always have\n * an odd number of vias, if it doesn't have a layer change, it will always\n * have an even number of vias or 0\n *\n * e.g. if we have...\n * SEGMENTS_PER_POLYLINE = 3\n * polyLine0 = no layer change\n * polyLine1 = layer change\n *\n * We would have these possible variants:\n * [\n *  [0, 1],\n *  [0, 3],\n *  [2, 1],\n *  [2, 3]\n * ]\n *\n * Likewise, if we have...\n * SEGMENTS_PER_POLYLINE = 4\n * polyLine0 = no layer change\n * polyLine1 = layer change\n * polyLine2 = no layer change\n * maxViaCount = 4\n * minViaCount = 2 (sometimes we know, because of same-layer intersections,\n *                  there must be at least N vias)\n *\n * We would have these possible variants:\n * [\n *  [0, 1, 0],\n *  [0, 1, 2],\n *  [0, 3, 0],\n *  [2, 1, 0],\n * ]\n */\nexport const computeViaCountVariants = (\n  portPairsEntries: Array<\n    [connectionName: string, { start: MHPoint2; end: MHPoint2 }]\n  >,\n  segmentsPerPolyline: number,\n  maxViaCount: number,\n  minViaCount: number,\n): Array<number[]> => {\n  const possibleViaCountsPerPolyline: number[][] = []\n\n  for (const [, portPair] of portPairsEntries) {\n    const needsLayerChange = portPair.start.z1 !== portPair.end.z1\n    const possibleCounts: number[] = []\n\n    for (let i = 0; i <= segmentsPerPolyline; i++) {\n      const isOdd = i % 2 !== 0\n      if (needsLayerChange && isOdd) {\n        possibleCounts.push(i)\n      } else if (!needsLayerChange && !isOdd) {\n        possibleCounts.push(i)\n      }\n    }\n    possibleViaCountsPerPolyline.push(possibleCounts)\n  }\n\n  // Generate Cartesian product of possible counts\n  if (possibleViaCountsPerPolyline.length === 0) {\n    return [[]] // No polylines, return one variant with empty counts\n  }\n\n  let variants: number[][] = getEveryCombinationFromChoiceArray(\n    possibleViaCountsPerPolyline,\n  ).filter((variant) => {\n    for (let i = 0; i < variant.length; i++) {\n      const viaCount = variant.reduce((acc, count) => acc + count, 0)\n      if (viaCount < minViaCount) return false\n    }\n    return true\n  })\n\n  // If a port pair has a z change, it must always have at least 1 via\n  variants = variants.filter((variant) => {\n    for (let i = 0; i < portPairsEntries.length; i++) {\n      const [, portPair1] = portPairsEntries[i]\n      if (portPair1.start.z1 !== portPair1.start.z2) {\n        if (variant[i] === 0) return false\n      }\n    }\n    return true\n  })\n\n  // If two port pairs intersect, the sum of their via counts must be >= 2\n  variants = variants.filter((variant) => {\n    for (let i = 0; i < portPairsEntries.length; i++) {\n      const [, portPair1] = portPairsEntries[i]\n      if (portPairsEntries[i][1].start.z1 !== portPairsEntries[i][1].start.z2)\n        continue\n      for (let j = i + 1; j < portPairsEntries.length; j++) {\n        if (portPairsEntries[j][1].start.z1 !== portPairsEntries[j][1].start.z2)\n          continue\n\n        const [, portPair2] = portPairsEntries[j]\n        if (\n          portPair1.start.z1 === portPair1.end.z1 &&\n          portPair2.start.z1 === portPair2.end.z1 &&\n          portPair1.start.z1 === portPair2.start.z1 &&\n          doSegmentsIntersect(\n            portPair1.start,\n            portPair1.end,\n            portPair2.start,\n            portPair2.end,\n          )\n        ) {\n          if (variant[i] + variant[j] < 2) return false\n        }\n      }\n    }\n    return true\n  })\n\n  variants = variants.filter((variant) => {\n    const viaCount = variant.reduce((acc, count) => acc + count, 0)\n    if (viaCount > maxViaCount) return false\n    return true\n  })\n\n  return variants\n}\n","import { MHPoint2 } from \"./types2\"\n\nexport const withinBounds = (\n  point: MHPoint2,\n  bounds: { minX: number; maxX: number; minY: number; maxY: number },\n  padding: number = 0,\n) => {\n  return (\n    point.x >= bounds.minX + padding &&\n    point.x <= bounds.maxX - padding &&\n    point.y >= bounds.minY + padding &&\n    point.y <= bounds.maxY - padding\n  )\n}\n","import type { Bounds } from \"@tscircuit/math-utils\"\nimport { MHPoint, PolyLine } from \"./types1\" // Assuming types1 has the necessary definitions\n\n// Re-use or adapt geometric primitives (Point, Segment, intersection, etc.)\n// For brevity, assuming similar primitives as in getCentroidsFromInnerBoxIntersections\n// or getNumberOfClosedFaces are available or defined here/imported.\n\ninterface Point {\n  x: number\n  y: number\n}\n\ninterface Segment {\n  start: Point\n  end: Point\n  connectionName: string | null // null for boundary segments\n  layer: number\n}\n\n// --- Geometric Primitives (Simplified - Adapt from existing utils) ---\n\nconst EPS = 1e-9\n\nfunction almostEqual(a: number, b: number): boolean {\n  return Math.abs(a - b) < EPS\n}\n\nfunction pointKey(p: Point): string {\n  return `${Math.round(p.x / EPS)}:${Math.round(p.y / EPS)}`\n}\n\nfunction cross(ax: number, ay: number, bx: number, by: number): number {\n  return ax * by - ay * bx\n}\n\nfunction segmentIntersection(\n  p1: Point,\n  p2: Point,\n  q1: Point,\n  q2: Point,\n): Point | null {\n  const r = { x: p2.x - p1.x, y: p2.y - p1.y }\n  const s = { x: q2.x - q1.x, y: q2.y - q1.y }\n  const rxs = cross(r.x, r.y, s.x, s.y)\n  const qp = { x: q1.x - p1.x, y: q1.y - p1.y }\n\n  if (almostEqual(rxs, 0)) {\n    // Collinear or parallel\n    // Check for overlap if collinear - Simplified: returning null for now\n    // A robust implementation would handle collinear overlaps.\n    return null\n  }\n\n  const t = cross(qp.x, qp.y, s.x, s.y) / rxs\n  const u = cross(qp.x, qp.y, r.x, r.y) / rxs\n\n  if (t >= -EPS && t <= 1 + EPS && u >= -EPS && u <= 1 + EPS) {\n    // Intersection point is within both segments\n    return { x: p1.x + t * r.x, y: p1.y + t * r.y }\n  }\n\n  return null // Intersection point is not on segments\n}\n\nfunction isOnSegment(p: Point, a: Point, b: Point): boolean {\n  const d_ap = Math.hypot(p.x - a.x, p.y - a.y)\n  const d_pb = Math.hypot(p.x - b.x, p.y - b.y)\n  const d_ab = Math.hypot(a.x - b.x, a.y - b.y)\n  return almostEqual(d_ap + d_pb, d_ab)\n}\n\n// --- DCEL-like Structures ---\n\ninterface DcelVertex extends Point {\n  id: number\n  isVia: boolean\n  connectionNames: Set<string> // Connections passing through this vertex (esp. for endpoints/vias)\n  outgoingEdges: DcelHalfEdge[] // Sorted CCW\n}\n\ninterface DcelHalfEdge {\n  id: number\n  origin: DcelVertex\n  twin: DcelHalfEdge | null\n  next: DcelHalfEdge | null\n  face: DcelFace | null\n  connectionName: string | null // From original segment\n  layer: number // From original segment\n  visited: boolean // For face traversal\n}\n\ninterface DcelFace {\n  id: number\n  outerComponent: DcelHalfEdge | null // One edge on the outer boundary\n  innerComponents: DcelHalfEdge[] // Edges bounding holes (if any) - not strictly needed for this check\n  isOuterFace: boolean\n}\n\n// --- Main Detection Function ---\n\nexport function detectMultiConnectionClosedFacesWithoutVias(\n  polyLines: PolyLine[],\n  bounds: Bounds,\n): boolean {\n  const allSegments: Segment[] = []\n  const viaPoints = new Map<\n    string,\n    { point: MHPoint; connectionName: string }\n  >() // key: pointKey(via)\n\n  // 1. Extract segments from polylines and identify vias\n  for (const polyLine of polyLines) {\n    const path = [polyLine.start, ...polyLine.mPoints, polyLine.end]\n    for (let i = 0; i < path.length - 1; i++) {\n      const p1 = path[i]\n      const p2 = path[i + 1]\n      const layer = p1.z2 // Layer of the segment\n\n      // Add segment\n      allSegments.push({\n        start: { x: p1.x, y: p1.y },\n        end: { x: p2.x, y: p2.y },\n        connectionName: polyLine.connectionName,\n        layer: layer,\n      })\n\n      // Check and store vias (using p1 as the reference point for the via)\n      if (p1.z1 !== p1.z2) {\n        const key = pointKey(p1)\n        if (!viaPoints.has(key)) {\n          viaPoints.set(key, {\n            point: p1,\n            connectionName: polyLine.connectionName,\n          })\n        }\n      }\n    }\n    // Check the last point in the path as well\n    const lastPoint = path[path.length - 1]\n    if (lastPoint.z1 !== lastPoint.z2) {\n      const key = pointKey(lastPoint)\n      if (!viaPoints.has(key)) {\n        viaPoints.set(key, {\n          point: lastPoint,\n          connectionName: polyLine.connectionName,\n        })\n      }\n    }\n  }\n\n  // 2. Add boundary segments (assuming layer 0, adjust if needed)\n  // Assign a special connectionName (e.g., null or \"__boundary__\")\n  const boundaryLayer = 0 // Or determine based on context if necessary\n  const boundarySegments: Segment[] = [\n    {\n      start: { x: bounds.minX, y: bounds.minY },\n      end: { x: bounds.maxX, y: bounds.minY },\n      connectionName: null,\n      layer: boundaryLayer,\n    },\n    {\n      start: { x: bounds.maxX, y: bounds.minY },\n      end: { x: bounds.maxX, y: bounds.maxY },\n      connectionName: null,\n      layer: boundaryLayer,\n    },\n    {\n      start: { x: bounds.maxX, y: bounds.maxY },\n      end: { x: bounds.minX, y: bounds.maxY },\n      connectionName: null,\n      layer: boundaryLayer,\n    },\n    {\n      start: { x: bounds.minX, y: bounds.maxY },\n      end: { x: bounds.minX, y: bounds.minY },\n      connectionName: null,\n      layer: boundaryLayer,\n    },\n  ]\n  allSegments.push(...boundarySegments)\n\n  // 3. Find all vertices (endpoints and intersections)\n  const verticesMap = new Map<string, DcelVertex>()\n  let vertexIdCounter = 0\n\n  function getOrCreateVertex(\n    p: Point,\n    connectionName?: string | null,\n  ): DcelVertex {\n    const key = pointKey(p)\n    let vertex = verticesMap.get(key)\n    if (!vertex) {\n      const isVia = viaPoints.has(key)\n      vertex = {\n        id: vertexIdCounter++,\n        x: p.x,\n        y: p.y,\n        isVia: isVia,\n        connectionNames: new Set(),\n        outgoingEdges: [],\n      }\n      verticesMap.set(key, vertex)\n      if (isVia && viaPoints.get(key)) {\n        vertex.connectionNames.add(viaPoints.get(key)!.connectionName)\n      }\n    }\n    // Add connection name if provided (e.g., for original endpoints)\n    if (connectionName) {\n      vertex.connectionNames.add(connectionName)\n    }\n    return vertex\n  }\n\n  // Add original endpoints\n  for (const seg of allSegments) {\n    getOrCreateVertex(seg.start, seg.connectionName)\n    getOrCreateVertex(seg.end, seg.connectionName)\n  }\n\n  // Find and add intersection points\n  const segmentBreakpoints = new Map<Segment, Point[]>()\n  // Initialize the map for all segments first\n  for (const segment of allSegments) {\n    segmentBreakpoints.set(segment, [])\n  }\n\n  for (let i = 0; i < allSegments.length; i++) {\n    // The entry for allSegments[i] is already initialized above\n    for (let j = i + 1; j < allSegments.length; j++) {\n      // Only intersect segments on the same layer\n      if (allSegments[i].layer !== allSegments[j].layer) continue\n\n      const intersection = segmentIntersection(\n        allSegments[i].start,\n        allSegments[i].end,\n        allSegments[j].start,\n        allSegments[j].end,\n      )\n\n      if (intersection) {\n        getOrCreateVertex(intersection) // Create vertex for intersection\n        // Store intersection point relative to both segments for splitting later\n        if (\n          isOnSegment(intersection, allSegments[i].start, allSegments[i].end)\n        ) {\n          segmentBreakpoints.get(allSegments[i])!.push(intersection)\n        }\n        if (\n          isOnSegment(intersection, allSegments[j].start, allSegments[j].end)\n        ) {\n          segmentBreakpoints.get(allSegments[j])!.push(intersection)\n        }\n      }\n    }\n  }\n\n  // 4. Create Half-Edges from split segments\n  const halfEdges: DcelHalfEdge[] = []\n  let edgeIdCounter = 0\n\n  for (const segment of allSegments) {\n    const pointsOnSegment = [\n      segment.start,\n      ...segmentBreakpoints.get(segment)!,\n      segment.end,\n    ]\n\n    // Sort points along the segment\n    pointsOnSegment.sort((a, b) => {\n      const dx = segment.end.x - segment.start.x\n      const dy = segment.end.y - segment.start.y\n      if (Math.abs(dx) > Math.abs(dy)) {\n        // Sort primarily by x\n        return (a.x - segment.start.x) / dx - (b.x - segment.start.x) / dx\n      } else {\n        // Sort primarily by y\n        // Avoid division by zero if dy is small\n        return Math.abs(dy) < EPS\n          ? 0\n          : (a.y - segment.start.y) / dy - (b.y - segment.start.y) / dy\n      }\n    })\n\n    // Deduplicate points (intersections might be very close to endpoints)\n    const uniquePoints: Point[] = []\n    if (pointsOnSegment.length > 0) {\n      uniquePoints.push(pointsOnSegment[0])\n      for (let i = 1; i < pointsOnSegment.length; i++) {\n        if (\n          !almostEqual(pointsOnSegment[i].x, pointsOnSegment[i - 1].x) ||\n          !almostEqual(pointsOnSegment[i].y, pointsOnSegment[i - 1].y)\n        ) {\n          uniquePoints.push(pointsOnSegment[i])\n        }\n      }\n    }\n\n    // Create half-edges for each sub-segment\n    for (let i = 0; i < uniquePoints.length - 1; i++) {\n      const p1 = uniquePoints[i]\n      const p2 = uniquePoints[i + 1]\n      const v1 = getOrCreateVertex(p1, segment.connectionName)\n      const v2 = getOrCreateVertex(p2, segment.connectionName)\n\n      // Avoid creating zero-length edges\n      if (v1 === v2) continue\n\n      const edge1: DcelHalfEdge = {\n        id: edgeIdCounter++,\n        origin: v1,\n        twin: null, // Will be set later\n        next: null, // Will be set later\n        face: null, // Will be set later\n        connectionName: segment.connectionName,\n        layer: segment.layer,\n        visited: false,\n      }\n      const edge2: DcelHalfEdge = {\n        id: edgeIdCounter++,\n        origin: v2,\n        twin: edge1,\n        next: null,\n        face: null,\n        connectionName: segment.connectionName, // Twin carries same info\n        layer: segment.layer,\n        visited: false,\n      }\n      edge1.twin = edge2\n\n      halfEdges.push(edge1, edge2)\n      v1.outgoingEdges.push(edge1)\n      v2.outgoingEdges.push(edge2)\n    }\n  }\n\n  // 5. Link Half-Edges (Sort outgoing edges CCW and set `next` pointers)\n  for (const vertex of verticesMap.values()) {\n    vertex.outgoingEdges.sort((e1, e2) => {\n      const p1 = e1.twin!.origin // Destination of e1\n      const p2 = e2.twin!.origin // Destination of e2\n      const angle1 = Math.atan2(p1.y - vertex.y, p1.x - vertex.x)\n      const angle2 = Math.atan2(p2.y - vertex.y, p2.x - vertex.x)\n      return angle1 - angle2\n    })\n\n    // Set next pointers: e.twin.next = prev_edge\n    const numEdges = vertex.outgoingEdges.length\n    for (let i = 0; i < numEdges; i++) {\n      const currentEdge = vertex.outgoingEdges[i]\n      const prevEdge = vertex.outgoingEdges[(i - 1 + numEdges) % numEdges] // Edge arriving CW before currentEdge\n      // The 'next' edge in the face cycle starting from currentEdge.twin's origin is prevEdge\n      if (currentEdge.twin) {\n        currentEdge.twin.next = prevEdge\n      }\n    }\n  }\n\n  // 6. Traverse Faces and Check Conditions\n  const faces: DcelFace[] = []\n  let faceIdCounter = 0\n  let outerFace: DcelFace | null = null\n  let maxArea = -Infinity\n\n  for (const edge of halfEdges) {\n    if (edge.visited) continue\n\n    const face: DcelFace = {\n      id: faceIdCounter++,\n      outerComponent: edge,\n      innerComponents: [],\n      isOuterFace: false, // Assume internal first\n    }\n    faces.push(face)\n\n    let currentEdge: DcelHalfEdge | null = edge\n    const faceEdges: DcelHalfEdge[] = []\n    const faceVertices: DcelVertex[] = []\n    const faceConnectionNames = new Set<string | null>()\n    let faceArea = 0\n\n    do {\n      if (!currentEdge || currentEdge.visited) {\n        // This might happen with malformed geometry or complex overlaps\n        console.warn(\n          \"Face traversal encountered visited edge or null, breaking loop.\",\n          face.id,\n        )\n        // Resetting faceEdges to prevent partial face analysis\n        faceEdges.length = 0\n        break\n      }\n      currentEdge.visited = true\n      currentEdge.face = face\n      faceEdges.push(currentEdge)\n      faceVertices.push(currentEdge.origin)\n      if (currentEdge.connectionName !== null) {\n        // Exclude boundary connection name\n        faceConnectionNames.add(currentEdge.connectionName)\n      }\n\n      // Area calculation (Shoelace formula)\n      const p1 = currentEdge.origin\n      const p2 = currentEdge.twin!.origin\n      faceArea += p1.x * p2.y - p2.x * p1.y\n\n      currentEdge = currentEdge.next\n    } while (currentEdge !== edge && currentEdge !== null)\n\n    // Check if the loop closed properly\n    if (currentEdge !== edge) {\n      // Loop didn't close, likely due to geometric issues or incomplete DCEL linking.\n      // Mark this face as potentially problematic or discard it.\n      console.warn(`Face ${face.id} did not close properly.`)\n      // Optionally remove the face or mark it invalid\n      faces.pop() // Remove the incomplete face\n      faceIdCounter--\n      // Backtrack visited flags? This can be complex. Simpler to log and potentially ignore.\n      continue // Skip analysis for this incomplete face\n    }\n\n    faceArea = 0.5 * Math.abs(faceArea)\n\n    // Identify outer face (largest area)\n    if (faceArea > maxArea) {\n      maxArea = faceArea\n      if (outerFace) outerFace.isOuterFace = false // Demote previous outer face\n      outerFace = face\n      face.isOuterFace = true\n    }\n\n    // --- Condition Check for Internal Faces ---\n    if (!face.isOuterFace && faceEdges.length > 0) {\n      // Ensure face is valid and internal\n      // Check 1: Does the face involve multiple non-boundary connections?\n      // Note: All edges in a valid face should be on the same layer due to the intersection logic.\n      const actualConnectionNames = [...faceConnectionNames].filter(\n        (name) => name !== null,\n      )\n\n      if (actualConnectionNames.length > 1) {\n        // Check 2: Is ANY vertex on this face's boundary a via?\n        let viaFoundOnFace = false\n        for (const vertex of faceVertices) {\n          if (vertex.isVia) {\n            viaFoundOnFace = true\n            break // Found a via on the boundary, this face is potentially valid\n          }\n        }\n\n        // If multiple connections form the face AND NO via was found on its boundary...\n        if (!viaFoundOnFace) {\n          // This configuration is invalid because multiple nets form a closed loop\n          // on the same layer without a via allowing a layer change.\n          // console.log(`Detected multi-connection face (ID: ${face.id}, Connections: ${actualConnectionNames.join(', ')}) on layer ${faceEdges[0]?.layer} without any vias on its boundary.`)\n          return true // Found the problematic configuration\n        }\n      }\n    }\n  }\n\n  // If we finish traversing all faces without returning true, the condition was not met\n  return false\n}\n","import { ConnectivityMap } from \"circuit-json-to-connectivity-map\"\nimport { BaseSolver } from \"lib/solvers/BaseSolver\"\nimport { HighDensityHyperParameters } from \"../HighDensityHyperParameters\"\nimport {\n  HighDensityIntraNodeRoute,\n  NodeWithPortPoints,\n} from \"lib/types/high-density-types\"\nimport { GraphicsObject } from \"graphics-debug\"\nimport { generateColorMapFromNodeWithPortPoints } from \"lib/utils/generateColorMapFromNodeWithPortPoints\"\nimport { safeTransparentize } from \"lib/solvers/colors\"\nimport { getIntraNodeCrossings } from \"lib/utils/getIntraNodeCrossings\"\nimport {\n  distance,\n  doSegmentsIntersect,\n  pointToSegmentDistance,\n  segmentToSegmentMinDistance,\n  pointToSegmentClosestPoint,\n  distSq,\n  clamp,\n} from \"@tscircuit/math-utils\"\nimport { getPossibleInitialViaPositions } from \"./getPossibleInitialViaPositions\"\nimport { getEveryPossibleOrdering } from \"./getEveryPossibleOrdering\"\nimport { getEveryCombinationFromChoiceArray } from \"./getEveryCombinationFromChoiceArray\"\nimport { PolyLine, MHPoint, Candidate } from \"./types1\"\nimport { constructMiddlePointsWithViaPositions } from \"./constructMiddlePointsWithViaPositions\"\nimport { computeViaCountVariants } from \"./computeViaCountVariants\"\nimport { MHPoint2, PolyLine2 } from \"./types2\"\nimport { withinBounds } from \"./withinBounds\"\nimport { detectMultiConnectionClosedFacesWithoutVias } from \"./detectMultiConnectionClosedFacesWithoutVias\"\n\nexport class MultiHeadPolyLineIntraNodeSolver extends BaseSolver {\n  nodeWithPortPoints: NodeWithPortPoints\n  colorMap: Record<string, string>\n  hyperParameters: Partial<HighDensityHyperParameters>\n  connMap?: ConnectivityMap\n  candidates: Candidate[]\n  bounds: { minX: number; maxX: number; minY: number; maxY: number }\n  solvedRoutes: HighDensityIntraNodeRoute[] = []\n  unsolvedConnections: any[] = []\n\n  SEGMENTS_PER_POLYLINE: number\n\n  cellSize: number\n\n  MAX_CANDIDATES = 50e3\n\n  viaDiameter: number = 0.6\n  obstacleMargin: number = 0.1\n  traceWidth: number = 0.15\n  availableZ: number[] = []\n  uniqueConnections: number = 0\n\n  BOUNDARY_PADDING: number\n\n  lastCandidate: Candidate | null = null\n\n  maxViaCount: number\n  minViaCount: number\n\n  phase: \"setup\" | \"solving\" = \"setup\"\n  progress = 0\n\n  constructor(params: {\n    nodeWithPortPoints: NodeWithPortPoints\n    colorMap?: Record<string, string>\n    hyperParameters?: Partial<HighDensityHyperParameters>\n    connMap?: ConnectivityMap\n  }) {\n    super()\n    this.MAX_ITERATIONS = 10e3\n    this.nodeWithPortPoints = params.nodeWithPortPoints\n    this.colorMap =\n      params.colorMap ??\n      generateColorMapFromNodeWithPortPoints(params.nodeWithPortPoints)\n    this.hyperParameters = params.hyperParameters ?? {}\n    this.SEGMENTS_PER_POLYLINE =\n      params.hyperParameters?.SEGMENTS_PER_POLYLINE ?? 3\n    this.BOUNDARY_PADDING = params.hyperParameters?.BOUNDARY_PADDING ?? 0.05\n    this.connMap = params.connMap\n\n    // TODO swap with more sophisticated grid in SingleHighDensityRouteSolver\n    this.cellSize = this.nodeWithPortPoints.width / 1024\n\n    this.candidates = []\n    this.availableZ = this.nodeWithPortPoints.availableZ ?? [0, 1]\n\n    this.bounds = {\n      minX:\n        this.nodeWithPortPoints.center.x - this.nodeWithPortPoints.width / 2,\n      maxX:\n        this.nodeWithPortPoints.center.x + this.nodeWithPortPoints.width / 2,\n      minY:\n        this.nodeWithPortPoints.center.y - this.nodeWithPortPoints.height / 2,\n      maxY:\n        this.nodeWithPortPoints.center.y + this.nodeWithPortPoints.height / 2,\n    }\n\n    const areaInsideNode =\n      this.nodeWithPortPoints.width * this.nodeWithPortPoints.height\n    const areaPerVia =\n      (this.viaDiameter + this.obstacleMargin * 2 + this.traceWidth / 2) ** 2\n\n    const uniqueConnections = new Set(\n      this.nodeWithPortPoints.portPoints.map((pp) => pp.connectionName),\n    ).size\n    this.uniqueConnections = uniqueConnections\n\n    const { numSameLayerCrossings, numTransitions } = getIntraNodeCrossings(\n      this.nodeWithPortPoints,\n    )\n\n    this.minViaCount = numSameLayerCrossings * 2 + numTransitions\n    this.maxViaCount = Math.min(\n      Math.floor(areaInsideNode / areaPerVia),\n      Math.ceil(uniqueConnections * 1.5),\n    )\n\n    // if (uniqueConnections > 5) {\n    //   this.failed = true\n    //   this.error = `Limit is currently set to 6 unique connections, ${uniqueConnections} found`\n    //   return\n    // }\n\n    if (\n      this.minViaCount >\n      this.SEGMENTS_PER_POLYLINE * (uniqueConnections / 2)\n    ) {\n      this.failed = true\n      this.error = `Not possible to solve problem with given SEGMENTS_PER_POLYLINE (${this.SEGMENTS_PER_POLYLINE}), atleast ${this.minViaCount} vias are required`\n      return\n    }\n\n    if (this.maxViaCount > this.SEGMENTS_PER_POLYLINE) {\n      this.maxViaCount = this.SEGMENTS_PER_POLYLINE\n    }\n\n    if (this.maxViaCount < this.minViaCount) {\n      this.maxViaCount = this.minViaCount\n    }\n  }\n\n  /**\n   * minGaps is a list of distances representing the \"gap\" between segments\n   * on each layer.\n   *\n   * Each minGaps number represents the gap for a polyline pair, for example if\n   * you have 3 polylines, you would have 3 minGaps...\n   *\n   * [ p1 -> p2 , p1 -> p3, p2 -> p3 ]\n   */\n  computeMinGapBtwPolyLines(polyLines: PolyLine2[]) {\n    const minGaps = []\n    const polyLineSegmentsByLayer: Array<Map<number, [MHPoint2, MHPoint2][]>> =\n      []\n    const polyLineVias: Array<MHPoint2[]> = []\n    for (let i = 0; i < polyLines.length; i++) {\n      const polyLine = polyLines[i]\n      const path = [polyLine.start, ...polyLine.mPoints, polyLine.end]\n      const segmentsByLayer: Map<number, [MHPoint2, MHPoint2][]> = new Map(\n        this.availableZ.map((z) => [z, []]),\n      )\n      for (let i = 0; i < path.length - 1; i++) {\n        const segment: [MHPoint2, MHPoint2] = [path[i], path[i + 1]]\n        segmentsByLayer.get(segment[0].z2)!.push(segment)\n      }\n      polyLineSegmentsByLayer.push(segmentsByLayer)\n      polyLineVias.push(path.filter((p) => p.z1 !== p.z2))\n    }\n\n    for (let i = 0; i < polyLines.length; i++) {\n      const path1SegmentsByLayer = polyLineSegmentsByLayer[i]\n      const path1Vias = polyLineVias[i]\n      // Start j from i + 1 to compare distinct pairs only once\n      for (let j = i + 1; j < polyLines.length; j++) {\n        if (\n          this.connMap?.areIdsConnected(\n            polyLines[i].connectionName,\n            polyLines[j].connectionName,\n          )\n        ) {\n          continue\n        }\n        const path2SegmentsByLayer = polyLineSegmentsByLayer[j]\n        const path2Vias = polyLineVias[j]\n\n        let minGap = 1\n        for (const zLayer of this.availableZ) {\n          const path1Segments = path1SegmentsByLayer.get(zLayer) ?? []\n          const path2Segments = path2SegmentsByLayer.get(zLayer) ?? []\n\n          // SEGMENT TO SEGMENT DISTANCES\n          for (const segment1 of path1Segments) {\n            for (const segment2 of path2Segments) {\n              minGap = Math.min(\n                minGap,\n                segmentToSegmentMinDistance(\n                  segment1[0],\n                  segment1[1],\n                  segment2[0],\n                  segment2[1],\n                ) - this.traceWidth,\n              )\n            }\n          }\n\n          // VIA TO SEGMENT DISTANCES\n          for (const via of path1Vias) {\n            for (const segment of path2Segments) {\n              minGap = Math.min(\n                minGap,\n                pointToSegmentDistance(via, segment[0], segment[1]) -\n                  this.traceWidth / 2 -\n                  this.viaDiameter / 2,\n              )\n            }\n          }\n          for (const via of path2Vias) {\n            for (const segment of path1Segments) {\n              minGap = Math.min(\n                minGap,\n                pointToSegmentDistance(via, segment[0], segment[1]) -\n                  this.traceWidth / 2 -\n                  this.viaDiameter / 2,\n              )\n            }\n          }\n\n          // VIA TO VIA DISTANCES\n          for (const via1 of path1Vias) {\n            for (const via2 of path2Vias) {\n              minGap = Math.min(minGap, distance(via1, via2) - this.viaDiameter)\n            }\n          }\n        }\n        minGaps.push(minGap)\n      }\n    }\n    return minGaps\n  }\n\n  insertCandidate(candidate: any) {\n    // Binary search to find the correct position\n    let low = 0\n    let high = this.candidates.length - 1\n    while (low <= high) {\n      const mid = Math.floor((low + high) / 2)\n      if (this.candidates[mid].f < candidate.f) {\n        low = mid + 1\n      } else {\n        high = mid - 1\n      }\n    }\n    this.candidates.splice(low, 0, candidate)\n  }\n\n  /**\n   * Unlike most A* solvers with one initial candidate, we create a candidate\n   * for each configuration of vias we want to test, this way when computing\n   * neighbors we never consider changing layers\n   */\n  setupInitialPolyLines() {\n    const portPairs: Map<string, { start: MHPoint; end: MHPoint }> = new Map()\n    this.nodeWithPortPoints.portPoints.forEach((portPoint) => {\n      if (!portPairs.has(portPoint.connectionName)) {\n        portPairs.set(portPoint.connectionName, {\n          start: {\n            ...portPoint,\n            z1: portPoint.z ?? 0,\n            z2: portPoint.z ?? 0,\n          },\n          end: null as any,\n        })\n      } else {\n        portPairs.get(portPoint.connectionName)!.end = {\n          ...portPoint,\n          z1: portPoint.z ?? 0,\n          z2: portPoint.z ?? 0,\n        }\n      }\n    })\n\n    // Remove port pairs with only one point\n    for (const [connectionName, portPair] of portPairs.entries()) {\n      if (portPair.end === null) {\n        portPairs.delete(connectionName)\n      }\n    }\n\n    if (portPairs.size === 0) {\n      this.failed = true\n      this.error = \"No port pairs found, can't solve\"\n      return\n    }\n\n    const portPairsEntries = Array.from(portPairs.entries())\n\n    const viaCountVariants = computeViaCountVariants(\n      portPairsEntries,\n      this.SEGMENTS_PER_POLYLINE,\n      this.maxViaCount,\n      this.minViaCount,\n    )\n\n    const possibleViaPositions = getPossibleInitialViaPositions({\n      portPairsEntries,\n      viaCountVariants,\n      bounds: this.bounds,\n    })\n\n    const possibleViaPositionsWithReorderings = []\n    for (const { viaCountVariant, viaPositions } of possibleViaPositions) {\n      const viaPositionsWithReorderings = getEveryPossibleOrdering(viaPositions)\n      for (const viaPositions of viaPositionsWithReorderings) {\n        possibleViaPositionsWithReorderings.push({\n          viaCountVariant,\n          viaPositions,\n        })\n      }\n    }\n\n    // MAJOR OPTIMIZATION ISSUE:\n    // We currently generate a lot of redundant or invalid viaPositions because\n    // we don't specify that only certain connectionNames should occupy a via\n    // position. We later detect when there's a \"single-layer closed face\" and\n    // discard these candidates- but they should never be generated! For 5\n    // connections you can easily have 80,000 via position variants, with over\n    // ~90% being invalid from empirical testing.\n\n    // Convert the portPairs into PolyLines for the initial candidate\n    for (const {\n      viaPositions,\n      viaCountVariant,\n    } of possibleViaPositionsWithReorderings) {\n      const polyLines: PolyLine[] = []\n      let viaPositionIndicesUsed = 0\n      for (let i = 0; i < portPairsEntries.length; i++) {\n        const [connectionName, portPair] = portPairsEntries[i]\n        const viaCount = viaCountVariant[i]\n        const viaPositionsForPolyline = viaPositions.slice(\n          viaPositionIndicesUsed,\n          viaPositionIndicesUsed + viaCount,\n        )\n        const middlePoints = constructMiddlePointsWithViaPositions({\n          start: portPair.start,\n          end: portPair.end,\n          segmentsPerPolyline: this.SEGMENTS_PER_POLYLINE,\n          viaPositions: viaPositionsForPolyline,\n          viaCount,\n          availableZ: this.availableZ,\n        })\n        viaPositionIndicesUsed += viaCount\n\n        polyLines.push({\n          connectionName,\n          start: portPair.start,\n          end: portPair.end,\n          mPoints: middlePoints,\n        })\n      }\n      const hasClosedSameLayerFace =\n        detectMultiConnectionClosedFacesWithoutVias(polyLines, this.bounds)\n\n      if (hasClosedSameLayerFace) continue\n\n      const minGaps = this.computeMinGapBtwPolyLines(polyLines)\n      const h = this.computeH({ minGaps, forces: [] })\n      const newCandidate = {\n        polyLines,\n        g: 0,\n        h: h,\n        f: h,\n        viaCount: viaCountVariant.reduce((acc, count) => acc + count, 0),\n        minGaps,\n        // hasClosedSameLayerFace\n      }\n\n      if (this.checkIfSolved(newCandidate)) {\n        this.candidates = [newCandidate]\n        return\n      }\n\n      this.candidates.push(newCandidate)\n\n      // NOTE: Might make sense to move this to ._step() so we can\n      // keep generating\n      if (this.candidates.length > this.MAX_CANDIDATES) {\n        return\n      }\n    }\n    this.candidates.sort((a, b) => a.f - b.f)\n  }\n\n  /**\n   * g is the cost of each candidate, we consider complexity (deviation from\n   * the straight line path for # of operations). This means g increases by\n   * 1 from the parent for each operation\n   */\n  computeG(polyLines: PolyLine[], candidate: Candidate) {\n    // return 0\n    return candidate.g + 0.000005 + candidate.viaCount * 0.000005 * 100\n  }\n\n  /**\n   * h is the heuristic cost of each candidate.\n   */\n  computeH(candidate: Pick<Candidate, \"minGaps\" | \"forces\">) {\n    // Compute the total force magnitude\n    let totalForceMagnitude = 0\n    for (const force of candidate.forces ?? []) {\n      for (const forceMap of force) {\n        for (const force of forceMap.values()) {\n          totalForceMagnitude += force.fx * force.fx + force.fy * force.fy\n        }\n      }\n    }\n    return totalForceMagnitude\n  }\n\n  getNeighbors(candidate: Candidate): Candidate[] {\n    const { polyLines } = candidate\n    const numPolyLines = polyLines.length\n    const FORCE_MAGNITUDE = 0.02 // Tunable parameter for force strength\n    const VIA_FORCE_MULTIPLIER = 2.0 // Vias push harder\n    const INSIDE_VIA_FORCE_MULTIPLIER = 4.0 // Extra multiplier when inside a via\n    const SEGMENT_FORCE_MULTIPLIER = 1.0\n    // const FORCE_DECAY_RATE = 1.0 / this.cellSize // Controls how quickly force falls off with distance (adjust as needed)\n    const FORCE_DECAY_RATE = 6\n    const BOUNDARY_FORCE_STRENGTH = 0.008 // How strongly points are pushed back into bounds\n    const EPSILON = 1e-6 // To avoid division by zero\n\n    // 1. Initialize forces structure: forces[targetLineIdx][targetMPointIdx] = Map<sourceId, {fx, fy}>\n    const forces: Array<Array<Map<string, { fx: number; fy: number }>>> =\n      Array.from({ length: numPolyLines }, (_, i) =>\n        Array.from({ length: polyLines[i].mPoints.length }, () => new Map()),\n      )\n\n    // Helper to add a specific force contribution to an mPoint if it exists\n    const addForceContribution = (\n      targetLineIndex: number,\n      targetPointIndexInFullPath: number, // Index in [start, ...mPoints, end]\n      sourceId: string, // Identifier for the source of the force\n      fx: number,\n      fy: number,\n    ) => {\n      // Only apply force if the target point is an mPoint (not start or end)\n      if (\n        targetPointIndexInFullPath > 0 &&\n        targetPointIndexInFullPath <\n          polyLines[targetLineIndex].mPoints.length + 1\n      ) {\n        const targetMPointIndex = targetPointIndexInFullPath - 1\n        const forceMap = forces[targetLineIndex][targetMPointIndex]\n        const existingForce = forceMap.get(sourceId) || { fx: 0, fy: 0 }\n        forceMap.set(sourceId, {\n          fx: existingForce.fx + fx,\n          fy: existingForce.fy + fy,\n        })\n      }\n    }\n\n    // 2. Calculate forces between all pairs of polylines\n    for (let i = 0; i < numPolyLines; i++) {\n      for (let j = i + 1; j < numPolyLines; j++) {\n        const polyLine1 = polyLines[i]\n        const polyLine2 = polyLines[j]\n\n        const points1 = [polyLine1.start, ...polyLine1.mPoints, polyLine1.end]\n        const points2 = [polyLine2.start, ...polyLine2.mPoints, polyLine2.end]\n\n        // Extract segments and vias for easier processing\n        const segments1: Array<{\n          p1: MHPoint\n          p2: MHPoint\n          layer: number\n          p1Idx: number\n          p2Idx: number\n        }> = []\n        const vias1: Array<{\n          point: MHPoint\n          layers: number[]\n          index: number\n        }> = []\n        for (let k = 0; k < points1.length - 1; k++) {\n          segments1.push({\n            p1: points1[k],\n            p2: points1[k + 1],\n            layer: points1[k].z2,\n            p1Idx: k,\n            p2Idx: k + 1,\n          })\n        }\n        points1.forEach((p, k) => {\n          if (p.z1 !== p.z2)\n            vias1.push({ point: p, layers: [p.z1, p.z2], index: k })\n        })\n\n        const segments2: Array<{\n          p1: MHPoint\n          p2: MHPoint\n          layer: number\n          p1Idx: number\n          p2Idx: number\n        }> = []\n        const vias2: Array<{\n          point: MHPoint\n          layers: number[]\n          index: number\n        }> = []\n        for (let k = 0; k < points2.length - 1; k++) {\n          segments2.push({\n            p1: points2[k],\n            p2: points2[k + 1],\n            layer: points2[k].z2,\n            p1Idx: k,\n            p2Idx: k + 1,\n          })\n        }\n        points2.forEach((p, k) => {\n          if (p.z1 !== p.z2)\n            vias2.push({ point: p, layers: [p.z1, p.z2], index: k })\n        })\n\n        // --- Interaction Calculations ---\n\n        // a) Segment <-> Segment\n        for (const seg1 of segments1) {\n          for (const seg2 of segments2) {\n            if (seg1.layer === seg2.layer) {\n              const minDist = segmentToSegmentMinDistance(\n                seg1.p1,\n                seg1.p2,\n                seg2.p1,\n                seg2.p2,\n              )\n              if (minDist < EPSILON) continue // Avoid division by zero if segments overlap significantly\n\n              // Simple repulsive force based on center-to-center distance for now\n              // TODO: A more sophisticated segment-segment force might be needed\n              const center1 = {\n                x: (seg1.p1.x + seg1.p2.x) / 2,\n                y: (seg1.p1.y + seg1.p2.y) / 2,\n              }\n              const center2 = {\n                x: (seg2.p1.x + seg2.p2.x) / 2,\n                y: (seg2.p1.y + seg2.p2.y) / 2,\n              }\n              const dx = center1.x - center2.x\n              const dy = center1.y - center2.y\n              const dSq = dx * dx + dy * dy\n\n              if (dSq > EPSILON) {\n                const dist = Math.sqrt(dSq)\n                // Exponential falloff: force = base * exp(-decay_rate * distance)\n                const forceMag =\n                  SEGMENT_FORCE_MULTIPLIER *\n                  FORCE_MAGNITUDE *\n                  Math.exp(-FORCE_DECAY_RATE * dist)\n                const fx = (dx / dist) * forceMag\n                const fy = (dy / dist) * forceMag\n\n                // Add force contributions: seg2 (j) applies force to seg1 (i), seg1 (i) applies force to seg2 (j)\n                const sourceIdSeg2 = `seg:${j}:${seg2.p1Idx}:${seg2.p2Idx}`\n                const sourceIdSeg1 = `seg:${i}:${seg1.p1Idx}:${seg1.p2Idx}`\n\n                // helper to process one endpoint against the opposite segment\n                const endpointForce = (\n                  ep: MHPoint,\n                  epIdx: number,\n                  otherSeg: {\n                    p1: MHPoint\n                    p2: MHPoint\n                    p1Idx: number\n                    p2Idx: number\n                  },\n                  targetLine: number,\n                  oppLine: number,\n                  srcIdOpp: string,\n                  srcIdThis: string,\n                ) => {\n                  const cp = pointToSegmentClosestPoint(\n                    ep,\n                    otherSeg.p1,\n                    otherSeg.p2,\n                  )\n                  const dx = ep.x - cp.x\n                  const dy = ep.y - cp.y\n                  const dSq = dx * dx + dy * dy\n                  if (dSq <= EPSILON) return\n                  const dist = Math.sqrt(dSq)\n                  const mag =\n                    SEGMENT_FORCE_MULTIPLIER *\n                    FORCE_MAGNITUDE *\n                    Math.exp(-FORCE_DECAY_RATE * dist)\n                  const fx = (dx / dist) * mag\n                  const fy = (dy / dist) * mag\n\n                  // push this endpoint\n                  addForceContribution(targetLine, epIdx, srcIdOpp, fx, fy)\n                  // equal & opposite distributed onto the two endpoints of the other seg\n                  addForceContribution(\n                    oppLine,\n                    otherSeg.p1Idx,\n                    srcIdThis,\n                    -fx / 2,\n                    -fy / 2,\n                  )\n                  addForceContribution(\n                    oppLine,\n                    otherSeg.p2Idx,\n                    srcIdThis,\n                    -fx / 2,\n                    -fy / 2,\n                  )\n                }\n\n                // endpoints of s1 against s2\n                endpointForce(\n                  seg1.p1,\n                  seg1.p1Idx,\n                  seg2,\n                  i,\n                  j,\n                  sourceIdSeg2,\n                  sourceIdSeg1,\n                )\n                endpointForce(\n                  seg1.p2,\n                  seg1.p2Idx,\n                  seg2,\n                  i,\n                  j,\n                  sourceIdSeg2,\n                  sourceIdSeg1,\n                )\n                // endpoints of s2 against s1\n                endpointForce(\n                  seg2.p1,\n                  seg2.p1Idx,\n                  seg1,\n                  j,\n                  i,\n                  sourceIdSeg1,\n                  sourceIdSeg2,\n                )\n                endpointForce(\n                  seg2.p2,\n                  seg2.p2Idx,\n                  seg1,\n                  j,\n                  i,\n                  sourceIdSeg1,\n                  sourceIdSeg2,\n                )\n              }\n            }\n          }\n        }\n\n        // b) Via <-> Segment\n        for (const via1 of vias1) {\n          for (const seg2 of segments2) {\n            if (via1.layers.includes(seg2.layer)) {\n              const closestPointOnSeg = pointToSegmentClosestPoint(\n                via1.point,\n                seg2.p1,\n                seg2.p2,\n              )\n              const dx = via1.point.x - closestPointOnSeg.x\n              const dy = via1.point.y - closestPointOnSeg.y\n              const dSq = dx * dx + dy * dy\n\n              if (dSq > EPSILON) {\n                const dist = Math.sqrt(dSq)\n                let forceMultiplier = VIA_FORCE_MULTIPLIER\n                let effectiveDistance = dist\n\n                if (dist < this.viaDiameter / 2) {\n                  // Point is inside the via radius\n                  forceMultiplier *= INSIDE_VIA_FORCE_MULTIPLIER // Apply stronger force\n                  // Use distance from center directly for decay calculation\n                  effectiveDistance = Math.max(EPSILON, dist)\n                } else {\n                  // Point is outside the via radius\n                  // Calculate distance from the edge\n                  effectiveDistance = Math.max(\n                    EPSILON,\n                    dist - this.viaDiameter / 2,\n                  )\n                }\n\n                // Force applied ONLY to the via (i) by the segment (j) - Exponential falloff\n                const forceMag =\n                  forceMultiplier *\n                  FORCE_MAGNITUDE *\n                  Math.exp(-FORCE_DECAY_RATE * effectiveDistance)\n                const fx_j_on_i = (dx / dist) * forceMag // Direction is still based on center-to-point vector\n                const fy_j_on_i = (dy / dist) * forceMag\n                const sourceIdSeg2 = `seg:${j}:${seg2.p1Idx}:${seg2.p2Idx}`\n                addForceContribution(\n                  i,\n                  via1.index,\n                  sourceIdSeg2,\n                  fx_j_on_i,\n                  fy_j_on_i,\n                )\n                // Force from via1 (i) onto seg2 (j) - Apply opposite force to segment endpoints\n                const sourceIdVia1 = `via:${i}:${via1.index}`\n                addForceContribution(\n                  j,\n                  seg2.p1Idx,\n                  sourceIdVia1,\n                  -fx_j_on_i / 2,\n                  -fy_j_on_i / 2,\n                )\n                addForceContribution(\n                  j,\n                  seg2.p2Idx,\n                  sourceIdVia1,\n                  -fx_j_on_i / 2,\n                  -fy_j_on_i / 2,\n                )\n              }\n            }\n          }\n        }\n        for (const via2 of vias2) {\n          for (const seg1 of segments1) {\n            if (via2.layers.includes(seg1.layer)) {\n              const closestPointOnSeg = pointToSegmentClosestPoint(\n                via2.point,\n                seg1.p1,\n                seg1.p2,\n              )\n              const dx = via2.point.x - closestPointOnSeg.x\n              const dy = via2.point.y - closestPointOnSeg.y\n              const dSq = dx * dx + dy * dy\n\n              if (dSq > EPSILON) {\n                const dist = Math.sqrt(dSq)\n                let forceMultiplier = VIA_FORCE_MULTIPLIER\n                let effectiveDistance = dist\n\n                if (dist < this.viaDiameter / 2) {\n                  // Point is inside the via radius\n                  forceMultiplier *= INSIDE_VIA_FORCE_MULTIPLIER // Apply stronger force\n                  // Use distance from center directly for decay calculation\n                  effectiveDistance = Math.max(EPSILON, dist)\n                } else {\n                  // Point is outside the via radius\n                  // Calculate distance from the edge\n                  effectiveDistance = Math.max(\n                    EPSILON,\n                    dist - this.viaDiameter / 2,\n                  )\n                }\n\n                // Force applied ONLY to the via (j) by the segment (i) - Exponential falloff\n                const forceMag =\n                  forceMultiplier *\n                  FORCE_MAGNITUDE *\n                  Math.exp(-FORCE_DECAY_RATE * effectiveDistance)\n                const fx_i_on_j = (dx / dist) * forceMag // Direction is still based on center-to-point vector\n                const fy_i_on_j = (dy / dist) * forceMag\n                const sourceIdSeg1 = `seg:${i}:${seg1.p1Idx}:${seg1.p2Idx}`\n                addForceContribution(\n                  j,\n                  via2.index,\n                  sourceIdSeg1,\n                  fx_i_on_j,\n                  fy_i_on_j,\n                )\n                // Force from via2 (j) onto seg1 (i) - Apply opposite force to segment endpoints\n                const sourceIdVia2 = `via:${j}:${via2.index}`\n                addForceContribution(\n                  i,\n                  seg1.p1Idx,\n                  sourceIdVia2,\n                  -fx_i_on_j / 2,\n                  -fy_i_on_j / 2,\n                )\n                addForceContribution(\n                  i,\n                  seg1.p2Idx,\n                  sourceIdVia2,\n                  -fx_i_on_j / 2,\n                  -fy_i_on_j / 2,\n                )\n              }\n            }\n          }\n        }\n\n        // c) Via <-> Via\n        for (const via1 of vias1) {\n          for (const via2 of vias2) {\n            const commonLayers = via1.layers.filter((z) =>\n              via2.layers.includes(z),\n            )\n            if (commonLayers.length > 0) {\n              const dx = via1.point.x - via2.point.x\n              const dy = via1.point.y - via2.point.y\n              const dSq = dx * dx + dy * dy\n\n              if (dSq > EPSILON) {\n                const dist = Math.sqrt(dSq)\n                let forceMultiplier = VIA_FORCE_MULTIPLIER\n                let effectiveDistance = dist\n\n                if (dist < this.viaDiameter) {\n                  // Vias overlap\n                  forceMultiplier *= INSIDE_VIA_FORCE_MULTIPLIER // Apply stronger force\n                  // Use center-to-center distance directly for decay calculation\n                  effectiveDistance = Math.max(EPSILON, dist)\n                } else {\n                  // Vias do not overlap\n                  // Calculate distance between edges\n                  effectiveDistance = Math.max(EPSILON, dist - this.viaDiameter)\n                }\n\n                // Exponential falloff\n                const forceMag =\n                  forceMultiplier *\n                  FORCE_MAGNITUDE *\n                  Math.exp(-FORCE_DECAY_RATE * effectiveDistance)\n                const fx_j_on_i = (dx / dist) * forceMag // Force applied by via2 (j) onto via1 (i)\n                const fy_j_on_i = (dy / dist) * forceMag\n                const sourceIdVia2 = `via:${j}:${via2.index}`\n                const sourceIdVia1 = `via:${i}:${via1.index}`\n                addForceContribution(\n                  i,\n                  via1.index,\n                  sourceIdVia2,\n                  fx_j_on_i,\n                  fy_j_on_i,\n                )\n                addForceContribution(\n                  j,\n                  via2.index,\n                  sourceIdVia1,\n                  -fx_j_on_i,\n                  -fy_j_on_i,\n                ) // Force applied by via1 (i) onto via2 (j)\n              }\n            }\n          }\n        }\n      }\n    }\n\n    // 2.5 Calculate forces between vias WITHIN the SAME polyline\n    for (let i = 0; i < numPolyLines; i++) {\n      const polyLine = polyLines[i]\n      const points = [polyLine.start, ...polyLine.mPoints, polyLine.end]\n      const vias: Array<{ point: MHPoint; layers: number[]; index: number }> =\n        []\n      points.forEach((p, k) => {\n        if (p.z1 !== p.z2)\n          vias.push({ point: p, layers: [p.z1, p.z2], index: k })\n      })\n\n      if (vias.length < 2) continue // Need at least two vias to interact\n\n      for (let v1Idx = 0; v1Idx < vias.length; v1Idx++) {\n        for (let v2Idx = v1Idx + 1; v2Idx < vias.length; v2Idx++) {\n          const via1 = vias[v1Idx]\n          const via2 = vias[v2Idx]\n\n          // Vias on the same polyline always interact (repel) regardless of layer\n          const dx = via1.point.x - via2.point.x\n          const dy = via1.point.y - via2.point.y\n          const dSq = dx * dx + dy * dy\n\n          if (dSq > EPSILON) {\n            const dist = Math.sqrt(dSq)\n            let forceMultiplier = VIA_FORCE_MULTIPLIER\n            let effectiveDistance = dist\n\n            if (dist < this.viaDiameter) {\n              // Vias overlap\n              forceMultiplier *= INSIDE_VIA_FORCE_MULTIPLIER // Apply stronger force\n              effectiveDistance = Math.max(EPSILON, dist)\n            } else {\n              // Vias do not overlap\n              effectiveDistance = Math.max(EPSILON, dist - this.viaDiameter)\n            }\n\n            // Exponential falloff\n            const forceMag =\n              forceMultiplier *\n              FORCE_MAGNITUDE *\n              Math.exp(-FORCE_DECAY_RATE * effectiveDistance)\n            const fx_2_on_1 = (dx / dist) * forceMag // Force applied by via2 onto via1\n            const fy_2_on_1 = (dy / dist) * forceMag\n            const sourceIdVia2 = `via:${i}:${via2.index}` // Source is via2 on line i\n            const sourceIdVia1 = `via:${i}:${via1.index}` // Source is via1 on line i\n\n            // Apply force from via2 onto via1 (both on line i)\n            addForceContribution(\n              i,\n              via1.index,\n              sourceIdVia2,\n              fx_2_on_1,\n              fy_2_on_1,\n            )\n            // Apply force from via1 onto via2 (both on line i) - opposite direction\n            addForceContribution(\n              i,\n              via2.index,\n              sourceIdVia1,\n              -fx_2_on_1,\n              -fy_2_on_1,\n            )\n          }\n        }\n      }\n    }\n\n    // 3. Apply forces and create the new neighbor candidate\n    // Deep clone polylines to modify them\n    const newPolyLines = polyLines.map((pl) => ({\n      ...pl,\n      mPoints: pl.mPoints.map((mp) => ({ ...mp })),\n    }))\n\n    let pointsMoved = false\n    for (let i = 0; i < numPolyLines; i++) {\n      for (let k = 0; k < newPolyLines[i].mPoints.length; k++) {\n        const mPoint = newPolyLines[i].mPoints[k]\n        const forceMap = forces[i][k]\n\n        // Calculate the net force by summing contributions\n        const netForce = { fx: 0, fy: 0 }\n        for (const force of forceMap.values()) {\n          netForce.fx += force.fx\n          netForce.fy += force.fy\n        }\n\n        const isVia = mPoint.z1 !== mPoint.z2\n        let newX = mPoint.x + netForce.fx\n        let newY = mPoint.y + netForce.fy\n\n        if (isVia) {\n          // Apply exponential boundary force ONLY to vias\n          const radius = this.viaDiameter / 2\n          let boundaryForceX = 0\n          let boundaryForceY = 0\n\n          // Use a margin appropriate for vias pushing away from the edge\n          const baseForceMargin = this.viaDiameter / 2 // Or perhaps obstacleMargin\n          const forceMargin = baseForceMargin + this.BOUNDARY_PADDING\n\n          const minX = this.bounds.minX + forceMargin\n          const maxX = this.bounds.maxX - forceMargin\n          const minY = this.bounds.minY + forceMargin\n          const maxY = this.bounds.maxY - forceMargin\n\n          const distOutsideMinX = minX + radius - mPoint.x // How far the via *center* is past the allowed edge\n          const distOutsideMaxX = mPoint.x - (maxX - radius)\n          const distOutsideMinY = minY + radius - mPoint.y\n          const distOutsideMaxY = mPoint.y - (maxY - radius)\n\n          if (distOutsideMinX > 0) {\n            boundaryForceX =\n              BOUNDARY_FORCE_STRENGTH *\n              (Math.exp(distOutsideMinX / (this.obstacleMargin * 2)) - 1)\n          } else if (distOutsideMaxX > 0) {\n            boundaryForceX =\n              -BOUNDARY_FORCE_STRENGTH *\n              (Math.exp(distOutsideMaxX / (this.obstacleMargin * 2)) - 1)\n          }\n\n          if (distOutsideMinY > 0) {\n            boundaryForceY =\n              BOUNDARY_FORCE_STRENGTH *\n              (Math.exp(distOutsideMinY / (this.obstacleMargin * 2)) - 1)\n          } else if (distOutsideMaxY > 0) {\n            boundaryForceY =\n              -BOUNDARY_FORCE_STRENGTH *\n              (Math.exp(distOutsideMaxY / (this.obstacleMargin * 2)) - 1)\n          }\n\n          // Add boundary force to net force and recalculate potential position\n          netForce.fx += boundaryForceX\n          netForce.fy += boundaryForceY\n          newX = mPoint.x + netForce.fx\n          newY = mPoint.y + netForce.fy\n\n          // Optional: Clamp via position as a hard stop if force isn't enough?\n          // newX = Math.max(this.bounds.minX + radius, Math.min(this.bounds.maxX - radius, newX));\n          // newY = Math.max(this.bounds.minY + radius, Math.min(this.bounds.maxY - radius, newY));\n        } else {\n          // For regular points, CLAMP position to bounds + traceWidth/2 padding\n          const basePadding = this.traceWidth / 2\n          const padding = basePadding + this.BOUNDARY_PADDING\n          newX = Math.max(\n            this.bounds.minX + padding,\n            Math.min(this.bounds.maxX - padding, newX),\n          )\n          newY = Math.max(\n            this.bounds.minY + padding,\n            Math.min(this.bounds.maxY - padding, newY),\n          )\n        }\n\n        // Dampen force? Add friction? (Optional) - Applied before clamping/boundary force\n\n        if (\n          Math.abs(netForce.fx) < EPSILON &&\n          Math.abs(netForce.fy) < EPSILON\n        ) {\n          continue // No significant net force, skip update\n        }\n\n        // Limit maximum movement per step? (Optional)\n        // const maxMove = this.cellSize;\n        // const forceMag = Math.sqrt(netForce.fx * netForce.fx + netForce.fy * netForce.fy);\n        // Update position if moved significantly from original position\n        // Use the calculated (and potentially clamped/boundary-forced) newX, newY\n        if (\n          Math.abs(mPoint.x - newX) > EPSILON ||\n          Math.abs(mPoint.y - newY) > EPSILON\n        ) {\n          mPoint.x = newX\n          mPoint.y = newY\n          pointsMoved = true\n        }\n      }\n    }\n\n    // If no points moved significantly, don't generate a redundant neighbor\n    if (!pointsMoved) {\n      // console.log(\"No points moved significantly, skipping neighbor generation.\");\n      return []\n    }\n\n    const minGaps = this.computeMinGapBtwPolyLines(newPolyLines)\n    const g = this.computeG(newPolyLines, candidate) // G might represent something else now, e.g., total displacement or just step count\n    const h = this.computeH({ minGaps, forces })\n    const newNeighbor: Candidate = {\n      polyLines: newPolyLines,\n      g,\n      h,\n      // The rounding of g is for fun animations (prevents flashing btw multiple candidate paths)\n      f: Math.round(g * 5) / 5 + h,\n      minGaps,\n      forces: forces, // Store the calculated forces\n      viaCount: candidate.viaCount,\n    }\n\n    // console.log(`Generated neighbor ${neighborHash.substring(0, 10)}... f=${newNeighbor.f.toFixed(3)}`);\n\n    return [newNeighbor]\n  }\n\n  checkIfSolved(candidate: Pick<Candidate, \"polyLines\" | \"minGaps\">) {\n    const minGapsToOtherConnectionsValid = candidate.minGaps.every(\n      (minGap) => minGap >= this.obstacleMargin,\n    )\n\n    const allPointsWithinBounds = candidate.polyLines.every((polyLine) => {\n      return polyLine.mPoints.every((mPoint) => {\n        const basePadding =\n          mPoint.z1 !== mPoint.z2 ? this.viaDiameter / 2 : this.traceWidth / 2\n        const padding = basePadding + this.BOUNDARY_PADDING\n        return withinBounds(mPoint, this.bounds, padding)\n      })\n    })\n\n    return minGapsToOtherConnectionsValid && allPointsWithinBounds\n  }\n\n  // ------------------------------------------------------------------\n  //  Try accepting the best candidate even if normal solving failed.\n  // ------------------------------------------------------------------\n  tryFinalAcceptance() {\n    const minGapTarget =\n      this.hyperParameters?.MINIMUM_FINAL_ACCEPTANCE_GAP ?? undefined\n    if (\n      minGapTarget === undefined ||\n      this.lastCandidate === null ||\n      this.lastCandidate.minGaps.length === 0\n    )\n      return\n\n    // take the smallest layer-to-layer gap of the last explored candidate\n    const minGapAchieved = Math.min(...this.lastCandidate.minGaps)\n    if (minGapAchieved >= minGapTarget) {\n      // Accept this imperfect but good-enough solution\n      this.solved = true\n      this._setSolvedRoutes()\n      return\n    }\n    return\n  }\n\n  _step() {\n    if (this.phase === \"setup\") {\n      this.setupInitialPolyLines()\n      this.phase = \"solving\"\n      return\n    }\n    const currentCandidate = this.candidates.shift()\n    if (!currentCandidate) {\n      this.tryFinalAcceptance()\n      if (this.solved) return\n      this.failed = true\n      this.error = \"No candidates left\"\n      return\n    }\n    this.lastCandidate = currentCandidate\n    if (this.checkIfSolved(currentCandidate)) {\n      this.solved = true\n      this._setSolvedRoutes()\n      return\n    }\n    if (!currentCandidate) {\n      this.failed = true\n      return\n    }\n    const neighbors = this.getNeighbors(currentCandidate)\n    for (const neighbor of neighbors) {\n      this.insertCandidate(neighbor)\n    }\n  }\n\n  visualize(): GraphicsObject {\n    const graphicsObject: Required<GraphicsObject> = {\n      points: [],\n      lines: [],\n      rects: [],\n      circles: [],\n      coordinateSystem: \"cartesian\",\n      title: \"MultiHeadPolyLineIntraNodeSolver Visualization\",\n    }\n\n    // Draw node bounds\n    graphicsObject.lines.push({\n      points: [\n        { x: this.bounds.minX, y: this.bounds.minY },\n        { x: this.bounds.maxX, y: this.bounds.minY },\n        { x: this.bounds.maxX, y: this.bounds.maxY },\n        { x: this.bounds.minX, y: this.bounds.maxY },\n        { x: this.bounds.minX, y: this.bounds.minY },\n      ],\n      strokeColor: \"gray\",\n    })\n\n    // Visualize the polylines from the last evaluated candidate (or initial if none evaluated)\n    const candidateToVisualize = this.lastCandidate ?? this.candidates[0]\n\n    // Add indicator for closed face\n    if (candidateToVisualize?.hasClosedSameLayerFace) {\n      const rectWidth = (this.bounds.maxX - this.bounds.minX) * 0.1\n      const rectHeight = (this.bounds.maxY - this.bounds.minY) * 0.1\n      graphicsObject.rects.push({\n        center: {\n          x: this.bounds.maxX + rectWidth * 0.6, // Position slightly outside top-right\n          y: this.bounds.maxY + rectHeight * 0.6,\n        },\n        width: rectWidth,\n        height: rectHeight,\n        fill: \"red\",\n        label: \"HAS CLOSED FACE\",\n      })\n    }\n\n    // Draw input port points\n    for (const pt of this.nodeWithPortPoints.portPoints) {\n      graphicsObject.points.push({\n        x: pt.x,\n        y: pt.y,\n        // Assuming port points represent a single layer entry/exit, use z or default to 0\n        label: `${pt.connectionName} (Port z=${pt.z ?? 0})`,\n        color: this.colorMap[pt.connectionName] ?? \"blue\",\n      })\n    }\n\n    // Visualize the polylines (if a candidate exists)\n    if (candidateToVisualize) {\n      candidateToVisualize.polyLines.forEach((polyLine, polyLineIndex) => {\n        const color = this.colorMap[polyLine.connectionName] ?? \"purple\"\n        const pointsInPolyline = [\n          polyLine.start,\n          ...polyLine.mPoints,\n          polyLine.end,\n        ]\n\n        // Draw segments of the polyline\n        for (let i = 0; i < pointsInPolyline.length - 1; i++) {\n          const p1 = pointsInPolyline[i] // Point where segment starts (or via ends)\n          const p2 = pointsInPolyline[i + 1] // Point where segment ends (or via starts)\n\n          // A segment exists between p1 and p2 on layer p1.z2 (layer after p1's potential via)\n          // which should be the same as p2.z1 (layer before p2's potential via)\n          // If p1.z2 !== p2.z1, something is wrong in the data structure.\n          const segmentLayer = p1.z2\n          const isLayer0 = segmentLayer === 0\n          const segmentColor = isLayer0 ? color : safeTransparentize(color, 0.5)\n\n          graphicsObject.lines.push({\n            points: [p1, p2],\n            strokeColor: segmentColor,\n            strokeWidth: this.traceWidth, // TODO: Use actual trace thickness from HighDensityRoute?\n            strokeDash: !isLayer0 ? [0.15, 0.15] : undefined, // Dashed for layers > 0\n            label: `${polyLine.connectionName} segment (z=${segmentLayer})`,\n          })\n        }\n\n        // Draw points (start, mPoints, end) and Vias\n        pointsInPolyline.forEach((point, pointIndex) => {\n          const isVia = point.z1 !== point.z2\n          const pointLayer = point.z1 // Layer before potential via\n          const isMPoint =\n            pointIndex > 0 && pointIndex < pointsInPolyline.length - 1\n\n          let label = \"\"\n          let forceLabel = \"\"\n\n          if (isMPoint) {\n            const mPointIndex = pointIndex - 1\n            const forceMap =\n              candidateToVisualize.forces?.[polyLineIndex]?.[mPointIndex]\n\n            if (forceMap && forceMap.size > 0) {\n              const netForce = { fx: 0, fy: 0 }\n              forceMap.forEach((force, sourceId) => {\n                netForce.fx += force.fx\n                netForce.fy += force.fy\n\n                if (Math.abs(force.fx) > 1e-6 || Math.abs(force.fy) > 1e-6) {\n                  const parts = sourceId.split(\":\")\n                  const sourceType = parts[0] // \"via\" or \"seg\"\n                  const applyingLineIndex = parseInt(parts[1], 10)\n                  const applyingPolyline =\n                    candidateToVisualize.polyLines[applyingLineIndex]\n                  const applyingColor =\n                    this.colorMap[applyingPolyline.connectionName] ?? \"gray\"\n                  const forceScale = 20 // Adjust scale for visibility\n                  const forceEndPoint = {\n                    x: point.x + force.fx * forceScale,\n                    y: point.y + force.fy * forceScale,\n                  }\n\n                  let sourceLabel = applyingPolyline.connectionName\n                  if (sourceType === \"via\") {\n                    const pointIdx = parseInt(parts[2], 10)\n                    sourceLabel += ` Via ${pointIdx}`\n                  } else if (sourceType === \"seg\") {\n                    const p1Idx = parseInt(parts[2], 10)\n                    const p2Idx = parseInt(parts[3], 10)\n                    sourceLabel += ` Seg ${p1Idx}-${p2Idx}`\n                  }\n\n                  graphicsObject.lines.push({\n                    points: [point, forceEndPoint],\n                    strokeColor: applyingColor, // Color by applying polyline\n                    strokeWidth: 0.02,\n                    strokeDash: \"2,2\", // Dashed line for force\n                    label: `Force by ${sourceLabel} on ${polyLine.connectionName} mPoint ${mPointIndex}`,\n                  })\n                }\n              })\n              // Update the label to show the net force\n              if (\n                Math.abs(netForce.fx) > 1e-6 ||\n                Math.abs(netForce.fy) > 1e-6\n              ) {\n                forceLabel = `\\nNet Force: (${netForce.fx.toFixed(3)}, ${netForce.fy.toFixed(3)})`\n              }\n            }\n          }\n\n          if (isVia) {\n            // Draw Via\n            label = `Via (${polyLine.connectionName} z=${point.z1} -> z=${point.z2})${forceLabel}`\n            graphicsObject.circles.push({\n              center: point,\n              radius: this.viaDiameter / 2,\n              fill: safeTransparentize(color, 0.5), // Distinct Via color\n              label: label,\n            })\n          } else {\n            // Draw regular point (only draw mPoints for clarity, start/end are ports)\n            if (isMPoint) {\n              const isLayer0 = pointLayer === 0\n              // Regular mPoint (not a via)\n              // const isLayer0 = pointLayer === 0 // Removed duplicate declaration\n              const pointColor = isLayer0\n                ? color\n                : safeTransparentize(color, 0.5)\n              label = `mPoint (${polyLine.connectionName} z=${pointLayer})${forceLabel}`\n\n              // Draw the circle for the mPoint itself\n              graphicsObject.circles.push({\n                center: point,\n                radius: this.cellSize / 8, // Smaller circle for mPoints\n                fill: pointColor,\n                label: label,\n              })\n            }\n            // Start/End points are visualized by the port points loop earlier\n          }\n        })\n      })\n    }\n\n    return graphicsObject\n  }\n\n  _setSolvedRoutes() {\n    if (!this.solved || !this.lastCandidate) {\n      return []\n    }\n\n    const solvedRoutes: HighDensityIntraNodeRoute[] = []\n\n    for (const polyLine of this.lastCandidate.polyLines) {\n      const routePoints: Array<{ x: number; y: number; z: number }> = []\n      const vias: Array<{ x: number; y: number }> = []\n      const fullPath = [polyLine.start, ...polyLine.mPoints, polyLine.end]\n\n      for (let i = 0; i < fullPath.length; i++) {\n        const currentPoint = fullPath[i]\n\n        // Add the point on its starting layer (z1)\n        routePoints.push({\n          x: currentPoint.x,\n          y: currentPoint.y,\n          z: currentPoint.z1,\n        })\n\n        // If it's a via (layer transition)\n        if (currentPoint.z1 !== currentPoint.z2) {\n          // Add the via location\n          vias.push({ x: currentPoint.x, y: currentPoint.y })\n          // Add the point again on the ending layer (z2)\n          // This creates the vertical segment in the route representation\n          routePoints.push({\n            x: currentPoint.x,\n            y: currentPoint.y,\n            z: currentPoint.z2,\n          })\n        }\n      }\n\n      // TODO: Optimize the route points (remove collinear points on the same layer)\n\n      solvedRoutes.push({\n        connectionName: polyLine.connectionName,\n        traceThickness: this.traceWidth,\n        viaDiameter: this.viaDiameter,\n        route: routePoints,\n        vias: vias,\n      })\n    }\n\n    this.solvedRoutes = solvedRoutes\n  }\n}\n","import {\n  segmentToSegmentMinDistance,\n  pointToSegmentClosestPoint,\n} from \"@tscircuit/math-utils\"\nimport { PolyLine2, MHPoint2, Candidate2 } from \"./types2\"\nimport { MultiHeadPolyLineIntraNodeSolver } from \"./MultiHeadPolyLineIntraNodeSolver\"\n\nexport class MultiHeadPolyLineIntraNodeSolver2 extends MultiHeadPolyLineIntraNodeSolver {\n  computeG(polyLines: any, candidate: any) {\n    return candidate.g + 0.000005 + candidate.viaCount * 0.000005 * 100\n  }\n\n  /**\n   * We don't use the heuristic because we don't queue new candidates with this\n   * solver\n   */\n  computeH(candidate: any) {\n    const { minGaps } = candidate\n    let collisionScore = 0\n    for (const gap of minGaps) {\n      if (gap < 0) {\n        collisionScore += this.obstacleMargin\n      }\n      if (gap < this.obstacleMargin) {\n        collisionScore += this.obstacleMargin - gap\n      }\n    }\n    return collisionScore * 0.011 // 100 iterations @ hdpolyline09_optimized\n  }\n\n  _step() {\n    if (this.phase === \"setup\") {\n      this.setupInitialPolyLines()\n      this.phase = \"solving\"\n      return\n    }\n\n    const currentCandidate = this.candidates.shift()\n    if (!currentCandidate) {\n      this.tryFinalAcceptance()\n      if (this.solved) return\n      this.failed = true\n      return\n    }\n    this.lastCandidate = currentCandidate\n\n    if (this.checkIfSolved(currentCandidate)) {\n      this.solved = true\n      this._setSolvedRoutes()\n      return\n    }\n\n    // Apply forces iteratively to the current candidate\n    let lastStepMoved = false\n    let magForceApplied = 0\n    // First run we just do a single step to get the force applied for h\n    // computation\n    const stepsToRun = currentCandidate.magForceApplied === undefined ? 1 : 10\n    for (let step = 0; step < stepsToRun; step++) {\n      const result = this.applyForcesToPolyLines(currentCandidate.polyLines)\n      magForceApplied += result.magForceApplied\n      lastStepMoved = result.lastStepMoved\n      if (!result.lastStepMoved) break\n    }\n    currentCandidate.magForceApplied = magForceApplied\n\n    currentCandidate.minGaps = this.computeMinGapBtwPolyLines(\n      currentCandidate.polyLines,\n    )\n\n    if (this.checkIfSolved(currentCandidate)) {\n      this.solved = true\n      this._setSolvedRoutes()\n      return\n    }\n\n    currentCandidate.g = this.computeG(\n      currentCandidate.polyLines,\n      currentCandidate,\n    )\n    currentCandidate.h = this.computeH(currentCandidate)\n    currentCandidate.f = currentCandidate.g + currentCandidate.h\n\n    if (lastStepMoved) {\n      this.insertCandidate(currentCandidate)\n    }\n  }\n\n  /**\n   * Applies repulsive forces between polylines (segments and vias) and boundary forces\n   * directly modifying the input polyLines array.\n   * Returns true if any mPoint was moved, false otherwise.\n   */\n  applyForcesToPolyLines(polyLines: PolyLine2[]): {\n    lastStepMoved: boolean\n    magForceApplied: number\n  } {\n    let magForceApplied = 0\n    const numPolyLines = polyLines.length\n    const FORCE_MAGNITUDE = 0.02 // Tunable parameter for force strength\n    const VIA_FORCE_MULTIPLIER = 2.0 // Vias push harder\n    const INSIDE_VIA_FORCE_MULTIPLIER = 4.0 // Extra multiplier when inside a via\n    const SEGMENT_FORCE_MULTIPLIER = 1.0\n    // const FORCE_DECAY_RATE = 1.0 / this.cellSize // Controls how quickly force falls off with distance (adjust as needed)\n    const FORCE_DECAY_RATE = 6\n    const BOUNDARY_FORCE_STRENGTH = 0.008 // How strongly points are pushed back into bounds\n    const EPSILON = 1e-6 // To avoid division by zero\n\n    // 1. Initialize net forces structure: netForces[lineIdx][mPointIdx] = {fx, fy}\n    const netForces: Array<Array<{ fx: number; fy: number }>> = Array.from(\n      { length: numPolyLines },\n      (_, i) =>\n        Array.from({ length: polyLines[i].mPoints.length }, () => ({\n          fx: 0,\n          fy: 0,\n        })),\n    )\n\n    // Helper to add force directly to the netForces array for a given mPoint index\n    const addNetForce = (\n      lineIndex: number,\n      pointIndexInFullPath: number, // Index in [start, ...mPoints, end]\n      fx: number,\n      fy: number,\n    ) => {\n      // Only apply force if the target point is an mPoint (not start or end)\n      if (\n        pointIndexInFullPath > 0 &&\n        pointIndexInFullPath < polyLines[lineIndex].mPoints.length + 1\n      ) {\n        const mPointIndex = pointIndexInFullPath - 1\n        netForces[lineIndex][mPointIndex].fx += fx\n        netForces[lineIndex][mPointIndex].fy += fy\n      }\n    }\n\n    // 2. Calculate forces between all pairs of polylines\n\n    // Helper to process one endpoint against the opposite segment\n    const endpointForce = (\n      ep: MHPoint2,\n      epIdx: number,\n      otherSeg: { p1: MHPoint2; p2: MHPoint2; p1Idx: number; p2Idx: number },\n      targetLine: number,\n      oppLine: number,\n      // srcIdOpp: string, // Not needed with addNetForce\n      // srcIdThis: string, // Not needed with addNetForce\n    ) => {\n      const cp = pointToSegmentClosestPoint(ep, otherSeg.p1, otherSeg.p2)\n      const dx = ep.x - cp.x\n      const dy = ep.y - cp.y\n      const dSq = dx * dx + dy * dy\n      if (dSq <= EPSILON) return\n      const dist = Math.sqrt(dSq)\n      const mag =\n        SEGMENT_FORCE_MULTIPLIER *\n        FORCE_MAGNITUDE *\n        Math.exp(-FORCE_DECAY_RATE * dist)\n      const fx = (dx / dist) * mag\n      const fy = (dy / dist) * mag\n\n      // push this endpoint\n      addNetForce(targetLine, epIdx, fx, fy)\n      // equal & opposite distributed onto the two endpoints of the other seg\n      addNetForce(oppLine, otherSeg.p1Idx, -fx / 2, -fy / 2)\n      addNetForce(oppLine, otherSeg.p2Idx, -fx / 2, -fy / 2)\n    }\n\n    for (let i = 0; i < numPolyLines; i++) {\n      for (let j = i + 1; j < numPolyLines; j++) {\n        const polyLine1 = polyLines[i]\n        const polyLine2 = polyLines[j]\n\n        const points1 = [polyLine1.start, ...polyLine1.mPoints, polyLine1.end]\n        const points2 = [polyLine2.start, ...polyLine2.mPoints, polyLine2.end]\n\n        // Extract segments and vias for easier processing\n        const segments1: Array<{\n          p1: MHPoint2\n          p2: MHPoint2\n          layer: number\n          p1Idx: number\n          p2Idx: number\n        }> = []\n        const vias1: Array<{\n          point: MHPoint2\n          layers: number[]\n          index: number\n        }> = []\n        for (let k = 0; k < points1.length - 1; k++) {\n          segments1.push({\n            p1: points1[k],\n            p2: points1[k + 1],\n            layer: points1[k].z2,\n            p1Idx: k,\n            p2Idx: k + 1,\n          })\n        }\n        points1.forEach((p, k) => {\n          if (p.z1 !== p.z2)\n            vias1.push({ point: p, layers: [p.z1, p.z2], index: k })\n        })\n\n        const segments2: Array<{\n          p1: MHPoint2\n          p2: MHPoint2\n          layer: number\n          p1Idx: number\n          p2Idx: number\n        }> = []\n        const vias2: Array<{\n          point: MHPoint2\n          layers: number[]\n          index: number\n        }> = []\n        for (let k = 0; k < points2.length - 1; k++) {\n          segments2.push({\n            p1: points2[k],\n            p2: points2[k + 1],\n            layer: points2[k].z2,\n            p1Idx: k,\n            p2Idx: k + 1,\n          })\n        }\n        points2.forEach((p, k) => {\n          if (p.z1 !== p.z2)\n            vias2.push({ point: p, layers: [p.z1, p.z2], index: k })\n        })\n\n        // --- Interaction Calculations ---\n\n        // a) Segment <-> Segment\n        for (const seg1 of segments1) {\n          for (const seg2 of segments2) {\n            if (seg1.layer === seg2.layer) {\n              const minDist = segmentToSegmentMinDistance(\n                seg1.p1,\n                seg1.p2,\n                seg2.p1,\n                seg2.p2,\n              )\n              // endpoints of s1 against s2\n              endpointForce(seg1.p1, seg1.p1Idx, seg2, i, j)\n              endpointForce(seg1.p2, seg1.p2Idx, seg2, i, j)\n              // endpoints of s2 against s1\n              endpointForce(seg2.p1, seg2.p1Idx, seg1, j, i)\n              endpointForce(seg2.p2, seg2.p2Idx, seg1, j, i)\n            }\n          }\n        }\n\n        // b) Via <-> Segment\n        for (const via1 of vias1) {\n          for (const seg2 of segments2) {\n            if (via1.layers.includes(seg2.layer)) {\n              const closestPointOnSeg = pointToSegmentClosestPoint(\n                via1.point,\n                seg2.p1,\n                seg2.p2,\n              )\n              const dx = via1.point.x - closestPointOnSeg.x\n              const dy = via1.point.y - closestPointOnSeg.y\n              const dSq = dx * dx + dy * dy\n\n              if (dSq > EPSILON) {\n                const dist = Math.sqrt(dSq)\n                let forceMultiplier = VIA_FORCE_MULTIPLIER\n                let effectiveDistance = dist\n\n                if (dist < this.viaDiameter / 2) {\n                  // Point is inside the via radius\n                  forceMultiplier *= INSIDE_VIA_FORCE_MULTIPLIER // Apply stronger force\n                  // Use distance from center directly for decay calculation\n                  effectiveDistance = Math.max(EPSILON, dist)\n                } else {\n                  // Point is outside the via radius\n                  // Calculate distance from the edge\n                  effectiveDistance = Math.max(\n                    EPSILON,\n                    dist - this.viaDiameter / 2,\n                  )\n                }\n\n                // Force applied ONLY to the via (i) by the segment (j) - Exponential falloff\n                const forceMag =\n                  forceMultiplier *\n                  FORCE_MAGNITUDE *\n                  Math.exp(-FORCE_DECAY_RATE * effectiveDistance)\n                const fx_j_on_i = (dx / dist) * forceMag // Direction is still based on center-to-point vector\n                const fy_j_on_i = (dy / dist) * forceMag\n\n                // Force applied ONLY to the via (i) by the segment (j)\n                addNetForce(i, via1.index, fx_j_on_i, fy_j_on_i)\n\n                // Force from via1 (i) onto seg2 (j) - Apply opposite force to segment endpoints\n                addNetForce(j, seg2.p1Idx, -fx_j_on_i / 2, -fy_j_on_i / 2)\n                addNetForce(j, seg2.p2Idx, -fx_j_on_i / 2, -fy_j_on_i / 2)\n              }\n            }\n          }\n        }\n        for (const via2 of vias2) {\n          for (const seg1 of segments1) {\n            if (via2.layers.includes(seg1.layer)) {\n              const closestPointOnSeg = pointToSegmentClosestPoint(\n                via2.point,\n                seg1.p1,\n                seg1.p2,\n              )\n              const dx = via2.point.x - closestPointOnSeg.x\n              const dy = via2.point.y - closestPointOnSeg.y\n              const dSq = dx * dx + dy * dy\n\n              if (dSq > EPSILON) {\n                const dist = Math.sqrt(dSq)\n                let forceMultiplier = VIA_FORCE_MULTIPLIER\n                let effectiveDistance = dist\n\n                if (dist < this.viaDiameter / 2) {\n                  // Point is inside the via radius\n                  forceMultiplier *= INSIDE_VIA_FORCE_MULTIPLIER // Apply stronger force\n                  // Use distance from center directly for decay calculation\n                  effectiveDistance = Math.max(EPSILON, dist)\n                } else {\n                  // Point is outside the via radius\n                  // Calculate distance from the edge\n                  effectiveDistance = Math.max(\n                    EPSILON,\n                    dist - this.viaDiameter / 2,\n                  )\n                }\n\n                // Force applied ONLY to the via (j) by the segment (i) - Exponential falloff\n                const forceMag =\n                  forceMultiplier *\n                  FORCE_MAGNITUDE *\n                  Math.exp(-FORCE_DECAY_RATE * effectiveDistance)\n                const fx_i_on_j = (dx / dist) * forceMag // Direction is still based on center-to-point vector\n                const fy_i_on_j = (dy / dist) * forceMag\n\n                // Force applied ONLY to the via (j) by the segment (i)\n                addNetForce(j, via2.index, fx_i_on_j, fy_i_on_j)\n\n                // Force from via2 (j) onto seg1 (i) - Apply opposite force to segment endpoints\n                addNetForce(i, seg1.p1Idx, -fx_i_on_j / 2, -fy_i_on_j / 2)\n                addNetForce(i, seg1.p2Idx, -fx_i_on_j / 2, -fy_i_on_j / 2)\n              }\n            }\n          }\n        }\n\n        // c) Via <-> Via\n        for (const via1 of vias1) {\n          for (const via2 of vias2) {\n            const commonLayers = via1.layers.filter((z) =>\n              via2.layers.includes(z),\n            )\n            if (commonLayers.length > 0) {\n              const dx = via1.point.x - via2.point.x\n              const dy = via1.point.y - via2.point.y\n              const dSq = dx * dx + dy * dy\n\n              if (dSq > EPSILON) {\n                const dist = Math.sqrt(dSq)\n                let forceMultiplier = VIA_FORCE_MULTIPLIER\n                let effectiveDistance = dist\n\n                if (dist < this.viaDiameter) {\n                  // Vias overlap\n                  forceMultiplier *= INSIDE_VIA_FORCE_MULTIPLIER // Apply stronger force\n                  // Use center-to-center distance directly for decay calculation\n                  effectiveDistance = Math.max(EPSILON, dist)\n                } else {\n                  // Vias do not overlap\n                  // Calculate distance between edges\n                  effectiveDistance = Math.max(EPSILON, dist - this.viaDiameter)\n                }\n\n                // Exponential falloff\n                const forceMag =\n                  forceMultiplier *\n                  FORCE_MAGNITUDE *\n                  Math.exp(-FORCE_DECAY_RATE * effectiveDistance)\n                const fx_j_on_i = (dx / dist) * forceMag // Force applied by via2 (j) onto via1 (i)\n                const fy_j_on_i = (dy / dist) * forceMag\n\n                // Apply force from via2 (j) onto via1 (i)\n                addNetForce(i, via1.index, fx_j_on_i, fy_j_on_i)\n                // Apply force from via1 (i) onto via2 (j)\n                addNetForce(j, via2.index, -fx_j_on_i, -fy_j_on_i)\n              }\n            }\n          }\n        }\n      }\n    }\n\n    // 2.5 Calculate forces between vias WITHIN the SAME polyline\n    for (let i = 0; i < numPolyLines; i++) {\n      const polyLine = polyLines[i]\n      const points = [polyLine.start, ...polyLine.mPoints, polyLine.end]\n      const vias: Array<{ point: MHPoint2; layers: number[]; index: number }> =\n        []\n      points.forEach((p, k) => {\n        if (p.z1 !== p.z2)\n          vias.push({ point: p, layers: [p.z1, p.z2], index: k })\n      })\n\n      if (vias.length < 2) continue // Need at least two vias to interact\n\n      for (let v1Idx = 0; v1Idx < vias.length; v1Idx++) {\n        for (let v2Idx = v1Idx + 1; v2Idx < vias.length; v2Idx++) {\n          const via1 = vias[v1Idx]\n          const via2 = vias[v2Idx]\n\n          // Vias on the same polyline always interact (repel) regardless of layer\n          const dx = via1.point.x - via2.point.x\n          const dy = via1.point.y - via2.point.y\n          const dSq = dx * dx + dy * dy\n\n          if (dSq > EPSILON) {\n            const dist = Math.sqrt(dSq)\n            let forceMultiplier = VIA_FORCE_MULTIPLIER\n            let effectiveDistance = dist\n\n            if (dist < this.viaDiameter) {\n              // Vias overlap\n              forceMultiplier *= INSIDE_VIA_FORCE_MULTIPLIER // Apply stronger force\n              effectiveDistance = Math.max(EPSILON, dist)\n            } else {\n              // Vias do not overlap\n              effectiveDistance = Math.max(EPSILON, dist - this.viaDiameter)\n            }\n\n            // Exponential falloff\n            const forceMag =\n              forceMultiplier *\n              FORCE_MAGNITUDE *\n              Math.exp(-FORCE_DECAY_RATE * effectiveDistance)\n            const fx_2_on_1 = (dx / dist) * forceMag // Force applied by via2 onto via1\n            const fy_2_on_1 = (dy / dist) * forceMag\n\n            // Apply force from via2 onto via1 (both on line i)\n            addNetForce(i, via1.index, fx_2_on_1, fy_2_on_1)\n            // Apply force from via1 onto via2 (both on line i) - opposite direction\n            addNetForce(i, via2.index, -fx_2_on_1, -fy_2_on_1)\n          }\n        }\n      }\n    }\n\n    // 3. Apply forces directly to the input polyLines\n    let pointsMoved = false\n    for (let i = 0; i < numPolyLines; i++) {\n      for (let k = 0; k < polyLines[i].mPoints.length; k++) {\n        const mPoint = polyLines[i].mPoints[k]\n        const netForce = netForces[i][k] // Get the pre-calculated net force\n\n        // No need to sum contributions here anymore\n\n        const isVia = mPoint.z1 !== mPoint.z2\n        let currentForceX = netForce.fx // Start with the repulsive/attractive force\n        let currentForceY = netForce.fy\n        let newX = mPoint.x + currentForceX\n        let newY = mPoint.y + currentForceY\n\n        if (isVia) {\n          // Apply exponential boundary force ONLY to vias\n          const radius = this.viaDiameter / 2\n          let boundaryForceX = 0\n          let boundaryForceY = 0\n\n          // Use a margin appropriate for vias pushing away from the edge\n          const baseForceMargin = this.viaDiameter / 2\n          const forceMargin = baseForceMargin + this.BOUNDARY_PADDING\n\n          const minX = this.bounds.minX + forceMargin\n          const maxX = this.bounds.maxX - forceMargin\n          const minY = this.bounds.minY + forceMargin\n          const maxY = this.bounds.maxY - forceMargin\n\n          const distOutsideMinX = minX + radius - mPoint.x // How far the via *center* is past the allowed edge\n          const distOutsideMaxX = mPoint.x - (maxX - radius)\n          const distOutsideMinY = minY + radius - mPoint.y\n          const distOutsideMaxY = mPoint.y - (maxY - radius)\n\n          if (distOutsideMinX > 0) {\n            boundaryForceX =\n              BOUNDARY_FORCE_STRENGTH *\n              (Math.exp(distOutsideMinX / (this.obstacleMargin * 2)) - 1)\n          } else if (distOutsideMaxX > 0) {\n            boundaryForceX =\n              -BOUNDARY_FORCE_STRENGTH *\n              (Math.exp(distOutsideMaxX / (this.obstacleMargin * 2)) - 1)\n          }\n\n          if (distOutsideMinY > 0) {\n            boundaryForceY =\n              BOUNDARY_FORCE_STRENGTH *\n              (Math.exp(distOutsideMinY / (this.obstacleMargin * 2)) - 1)\n          } else if (distOutsideMaxY > 0) {\n            boundaryForceY =\n              -BOUNDARY_FORCE_STRENGTH *\n              (Math.exp(distOutsideMaxY / (this.obstacleMargin * 2)) - 1)\n          }\n\n          // Add boundary force to the current force being considered for this step\n          currentForceX += boundaryForceX\n          currentForceY += boundaryForceY\n          newX = mPoint.x + currentForceX\n          newY = mPoint.y + currentForceY\n\n          // Optional: Clamp via position as a hard stop if force isn't enough?\n          // newX = Math.max(this.bounds.minX + radius, Math.min(this.bounds.maxX - radius, newX));\n          // newY = Math.max(this.bounds.minY + radius, Math.min(this.bounds.maxY - radius, newY));\n        } else {\n          // For regular points, CLAMP position to bounds + traceWidth/2 padding\n          const basePadding = this.traceWidth / 2\n          const padding = basePadding + this.BOUNDARY_PADDING\n          newX = Math.max(\n            this.bounds.minX + padding,\n            Math.min(this.bounds.maxX - padding, newX),\n          )\n          newY = Math.max(\n            this.bounds.minY + padding,\n            Math.min(this.bounds.maxY - padding, newY),\n          )\n        }\n\n        // Dampen force? Add friction? (Optional) - Applied before clamping/boundary force\n\n        // Check if the *total applied force* (including boundary) is significant\n        if (\n          Math.abs(currentForceX) < EPSILON &&\n          Math.abs(currentForceY) < EPSILON\n        ) {\n          continue // No significant force applied in this step, skip update\n        }\n\n        // Limit maximum movement per step? (Optional)\n        // const maxMove = this.cellSize;\n        const forceMag = Math.sqrt(\n          currentForceX * currentForceX + currentForceY * currentForceY,\n        )\n        magForceApplied += forceMag\n        // Update position if moved significantly from original position\n        // Use the calculated (and potentially clamped/boundary-forced) newX, newY\n        if (\n          Math.abs(mPoint.x - newX) > EPSILON ||\n          Math.abs(mPoint.y - newY) > EPSILON\n        ) {\n          mPoint.x = newX\n          mPoint.y = newY\n          pointsMoved = true\n        }\n      }\n      // Recompute hash after potential modifications\n    }\n\n    // Return whether any points actually moved\n    return { lastStepMoved: pointsMoved, magForceApplied }\n  }\n}\n","import { Point3, distance } from \"@tscircuit/math-utils\"\nimport { ViaPossibilitiesSolver2 } from \"lib/solvers/ViaPossibilitiesSolver/ViaPossibilitiesSolver2\"\nimport { MultiHeadPolyLineIntraNodeSolver } from \"./MultiHeadPolyLineIntraNodeSolver\"\nimport { MHPoint, PolyLine, Candidate } from \"./types1\"\nimport { PolyLine2 } from \"./types2\"\nimport { MultiHeadPolyLineIntraNodeSolver2 } from \"./MultiHeadPolyLineIntraNodeSolver2_Optimized\"\n\nconst hashPolyLines = (polyLines: PolyLine2[]) => {\n  return polyLines\n    .flatMap(\n      (pl) =>\n        `${pl.connectionName}-${pl.mPoints.map((mp) => `${mp.x.toFixed(2)},${mp.y.toFixed(2)},${mp.z1},${mp.z2}`)}`,\n    )\n    .sort()\n    .join(\"|\")\n}\n\nfunction factorial(n: number) {\n  if (!Number.isInteger(n) || n < 0) {\n    throw new RangeError(\"n must be a non-negative integer\")\n  }\n  let result = 1\n  for (let i = 2; i <= n; i++) {\n    result *= i\n  }\n  return result\n}\n\nexport class MultiHeadPolyLineIntraNodeSolver3 extends MultiHeadPolyLineIntraNodeSolver2 {\n  constructor(\n    params: ConstructorParameters<typeof MultiHeadPolyLineIntraNodeSolver2>[0],\n  ) {\n    super(params)\n    this.MAX_ITERATIONS = 1000\n  }\n\n  createInitialCandidateFromSeed(shuffleSeed: number): Candidate | null {\n    // 1. Run ViaPossibilitiesSolver2 to get a valid path layout\n    const viaSolver = new ViaPossibilitiesSolver2({\n      nodeWithPortPoints: this.nodeWithPortPoints,\n      colorMap: this.colorMap,\n      // Pass relevant hyperparameters if needed, e.g., shuffle seed\n      hyperParameters: {\n        SHUFFLE_SEED: shuffleSeed,\n      },\n    })\n\n    viaSolver.solve()\n\n    if (viaSolver.failed || !viaSolver.solved) {\n      return null\n    }\n\n    // 2. Convert the completedPaths from ViaPossibilitiesSolver2 into PolyLine[]\n    const polyLines: PolyLine[] = []\n    let totalViaCount = 0\n\n    for (const [\n      connectionName,\n      pathPoints,\n    ] of viaSolver.completedPaths.entries()) {\n      if (pathPoints.length < 2) {\n        console.warn(\n          `Skipping connection \"${connectionName}\" due to insufficient points (${pathPoints.length}) in ViaPossibilitiesSolver2 path.`,\n        )\n        continue // Should not happen with a valid solution\n      }\n\n      const startPoint = pathPoints[0]\n      const endPoint = pathPoints[pathPoints.length - 1]\n      const middlePointsRaw = pathPoints.slice(1, -1)\n\n      const mPoints: MHPoint[] = []\n      let currentViaCount = 0\n\n      // Convert Point3[] to MHPoint[] and identify vias\n      // The ViaPossibilitiesSolver2 path structure is [start, p1_z1, p1_z2, p2_z2, ..., end]\n      // We need to map this to MHPoint structure { x, y, z1, z2 }\n      let lastZ = startPoint.z\n      for (let i = 0; i < middlePointsRaw.length; i++) {\n        const currentRawPoint = middlePointsRaw[i]\n        const nextRawPoint =\n          i + 1 < middlePointsRaw.length ? middlePointsRaw[i + 1] : endPoint // Look ahead to determine z2\n\n        const isViaStart =\n          i + 1 < middlePointsRaw.length &&\n          currentRawPoint.x === nextRawPoint.x &&\n          currentRawPoint.y === nextRawPoint.y &&\n          currentRawPoint.z !== nextRawPoint.z\n\n        const z1 = lastZ\n        const z2 = isViaStart ? nextRawPoint.z : currentRawPoint.z\n\n        mPoints.push({\n          x: currentRawPoint.x,\n          y: currentRawPoint.y,\n          z1: z1,\n          z2: z2,\n        })\n\n        if (z1 !== z2) {\n          currentViaCount++\n          // Skip the next point as it's the second part of the via pair\n          i++\n          lastZ = z2 // Update lastZ after the via transition\n        } else {\n          lastZ = currentRawPoint.z // Update lastZ for the next segment\n        }\n      }\n      totalViaCount += currentViaCount\n\n      // Ensure the polyline has SEGMENTS_PER_POLYLINE segments by splitting the longest ones\n      const targetSegmentCount = this.SEGMENTS_PER_POLYLINE\n      let currentSegments = mPoints.length + 1\n\n      while (currentSegments < targetSegmentCount) {\n        let longestSegmentLength = -1\n        let longestSegmentIndex = -1 // Index of the point *before* the longest segment\n        let p1: MHPoint | null = null\n        let p2: MHPoint | null = null\n        const fullPathPoints = [\n          {\n            ...startPoint,\n            z1: startPoint.z,\n            z2: startPoint.z,\n            connectionName,\n          },\n          ...mPoints,\n          { ...endPoint, z1: endPoint.z, z2: endPoint.z, connectionName },\n        ]\n\n        for (let k = 0; k < fullPathPoints.length - 1; k++) {\n          const segP1 = fullPathPoints[k]\n          const segP2 = fullPathPoints[k + 1]\n\n          // Skip via segments (where only Z changes)\n          if (segP1.x === segP2.x && segP1.y === segP2.y) {\n            continue\n          }\n\n          const len = distance(segP1, segP2)\n          if (len > longestSegmentLength) {\n            longestSegmentLength = len\n            longestSegmentIndex = k\n            p1 = segP1\n            p2 = segP2\n          }\n        }\n\n        if (longestSegmentIndex === -1 || !p1 || !p2) {\n          // Should not happen if there are non-via segments and targetSegmentCount > currentSegments\n          console.warn(\n            `Could not find longest segment for ${connectionName} while trying to reach ${targetSegmentCount} segments.`,\n          )\n          break // Exit loop to prevent infinite loop\n        }\n\n        // Calculate midpoint and determine segment layer\n        const midX = (p1.x + p2.x) / 2\n        const midY = (p1.y + p2.y) / 2\n        // The segment exists on the layer *after* p1's potential via, which is p1.z2\n        // This should also be the same as p2.z1 (layer *before* p2's potential via)\n        const segmentZ = p1.z2\n\n        const newMPoint: MHPoint = {\n          x: midX,\n          y: midY,\n          z1: segmentZ, // New point is on the same layer\n          z2: segmentZ,\n        }\n\n        // Insert the new midpoint into the mPoints array\n        // longestSegmentIndex is the index of the point *before* the segment,\n        // so the new point goes at index `longestSegmentIndex` in mPoints\n        // (which corresponds to `longestSegmentIndex + 1` in fullPathPoints)\n        mPoints.splice(longestSegmentIndex, 0, newMPoint)\n        currentSegments++\n      }\n\n      // Create the final PolyLine object with potentially adjusted mPoints\n      polyLines.push({\n        connectionName,\n        start: {\n          // Use original start/end points from ViaSolver\n          ...startPoint,\n          z1: startPoint.z,\n          z2: startPoint.z, // Start point is not a via itself\n        },\n        end: {\n          ...endPoint,\n          z1: endPoint.z, // End point uses its own Z as z1\n          z2: endPoint.z, // End point is not a via itself\n        },\n        mPoints,\n      })\n    }\n\n    if (polyLines.length === 0) {\n      this.failed = true\n      this.error = \"No valid polylines generated from ViaPossibilitiesSolver2.\"\n      console.error(this.error)\n      return null\n    }\n\n    const minGaps = this.computeMinGapBtwPolyLines(polyLines)\n    const h = this.computeH({ minGaps, forces: [] }) // Initial forces are zero\n\n    const initialCandidate = {\n      polyLines,\n      g: 0,\n      h: h,\n      f: 0 + h, // f = g + h\n      viaCount: totalViaCount,\n      minGaps,\n    }\n    initialCandidate.g = this.computeG(polyLines, initialCandidate)\n    initialCandidate.f = initialCandidate.g + initialCandidate.h\n\n    return initialCandidate\n  }\n\n  setupInitialPolyLines(): void {\n    this.candidates = []\n    const maxCandidatesToGenerate = Math.min(\n      2000,\n      factorial(this.uniqueConnections),\n    )\n    const candidatePolylineHashes = new Set<string>()\n    for (let i = 0; i < maxCandidatesToGenerate; i++) {\n      const newCandidate = this.createInitialCandidateFromSeed(i)\n      if (!newCandidate) continue\n      const newCandidatePolylineHash = hashPolyLines(newCandidate.polyLines)\n      if (candidatePolylineHashes.has(newCandidatePolylineHash)) continue\n      candidatePolylineHashes.add(newCandidatePolylineHash)\n      this.candidates.push(newCandidate)\n    }\n    this.candidates.sort((a, b) => a.f - b.f) // Sort in case we add more initial candidates later\n  }\n}\n","import {\n  HighDensityIntraNodeRoute,\n  NodeWithPortPoints,\n} from \"lib/types/high-density-types\"\nimport { IntraNodeRouteSolver } from \"../HighDensitySolver/IntraNodeSolver\"\nimport {\n  HyperParameterSupervisorSolver,\n  SupervisedSolver,\n} from \"../HyperParameterSupervisorSolver\"\nimport { ConnectivityMap } from \"circuit-json-to-connectivity-map\"\nimport { TwoCrossingRoutesHighDensitySolver } from \"../HighDensitySolver/TwoRouteHighDensitySolver/TwoCrossingRoutesHighDensitySolver\"\nimport { SingleTransitionCrossingRouteSolver } from \"../HighDensitySolver/TwoRouteHighDensitySolver/SingleTransitionCrossingRouteSolver\"\nimport { MultiHeadPolyLineIntraNodeSolver2 } from \"../HighDensitySolver/MultiHeadPolyLineIntraNodeSolver/MultiHeadPolyLineIntraNodeSolver2_Optimized\"\nimport { MultiHeadPolyLineIntraNodeSolver3 } from \"../HighDensitySolver/MultiHeadPolyLineIntraNodeSolver/MultiHeadPolyLineIntraNodeSolver3_ViaPossibilitiesSolverIntegration\"\n\nexport class HyperSingleIntraNodeSolver extends HyperParameterSupervisorSolver<\n  IntraNodeRouteSolver | TwoCrossingRoutesHighDensitySolver\n> {\n  constructorParams: ConstructorParameters<typeof IntraNodeRouteSolver>[0]\n  solvedRoutes: HighDensityIntraNodeRoute[] = []\n  nodeWithPortPoints: NodeWithPortPoints\n  connMap?: ConnectivityMap\n\n  constructor(opts: ConstructorParameters<typeof IntraNodeRouteSolver>[0]) {\n    super()\n    this.nodeWithPortPoints = opts.nodeWithPortPoints\n    this.connMap = opts.connMap\n    this.constructorParams = opts\n    this.MAX_ITERATIONS = 250_000\n    this.GREEDY_MULTIPLIER = 5\n    this.MIN_SUBSTEPS = 100\n  }\n\n  getCombinationDefs() {\n    return [\n      [\"multiHeadPolyLine\"],\n      [\"majorCombinations\", \"orderings6\", \"cellSizeFactor\"],\n      [\"noVias\"],\n      [\"orderings50\"],\n      [\"flipTraceAlignmentDirection\", \"orderings6\"],\n      [\"closedFormTwoTrace\"],\n    ]\n  }\n\n  getHyperParameterDefs() {\n    return [\n      {\n        name: \"majorCombinations\",\n        possibleValues: [\n          {\n            FUTURE_CONNECTION_PROX_TRACE_PENALTY_FACTOR: 2,\n            FUTURE_CONNECTION_PROX_VIA_PENALTY_FACTOR: 1,\n            FUTURE_CONNECTION_PROXIMITY_VD: 10,\n            MISALIGNED_DIST_PENALTY_FACTOR: 5,\n          },\n          {\n            FUTURE_CONNECTION_PROX_TRACE_PENALTY_FACTOR: 1,\n            FUTURE_CONNECTION_PROX_VIA_PENALTY_FACTOR: 0.5,\n            FUTURE_CONNECTION_PROXIMITY_VD: 5,\n            MISALIGNED_DIST_PENALTY_FACTOR: 2,\n          },\n          {\n            FUTURE_CONNECTION_PROX_TRACE_PENALTY_FACTOR: 10,\n            FUTURE_CONNECTION_PROX_VIA_PENALTY_FACTOR: 1,\n            FUTURE_CONNECTION_PROXIMITY_VD: 5,\n            MISALIGNED_DIST_PENALTY_FACTOR: 10,\n            VIA_PENALTY_FACTOR_2: 1,\n          },\n        ],\n      },\n      {\n        name: \"orderings6\",\n        possibleValues: [\n          {\n            SHUFFLE_SEED: 0,\n          },\n          {\n            SHUFFLE_SEED: 1,\n          },\n          {\n            SHUFFLE_SEED: 2,\n          },\n          {\n            SHUFFLE_SEED: 3,\n          },\n          {\n            SHUFFLE_SEED: 4,\n          },\n          {\n            SHUFFLE_SEED: 5,\n          },\n        ],\n      },\n      {\n        name: \"cellSizeFactor\",\n        possibleValues: [\n          {\n            CELL_SIZE_FACTOR: 0.5,\n          },\n          {\n            CELL_SIZE_FACTOR: 1,\n          },\n        ],\n      },\n      {\n        name: \"flipTraceAlignmentDirection\",\n        possibleValues: [\n          {\n            FLIP_TRACE_ALIGNMENT_DIRECTION: true,\n          },\n        ],\n      },\n      {\n        name: \"noVias\",\n        possibleValues: [\n          {\n            CELL_SIZE_FACTOR: 2,\n            VIA_PENALTY_FACTOR_2: 10,\n          },\n        ],\n      },\n      {\n        name: \"orderings50\",\n        possibleValues: Array.from({ length: 50 }, (_, i) => ({\n          SHUFFLE_SEED: 100 + i,\n        })),\n      },\n      {\n        name: \"closedFormTwoTrace\",\n        possibleValues: [\n          {\n            CLOSED_FORM_TWO_TRACE_SAME_LAYER: true,\n          },\n          {\n            CLOSED_FORM_TWO_TRACE_TRANSITION_CROSSING: true,\n          },\n        ],\n      },\n      {\n        name: \"multiHeadPolyLine\",\n        possibleValues: [\n          {\n            MULTI_HEAD_POLYLINE_SOLVER: true,\n            SEGMENTS_PER_POLYLINE: 6,\n            BOUNDARY_PADDING: 0.05,\n          },\n          {\n            MULTI_HEAD_POLYLINE_SOLVER: true,\n            SEGMENTS_PER_POLYLINE: 6,\n            BOUNDARY_PADDING: -0.05, // Allow vias/traces outside the boundary\n            ITERATION_PENALTY: 10000,\n            MINIMUM_FINAL_ACCEPTANCE_GAP: 0.001,\n          },\n        ],\n      },\n    ]\n  }\n\n  computeG(solver: IntraNodeRouteSolver) {\n    if (solver?.hyperParameters?.MULTI_HEAD_POLYLINE_SOLVER) {\n      return (\n        1000 +\n        ((solver.hyperParameters?.ITERATION_PENALTY ?? 0) + solver.iterations) /\n          10_000 +\n        10_000 * (solver.hyperParameters.SEGMENTS_PER_POLYLINE! - 3)\n      )\n    }\n    return (\n      solver.iterations / 10_000 // + solver.hyperParameters.SHUFFLE_SEED! * 0.05\n    )\n  }\n\n  computeH(solver: IntraNodeRouteSolver) {\n    return 1 - (solver.progress || 0)\n  }\n\n  generateSolver(hyperParameters: any): IntraNodeRouteSolver {\n    if (hyperParameters.CLOSED_FORM_TWO_TRACE_SAME_LAYER) {\n      return new TwoCrossingRoutesHighDensitySolver({\n        nodeWithPortPoints: this.nodeWithPortPoints,\n      }) as any\n    }\n    if (hyperParameters.CLOSED_FORM_TWO_TRACE_TRANSITION_CROSSING) {\n      return new SingleTransitionCrossingRouteSolver({\n        nodeWithPortPoints: this.nodeWithPortPoints,\n      }) as any\n    }\n    if (hyperParameters.MULTI_HEAD_POLYLINE_SOLVER) {\n      return new MultiHeadPolyLineIntraNodeSolver3({\n        nodeWithPortPoints: this.nodeWithPortPoints,\n        connMap: this.connMap,\n        hyperParameters: hyperParameters,\n      }) as any\n    }\n    return new IntraNodeRouteSolver({\n      ...this.constructorParams,\n      hyperParameters,\n    })\n  }\n\n  onSolve(solver: SupervisedSolver<IntraNodeRouteSolver>) {\n    this.solvedRoutes = solver.solver.solvedRoutes\n  }\n}\n","interface RoutePoint {\n  x: number\n  y: number\n  z: number\n}\n\ninterface MergedSegment {\n  points: { x: number; y: number }[]\n  z: number\n  connectionName: string\n  color: string\n}\n\n/**\n * Merges consecutive route points with the same z-coordinate into segments\n * @param route Array of route points\n * @param connectionName Name of the connection\n * @param color Color for the segment\n * @returns Array of merged segments\n */\nexport function mergeRouteSegments(\n  route: RoutePoint[],\n  connectionName: string,\n  color: string,\n): MergedSegment[] {\n  const segments: MergedSegment[] = []\n  let currentSegment: MergedSegment | null = null\n\n  for (let i = 0; i < route.length; i++) {\n    const point = route[i]\n\n    if (!currentSegment) {\n      currentSegment = {\n        points: [{ x: point.x, y: point.y }],\n        z: point.z,\n        connectionName,\n        color,\n      }\n    } else if (currentSegment.z === point.z) {\n      currentSegment.points.push({ x: point.x, y: point.y })\n    } else {\n      segments.push(currentSegment)\n      currentSegment = {\n        points: [{ x: point.x, y: point.y }],\n        z: point.z,\n        connectionName,\n        color,\n      }\n    }\n\n    // Add final segment if we're at the last point\n    if (i === route.length - 1 && currentSegment) {\n      segments.push(currentSegment)\n    }\n  }\n\n  return segments\n}\n","import type {\n  HighDensityIntraNodeRoute,\n  NodeWithPortPoints,\n} from \"../../types/high-density-types\"\nimport type { GraphicsObject } from \"graphics-debug\"\nimport { BaseSolver } from \"../BaseSolver\"\nimport { safeTransparentize } from \"../colors\"\nimport { IntraNodeRouteSolver } from \"./IntraNodeSolver\"\nimport { HyperSingleIntraNodeSolver } from \"../HyperHighDensitySolver/HyperSingleIntraNodeSolver\"\nimport { combineVisualizations } from \"lib/utils/combineVisualizations\"\nimport { ConnectivityMap } from \"circuit-json-to-connectivity-map\"\nimport { mergeRouteSegments } from \"lib/utils/mergeRouteSegments\"\n\nexport class HighDensitySolver extends BaseSolver {\n  unsolvedNodePortPoints: NodeWithPortPoints[]\n  routes: HighDensityIntraNodeRoute[]\n  colorMap: Record<string, string>\n\n  // Defaults as specified: viaDiameter of 0.6 and traceThickness of 0.15\n  readonly defaultViaDiameter = 0.6\n  readonly defaultTraceThickness = 0.15\n\n  failedSolvers: (IntraNodeRouteSolver | HyperSingleIntraNodeSolver)[]\n  activeSubSolver: IntraNodeRouteSolver | HyperSingleIntraNodeSolver | null =\n    null\n  connMap?: ConnectivityMap\n\n  constructor({\n    nodePortPoints,\n    colorMap,\n    connMap,\n  }: {\n    nodePortPoints: NodeWithPortPoints[]\n    colorMap?: Record<string, string>\n    connMap?: ConnectivityMap\n  }) {\n    super()\n    this.unsolvedNodePortPoints = nodePortPoints\n    this.colorMap = colorMap ?? {}\n    this.connMap = connMap\n    this.routes = []\n    this.failedSolvers = []\n    this.MAX_ITERATIONS = 1e6\n  }\n\n  /**\n   * Each iteration, pop an unsolved node and attempt to find the routes inside\n   * of it.\n   */\n  _step() {\n    if (this.activeSubSolver) {\n      this.activeSubSolver.step()\n      if (this.activeSubSolver.solved) {\n        this.routes.push(...this.activeSubSolver.solvedRoutes)\n        this.activeSubSolver = null\n      } else if (this.activeSubSolver.failed) {\n        this.failedSolvers.push(this.activeSubSolver)\n        this.activeSubSolver = null\n      }\n      return\n    }\n    if (this.unsolvedNodePortPoints.length === 0) {\n      if (this.failedSolvers.length > 0) {\n        this.solved = false\n        this.failed = true\n        // debugger\n        this.error = `Failed to solve ${this.failedSolvers.length} nodes, ${this.failedSolvers.slice(0, 5).map((fs) => fs.nodeWithPortPoints.capacityMeshNodeId)}. err0: ${this.failedSolvers[0].error}.`\n        return\n      }\n\n      this.solved = true\n      return\n    }\n    const node = this.unsolvedNodePortPoints.pop()!\n\n    this.activeSubSolver = new HyperSingleIntraNodeSolver({\n      nodeWithPortPoints: node,\n      colorMap: this.colorMap,\n      connMap: this.connMap,\n    })\n  }\n\n  visualize(): GraphicsObject {\n    let graphics: GraphicsObject = {\n      lines: [],\n      points: [],\n      rects: [],\n      circles: [],\n    }\n    for (const route of this.routes) {\n      // Merge segments based on z-coordinate\n      const mergedSegments = mergeRouteSegments(\n        route.route,\n        route.connectionName,\n        this.colorMap[route.connectionName],\n      )\n\n      // Add merged segments to graphics\n      for (const segment of mergedSegments) {\n        graphics.lines!.push({\n          points: segment.points,\n          label: segment.connectionName,\n          strokeColor:\n            segment.z === 0\n              ? segment.color\n              : safeTransparentize(segment.color, 0.75),\n          layer: `z${segment.z}`,\n          strokeWidth: route.traceThickness,\n          strokeDash: segment.z !== 0 ? \"10, 5\" : undefined,\n        })\n      }\n      for (const via of route.vias) {\n        graphics.circles!.push({\n          center: via,\n          layer: \"z0,1\",\n          radius: route.viaDiameter / 2,\n          fill: this.colorMap[route.connectionName],\n          label: `${route.connectionName} via`,\n        })\n      }\n    }\n    for (const solver of this.failedSolvers) {\n      const node = solver.nodeWithPortPoints\n\n      // Add a small rectangle in the center for failed nodes\n      const rectWidth = node.width * 0.1\n      const rectHeight = node.height * 0.1\n      graphics.rects!.push({\n        center: {\n          x: node.center.x - rectWidth / 2,\n          y: node.center.y - rectHeight / 2,\n        },\n        layer: \"did_not_connect\",\n        width: rectWidth,\n        height: rectHeight,\n        fill: \"red\",\n        label: `Failed: ${node.capacityMeshNodeId}`,\n      })\n\n      // Group port points by connectionName\n      const connectionGroups: Record<\n        string,\n        { x: number; y: number; z: number }[]\n      > = {}\n      for (const pt of node.portPoints) {\n        if (!connectionGroups[pt.connectionName]) {\n          connectionGroups[pt.connectionName] = []\n        }\n        connectionGroups[pt.connectionName].push({ x: pt.x, y: pt.y, z: pt.z })\n      }\n\n      for (const [connectionName, points] of Object.entries(connectionGroups)) {\n        for (let i = 0; i < points.length - 1; i++) {\n          const start = points[i]\n          const end = points[i + 1]\n          graphics.lines!.push({\n            points: [start, end],\n            strokeColor: \"red\",\n            strokeDash: \"10, 5\",\n            layer: \"did_not_connect\",\n          })\n        }\n      }\n    }\n    if (this.activeSubSolver) {\n      graphics = combineVisualizations(\n        graphics,\n        this.activeSubSolver.visualize(),\n      )\n    }\n    return graphics\n  }\n}\n","type NodeId = string\n\nexport function findConnectedNetworks(\n  connections: Array<NodeId[]>,\n): Record<string, string[]> {\n  const networks: Map<string, Set<string>> = new Map()\n  let netCounter = 0\n\n  function getOrCreateNetwork(nodeId: string): Set<string> {\n    for (const [, network] of networks) {\n      if (network.has(nodeId)) {\n        return network\n      }\n    }\n    const newNetwork = new Set<string>()\n    networks.set(`connectivity_net${netCounter++}`, newNetwork)\n    return newNetwork\n  }\n\n  for (const connection of connections) {\n    let network: Set<string> | null = null\n\n    for (const nodeId of connection) {\n      if (!network) {\n        network = getOrCreateNetwork(nodeId)\n      } else if (!network.has(nodeId)) {\n        const existingNetwork = getOrCreateNetwork(nodeId)\n        if (existingNetwork !== network) {\n          // Merge networks\n          for (const node of existingNetwork) {\n            network.add(node)\n          }\n          networks.delete(\n            Array.from(networks.entries()).find(\n              ([, net]) => net === existingNetwork,\n            )![0],\n          )\n        }\n      }\n      network.add(nodeId)\n    }\n  }\n\n  return Object.fromEntries(\n    Array.from(networks.entries()).map(([netId, connectedNodes]) => [\n      netId,\n      Array.from(connectedNodes),\n    ]),\n  )\n}\n","export class ConnectivityMap {\n  netMap: Record<string, string[]>\n\n  idToNetMap: Record<string, string>\n\n  constructor(netMap: Record<string, string[]>) {\n    this.netMap = netMap\n    this.idToNetMap = {}\n    for (const [netId, ids] of Object.entries(netMap)) {\n      for (const id of ids) {\n        this.idToNetMap[id] = netId\n      }\n    }\n  }\n\n  addConnections(connections: string[][]) {\n    for (const connection of connections) {\n      const existingNets = new Set<string>()\n\n      // Find all existing nets for the connection\n      for (const id of connection) {\n        const existingNetId = this.idToNetMap[id]\n        if (existingNetId) {\n          existingNets.add(existingNetId)\n        }\n      }\n\n      let targetNetId: string\n\n      if (existingNets.size === 0) {\n        // If no existing nets found, create a new one\n        targetNetId = `connectivity_net${Object.keys(this.netMap).length}`\n        this.netMap[targetNetId] = []\n      } else if (existingNets.size === 1) {\n        // If only one existing net found, use it\n        targetNetId =\n          existingNets.values().next().value ??\n          `connectivity_net${Object.keys(this.netMap).length}`\n      } else {\n        // If multiple nets found, merge them\n        targetNetId =\n          existingNets.values().next().value ??\n          `connectivity_net${Object.keys(this.netMap).length}`\n        for (const netId of existingNets) {\n          if (netId !== targetNetId) {\n            this.netMap[targetNetId].push(...this.netMap[netId])\n\n            // we could delete the net, but setting it to reference the other net\n            // will make sure any usage of the old netId will still work\n            this.netMap[netId] = this.netMap[targetNetId]\n            for (const id of this.netMap[targetNetId]) {\n              this.idToNetMap[id] = targetNetId\n            }\n          }\n        }\n      }\n\n      // Add all ids to the target net\n      for (const id of connection) {\n        if (!this.netMap[targetNetId].includes(id)) {\n          this.netMap[targetNetId].push(id)\n        }\n        this.idToNetMap[id] = targetNetId\n      }\n    }\n  }\n\n  getIdsConnectedToNet(netId: string): string[] {\n    return this.netMap[netId] || []\n  }\n\n  getNetConnectedToId(id: string): string | undefined {\n    return this.idToNetMap[id]\n  }\n\n  areIdsConnected(id1: string, id2: string): boolean {\n    if (id1 === id2) return true\n    const netId1 = this.getNetConnectedToId(id1)\n    if (!netId1) return false\n    const netId2 = this.getNetConnectedToId(id2)\n    if (!netId2) return false\n    return netId1 === netId2 || netId2 === id1 || netId2 === id1\n  }\n\n  areAllIdsConnected(ids: string[]): boolean {\n    const netId = this.getNetConnectedToId(ids[0])\n    for (const id of ids) {\n      const nextNetId = this.getNetConnectedToId(id)\n      if (nextNetId === undefined) {\n        return false\n      }\n      if (nextNetId !== netId) {\n        return false\n      }\n    }\n    return true\n  }\n}\n","import type { AnyCircuitElement } from \"circuit-json\"\nimport { findConnectedNetworks } from \"./findConnectedNetworks\"\nimport { ConnectivityMap } from \"./ConnectivityMap\"\n\nexport const getSourcePortConnectivityMapFromCircuitJson = (\n  circuitJson: AnyCircuitElement[],\n) => {\n  const connections: string[][] = []\n\n  for (const element of circuitJson) {\n    if (element.type === \"source_trace\") {\n      connections.push([\n        ...(element.connected_source_port_ids ?? []),\n        ...(element.connected_source_net_ids ?? []),\n      ])\n    }\n  }\n\n  const netMap = findConnectedNetworks(connections)\n\n  return new ConnectivityMap(netMap)\n}\n","import type { AnyCircuitElement } from \"circuit-json\"\nimport { findConnectedNetworks } from \"./findConnectedNetworks\"\nimport { ConnectivityMap } from \"./ConnectivityMap\"\n\nexport const getFullConnectivityMapFromCircuitJson = (\n  circuitJson: AnyCircuitElement[],\n) => {\n  const connections: string[][] = []\n\n  for (const element of circuitJson) {\n    if (element.type === \"source_trace\") {\n      connections.push(\n        [\n          element.source_trace_id,\n          ...(element.connected_source_port_ids ?? []),\n          ...(element.connected_source_net_ids ?? []),\n        ].filter(Boolean),\n      )\n    } else if (element.type === \"pcb_port\") {\n      const { pcb_port_id, source_port_id } = element\n      if (source_port_id && pcb_port_id) {\n        connections.push([source_port_id, pcb_port_id])\n      }\n    } else if (element.type === \"pcb_smtpad\") {\n      const { pcb_smtpad_id, pcb_port_id } = element\n      if (pcb_port_id && pcb_smtpad_id) {\n        connections.push([pcb_smtpad_id, pcb_port_id])\n      }\n    } else if (element.type === \"pcb_plated_hole\") {\n      const { pcb_plated_hole_id, pcb_port_id } = element\n      if (pcb_port_id && pcb_plated_hole_id) {\n        connections.push([pcb_plated_hole_id, pcb_port_id])\n      }\n    } else if (element.type === \"pcb_trace\") {\n      const { pcb_trace_id, source_trace_id } = element\n      if (source_trace_id && pcb_trace_id) {\n        connections.push([pcb_trace_id, source_trace_id])\n      }\n    }\n  }\n\n  const netMap = findConnectedNetworks(connections)\n\n  return new ConnectivityMap(netMap)\n}\n","import type { AnyCircuitElement, PCBPort, PCBTrace } from \"circuit-json\"\nimport { ConnectivityMap } from \"./ConnectivityMap\"\nimport { doesLineIntersectLine } from \"@tscircuit/math-utils\"\nimport { findConnectedNetworks } from \"./findConnectedNetworks\"\n\n/**\n * A PCB Connectivity Map is a connectivity map that has analyzed what traces and ports are actually connected on the\n * PCB.\n *\n * This is useful for determining how to route a trace on the PCB. For example, you may want to determine where the\n * nearest connected net point is to connect an unrouted pin.\n */\nexport class PcbConnectivityMap {\n  circuitJson: AnyCircuitElement[]\n  traceIdToElm: Map<string, PCBTrace>\n  portIdToElm: Map<string, PCBPort>\n  connMap: ConnectivityMap\n\n  constructor(circuitJson?: AnyCircuitElement[]) {\n    this.circuitJson = circuitJson || []\n    this.traceIdToElm = new Map()\n    this.portIdToElm = new Map()\n    if (circuitJson) {\n      this._buildTraceMap()\n      this._buildPortMap()\n      this.connMap = this._buildTraceConnectivityMap()\n    } else {\n      this.connMap = new ConnectivityMap({})\n    }\n  }\n\n  private _buildPortMap() {\n    for (const element of this.circuitJson) {\n      if (element.type === \"pcb_port\") {\n        this.portIdToElm.set(element.pcb_port_id, element as PCBPort)\n      }\n    }\n  }\n\n  private _buildTraceMap() {\n    for (const element of this.circuitJson) {\n      if (element.type === \"pcb_trace\") {\n        this.traceIdToElm.set(element.pcb_trace_id, element as PCBTrace)\n      }\n    }\n  }\n\n  private _buildTraceConnectivityMap(): ConnectivityMap {\n    const connections: string[][] = []\n    const traceIds = Array.from(this.traceIdToElm.keys())\n\n    for (let i = 0; i < traceIds.length; i++) {\n      for (let j = i + 1; j < traceIds.length; j++) {\n        const trace1 = this.traceIdToElm.get(traceIds[i])!\n        const trace2 = this.traceIdToElm.get(traceIds[j])!\n        if (this._arePcbTracesConnected(trace1, trace2)) {\n          connections.push([traceIds[i], traceIds[j]])\n        }\n      }\n    }\n\n    for (const port of this.portIdToElm.values()) {\n      for (const trace of this.traceIdToElm.values()) {\n        for (const rp of trace.route) {\n          if (rp.route_type === \"wire\") {\n            if (rp.start_pcb_port_id === port.pcb_port_id) {\n              connections.push([port.pcb_port_id, trace.pcb_trace_id])\n            } else if (rp.end_pcb_port_id === port.pcb_port_id) {\n              connections.push([trace.pcb_trace_id, port.pcb_port_id])\n            }\n          }\n        }\n      }\n    }\n\n    return new ConnectivityMap(findConnectedNetworks(connections))\n  }\n\n  addTrace(trace: PCBTrace) {\n    this.traceIdToElm.set(trace.pcb_trace_id, trace)\n    const connections: string[][] = []\n    for (const rp of trace.route) {\n      if (rp.route_type === \"wire\") {\n        if (rp.start_pcb_port_id) {\n          connections.push([rp.start_pcb_port_id, trace.pcb_trace_id])\n        }\n        if (rp.end_pcb_port_id) {\n          connections.push([rp.end_pcb_port_id, trace.pcb_trace_id])\n        }\n      }\n    }\n\n    this.connMap.addConnections(connections)\n  }\n\n  _arePcbTracesConnected(trace1: PCBTrace, trace2: PCBTrace): boolean {\n    for (let i = 0; i < trace1.route.length - 1; i++) {\n      const segment1A = trace1.route[i]\n      const segment1B = trace1.route[i + 1]\n      if (segment1A.route_type !== \"wire\") continue\n      if (segment1B.route_type !== \"wire\") continue\n      for (let j = 0; j < trace2.route.length - 1; j++) {\n        const segment2A = trace2.route[j]\n        const segment2B = trace2.route[j + 1]\n\n        if (segment2A.route_type !== \"wire\") continue\n        if (segment2B.route_type !== \"wire\") continue\n\n        // Check if lines are overlapping\n        const isOverlapping = doesLineIntersectLine(\n          [segment1A, segment1B],\n          [segment2A, segment2B],\n          {\n            lineThickness: (segment1A.width + segment2A.width) / 2,\n          },\n        )\n        if (isOverlapping) {\n          return true\n        }\n      }\n    }\n    return false\n  }\n\n  areTracesConnected(traceId1: string, traceId2: string): boolean {\n    return this.connMap.areIdsConnected(traceId1, traceId2)\n  }\n\n  getAllTracesConnectedToTrace(traceId: string): PCBTrace[] {\n    const netId = this.connMap.getNetConnectedToId(traceId)\n    return netId\n      ? this.connMap\n          .getIdsConnectedToNet(netId)\n          .filter((id) => this.traceIdToElm.has(id))\n          .map((id) => this.traceIdToElm.get(id) as PCBTrace)\n      : []\n  }\n\n  getAllTracesConnectedToPort(portId: string): PCBTrace[] {\n    const netId = this.connMap.getNetConnectedToId(portId)\n    return netId\n      ? this.connMap\n          .getIdsConnectedToNet(netId)\n          .filter((id) => this.traceIdToElm.has(id))\n          .map((id) => this.traceIdToElm.get(id) as PCBTrace)\n      : []\n  }\n}\n","import { SimpleRouteJson } from \"lib/types\"\nimport { ConnectivityMap } from \"circuit-json-to-connectivity-map\"\n\nexport const getConnectivityMapFromSimpleRouteJson = (srj: SimpleRouteJson) => {\n  const connMap = new ConnectivityMap({})\n  for (const connection of srj.connections) {\n    for (const point of connection.pointsToConnect) {\n      if (\"pcb_port_id\" in point && point.pcb_port_id) {\n        connMap.addConnections([[connection.name, point.pcb_port_id as string]])\n      }\n    }\n  }\n  for (const obstacle of srj.obstacles) {\n    connMap.addConnections([obstacle.connectedTo])\n  }\n  return connMap\n}\n","type Point = { x: number; y: number }\n\nexport class KDNode {\n  point: Point\n  left: KDNode | null = null\n  right: KDNode | null = null\n\n  constructor(point: Point) {\n    this.point = point\n  }\n}\n\nclass KDTree {\n  root: KDNode | null = null\n\n  constructor(points: Point[]) {\n    if (points.length > 0) {\n      this.root = this.buildTree(points, 0)\n    }\n  }\n\n  private buildTree(points: Point[], depth: number): KDNode {\n    const axis = depth % 2 === 0 ? \"x\" : \"y\"\n\n    // Sort points by the current axis\n    points.sort((a, b) => a[axis] - b[axis])\n\n    // Choose median as the pivot element\n    const medianIndex = Math.floor(points.length / 2)\n    const node = new KDNode(points[medianIndex])\n\n    // Recursively build left and right subtrees\n    if (medianIndex > 0) {\n      node.left = this.buildTree(points.slice(0, medianIndex), depth + 1)\n    }\n\n    if (medianIndex < points.length - 1) {\n      node.right = this.buildTree(points.slice(medianIndex + 1), depth + 1)\n    }\n\n    return node\n  }\n\n  // Find the nearest neighbor to a query point\n  findNearestNeighbor(queryPoint: Point): Point {\n    if (!this.root) {\n      throw new Error(\"Tree is empty\")\n    }\n\n    const best: Point = this.root.point\n    const bestDistance = this.distance(queryPoint, best)\n\n    this.nearestNeighborSearch(this.root, queryPoint, 0, best, bestDistance)\n\n    return best\n  }\n\n  private nearestNeighborSearch(\n    node: KDNode | null,\n    queryPoint: Point,\n    depth: number,\n    best: Point,\n    bestDistance: number,\n  ): Point {\n    if (!node) {\n      return best\n    }\n\n    const axis = depth % 2 ? \"x\" : \"y\"\n    const currentDistance = this.distance(queryPoint, node.point)\n\n    if (currentDistance < bestDistance) {\n      best = node.point\n      bestDistance = currentDistance\n    }\n\n    // Determine which subtree to search first\n    const axisDiff = queryPoint[axis] - node.point[axis]\n    const firstBranch = axisDiff <= 0 ? node.left : node.right\n    const secondBranch = axisDiff <= 0 ? node.right : node.left\n\n    // Recursively search the first branch\n    best = this.nearestNeighborSearch(\n      firstBranch,\n      queryPoint,\n      depth + 1,\n      best,\n      bestDistance,\n    )\n    bestDistance = this.distance(queryPoint, best)\n\n    // Check if we need to search the second branch\n    if (Math.abs(axisDiff) < bestDistance) {\n      best = this.nearestNeighborSearch(\n        secondBranch,\n        queryPoint,\n        depth + 1,\n        best,\n        bestDistance,\n      )\n    }\n\n    return best\n  }\n\n  // Find k nearest neighbors\n  findKNearestNeighbors(queryPoint: Point, k: number): Point[] {\n    if (!this.root) {\n      return []\n    }\n\n    const neighbors: Array<{ point: Point; distance: number }> = []\n\n    this.kNearestNeighborSearch(this.root, queryPoint, 0, neighbors, k)\n\n    return neighbors\n      .sort((a, b) => a.distance - b.distance)\n      .slice(0, k)\n      .map((n) => n.point)\n  }\n\n  private kNearestNeighborSearch(\n    node: KDNode | null,\n    queryPoint: Point,\n    depth: number,\n    neighbors: Array<{ point: Point; distance: number }>,\n    k: number,\n  ): void {\n    if (!node) {\n      return\n    }\n\n    const axis = depth % 2 ? \"x\" : \"y\"\n    const currentDistance = this.distance(queryPoint, node.point)\n\n    // Add current node to neighbors\n    neighbors.push({ point: node.point, distance: currentDistance })\n\n    // Determine which subtree to search first\n    const axisDiff = queryPoint[axis] - node.point[axis]\n    const firstBranch = axisDiff <= 0 ? node.left : node.right\n    const secondBranch = axisDiff <= 0 ? node.right : node.left\n\n    // Recursively search the first branch\n    this.kNearestNeighborSearch(\n      firstBranch,\n      queryPoint,\n      depth + 1,\n      neighbors,\n      k,\n    )\n\n    // Get the kth distance if we have k neighbors\n    let kthDistance = Infinity\n    if (neighbors.length >= k) {\n      neighbors.sort((a, b) => a.distance - b.distance)\n      kthDistance = neighbors[k - 1]?.distance || Infinity\n    }\n\n    // Search the other branch if necessary\n    if (Math.abs(axisDiff) < kthDistance || neighbors.length < k) {\n      this.kNearestNeighborSearch(\n        secondBranch,\n        queryPoint,\n        depth + 1,\n        neighbors,\n        k,\n      )\n    }\n  }\n\n  // Calculate Euclidean distance between two points\n  private distance(a: Point, b: Point): number {\n    return Math.sqrt((a.x - b.x) ** 2 + (a.y - b.y) ** 2)\n  }\n}\n\n// Disjoint Set (Union-Find) data structure for Kruskal's algorithm\nexport class DisjointSet {\n  private parent: Map<string, string> = new Map()\n  private rank: Map<string, number> = new Map()\n\n  constructor(points: Point[]) {\n    // Initialize each point as a separate set\n    for (const point of points) {\n      const key = this.pointToKey(point)\n      this.parent.set(key, key)\n      this.rank.set(key, 0)\n    }\n  }\n\n  private pointToKey(point: Point): string {\n    return `${point.x},${point.y}`\n  }\n\n  find(point: Point): string {\n    const key = this.pointToKey(point)\n    if (!this.parent.has(key)) {\n      throw new Error(`Point ${key} not found in DisjointSet`)\n    }\n\n    let root = key\n    while (root !== this.parent.get(root)) {\n      root = this.parent.get(root)!\n    }\n\n    // Path compression\n    let current = key\n    while (current !== root) {\n      const next = this.parent.get(current)!\n      this.parent.set(current, root)\n      current = next\n    }\n\n    return root\n  }\n\n  union(pointA: Point, pointB: Point): boolean {\n    const rootA = this.find(pointA)\n    const rootB = this.find(pointB)\n\n    if (rootA === rootB) {\n      return false // Already in the same set\n    }\n\n    // Union by rank\n    const rankA = this.rank.get(rootA) || 0\n    const rankB = this.rank.get(rootB) || 0\n\n    if (rankA < rankB) {\n      this.parent.set(rootA, rootB)\n    } else if (rankA > rankB) {\n      this.parent.set(rootB, rootA)\n    } else {\n      this.parent.set(rootB, rootA)\n      this.rank.set(rootA, rankA + 1)\n    }\n\n    return true\n  }\n}\n\n// Edge representation for Kruskal's algorithm\ninterface Edge<T extends Point> {\n  from: T\n  to: T\n  weight: number\n}\n\n// Main function to build a minimum spanning tree using Kruskal's algorithm\nexport function buildMinimumSpanningTree<T extends Point>(\n  points: T[],\n): Edge<T>[] {\n  if (points.length <= 1) {\n    return []\n  }\n\n  // Build KD-Tree for efficient nearest neighbor search\n  const kdTree = new KDTree(points)\n\n  // Generate edges with k-nearest neighbors for each point\n  // This is an optimization to avoid generating all possible n(n-1)/2 edges\n  const edges: Edge<T>[] = []\n  const k = Math.min(10, points.length - 1) // Consider k nearest neighbors\n\n  for (const point of points) {\n    const neighbors = kdTree.findKNearestNeighbors(point, k + 1) // +1 because it includes the point itself\n\n    for (const neighbor of neighbors) {\n      // Skip self\n      if (point.x === neighbor.x && point.y === neighbor.y) {\n        continue\n      }\n\n      const distance = Math.sqrt(\n        (point.x - neighbor.x) ** 2 + (point.y - neighbor.y) ** 2,\n      )\n\n      edges.push({\n        from: point,\n        to: neighbor as T,\n        weight: distance,\n      })\n    }\n  }\n\n  // Sort edges by weight (distance)\n  edges.sort((a, b) => a.weight - b.weight)\n\n  // Apply Kruskal's algorithm\n  const disjointSet = new DisjointSet(points)\n  const mstEdges: Edge<T>[] = []\n\n  for (const edge of edges) {\n    if (disjointSet.union(edge.from, edge.to)) {\n      mstEdges.push(edge)\n\n      // MST has n-1 edges for n points\n      if (mstEdges.length === points.length - 1) {\n        break\n      }\n    }\n  }\n\n  return mstEdges\n}\n","import { SimpleRouteConnection, SimpleRouteJson } from \"lib/types\"\nimport { BaseSolver } from \"../BaseSolver\"\nimport { buildMinimumSpanningTree } from \"./buildMinimumSpanningTree\"\nimport { GraphicsObject } from \"graphics-debug\"\nimport { seededRandom } from \"lib/utils/cloneAndShuffleArray\"\n\n/**\n * Converts a net containing many points to connect into an array of point pair\n * connections.\n *\n * For example, a connection with 3 pointsToConnect could be turned into 2\n * connections of 2 points each.\n *\n * Where we create the minimum number of pairs, we're using a minimum spanning\n * tree (MST).\n *\n * Sometimes it can be used to add additional traces to help make sure we\n * distribute load effectively. In this version we don't do that!\n */\nexport class NetToPointPairsSolver extends BaseSolver {\n  unprocessedConnections: Array<SimpleRouteConnection>\n  newConnections: Array<SimpleRouteConnection>\n\n  constructor(\n    public ogSrj: SimpleRouteJson,\n    public colorMap: Record<string, string> = {},\n  ) {\n    super()\n    this.unprocessedConnections = [...ogSrj.connections]\n    this.newConnections = []\n  }\n\n  _step() {\n    if (this.unprocessedConnections.length === 0) {\n      this.solved = true\n      return\n    }\n    const connection = this.unprocessedConnections.pop()!\n\n    // ----------------------------------------------\n    // 1.  Detect externally-connected point groups\n    // ----------------------------------------------\n    const externalGroups = connection.externallyConnectedPointIds ?? []\n    const pointIdToGroup = new Map<string, number>()\n    externalGroups.forEach((group, idx) =>\n      group.forEach((pid) => pointIdToGroup.set(pid, idx)),\n    )\n\n    const areExternallyConnected = (\n      a: { pointId?: string },\n      b: { pointId?: string },\n    ) => {\n      if (!a.pointId || !b.pointId) return false\n      const g1 = pointIdToGroup.get(a.pointId)\n      const g2 = pointIdToGroup.get(b.pointId)\n      return g1 !== undefined && g1 === g2\n    }\n\n    if (connection.pointsToConnect.length === 2) {\n      if (\n        areExternallyConnected(\n          connection.pointsToConnect[0],\n          connection.pointsToConnect[1],\n        )\n      ) {\n        // No routing required  they are already connected off-board\n        return\n      }\n      this.newConnections.push(connection)\n      return\n    }\n\n    const edges = buildMinimumSpanningTree(connection.pointsToConnect)\n\n    let mstIdx = 0\n    for (const edge of edges) {\n      if (areExternallyConnected(edge.from, edge.to)) continue\n      this.newConnections.push({\n        pointsToConnect: [edge.from, edge.to],\n        name: `${connection.name}_mst${mstIdx++}`,\n      })\n    }\n  }\n\n  getNewSimpleRouteJson(): SimpleRouteJson {\n    return {\n      ...this.ogSrj,\n      connections: this.newConnections,\n    }\n  }\n\n  visualize(): GraphicsObject {\n    const graphics: GraphicsObject = {\n      lines: [],\n      points: [],\n      rects: [],\n      circles: [],\n      coordinateSystem: \"cartesian\",\n      title: \"Net To Point Pairs Visualization\",\n    }\n\n    // Draw unprocessed connections in red\n    this.unprocessedConnections.forEach((connection) => {\n      // Draw points\n      connection.pointsToConnect.forEach((point) => {\n        graphics.points!.push({\n          x: point.x,\n          y: point.y,\n          color: \"red\",\n          label: connection.name,\n        })\n      })\n\n      // Draw lines connecting all points in the connection\n      const fullyConnectedEdgeCount = connection.pointsToConnect.length ** 2\n      const random = seededRandom(0)\n      const alreadyPlacedEdges = new Set<string>()\n      for (\n        let i = 0;\n        i <\n        Math.max(\n          fullyConnectedEdgeCount,\n          connection.pointsToConnect.length * 2,\n        );\n        i++\n      ) {\n        const a = Math.floor(random() * connection.pointsToConnect.length)\n        const b = Math.floor(random() * connection.pointsToConnect.length)\n        if (alreadyPlacedEdges.has(`${a}-${b}`)) continue\n        alreadyPlacedEdges.add(`${a}-${b}`)\n        graphics.lines!.push({\n          points: [\n            connection.pointsToConnect[a],\n            connection.pointsToConnect[b],\n          ],\n          strokeColor: \"rgba(255,0,0,0.25)\",\n        })\n      }\n    })\n\n    // Draw processed connections with appropriate colors\n    this.newConnections.forEach((connection) => {\n      const color = this.colorMap?.[connection.name] || \"blue\"\n\n      // Draw points\n      connection.pointsToConnect.forEach((point) => {\n        graphics.points!.push({\n          x: point.x,\n          y: point.y,\n          color: color,\n          label: connection.name,\n        })\n      })\n\n      // Draw lines connecting all points in the connection\n      for (let i = 0; i < connection.pointsToConnect.length - 1; i++) {\n        for (let j = i + 1; j < connection.pointsToConnect.length; j++) {\n          graphics.lines!.push({\n            points: [\n              connection.pointsToConnect[i],\n              connection.pointsToConnect[j],\n            ],\n            strokeColor: color,\n          })\n        }\n      }\n    })\n\n    return graphics\n  }\n}\n","export type LayerName =\n  | \"top\"\n  | \"bottom\"\n  | \"inner1\"\n  | \"inner2\"\n  | \"inner3\"\n  | \"inner4\"\n  | \"inner5\"\n  | \"inner6\"\n\nexport const mapZToLayerName = (z: number, layerCount: number): LayerName => {\n  if (z < 0 || z >= layerCount) {\n    throw new Error(`Invalid z \"${z}\" for layer count: ${layerCount}`)\n  }\n\n  if (z === 0) return \"top\"\n  if (z === layerCount - 1) return \"bottom\"\n  return `inner${z}` as any\n}\n","import { SimplifiedPcbTraces } from \"lib/types\"\nimport { HighDensityIntraNodeRoute } from \"lib/types/high-density-types\"\nimport { mapZToLayerName } from \"./mapZToLayerName\"\n\ntype Point = { x: number; y: number; z: number }\n\nexport const convertHdRouteToSimplifiedRoute = (\n  hdRoute: HighDensityIntraNodeRoute,\n  layerCount: number,\n): SimplifiedPcbTraces[number][\"route\"] => {\n  const result: SimplifiedPcbTraces[number][\"route\"] = []\n  if (hdRoute.route.length === 0) return result\n\n  let currentLayerPoints: Point[] = []\n  let currentZ = hdRoute.route[0].z\n\n  // Add all points to their respective layer segments\n  for (let i = 0; i < hdRoute.route.length; i++) {\n    const point = hdRoute.route[i]\n\n    // If we're changing layers, process the current layer's points\n    // and add a via if one exists at this position\n    if (point.z !== currentZ) {\n      // Add all wire segments for the current layer\n      const layerName = mapZToLayerName(currentZ, layerCount)\n      for (const layerPoint of currentLayerPoints) {\n        result.push({\n          route_type: \"wire\",\n          x: layerPoint.x,\n          y: layerPoint.y,\n          width: hdRoute.traceThickness,\n          layer: layerName,\n        })\n      }\n\n      // Check if a via exists at this position\n      const viaExists = hdRoute.vias.some(\n        (via) =>\n          Math.abs(via.x - point.x) < 0.001 &&\n          Math.abs(via.y - point.y) < 0.001,\n      )\n\n      // Add a via if one exists\n      if (viaExists) {\n        const fromLayer = mapZToLayerName(currentZ, layerCount)\n        const toLayer = mapZToLayerName(point.z, layerCount)\n\n        result.push({\n          route_type: \"via\",\n          x: point.x,\n          y: point.y,\n          from_layer: fromLayer,\n          to_layer: toLayer,\n        })\n      }\n\n      // Start a new layer\n      currentLayerPoints = [point]\n      currentZ = point.z\n    } else {\n      // Continue on the same layer\n      currentLayerPoints.push(point)\n    }\n  }\n\n  // Add the final layer's wire segments\n  const layerName = mapZToLayerName(currentZ, layerCount)\n  for (const layerPoint of currentLayerPoints) {\n    result.push({\n      route_type: \"wire\",\n      x: layerPoint.x,\n      y: layerPoint.y,\n      width: hdRoute.traceThickness,\n      layer: layerName,\n    })\n  }\n\n  return result\n}\n","import { HighDensityIntraNodeRoute } from \"lib/types/high-density-types\"\nimport { BaseSolver } from \"../BaseSolver\"\nimport { GraphicsObject } from \"graphics-debug\"\nimport { distance } from \"@tscircuit/math-utils\"\n\nexport class SingleHighDensityRouteStitchSolver extends BaseSolver {\n  mergedHdRoute: HighDensityIntraNodeRoute\n  remainingHdRoutes: HighDensityIntraNodeRoute[]\n  start: { x: number; y: number; z: number }\n  end: { x: number; y: number; z: number }\n  colorMap: Record<string, string>\n\n  constructor(opts: {\n    connectionName: string\n    hdRoutes: HighDensityIntraNodeRoute[]\n    start: { x: number; y: number; z: number }\n    end: { x: number; y: number; z: number }\n    colorMap?: Record<string, string>\n    defaultTraceThickness?: number\n    defaultViaDiameter?: number\n  }) {\n    super()\n    this.remainingHdRoutes = [...opts.hdRoutes]\n    this.colorMap = opts.colorMap ?? {} // Store colorMap, default to empty object\n\n    if (opts.hdRoutes.length === 0) {\n      this.start = opts.start\n      this.end = opts.end\n      const routePoints = [\n        { x: opts.start.x, y: opts.start.y, z: opts.start.z },\n      ]\n      const vias = []\n\n      if (opts.start.z !== opts.end.z) {\n        // If layers are different, add a via at the start point and a segment on the new layer\n        routePoints.push({ x: opts.start.x, y: opts.start.y, z: opts.end.z })\n        vias.push({ x: opts.start.x, y: opts.start.y })\n      }\n      routePoints.push({ x: opts.end.x, y: opts.end.y, z: opts.end.z })\n\n      this.mergedHdRoute = {\n        connectionName: opts.connectionName,\n        route: routePoints,\n        vias: vias,\n        viaDiameter: opts.defaultViaDiameter ?? 0.6, // Use default or fallback\n        traceThickness: opts.defaultTraceThickness ?? 0.15, // Use default or fallback\n      }\n      this.solved = true\n      return // Early exit as there's nothing to stitch\n    }\n\n    const { firstRoute } = this.getDisjointedRoute()\n\n    const firstRouteToStartDist = Math.min(\n      distance(firstRoute.route[0], opts.start),\n      distance(firstRoute.route[firstRoute.route.length - 1], opts.start),\n    )\n    const firstRouteToEndDist = Math.min(\n      distance(firstRoute.route[0], opts.end),\n      distance(firstRoute.route[firstRoute.route.length - 1], opts.end),\n    )\n\n    if (firstRouteToStartDist < firstRouteToEndDist) {\n      this.start = opts.start\n      this.end = opts.end\n    } else {\n      this.start = opts.end\n      this.end = opts.start\n    }\n\n    this.mergedHdRoute = {\n      connectionName: opts.connectionName, // Use mandatory connectionName\n      route: [\n        {\n          x: this.start.x,\n          y: this.start.y,\n          z: this.start.z,\n        },\n      ],\n      vias: [],\n      viaDiameter: firstRoute.viaDiameter,\n      traceThickness: firstRoute.traceThickness,\n    }\n  }\n\n  /**\n   * Scan `remainingHdRoutes` and find a route that has **one** end that is not\n   * within `5e-6` of the start or end of any other route on the same layer.\n   * That lonely end marks one extremity of the whole chain, which we use as\n   * our starting segment. If no such route exists (e.g., the data form a loop),\n   * we simply return the first route so the solver can proceed.\n   */\n  getDisjointedRoute() {\n    const TOL = 5e-6\n\n    for (const candidate of this.remainingHdRoutes) {\n      const candidateEnds = [\n        candidate.route[0],\n        candidate.route[candidate.route.length - 1],\n      ]\n\n      // true if at least one end of `candidate` is not matched by any other route\n      const hasLonelyEnd = candidateEnds.some((end) => {\n        // Look through every *other* route and its two ends\n        return !this.remainingHdRoutes.some((other) => {\n          if (other === candidate) return false\n          const otherEnds = [\n            other.route[0],\n            other.route[other.route.length - 1],\n          ]\n          return otherEnds.some(\n            (oe) => oe.z === end.z && distance(end, oe) < TOL,\n          )\n        })\n      })\n\n      if (hasLonelyEnd) {\n        return { firstRoute: candidate }\n      }\n    }\n\n    // Degenerate case: everything is paired (forms a loop)  just pick the first route\n    return { firstRoute: this.remainingHdRoutes[0] }\n  }\n\n  _step() {\n    if (this.remainingHdRoutes.length === 0) {\n      // Add the end point to the merged route\n      this.mergedHdRoute.route.push({\n        x: this.end.x,\n        y: this.end.y,\n        z: this.end.z,\n      })\n      this.solved = true\n      return\n    }\n\n    const lastMergedPoint =\n      this.mergedHdRoute.route[this.mergedHdRoute.route.length - 1]\n\n    // Find the next logical route to merge\n    // 1. We need to check both the first and last points of the remaining routes\n    // 2. If the last point is closest, we need to reverse the hd route before merging\n    // 3. After merging, we remove it from the remaining routes\n\n    let closestRouteIndex = 0\n    let matchedOn: \"first\" | \"last\" = \"first\"\n    let closestDistance = Infinity\n    for (let i = 0; i < this.remainingHdRoutes.length; i++) {\n      const hdRoute = this.remainingHdRoutes[i]\n      const lastPointInCandidate = hdRoute.route[hdRoute.route.length - 1]\n      const firstPointInCandidate = hdRoute.route[0]\n      const distToFirst = distance(lastMergedPoint, firstPointInCandidate)\n      const distToLast = distance(lastMergedPoint, lastPointInCandidate)\n      if (\n        distToFirst < closestDistance &&\n        lastMergedPoint.z === firstPointInCandidate.z\n      ) {\n        closestDistance = distToFirst\n        closestRouteIndex = i\n        matchedOn = \"first\"\n      }\n      if (\n        distToLast < closestDistance &&\n        lastMergedPoint.z === lastPointInCandidate.z\n      ) {\n        closestDistance = distToLast\n        closestRouteIndex = i\n        matchedOn = \"last\"\n      }\n    }\n\n    const hdRouteToMerge = this.remainingHdRoutes[closestRouteIndex]\n    this.remainingHdRoutes.splice(closestRouteIndex, 1)\n\n    if (matchedOn === \"first\") {\n      this.mergedHdRoute.route.push(...hdRouteToMerge.route)\n    } else {\n      this.mergedHdRoute.route.push(...[...hdRouteToMerge.route].reverse())\n    }\n\n    this.mergedHdRoute.vias.push(...hdRouteToMerge.vias)\n  }\n\n  visualize(): GraphicsObject {\n    const graphics: GraphicsObject = {\n      points: [],\n      lines: [],\n      circles: [],\n      title: \"Single High Density Route Stitch Solver\",\n    }\n\n    // Visualize start and end points\n    graphics.points?.push(\n      {\n        x: this.start.x,\n        y: this.start.y,\n        color: \"green\",\n        label: \"Start\",\n      },\n      {\n        x: this.end.x,\n        y: this.end.y,\n        color: \"red\",\n        label: \"End\",\n      },\n    )\n\n    // Visualize the merged HD route in green\n    if (this.mergedHdRoute && this.mergedHdRoute.route.length > 1) {\n      graphics.lines?.push({\n        points: this.mergedHdRoute.route.map((point) => ({\n          x: point.x,\n          y: point.y,\n        })),\n        strokeColor: \"green\",\n      })\n\n      // Add points for the merged route\n      for (const point of this.mergedHdRoute.route) {\n        graphics.points?.push({\n          x: point.x,\n          y: point.y,\n          color: \"green\",\n        })\n      }\n\n      // Visualize vias in the merged route\n      for (const via of this.mergedHdRoute.vias) {\n        graphics.circles?.push({\n          center: { x: via.x, y: via.y },\n          radius: this.mergedHdRoute.viaDiameter / 2,\n          fill: \"green\",\n        })\n      }\n    }\n\n    // Visualize all remaining HD routes using colorMap\n    for (const [i, hdRoute] of this.remainingHdRoutes.entries()) {\n      const routeColor = this.colorMap[hdRoute.connectionName] ?? \"gray\" // Default to gray if not in map\n      if (hdRoute.route.length > 1) {\n        // Create a line for the route\n        graphics.lines?.push({\n          points: hdRoute.route.map((point) => ({ x: point.x, y: point.y })),\n          strokeColor: routeColor,\n        })\n      }\n\n      // Add points for each route node\n      for (let pi = 0; pi < hdRoute.route.length; pi++) {\n        const point = hdRoute.route[pi]\n        graphics.points?.push({\n          x: point.x + ((i % 2) - 0.5) / 500 + ((pi % 8) - 4) / 1000, // Keep slight offset for visibility\n          y: point.y + ((i % 2) - 0.5) / 500 + ((pi % 8) - 4) / 1000,\n          color: routeColor,\n          label: `Route ${hdRoute.connectionName} ${point === hdRoute.route[0] ? \"First\" : point === hdRoute.route[hdRoute.route.length - 1] ? \"Last\" : \"\"}`,\n        })\n      }\n\n      // Visualize vias\n      for (const via of hdRoute.vias) {\n        graphics.circles?.push({\n          center: { x: via.x, y: via.y },\n          radius: hdRoute.viaDiameter / 2,\n          fill: routeColor,\n        })\n      }\n    }\n\n    return graphics\n  }\n}\n","import { SimpleRouteConnection } from \"lib/types\"\nimport { HighDensityIntraNodeRoute } from \"lib/types/high-density-types\"\nimport { BaseSolver } from \"../BaseSolver\"\nimport { mapLayerNameToZ } from \"lib/utils/mapLayerNameToZ\"\nimport { SingleHighDensityRouteStitchSolver } from \"./SingleHighDensityRouteStitchSolver\"\nimport { GraphicsObject } from \"graphics-debug\"\nimport { safeTransparentize } from \"../colors\"\n\nexport type UnsolvedRoute = {\n  connectionName: string\n  hdRoutes: HighDensityIntraNodeRoute[]\n  start: { x: number; y: number; z: number }\n  end: { x: number; y: number; z: number }\n}\n\nexport class MultipleHighDensityRouteStitchSolver extends BaseSolver {\n  unsolvedRoutes: UnsolvedRoute[]\n  activeSolver: SingleHighDensityRouteStitchSolver | null = null\n  mergedHdRoutes: HighDensityIntraNodeRoute[] = []\n  colorMap: Record<string, string> = {}\n  defaultTraceThickness: number\n  defaultViaDiameter: number\n\n  constructor(opts: {\n    connections: SimpleRouteConnection[]\n    hdRoutes: HighDensityIntraNodeRoute[]\n    colorMap?: Record<string, string>\n    layerCount: number\n  }) {\n    super()\n    this.colorMap = opts.colorMap ?? {}\n\n    if (opts.hdRoutes.length > 0) {\n      this.defaultTraceThickness = opts.hdRoutes[0].traceThickness\n      this.defaultViaDiameter = opts.hdRoutes[0].viaDiameter\n    } else {\n      // Fallback defaults if no hdRoutes are provided at all\n      this.defaultTraceThickness = 0.15\n      this.defaultViaDiameter = 0.6\n    }\n\n    this.unsolvedRoutes = opts.connections.map((c) => ({\n      connectionName: c.name,\n      hdRoutes: opts.hdRoutes.filter((r) => r.connectionName === c.name),\n      start: {\n        ...c.pointsToConnect[0],\n        z: mapLayerNameToZ(c.pointsToConnect[0].layer, opts.layerCount),\n      },\n      end: {\n        ...c.pointsToConnect[1],\n        z: mapLayerNameToZ(c.pointsToConnect[1].layer, opts.layerCount),\n      },\n    }))\n    this.MAX_ITERATIONS = 100e3\n  }\n\n  _step() {\n    if (this.activeSolver) {\n      this.activeSolver.step()\n      if (this.activeSolver.solved) {\n        this.mergedHdRoutes.push(this.activeSolver.mergedHdRoute)\n        this.activeSolver = null\n      } else if (this.activeSolver.failed) {\n        this.failed = true\n        this.error = this.activeSolver.error\n      }\n      return\n    }\n\n    const unsolvedRoute = this.unsolvedRoutes.pop()\n\n    if (!unsolvedRoute) {\n      this.solved = true\n      return\n    }\n\n    this.activeSolver = new SingleHighDensityRouteStitchSolver({\n      connectionName: unsolvedRoute.connectionName,\n      hdRoutes: unsolvedRoute.hdRoutes,\n      start: unsolvedRoute.start,\n      end: unsolvedRoute.end,\n      colorMap: this.colorMap,\n      defaultTraceThickness: this.defaultTraceThickness,\n      defaultViaDiameter: this.defaultViaDiameter,\n    })\n  }\n\n  visualize(): GraphicsObject {\n    const graphics: GraphicsObject = {\n      points: [],\n      lines: [],\n      circles: [],\n      title: \"Multiple High Density Route Stitch Solver\",\n    }\n\n    // Visualize the active solver if one exists\n    if (this.activeSolver) {\n      // Combine visualizations from the active solver\n      const activeSolverGraphics = this.activeSolver.visualize()\n\n      // Merge points\n      if (activeSolverGraphics.points?.length) {\n        graphics.points?.push(...activeSolverGraphics.points)\n      }\n\n      // Merge lines\n      if (activeSolverGraphics.lines?.length) {\n        graphics.lines?.push(...activeSolverGraphics.lines)\n      }\n\n      // Merge circles\n      if (activeSolverGraphics.circles?.length) {\n        graphics.circles?.push(...activeSolverGraphics.circles)\n      }\n\n      // Merge rects if they exist\n      if (activeSolverGraphics.rects?.length) {\n        graphics.rects = activeSolverGraphics.rects\n      }\n    }\n\n    // Visualize all merged HD routes that have been solved\n    for (const [i, mergedRoute] of this.mergedHdRoutes.entries()) {\n      const solvedColor =\n        this.colorMap[mergedRoute.connectionName] ??\n        `hsl(120, 100%, ${40 + ((i * 10) % 40)}%)` // Different shades of green\n\n      // Visualize the route path segment by segment\n      for (let j = 0; j < mergedRoute.route.length - 1; j++) {\n        const p1 = mergedRoute.route[j]\n        const p2 = mergedRoute.route[j + 1]\n        const segmentColor =\n          p1.z !== 0 ? safeTransparentize(solvedColor, 0.5) : solvedColor\n\n        graphics.lines?.push({\n          points: [\n            { x: p1.x, y: p1.y },\n            { x: p2.x, y: p2.y },\n          ],\n          strokeColor: segmentColor,\n          strokeWidth: mergedRoute.traceThickness,\n        })\n      }\n\n      // Visualize route points (apply transparency based on Z)\n      for (const point of mergedRoute.route) {\n        const pointColor =\n          point.z !== 0 ? safeTransparentize(solvedColor, 0.5) : solvedColor\n        graphics.points?.push({\n          x: point.x,\n          y: point.y,\n          color: pointColor,\n        })\n      }\n\n      // Visualize vias in the merged route (Vias inherently connect layers, keep solid for now)\n      // TODO: Consider if via transparency should depend on connected layers\n      for (const via of mergedRoute.vias) {\n        graphics.circles?.push({\n          center: { x: via.x, y: via.y },\n          radius: mergedRoute.viaDiameter / 2,\n          fill: solvedColor, // Keep vias solid color for visibility\n        })\n      }\n    }\n\n    // Visualize all remaining unsolved routes - start/end points only\n    for (const unsolvedRoute of this.unsolvedRoutes) {\n      const routeColor = this.colorMap[unsolvedRoute.connectionName] ?? \"gray\" // Use colorMap, default to gray\n\n      // Add start and end points for unsolved connections\n      graphics.points?.push(\n        {\n          x: unsolvedRoute.start.x,\n          y: unsolvedRoute.start.y,\n          color: routeColor,\n          label: `${unsolvedRoute.connectionName} Start (z=${unsolvedRoute.start.z})`,\n        },\n        {\n          x: unsolvedRoute.end.x,\n          y: unsolvedRoute.end.y,\n          color: routeColor,\n          label: `${unsolvedRoute.connectionName} End (z=${unsolvedRoute.end.z})`,\n        },\n      )\n\n      // Add a light dashed line between start and end to show pending connections\n      graphics.lines?.push({\n        points: [\n          { x: unsolvedRoute.start.x, y: unsolvedRoute.start.y },\n          { x: unsolvedRoute.end.x, y: unsolvedRoute.end.y },\n        ],\n        strokeColor: routeColor,\n        strokeDash: \"2 2\",\n      })\n\n      // Visualize HD routes associated with unsolved routes (faded)\n      for (const hdRoute of unsolvedRoute.hdRoutes) {\n        if (hdRoute.route.length > 1) {\n          graphics.lines?.push({\n            points: hdRoute.route.map((point) => ({ x: point.x, y: point.y })),\n            strokeColor: safeTransparentize(routeColor, 0.5), // Use routeColor\n            strokeDash: \"10 5\",\n          })\n        }\n\n        // Visualize vias\n        for (const via of hdRoute.vias) {\n          graphics.circles?.push({\n            center: { x: via.x, y: via.y },\n            radius: hdRoute.viaDiameter / 2,\n            fill: routeColor, // Use routeColor\n          })\n        }\n      }\n    }\n\n    return graphics\n  }\n}\n","import { Rect, Line, Circle, Point } from \"graphics-debug\"\nimport { SimpleRouteJson } from \"lib/types\"\nimport { getColorMap, safeTransparentize } from \"lib/solvers/colors\"\nimport { mapZToLayerName } from \"lib/utils/mapZToLayerName\"\nimport { mapLayerNameToZ } from \"lib/utils/mapLayerNameToZ\"\n\nexport const convertSrjToGraphicsObject = (srj: SimpleRouteJson) => {\n  const lines: Line[] = []\n  const circles: Circle[] = []\n  const points: Point[] = []\n\n  const colorMap: Record<string, string> = getColorMap(srj)\n  const layerCount = 2\n\n  // Add points for each connection's pointsToConnect\n  if (srj.connections) {\n    for (const connection of srj.connections) {\n      for (const point of connection.pointsToConnect) {\n        points.push({\n          x: point.x,\n          y: point.y,\n          color: colorMap[connection.name]!,\n          layer:\n            point.layer ??\n            (\"z\" in point\n              ? mapZToLayerName(point.z as number, layerCount)\n              : \"top\"),\n          label: `${connection.name} (${point.layer})`,\n        })\n      }\n    }\n  }\n\n  // Process each trace\n  if (srj.traces) {\n    for (const trace of srj.traces) {\n      for (let j = 0; j < trace.route.length - 1; j++) {\n        const routePoint = trace.route[j]\n        const nextRoutePoint = trace.route[j + 1]\n\n        if (routePoint.route_type === \"via\") {\n          // Add a circle for the via\n          circles.push({\n            center: { x: routePoint.x, y: routePoint.y },\n            radius: 0.3, // 0.6 via diameter\n            fill: \"blue\",\n            stroke: \"none\",\n            layer: \"z0,1\",\n          })\n        } else if (\n          routePoint.route_type === \"wire\" &&\n          nextRoutePoint.route_type === \"wire\" &&\n          nextRoutePoint.layer === routePoint.layer\n        ) {\n          // Create a line between consecutive wire segments on the same layer\n          lines.push({\n            points: [\n              { x: routePoint.x, y: routePoint.y },\n              { x: nextRoutePoint.x, y: nextRoutePoint.y },\n            ],\n            layer: `z${mapLayerNameToZ(routePoint.layer, layerCount)}`,\n            strokeWidth: 0.15,\n            strokeColor: safeTransparentize(\n              {\n                top: \"red\",\n                bottom: \"blue\",\n                inner1: \"green\",\n                inner2: \"yellow\",\n              }[routePoint.layer]!,\n              0.5,\n            ),\n            // For some reason this is too small, likely a graphics-debug bug\n            // strokeWidth: 0.15,\n          })\n        }\n      }\n    }\n  }\n\n  return {\n    rects: srj.obstacles.map(\n      (o) =>\n        ({\n          center: o.center,\n          width: o.width,\n          height: o.height,\n          fill: \"rgba(255,0,0,0.5)\",\n          layer: `z${o.layers.map(mapLayerNameToZ).join(\",\")}`,\n        }) as Rect,\n    ),\n    circles,\n    lines,\n    points,\n  }\n}\n","import { CapacityMeshNodeId } from \"lib/types\"\n\nexport function getNodesNearNode(params: {\n  nodeId: CapacityMeshNodeId\n  nodeIdToSegmentIds: Map<CapacityMeshNodeId, CapacityMeshNodeId[]>\n  segmentIdToNodeIds: Map<CapacityMeshNodeId, CapacityMeshNodeId[]>\n  hops: number\n}): CapacityMeshNodeId[] {\n  const { nodeId, nodeIdToSegmentIds, segmentIdToNodeIds, hops } = params\n\n  if (hops === 0) return [nodeId]\n\n  const visitedNodes = new Set<CapacityMeshNodeId>([nodeId])\n  const exploreQueue: Array<{\n    nodeId: CapacityMeshNodeId\n    remainingHops: number\n  }> = [{ nodeId: nodeId, remainingHops: hops }]\n\n  while (exploreQueue.length > 0) {\n    const { nodeId: node, remainingHops } = exploreQueue.shift()!\n\n    if (remainingHops === 0) continue\n\n    const segments = nodeIdToSegmentIds.get(node) || []\n    for (const segmentId of segments) {\n      const adjacentNodeIds = segmentIdToNodeIds.get(segmentId) || []\n      for (const adjacentNodeId of adjacentNodeIds) {\n        if (!visitedNodes.has(adjacentNodeId)) {\n          visitedNodes.add(adjacentNodeId)\n          exploreQueue.push({\n            nodeId: adjacentNodeId,\n            remainingHops: remainingHops - 1,\n          })\n        }\n      }\n    }\n  }\n\n  return Array.from(visitedNodes)\n}\n","import { SegmentPointId } from \"./types\"\n\nexport const createPointModificationsHash = (\n  pointModifications: Map<\n    SegmentPointId,\n    { x?: number; y?: number; z?: number }\n  >,\n) => {\n  return Array.from(pointModifications.entries())\n    .map(\n      ([id, { x, y, z }]) =>\n        `${id}(${x?.toFixed(3) ?? \"\"},${y?.toFixed(3) ?? \"\"},${z ?? \"\"})`,\n    )\n    .sort()\n    .join(\"&\")\n}\n\nexport const createFullPointModificationsHash = (\n  originalPoints: Map<SegmentPointId, { x: number; y: number; z: number }>,\n  pointModifications: Map<\n    SegmentPointId,\n    { x?: number; y?: number; z?: number }\n  >,\n) => {\n  return Array.from(originalPoints.entries())\n    .map(([id, originalPoint]) => {\n      const mods = pointModifications.get(id)\n      const finalPoint = {\n        x: mods?.x !== undefined ? mods.x : originalPoint.x,\n        y: mods?.y !== undefined ? mods.y : originalPoint.y,\n        z: mods?.z !== undefined ? mods.z : originalPoint.z,\n      }\n      return `${id}(${finalPoint.x.toFixed(3)},${finalPoint.y.toFixed(3)},${finalPoint.z})`\n    })\n    .sort()\n    .join(\"&\")\n}\n","export const hasZRangeOverlap = (\n  A_z1: number,\n  A_z2: number,\n  B_z1: number,\n  B_z2: number,\n) => {\n  const Amin = Math.min(A_z1, A_z2)\n  const Amax = Math.max(A_z1, A_z2)\n  const Bmin = Math.min(B_z1, B_z2)\n  const Bmax = Math.max(B_z1, B_z2)\n  return Amin <= Bmax && Amax >= Bmin\n}\n","import { CapacityMeshNode, CapacityMeshNodeId } from \"lib/types\"\nimport {\n  UnravelSection,\n  UnravelIssue,\n  UnravelTransitionViaIssue,\n  SegmentPoint,\n  SegmentPointId,\n  UnravelSameLayerCrossingIssue,\n  UnravelSingleTransitionCrossingIssue,\n  UnravelDoubleTransitionCrossingIssue,\n} from \"./types\"\nimport { getIntraNodeCrossingsFromSegments } from \"lib/utils/getIntraNodeCrossingsFromSegments\"\nimport { getTunedTotalCapacity1 } from \"lib/utils/getTunedTotalCapacity1\"\nimport { doSegmentsIntersect } from \"@tscircuit/math-utils\"\nimport { ConnectivityMap } from \"circuit-json-to-connectivity-map\"\nimport { hasZRangeOverlap } from \"./hasZRangeOverlap\"\n\nexport const getIssuesInSection = (\n  section: UnravelSection,\n  nodeMap: Map<CapacityMeshNodeId, CapacityMeshNode>,\n  pointModifications: Map<\n    SegmentPointId,\n    { x?: number; y?: number; z?: number }\n  >,\n  connMap?: ConnectivityMap,\n): UnravelIssue[] => {\n  const issues: UnravelIssue[] = []\n\n  const points: Map<SegmentPointId, { x: number; y: number; z: number }> =\n    new Map(section.originalPointMap)\n  for (const [segmentPointId, modPoint] of pointModifications.entries()) {\n    const ogPoint = points.get(segmentPointId)!\n    points.set(segmentPointId, {\n      x: modPoint.x ?? ogPoint.x,\n      y: modPoint.y ?? ogPoint.y,\n      z: modPoint.z ?? ogPoint.z,\n    })\n  }\n\n  for (const nodeId of section.allNodeIds) {\n    const node = nodeMap.get(nodeId)\n    if (!node) continue\n\n    const nodeSegmentPairs = section.segmentPairsInNode.get(nodeId)!\n\n    // If there's a Z transition within the pair, there's a transition_via issue\n    for (const pair of nodeSegmentPairs) {\n      const A = points.get(pair[0])!\n      const B = points.get(pair[1])!\n      if (A.z !== B.z) {\n        issues.push({\n          type: \"transition_via\",\n          segmentPoints: pair,\n          capacityMeshNodeId: nodeId,\n          probabilityOfFailure: 0,\n        })\n      }\n    }\n\n    // Find crossing issues\n    for (let i = 0; i < nodeSegmentPairs.length; i++) {\n      for (let j = i + 1; j < nodeSegmentPairs.length; j++) {\n        if (\n          connMap?.areIdsConnected(\n            nodeSegmentPairs[i][0],\n            nodeSegmentPairs[i][1],\n          )\n        ) {\n          continue\n        }\n\n        const pair1 = nodeSegmentPairs[i]\n        const pair2 = nodeSegmentPairs[j]\n\n        const A = points.get(pair1[0])!\n        const B = points.get(pair1[1])!\n        const C = points.get(pair2[0])!\n        const D = points.get(pair2[1])!\n\n        // Are the lines ever on the same layer? Is there any risk of overlap?\n        if (!hasZRangeOverlap(A.z, B.z, C.z, D.z)) continue\n\n        const areCrossing = doSegmentsIntersect(A, B, C, D)\n        const isSameLayer = A.z === B.z && C.z === D.z && A.z === C.z\n        if (areCrossing) {\n          if (isSameLayer) {\n            issues.push({\n              type: \"same_layer_crossing\",\n              segmentPoints: [pair1, pair2],\n              capacityMeshNodeId: nodeId,\n              crossingLine1: pair1,\n              crossingLine2: pair2,\n              probabilityOfFailure: 0,\n            } as UnravelSameLayerCrossingIssue)\n          } else if (A.z === B.z && C.z !== D.z) {\n            issues.push({\n              type: \"single_transition_crossing\",\n              segmentPoints: [pair1, pair2],\n              capacityMeshNodeId: nodeId,\n              sameLayerCrossingLine: pair1,\n              transitionCrossingLine: pair2,\n              probabilityOfFailure: 0,\n            } as UnravelSingleTransitionCrossingIssue)\n          } else if (A.z !== B.z && C.z === D.z) {\n            issues.push({\n              type: \"single_transition_crossing\",\n              segmentPoints: [pair1, pair2],\n              capacityMeshNodeId: nodeId,\n              sameLayerCrossingLine: pair2,\n              transitionCrossingLine: pair1,\n              probabilityOfFailure: 0,\n            } as UnravelSingleTransitionCrossingIssue)\n          } else if (A.z !== B.z && C.z !== D.z) {\n            issues.push({\n              type: \"double_transition_crossing\",\n              segmentPoints: [pair1, pair2],\n              capacityMeshNodeId: nodeId,\n              crossingLine1: pair1,\n              crossingLine2: pair2,\n              probabilityOfFailure: 0,\n            } as UnravelDoubleTransitionCrossingIssue)\n          }\n        }\n      }\n    }\n  }\n\n  return issues\n}\n","import { SegmentPointId, UnravelOperation } from \"./types\"\n\n/**\n * Applies an operation to the point modifications map\n * @param pointModifications The current point modifications map\n * @param operation The operation to apply\n * @param getPointInCandidate Function to get the current point values (with any existing modifications)\n * @returns The modified point modifications map\n */\nexport const applyOperationToPointModifications = (\n  pointModifications: Map<\n    SegmentPointId,\n    { x?: number; y?: number; z?: number }\n  >,\n  operation: UnravelOperation,\n  getPointInCandidate: (segmentPointId: SegmentPointId) => {\n    x: number\n    y: number\n    z: number\n    segmentId: string\n  },\n) => {\n  if (operation.type === \"change_layer\") {\n    for (const segmentPointId of operation.segmentPointIds) {\n      const existingMods = pointModifications.get(segmentPointId) || {}\n      pointModifications.set(segmentPointId, {\n        ...existingMods,\n        z: operation.newZ,\n      })\n    }\n  } else if (operation.type === \"swap_position_on_segment\") {\n    const [ASpId, BSpId] = operation.segmentPointIds\n    const A = getPointInCandidate(ASpId)\n    const B = getPointInCandidate(BSpId)\n\n    const existingModsA = pointModifications.get(ASpId) || {}\n    const existingModsB = pointModifications.get(BSpId) || {}\n\n    pointModifications.set(ASpId, {\n      ...existingModsA,\n      x: B.x,\n      y: B.y,\n    })\n\n    pointModifications.set(BSpId, {\n      ...existingModsB,\n      x: A.x,\n      y: A.y,\n    })\n  } else if (operation.type === \"combined\") {\n    // For combined operations, recursively apply each operation\n    for (const subOperation of operation.operations) {\n      // Apply each sub-operation directly to the modifications\n      applyOperationToPointModifications(\n        pointModifications,\n        subOperation,\n        getPointInCandidate,\n      )\n    }\n  }\n}\n","import { CapacityMeshNodeId } from \"lib/types\"\nimport { SegmentWithAssignedPoints } from \"../CapacityMeshSolver/CapacitySegmentToPointSolver\"\nimport {\n  SegmentId,\n  SegmentPoint,\n  SegmentPointId,\n  SegmentPointMap,\n} from \"./types\"\n\nexport type SegmentPointMapAndReverseMaps = {\n  segmentPointMap: SegmentPointMap\n  nodeToSegmentPointMap: Map<CapacityMeshNodeId, SegmentPointId[]>\n  segmentToSegmentPointMap: Map<SegmentId, SegmentPointId[]>\n}\n\nexport const createSegmentPointMap = (\n  dedupedSegments: SegmentWithAssignedPoints[],\n  segmentIdToNodeIds: Map<SegmentId, CapacityMeshNodeId[]>,\n): SegmentPointMapAndReverseMaps => {\n  const segmentPointMap: SegmentPointMap = new Map()\n  const nodeToSegmentPointMap: Map<CapacityMeshNodeId, SegmentPointId[]> =\n    new Map()\n  const segmentToSegmentPointMap: Map<SegmentId, SegmentPointId[]> = new Map()\n\n  const segmentPoints: SegmentPoint[] = []\n  let highestSegmentPointId = 0\n  for (const segment of dedupedSegments) {\n    for (const point of segment.assignedPoints!) {\n      const sp = {\n        segmentPointId: `SP${highestSegmentPointId++}`,\n        segmentId: segment.nodePortSegmentId!,\n        capacityMeshNodeIds: segmentIdToNodeIds.get(\n          segment.nodePortSegmentId!,\n        )!,\n        connectionName: point.connectionName,\n        x: point.point.x,\n        y: point.point.y,\n        z: point.point.z,\n        directlyConnectedSegmentPointIds: [],\n      }\n\n      segmentPointMap.set(sp.segmentPointId, sp)\n      for (const nodeId of sp.capacityMeshNodeIds) {\n        nodeToSegmentPointMap.set(nodeId, [\n          ...(nodeToSegmentPointMap.get(nodeId) ?? []),\n          sp.segmentPointId,\n        ])\n      }\n\n      segmentToSegmentPointMap.set(segment.nodePortSegmentId!, [\n        ...(segmentToSegmentPointMap.get(segment.nodePortSegmentId!) ?? []),\n        sp.segmentPointId,\n      ])\n\n      segmentPoints.push(sp)\n    }\n  }\n\n  return {\n    segmentPointMap,\n    nodeToSegmentPointMap,\n    segmentToSegmentPointMap,\n  }\n}\n","import { CapacityMeshNode } from \"lib/types\"\nimport { getTunedTotalCapacity1 } from \"lib/utils/getTunedTotalCapacity1\"\n\nexport const calculateNodeProbabilityOfFailure = (\n  node: CapacityMeshNode,\n  numSameLayerCrossings: number,\n  numEntryExitLayerChanges: number,\n  numTransitionCrossings: number,\n): number => {\n  if (node?._containsTarget) return 0\n\n  // Number of traces through the node\n  const totalCapacity = getTunedTotalCapacity1(node)\n\n  // Estimated number of vias based on crossings\n  const estNumVias =\n    numSameLayerCrossings * 0.82 +\n    numEntryExitLayerChanges * 0.41 +\n    numTransitionCrossings * 0.2\n\n  const estUsedCapacity = (estNumVias / 2) ** 1.1\n\n  // We could refine this with actual trace capacity\n  const approxProb = estUsedCapacity / totalCapacity\n\n  // Bounded probability calculation\n  return approxProb\n}\n","import { CapacityMeshNode, CapacityMeshNodeId } from \"lib/types\"\nimport { BaseSolver } from \"../BaseSolver\"\nimport { SegmentWithAssignedPoints } from \"../CapacityMeshSolver/CapacitySegmentToPointSolver\"\nimport {\n  UnravelSection,\n  UnravelCandidate,\n  SegmentPoint,\n  SegmentPointId,\n  SegmentId,\n  UnravelOperation,\n  UnravelIssue,\n  SegmentPointMap,\n} from \"./types\"\nimport { getNodesNearNode } from \"./getNodesNearNode\"\nimport { GraphicsObject } from \"graphics-debug\"\nimport {\n  createFullPointModificationsHash,\n  createPointModificationsHash,\n} from \"./createPointModificationsHash\"\nimport { getIssuesInSection } from \"./getIssuesInSection\"\nimport { getTunedTotalCapacity1 } from \"lib/utils/getTunedTotalCapacity1\"\nimport { applyOperationToPointModifications } from \"./applyOperationToPointModifications\"\nimport {\n  createSegmentPointMap,\n  SegmentPointMapAndReverseMaps,\n} from \"./createSegmentPointMap\"\nimport { calculateNodeProbabilityOfFailure } from \"./calculateCrossingProbabilityOfFailure\"\nimport { PointModificationsMap } from \"./types\"\n\nexport interface UnravelSectionHyperParameters {\n  MAX_ITERATIONS_WITHOUT_IMPROVEMENT: number\n}\n\ninterface UnravelSectionSolverParams {\n  rootNodeId: CapacityMeshNodeId\n  colorMap?: Record<string, string>\n  MUTABLE_HOPS?: number\n  nodeMap: Map<CapacityMeshNodeId, CapacityMeshNode>\n  dedupedSegments: SegmentWithAssignedPoints[]\n  dedupedSegmentMap?: Map<SegmentId, SegmentWithAssignedPoints>\n  nodeIdToSegmentIds: Map<CapacityMeshNodeId, CapacityMeshNodeId[]>\n  segmentIdToNodeIds: Map<CapacityMeshNodeId, CapacityMeshNodeId[]>\n  segmentPointMap?: SegmentPointMap\n  nodeToSegmentPointMap?: Map<CapacityMeshNodeId, SegmentPointId[]>\n  segmentToSegmentPointMap?: Map<SegmentId, SegmentPointId[]>\n  hyperParameters?: Partial<UnravelSectionHyperParameters>\n}\n\n/**\n * The UntangleSectionSolver optimizes a section of connected capacity nodes\n * with their deduplicated segments.\n *\n * The section always has a \"root\" node. From the root node, MUTABLE_HOPS are\n * taken to reach other nodes that are mutable. One additional hop is taken to\n * have all the impacted nodes in section. So a section is composed of mutable\n * and immutable nodes.\n *\n * The goal of the solver is to perform operations on the mutable nodes of the\n * section to lower the overall cost of the section.\n *\n * The untangle phase will perform \"operations\" on segments based on \"issues\"\n *\n * An \"issue\" is anything that increases the cost of the node:\n * - Anything that causes a via (e.g. layer transition)\n * - Any time two traces cross on the same layer\n *\n * An operation is a change to a segment. There are two main operations:\n * - Change layer\n * - Change point order on segment\n *\n * This solver works by exploring different paths of operations. When an\n * operation is performed, new issues are created. Each path has a cost, and\n * a set of neighbors representing next operations to perform.\n *\n */\nexport class UnravelSectionSolver extends BaseSolver {\n  nodeMap: Map<CapacityMeshNodeId, CapacityMeshNode>\n  dedupedSegments: SegmentWithAssignedPoints[]\n  dedupedSegmentMap: Map<SegmentId, SegmentWithAssignedPoints>\n\n  MUTABLE_HOPS = 1\n\n  unravelSection: UnravelSection\n\n  candidates: UnravelCandidate[] = []\n\n  lastProcessedCandidate: UnravelCandidate | null = null\n  bestCandidate: UnravelCandidate | null = null\n  originalCandidate: UnravelCandidate\n\n  rootNodeId: CapacityMeshNodeId\n  nodeIdToSegmentIds: Map<CapacityMeshNodeId, CapacityMeshNodeId[]>\n  segmentIdToNodeIds: Map<CapacityMeshNodeId, CapacityMeshNodeId[]>\n  colorMap: Record<string, string>\n  tunedNodeCapacityMap: Map<CapacityMeshNodeId, number>\n  MAX_CANDIDATES = 500\n  iterationsSinceImprovement = 0\n\n  hyperParameters: UnravelSectionHyperParameters\n\n  selectedCandidateIndex: number | \"best\" | \"original\" | null = null\n\n  queuedOrExploredCandidatePointModificationHashes: Set<string> = new Set()\n\n  constructorParams: UnravelSectionSolverParams\n\n  constructor(params: UnravelSectionSolverParams) {\n    super()\n\n    this.constructorParams = params\n\n    this.MUTABLE_HOPS = params.MUTABLE_HOPS ?? this.MUTABLE_HOPS\n    this.MAX_ITERATIONS = 50_000\n\n    this.hyperParameters = {\n      ...params.hyperParameters,\n      MAX_ITERATIONS_WITHOUT_IMPROVEMENT: 200,\n    }\n\n    this.nodeMap = params.nodeMap\n    this.dedupedSegments = params.dedupedSegments\n    if (params.dedupedSegmentMap) {\n      this.dedupedSegmentMap = params.dedupedSegmentMap\n    } else {\n      this.dedupedSegmentMap = new Map()\n      for (const segment of this.dedupedSegments) {\n        this.dedupedSegmentMap.set(segment.nodePortSegmentId!, segment)\n      }\n    }\n    this.nodeIdToSegmentIds = params.nodeIdToSegmentIds\n    this.segmentIdToNodeIds = params.segmentIdToNodeIds\n    this.rootNodeId = params.rootNodeId\n    this.colorMap = params.colorMap ?? {}\n    this.unravelSection = this.createUnravelSection({\n      segmentPointMap: params.segmentPointMap!,\n      nodeToSegmentPointMap: params.nodeToSegmentPointMap!,\n      segmentToSegmentPointMap: params.segmentToSegmentPointMap!,\n    })\n    this.tunedNodeCapacityMap = new Map()\n    for (const nodeId of this.unravelSection.allNodeIds) {\n      this.tunedNodeCapacityMap.set(\n        nodeId,\n        getTunedTotalCapacity1(this.nodeMap.get(nodeId)!),\n      )\n    }\n    this.originalCandidate = this.createInitialCandidate()\n    this.candidates = [this.originalCandidate]\n  }\n\n  getConstructorParams(): UnravelSectionSolverParams {\n    return {\n      ...this.constructorParams,\n      // use the section maps instead of the global maps\n      segmentPointMap: this.unravelSection.segmentPointMap,\n      nodeToSegmentPointMap: this.unravelSection.segmentPointsInNode,\n      segmentToSegmentPointMap: this.unravelSection.segmentPointsInSegment,\n    }\n  }\n\n  createUnravelSection(\n    largeSpMaps?: SegmentPointMapAndReverseMaps,\n  ): UnravelSection {\n    const mutableNodeIds = getNodesNearNode({\n      nodeId: this.rootNodeId,\n      nodeIdToSegmentIds: this.nodeIdToSegmentIds,\n      segmentIdToNodeIds: this.segmentIdToNodeIds,\n      hops: this.MUTABLE_HOPS,\n    })\n    const allSectionNodeIds = getNodesNearNode({\n      nodeId: this.rootNodeId,\n      nodeIdToSegmentIds: this.nodeIdToSegmentIds,\n      segmentIdToNodeIds: this.segmentIdToNodeIds,\n      hops: this.MUTABLE_HOPS + 1,\n    })\n    const immutableNodeIds = Array.from(\n      new Set(allSectionNodeIds).difference(new Set(mutableNodeIds)),\n    )\n\n    if (!largeSpMaps?.segmentPointMap) {\n      largeSpMaps = createSegmentPointMap(\n        this.dedupedSegments,\n        this.segmentIdToNodeIds,\n      )\n    }\n\n    const segmentPointsInNode = new Map<CapacityMeshNodeId, SegmentPointId[]>()\n    for (const nodeId of allSectionNodeIds) {\n      segmentPointsInNode.set(\n        nodeId,\n        largeSpMaps.nodeToSegmentPointMap.get(nodeId)!,\n      )\n    }\n\n    const sectionPointMap = new Map<SegmentPointId, SegmentPoint>()\n    for (const nodeId of allSectionNodeIds) {\n      for (const segmentPointId of segmentPointsInNode.get(nodeId)!) {\n        const point = largeSpMaps.segmentPointMap.get(segmentPointId)!\n        sectionPointMap.set(segmentPointId, point)\n      }\n    }\n\n    const segmentPoints = Array.from(sectionPointMap.values())\n\n    const segmentPointsInSegment = new Map<SegmentId, SegmentPointId[]>()\n    for (const segmentPoint of segmentPoints) {\n      segmentPointsInSegment.set(segmentPoint.segmentId, [\n        ...(segmentPointsInSegment.get(segmentPoint.segmentId) ?? []),\n        segmentPoint.segmentPointId,\n      ])\n    }\n\n    // Second pass: set neighboring segment point ids\n    for (const [nodeId, segmentPoints] of segmentPointsInNode.entries()) {\n      for (let i = 0; i < segmentPoints.length; i++) {\n        const A = largeSpMaps.segmentPointMap.get(segmentPoints[i])!\n        for (let j = i + 1; j < segmentPoints.length; j++) {\n          const B = largeSpMaps.segmentPointMap.get(segmentPoints[j])!\n\n          if (B.segmentPointId === A.segmentPointId) continue\n          if (B.segmentId === A.segmentId) continue\n          if (B.connectionName !== A.connectionName) continue\n          if (B.directlyConnectedSegmentPointIds.includes(A.segmentPointId))\n            continue\n\n          A.directlyConnectedSegmentPointIds.push(B.segmentPointId)\n          B.directlyConnectedSegmentPointIds.push(A.segmentPointId)\n        }\n      }\n    }\n\n    const segmentPairsInNode = new Map<\n      CapacityMeshNodeId,\n      Array<[SegmentPointId, SegmentPointId]>\n    >()\n    for (const nodeId of allSectionNodeIds) {\n      segmentPairsInNode.set(nodeId, [])\n    }\n\n    for (const A of segmentPoints) {\n      for (const nodeId of A.capacityMeshNodeIds) {\n        const segmentPairs = segmentPairsInNode.get(nodeId)\n        if (!segmentPairs) continue\n        for (const BId of A.directlyConnectedSegmentPointIds) {\n          const B = largeSpMaps.segmentPointMap.get(BId)!\n          if (B.segmentPointId === A.segmentPointId) continue\n          if (!B.capacityMeshNodeIds.some((nId) => nId === nodeId)) continue\n          if (\n            !segmentPairs.some(\n              ([a, b]) =>\n                (a === A.segmentPointId && b === B.segmentPointId) ||\n                (a === B.segmentPointId && b === A.segmentPointId),\n            )\n          ) {\n            segmentPairs.push([A.segmentPointId, B.segmentPointId])\n          }\n        }\n      }\n    }\n\n    const mutableSegmentIds = new Set<string>()\n    for (const nodeId of mutableNodeIds) {\n      for (const segmentId of this.nodeIdToSegmentIds.get(nodeId)!) {\n        const allNodeIdsWithSegment = this.segmentIdToNodeIds.get(segmentId)!\n        if (\n          allNodeIdsWithSegment.every(\n            (nodeId) => !this.nodeMap.get(nodeId)!._containsTarget,\n          )\n        ) {\n          mutableSegmentIds.add(segmentId)\n        }\n      }\n    }\n\n    const mutableSegmentPointIds = new Set<SegmentPointId>()\n    for (const sp of segmentPoints) {\n      if (sp.capacityMeshNodeIds.some((id) => mutableNodeIds.includes(id))) {\n        mutableSegmentPointIds.add(sp.segmentPointId)\n      }\n    }\n\n    return {\n      allNodeIds: allSectionNodeIds,\n      mutableNodeIds,\n      immutableNodeIds,\n      mutableSegmentIds,\n      segmentPairsInNode,\n      segmentPointMap: sectionPointMap,\n      segmentPointsInNode,\n      segmentPointsInSegment,\n      originalPointMap: sectionPointMap,\n      mutableSegmentPointIds,\n    }\n  }\n\n  createInitialCandidate(): UnravelCandidate {\n    const pointModifications = new Map<\n      SegmentPointId,\n      { x?: number; y?: number; z?: number }\n    >()\n    const issues = getIssuesInSection(\n      this.unravelSection,\n      this.nodeMap,\n      pointModifications,\n    )\n    const g = this.computeG({\n      issues,\n      originalCandidate: {} as any,\n      operationsPerformed: 0,\n      operation: {} as any,\n    })\n    return {\n      pointModifications,\n      g,\n      h: 0,\n      f: g,\n      operationsPerformed: 0,\n      candidateHash: createPointModificationsHash(pointModifications),\n      // candidateFullHash: createFullPointModificationsHash(\n      //   this.unravelSection.segmentPointMap,\n      //   pointModifications,\n      // ),\n      // Ensure original candidate has issues calculated\n      issues: getIssuesInSection(\n        this.unravelSection,\n        this.nodeMap,\n        pointModifications,\n      ),\n    }\n  }\n\n  get nextCandidate(): UnravelCandidate | null {\n    return this.candidates[0] ?? null\n  }\n\n  getPointInCandidate(\n    candidate: UnravelCandidate,\n    segmentPointId: SegmentPointId,\n  ): { x: number; y: number; z: number; segmentId: string } {\n    const originalPoint =\n      this.unravelSection.segmentPointMap.get(segmentPointId)!\n    const modifications = candidate.pointModifications.get(segmentPointId)\n\n    return {\n      x: modifications?.x ?? originalPoint.x,\n      y: modifications?.y ?? originalPoint.y,\n      z: modifications?.z ?? originalPoint.z,\n      segmentId: originalPoint.segmentId,\n    }\n  }\n\n  getOperationsForIssue(\n    candidate: UnravelCandidate,\n    issue: UnravelIssue,\n  ): UnravelOperation[] {\n    const operations: UnravelOperation[] = []\n\n    if (issue.type === \"transition_via\") {\n      // When there's a transition via, we attempt to change the layer of either\n      // end to match the other end\n      const [APointId, BPointId] = issue.segmentPoints\n      const pointA = this.getPointInCandidate(candidate, APointId)\n      const pointB = this.getPointInCandidate(candidate, BPointId)\n\n      const aAvailableZ = this.dedupedSegmentMap.get(\n        pointA.segmentId,\n      )!.availableZ\n      const bAvailableZ = this.dedupedSegmentMap.get(\n        pointB.segmentId,\n      )!.availableZ\n\n      if (\n        this.unravelSection.mutableSegmentPointIds.has(APointId) &&\n        aAvailableZ.includes(pointB.z)\n      ) {\n        operations.push({\n          type: \"change_layer\",\n          newZ: pointB.z,\n          segmentPointIds: [APointId],\n        })\n      }\n      if (\n        this.unravelSection.mutableSegmentPointIds.has(BPointId) &&\n        bAvailableZ.includes(pointA.z)\n      ) {\n        operations.push({\n          type: \"change_layer\",\n          newZ: pointA.z,\n          segmentPointIds: [BPointId],\n        })\n      }\n    }\n\n    if (issue.type === \"same_layer_crossing\") {\n      // For a same-layer crossing, we should try all the following:\n      // 1. Swap the points on each segment (for each shared segment, if any)\n      // 2. Change the layer of each segment entirely to remove the crossing\n      // 3. Change the layer of each point individually to make it a transition\n      //   crossing\n\n      // 1. SWAP POINTS\n      const [APointId, BPointId] = issue.crossingLine1\n      const [CPointId, DPointId] = issue.crossingLine2\n\n      const sharedSegments: Array<[SegmentPointId, SegmentPointId]> = []\n      const A = this.unravelSection.segmentPointMap.get(APointId)!\n      const B = this.unravelSection.segmentPointMap.get(BPointId)!\n      const C = this.unravelSection.segmentPointMap.get(CPointId)!\n      const D = this.unravelSection.segmentPointMap.get(DPointId)!\n\n      const AIsMutable =\n        this.unravelSection.mutableSegmentPointIds.has(APointId)\n      const BIsMutable =\n        this.unravelSection.mutableSegmentPointIds.has(BPointId)\n      const CIsMutable =\n        this.unravelSection.mutableSegmentPointIds.has(CPointId)\n      const DIsMutable =\n        this.unravelSection.mutableSegmentPointIds.has(DPointId)\n\n      if (AIsMutable && CIsMutable && A.segmentId === C.segmentId) {\n        sharedSegments.push([APointId, CPointId])\n      }\n      if (AIsMutable && DIsMutable && A.segmentId === D.segmentId) {\n        sharedSegments.push([APointId, DPointId])\n      }\n      if (BIsMutable && CIsMutable && B.segmentId === C.segmentId) {\n        sharedSegments.push([BPointId, CPointId])\n      }\n      if (BIsMutable && DIsMutable && B.segmentId === D.segmentId) {\n        sharedSegments.push([BPointId, DPointId])\n      }\n\n      for (const [EPointId, FPointId] of sharedSegments) {\n        operations.push({\n          type: \"swap_position_on_segment\",\n          segmentPointIds: [EPointId, FPointId],\n        })\n      }\n\n      // 2. CHANGE LAYER OF EACH SEGMENT ENTIRELY TO REMOVE CROSSING\n      const aSegment = this.dedupedSegmentMap.get(A.segmentId)!\n      const bSegment = this.dedupedSegmentMap.get(B.segmentId)!\n      const cSegment = this.dedupedSegmentMap.get(C.segmentId)!\n      const dSegment = this.dedupedSegmentMap.get(D.segmentId)!\n\n      // Function to check if a new Z level is available for all segments\n      const isNewZAvailableForAll = (segmentObjects: any[], newZ: number) => {\n        return segmentObjects.every((seg) => seg.availableZ.includes(newZ))\n      }\n\n      // Only propose layer changes if both segments can use the target layer\n      if (AIsMutable && BIsMutable) {\n        const newZ = A.z === 0 ? 1 : 0\n        if (isNewZAvailableForAll([aSegment, bSegment], newZ)) {\n          operations.push({\n            type: \"change_layer\",\n            newZ,\n            segmentPointIds: [APointId, BPointId],\n          })\n        }\n      }\n\n      if (CIsMutable && DIsMutable) {\n        const newZ = C.z === 0 ? 1 : 0\n        if (isNewZAvailableForAll([cSegment, dSegment], newZ)) {\n          operations.push({\n            type: \"change_layer\",\n            newZ,\n            segmentPointIds: [CPointId, DPointId],\n          })\n        }\n      }\n\n      // 3. CHANGE LAYER OF EACH POINT INDIVIDUALLY TO MAKE TRANSITION CROSSING\n      if (AIsMutable) {\n        const newZ = A.z === 0 ? 1 : 0\n        if (aSegment.availableZ.includes(newZ)) {\n          operations.push({\n            type: \"change_layer\",\n            newZ,\n            segmentPointIds: [APointId],\n          })\n        }\n      }\n\n      if (BIsMutable) {\n        const newZ = B.z === 0 ? 1 : 0\n        if (bSegment.availableZ.includes(newZ)) {\n          operations.push({\n            type: \"change_layer\",\n            newZ,\n            segmentPointIds: [BPointId],\n          })\n        }\n      }\n\n      if (CIsMutable) {\n        const newZ = C.z === 0 ? 1 : 0\n        if (cSegment.availableZ.includes(newZ)) {\n          operations.push({\n            type: \"change_layer\",\n            newZ,\n            segmentPointIds: [CPointId],\n          })\n        }\n      }\n\n      if (DIsMutable) {\n        const newZ = D.z === 0 ? 1 : 0\n        if (dSegment.availableZ.includes(newZ)) {\n          operations.push({\n            type: \"change_layer\",\n            newZ,\n            segmentPointIds: [DPointId],\n          })\n        }\n      }\n    }\n\n    // TODO single_transition_crossing\n    // TODO double_transition_crossing\n    // TODO same_layer_trace_imbalance_with_low_capacity\n\n    return operations\n  }\n\n  computeG(params: {\n    issues: UnravelIssue[]\n    originalCandidate: UnravelCandidate\n    operationsPerformed: number\n    operation: UnravelOperation\n  }): number {\n    const { issues, originalCandidate, operationsPerformed, operation } = params\n\n    const nodeProblemCounts = new Map<\n      CapacityMeshNodeId,\n      {\n        numTransitionCrossings: number\n        numSameLayerCrossings: number\n        numEntryExitLayerChanges: number\n      }\n    >()\n\n    for (const issue of issues) {\n      if (!nodeProblemCounts.has(issue.capacityMeshNodeId)) {\n        nodeProblemCounts.set(issue.capacityMeshNodeId, {\n          numTransitionCrossings: 0,\n          numSameLayerCrossings: 0,\n          numEntryExitLayerChanges: 0,\n        })\n      }\n\n      const nodeProblemCount = nodeProblemCounts.get(issue.capacityMeshNodeId)!\n\n      if (issue.type === \"transition_via\") {\n        nodeProblemCount.numTransitionCrossings++\n      } else if (issue.type === \"same_layer_crossing\") {\n        nodeProblemCount.numSameLayerCrossings++\n      } else if (\n        issue.type === \"double_transition_crossing\" ||\n        issue.type === \"single_transition_crossing\"\n      ) {\n        nodeProblemCount.numEntryExitLayerChanges++\n      } else if (\n        issue.type === \"same_layer_trace_imbalance_with_low_capacity\"\n      ) {\n        // TODO\n      }\n    }\n\n    function log1mexp(x: number): number {\n      if (x < -Math.LN2) return Math.log(1 - Math.exp(x))\n      else return Math.log(-Math.expm1(x)) // more accurate when x ~ 0\n    }\n\n    let logSuccess = 0 // log(probability all nodes succeed)\n\n    for (const [\n      nodeId,\n      {\n        numEntryExitLayerChanges,\n        numSameLayerCrossings,\n        numTransitionCrossings,\n      },\n    ] of nodeProblemCounts) {\n      const node = this.nodeMap.get(nodeId)!\n      const estPf = Math.min(\n        calculateNodeProbabilityOfFailure(\n          node,\n          numSameLayerCrossings,\n          numEntryExitLayerChanges,\n          numTransitionCrossings,\n        ),\n        0.999999,\n      )\n\n      const log1mPf = Math.log(1 - estPf)\n      logSuccess += log1mPf\n    }\n\n    const logPf = log1mexp(logSuccess)\n\n    return logPf\n  }\n\n  getUnexploredNeighborByApplyingOperation(\n    currentCandidate: UnravelCandidate,\n    operation: UnravelOperation,\n  ): UnravelCandidate | null {\n    const pointModifications = new Map<\n      SegmentPointId,\n      { x?: number; y?: number; z?: number }\n    >(currentCandidate.pointModifications)\n\n    applyOperationToPointModifications(\n      pointModifications,\n      operation,\n      (segmentPointId) =>\n        this.getPointInCandidate(currentCandidate, segmentPointId),\n    )\n\n    const candidateHash = createPointModificationsHash(pointModifications)\n\n    if (\n      this.queuedOrExploredCandidatePointModificationHashes.has(candidateHash)\n    ) {\n      return null\n    }\n\n    const issues: UnravelIssue[] = getIssuesInSection(\n      this.unravelSection,\n      this.nodeMap,\n      pointModifications,\n    )\n\n    const operationsPerformed = currentCandidate.operationsPerformed + 1\n\n    const g = this.computeG({\n      issues,\n      originalCandidate: currentCandidate,\n      operationsPerformed,\n      operation,\n    })\n\n    return {\n      issues,\n      g,\n      h: 0,\n      f: g,\n      pointModifications,\n      candidateHash,\n\n      // TODO PERFORMANCE allow disabling this\n      // candidateFullHash: createFullPointModificationsHash(\n      //   this.unravelSection.segmentPointMap,\n      //   pointModifications,\n      // ),\n\n      operationsPerformed,\n    }\n  }\n\n  getNeighborOperationsForCandidate(\n    candidate: UnravelCandidate,\n  ): UnravelOperation[] {\n    return candidate.issues.flatMap((issue) =>\n      this.getOperationsForIssue(candidate, issue),\n    )\n  }\n\n  getNeighbors(candidate: UnravelCandidate): UnravelCandidate[] {\n    const neighbors: UnravelCandidate[] = []\n\n    const operations = this.getNeighborOperationsForCandidate(candidate)\n    for (const operation of operations) {\n      const neighbor = this.getUnexploredNeighborByApplyingOperation(\n        candidate,\n        operation,\n      )\n      if (!neighbor) continue\n      neighbors.push(neighbor)\n    }\n\n    return neighbors\n  }\n\n  _step() {\n    const candidate = this.candidates.shift()\n    this.iterationsSinceImprovement++\n    if (\n      this.iterationsSinceImprovement >\n      this.hyperParameters.MAX_ITERATIONS_WITHOUT_IMPROVEMENT\n    ) {\n      this.solved = true\n      return\n    }\n    if (!candidate) {\n      this.solved = true\n      return\n    }\n    this.lastProcessedCandidate = candidate\n\n    if (candidate.f < (this.bestCandidate?.f ?? Infinity)) {\n      this.bestCandidate = candidate\n      this.iterationsSinceImprovement = 0\n      // TODO, only works if we start computing f\n      // if (candidate.f <= 0.00001) {\n      //   this.solved = true\n      //   return\n      // }\n    }\n\n    this.getNeighbors(candidate).forEach((neighbor) => {\n      const isPartialHashExplored =\n        this.queuedOrExploredCandidatePointModificationHashes.has(\n          neighbor.candidateHash,\n        )\n      // const isFullHashExplored =\n      //   neighbor.candidateFullHash &&\n      //   this.queuedOrExploredCandidatePointModificationHashes.has(\n      //     neighbor.candidateFullHash,\n      //   )\n\n      // if (isPartialHashExplored || isFullHashExplored) return\n      if (isPartialHashExplored) return\n      this.queuedOrExploredCandidatePointModificationHashes.add(\n        neighbor.candidateHash,\n      )\n      // if (neighbor.candidateFullHash) {\n      //   this.queuedOrExploredCandidatePointModificationHashes.add(\n      //     neighbor.candidateFullHash,\n      //   )\n      // }\n      this.candidates.push(neighbor)\n    })\n    this.candidates.sort((a, b) => a.f - b.f)\n    this.candidates.length = Math.min(\n      this.candidates.length,\n      this.MAX_CANDIDATES,\n    )\n  }\n\n  visualize(): GraphicsObject {\n    const graphics: Required<GraphicsObject> = {\n      points: [],\n      lines: [],\n      rects: [],\n      circles: [],\n      coordinateSystem: \"cartesian\",\n      title: \"Unravel Section Solver\",\n    }\n\n    // Get the candidate to visualize\n    let candidate: UnravelCandidate | null = null\n    if (this.selectedCandidateIndex !== null) {\n      if (this.selectedCandidateIndex === \"best\") {\n        candidate = this.bestCandidate\n      } else if (this.selectedCandidateIndex === \"original\") {\n        candidate = this.originalCandidate\n      } else {\n        candidate = this.candidates[this.selectedCandidateIndex]\n      }\n    } else if (this.solved) {\n      candidate = this.bestCandidate\n    } else {\n      candidate = this.lastProcessedCandidate || this.candidates[0]\n    }\n    if (!candidate) return graphics\n\n    // Create a map of segment points with modifications applied\n    const modifiedSegmentPoints = new Map<string, SegmentPoint>()\n    for (const [segmentPointId, segmentPoint] of this.unravelSection\n      .segmentPointMap) {\n      // Create a copy of the original point\n      const modifiedPoint = { ...segmentPoint }\n\n      // Apply any modifications from the candidate\n      const modification = candidate.pointModifications.get(segmentPointId)\n      if (modification) {\n        if (modification.x !== undefined) modifiedPoint.x = modification.x\n        if (modification.y !== undefined) modifiedPoint.y = modification.y\n        if (modification.z !== undefined) modifiedPoint.z = modification.z\n      }\n\n      modifiedSegmentPoints.set(segmentPointId, modifiedPoint)\n    }\n\n    // Visualize all segment points with modifications applied\n    for (const [segmentPointId, segmentPoint] of modifiedSegmentPoints) {\n      graphics.points.push({\n        x: segmentPoint.x,\n        y: segmentPoint.y,\n        label: `${segmentPointId}\\nSegment: ${segmentPoint.segmentId} ${this.unravelSection.mutableSegmentIds.has(segmentPoint.segmentId) ? \"MUTABLE\" : \"IMMUTABLE\"}\\nLayer: ${segmentPoint.z}`,\n        color: this.colorMap[segmentPoint.connectionName] || \"#000\",\n      })\n    }\n\n    // Calculate node stats for the selected candidate\n    const nodeStatsMap = new Map<\n      CapacityMeshNodeId,\n      {\n        numTransitionCrossings: number\n        numSameLayerCrossings: number\n        numEntryExitLayerChanges: number\n        estPf: number\n      }\n    >()\n\n    for (const nodeId of this.unravelSection.allNodeIds) {\n      nodeStatsMap.set(nodeId, {\n        numTransitionCrossings: 0,\n        numSameLayerCrossings: 0,\n        numEntryExitLayerChanges: 0,\n        estPf: 0,\n      })\n    }\n\n    for (const issue of candidate.issues) {\n      const stats = nodeStatsMap.get(issue.capacityMeshNodeId)!\n      if (issue.type === \"transition_via\") {\n        stats.numTransitionCrossings++\n      } else if (issue.type === \"same_layer_crossing\") {\n        stats.numSameLayerCrossings++\n      } else if (\n        issue.type === \"double_transition_crossing\" ||\n        issue.type === \"single_transition_crossing\"\n      ) {\n        stats.numEntryExitLayerChanges++\n      }\n      // TODO: Handle same_layer_trace_imbalance_with_low_capacity if needed for stats\n    }\n\n    // Calculate Pf for each node\n    for (const [nodeId, stats] of nodeStatsMap.entries()) {\n      const node = this.nodeMap.get(nodeId)!\n      stats.estPf = calculateNodeProbabilityOfFailure(\n        node,\n        stats.numSameLayerCrossings,\n        stats.numEntryExitLayerChanges,\n        stats.numTransitionCrossings,\n      )\n    }\n\n    // Visualize nodes with stats\n    for (const nodeId of this.unravelSection.allNodeIds) {\n      const node = this.nodeMap.get(nodeId)!\n      const isMutable = this.unravelSection.mutableNodeIds.includes(nodeId)\n      const stats = nodeStatsMap.get(nodeId)!\n\n      const label = [\n        `${nodeId} (${isMutable ? \"MUT\" : \"IMM\"})`,\n        `${node.width.toFixed(2)}x${node.height.toFixed(2)}`,\n        `Pf: ${stats.estPf.toFixed(3)}`,\n        `TC: ${stats.numTransitionCrossings}`, // Transition Crossings (Vias)\n        `SLC: ${stats.numSameLayerCrossings}`, // Same Layer Crossings\n        `EELC: ${stats.numEntryExitLayerChanges}`, // Entry/Exit Layer Changes\n      ].join(\"\\n\")\n\n      graphics.rects.push({\n        center: node.center,\n        label: label,\n        color: isMutable ? \"green\" : \"red\",\n        width: node.width / 8,\n        height: node.height / 8,\n      })\n    }\n\n    // Connect segment points that belong to the same segment\n    for (const [segmentId, segmentPointIds] of this.unravelSection\n      .segmentPointsInSegment) {\n      if (segmentPointIds.length <= 1) continue\n\n      const points = segmentPointIds.map(\n        (spId) => modifiedSegmentPoints.get(spId)!,\n      )\n\n      // Connect points in order\n      for (let i = 0; i < points.length - 1; i++) {\n        graphics.lines.push({\n          points: [\n            { x: points[i].x, y: points[i].y },\n            { x: points[i + 1].x, y: points[i + 1].y },\n          ],\n          strokeColor: this.colorMap[segmentId] || \"#000\",\n        })\n      }\n    }\n\n    // Connect directly connected segment points (points with the same connection name)\n    for (const [segmentPointId, segmentPoint] of modifiedSegmentPoints) {\n      for (const connectedPointId of segmentPoint.directlyConnectedSegmentPointIds) {\n        // Only process each connection once (when the current point's ID is less than the connected point's ID)\n        if (segmentPointId < connectedPointId) {\n          const connectedPoint = modifiedSegmentPoints.get(connectedPointId)!\n          if (!connectedPoint) continue\n\n          // Determine line style based on layer (z) values\n          const sameLayer = segmentPoint.z === connectedPoint.z\n          const commonLayer = segmentPoint.z\n\n          let strokeDash: string | undefined\n          if (sameLayer) {\n            strokeDash = commonLayer === 0 ? undefined : \"10 5\" // top layer: solid, bottom layer: long dash\n          } else {\n            strokeDash = \"3 3 10\" // transition between layers: mixed dash pattern\n          }\n\n          graphics.lines.push({\n            points: [\n              { x: segmentPoint.x, y: segmentPoint.y },\n              { x: connectedPoint.x, y: connectedPoint.y },\n            ],\n            strokeDash,\n            strokeColor: this.colorMap[segmentPoint.connectionName] || \"#000\",\n          })\n        }\n      }\n    }\n\n    // Visualize issues\n    for (const issue of candidate.issues) {\n      const node = this.nodeMap.get(issue.capacityMeshNodeId)!\n\n      if (issue.type === \"transition_via\") {\n        // Highlight via issues\n        for (const segmentPointId of issue.segmentPoints) {\n          const segmentPoint = modifiedSegmentPoints.get(segmentPointId)!\n          graphics.circles.push({\n            center: { x: segmentPoint.x, y: segmentPoint.y },\n            radius: node.width / 16,\n            stroke: \"#ff0000\",\n            fill: \"rgba(255, 0, 0, 0.2)\",\n            label: `Via Issue\\n${segmentPointId}\\nLayer: ${segmentPoint.z}`,\n          })\n        }\n      } else if (issue.type === \"same_layer_crossing\") {\n        // Highlight crossing issues\n        for (const [sp1Id, sp2Id] of [\n          issue.crossingLine1,\n          issue.crossingLine2,\n        ]) {\n          const sp1 = modifiedSegmentPoints.get(sp1Id)!\n          const sp2 = modifiedSegmentPoints.get(sp2Id)!\n\n          graphics.lines.push({\n            points: [\n              { x: sp1.x, y: sp1.y },\n              { x: sp2.x, y: sp2.y },\n            ],\n            strokeColor: \"rgba(255,0,0,0.2)\",\n            strokeWidth: node.width / 32,\n          })\n        }\n      }\n    }\n\n    // Highlight modified points\n    for (const [segmentPointId, modification] of candidate.pointModifications) {\n      const modifiedPoint = modifiedSegmentPoints.get(segmentPointId)!\n      const originalPoint =\n        this.unravelSection.segmentPointMap.get(segmentPointId)!\n\n      graphics.circles.push({\n        center: { x: modifiedPoint.x, y: modifiedPoint.y },\n        radius: 0.05,\n        stroke: \"#0000ff\",\n        fill: \"rgba(0, 0, 255, 0.2)\",\n        label: `${segmentPointId}\\nOriginal: (${originalPoint.x.toFixed(2)}, ${originalPoint.y.toFixed(2)}, ${originalPoint.z})\\nNew: (${modifiedPoint.x.toFixed(2)}, ${modifiedPoint.y.toFixed(2)}, ${modifiedPoint.z})`,\n      })\n    }\n\n    return graphics\n  }\n}\n","import { CachableSolver, CacheProvider } from \"lib/cache/types\"\nimport { UnravelSectionSolver } from \"./UnravelSectionSolver\"\nimport { InMemoryCache } from \"lib/cache/InMemoryCache\"\nimport {\n  PointModificationsMap,\n  SegmentPointId,\n  UnravelCandidate,\n} from \"./types\"\nimport { createPointModificationsHash } from \"./createPointModificationsHash\"\nimport { BaseSolver } from \"../BaseSolver\"\nimport stableStringify from \"fast-json-stable-stringify\"\nimport objectHash from \"object-hash\"\nimport { getIssuesInSection } from \"./getIssuesInSection\"\nimport { CapacityMeshNode, CapacityMeshNodeId } from \"lib/types\"\nimport { SegmentId } from \"./types\"\nimport { LocalStorageCache } from \"lib/cache/LocalStorageCache\"\nimport {\n  getGlobalLocalStorageCache,\n  setupGlobalCaches,\n} from \"lib/cache/setupGlobalCaches\"\nimport {\n  translate,\n  type Matrix,\n  applyToPoint,\n  applyToPoints,\n  scale,\n  compose,\n} from \"transformation-matrix\"\n\n// Normalized IDs are simple strings like \"node_0\", \"sp_1\", etc.\ntype NormalizedId = string\n\n// Helper function to round to nearest 50 microns (0.05 mm) and return as string\nconst approximateCoordinate = (coord: number): string => {\n  // Multiply by 20 (1 / 0.05), round, then divide by 20\n  // Use toFixed(2) to ensure consistent string format like \"1.20\" or \"0.05\"\n  return (Math.round(coord * 20) / 20).toFixed(2)\n}\n\n// Helper function to round to nearest micron (0.001 mm) and return as string.\nconst approximateDeltaCoordinate = (coord: number): string => {\n  // Multiply by 1000 (1 / 0.001), round, then divide by 1000\n  // Use toFixed(3) to ensure consistent string format like \"1.200\" or \"0.005\"\n  return (Math.round(coord * 1000) / 1000).toFixed(3)\n}\n\ninterface CacheToUnravelSectionTransform {\n  realToCacheTransform: Matrix\n  // Mappings from original UUIDs to normalized IDs\n  nodeIdMap: Map<CapacityMeshNodeId, NormalizedId>\n  segmentIdMap: Map<SegmentId, NormalizedId>\n  segmentPointIdMap: Map<SegmentPointId, NormalizedId>\n  // Reverse mappings from normalized IDs back to original UUIDs\n  reverseNodeIdMap: Map<NormalizedId, CapacityMeshNodeId>\n  reverseSegmentIdMap: Map<NormalizedId, SegmentId>\n  reverseSegmentPointIdMap: Map<NormalizedId, SegmentPointId>\n}\ntype CachedSolvedUnravelSection =\n  | {\n      success: true\n      // Store the DELTA using NORMALIZED IDs and APPROXIMATED coordinate offsets (as strings)\n      bestCandidatePointModificationsDelta: Array<\n        [NormalizedId, { dx?: string; dy?: string; dz?: number }] // Normalized ID and approximated coord deltas (dx, dy as string)\n      >\n      // Store the 'f' value to reconstruct the candidate accurately\n      bestCandidateF: number\n    }\n  | { success: false }\n\nsetupGlobalCaches()\n\nexport class CachedUnravelSectionSolver\n  extends UnravelSectionSolver\n  implements\n    CachableSolver<CacheToUnravelSectionTransform, CachedSolvedUnravelSection>\n{\n  cacheHit = false\n  cacheProvider: CacheProvider | null\n  declare cacheToSolveSpaceTransform?:\n    | CacheToUnravelSectionTransform\n    | undefined\n  hasAttemptedToUseCache = false\n\n  constructor(\n    params: ConstructorParameters<typeof UnravelSectionSolver>[0] & {\n      cacheProvider?: CacheProvider | null\n    },\n  ) {\n    super(params)\n    this.cacheProvider =\n      params.cacheProvider === undefined\n        ? getGlobalLocalStorageCache() // Default to in-memory if undefined\n        : params.cacheProvider // Use null if explicitly passed as null\n  }\n\n  _step() {\n    if (!this.hasAttemptedToUseCache && this.cacheProvider) {\n      if (this.attemptToUseCacheSync()) return\n    }\n    super._step()\n    if ((this.solved || this.failed) && this.cacheProvider) {\n      this.saveToCacheSync()\n    }\n  }\n\n  computeCacheKeyAndTransform(): {\n    cacheKey: string\n    cacheToSolveSpaceTransform: CacheToUnravelSectionTransform\n  } {\n    // 1. Calculate Transformation Matrix (currently just translation)\n    const rootNode = this.nodeMap.get(this.rootNodeId)!\n    const realToCacheTransform = translate(\n      -rootNode.center.x,\n      -rootNode.center.y,\n    )\n    // TODO: Add scaling here in the future if needed, e.g.,\n    // const scaleFactor = 1 / someUnit;\n    // const realToCacheTransform = compose(\n    //   translate(-rootNode.center.x, -rootNode.center.y),\n    //   scale(scaleFactor, scaleFactor)\n    // );\n\n    // 2. Create ID Mappings\n    const nodeIdMap = new Map<CapacityMeshNodeId, NormalizedId>()\n    const reverseNodeIdMap = new Map<NormalizedId, CapacityMeshNodeId>()\n    const segmentIdMap = new Map<SegmentId, NormalizedId>()\n    const reverseSegmentIdMap = new Map<NormalizedId, SegmentId>()\n    const segmentPointIdMap = new Map<SegmentPointId, NormalizedId>()\n    const reverseSegmentPointIdMap = new Map<NormalizedId, SegmentPointId>()\n\n    let nodeCounter = 0\n    let segmentCounter = 0\n    let spCounter = 0\n\n    // Sort node IDs for deterministic normalized IDs based on coordinates (x then y)\n    const sortedNodeIds = [...this.unravelSection.allNodeIds].sort(\n      (aNId, bNId) => {\n        const n1 = this.nodeMap.get(aNId)!\n        const n2 = this.nodeMap.get(bNId)!\n\n        if (n1.center.x !== n2.center.x) {\n          return n1.center.x - n2.center.x\n        }\n        return n1.center.y - n2.center.y\n      },\n    )\n    for (const nodeId of sortedNodeIds) {\n      const normId = `node_${nodeCounter++}`\n      nodeIdMap.set(nodeId, normId)\n      reverseNodeIdMap.set(normId, nodeId)\n    }\n\n    // Sort segment point IDs for deterministic normalized IDs\n    const sortedSegmentPointIds = [\n      ...Array.from(this.unravelSection.segmentPointMap.entries())\n        .sort(([, a], [, b]) => {\n          if (a.x !== b.x) {\n            return a.x - b.x\n          }\n          return a.y - b.y\n        })\n        .map(([id]) => id),\n    ].sort()\n    for (const spId of sortedSegmentPointIds) {\n      const normSpId = `sp_${spCounter++}`\n      segmentPointIdMap.set(spId, normSpId)\n      reverseSegmentPointIdMap.set(normSpId, spId)\n\n      const segmentId = this.unravelSection.segmentPointMap.get(spId)!.segmentId\n      if (!segmentIdMap.has(segmentId)) {\n        const normSegId = `seg_${segmentCounter++}`\n        segmentIdMap.set(segmentId, normSegId)\n        reverseSegmentIdMap.set(normSegId, segmentId)\n      }\n    }\n\n    // 3. Create Normalized Structure for Hashing\n    const normalizedNodes: Record<\n      NormalizedId,\n      {\n        width: number\n        height: number\n        availableZ: number[]\n        center: { x: string; y: string } // Coordinates are approximated strings\n      }\n    > = {}\n    for (const [nodeId, normNodeId] of nodeIdMap.entries()) {\n      const node = this.nodeMap.get(nodeId)!\n      const transformedCenter = applyToPoint(realToCacheTransform, node.center)\n      normalizedNodes[normNodeId] = {\n        // ...node,\n        width: node.width, // TODO: Scale width/height if transform includes scaling\n        height: node.height,\n        availableZ: node.availableZ,\n        center: {\n          x: approximateCoordinate(transformedCenter.x),\n          y: approximateCoordinate(transformedCenter.y),\n        },\n      }\n    }\n\n    const normalizedSegmentPoints: Record<\n      NormalizedId,\n      {\n        x: string // Approximated string coordinate\n        y: string // Approximated string coordinate\n        z: number\n        // segmentId: NormalizedId // Use normalized ID\n        // connectionName: string\n        // Add other relevant properties if needed\n      }\n    > = {}\n    for (const [spId, normSpId] of segmentPointIdMap.entries()) {\n      const sp = this.unravelSection.segmentPointMap.get(spId)!\n      const transformedPoint = applyToPoint(realToCacheTransform, {\n        x: sp.x,\n        y: sp.y,\n      })\n      normalizedSegmentPoints[normSpId] = {\n        x: approximateCoordinate(transformedPoint.x),\n        y: approximateCoordinate(transformedPoint.y),\n        z: sp.z, // Z is not transformed by 2D matrix\n        // segmentId: segmentIdMap.get(sp.segmentId)!,\n        // connectionName: sp.connectionName,\n      }\n    }\n\n    // Include connectivity/relationships if necessary for the hash\n    // e.g., normalized segmentPairsInNode, normalized nodeIdToSegmentIds etc.\n    // For simplicity, we'll hash nodes, points, and parameters for now.\n\n    const keyData = {\n      hyperParameters: this.hyperParameters,\n      normalizedNodes,\n      normalizedSegmentPoints,\n      mutableHops: this.MUTABLE_HOPS,\n    }\n\n    // Use object-hash for potentially better handling of object structures\n    // const cacheKey = stableStringify(keyData)\n    const cacheKey = `unravelsec:${objectHash(keyData)}`\n\n    const cacheToSolveSpaceTransform: CacheToUnravelSectionTransform = {\n      realToCacheTransform,\n      nodeIdMap,\n      segmentIdMap,\n      segmentPointIdMap,\n      reverseNodeIdMap,\n      reverseSegmentIdMap,\n      reverseSegmentPointIdMap,\n    }\n\n    this.cacheKey = cacheKey\n    this.cacheToSolveSpaceTransform = cacheToSolveSpaceTransform\n\n    return { cacheKey, cacheToSolveSpaceTransform }\n  }\n\n  applyCachedSolution(cachedSolution: CachedSolvedUnravelSection): void {\n    if (cachedSolution.success === false) {\n      this.failed = true\n      return\n    }\n    if (!this.cacheToSolveSpaceTransform) {\n      console.error(\"Cache transform not available to apply cached solution.\")\n      return\n    }\n\n    const {\n      // realToCacheTransform, // Not needed to apply deltas\n      reverseSegmentPointIdMap,\n      reverseNodeIdMap, // Needed if issues depend on node IDs\n    } = this.cacheToSolveSpaceTransform\n\n    // Create point modifications map using ORIGINAL IDs and ORIGINAL coordinates\n    const pointModifications = new Map<\n      SegmentPointId,\n      { x?: number; y?: number; z?: number }\n    >()\n\n    for (const [\n      normSpId,\n      normDelta, // normDelta.dx and normDelta.dy are strings here\n    ] of cachedSolution.bestCandidatePointModificationsDelta) {\n      const originalSpId = reverseSegmentPointIdMap.get(normSpId)\n      if (!originalSpId) {\n        console.warn(\n          `Could not find original ID for normalized SP ID: ${normSpId} when applying cache.`,\n        )\n        continue\n      }\n\n      const originalSegmentPoint =\n        this.unravelSection.segmentPointMap.get(originalSpId)\n      if (!originalSegmentPoint) {\n        console.warn(\n          `Could not find original segment point for ID: ${originalSpId} when applying cache.`,\n        )\n        continue\n      }\n\n      // Calculate absolute coordinates by applying the delta to the original point\n      const modifiedPoint: { x?: number; y?: number; z?: number } = {}\n\n      if (normDelta.dx !== undefined) {\n        const dxNum = parseFloat(normDelta.dx)\n        if (!Number.isNaN(dxNum)) {\n          // Apply delta to the original coordinate (no translation offset needed here as delta is relative)\n          modifiedPoint.x = originalSegmentPoint.x + dxNum\n        } else {\n          console.warn(`Failed to parse cached dx coordinate: ${normDelta.dx}`)\n        }\n      }\n      if (normDelta.dy !== undefined) {\n        const dyNum = parseFloat(normDelta.dy)\n        if (!Number.isNaN(dyNum)) {\n          // Apply delta to the original coordinate\n          modifiedPoint.y = originalSegmentPoint.y + dyNum\n        } else {\n          console.warn(`Failed to parse cached dy coordinate: ${normDelta.dy}`)\n        }\n      }\n      if (normDelta.dz !== undefined) {\n        // Z delta is applied directly\n        modifiedPoint.z = originalSegmentPoint.z + normDelta.dz\n      }\n\n      // Only add modification if at least one coordinate changed\n      if (Object.keys(modifiedPoint).length > 0) {\n        pointModifications.set(originalSpId, modifiedPoint)\n      }\n    }\n\n    // Reconstruct the best candidate using ORIGINAL IDs/coords\n    // Note: Issues are recalculated based on the loaded (denormalized) modifications.\n    //       'g' and 'h' might not be perfectly reconstructed if they depended\n    //       on the path taken, but 'f' (the primary cost) is stored.\n    const issues = getIssuesInSection(\n      this.unravelSection,\n      this.nodeMap,\n      pointModifications,\n    )\n\n    this.bestCandidate = {\n      pointModifications,\n      issues,\n      f: cachedSolution.bestCandidateF,\n      g: cachedSolution.bestCandidateF, // Assume g is the main component off for cached solution\n      h: 0, // Heuristic is 0 when solution is loaded\n      operationsPerformed: -1, // Indicate it's from cache, operation count unknown\n      candidateHash: createPointModificationsHash(pointModifications),\n    }\n\n    this.cacheHit = true\n    this.solved = true // Mark as solved since we applied a cached solution\n  }\n\n  attemptToUseCacheSync(): boolean {\n    this.hasAttemptedToUseCache = true\n    if (!this.cacheProvider?.isSyncCache) {\n      console.log(\n        \"Cache provider is not synchronous, skipping sync cache check.\",\n      )\n      return false\n    }\n\n    if (!this.cacheKey) {\n      this.computeCacheKeyAndTransform()\n    }\n\n    if (!this.cacheKey) {\n      console.error(\"Failed to compute cache key.\")\n      return false\n    }\n\n    try {\n      const cachedSolution = this.cacheProvider.getCachedSolutionSync(\n        this.cacheKey,\n      )\n\n      if (cachedSolution) {\n        this.applyCachedSolution(cachedSolution as CachedSolvedUnravelSection)\n        return true\n      } else {\n        // console.log(`Cache miss for UnravelSectionSolver: ${this.cacheKey}`)\n      }\n    } catch (error) {\n      console.error(\"Error attempting to use cache:\", error)\n    }\n\n    return false\n  }\n\n  saveToCacheSync(): void {\n    if (this.failed) {\n      this.cacheProvider?.setCachedSolutionSync(this.cacheKey!, {\n        success: false,\n      })\n      return\n    }\n    if (!this.bestCandidate) return\n    const {\n      // realToCacheTransform, // Not needed to calculate deltas\n      segmentPointIdMap,\n    } = this.cacheToSolveSpaceTransform!\n\n    // Convert best candidate modifications to NORMALIZED DELTAs with approximated coordinate offsets\n    const normalizedDeltas: Array<\n      [NormalizedId, { dx?: string; dy?: string; dz?: number }] // dx, dy are strings\n    > = []\n\n    for (const [\n      originalSpId,\n      modifiedPoint, // This contains the absolute modified coordinates {x?, y?, z?}\n    ] of this.bestCandidate.pointModifications.entries()) {\n      const normSpId = segmentPointIdMap.get(originalSpId)\n      if (!normSpId) {\n        console.warn(\n          `Could not find normalized ID for original SP ID: ${originalSpId} when saving to cache.`,\n        )\n        continue\n      }\n\n      const originalSegmentPoint =\n        this.unravelSection.segmentPointMap.get(originalSpId)\n      if (!originalSegmentPoint) {\n        console.warn(\n          `Could not find original segment point for ID: ${originalSpId} when saving cache.`,\n        )\n        continue\n      }\n\n      // Calculate delta and approximate\n      const normDelta: { dx?: string; dy?: string; dz?: number } = {}\n      let hasDelta = false\n      if (modifiedPoint.x !== undefined) {\n        const dx = modifiedPoint.x - originalSegmentPoint.x\n        // Only store delta if it's non-zero (within approximation tolerance)\n        const approxDx = approximateDeltaCoordinate(dx)\n        if (parseFloat(approxDx) !== 0) {\n          normDelta.dx = approxDx\n          hasDelta = true\n        }\n      }\n      if (modifiedPoint.y !== undefined) {\n        const dy = modifiedPoint.y - originalSegmentPoint.y\n        const approxDy = approximateDeltaCoordinate(dy)\n        if (parseFloat(approxDy) !== 0) {\n          normDelta.dy = approxDy\n          hasDelta = true\n        }\n      }\n      if (modifiedPoint.z !== undefined) {\n        const dz = modifiedPoint.z - originalSegmentPoint.z\n        // Z doesn't need approximation, store if non-zero\n        if (dz !== 0) {\n          normDelta.dz = dz\n          hasDelta = true\n        }\n      }\n\n      // Only add to cache if there was an actual change\n      if (hasDelta) {\n        normalizedDeltas.push([normSpId, normDelta])\n      }\n    }\n\n    const cachedSolution: CachedSolvedUnravelSection = {\n      success: true,\n      bestCandidatePointModificationsDelta: normalizedDeltas,\n      bestCandidateF: this.bestCandidate.f,\n    }\n\n    this.cacheProvider?.setCachedSolutionSync(this.cacheKey!, cachedSolution)\n  }\n}\n","import { CacheProvider } from \"./types\"\n\n/**\n * An in-memory implementation of the CacheProvider interface.\n * Useful for testing or scenarios where persistence is not required.\n */\nexport class InMemoryCache implements CacheProvider {\n  cacheHitsByPrefix: Record<string, number> = {}\n  cacheMissesByPrefix: Record<string, number> = {}\n  isSyncCache = true\n  cacheHits = 0\n  cacheMisses = 0\n\n  cache: Map<string, any> = new Map()\n\n  /**\n   * Retrieves a cached solution synchronously based on the cache key.\n   * Increments cache hit/miss counters.\n   * @param cacheKey The key to look up in the cache.\n   * @returns The cached solution if found, otherwise undefined.\n   */\n  getCachedSolutionSync(cacheKey: string): any {\n    const cachedSolution = this.cache.get(cacheKey)\n    if (cachedSolution !== undefined) {\n      this.cacheHits++\n      // Return a structured clone to prevent accidental modification of the cached object\n      return structuredClone(cachedSolution)\n    } else {\n      this.cacheMisses++\n      return undefined\n    }\n  }\n\n  /**\n   * Retrieves a cached solution asynchronously. Wraps the synchronous method.\n   * @param cacheKey The key to look up in the cache.\n   * @returns A promise that resolves with the cached solution or undefined.\n   */\n  async getCachedSolution(cacheKey: string): Promise<any> {\n    return this.getCachedSolutionSync(cacheKey)\n  }\n\n  /**\n   * Stores a solution in the cache synchronously.\n   * Uses structured cloning to store a copy, preventing external modifications.\n   * @param cacheKey The key under which to store the solution.\n   * @param cachedSolution The solution data to cache.\n   */\n  setCachedSolutionSync(cacheKey: string, cachedSolution: any): void {\n    // Store a structured clone to prevent external modification of the cached object\n    this.cache.set(cacheKey, structuredClone(cachedSolution))\n  }\n\n  /**\n   * Stores a solution in the cache asynchronously. Wraps the synchronous method.\n   * @param cacheKey The key under which to store the solution.\n   * @param cachedSolution The solution data to cache.\n   * @returns A promise that resolves when the solution is cached.\n   */\n  async setCachedSolution(\n    cacheKey: string,\n    cachedSolution: any,\n  ): Promise<void> {\n    this.setCachedSolutionSync(cacheKey, cachedSolution)\n  }\n\n  /**\n   * Clears the entire cache and resets hit/miss counters.\n   */\n  clearCache(): void {\n    this.cache.clear()\n    this.cacheHits = 0\n    this.cacheMisses = 0\n  }\n\n  getAllCacheKeys(): string[] {\n    return Array.from(this.cache.keys())\n  }\n}\n","import { CacheProvider } from \"./types\"\n\nconst CACHE_PREFIX = \"tscircuit_autorouter_cache_\"\n\n/**\n * A CacheProvider implementation using the browser's localStorage.\n * Note: localStorage has size limits (typically 5-10MB) and stores data as strings.\n * Complex objects will be JSON serialized/deserialized.\n */\nexport class LocalStorageCache implements CacheProvider {\n  isSyncCache = true\n  cacheHits = 0\n  cacheMisses = 0\n\n  cacheHitsByPrefix: Record<string, number> = {}\n  cacheMissesByPrefix: Record<string, number> = {}\n\n  constructor() {}\n\n  private getKey(cacheKey: string): string {\n    return `${CACHE_PREFIX}${cacheKey}`\n  }\n\n  /**\n   * Retrieves a cached solution synchronously from localStorage.\n   * Increments cache hit/miss counters.\n   * @param cacheKey The key to look up in the cache.\n   * @returns The cached solution if found and parsed correctly, otherwise undefined.\n   */\n  getCachedSolutionSync(cacheKey: string): any {\n    if (typeof localStorage === \"undefined\") return undefined\n\n    const key = this.getKey(cacheKey)\n    try {\n      const cachedItem = localStorage.getItem(key)\n      if (cachedItem !== null) {\n        const solution = JSON.parse(cachedItem)\n        this.cacheHits++\n        const prefix = cacheKey.split(\":\")[0]\n        this.cacheHitsByPrefix[prefix] =\n          (this.cacheHitsByPrefix[prefix] || 0) + 1\n        // console.log(`Cache hit (sync) for: ${cacheKey}`)\n        return solution // No need for structuredClone, JSON parse creates a new object\n      } else {\n        this.cacheMisses++\n        const prefix = cacheKey.split(\":\")[0]\n        this.cacheMissesByPrefix[prefix] =\n          (this.cacheMissesByPrefix[prefix] || 0) + 1\n        // console.log(`Cache miss (sync) for: ${cacheKey}`)\n        return undefined\n      }\n    } catch (error) {\n      console.error(`Error getting cached solution sync for ${key}:`, error)\n      this.cacheMisses++ // Count as miss if retrieval/parsing fails\n      const prefix = cacheKey.split(\":\")[0]\n      this.cacheMissesByPrefix[prefix] =\n        (this.cacheMissesByPrefix[prefix] || 0) + 1\n      // Optionally remove the corrupted item\n      // localStorage.removeItem(key);\n      return undefined\n    }\n  }\n\n  /**\n   * Retrieves a cached solution asynchronously. Wraps the synchronous method.\n   * @param cacheKey The key to look up in the cache.\n   * @returns A promise that resolves with the cached solution or undefined.\n   */\n  async getCachedSolution(cacheKey: string): Promise<any> {\n    // localStorage API is synchronous, so we just wrap the sync method\n    return this.getCachedSolutionSync(cacheKey)\n  }\n\n  /**\n   * Stores a solution in localStorage synchronously.\n   * The solution is JSON stringified before storing.\n   * @param cacheKey The key under which to store the solution.\n   * @param cachedSolution The solution data to cache.\n   */\n  setCachedSolutionSync(cacheKey: string, cachedSolution: any): void {\n    if (typeof localStorage === \"undefined\") return\n\n    const key = this.getKey(cacheKey)\n    try {\n      const stringifiedSolution = JSON.stringify(cachedSolution)\n      localStorage.setItem(key, stringifiedSolution)\n    } catch (error) {\n      console.error(`Error setting cached solution sync for ${key}:`, error)\n      // Handle potential storage quota errors\n      if (\n        error instanceof DOMException &&\n        (error.name === \"QuotaExceededError\" ||\n          error.name === \"NS_ERROR_DOM_QUOTA_REACHED\")\n      ) {\n        console.warn(\n          `LocalStorage quota exceeded. Failed to cache solution for ${key}. Consider clearing the cache.`,\n        )\n        // Potential strategy: Implement LRU eviction here\n      }\n    }\n  }\n\n  /**\n   * Stores a solution in the cache asynchronously. Wraps the synchronous method.\n   * @param cacheKey The key under which to store the solution.\n   * @param cachedSolution The solution data to cache.\n   * @returns A promise that resolves when the solution is cached.\n   */\n  async setCachedSolution(\n    cacheKey: string,\n    cachedSolution: any,\n  ): Promise<void> {\n    // localStorage API is synchronous, so we just wrap the sync method\n    this.setCachedSolutionSync(cacheKey, cachedSolution)\n  }\n\n  /**\n   * Clears all cache entries created by this instance from localStorage\n   * and resets hit/miss counters.\n   */\n  clearCache(): void {\n    if (typeof localStorage === \"undefined\") return\n\n    try {\n      const keysToRemove: string[] = []\n      for (let i = 0; i < localStorage.length; i++) {\n        const key = localStorage.key(i)\n        if (key?.startsWith(CACHE_PREFIX)) {\n          keysToRemove.push(key)\n        }\n      }\n      keysToRemove.forEach((key) => localStorage.removeItem(key))\n      console.log(\n        `Cleared ${keysToRemove.length} items from LocalStorage cache.`,\n      )\n    } catch (error) {\n      console.error(\"Error clearing LocalStorage cache:\", error)\n    } finally {\n      this.cacheHits = 0\n      this.cacheMisses = 0\n      this.cacheHitsByPrefix = {}\n      this.cacheMissesByPrefix = {}\n    }\n  }\n\n  getAllCacheKeys(): string[] {\n    const cacheKeys: string[] = []\n    for (let i = 0; i < 10_000; i++) {\n      const keyName = localStorage.key(i)\n      if (!keyName) break\n      if (!keyName.includes(CACHE_PREFIX)) continue\n      cacheKeys.push(keyName)\n    }\n    return cacheKeys\n  }\n}\n","import { InMemoryCache } from \"./InMemoryCache\"\nimport { LocalStorageCache } from \"./LocalStorageCache\"\n\n// Add global declare for globalThis to fix types\ndeclare global {\n  var TSCIRCUIT_AUTOROUTER_LOCAL_STORAGE_CACHE: LocalStorageCache\n  var TSCIRCUIT_AUTOROUTER_IN_MEMORY_CACHE: InMemoryCache\n}\n\nexport function getGlobalLocalStorageCache() {\n  if (!globalThis.TSCIRCUIT_AUTOROUTER_LOCAL_STORAGE_CACHE) {\n    setupGlobalCaches()\n  }\n  return globalThis.TSCIRCUIT_AUTOROUTER_LOCAL_STORAGE_CACHE\n}\n\nexport function getGlobalInMemoryCache() {\n  if (!globalThis.TSCIRCUIT_AUTOROUTER_IN_MEMORY_CACHE) {\n    setupGlobalCaches()\n  }\n  return globalThis.TSCIRCUIT_AUTOROUTER_IN_MEMORY_CACHE\n}\n\nexport function setupGlobalCaches() {\n  globalThis.TSCIRCUIT_AUTOROUTER_LOCAL_STORAGE_CACHE ??=\n    new LocalStorageCache()\n  globalThis.TSCIRCUIT_AUTOROUTER_IN_MEMORY_CACHE ??= new InMemoryCache()\n}\n","/**\n * Calculate a point transformed with an affine matrix\n * @param matrix {Matrix} Affine Matrix\n * @param  point {Point} Point\n * @returns {Point} Point\n */\nexport function applyToPoint (matrix, point) {\n  return Array.isArray(point)\n    ? [\n        matrix.a * point[0] + matrix.c * point[1] + matrix.e,\n        matrix.b * point[0] + matrix.d * point[1] + matrix.f\n      ]\n    : {\n        x: matrix.a * point.x + matrix.c * point.y + matrix.e,\n        y: matrix.b * point.x + matrix.d * point.y + matrix.f\n      }\n}\n\n/**\n * Calculate an array of points transformed with an affine matrix\n * @param matrix {Matrix} Affine Matrix\n * @param points {Point[]} Array of point\n * @returns {Point[]} Array of point\n */\nexport function applyToPoints (matrix, points) {\n  return points.map(point => applyToPoint(matrix, point))\n}\n","/**\n * Calculate a translate matrix\n * @param tx {number} Translation on axis x\n * @param [ty = 0] {number} Translation on axis y\n * @returns {Matrix} Affine Matrix\n */\nexport function translate (tx, ty = 0) {\n  return {\n    a: 1,\n    c: 0,\n    e: tx,\n    b: 0,\n    d: 1,\n    f: ty\n  }\n}\n","import { isUndefined } from './utils'\nimport { translate } from './translate'\nimport { transform } from './transform'\n\nconst { cos, sin, PI } = Math\n/**\n * Calculate a rotation matrix\n * @param angle {number} Angle in radians\n * @param [cx] {number} If (cx,cy) are supplied the rotate is about this point\n * @param [cy] {number} If (cx,cy) are supplied the rotate is about this point\n * @returns {Matrix} Affine Matrix\n */\nexport function rotate (angle, cx, cy) {\n  const cosAngle = cos(angle)\n  const sinAngle = sin(angle)\n  const rotationMatrix = {\n    a: cosAngle,\n    c: -sinAngle,\n    e: 0,\n    b: sinAngle,\n    d: cosAngle,\n    f: 0\n  }\n  if (isUndefined(cx) || isUndefined(cy)) {\n    return rotationMatrix\n  }\n\n  return transform([\n    translate(cx, cy),\n    rotationMatrix,\n    translate(-cx, -cy)\n  ])\n}\n\n/**\n * Calculate a rotation matrix with a DEG angle\n * @param angle {number} Angle in degree\n * @param [cx] {number} If (cx,cy) are supplied the rotate is about this point\n * @param [cy] {number} If (cx,cy) are supplied the rotate is about this point\n * @returns {Matrix} Affine Matrix\n */\nexport function rotateDEG (angle, cx = undefined, cy = undefined) {\n  return rotate(angle * PI / 180, cx, cy)\n}\n","// https://developer.mozilla.org/en-US/docs/Web/CSS/transform-function/skew\nconst { tan } = Math\n\n/**\n * Calculate a skew matrix\n * @param ax {number} Skew on axis x\n * @param ay {number} Skew on axis y\n * @returns {Matrix} Affine Matrix\n */\nexport function skew (ax, ay) {\n  return {\n    a: 1,\n    c: tan(ax),\n    e: 0,\n    b: tan(ay),\n    d: 1,\n    f: 0\n  }\n}\n\n/**\n * Calculate a skew matrix using DEG angles\n * @param ax {number} Skew on axis x\n * @param ay {number} Skew on axis y\n * @returns {Matrix} Affine Matrix\n */\nexport function skewDEG (ax, ay) {\n  return skew(ax * Math.PI / 180, ay * Math.PI / 180)\n}\n","// Generated by Peggy 3.0.2.\n//\n// https://peggyjs.org/\n\nfunction peg$subclass(child, parent) {\n  function C() { this.constructor = child; }\n  C.prototype = parent.prototype;\n  child.prototype = new C();\n}\n\nfunction peg$SyntaxError(message, expected, found, location) {\n  var self = Error.call(this, message);\n  // istanbul ignore next Check is a necessary evil to support older environments\n  if (Object.setPrototypeOf) {\n    Object.setPrototypeOf(self, peg$SyntaxError.prototype);\n  }\n  self.expected = expected;\n  self.found = found;\n  self.location = location;\n  self.name = \"SyntaxError\";\n  return self;\n}\n\npeg$subclass(peg$SyntaxError, Error);\n\nfunction peg$padEnd(str, targetLength, padString) {\n  padString = padString || \" \";\n  if (str.length > targetLength) { return str; }\n  targetLength -= str.length;\n  padString += padString.repeat(targetLength);\n  return str + padString.slice(0, targetLength);\n}\n\npeg$SyntaxError.prototype.format = function(sources) {\n  var str = \"Error: \" + this.message;\n  if (this.location) {\n    var src = null;\n    var k;\n    for (k = 0; k < sources.length; k++) {\n      if (sources[k].source === this.location.source) {\n        src = sources[k].text.split(/\\r\\n|\\n|\\r/g);\n        break;\n      }\n    }\n    var s = this.location.start;\n    var offset_s = (this.location.source && (typeof this.location.source.offset === \"function\"))\n      ? this.location.source.offset(s)\n      : s;\n    var loc = this.location.source + \":\" + offset_s.line + \":\" + offset_s.column;\n    if (src) {\n      var e = this.location.end;\n      var filler = peg$padEnd(\"\", offset_s.line.toString().length, ' ');\n      var line = src[s.line - 1];\n      var last = s.line === e.line ? e.column : line.length + 1;\n      var hatLen = (last - s.column) || 1;\n      str += \"\\n --> \" + loc + \"\\n\"\n          + filler + \" |\\n\"\n          + offset_s.line + \" | \" + line + \"\\n\"\n          + filler + \" | \" + peg$padEnd(\"\", s.column - 1, ' ')\n          + peg$padEnd(\"\", hatLen, \"^\");\n    } else {\n      str += \"\\n at \" + loc;\n    }\n  }\n  return str;\n};\n\npeg$SyntaxError.buildMessage = function(expected, found) {\n  var DESCRIBE_EXPECTATION_FNS = {\n    literal: function(expectation) {\n      return \"\\\"\" + literalEscape(expectation.text) + \"\\\"\";\n    },\n\n    class: function(expectation) {\n      var escapedParts = expectation.parts.map(function(part) {\n        return Array.isArray(part)\n          ? classEscape(part[0]) + \"-\" + classEscape(part[1])\n          : classEscape(part);\n      });\n\n      return \"[\" + (expectation.inverted ? \"^\" : \"\") + escapedParts.join(\"\") + \"]\";\n    },\n\n    any: function() {\n      return \"any character\";\n    },\n\n    end: function() {\n      return \"end of input\";\n    },\n\n    other: function(expectation) {\n      return expectation.description;\n    }\n  };\n\n  function hex(ch) {\n    return ch.charCodeAt(0).toString(16).toUpperCase();\n  }\n\n  function literalEscape(s) {\n    return s\n      .replace(/\\\\/g, \"\\\\\\\\\")\n      .replace(/\"/g,  \"\\\\\\\"\")\n      .replace(/\\0/g, \"\\\\0\")\n      .replace(/\\t/g, \"\\\\t\")\n      .replace(/\\n/g, \"\\\\n\")\n      .replace(/\\r/g, \"\\\\r\")\n      .replace(/[\\x00-\\x0F]/g,          function(ch) { return \"\\\\x0\" + hex(ch); })\n      .replace(/[\\x10-\\x1F\\x7F-\\x9F]/g, function(ch) { return \"\\\\x\"  + hex(ch); });\n  }\n\n  function classEscape(s) {\n    return s\n      .replace(/\\\\/g, \"\\\\\\\\\")\n      .replace(/\\]/g, \"\\\\]\")\n      .replace(/\\^/g, \"\\\\^\")\n      .replace(/-/g,  \"\\\\-\")\n      .replace(/\\0/g, \"\\\\0\")\n      .replace(/\\t/g, \"\\\\t\")\n      .replace(/\\n/g, \"\\\\n\")\n      .replace(/\\r/g, \"\\\\r\")\n      .replace(/[\\x00-\\x0F]/g,          function(ch) { return \"\\\\x0\" + hex(ch); })\n      .replace(/[\\x10-\\x1F\\x7F-\\x9F]/g, function(ch) { return \"\\\\x\"  + hex(ch); });\n  }\n\n  function describeExpectation(expectation) {\n    return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);\n  }\n\n  function describeExpected(expected) {\n    var descriptions = expected.map(describeExpectation);\n    var i, j;\n\n    descriptions.sort();\n\n    if (descriptions.length > 0) {\n      for (i = 1, j = 1; i < descriptions.length; i++) {\n        if (descriptions[i - 1] !== descriptions[i]) {\n          descriptions[j] = descriptions[i];\n          j++;\n        }\n      }\n      descriptions.length = j;\n    }\n\n    switch (descriptions.length) {\n      case 1:\n        return descriptions[0];\n\n      case 2:\n        return descriptions[0] + \" or \" + descriptions[1];\n\n      default:\n        return descriptions.slice(0, -1).join(\", \")\n          + \", or \"\n          + descriptions[descriptions.length - 1];\n    }\n  }\n\n  function describeFound(found) {\n    return found ? \"\\\"\" + literalEscape(found) + \"\\\"\" : \"end of input\";\n  }\n\n  return \"Expected \" + describeExpected(expected) + \" but \" + describeFound(found) + \" found.\";\n};\n\nfunction peg$parse(input, options) {\n  options = options !== undefined ? options : {};\n\n  var peg$FAILED = {};\n  var peg$source = options.grammarSource;\n\n  var peg$startRuleFunctions = { transformList: peg$parsetransformList };\n  var peg$startRuleFunction = peg$parsetransformList;\n\n  var peg$c0 = \"matrix\";\n  var peg$c1 = \"(\";\n  var peg$c2 = \")\";\n  var peg$c3 = \"translate\";\n  var peg$c4 = \"scale\";\n  var peg$c5 = \"rotate\";\n  var peg$c6 = \"skewX\";\n  var peg$c7 = \"skewY\";\n  var peg$c8 = \",\";\n  var peg$c9 = \".\";\n\n  var peg$r0 = /^[eE]/;\n  var peg$r1 = /^[+\\-]/;\n  var peg$r2 = /^[0-9]/;\n  var peg$r3 = /^[ \\t\\r\\n]/;\n\n  var peg$e0 = peg$literalExpectation(\"matrix\", false);\n  var peg$e1 = peg$literalExpectation(\"(\", false);\n  var peg$e2 = peg$literalExpectation(\")\", false);\n  var peg$e3 = peg$literalExpectation(\"translate\", false);\n  var peg$e4 = peg$literalExpectation(\"scale\", false);\n  var peg$e5 = peg$literalExpectation(\"rotate\", false);\n  var peg$e6 = peg$literalExpectation(\"skewX\", false);\n  var peg$e7 = peg$literalExpectation(\"skewY\", false);\n  var peg$e8 = peg$literalExpectation(\",\", false);\n  var peg$e9 = peg$otherExpectation(\"fractionalConstant\");\n  var peg$e10 = peg$literalExpectation(\".\", false);\n  var peg$e11 = peg$classExpectation([\"e\", \"E\"], false, false);\n  var peg$e12 = peg$classExpectation([\"+\", \"-\"], false, false);\n  var peg$e13 = peg$classExpectation([[\"0\", \"9\"]], false, false);\n  var peg$e14 = peg$classExpectation([\" \", \"\\t\", \"\\r\", \"\\n\"], false, false);\n\n  var peg$f0 = function(ts) { return ts; };\n  var peg$f1 = function(t, ts) { return t.concat(ts) };\n  var peg$f2 = function(a, b, c, d, e, f) {\n      return [{type: 'matrix', a: a, b: b, c: c, d: d, e: e, f: f}];\n    };\n  var peg$f3 = function(tx, ty) {\n      var t = {type: 'translate', tx: tx};\n      if (ty) t.ty = ty;\n      return [t];\n    };\n  var peg$f4 = function(sx, sy) {\n      var s = {type:'scale', sx: sx};\n      if (sy) s.sy = sy;\n      return [s];\n    };\n  var peg$f5 = function(angle, c) {\n      var r = {type:'rotate', angle: angle};\n      if (c) {\n        r.cx = c[0];\n        r.cy = c[1];\n      }\n      return [r];\n    };\n  var peg$f6 = function(angle) {\n      return [{type: 'skewX', angle: angle}];\n    };\n  var peg$f7 = function(angle) {\n      return [{type: 'skewY', angle: angle}];\n    };\n  var peg$f8 = function(f) { return parseFloat(f.join(\"\")); };\n  var peg$f9 = function(i) { return parseInt(i.join(\"\")); };\n  var peg$f10 = function(n) { return n; };\n  var peg$f11 = function(n1, n2) { return [n1, n2]; };\n  var peg$f12 = function(ds) { return ds.join(\"\"); };\n  var peg$f13 = function(f, e) { return [f, e || null].join(\"\")};\n  var peg$f14 = function(d, e) { return [d, e].join(\"\")};\n  var peg$f15 = function(d1, d2) { return [d1 ? d1.join(\"\") : null, \".\", d2.join(\"\")].join(\"\"); };\n  var peg$f16 = function(d) { return d.join(\"\"); };\n  var peg$f17 = function(s, d) { return ['e', s, d.join(\"\")].join(\"\") };\n  var peg$currPos = 0;\n  var peg$savedPos = 0;\n  var peg$posDetailsCache = [{ line: 1, column: 1 }];\n  var peg$maxFailPos = 0;\n  var peg$maxFailExpected = [];\n  var peg$silentFails = 0;\n\n  var peg$result;\n\n  if (\"startRule\" in options) {\n    if (!(options.startRule in peg$startRuleFunctions)) {\n      throw new Error(\"Can't start parsing from rule \\\"\" + options.startRule + \"\\\".\");\n    }\n\n    peg$startRuleFunction = peg$startRuleFunctions[options.startRule];\n  }\n\n  function text() {\n    return input.substring(peg$savedPos, peg$currPos);\n  }\n\n  function offset() {\n    return peg$savedPos;\n  }\n\n  function range() {\n    return {\n      source: peg$source,\n      start: peg$savedPos,\n      end: peg$currPos\n    };\n  }\n\n  function location() {\n    return peg$computeLocation(peg$savedPos, peg$currPos);\n  }\n\n  function expected(description, location) {\n    location = location !== undefined\n      ? location\n      : peg$computeLocation(peg$savedPos, peg$currPos);\n\n    throw peg$buildStructuredError(\n      [peg$otherExpectation(description)],\n      input.substring(peg$savedPos, peg$currPos),\n      location\n    );\n  }\n\n  function error(message, location) {\n    location = location !== undefined\n      ? location\n      : peg$computeLocation(peg$savedPos, peg$currPos);\n\n    throw peg$buildSimpleError(message, location);\n  }\n\n  function peg$literalExpectation(text, ignoreCase) {\n    return { type: \"literal\", text: text, ignoreCase: ignoreCase };\n  }\n\n  function peg$classExpectation(parts, inverted, ignoreCase) {\n    return { type: \"class\", parts: parts, inverted: inverted, ignoreCase: ignoreCase };\n  }\n\n  function peg$anyExpectation() {\n    return { type: \"any\" };\n  }\n\n  function peg$endExpectation() {\n    return { type: \"end\" };\n  }\n\n  function peg$otherExpectation(description) {\n    return { type: \"other\", description: description };\n  }\n\n  function peg$computePosDetails(pos) {\n    var details = peg$posDetailsCache[pos];\n    var p;\n\n    if (details) {\n      return details;\n    } else {\n      p = pos - 1;\n      while (!peg$posDetailsCache[p]) {\n        p--;\n      }\n\n      details = peg$posDetailsCache[p];\n      details = {\n        line: details.line,\n        column: details.column\n      };\n\n      while (p < pos) {\n        if (input.charCodeAt(p) === 10) {\n          details.line++;\n          details.column = 1;\n        } else {\n          details.column++;\n        }\n\n        p++;\n      }\n\n      peg$posDetailsCache[pos] = details;\n\n      return details;\n    }\n  }\n\n  function peg$computeLocation(startPos, endPos, offset) {\n    var startPosDetails = peg$computePosDetails(startPos);\n    var endPosDetails = peg$computePosDetails(endPos);\n\n    var res = {\n      source: peg$source,\n      start: {\n        offset: startPos,\n        line: startPosDetails.line,\n        column: startPosDetails.column\n      },\n      end: {\n        offset: endPos,\n        line: endPosDetails.line,\n        column: endPosDetails.column\n      }\n    };\n    if (offset && peg$source && (typeof peg$source.offset === \"function\")) {\n      res.start = peg$source.offset(res.start);\n      res.end = peg$source.offset(res.end);\n    }\n    return res;\n  }\n\n  function peg$fail(expected) {\n    if (peg$currPos < peg$maxFailPos) { return; }\n\n    if (peg$currPos > peg$maxFailPos) {\n      peg$maxFailPos = peg$currPos;\n      peg$maxFailExpected = [];\n    }\n\n    peg$maxFailExpected.push(expected);\n  }\n\n  function peg$buildSimpleError(message, location) {\n    return new peg$SyntaxError(message, null, null, location);\n  }\n\n  function peg$buildStructuredError(expected, found, location) {\n    return new peg$SyntaxError(\n      peg$SyntaxError.buildMessage(expected, found),\n      expected,\n      found,\n      location\n    );\n  }\n\n  function peg$parsetransformList() {\n    var s0, s1, s2, s3, s4;\n\n    s0 = peg$currPos;\n    s1 = [];\n    s2 = peg$parsewsp();\n    while (s2 !== peg$FAILED) {\n      s1.push(s2);\n      s2 = peg$parsewsp();\n    }\n    s2 = peg$parsetransforms();\n    if (s2 === peg$FAILED) {\n      s2 = null;\n    }\n    s3 = [];\n    s4 = peg$parsewsp();\n    while (s4 !== peg$FAILED) {\n      s3.push(s4);\n      s4 = peg$parsewsp();\n    }\n    peg$savedPos = s0;\n    s0 = peg$f0(s2);\n\n    return s0;\n  }\n\n  function peg$parsetransforms() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    s1 = peg$parsetransform();\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      s3 = peg$parsecommaWsp();\n      if (s3 !== peg$FAILED) {\n        while (s3 !== peg$FAILED) {\n          s2.push(s3);\n          s3 = peg$parsecommaWsp();\n        }\n      } else {\n        s2 = peg$FAILED;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsetransforms();\n        if (s3 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s0 = peg$f1(s1, s3);\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    if (s0 === peg$FAILED) {\n      s0 = peg$parsetransform();\n    }\n\n    return s0;\n  }\n\n  function peg$parsetransform() {\n    var s0;\n\n    s0 = peg$parsematrix();\n    if (s0 === peg$FAILED) {\n      s0 = peg$parsetranslate();\n      if (s0 === peg$FAILED) {\n        s0 = peg$parsescale();\n        if (s0 === peg$FAILED) {\n          s0 = peg$parserotate();\n          if (s0 === peg$FAILED) {\n            s0 = peg$parseskewX();\n            if (s0 === peg$FAILED) {\n              s0 = peg$parseskewY();\n            }\n          }\n        }\n      }\n    }\n\n    return s0;\n  }\n\n  function peg$parsematrix() {\n    var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, s13, s14, s15, s16, s17;\n\n    s0 = peg$currPos;\n    if (input.substr(peg$currPos, 6) === peg$c0) {\n      s1 = peg$c0;\n      peg$currPos += 6;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e0); }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      s3 = peg$parsewsp();\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$parsewsp();\n      }\n      if (input.charCodeAt(peg$currPos) === 40) {\n        s3 = peg$c1;\n        peg$currPos++;\n      } else {\n        s3 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$e1); }\n      }\n      if (s3 !== peg$FAILED) {\n        s4 = [];\n        s5 = peg$parsewsp();\n        while (s5 !== peg$FAILED) {\n          s4.push(s5);\n          s5 = peg$parsewsp();\n        }\n        s5 = peg$parsenumber();\n        if (s5 !== peg$FAILED) {\n          s6 = peg$parsecommaWsp();\n          if (s6 !== peg$FAILED) {\n            s7 = peg$parsenumber();\n            if (s7 !== peg$FAILED) {\n              s8 = peg$parsecommaWsp();\n              if (s8 !== peg$FAILED) {\n                s9 = peg$parsenumber();\n                if (s9 !== peg$FAILED) {\n                  s10 = peg$parsecommaWsp();\n                  if (s10 !== peg$FAILED) {\n                    s11 = peg$parsenumber();\n                    if (s11 !== peg$FAILED) {\n                      s12 = peg$parsecommaWsp();\n                      if (s12 !== peg$FAILED) {\n                        s13 = peg$parsenumber();\n                        if (s13 !== peg$FAILED) {\n                          s14 = peg$parsecommaWsp();\n                          if (s14 !== peg$FAILED) {\n                            s15 = peg$parsenumber();\n                            if (s15 !== peg$FAILED) {\n                              s16 = [];\n                              s17 = peg$parsewsp();\n                              while (s17 !== peg$FAILED) {\n                                s16.push(s17);\n                                s17 = peg$parsewsp();\n                              }\n                              if (input.charCodeAt(peg$currPos) === 41) {\n                                s17 = peg$c2;\n                                peg$currPos++;\n                              } else {\n                                s17 = peg$FAILED;\n                                if (peg$silentFails === 0) { peg$fail(peg$e2); }\n                              }\n                              if (s17 !== peg$FAILED) {\n                                peg$savedPos = s0;\n                                s0 = peg$f2(s5, s7, s9, s11, s13, s15);\n                              } else {\n                                peg$currPos = s0;\n                                s0 = peg$FAILED;\n                              }\n                            } else {\n                              peg$currPos = s0;\n                              s0 = peg$FAILED;\n                            }\n                          } else {\n                            peg$currPos = s0;\n                            s0 = peg$FAILED;\n                          }\n                        } else {\n                          peg$currPos = s0;\n                          s0 = peg$FAILED;\n                        }\n                      } else {\n                        peg$currPos = s0;\n                        s0 = peg$FAILED;\n                      }\n                    } else {\n                      peg$currPos = s0;\n                      s0 = peg$FAILED;\n                    }\n                  } else {\n                    peg$currPos = s0;\n                    s0 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsetranslate() {\n    var s0, s1, s2, s3, s4, s5, s6, s7, s8;\n\n    s0 = peg$currPos;\n    if (input.substr(peg$currPos, 9) === peg$c3) {\n      s1 = peg$c3;\n      peg$currPos += 9;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e3); }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      s3 = peg$parsewsp();\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$parsewsp();\n      }\n      if (input.charCodeAt(peg$currPos) === 40) {\n        s3 = peg$c1;\n        peg$currPos++;\n      } else {\n        s3 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$e1); }\n      }\n      if (s3 !== peg$FAILED) {\n        s4 = [];\n        s5 = peg$parsewsp();\n        while (s5 !== peg$FAILED) {\n          s4.push(s5);\n          s5 = peg$parsewsp();\n        }\n        s5 = peg$parsenumber();\n        if (s5 !== peg$FAILED) {\n          s6 = peg$parsecommaWspNumber();\n          if (s6 === peg$FAILED) {\n            s6 = null;\n          }\n          s7 = [];\n          s8 = peg$parsewsp();\n          while (s8 !== peg$FAILED) {\n            s7.push(s8);\n            s8 = peg$parsewsp();\n          }\n          if (input.charCodeAt(peg$currPos) === 41) {\n            s8 = peg$c2;\n            peg$currPos++;\n          } else {\n            s8 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$e2); }\n          }\n          if (s8 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s0 = peg$f3(s5, s6);\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsescale() {\n    var s0, s1, s2, s3, s4, s5, s6, s7, s8;\n\n    s0 = peg$currPos;\n    if (input.substr(peg$currPos, 5) === peg$c4) {\n      s1 = peg$c4;\n      peg$currPos += 5;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e4); }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      s3 = peg$parsewsp();\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$parsewsp();\n      }\n      if (input.charCodeAt(peg$currPos) === 40) {\n        s3 = peg$c1;\n        peg$currPos++;\n      } else {\n        s3 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$e1); }\n      }\n      if (s3 !== peg$FAILED) {\n        s4 = [];\n        s5 = peg$parsewsp();\n        while (s5 !== peg$FAILED) {\n          s4.push(s5);\n          s5 = peg$parsewsp();\n        }\n        s5 = peg$parsenumber();\n        if (s5 !== peg$FAILED) {\n          s6 = peg$parsecommaWspNumber();\n          if (s6 === peg$FAILED) {\n            s6 = null;\n          }\n          s7 = [];\n          s8 = peg$parsewsp();\n          while (s8 !== peg$FAILED) {\n            s7.push(s8);\n            s8 = peg$parsewsp();\n          }\n          if (input.charCodeAt(peg$currPos) === 41) {\n            s8 = peg$c2;\n            peg$currPos++;\n          } else {\n            s8 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$e2); }\n          }\n          if (s8 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s0 = peg$f4(s5, s6);\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parserotate() {\n    var s0, s1, s2, s3, s4, s5, s6, s7, s8;\n\n    s0 = peg$currPos;\n    if (input.substr(peg$currPos, 6) === peg$c5) {\n      s1 = peg$c5;\n      peg$currPos += 6;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e5); }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      s3 = peg$parsewsp();\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$parsewsp();\n      }\n      if (input.charCodeAt(peg$currPos) === 40) {\n        s3 = peg$c1;\n        peg$currPos++;\n      } else {\n        s3 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$e1); }\n      }\n      if (s3 !== peg$FAILED) {\n        s4 = [];\n        s5 = peg$parsewsp();\n        while (s5 !== peg$FAILED) {\n          s4.push(s5);\n          s5 = peg$parsewsp();\n        }\n        s5 = peg$parsenumber();\n        if (s5 !== peg$FAILED) {\n          s6 = peg$parsecommaWspTwoNumbers();\n          if (s6 === peg$FAILED) {\n            s6 = null;\n          }\n          s7 = [];\n          s8 = peg$parsewsp();\n          while (s8 !== peg$FAILED) {\n            s7.push(s8);\n            s8 = peg$parsewsp();\n          }\n          if (input.charCodeAt(peg$currPos) === 41) {\n            s8 = peg$c2;\n            peg$currPos++;\n          } else {\n            s8 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$e2); }\n          }\n          if (s8 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s0 = peg$f5(s5, s6);\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseskewX() {\n    var s0, s1, s2, s3, s4, s5, s6, s7;\n\n    s0 = peg$currPos;\n    if (input.substr(peg$currPos, 5) === peg$c6) {\n      s1 = peg$c6;\n      peg$currPos += 5;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e6); }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      s3 = peg$parsewsp();\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$parsewsp();\n      }\n      if (input.charCodeAt(peg$currPos) === 40) {\n        s3 = peg$c1;\n        peg$currPos++;\n      } else {\n        s3 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$e1); }\n      }\n      if (s3 !== peg$FAILED) {\n        s4 = [];\n        s5 = peg$parsewsp();\n        while (s5 !== peg$FAILED) {\n          s4.push(s5);\n          s5 = peg$parsewsp();\n        }\n        s5 = peg$parsenumber();\n        if (s5 !== peg$FAILED) {\n          s6 = [];\n          s7 = peg$parsewsp();\n          while (s7 !== peg$FAILED) {\n            s6.push(s7);\n            s7 = peg$parsewsp();\n          }\n          if (input.charCodeAt(peg$currPos) === 41) {\n            s7 = peg$c2;\n            peg$currPos++;\n          } else {\n            s7 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$e2); }\n          }\n          if (s7 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s0 = peg$f6(s5);\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseskewY() {\n    var s0, s1, s2, s3, s4, s5, s6, s7;\n\n    s0 = peg$currPos;\n    if (input.substr(peg$currPos, 5) === peg$c7) {\n      s1 = peg$c7;\n      peg$currPos += 5;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e7); }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      s3 = peg$parsewsp();\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$parsewsp();\n      }\n      if (input.charCodeAt(peg$currPos) === 40) {\n        s3 = peg$c1;\n        peg$currPos++;\n      } else {\n        s3 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$e1); }\n      }\n      if (s3 !== peg$FAILED) {\n        s4 = [];\n        s5 = peg$parsewsp();\n        while (s5 !== peg$FAILED) {\n          s4.push(s5);\n          s5 = peg$parsewsp();\n        }\n        s5 = peg$parsenumber();\n        if (s5 !== peg$FAILED) {\n          s6 = [];\n          s7 = peg$parsewsp();\n          while (s7 !== peg$FAILED) {\n            s6.push(s7);\n            s7 = peg$parsewsp();\n          }\n          if (input.charCodeAt(peg$currPos) === 41) {\n            s7 = peg$c2;\n            peg$currPos++;\n          } else {\n            s7 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$e2); }\n          }\n          if (s7 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s0 = peg$f7(s5);\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsenumber() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    s1 = peg$currPos;\n    s2 = peg$parsesign();\n    if (s2 === peg$FAILED) {\n      s2 = null;\n    }\n    s3 = peg$parsefloatingPointConstant();\n    if (s3 !== peg$FAILED) {\n      s2 = [s2, s3];\n      s1 = s2;\n    } else {\n      peg$currPos = s1;\n      s1 = peg$FAILED;\n    }\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = s0;\n      s1 = peg$f8(s1);\n    }\n    s0 = s1;\n    if (s0 === peg$FAILED) {\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parsesign();\n      if (s2 === peg$FAILED) {\n        s2 = null;\n      }\n      s3 = peg$parseintegerConstant();\n      if (s3 !== peg$FAILED) {\n        s2 = [s2, s3];\n        s1 = s2;\n      } else {\n        peg$currPos = s1;\n        s1 = peg$FAILED;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$f9(s1);\n      }\n      s0 = s1;\n    }\n\n    return s0;\n  }\n\n  function peg$parsecommaWspNumber() {\n    var s0, s1, s2;\n\n    s0 = peg$currPos;\n    s1 = peg$parsecommaWsp();\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parsenumber();\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s0 = peg$f10(s2);\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsecommaWspTwoNumbers() {\n    var s0, s1, s2, s3, s4;\n\n    s0 = peg$currPos;\n    s1 = peg$parsecommaWsp();\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parsenumber();\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsecommaWsp();\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parsenumber();\n          if (s4 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s0 = peg$f11(s2, s4);\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsecommaWsp() {\n    var s0, s1, s2, s3, s4;\n\n    s0 = peg$currPos;\n    s1 = [];\n    s2 = peg$parsewsp();\n    if (s2 !== peg$FAILED) {\n      while (s2 !== peg$FAILED) {\n        s1.push(s2);\n        s2 = peg$parsewsp();\n      }\n    } else {\n      s1 = peg$FAILED;\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parsecomma();\n      if (s2 === peg$FAILED) {\n        s2 = null;\n      }\n      s3 = [];\n      s4 = peg$parsewsp();\n      while (s4 !== peg$FAILED) {\n        s3.push(s4);\n        s4 = peg$parsewsp();\n      }\n      s1 = [s1, s2, s3];\n      s0 = s1;\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    if (s0 === peg$FAILED) {\n      s0 = peg$currPos;\n      s1 = peg$parsecomma();\n      if (s1 !== peg$FAILED) {\n        s2 = [];\n        s3 = peg$parsewsp();\n        while (s3 !== peg$FAILED) {\n          s2.push(s3);\n          s3 = peg$parsewsp();\n        }\n        s1 = [s1, s2];\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    }\n\n    return s0;\n  }\n\n  function peg$parsecomma() {\n    var s0;\n\n    if (input.charCodeAt(peg$currPos) === 44) {\n      s0 = peg$c8;\n      peg$currPos++;\n    } else {\n      s0 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e8); }\n    }\n\n    return s0;\n  }\n\n  function peg$parseintegerConstant() {\n    var s0, s1;\n\n    s0 = peg$currPos;\n    s1 = peg$parsedigitSequence();\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = s0;\n      s1 = peg$f12(s1);\n    }\n    s0 = s1;\n\n    return s0;\n  }\n\n  function peg$parsefloatingPointConstant() {\n    var s0, s1, s2;\n\n    s0 = peg$currPos;\n    s1 = peg$parsefractionalConstant();\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parseexponent();\n      if (s2 === peg$FAILED) {\n        s2 = null;\n      }\n      peg$savedPos = s0;\n      s0 = peg$f13(s1, s2);\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    if (s0 === peg$FAILED) {\n      s0 = peg$currPos;\n      s1 = peg$parsedigitSequence();\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parseexponent();\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s0 = peg$f14(s1, s2);\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    }\n\n    return s0;\n  }\n\n  function peg$parsefractionalConstant() {\n    var s0, s1, s2, s3;\n\n    peg$silentFails++;\n    s0 = peg$currPos;\n    s1 = peg$parsedigitSequence();\n    if (s1 === peg$FAILED) {\n      s1 = null;\n    }\n    if (input.charCodeAt(peg$currPos) === 46) {\n      s2 = peg$c9;\n      peg$currPos++;\n    } else {\n      s2 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e10); }\n    }\n    if (s2 !== peg$FAILED) {\n      s3 = peg$parsedigitSequence();\n      if (s3 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s0 = peg$f15(s1, s3);\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    if (s0 === peg$FAILED) {\n      s0 = peg$currPos;\n      s1 = peg$parsedigitSequence();\n      if (s1 !== peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 46) {\n          s2 = peg$c9;\n          peg$currPos++;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$e10); }\n        }\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s0 = peg$f16(s1);\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    }\n    peg$silentFails--;\n    if (s0 === peg$FAILED) {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e9); }\n    }\n\n    return s0;\n  }\n\n  function peg$parseexponent() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    if (peg$r0.test(input.charAt(peg$currPos))) {\n      s1 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e11); }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parsesign();\n      if (s2 === peg$FAILED) {\n        s2 = null;\n      }\n      s3 = peg$parsedigitSequence();\n      if (s3 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s0 = peg$f17(s2, s3);\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsesign() {\n    var s0;\n\n    if (peg$r1.test(input.charAt(peg$currPos))) {\n      s0 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s0 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e12); }\n    }\n\n    return s0;\n  }\n\n  function peg$parsedigitSequence() {\n    var s0, s1;\n\n    s0 = [];\n    s1 = peg$parsedigit();\n    if (s1 !== peg$FAILED) {\n      while (s1 !== peg$FAILED) {\n        s0.push(s1);\n        s1 = peg$parsedigit();\n      }\n    } else {\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsedigit() {\n    var s0;\n\n    if (peg$r2.test(input.charAt(peg$currPos))) {\n      s0 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s0 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e13); }\n    }\n\n    return s0;\n  }\n\n  function peg$parsewsp() {\n    var s0;\n\n    if (peg$r3.test(input.charAt(peg$currPos))) {\n      s0 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s0 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e14); }\n    }\n\n    return s0;\n  }\n\n  peg$result = peg$startRuleFunction();\n\n  if (peg$result !== peg$FAILED && peg$currPos === input.length) {\n    return peg$result;\n  } else {\n    if (peg$result !== peg$FAILED && peg$currPos < input.length) {\n      peg$fail(peg$endExpectation());\n    }\n\n    throw peg$buildStructuredError(\n      peg$maxFailExpected,\n      peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,\n      peg$maxFailPos < input.length\n        ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1)\n        : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)\n    );\n  }\n}\n\nexport {\n  peg$SyntaxError as SyntaxError,\n\n  peg$parse as parse\n};\n","import { NodePortSegment } from \"lib/types/capacity-edges-to-port-segments-types\"\nimport { SegmentWithAssignedPoints } from \"../CapacityMeshSolver/CapacitySegmentToPointSolver\"\n\n/**\n * Deduplicates segments with the same start and end points.\n * Assigns a unique ID to each unique segment and ensures all segments with the same\n * start/end points share the same ID.\n * @param assignedSegments The segments to deduplicate\n * @returns Deduplicated segments with unique IDs\n */\nexport const getDedupedSegments = (\n  assignedSegments: NodePortSegment[],\n): SegmentWithAssignedPoints[] => {\n  const dedupedSegments: SegmentWithAssignedPoints[] = []\n  type SegKey = `${number}-${number}-${number}-${number}-${string}`\n  const dedupedSegPointMap: Map<SegKey, NodePortSegment> = new Map()\n  let highestSegmentId = -1\n\n  for (const seg of assignedSegments) {\n    // Check if there's another segment with the same start and end and availableZ\n    const segKey: SegKey = `${seg.start.x}-${seg.start.y}-${seg.end.x}-${seg.end.y}-${seg.availableZ.join(\",\")}`\n    const existingSeg = dedupedSegPointMap.get(segKey)\n\n    if (!existingSeg) {\n      highestSegmentId++\n      seg.nodePortSegmentId = `SEG${highestSegmentId}`\n      dedupedSegPointMap.set(segKey, seg)\n      dedupedSegments.push(seg)\n      continue\n    }\n\n    seg.nodePortSegmentId = existingSeg.nodePortSegmentId\n  }\n\n  return dedupedSegments\n}\n","import { doSegmentsIntersect } from \"@tscircuit/math-utils\"\nimport { SegmentPoint } from \"lib/solvers/UnravelSolver/types\"\n\nexport const getIntraNodeCrossingsFromSegmentPoints = (\n  segmentPoints: SegmentPoint[],\n) => {\n  // Count the number of crossings\n  let numSameLayerCrossings = 0\n  let numEntryExitLayerChanges = 0\n  let numTransitionCrossings = 0\n\n  // Group segment points by connection name\n  const connectionGroups = new Map<string, SegmentPoint[]>()\n\n  for (const point of segmentPoints) {\n    if (!connectionGroups.has(point.connectionName)) {\n      connectionGroups.set(point.connectionName, [])\n    }\n    connectionGroups.get(point.connectionName)!.push(point)\n  }\n\n  const pointPairs: {\n    points: { x: number; y: number; z: number }[]\n    z: number\n    connectionName: string\n  }[] = []\n\n  const transitionPairPoints: {\n    points: { x: number; y: number; z: number }[]\n    connectionName: string\n  }[] = []\n\n  // Process each connection group\n  for (const [connectionName, points] of connectionGroups.entries()) {\n    if (points.length < 2) continue\n\n    // For simplicity, we'll just connect the first point to all others in the group\n    // This assumes a simple connection pattern\n    const firstPoint = points[0]\n\n    for (let i = 1; i < points.length; i++) {\n      const secondPoint = points[i]\n\n      const pointPair = {\n        connectionName,\n        z: firstPoint.z,\n        points: [firstPoint, secondPoint],\n      }\n\n      if (firstPoint.z !== secondPoint.z) {\n        numEntryExitLayerChanges++\n        transitionPairPoints.push({\n          connectionName,\n          points: [firstPoint, secondPoint],\n        })\n      } else {\n        pointPairs.push(pointPair)\n      }\n    }\n  }\n\n  // Check for same layer crossings\n  for (let i = 0; i < pointPairs.length; i++) {\n    for (let j = i + 1; j < pointPairs.length; j++) {\n      const pair1 = pointPairs[i]\n      const pair2 = pointPairs[j]\n\n      if (\n        pair1.z === pair2.z &&\n        doSegmentsIntersect(\n          pair1.points[0],\n          pair1.points[1],\n          pair2.points[0],\n          pair2.points[1],\n        )\n      ) {\n        numSameLayerCrossings++\n      }\n    }\n  }\n\n  // Check for transition crossings\n  for (let i = 0; i < transitionPairPoints.length; i++) {\n    for (let j = i + 1; j < transitionPairPoints.length; j++) {\n      const pair1 = transitionPairPoints[i]\n      const pair2 = transitionPairPoints[j]\n\n      if (\n        doSegmentsIntersect(\n          pair1.points[0],\n          pair1.points[1],\n          pair2.points[0],\n          pair2.points[1],\n        )\n      ) {\n        numTransitionCrossings++\n      }\n    }\n  }\n\n  // Check for crossings between transition pairs and regular pairs\n  for (let i = 0; i < transitionPairPoints.length; i++) {\n    for (let j = 0; j < pointPairs.length; j++) {\n      const pair1 = transitionPairPoints[i]\n      const pair2 = pointPairs[j]\n\n      if (\n        doSegmentsIntersect(\n          pair1.points[0],\n          pair1.points[1],\n          pair2.points[0],\n          pair2.points[1],\n        )\n      ) {\n        numTransitionCrossings++\n      }\n    }\n  }\n\n  return {\n    numSameLayerCrossings,\n    numEntryExitLayerChanges,\n    numTransitionCrossings,\n  }\n}\n","import { CapacityMeshNode, CapacityMeshNodeId } from \"lib/types\"\nimport { getTunedTotalCapacity1 } from \"lib/utils/getTunedTotalCapacity1\"\nimport { SegmentWithAssignedPoints } from \"../CapacityMeshSolver/CapacitySegmentToPointSolver\"\nimport { UnravelSectionSolver } from \"./UnravelSectionSolver\"\nimport { CachedUnravelSectionSolver } from \"./CachedUnravelSectionSolver\"\nimport { getIntraNodeCrossings } from \"lib/utils/getIntraNodeCrossings\"\nimport { NodePortSegment } from \"lib/types/capacity-edges-to-port-segments-types\"\nimport { getDedupedSegments } from \"./getDedupedSegments\"\nimport { getIntraNodeCrossingsFromSegments } from \"lib/utils/getIntraNodeCrossingsFromSegments\"\nimport { calculateNodeProbabilityOfFailure } from \"./calculateCrossingProbabilityOfFailure\"\nimport { BaseSolver } from \"../BaseSolver\"\nimport { GraphicsObject } from \"graphics-debug\"\nimport { NodeWithPortPoints } from \"lib/types/high-density-types\"\nimport {\n  PointModificationsMap,\n  SegmentId,\n  SegmentPoint,\n  SegmentPointId,\n  SegmentPointMap,\n} from \"./types\"\nimport { createSegmentPointMap } from \"./createSegmentPointMap\"\nimport { getIntraNodeCrossingsFromSegmentPoints } from \"lib/utils/getIntraNodeCrossingsFromSegmentPoints\"\nimport { getNodesNearNode } from \"./getNodesNearNode\"\nimport { CacheProvider } from \"lib/cache/types\"\n\nexport class UnravelMultiSectionSolver extends BaseSolver {\n  nodeMap: Map<CapacityMeshNodeId, CapacityMeshNode>\n  dedupedSegmentMap: Map<SegmentId, SegmentWithAssignedPoints>\n  dedupedSegments: SegmentWithAssignedPoints[]\n  nodeIdToSegmentIds: Map<CapacityMeshNodeId, CapacityMeshNodeId[]>\n  segmentIdToNodeIds: Map<CapacityMeshNodeId, CapacityMeshNodeId[]>\n  nodeToSegmentPointMap: Map<CapacityMeshNodeId, SegmentPointId[]>\n  segmentToSegmentPointMap: Map<SegmentId, SegmentPointId[]>\n  colorMap: Record<string, string>\n  tunedNodeCapacityMap: Map<CapacityMeshNodeId, number>\n\n  MAX_NODE_ATTEMPTS = 2\n\n  MUTABLE_HOPS = 1\n\n  ACCEPTABLE_PF = 0.05\n\n  MAX_ITERATIONS_WITHOUT_IMPROVEMENT = 200\n\n  /**\n   * Probability of failure for each node\n   */\n  nodePfMap: Map<CapacityMeshNodeId, number>\n\n  attemptsToFixNode: Map<CapacityMeshNodeId, number>\n\n  activeSubSolver: UnravelSectionSolver | null = null\n\n  segmentPointMap: SegmentPointMap\n\n  cacheProvider: CacheProvider | null = null\n\n  constructor({\n    assignedSegments,\n    colorMap,\n    nodes,\n    cacheProvider,\n  }: {\n    assignedSegments: NodePortSegment[]\n    colorMap?: Record<string, string>\n    /**\n     * This isn't used by the algorithm, but allows associating metadata\n     * for the result datatype (the center, width, height of the node)\n     */\n    nodes: CapacityMeshNode[]\n    cacheProvider?: CacheProvider | null\n  }) {\n    super()\n\n    this.stats.successfulOptimizations = 0\n    this.stats.failedOptimizations = 0\n    this.stats.cacheHits = 0\n    this.stats.cacheMisses = 0\n\n    this.cacheProvider = cacheProvider ?? null\n\n    this.MAX_ITERATIONS = 1e6\n\n    this.dedupedSegments = getDedupedSegments(assignedSegments)\n    this.dedupedSegmentMap = new Map()\n    for (const segment of this.dedupedSegments) {\n      this.dedupedSegmentMap.set(segment.nodePortSegmentId!, segment)\n    }\n    this.nodeMap = new Map()\n    for (const node of nodes) {\n      this.nodeMap.set(node.capacityMeshNodeId, node)\n    }\n\n    this.nodeIdToSegmentIds = new Map()\n    this.segmentIdToNodeIds = new Map()\n    this.attemptsToFixNode = new Map()\n\n    for (const segment of assignedSegments) {\n      this.segmentIdToNodeIds.set(segment.nodePortSegmentId!, [\n        ...(this.segmentIdToNodeIds.get(segment.nodePortSegmentId!) ?? []),\n        segment.capacityMeshNodeId,\n      ])\n      this.nodeIdToSegmentIds.set(segment.capacityMeshNodeId, [\n        ...(this.nodeIdToSegmentIds.get(segment.capacityMeshNodeId) ?? []),\n        segment.nodePortSegmentId!,\n      ])\n    }\n\n    this.colorMap = colorMap ?? {}\n\n    // Compute tuned capacity for each node\n    this.tunedNodeCapacityMap = new Map()\n    for (const [nodeId, node] of this.nodeMap) {\n      this.tunedNodeCapacityMap.set(nodeId, getTunedTotalCapacity1(node))\n    }\n\n    const { segmentPointMap, nodeToSegmentPointMap, segmentToSegmentPointMap } =\n      createSegmentPointMap(this.dedupedSegments, this.segmentIdToNodeIds)\n\n    this.segmentPointMap = segmentPointMap\n    this.nodeToSegmentPointMap = nodeToSegmentPointMap\n    this.segmentToSegmentPointMap = segmentToSegmentPointMap\n\n    this.nodePfMap = this.computeInitialPfMap()\n  }\n\n  computeInitialPfMap() {\n    const pfMap = new Map<CapacityMeshNodeId, number>()\n\n    for (const [nodeId, node] of this.nodeMap.entries()) {\n      pfMap.set(nodeId, this.computeNodePf(node))\n    }\n\n    return pfMap\n  }\n\n  computeNodePf(node: CapacityMeshNode) {\n    const {\n      numSameLayerCrossings,\n      numEntryExitLayerChanges,\n      numTransitionCrossings,\n    } = getIntraNodeCrossingsFromSegmentPoints(\n      (this.nodeToSegmentPointMap.get(node.capacityMeshNodeId) ?? []).map(\n        (segPointId) => this.segmentPointMap.get(segPointId)!,\n      ),\n    )\n\n    const probabilityOfFailure = calculateNodeProbabilityOfFailure(\n      node,\n      numSameLayerCrossings,\n      numEntryExitLayerChanges,\n      numTransitionCrossings,\n    )\n\n    return probabilityOfFailure\n  }\n\n  _step() {\n    if (this.iterations >= this.MAX_ITERATIONS - 1) {\n      this.solved = true\n      return\n    }\n    if (!this.activeSubSolver) {\n      // Find the node with the highest probability of failure\n      let highestPfNodeId = null\n      let highestPf = 0\n      for (const [nodeId, pf] of this.nodePfMap.entries()) {\n        const pfReduced =\n          pf *\n          (1 -\n            (this.attemptsToFixNode.get(nodeId) ?? 0) / this.MAX_NODE_ATTEMPTS)\n        if (pfReduced > highestPf) {\n          highestPf = pf\n          highestPfNodeId = nodeId\n        }\n      }\n\n      if (!highestPfNodeId || highestPf < this.ACCEPTABLE_PF) {\n        this.solved = true\n        return\n      }\n\n      this.attemptsToFixNode.set(\n        highestPfNodeId,\n        (this.attemptsToFixNode.get(highestPfNodeId) ?? 0) + 1,\n      )\n      this.activeSubSolver = new CachedUnravelSectionSolver({\n        dedupedSegments: this.dedupedSegments,\n        dedupedSegmentMap: this.dedupedSegmentMap,\n        nodeMap: this.nodeMap,\n        nodeIdToSegmentIds: this.nodeIdToSegmentIds,\n        segmentIdToNodeIds: this.segmentIdToNodeIds,\n        colorMap: this.colorMap,\n        rootNodeId: highestPfNodeId,\n        MUTABLE_HOPS: this.MUTABLE_HOPS,\n        segmentPointMap: this.segmentPointMap,\n        nodeToSegmentPointMap: this.nodeToSegmentPointMap,\n        segmentToSegmentPointMap: this.segmentToSegmentPointMap,\n        cacheProvider: this.cacheProvider,\n      })\n    }\n\n    this.activeSubSolver.step()\n\n    const { bestCandidate, originalCandidate, lastProcessedCandidate } =\n      this.activeSubSolver\n\n    // const shouldEarlyStop =\n    //   this.activeSubSolver.iterationsSinceImprovement >\n    //   this.MAX_ITERATIONS_WITHOUT_IMPROVEMENT\n\n    // cn90994\n    if (this.activeSubSolver.failed) {\n      this.stats.failedOptimizations += 1\n      this.activeSubSolver = null\n      return\n    }\n    if (this.activeSubSolver.solved) {\n      if (this.activeSubSolver.cacheHit) {\n        this.stats.cacheHits += 1\n      } else {\n        this.stats.cacheMisses += 1\n      }\n\n      // Incorporate the changes from the active solver\n      const foundBetterSolution =\n        bestCandidate && bestCandidate.g < originalCandidate!.g\n\n      if (foundBetterSolution) {\n        this.stats.successfulOptimizations += 1\n        // Modify the points using the pointModifications of the candidate\n        for (const [\n          segmentPointId,\n          pointModification,\n        ] of bestCandidate.pointModifications.entries()) {\n          const segmentPoint = this.segmentPointMap.get(segmentPointId)!\n          segmentPoint.x = pointModification.x ?? segmentPoint.x\n          segmentPoint.y = pointModification.y ?? segmentPoint.y\n          segmentPoint.z = pointModification.z ?? segmentPoint.z\n        }\n\n        // Update node failure probabilities\n        for (const nodeId of this.activeSubSolver.unravelSection.allNodeIds) {\n          this.nodePfMap.set(\n            nodeId,\n            this.computeNodePf(this.nodeMap.get(nodeId)!),\n          )\n        }\n      } else {\n        // did not find better solution\n        this.stats.failedOptimizations += 1\n      }\n\n      this.activeSubSolver = null\n    }\n  }\n\n  visualize(): GraphicsObject {\n    if (this.activeSubSolver) {\n      return this.activeSubSolver.visualize()\n    }\n\n    const graphics: Required<GraphicsObject> = {\n      lines: [],\n      points: [],\n      rects: [],\n      circles: [],\n      coordinateSystem: \"cartesian\",\n      title: \"Unravel Multi Section Solver\",\n    }\n\n    // Visualize nodes\n    for (const [nodeId, node] of this.nodeMap.entries()) {\n      const probabilityOfFailure = this.nodePfMap.get(nodeId) || 0\n      // Color based on probability of failure - red for high, gradient to green for low\n      const pf = Math.min(probabilityOfFailure, 1) // Cap at 1\n      const red = Math.floor(255 * pf)\n      const green = Math.floor(255 * (1 - pf))\n      const color = `rgb(${red}, ${green}, 0)`\n\n      if ((this.attemptsToFixNode.get(nodeId) ?? 0) === 0 && pf === 0) {\n        continue\n      }\n\n      graphics.rects.push({\n        center: node.center,\n        label: [\n          nodeId,\n          `${node.width.toFixed(2)}x${node.height.toFixed(2)}`,\n          `Pf: ${probabilityOfFailure.toFixed(3)}`,\n        ].join(\"\\n\"),\n        color,\n        width: node.width / 8,\n        height: node.height / 8,\n      })\n    }\n\n    // Visualize segment points\n    for (const segmentPoint of this.segmentPointMap.values()) {\n      const segment = this.dedupedSegmentMap.get(segmentPoint.segmentId)\n      graphics.points.push({\n        x: segmentPoint.x,\n        y: segmentPoint.y,\n        label: [\n          segmentPoint.segmentPointId,\n          segmentPoint.segmentId,\n          `z: ${segmentPoint.z}`,\n          `segment.availableZ: ${segment?.availableZ.join(\",\")}`,\n        ].join(\"\\n\"),\n        color: this.colorMap[segmentPoint.connectionName] || \"#000\",\n      })\n    }\n\n    // Connect segment points that belong to the same segment\n    // Group points by segment ID\n    const pointsBySegment = new Map<string, SegmentPoint[]>()\n    for (const point of this.segmentPointMap.values()) {\n      if (!pointsBySegment.has(point.segmentId)) {\n        pointsBySegment.set(point.segmentId, [])\n      }\n      pointsBySegment.get(point.segmentId)!.push(point)\n    }\n\n    // Connect points in each segment\n    for (const [segmentId, points] of pointsBySegment.entries()) {\n      if (points.length < 2) continue\n\n      // Sort points by some logical order (this approximates the correct ordering)\n      const sortedPoints = [...points].sort((a, b) =>\n        a.x !== b.x ? a.x - b.x : a.y - b.y,\n      )\n\n      // Connect adjacent points in the sorted order\n      for (let i = 0; i < sortedPoints.length - 1; i++) {\n        graphics.lines.push({\n          points: [\n            { x: sortedPoints[i].x, y: sortedPoints[i].y },\n            { x: sortedPoints[i + 1].x, y: sortedPoints[i + 1].y },\n          ],\n          strokeColor: this.colorMap[segmentId] || \"#000\",\n        })\n      }\n    }\n\n    // Connect points with the same connection name that share a node\n    const processedConnections = new Set<string>()\n    const allPoints = Array.from(this.segmentPointMap.values())\n\n    for (let i = 0; i < allPoints.length; i++) {\n      const point1 = allPoints[i]\n      for (let j = i + 1; j < allPoints.length; j++) {\n        const point2 = allPoints[j]\n\n        // Skip if they have different connection names or are in the same segment\n        if (\n          point1.connectionName !== point2.connectionName ||\n          point1.segmentId === point2.segmentId\n        ) {\n          continue\n        }\n\n        // Check if they share a node\n        const hasSharedNode = point1.capacityMeshNodeIds.some((nodeId) =>\n          point2.capacityMeshNodeIds.includes(nodeId),\n        )\n\n        if (hasSharedNode) {\n          const connectionKey = `${point1.segmentPointId}-${point2.segmentPointId}`\n          if (processedConnections.has(connectionKey)) continue\n          processedConnections.add(connectionKey)\n\n          // Determine line style based on layer (z) values\n          const sameLayer = point1.z === point2.z\n          const layer = point1.z\n\n          let strokeDash: string | undefined\n          if (sameLayer) {\n            strokeDash = layer === 0 ? undefined : \"10 5\" // Solid for layer 0, long dash for other layers\n          } else {\n            strokeDash = \"3 3 10\" // Mixed dash for transitions between layers\n          }\n\n          graphics.lines.push({\n            points: [\n              { x: point1.x, y: point1.y },\n              { x: point2.x, y: point2.y },\n            ],\n            strokeDash,\n            strokeColor: this.colorMap[point1.connectionName] || \"#666\",\n          })\n        }\n      }\n    }\n    return graphics\n  }\n\n  getNodesWithPortPoints(): NodeWithPortPoints[] {\n    if (!this.solved) {\n      throw new Error(\n        \"CapacitySegmentToPointSolver not solved, can't give port points yet\",\n      )\n    }\n    const nodeWithPortPointsMap = new Map<string, NodeWithPortPoints>()\n    for (const segment of this.dedupedSegments) {\n      const segId = segment.nodePortSegmentId!\n      for (const nodeId of this.segmentIdToNodeIds.get(segId)!) {\n        const node = this.nodeMap.get(nodeId)!\n        if (!nodeWithPortPointsMap.has(nodeId)) {\n          nodeWithPortPointsMap.set(nodeId, {\n            capacityMeshNodeId: nodeId,\n            portPoints: [],\n            center: node.center,\n            width: node.width,\n            height: node.height,\n          })\n        }\n      }\n    }\n\n    for (const segmentPoint of this.segmentPointMap.values()) {\n      for (const nodeId of segmentPoint.capacityMeshNodeIds) {\n        const nodeWithPortPoints = nodeWithPortPointsMap.get(nodeId)\n        if (nodeWithPortPoints) {\n          nodeWithPortPoints.portPoints.push({\n            x: segmentPoint.x,\n            y: segmentPoint.y,\n            z: segmentPoint.z,\n            connectionName: segmentPoint.connectionName,\n          })\n        }\n      }\n    }\n\n    return Array.from(nodeWithPortPointsMap.values())\n  }\n}\n","import { Rect } from \"graphics-debug\"\nimport { CapacityMeshNode } from \"lib/types\"\n\nexport const createRectFromCapacityNode = (\n  node: CapacityMeshNode,\n  opts: {\n    rectMargin?: number\n    zOffset?: number\n  } = {},\n): Rect => {\n  const lowestZ = Math.min(...node.availableZ)\n  return {\n    center:\n      !opts.rectMargin || opts.zOffset\n        ? {\n            x: node.center.x + lowestZ * node.width * (opts.zOffset ?? 0.05),\n            y: node.center.y - lowestZ * node.width * (opts.zOffset ?? 0.05),\n          }\n        : node.center,\n    width: opts.rectMargin\n      ? node.width - opts.rectMargin * 2\n      : Math.max(node.width - 0.5, node.width * 0.8),\n    height: opts.rectMargin\n      ? node.height - opts.rectMargin * 2\n      : Math.max(node.height - 0.5, node.height * 0.8),\n    fill: node._containsObstacle\n      ? \"rgba(255,0,0,0.1)\"\n      : ({\n          \"0,1\": \"rgba(0,0,0,0.1)\",\n          \"0\": \"rgba(0,200,200, 0.1)\",\n          \"1\": \"rgba(0,0,200, 0.1)\",\n        }[node.availableZ.join(\",\")] ?? \"rgba(0,200,200,0.1)\"),\n    layer: `z${node.availableZ.join(\",\")}`,\n    label: [\n      node.capacityMeshNodeId,\n      `availableZ: ${node.availableZ.join(\",\")}`,\n      `${node._containsTarget ? \"containsTarget\" : \"\"}`,\n      `${node._containsObstacle ? \"containsObstacle\" : \"\"}`,\n    ]\n      .filter(Boolean)\n      .join(\"\\n\"),\n  }\n}\n","import { BaseSolver } from \"../BaseSolver\"\nimport type {\n  CapacityMeshEdge,\n  CapacityMeshNode,\n  CapacityMeshNodeId,\n  CapacityPath,\n  SimpleRouteConnection,\n  SimpleRouteJson,\n} from \"../../types\"\nimport { getNodeEdgeMap } from \"../CapacityMeshSolver/getNodeEdgeMap\"\nimport { distance } from \"@tscircuit/math-utils\"\nimport { CapacityHyperParameters } from \"../CapacityHyperParameters\"\nimport { GraphicsObject } from \"graphics-debug\"\nimport { safeTransparentize } from \"../colors\"\nimport { createRectFromCapacityNode } from \"lib/utils/createRectFromCapacityNode\"\n\nexport type Candidate = {\n  prevCandidate: Candidate | null\n  node: CapacityMeshNode\n  f: number\n  g: number\n  h: number\n}\n\nexport type ConnectionPathWithNodes = {\n  connection: SimpleRouteConnection\n  nodes: CapacityMeshNode[]\n  path?: CapacityMeshNode[]\n  straightLineDistance: number\n}\n\nexport class CapacityPathingSolver extends BaseSolver {\n  connectionsWithNodes: Array<ConnectionPathWithNodes>\n\n  usedNodeCapacityMap: Map<CapacityMeshNodeId, number>\n\n  simpleRouteJson: SimpleRouteJson\n  nodes: CapacityMeshNode[]\n  edges: CapacityMeshEdge[]\n  GREEDY_MULTIPLIER = 1.1\n  MAX_CANDIDATES_IN_MEMORY = 10_000\n\n  nodeMap: Map<CapacityMeshNodeId, CapacityMeshNode>\n  nodeEdgeMap: Map<CapacityMeshNodeId, CapacityMeshEdge[]>\n  connectionNameToGoalNodeIds: Map<string, CapacityMeshNodeId[]>\n  colorMap: Record<string, string>\n  maxDepthOfNodes: number\n\n  activeCandidateStraightLineDistance?: number\n\n  debug_lastNodeCostMap: Map<\n    CapacityMeshNodeId,\n    {\n      g: number\n      h: number\n      f: number\n    }\n  >\n\n  hyperParameters: Partial<CapacityHyperParameters>\n\n  constructor({\n    simpleRouteJson,\n    nodes,\n    edges,\n    colorMap,\n    MAX_ITERATIONS = 1e6,\n    hyperParameters = {},\n  }: {\n    simpleRouteJson: SimpleRouteJson\n    nodes: CapacityMeshNode[]\n    edges: CapacityMeshEdge[]\n    colorMap?: Record<string, string>\n    MAX_ITERATIONS?: number\n    hyperParameters?: Partial<CapacityHyperParameters>\n  }) {\n    super()\n    this.MAX_ITERATIONS = MAX_ITERATIONS\n    this.simpleRouteJson = simpleRouteJson\n    this.nodes = nodes\n    this.edges = edges\n    this.colorMap = colorMap ?? {}\n    const { connectionsWithNodes, connectionNameToGoalNodeIds } =\n      this.getConnectionsWithNodes()\n    this.connectionsWithNodes = connectionsWithNodes\n    this.connectionNameToGoalNodeIds = connectionNameToGoalNodeIds\n    this.hyperParameters = hyperParameters\n    this.usedNodeCapacityMap = new Map(\n      this.nodes.map((node) => [node.capacityMeshNodeId, 0]),\n    )\n    this.nodeMap = new Map(\n      this.nodes.map((node) => [node.capacityMeshNodeId, node]),\n    )\n    this.nodeEdgeMap = getNodeEdgeMap(this.edges)\n    this.maxDepthOfNodes = Math.max(\n      ...this.nodes.map((node) => node._depth ?? 0),\n    )\n    this.debug_lastNodeCostMap = new Map()\n  }\n\n  getTotalCapacity(node: CapacityMeshNode): number {\n    const depth = node._depth ?? 0\n    return (this.maxDepthOfNodes - depth + 1) ** 2\n  }\n\n  getConnectionsWithNodes() {\n    const connectionsWithNodes: Array<{\n      connection: SimpleRouteConnection\n      nodes: CapacityMeshNode[]\n      pathFound: boolean\n      straightLineDistance: number\n    }> = []\n    const nodesWithTargets = this.nodes.filter((node) => node._containsTarget)\n    const connectionNameToGoalNodeIds = new Map<string, CapacityMeshNodeId[]>()\n\n    for (const connection of this.simpleRouteJson.connections) {\n      const nodesForConnection: CapacityMeshNode[] = []\n      for (const point of connection.pointsToConnect) {\n        let closestNode = this.nodes[0]\n        let minDistance = Number.MAX_VALUE\n\n        for (const node of nodesWithTargets) {\n          const distance = Math.sqrt(\n            (node.center.x - point.x) ** 2 + (node.center.y - point.y) ** 2,\n          )\n          if (distance < minDistance) {\n            minDistance = distance\n            closestNode = node\n          }\n        }\n        nodesForConnection.push(closestNode)\n      }\n      if (nodesForConnection.length < 2) {\n        throw new Error(\n          `Not enough nodes for connection \"${connection.name}\", only ${nodesForConnection.length} found`,\n        )\n      }\n      connectionNameToGoalNodeIds.set(\n        connection.name,\n        nodesForConnection.map((n) => n.capacityMeshNodeId),\n      )\n      connectionsWithNodes.push({\n        connection,\n        nodes: nodesForConnection,\n        pathFound: false,\n        straightLineDistance: distance(\n          nodesForConnection[0].center,\n          nodesForConnection[nodesForConnection.length - 1].center,\n        ),\n      })\n    }\n\n    connectionsWithNodes.sort(\n      (a, b) => a.straightLineDistance - b.straightLineDistance,\n    )\n    return { connectionsWithNodes, connectionNameToGoalNodeIds }\n  }\n\n  currentConnectionIndex = 0\n\n  candidates?: Array<Candidate> | null\n  visitedNodes?: Set<CapacityMeshNodeId> | null\n\n  computeG(\n    prevCandidate: Candidate,\n    node: CapacityMeshNode,\n    endGoal: CapacityMeshNode,\n  ) {\n    return (\n      prevCandidate.g + this.getDistanceBetweenNodes(prevCandidate.node, node)\n    )\n  }\n\n  computeH(\n    prevCandidate: Candidate,\n    node: CapacityMeshNode,\n    endGoal: CapacityMeshNode,\n  ) {\n    return this.getDistanceBetweenNodes(node, endGoal)\n  }\n\n  getBacktrackedPath(candidate: Candidate) {\n    const path: CapacityMeshNode[] = []\n    let currentCandidate = candidate\n    while (currentCandidate) {\n      path.push(currentCandidate.node)\n      currentCandidate = currentCandidate.prevCandidate!\n    }\n    return path\n  }\n\n  getNeighboringNodes(node: CapacityMeshNode) {\n    return this.nodeEdgeMap\n      .get(node.capacityMeshNodeId)!\n      .flatMap((edge): CapacityMeshNodeId[] =>\n        edge.nodeIds.filter((n) => n !== node.capacityMeshNodeId),\n      )\n      .map((n) => this.nodeMap.get(n)!)\n  }\n\n  getCapacityPaths() {\n    const capacityPaths: CapacityPath[] = []\n    for (const connection of this.connectionsWithNodes) {\n      const path = connection.path\n      if (path) {\n        capacityPaths.push({\n          capacityPathId: connection.connection.name,\n          connectionName: connection.connection.name,\n          nodeIds: path.map((node) => node.capacityMeshNodeId),\n        })\n      }\n    }\n    return capacityPaths\n  }\n\n  doesNodeHaveCapacityForTrace(\n    node: CapacityMeshNode,\n    prevNode: CapacityMeshNode,\n  ) {\n    const usedCapacity =\n      this.usedNodeCapacityMap.get(node.capacityMeshNodeId) ?? 0\n    const totalCapacity = this.getTotalCapacity(node)\n\n    // Single layer nodes can't safely have multiple traces because there's no\n    // way to cross over two traces without a via\n    if (\n      node.availableZ.length === 1 &&\n      !node._containsTarget &&\n      usedCapacity > 0\n    )\n      return false\n\n    let additionalCapacityRequirement = 0\n    if (node.availableZ.length > 1 && prevNode.availableZ.length === 1) {\n      additionalCapacityRequirement += 0.5\n    }\n\n    return usedCapacity + additionalCapacityRequirement < totalCapacity\n  }\n\n  canTravelThroughObstacle(node: CapacityMeshNode, connectionName: string) {\n    const goalNodeIds = this.connectionNameToGoalNodeIds.get(connectionName)\n\n    return goalNodeIds?.includes(node.capacityMeshNodeId) ?? false\n  }\n\n  getDistanceBetweenNodes(A: CapacityMeshNode, B: CapacityMeshNode) {\n    return Math.sqrt(\n      (A.center.x - B.center.x) ** 2 + (A.center.y - B.center.y) ** 2,\n    )\n  }\n\n  reduceCapacityAlongPath(nextConnection: { path?: CapacityMeshNode[] }) {\n    for (const node of nextConnection.path ?? []) {\n      this.usedNodeCapacityMap.set(\n        node.capacityMeshNodeId,\n        this.usedNodeCapacityMap.get(node.capacityMeshNodeId)! + 1,\n      )\n    }\n  }\n\n  isConnectedToEndGoal(node: CapacityMeshNode, endGoal: CapacityMeshNode) {\n    return this.nodeEdgeMap\n      .get(node.capacityMeshNodeId)!\n      .some((edge) => edge.nodeIds.includes(endGoal.capacityMeshNodeId))\n  }\n\n  _step() {\n    const nextConnection =\n      this.connectionsWithNodes[this.currentConnectionIndex]\n    if (!nextConnection) {\n      this.solved = true\n      return\n    }\n    const [start, end] = nextConnection.nodes\n    if (!this.candidates) {\n      this.candidates = [{ prevCandidate: null, node: start, f: 0, g: 0, h: 0 }]\n      this.debug_lastNodeCostMap = new Map()\n      this.visitedNodes = new Set([start.capacityMeshNodeId])\n      this.activeCandidateStraightLineDistance = distance(\n        start.center,\n        end.center,\n      )\n    }\n\n    this.candidates.sort((a, b) => a.f - b.f)\n    const currentCandidate = this.candidates.shift()\n    if (this.candidates.length > this.MAX_CANDIDATES_IN_MEMORY) {\n      this.candidates.splice(\n        this.MAX_CANDIDATES_IN_MEMORY,\n        this.candidates.length - this.MAX_CANDIDATES_IN_MEMORY,\n      )\n    }\n    if (!currentCandidate) {\n      // TODO Track failed paths, make sure solver doesn't think it solved\n      console.error(\n        `Ran out of candidates on connection ${nextConnection.connection.name}`,\n      )\n      this.currentConnectionIndex++\n      this.candidates = null\n      this.visitedNodes = null\n      this.failed = true\n      return\n    }\n    if (this.isConnectedToEndGoal(currentCandidate.node, end)) {\n      nextConnection.path = this.getBacktrackedPath({\n        prevCandidate: currentCandidate,\n        node: end,\n        f: 0,\n        g: 0,\n        h: 0,\n      })\n\n      this.reduceCapacityAlongPath(nextConnection)\n\n      this.currentConnectionIndex++\n      this.candidates = null\n      this.visitedNodes = null\n      return\n    }\n\n    const neighborNodes = this.getNeighboringNodes(currentCandidate.node)\n    for (const neighborNode of neighborNodes) {\n      if (this.visitedNodes?.has(neighborNode.capacityMeshNodeId)) {\n        continue\n      }\n      if (\n        !this.doesNodeHaveCapacityForTrace(neighborNode, currentCandidate.node)\n      ) {\n        continue\n      }\n      const connectionName =\n        this.connectionsWithNodes[this.currentConnectionIndex].connection.name\n      if (\n        neighborNode._containsObstacle &&\n        !this.canTravelThroughObstacle(neighborNode, connectionName)\n      ) {\n        continue\n      }\n      const g = this.computeG(currentCandidate, neighborNode, end)\n      const h = this.computeH(currentCandidate, neighborNode, end)\n      const f = g + h * this.GREEDY_MULTIPLIER\n\n      this.debug_lastNodeCostMap.set(neighborNode.capacityMeshNodeId, {\n        f,\n        g,\n        h,\n      })\n\n      const newCandidate = {\n        prevCandidate: currentCandidate,\n        node: neighborNode,\n        f,\n        g,\n        h,\n      }\n      this.candidates.push(newCandidate)\n    }\n    this.visitedNodes!.add(currentCandidate.node.capacityMeshNodeId)\n  }\n\n  visualize(): GraphicsObject {\n    const graphics: GraphicsObject = {\n      lines: [],\n      points: [],\n      rects: [],\n      circles: [],\n    }\n\n    // Visualize each solved connection path (draw a line through each node's center)\n    if (this.connectionsWithNodes) {\n      for (let i = 0; i < this.connectionsWithNodes.length; i++) {\n        const conn = this.connectionsWithNodes[i]\n        if (conn.path && conn.path.length > 0) {\n          const pathPoints = conn.path.map(\n            ({ center: { x, y }, width, availableZ }) => ({\n              // slight offset to allow viewing overlapping paths\n              x: x + ((i % 10) + (i % 19)) * (0.005 * width),\n              y: y + ((i % 10) + (i % 19)) * (0.005 * width),\n              availableZ,\n            }),\n          )\n          graphics.lines!.push({\n            points: pathPoints,\n            strokeColor: this.colorMap[conn.connection.name],\n          })\n          for (let u = 0; u < pathPoints.length; u++) {\n            const point = pathPoints[u]\n            graphics.points!.push({\n              x: point.x,\n              y: point.y,\n              label: [\n                `conn: ${conn.connection.name}`,\n                `node: ${conn.path[u].capacityMeshNodeId}`,\n                `z: ${point.availableZ.join(\",\")}`,\n              ].join(\"\\n\"),\n            })\n          }\n        }\n      }\n    }\n\n    for (const node of this.nodes) {\n      const usedCapacity =\n        this.usedNodeCapacityMap.get(node.capacityMeshNodeId) ?? 0\n      const totalCapacity = this.getTotalCapacity(node)\n      const nodeCosts = this.debug_lastNodeCostMap.get(node.capacityMeshNodeId)\n      graphics.rects!.push({\n        ...createRectFromCapacityNode(node, {\n          rectMargin: 0.025,\n          zOffset: 0.01,\n        }),\n        label: [\n          `${node.capacityMeshNodeId}`,\n          `${usedCapacity}/${totalCapacity}`,\n          `${node.width.toFixed(2)}x${node.height.toFixed(2)}`,\n          `g: ${nodeCosts?.g !== undefined ? nodeCosts.g.toFixed(2) : \"?\"}`,\n          `h: ${nodeCosts?.h !== undefined ? nodeCosts.h.toFixed(2) : \"?\"}`,\n          `f: ${nodeCosts?.f !== undefined ? nodeCosts.f.toFixed(2) : \"?\"}`,\n          `z: ${node.availableZ.join(\", \")}`,\n        ].join(\"\\n\"),\n        stroke: usedCapacity > totalCapacity + 0.5 ? \"red\" : undefined,\n      })\n    }\n\n    // Visualize connection points from each connection as circles\n    if (this.connectionsWithNodes) {\n      for (const conn of this.connectionsWithNodes) {\n        if (conn.connection?.pointsToConnect) {\n          for (const point of conn.connection.pointsToConnect) {\n            graphics.points!.push({\n              x: point.x,\n              y: point.y,\n              label: [`pointsToConnect ${conn.connection.name}`].join(\"\\n\"),\n            })\n          }\n        }\n      }\n    }\n\n    // Draw a dashed line from the start node to the end node\n    const nextConnection =\n      this.connectionsWithNodes[this.currentConnectionIndex]\n    if (nextConnection) {\n      const [start, end] = nextConnection.connection.pointsToConnect\n      graphics.lines!.push({\n        points: [\n          { x: start.x, y: start.y },\n          { x: end.x, y: end.y },\n        ],\n        strokeColor: \"red\",\n        strokeDash: \"10 5\",\n      })\n    }\n\n    // Visualize backtracked path of highest ranked candidate\n    if (this.candidates) {\n      // Get top 10 candidates\n      const topCandidates = this.candidates.slice(0, 5)\n      const connectionName =\n        this.connectionsWithNodes[this.currentConnectionIndex].connection.name\n\n      // Add paths for each candidate with decreasing opacity\n      topCandidates.forEach((candidate, index) => {\n        const opacity = 0.5 * (1 - index / 5) // Opacity decreases from 0.5 to 0.05\n        const backtrackedPath = this.getBacktrackedPath(candidate)\n        graphics.lines!.push({\n          points: backtrackedPath.map(({ center: { x, y } }) => ({ x, y })),\n          strokeColor: safeTransparentize(\n            this.colorMap[connectionName] ?? \"red\",\n            1 - opacity,\n          ),\n        })\n      })\n    }\n\n    return graphics\n  }\n}\n","import type { CapacityMeshNode } from \"lib/types\"\nimport { CapacityPathingSolver, type Candidate } from \"./CapacityPathingSolver\"\nimport { getTunedTotalCapacity1 } from \"lib/utils/getTunedTotalCapacity1\"\n\nexport class CapacityPathingSolver5 extends CapacityPathingSolver {\n  NEGATIVE_CAPACITY_PENALTY_FACTOR = 1\n  REDUCED_CAPACITY_PENALTY_FACTOR = 1\n\n  constructor(...args: ConstructorParameters<typeof CapacityPathingSolver>) {\n    super(...args)\n    this.GREEDY_MULTIPLIER = 2.5\n  }\n\n  get maxCapacityFactor() {\n    return this.hyperParameters.MAX_CAPACITY_FACTOR ?? 1\n  }\n\n  getTotalCapacity(node: CapacityMeshNode): number {\n    return getTunedTotalCapacity1(node, this.maxCapacityFactor)\n  }\n\n  /**\n   * Penalty you pay for using this node\n   */\n  getNodeCapacityPenalty(node: CapacityMeshNode): number {\n    // return 0.05\n\n    const MAX_PENALTY = node.width + node.height\n    const MIN_PENALTY = 0.05\n\n    const START_PENALIZING_CAPACITY_WHEN_IT_DROPS_BELOW = 2\n\n    const totalCapacity = this.getTotalCapacity(node)\n    const usedCapacity =\n      this.usedNodeCapacityMap.get(node.capacityMeshNodeId) ?? 0\n    const remainingCapacity = totalCapacity - usedCapacity\n\n    if (remainingCapacity > START_PENALIZING_CAPACITY_WHEN_IT_DROPS_BELOW) {\n      return MIN_PENALTY\n    }\n\n    const penalty =\n      (MAX_PENALTY - MIN_PENALTY) *\n        Math.max(\n          1,\n          (START_PENALIZING_CAPACITY_WHEN_IT_DROPS_BELOW - remainingCapacity) /\n            (MAX_PENALTY - MIN_PENALTY),\n        ) +\n      MIN_PENALTY\n\n    return penalty\n    // const penalty =\n    //   (MAX_PENALTY - MIN_PENALTY) *\n    //   (remainingCapacity / START_PENALIZING_CAPACITY_WHEN_IT_DROPS_BELOW)\n\n    // return penalty\n    // if (node.availableZ.length === 1) {\n    //   return 0\n    // }\n\n    // const dist = this.activeCandidateStraightLineDistance!\n\n    // if (remainingCapacity <= 0) {\n    //   //  | Total Cap | Remaining Cap | Remaining Cap Ratio | PenaltySLD    |\n    //   //  | 1         | 0             | (-( 0) + 1) / 1     | 1^2  = 1      |\n    //   //  | 1         | -1            | (-(-1) + 1) / 1     | 2^2  = 4      |\n    //   //  | 1         | -2            | (-(-2) + 1) / 1     | 3^2  = 9      |\n    //   //  | 2         | 0             | (-( 0) + 1) / 2     | 0.5^2 = 0.25  |\n    //   //  | 2         | -1            | (-(-1) + 1) / 2     | 1^2 = 1       |\n    //   //  | 2         | -2            | (-(-2) + 1) / 2     | 2^2 = 4       |\n    //   //  | 2         | -3            | (-(-3) + 1) / 2     | 3^2 = 9       |\n    //   //  | 3         | 0             | (-( 0) + 1) / 3     | 0.333^2= 0.111|\n    //   //  | 3         | -1            | (-(-1) + 1) / 3     | 0.666^2= 0.444|\n    //   //  | 3         | -2            | (-(-2) + 1) / 3     | 1^2 = 1       |\n    //   //  | 3         | -3            | (-(-3) + 1) / 3     | 2^2 = 4       |\n    //   const penalty =\n    //     ((-remainingCapacity + 1) / totalCapacity) *\n    //     dist *\n    //     (this.NEGATIVE_CAPACITY_PENALTY_FACTOR / 4)\n\n    //   return penalty ** 2\n    // }\n\n    // This node still has capacity, but penalize as we reduce the capacity\n    // return (\n    //   ((1 / remainingCapacity) * dist * this.REDUCED_CAPACITY_PENALTY_FACTOR) /\n    //   8\n    // )\n  }\n\n  /**\n   * We're rewarding travel into big nodes.\n   *\n   * To minimize shortest path, you'd want to comment this out.\n   */\n  getDistanceBetweenNodes(A: CapacityMeshNode, B: CapacityMeshNode) {\n    const dx = A.center.x - B.center.x\n    const dy = A.center.y - B.center.y\n\n    return Math.sqrt(dx ** 2 + dy ** 2)\n\n    // REWARD BIG NODE TRAVEL\n    // const szx = Math.max(A.width, B.width)\n    // const szy = Math.max(A.height, B.height)\n\n    // const dist = Math.sqrt(dx ** 2 + dy ** 2) / (szx * szy)\n\n    // return dist\n  }\n\n  computeG(\n    prevCandidate: Candidate,\n    node: CapacityMeshNode,\n    endGoal: CapacityMeshNode,\n  ) {\n    return (\n      prevCandidate.g +\n      this.getDistanceBetweenNodes(prevCandidate.node, node) +\n      this.getNodeCapacityPenalty(node)\n    )\n  }\n\n  computeH(\n    prevCandidate: Candidate,\n    node: CapacityMeshNode,\n    endGoal: CapacityMeshNode,\n  ) {\n    return (\n      this.getDistanceBetweenNodes(node, endGoal) +\n      this.getNodeCapacityPenalty(node)\n    )\n  }\n}\n","import { CapacityMeshNode } from \"lib/types\"\nimport { CapacityPathingSolver5 } from \"../CapacityPathingSolver/CapacityPathingSolver5\"\n\nexport class CapacityPathingGreedySolver extends CapacityPathingSolver5 {\n  doesNodeHaveCapacityForTrace(\n    node: CapacityMeshNode,\n    prevNode: CapacityMeshNode,\n  ): boolean {\n    return true\n  }\n\n  getNodeCapacityPenalty(node: CapacityMeshNode): number {\n    /**\n     * Roughly, -1 remaining capacity is penalized to this much distance\n     */\n    const mmPenaltyFactor = 2\n    const MIN_PENALTY = 0.05\n    const totalCapacity = this.getTotalCapacity(node)\n    const usedCapacity =\n      this.usedNodeCapacityMap.get(node.capacityMeshNodeId) ?? 0\n    const remainingCapacity = totalCapacity - usedCapacity - 1\n    if (remainingCapacity > 0) {\n      return 0\n    }\n    // const probabilityOfFailure = calculateNodeProbabilityOfFailure(\n    //   usedCapacity,\n    //   totalCapacity,\n    //   node.availableZ.length,\n    // )\n    let singleLayerUsagePenaltyFactor = 1\n    if (node.availableZ.length === 1) {\n      singleLayerUsagePenaltyFactor = 10\n    }\n    return (\n      (MIN_PENALTY + Math.abs(remainingCapacity) * mmPenaltyFactor) *\n      singleLayerUsagePenaltyFactor\n    )\n  }\n}\n","import { CapacityMeshNode } from \"lib/types\"\n\n// Helper interfaces\ninterface Point {\n  x: number\n  y: number\n}\ninterface Rect {\n  center: Point\n  width: number\n  height: number\n}\n\n/**\n * Calculates the intersection point of a ray starting from startPoint towards endPoint\n * with the boundary of an axis-aligned rectangle.\n * Returns the intersection point closest to startPoint along the ray.\n */\nfunction getEdgeIntersectionPoint(\n  startPoint: Point,\n  endPoint: Point,\n  rect: Rect,\n): Point {\n  const dx = endPoint.x - startPoint.x\n  const dy = endPoint.y - startPoint.y\n\n  // Handle cases where start and end points are the same or very close\n  if (Math.abs(dx) < 1e-9 && Math.abs(dy) < 1e-9) return startPoint\n\n  const halfWidth = rect.width / 2\n  const halfHeight = rect.height / 2\n  const minX = rect.center.x - halfWidth\n  const maxX = rect.center.x + halfWidth\n  const minY = rect.center.y - halfHeight\n  const maxY = rect.center.y + halfHeight\n\n  let tmin = 0 // Start checking from the origin of the ray\n  let tmax = Infinity // Assume ray extends infinitely\n\n  // Check intersection with vertical slab\n  if (Math.abs(dx) > 1e-9) {\n    const tx1 = (minX - startPoint.x) / dx\n    const tx2 = (maxX - startPoint.x) / dx\n    tmin = Math.max(tmin, Math.min(tx1, tx2))\n    tmax = Math.min(tmax, Math.max(tx1, tx2))\n  } else if (startPoint.x < minX || startPoint.x > maxX) {\n    // Ray is parallel to Y-axis and outside the vertical slab\n    return startPoint // Or handle as no intersection\n  }\n\n  // Check intersection with horizontal slab\n  if (Math.abs(dy) > 1e-9) {\n    const ty1 = (minY - startPoint.y) / dy\n    const ty2 = (maxY - startPoint.y) / dy\n    tmin = Math.max(tmin, Math.min(ty1, ty2))\n    tmax = Math.min(tmax, Math.max(ty1, ty2))\n  } else if (startPoint.y < minY || startPoint.y > maxY) {\n    // Ray is parallel to X-axis and outside the horizontal slab\n    return startPoint // Or handle as no intersection\n  }\n\n  // Check if the intersection interval is valid\n  if (\n    tmax < tmin ||\n    tmin === Infinity ||\n    tmin < -1e9 /* allow slight numerical errors */\n  ) {\n    // Fallback: If the start point is inside, the first intersection (tmin) should be valid.\n    // If calculation fails unexpectedly, return startPoint as a safe fallback.\n    return startPoint\n  }\n\n  // Calculate the intersection point using tmin (the first intersection along the ray)\n  const intersectX = startPoint.x + dx * tmin\n  const intersectY = startPoint.y + dy * tmin\n\n  return { x: intersectX, y: intersectY }\n}\n\n/**\n * Calculates the start and end points for drawing a line representing an edge\n * between two CapacityMeshNodes, inset slightly from the node boundaries.\n *\n * @param nodeA The first node.\n * @param nodeB The second node.\n * @returns An object containing the start and end points { lineStart: Point, lineEnd: Point }.\n */\nexport function getLinesBetweenNodes(\n  nodeA: CapacityMeshNode,\n  nodeB: CapacityMeshNode,\n): { lineStart: Point; lineEnd: Point } {\n  const centerA = nodeA.center\n  const centerB = nodeB.center\n\n  // Calculate intersection points with outer boundaries\n  const intersectA = getEdgeIntersectionPoint(centerA, centerB, nodeA)\n  const intersectB = getEdgeIntersectionPoint(centerB, centerA, nodeB)\n\n  // Calculate vector from A to B\n  const vec = { dx: centerB.x - centerA.x, dy: centerB.y - centerA.y }\n  const len = Math.sqrt(vec.dx * vec.dx + vec.dy * vec.dy)\n\n  let lineStart = intersectA\n  let lineEnd = intersectB\n\n  if (len > 1e-9) {\n    // Avoid division by zero if centers are coincident\n    const unitVec = { x: vec.dx / len, y: vec.dy / len }\n\n    // Calculate margins (e.g., 30% of the node's width)\n    const marginA = 0.3 * nodeA.width\n    const marginB = 0.3 * nodeB.width\n\n    // Calculate the distance between the intersection points\n    const distIntersectAIntersectB = Math.sqrt(\n      (intersectB.x - intersectA.x) ** 2 + (intersectB.y - intersectA.y) ** 2,\n    )\n\n    // Only apply margin if it doesn't exceed the distance between intersection points\n    if (marginA + marginB < distIntersectAIntersectB) {\n      lineStart = {\n        x: intersectA.x + unitVec.x * marginA,\n        y: intersectA.y + unitVec.y * marginA,\n      }\n      lineEnd = {\n        x: intersectB.x - unitVec.x * marginB,\n        y: intersectB.y - unitVec.y * marginB,\n      }\n    } else {\n      // If margins overlap, just use the intersection points.\n      lineStart = intersectA\n      lineEnd = intersectB\n    }\n  }\n\n  return { lineStart, lineEnd }\n}\n","import { CapacityMeshNode, CapacityMeshNodeId } from \"lib/types\"\nimport { ConnectionPathWithNodes } from \"../CapacityPathingSolver/CapacityPathingSolver\"\n\nexport const calculateNodeProbabilityOfFailure = (\n  usedCapacity: number,\n  totalCapacity: number,\n  layerCount: number,\n) => {\n  if (usedCapacity < totalCapacity) return 0\n  if (totalCapacity < 1 && usedCapacity <= 1) return 0\n\n  const ratioOverTotal = usedCapacity / totalCapacity\n\n  // If you only have one layer, you really can't have multiple paths, 50% of\n  // the time you'll have an unsolvable intersection\n  if (layerCount === 1 && usedCapacity > 1) {\n    return 1 - 0.01 ** usedCapacity\n  }\n\n  // Tunable parameter to shape the curve\n  const k = 2 // increase for steeper approach to 1\n  const adjustedRatio = ratioOverTotal - 1\n\n  // This function approaches 1 as adjustedRatio increases\n  return 1 - Math.exp(-k * adjustedRatio)\n}\n\n/**\n * Calculates the log(probability of success) for a single node.\n * Higher is better. Returns 0 if the node is a target or not over capacity.\n */\nexport const calculateSingleNodeLogSuccessProbability = (\n  usedCapacity: number,\n  totalCapacity: number,\n  node: CapacityMeshNode, // Used for availableZ.length and _containsTarget\n): number => {\n  // If the node is a target, it doesn't contribute negatively to the score based on capacity.\n  // Its \"success\" is tied to being reached, not its capacity pressure for other paths.\n  // We return 0, as log(1) = 0, implying full probability of success from a capacity standpoint.\n  if (node._containsTarget) return 0\n\n  // If used capacity is not greater than total capacity, probability of success is 1.\n  // log(1) = 0, so it doesn't negatively impact the sum.\n  if (usedCapacity <= totalCapacity) return 0\n\n  const probabilityOfFailure = calculateNodeProbabilityOfFailure(\n    usedCapacity,\n    totalCapacity,\n    node.availableZ.length,\n  )\n  const probabilityOfSuccess = 1 - probabilityOfFailure\n\n  // Avoid log(0) or log(<0) if probabilityOfFailure results in non-positive success probability\n  if (probabilityOfSuccess <= 0) {\n    return -1e9 // Represents an extremely low (effectively zero) probability of success\n  } else {\n    return Math.log(probabilityOfSuccess)\n  }\n}\n\n/**\n * Returns log(probability of success) for the section. Higher is better.\n */\nexport const computeSectionScore = ({\n  totalNodeCapacityMap,\n  usedNodeCapacityMap,\n  nodeMap,\n  sectionNodeIds, // Destructure sectionNodeIds here\n}: {\n  totalNodeCapacityMap: Map<CapacityMeshNodeId, number>\n  usedNodeCapacityMap: Map<CapacityMeshNodeId, number>\n  nodeMap: Map<CapacityMeshNodeId, CapacityMeshNode>\n  sectionNodeIds?: Set<CapacityMeshNodeId> // Optional: Only consider nodes in this set\n}) => {\n  let logProbabilityOfSuccessSum = 0\n  const nodesToConsider = sectionNodeIds ?? new Set(usedNodeCapacityMap.keys()) // Use provided set or all nodes in used map\n\n  for (const nodeId of nodesToConsider) {\n    // Skip if node doesn't have capacity info (shouldn't happen if maps are consistent)\n    if (!totalNodeCapacityMap.has(nodeId)) continue\n    const node = nodeMap.get(nodeId)\n    if (!node) continue\n\n    const totalCapacity = totalNodeCapacityMap.get(nodeId)!\n    const usedCapacity = usedNodeCapacityMap.get(nodeId) ?? 0\n\n    logProbabilityOfSuccessSum += calculateSingleNodeLogSuccessProbability(\n      usedCapacity,\n      totalCapacity,\n      node,\n    )\n  }\n\n  return logProbabilityOfSuccessSum\n}\n","import { GraphicsObject } from \"graphics-debug\"\nimport {\n  CapacityMeshEdge,\n  CapacityMeshNode,\n  CapacityMeshNodeId,\n} from \"lib/types\"\nimport { safeTransparentize } from \"../colors\" // Added import\nimport { createRectFromCapacityNode } from \"lib/utils/createRectFromCapacityNode\"\nimport { getLinesBetweenNodes } from \"lib/utils/getLinesBetweenNodes\"\nimport { calculateNodeProbabilityOfFailure } from \"./computeSectionScore\"\n\ninterface VisualizeSectionParams {\n  sectionNodes: CapacityMeshNode[]\n  sectionEdges: CapacityMeshEdge[] // Edges *only* within the section\n  sectionConnectionTerminals: Array<{\n    connectionName: string\n    startNodeId: CapacityMeshNodeId\n    endNodeId: CapacityMeshNodeId\n    path?: CapacityMeshNode[] // Optional path for terminals\n  }>\n  completedPaths?: Array<{\n    // Optional array for explicitly drawing completed paths\n    connectionName: string\n    path: CapacityMeshNode[]\n  }>\n  nodeMap: Map<CapacityMeshNodeId, CapacityMeshNode> // Map for all relevant nodes (section + potentially neighbors if needed for edges)\n  colorMap: Record<string, string>\n  centerNodeId?: CapacityMeshNodeId | null // Optional: for highlighting the center\n  title: string // Custom title for the visualization\n  nodeOpacity?: number\n  usedNodeCapacityMap?: Map<CapacityMeshNodeId, number> // Optional capacity map\n  totalCapacityMap?: Map<CapacityMeshNodeId, number> // Optional capacity map\n}\n\nexport function visualizeSection({\n  sectionNodes,\n  sectionEdges,\n  sectionConnectionTerminals,\n  completedPaths, // Added completedPaths\n  nodeMap,\n  colorMap,\n  centerNodeId,\n  title,\n  nodeOpacity = 0.1,\n  usedNodeCapacityMap, // Destructure added params\n  totalCapacityMap, // Destructure added params\n}: VisualizeSectionParams): GraphicsObject {\n  const graphics: GraphicsObject = {\n    points: [],\n    lines: [],\n    rects: [],\n    circles: [],\n    title: title,\n  }\n\n  const sectionNodeIds = new Set(sectionNodes.map((n) => n.capacityMeshNodeId))\n\n  // Highlight all nodes in the section\n  for (const node of sectionNodes) {\n    let nodeFill = `rgba(128, 128, 128, ${nodeOpacity})` // Default gray\n    let nodeStroke = `rgba(128, 128, 128, ${nodeOpacity})` // Default gray stroke\n\n    const availableZ = node.availableZ ?? []\n    const hasZ0 = availableZ.includes(0)\n    const hasZ1 = availableZ.includes(1)\n\n    if (hasZ0 && hasZ1) {\n      nodeFill = `rgba(128, 0, 128, ${nodeOpacity})` // Purple fill\n      nodeStroke = `rgba(128, 0, 128, ${nodeOpacity})` // Purple stroke\n    } else if (hasZ0) {\n      nodeFill = `rgba(0, 0, 255, ${nodeOpacity})` // Blue fill\n      nodeStroke = `rgba(0, 0, 255, ${nodeOpacity})` // Blue stroke\n    } else if (hasZ1) {\n      nodeFill = `rgba(255, 0, 0, ${nodeOpacity})` // Red fill\n      nodeStroke = `rgba(255, 0, 0, ${nodeOpacity})` // Red stroke\n    }\n\n    // Override for center node if provided\n    if (centerNodeId && node.capacityMeshNodeId === centerNodeId) {\n      nodeFill = `rgba(0, 255, 0, ${nodeOpacity})` // Center node green fill\n      nodeStroke = `rgba(0, 128, 0, ${nodeOpacity})` // Center node green stroke (using standard green RGB)\n    }\n\n    graphics.rects!.push({\n      ...createRectFromCapacityNode(node),\n      fill: nodeFill,\n      stroke: nodeStroke,\n      label: `${node.capacityMeshNodeId}\\n(Section Node)\\nZ: ${availableZ.join(\",\")}`,\n    })\n\n    // Add capacity info to label if maps are provided\n    const rectIndex = graphics.rects!.length - 1\n    if (usedNodeCapacityMap && totalCapacityMap) {\n      const used = usedNodeCapacityMap.get(node.capacityMeshNodeId) ?? 0\n      const total = totalCapacityMap.get(node.capacityMeshNodeId) ?? 0\n      const percent = total > 0 ? ((used / total) * 100).toFixed(1) : \"N/A\"\n      const probabilityOfFailure = calculateNodeProbabilityOfFailure(\n        used,\n        total,\n        node.availableZ.length,\n      )\n      graphics.rects![rectIndex].label += `\\n${used.toFixed(\n        1,\n      )} / ${total.toFixed(1)}\\n${percent}% (Pf: ${(\n        probabilityOfFailure * 100\n      ).toFixed(1)}%)`\n\n      // Add stroke if probability of failure is > 0\n      if (probabilityOfFailure > 0.2) {\n        graphics.rects![rectIndex].stroke = safeTransparentize(\n          \"red\",\n          (0.8 + nodeOpacity) * 0.7,\n        )\n      }\n    }\n  }\n\n  // Draw edges within the section\n  for (const edge of sectionEdges) {\n    const [nodeIdA, nodeIdB] = edge.nodeIds\n    // Both nodes must be in the provided nodeMap to draw the edge\n    const nodeA = nodeMap.get(nodeIdA)\n    const nodeB = nodeMap.get(nodeIdB)\n    if (nodeA && nodeB) {\n      const { lineStart, lineEnd } = getLinesBetweenNodes(nodeA, nodeB)\n      graphics.lines!.push({\n        points: [lineStart, lineEnd],\n        strokeColor: `rgba(0, 0, 0, ${0.2 * Math.min(1, nodeOpacity / 0.1)})`, // Light gray for intra-section edges\n      })\n    }\n  }\n\n  // Highlight connection terminals within the section\n  sectionConnectionTerminals.forEach((terminal, index) => {\n    const startNode = nodeMap.get(terminal.startNodeId)\n    const endNode = nodeMap.get(terminal.endNodeId)\n    const connectionColor = colorMap[terminal.connectionName] ?? \"black\" // Default to black if not found\n\n    // Ensure terminals are actually within the visualized section nodes\n    const isStartInSection =\n      startNode && sectionNodeIds.has(startNode.capacityMeshNodeId)\n    const isEndInSection =\n      endNode && sectionNodeIds.has(endNode.capacityMeshNodeId)\n\n    const offsetMultiplier = (index + index / 50) % 5 // Simple offset logic\n    let startOffsetX = 0\n    let startOffsetY = 0\n    let endOffsetX = 0\n    let endOffsetY = 0\n\n    if (isStartInSection && startNode) {\n      const baseOffset = 0.02 * Math.min(startNode.width, startNode.height)\n      startOffsetX = baseOffset * offsetMultiplier\n      startOffsetY = baseOffset * offsetMultiplier\n      graphics.points!.push({\n        x: startNode.center.x + startOffsetX,\n        y: startNode.center.y + startOffsetY,\n        color: connectionColor,\n        label: `Start: ${terminal.connectionName}\\n(${terminal.startNodeId})`,\n      })\n      graphics.lines!.push({\n        points: [\n          { x: startNode.center.x, y: startNode.center.y },\n          {\n            x: startNode.center.x + startOffsetX,\n            y: startNode.center.y + startOffsetY,\n          },\n        ],\n        strokeColor: \"gray\",\n        strokeDash: \"2 2\",\n      })\n    }\n\n    if (isEndInSection && endNode) {\n      const baseOffset = 0.02 * Math.min(endNode.width, endNode.height)\n      endOffsetX = baseOffset * offsetMultiplier\n      endOffsetY = baseOffset * offsetMultiplier\n      graphics.points!.push({\n        x: endNode.center.x + endOffsetX,\n        y: endNode.center.y + endOffsetY,\n        color: connectionColor,\n        label: `End: ${terminal.connectionName}\\n(${terminal.endNodeId})`,\n      })\n      graphics.lines!.push({\n        points: [\n          { x: endNode.center.x, y: endNode.center.y },\n          {\n            x: endNode.center.x + endOffsetX,\n            y: endNode.center.y + endOffsetY,\n          },\n        ],\n        strokeColor: \"gray\",\n        strokeDash: \"2 2\",\n      })\n    }\n\n    // Draw a line between terminals only if both are within the section\n    if (isStartInSection && isEndInSection && startNode && endNode) {\n      graphics.lines!.push({\n        points: [\n          {\n            x: startNode.center.x + startOffsetX,\n            y: startNode.center.y + startOffsetY,\n          },\n          {\n            x: endNode.center.x + endOffsetX,\n            y: endNode.center.y + endOffsetY,\n          },\n        ],\n        strokeColor: connectionColor,\n        strokeDash: \"5 5\",\n      })\n    }\n  })\n\n  // Draw completed paths if provided\n  if (completedPaths) {\n    completedPaths.forEach((solvedPathData, index) => {\n      if (solvedPathData.path && solvedPathData.path.length > 0) {\n        const pathColor = colorMap[solvedPathData.connectionName] ?? \"gray\"\n        const offset = {\n          x: ((index + index / 50) % 5) * 0.03,\n          y: ((index + index / 50) % 5) * 0.03,\n        }\n        graphics.lines!.push({\n          points: solvedPathData.path.map(({ center: { x, y } }) => ({\n            x: x + offset.x,\n            y: y + offset.y,\n          })),\n          strokeColor: safeTransparentize(pathColor, 0.2), // Make solved paths semi-transparent\n          // strokeWidth: 0.03,\n        })\n      }\n    })\n  }\n\n  return graphics\n}\n","import {\n  CapacityMeshEdge,\n  CapacityMeshNode,\n  CapacityMeshNodeId,\n} from \"lib/types\"\nimport { ConnectionPathWithNodes } from \"../CapacityPathingSolver/CapacityPathingSolver\"\n\nexport interface SectionConnectionTerminal {\n  connectionName: string\n  startNodeId: CapacityMeshNodeId\n  endNodeId: CapacityMeshNodeId\n  path?: CapacityMeshNode[] // To store the result for this connection\n}\nexport interface CapacityPathingSection {\n  centerNodeId: string\n  sectionConnectionTerminals: SectionConnectionTerminal[]\n  sectionNodes: CapacityMeshNode[]\n  sectionEdges: CapacityMeshEdge[]\n}\n\nexport const computeSectionNodesTerminalsAndEdges = (opts: {\n  centerNodeId: string\n  connectionsWithNodes: Array<ConnectionPathWithNodes>\n  nodeEdgeMap: Map<CapacityMeshNodeId, CapacityMeshEdge[]>\n  edges: CapacityMeshEdge[]\n  nodeMap: Map<CapacityMeshNodeId, CapacityMeshNode>\n  expansionDegrees: number\n}): CapacityPathingSection => {\n  const {\n    centerNodeId,\n    connectionsWithNodes,\n    nodeMap,\n    edges,\n    nodeEdgeMap,\n    expansionDegrees,\n  } = opts\n\n  const sectionNodeIds = new Set<CapacityMeshNodeId>()\n  const queue: Array<{ nodeId: CapacityMeshNodeId; depth: number }> = [\n    { nodeId: centerNodeId, depth: 0 },\n  ]\n  sectionNodeIds.add(centerNodeId)\n\n  let head = 0\n  while (head < queue.length) {\n    const { nodeId, depth } = queue[head++]\n\n    if (depth >= expansionDegrees) continue\n\n    const neighbors =\n      nodeEdgeMap\n        .get(nodeId)\n        ?.flatMap((edge) => edge.nodeIds.filter((id) => id !== nodeId)) ?? []\n\n    for (const neighborId of neighbors) {\n      if (!sectionNodeIds.has(neighborId)) {\n        sectionNodeIds.add(neighborId)\n        queue.push({ nodeId: neighborId, depth: depth + 1 })\n      }\n    }\n  }\n\n  const sectionNodes = Array.from(sectionNodeIds).map((id) => nodeMap.get(id)!)\n\n  // Compute section edges (edges where both nodes are in the section)\n  const sectionEdges = edges.filter((edge) => {\n    const [nodeIdA, nodeIdB] = edge.nodeIds\n    return sectionNodeIds.has(nodeIdA) && sectionNodeIds.has(nodeIdB)\n  })\n\n  // Compute terminals\n  const sectionConnectionTerminals = []\n  for (const conn of connectionsWithNodes) {\n    if (!conn.path) continue\n\n    let startNodeId: CapacityMeshNodeId | null = null\n    let endNodeId: CapacityMeshNodeId | null = null\n\n    // Find the first node in the path that is within the section\n    for (const node of conn.path) {\n      if (sectionNodeIds.has(node.capacityMeshNodeId)) {\n        startNodeId = node.capacityMeshNodeId\n        break\n      }\n    }\n\n    // Find the last node in the path that is within the section\n    for (let i = conn.path.length - 1; i >= 0; i--) {\n      const node = conn.path[i]\n      if (sectionNodeIds.has(node.capacityMeshNodeId)) {\n        endNodeId = node.capacityMeshNodeId\n        break\n      }\n    }\n\n    if (startNodeId && endNodeId) {\n      sectionConnectionTerminals.push({\n        connectionName: conn.connection.name,\n        startNodeId,\n        endNodeId,\n      })\n    }\n  }\n  return {\n    sectionConnectionTerminals,\n    sectionNodes,\n    sectionEdges,\n    centerNodeId,\n  }\n}\n","import { GraphicsObject } from \"graphics-debug\"\nimport {\n  CapacityMeshEdge,\n  CapacityMeshNode,\n  CapacityMeshNodeId,\n} from \"lib/types\"\nimport { BaseSolver } from \"../BaseSolver\"\nimport { visualizeSection } from \"./visualizeSection\"\nimport { getNodeEdgeMap } from \"../CapacityMeshSolver/getNodeEdgeMap\" // Added import\nimport { getTunedTotalCapacity1 } from \"lib/utils/getTunedTotalCapacity1\" // Added import\nimport { distance } from \"@tscircuit/math-utils\" // Added import\nimport {\n  computeSectionScore,\n  calculateSingleNodeLogSuccessProbability,\n} from \"./computeSectionScore\" // Added import & calculateSingleNodeLogSuccessProbability\nimport { safeTransparentize } from \"../colors\" // Added import\nimport { createRectFromCapacityNode } from \"lib/utils/createRectFromCapacityNode\" // Added import\nimport { cloneAndShuffleArray } from \"lib/utils/cloneAndShuffleArray\"\n\n// Copied from CapacityPathingSolver\nexport type Candidate = {\n  prevCandidate: Candidate | null\n  node: CapacityMeshNode\n  f: number\n  g: number\n  h: number\n}\n\nexport interface CpssPathingSolverHyperParameters {\n  SHUFFLE_SEED?: number\n  EXPANSION_DEGREES?: number\n}\n\nexport interface CapacityPathingSingleSectionPathingSolverParams {\n  sectionNodes: CapacityMeshNode[]\n  sectionEdges: CapacityMeshEdge[]\n  sectionConnectionTerminals: Array<{\n    // Corrected this part\n    connectionName: string\n    startNodeId: CapacityMeshNodeId\n    endNodeId: CapacityMeshNodeId\n    // Store the original full path for context if needed later\n    // originalPath?: CapacityMeshNode[];\n  }>\n  colorMap?: Record<string, string> // Make colorMap optional in params\n  centerNodeId: string\n  nodeMap?: Map<CapacityMeshNodeId, CapacityMeshNode>\n  nodeEdgeMap?: Map<CapacityMeshNodeId, CapacityMeshEdge[]>\n  hyperParameters?: CpssPathingSolverHyperParameters\n}\n\nexport class CapacityPathingSingleSectionSolver extends BaseSolver {\n  GREEDY_MULTIPLIER = 1.5\n  sectionNodes: CapacityMeshNode[]\n  sectionEdges: CapacityMeshEdge[]\n  sectionConnectionTerminals: Array<{\n    connectionName: string\n    startNodeId: CapacityMeshNodeId\n    endNodeId: CapacityMeshNodeId\n    path?: CapacityMeshNode[] // To store the result for this connection\n  }>\n  nodeMap: Map<CapacityMeshNodeId, CapacityMeshNode> // Map of nodes *within the section*\n  nodeEdgeMap: Map<CapacityMeshNodeId, CapacityMeshEdge[]> // Edges *within the section*\n  colorMap: Record<string, string>\n  usedNodeCapacityMap: Map<CapacityMeshNodeId, number> // Tracks capacity usage *within this solver's run*\n  totalNodeCapacityMap: Map<CapacityMeshNodeId, number> // Added: Stores total capacity for each node\n  centerNodeId: string\n  private currentSectionScore: number = 0\n\n  MAX_CANDIDATES_IN_MEMORY = 10_000\n\n  // A* state\n  currentConnectionIndex = 0\n  candidates?: Array<Candidate> | null = null\n  visitedNodes?: Set<CapacityMeshNodeId> | null = null\n  queuedNodes?: Set<CapacityMeshNodeId> | null = null\n  activeCandidateStraightLineDistance?: number\n  debug_lastNodeCostMap: Map<\n    CapacityMeshNodeId,\n    {\n      g: number\n      h: number\n      f: number\n    }\n  > = new Map()\n\n  // TODO: Decide if maxCapacityFactor needs to be configurable via hyperParameters\n  maxCapacityFactor = 1 // Default, similar to CapacityPathingSolver5\n\n  constructor(params: CapacityPathingSingleSectionPathingSolverParams) {\n    super()\n\n    this.MAX_ITERATIONS = 10e3\n    this.centerNodeId = params.centerNodeId\n    this.sectionNodes = params.sectionNodes\n    this.sectionEdges = params.sectionEdges\n    // Initialize path property for each terminal\n    this.sectionConnectionTerminals = params.sectionConnectionTerminals.map(\n      (t) => ({ ...t, path: undefined }),\n    )\n    this.nodeMap =\n      params.nodeMap ??\n      new Map(this.sectionNodes.map((n) => [n.capacityMeshNodeId, n]))\n    this.nodeEdgeMap = params.nodeEdgeMap ?? getNodeEdgeMap(this.sectionEdges) // Use only section edges\n    this.colorMap = params.colorMap ?? {}\n\n    // Initialize capacity map, potentially with starting values\n    this.usedNodeCapacityMap = new Map(\n      this.sectionNodes.map((node) => [node.capacityMeshNodeId, 0]),\n    )\n    this.totalNodeCapacityMap = new Map(\n      this.sectionNodes.map((node) => [\n        node.capacityMeshNodeId,\n        this.getTotalCapacity(node),\n      ]),\n    )\n\n    // Initialize currentSectionScore based on the initial state of capacities\n    const initialSectionNodeIds = new Set(\n      this.sectionNodes.map((n) => n.capacityMeshNodeId),\n    )\n    this.currentSectionScore = computeSectionScore({\n      totalNodeCapacityMap: this.totalNodeCapacityMap,\n      usedNodeCapacityMap: this.usedNodeCapacityMap, // Reflects initial capacities\n      nodeMap: this.nodeMap,\n      sectionNodeIds: initialSectionNodeIds,\n    })\n\n    if (params.hyperParameters?.SHUFFLE_SEED) {\n      this.sectionConnectionTerminals = cloneAndShuffleArray(\n        this.sectionConnectionTerminals,\n        params.hyperParameters?.SHUFFLE_SEED,\n      )\n    }\n    // Sort connections? (Maybe not necessary if order is determined by caller)\n    // this.sectionConnectionTerminals.sort((a, b) => ...);\n  }\n\n  // --- Methods adapted from CapacityPathingSolver & CapacityPathingSolver5 ---\n\n  // Adapted from CapacityPathingSolver5\n  getTotalCapacity(node: CapacityMeshNode): number {\n    return getTunedTotalCapacity1(node, this.maxCapacityFactor)\n  }\n\n  // Adapted from CapacityPathingSolver5\n  getNodeCapacityPenalty(node: CapacityMeshNode): number {\n    if (!this.nodeMap.has(node.capacityMeshNodeId)) return Infinity // Penalize leaving section heavily\n\n    /**\n     * Roughly, -1 remaining capacity is penalized to this much distance\n     */\n    const mmPenaltyFactor = 4\n\n    const MIN_PENALTY = 0.05\n\n    const totalCapacity = this.getTotalCapacity(node)\n    const usedCapacity =\n      this.usedNodeCapacityMap.get(node.capacityMeshNodeId) ?? 0\n    const remainingCapacity = totalCapacity - usedCapacity - 1\n\n    if (remainingCapacity > 0) {\n      return 0\n    }\n\n    // const probabilityOfFailure = calculateNodeProbabilityOfFailure(\n    //   usedCapacity,\n    //   totalCapacity,\n    //   node.availableZ.length,\n    // )\n\n    let singleLayerUsagePenaltyFactor = 1\n    if (node.availableZ.length === 1) {\n      singleLayerUsagePenaltyFactor = 10\n    }\n\n    return (\n      (MIN_PENALTY + remainingCapacity ** 2 * mmPenaltyFactor) *\n      singleLayerUsagePenaltyFactor\n    )\n  }\n\n  // Adapted from CapacityPathingSolver5 (using simple distance)\n  getDistanceBetweenNodes(A: CapacityMeshNode, B: CapacityMeshNode): number {\n    const dx = A.center.x - B.center.x\n    const dy = A.center.y - B.center.y\n    return Math.sqrt(dx ** 2 + dy ** 2)\n  }\n\n  // Adapted from CapacityPathingSolver5\n  computeG(\n    prevCandidate: Candidate,\n    node: CapacityMeshNode,\n    endGoal: CapacityMeshNode, // endGoal is not strictly needed here but kept for signature consistency\n  ): number {\n    return (\n      prevCandidate.g +\n      this.getDistanceBetweenNodes(prevCandidate.node, node) +\n      this.getNodeCapacityPenalty(node) // Apply penalty on arrival at the node\n    )\n  }\n\n  // Adapted from CapacityPathingSolver5\n  computeH(\n    prevCandidate: Candidate, // prevCandidate not strictly needed here\n    node: CapacityMeshNode,\n    endGoal: CapacityMeshNode,\n  ): number {\n    // Heuristic is distance to goal + estimated penalty at the current node\n    return (\n      this.getDistanceBetweenNodes(node, endGoal) +\n      this.getNodeCapacityPenalty(node) // Consider penalty of the current node for heuristic\n    )\n  }\n\n  // Adapted from CapacityPathingSolver\n  getBacktrackedPath(candidate: Candidate): CapacityMeshNode[] {\n    const path: CapacityMeshNode[] = []\n    let currentCandidate: Candidate | null = candidate\n    while (currentCandidate) {\n      path.push(currentCandidate.node)\n      // Ensure the node exists in our section map before adding\n      if (this.nodeMap.has(currentCandidate.node.capacityMeshNodeId)) {\n        currentCandidate = currentCandidate.prevCandidate\n      } else {\n        // Should not happen if search stays within bounds, but safety break\n        console.warn(\"Backtracked path went outside section bounds\")\n        break\n      }\n    }\n    return path.reverse() // Path is built end-to-start, reverse it\n  }\n\n  // Adapted from CapacityPathingSolver - uses section's nodeEdgeMap\n  getNeighboringNodes(node: CapacityMeshNode): CapacityMeshNode[] {\n    if (!this.nodeMap.has(node.capacityMeshNodeId)) return [] // Node not in section\n\n    return (\n      this.nodeEdgeMap\n        .get(node.capacityMeshNodeId)\n        ?.flatMap((edge): CapacityMeshNodeId[] =>\n          edge.nodeIds.filter((n) => n !== node.capacityMeshNodeId),\n        )\n        .map((nId) => this.nodeMap.get(nId)!)\n        .filter(Boolean) ?? [] // Ensure nodes exist in the section map and filter out undefined\n    )\n  }\n\n  // Adapted from CapacityPathingSolver - uses section's nodeEdgeMap\n  isConnectedToEndGoal(\n    node: CapacityMeshNode,\n    endGoal: CapacityMeshNode,\n  ): boolean {\n    if (\n      !this.nodeMap.has(node.capacityMeshNodeId) ||\n      !this.nodeMap.has(endGoal.capacityMeshNodeId)\n    )\n      return false\n\n    return (this.nodeEdgeMap.get(node.capacityMeshNodeId) ?? []).some((edge) =>\n      edge.nodeIds.includes(endGoal.capacityMeshNodeId),\n    )\n  }\n\n  // Adapted from CapacityPathingSolver - uses section's capacity map and total capacity calculation\n  doesNodeHaveCapacityForTrace(\n    node: CapacityMeshNode,\n    prevNode: CapacityMeshNode | null, // Can be null for the start node\n  ): boolean {\n    return true\n  }\n\n  // Adapted from CapacityPathingSolver - uses section's capacity map\n  reduceCapacityAlongPath(path: CapacityMeshNode[]) {\n    for (const pathNode of path) {\n      // Only reduce capacity and update score for nodes within our section\n      if (this.usedNodeCapacityMap.has(pathNode.capacityMeshNodeId)) {\n        const nodeId = pathNode.capacityMeshNodeId\n        const nodeInSection = this.nodeMap.get(nodeId)\n\n        if (!nodeInSection) {\n          // This should ideally not happen if paths are constrained to section nodes\n          console.warn(\n            `Node ${nodeId} from path not found in section's nodeMap during score update.`,\n          )\n          continue\n        }\n\n        const totalCapacity = this.totalNodeCapacityMap.get(nodeId)!\n        const oldUsedCapacity = this.usedNodeCapacityMap.get(nodeId) ?? 0\n\n        // Subtract the score contribution of the node with its old capacity\n        const oldNodeScoreContribution =\n          calculateSingleNodeLogSuccessProbability(\n            oldUsedCapacity,\n            totalCapacity,\n            nodeInSection, // Use the node object from the section's map\n          )\n        this.currentSectionScore -= oldNodeScoreContribution\n\n        // Increment the used capacity for the node\n        const newUsedCapacity = oldUsedCapacity + 1\n        this.usedNodeCapacityMap.set(nodeId, newUsedCapacity)\n\n        // Add the score contribution of the node with its new capacity\n        const newNodeScoreContribution =\n          calculateSingleNodeLogSuccessProbability(\n            newUsedCapacity,\n            totalCapacity,\n            nodeInSection, // Use the node object from the section's map\n          )\n        this.currentSectionScore += newNodeScoreContribution\n      }\n    }\n  }\n\n  getSolvedSectionScore(): number {\n    return this.currentSectionScore\n  }\n\n  _step() {\n    const currentTerminal =\n      this.sectionConnectionTerminals[this.currentConnectionIndex]\n    if (!currentTerminal) {\n      this.solved = true // All connections processed\n      return\n    }\n\n    const startNode = this.nodeMap.get(currentTerminal.startNodeId)\n    const endNode = this.nodeMap.get(currentTerminal.endNodeId)\n\n    if (!startNode || !endNode) {\n      console.error(\n        `Start or end node not found in section for connection ${currentTerminal.connectionName}`,\n      )\n      // Mark this connection as failed? Or skip?\n      this.currentConnectionIndex++\n      this.candidates = null\n      this.visitedNodes = null\n      // Consider setting this.failed = true if any connection fails critically\n      return\n    }\n\n    // Initialize A* for the current connection if not already started\n    if (!this.candidates) {\n      this._setupAStar(startNode, endNode)\n    }\n\n    const candidates = this.candidates!\n\n    if (candidates.length === 0) {\n      this._handleCandidatesExhausted(currentTerminal)\n      return\n    }\n\n    candidates.sort((a, b) => a.f - b.f)\n    const currentCandidate = candidates.shift()! // Not null due to check above\n    if (candidates.length > this.MAX_CANDIDATES_IN_MEMORY) {\n      candidates.splice(\n        this.MAX_CANDIDATES_IN_MEMORY,\n        candidates.length - this.MAX_CANDIDATES_IN_MEMORY,\n      )\n    }\n\n    // Add the node selected for expansion to the visited/closed set\n    this.visitedNodes!.add(currentCandidate.node.capacityMeshNodeId)\n\n    // Check if goal reached\n    // Use direct ID check first, then isConnectedToEndGoal if needed (e.g., for adjacent nodes)\n    if (\n      currentCandidate.node.capacityMeshNodeId === endNode.capacityMeshNodeId\n    ) {\n      this._handleGoalReached(currentCandidate, currentTerminal, endNode)\n      return\n    }\n\n    // Explore neighbors\n    const neighborNodes = this.getNeighboringNodes(currentCandidate.node)\n    for (const neighborNode of neighborNodes) {\n      // Skip if already visited\n      if (this.queuedNodes?.has(neighborNode.capacityMeshNodeId)) {\n        continue\n      }\n\n      // Skip if node lacks capacity (using the adapted check)\n      // Note: doesNodeHaveCapacityForTrace currently always returns true in this solver,\n      // capacity is handled via penalties. Keep the check structure for potential future changes.\n      if (\n        !this.doesNodeHaveCapacityForTrace(neighborNode, currentCandidate.node)\n      ) {\n        continue\n      }\n\n      // Skip if it's an obstacle node and not a designated terminal for *this* connection\n      if (neighborNode._containsObstacle) {\n        const isStartTerminal =\n          neighborNode.capacityMeshNodeId === currentTerminal.startNodeId\n        const isEndTerminal =\n          neighborNode.capacityMeshNodeId === currentTerminal.endNodeId\n        if (!isStartTerminal && !isEndTerminal) {\n          continue // Skip this neighbor as it's an obstacle and not a terminal\n        }\n      }\n\n      // Calculate costs\n      const g = this.computeG(currentCandidate, neighborNode, endNode)\n      const h = this.computeH(currentCandidate, neighborNode, endNode)\n      const f = g + h * this.GREEDY_MULTIPLIER\n\n      this.debug_lastNodeCostMap.set(neighborNode.capacityMeshNodeId, {\n        f,\n        g,\n        h,\n      })\n\n      // Create and add the new candidate\n      const newCandidate: Candidate = {\n        prevCandidate: currentCandidate,\n        node: neighborNode,\n        f,\n        g,\n        h,\n      }\n      this.queuedNodes?.add(neighborNode.capacityMeshNodeId)\n      candidates!.push(newCandidate)\n      // Do NOT add to visitedNodes here. Add only when a node is popped from candidates.\n    }\n\n    // Mark current node as fully processed (closed list) - This happens when the node is popped from candidates and added to visitedNodes.\n    // No, visitedNodes is the open list + closed list. Let's stick to adding when pushing to candidates.\n    // this.visitedNodes!.add(currentCandidate.node.capacityMeshNodeId); // This seems redundant if added above\n  }\n\n  computeProgress(): number {\n    const totalConnections = this.sectionConnectionTerminals.length\n    if (totalConnections === 0) return 1 // No work to do\n\n    // Base progress based on completed connections\n    const completedConnections = this.currentConnectionIndex\n    let progress = completedConnections / totalConnections\n\n    // Refine progress based on the current connection's A* search\n    if (\n      this.currentConnectionIndex < totalConnections &&\n      this.candidates &&\n      this.candidates.length > 0 &&\n      this.activeCandidateStraightLineDistance &&\n      this.activeCandidateStraightLineDistance > 0\n    ) {\n      // Find the candidate with the lowest h value (closest to the goal heuristically)\n      // Note: Sorting by f is standard A*, but for progress, lowest h is more indicative.\n      // Let's use the best candidate (lowest f) as a proxy, assuming h contributes significantly.\n      const bestCandidate = this.candidates.reduce((best, current) =>\n        current.f < best.f ? current : best,\n      )\n\n      // Estimate progress within the current connection: 1 - (current_h / initial_h)\n      // Clamp between 0 and 1, as h might increase due to penalties\n      const currentConnectionProgress = Math.max(\n        0,\n        Math.min(\n          1,\n          1 - bestCandidate.h / this.activeCandidateStraightLineDistance,\n        ),\n      )\n\n      // Add the fractional progress of the current connection\n      progress += currentConnectionProgress / totalConnections\n    } else if (this.solved) {\n      progress = 1 // Ensure progress is 1 when solved\n    }\n\n    return Math.min(1, progress) // Clamp final progress to 1\n  }\n\n  private _setupAStar(startNode: CapacityMeshNode, endNode: CapacityMeshNode) {\n    this.candidates = [\n      { prevCandidate: null, node: startNode, f: 0, g: 0, h: 0 },\n    ]\n    this.visitedNodes = new Set([startNode.capacityMeshNodeId])\n    this.debug_lastNodeCostMap = new Map() // Reset costs for the new connection\n    this.activeCandidateStraightLineDistance = distance(\n      startNode.center,\n      endNode.center,\n    )\n\n    // Initial cost calculation for start node\n    const initialH = this.computeH(null!, startNode, endNode)\n    this.candidates[0].h = initialH\n    this.candidates[0].f = initialH * this.GREEDY_MULTIPLIER // g is 0\n    this.debug_lastNodeCostMap.set(startNode.capacityMeshNodeId, {\n      f: this.candidates[0].f,\n      g: 0,\n      h: initialH,\n    })\n    this.queuedNodes = new Set([startNode.capacityMeshNodeId])\n  }\n\n  private _handleCandidatesExhausted(currentTerminal: {\n    connectionName: string\n  }) {\n    console.error(\n      `Ran out of candidates for section connection ${currentTerminal.connectionName}`,\n    )\n    // Failed to find path for this connection\n    this.currentConnectionIndex++\n    this.candidates = null\n    this.visitedNodes = null\n    this.queuedNodes = null\n    // Optionally mark the solver as failed if any path fails\n    // this.failed = true;\n  }\n\n  private _handleGoalReached(\n    currentCandidate: Candidate,\n    currentTerminal: {\n      connectionName: string\n      startNodeId: CapacityMeshNodeId\n      endNodeId: CapacityMeshNodeId\n      path?: CapacityMeshNode[]\n    },\n    endNode: CapacityMeshNode, // Pass endNode if needed for checks like isConnectedToEndGoal\n  ) {\n    // Found the path for the current connection\n    const path = this.getBacktrackedPath(currentCandidate)\n    // If using isConnectedToEndGoal, might need to add endNode explicitly if not the current node\n    // if (path[path.length - 1]?.capacityMeshNodeId !== endNode.capacityMeshNodeId) {\n    //    path.push(endNode);\n    // }\n\n    currentTerminal.path = path // Store the found path\n    this.reduceCapacityAlongPath(path) // Update capacity usage\n\n    // Move to the next connection\n    this.currentConnectionIndex++\n    this.candidates = null\n    this.visitedNodes = null\n    this.queuedNodes = null\n  }\n\n  visualize(): GraphicsObject {\n    // Prepare data for completed paths visualization\n    const completedPathsForViz = this.sectionConnectionTerminals\n      .filter((t) => t.path && t.path.length > 0) // Only include terminals with a solved path\n      .map((t) => ({\n        connectionName: t.connectionName,\n        path: t.path!, // Assert path is defined due to filter\n      }))\n\n    // Base visualization from visualizeSection\n    const baseGraphics = visualizeSection({\n      sectionNodes: this.sectionNodes,\n      sectionEdges: this.sectionEdges,\n      sectionConnectionTerminals: this.sectionConnectionTerminals, // Still pass terminals for start/end points\n      completedPaths: completedPathsForViz, // Pass the solved paths\n      nodeMap: this.nodeMap, // Pass the section's node map\n      colorMap: this.colorMap,\n      centerNodeId: null, // No single center node for pathing visualization\n      title: `Section Pathing: Conn ${this.currentConnectionIndex + 1}/${\n        this.sectionConnectionTerminals.length\n      } (${this.sectionNodes.length} nodes)`,\n      nodeOpacity: 0.1,\n    })\n\n    // Enhance with A* specific visualization (Keep this part)\n\n    // 1. Highlight node costs (f, g, h) and capacity usage\n    for (const node of this.sectionNodes) {\n      const rectIndex = baseGraphics.rects!.findIndex((r) =>\n        r.label?.includes(node.capacityMeshNodeId),\n      )\n      if (rectIndex !== -1) {\n        const costs = this.debug_lastNodeCostMap.get(node.capacityMeshNodeId)\n        const usedCapacity =\n          this.usedNodeCapacityMap.get(node.capacityMeshNodeId) ?? 0\n        const totalCapacity = this.getTotalCapacity(node)\n        const capacityLabel = `${usedCapacity.toFixed(1)}/${totalCapacity.toFixed(\n          1,\n        )}`\n        const costLabel = costs\n          ? `f:${costs.f.toFixed(1)} g:${costs.g.toFixed(\n              1,\n            )} h:${costs.h.toFixed(1)}`\n          : \"cost:?\"\n\n        baseGraphics.rects![rectIndex].label = [\n          node.capacityMeshNodeId,\n          `Cap: ${capacityLabel}`,\n          costLabel,\n          `Z: ${node.availableZ.join(\",\")}`,\n        ].join(\"\\n\")\n\n        // Add stroke if over capacity\n        if (usedCapacity > totalCapacity) {\n          baseGraphics.rects![rectIndex].stroke = safeTransparentize(\"red\", 0.7)\n        }\n      }\n    }\n\n    // 2. Visualize candidate paths (top few)\n    if (this.candidates && this.candidates.length > 0) {\n      const topCandidates = this.candidates\n        .slice() // Create a copy\n        .sort((a, b) => a.f - b.f) // Ensure sorted by f-cost\n        .slice(0, 5) // Take top 5\n\n      const currentTerminal =\n        this.sectionConnectionTerminals[this.currentConnectionIndex]\n      const connectionName = currentTerminal?.connectionName ?? \"unknown\"\n      const connectionColor = this.colorMap[connectionName] ?? \"purple\" // Default color\n\n      topCandidates.forEach((candidate, index) => {\n        const opacity = 0.8 * (1 - index / 5) // Decreasing opacity\n        const path = this.getBacktrackedPath(candidate)\n        if (path.length > 0) {\n          baseGraphics.lines!.push({\n            points: path.map(({ center: { x, y } }) => ({ x, y })),\n            strokeColor: safeTransparentize(connectionColor, 1 - opacity),\n            strokeWidth: 0.05,\n          })\n        }\n      })\n    }\n\n    return baseGraphics\n  }\n}\n\n/* @deprecated use CapacityPathingSingleSectionPathingSolver */\nexport const CapacityPathingSingleSectionPathingSolver =\n  CapacityPathingSingleSectionSolver\nexport type CapacityPathingSingleSectionPathingSolver = InstanceType<\n  typeof CapacityPathingSingleSectionSolver\n>\n","import { BaseSolver } from \"../BaseSolver\"\nimport {\n  HyperParameterDef,\n  HyperParameterSupervisorSolver,\n  SupervisedSolver,\n} from \"../HyperParameterSupervisorSolver\"\nimport {\n  CapacityPathingSingleSectionPathingSolver,\n  CapacityPathingSingleSectionPathingSolverParams,\n} from \"./CapacityPathingSingleSectionSolver\"\n\nconst range = (n: number) => Array.from({ length: n }, (_, i) => i)\n\nexport class HyperCapacityPathingSingleSectionSolver extends HyperParameterSupervisorSolver<CapacityPathingSingleSectionPathingSolver> {\n  constructorParams: CapacityPathingSingleSectionPathingSolverParams\n\n  declare winningSolver?: CapacityPathingSingleSectionPathingSolver\n\n  constructor(\n    params: ConstructorParameters<\n      typeof CapacityPathingSingleSectionPathingSolver\n    >[0],\n  ) {\n    super()\n    this.MAX_ITERATIONS = 100e3\n    this.constructorParams = params\n  }\n\n  // TODO this needs to use the section score, ideally incorporating the current best candidate\n  // of the paths being explored inside the single section\n  computeG(solver: CapacityPathingSingleSectionPathingSolver): number {\n    // return solver.iterations / 100\n    return -solver.getSolvedSectionScore()\n  }\n\n  computeH(solver: CapacityPathingSingleSectionPathingSolver): number {\n    return 0\n    // return solver.computeProgress()\n  }\n\n  getCombinationDefs(): Array<Array<string>> | null {\n    // TODO change combination defs based on hyperParameters.EXPANSION_DEGREES\n    const numConnections =\n      this.constructorParams.sectionConnectionTerminals.length\n\n    if (numConnections === 2) {\n      return [[\"orderings2_for2\"]]\n    } else if (numConnections === 3) {\n      return [[\"orderings6_for3\"]]\n    } else if (numConnections === 4) {\n      return [[\"orderings24_for4\"]]\n    }\n    return [[\"orderings30\"]]\n  }\n\n  getFailureMessage() {\n    return `All CapacityPathingSingleSection solvers failed for \"${this.centerNodeId}\"`\n  }\n\n  getHyperParameterDefs(): Array<HyperParameterDef> {\n    return [\n      {\n        name: \"orderings2_for2\",\n        possibleValues: range(2).map((i) => ({\n          SHUFFLE_SEED: i,\n        })),\n      },\n      {\n        name: \"orderings6_for3\",\n        possibleValues: range(6).map((i) => ({\n          SHUFFLE_SEED: i,\n        })),\n      },\n      {\n        name: \"orderings24_for4\",\n        possibleValues: range(24).map((i) => ({\n          SHUFFLE_SEED: i,\n        })),\n      },\n      {\n        name: \"orderings30\",\n        possibleValues: range(30).map((i) => ({\n          SHUFFLE_SEED: i,\n        })),\n      },\n    ]\n  }\n\n  generateSolver(\n    hyperParameters: any,\n  ): CapacityPathingSingleSectionPathingSolver {\n    return new CapacityPathingSingleSectionPathingSolver({\n      ...this.constructorParams,\n      hyperParameters: {\n        ...this.constructorParams.hyperParameters,\n        ...hyperParameters,\n      },\n    })\n  }\n\n  onSolve({\n    solver,\n  }: SupervisedSolver<CapacityPathingSingleSectionPathingSolver>) {\n    this.winningSolver = solver\n  }\n\n  get centerNodeId() {\n    return this.constructorParams.centerNodeId\n  }\n\n  get sectionNodes() {\n    return this.constructorParams.sectionNodes\n  }\n\n  get sectionConnectionTerminals() {\n    return this.winningSolver?.sectionConnectionTerminals\n  }\n}\n","import { CachableSolver, CacheProvider } from \"lib/cache/types\"\nimport { HyperCapacityPathingSingleSectionSolver } from \"./HyperCapacityPathingSingleSectionSolver\"\nimport { CapacityMeshNode, CapacityMeshNodeId } from \"lib/types\"\nimport objectHash from \"object-hash\"\nimport { getGlobalInMemoryCache } from \"lib/cache/setupGlobalCaches\"\nimport { getTunedTotalCapacity1 } from \"lib/utils/getTunedTotalCapacity1\"\nimport { GraphicsObject } from \"graphics-debug\"\nimport { visualizeSection } from \"./visualizeSection\"\n\ntype CacheSpaceNodeId = string\ntype ConnectionIndex = number\n\n// A normalized connection id - note that the first id is always lower than the second\n// This prevents cache key collisions when multiple routes exist between the same node pair\ntype CacheSpaceConnectionId =\n  `${CacheSpaceNodeId}->${CacheSpaceNodeId}::${ConnectionIndex}`\n\ninterface CacheToHyperCapacityPathingTransform {\n  cacheSpaceToRealConnectionId: Map<CacheSpaceConnectionId, string>\n  cacheSpaceToRealNodeId: Map<CacheSpaceNodeId, string>\n}\n\ntype CachedSolvedHyperCapacityPathingSection =\n  | { success: false }\n  | {\n      success: true\n      sectionScore: number\n      solutionPaths: Record<CacheSpaceConnectionId, CacheSpaceNodeId[]>\n    }\n\nconst roundCapacity = (capacity: number) => Math.floor(capacity * 10) / 10\n\ntype CacheCapacity = string // \"10.0\", (number).toFixed(1)\n\ninterface CacheKeyContent {\n  node_capacity_map: Record<CacheSpaceNodeId, CacheCapacity>\n  node_edge_map: Array<[CacheSpaceNodeId, CacheSpaceNodeId]>\n  terminals: Record<\n    CacheSpaceConnectionId,\n    {\n      start: CacheSpaceNodeId\n      end: CacheSpaceNodeId\n    }\n  >\n}\n\nexport class CachedHyperCapacityPathingSingleSectionSolver\n  extends HyperCapacityPathingSingleSectionSolver\n  implements\n    CachableSolver<\n      CacheToHyperCapacityPathingTransform,\n      CachedSolvedHyperCapacityPathingSection\n    >\n{\n  cacheHit = false\n  cacheProvider: CacheProvider | null\n  declare cacheToSolveSpaceTransform?:\n    | CacheToHyperCapacityPathingTransform\n    | undefined\n  hasAttemptedToUseCache = false\n  sectionNodeIdSet: Set<string>\n\n  public cachedSectionConnectionTerminals:\n    | typeof this.sectionConnectionTerminals\n    | null = null\n  public sectionScore: number = 0\n\n  constructor(\n    params: ConstructorParameters<\n      typeof HyperCapacityPathingSingleSectionSolver\n    >[0] & {\n      cacheProvider?: CacheProvider | null\n    },\n  ) {\n    params.nodeMap =\n      params.nodeMap ??\n      new Map(params.sectionNodes.map((n) => [n.capacityMeshNodeId, n]))\n    super(params)\n    this.sectionNodeIdSet = new Set(\n      params.sectionNodes.map((sn) => sn.capacityMeshNodeId),\n    )\n    this.cacheProvider =\n      params.cacheProvider === undefined\n        ? getGlobalInMemoryCache() // Default to localStorage if undefined\n        : params.cacheProvider // Use null if explicitly passed as null\n  }\n\n  _step() {\n    if (!this.hasAttemptedToUseCache && this.cacheProvider) {\n      if (this.attemptToUseCacheSync()) return\n    }\n    super._step()\n    if ((this.solved || this.failed) && this.cacheProvider) {\n      this.saveToCacheSync()\n    }\n  }\n\n  _computeBfsOrderingOfNodesInSection(): CapacityMeshNodeId[] {\n    const seenNodeIds = new Set<string>(this.constructorParams.centerNodeId)\n    const ordering: CapacityMeshNodeId[] = []\n\n    const candidates: Array<{\n      ancestorCapacitySum: number\n      capacity: number\n      g: number // ancestorCapacitySum + capacity\n      capacityMeshNodeId: CapacityMeshNodeId\n    }> = [\n      {\n        ancestorCapacitySum: 0,\n        capacity: 0,\n        g: 0,\n        capacityMeshNodeId: this.constructorParams.centerNodeId,\n      },\n    ]\n    // Run a breadth first search using the rounded capacity as a penalty for the ordering\n    while (candidates.length > 0) {\n      candidates.sort((a, b) => b.g - a.g)\n      const candidate = candidates.pop()\n      if (!candidate) break\n      ordering.push(candidate.capacityMeshNodeId)\n\n      // Add all the candidate's neighbors (if they are in the section)\n      const neighborNodeIds = this.constructorParams\n        .nodeEdgeMap!.get(candidate.capacityMeshNodeId)!\n        .flatMap((edge) => edge.nodeIds)!\n        .filter((nodeId) => !seenNodeIds.has(nodeId))\n        .filter((nodeId) => this.sectionNodeIdSet.has(nodeId))\n\n      for (const neighborNodeId of neighborNodeIds) {\n        seenNodeIds.add(neighborNodeId)\n        const neighbor = this.constructorParams.nodeMap!.get(neighborNodeId)!\n        const capacity = getTunedTotalCapacity1(neighbor)\n        candidates.push({\n          ancestorCapacitySum: candidate.g,\n          capacity,\n          g: candidate.g + capacity,\n          capacityMeshNodeId: neighborNodeId,\n        })\n      }\n    }\n    return ordering\n  }\n\n  computeCacheKeyAndTransform(): {\n    cacheKey: string\n    cacheToSolveSpaceTransform: CacheToHyperCapacityPathingTransform\n  } {\n    const nodeOrdering = this._computeBfsOrderingOfNodesInSection()\n    const realToCacheSpaceNodeIdMap = new Map<\n      CapacityMeshNodeId,\n      CacheSpaceNodeId\n    >()\n    const cacheSpaceToRealNodeIdMap = new Map<\n      CacheSpaceNodeId,\n      CapacityMeshNodeId\n    >()\n\n    nodeOrdering.forEach((realNodeId, i) => {\n      const cacheNodeId = `node${i}` as CacheSpaceNodeId\n      realToCacheSpaceNodeIdMap.set(realNodeId, cacheNodeId)\n      cacheSpaceToRealNodeIdMap.set(cacheNodeId, realNodeId)\n    })\n\n    const node_capacity_map: Record<CacheSpaceNodeId, CacheCapacity> = {}\n    for (const realNodeId of nodeOrdering) {\n      const cacheNodeId = realToCacheSpaceNodeIdMap.get(realNodeId)!\n      const node = this.constructorParams.nodeMap!.get(realNodeId)!\n      const capacity = getTunedTotalCapacity1(node)\n      node_capacity_map[cacheNodeId] = roundCapacity(capacity).toFixed(\n        1,\n      ) as CacheCapacity\n    }\n\n    const node_edge_map_set = new Set<string>()\n    const node_edge_map: Array<[CacheSpaceNodeId, CacheSpaceNodeId]> = []\n    for (const realNodeId1 of nodeOrdering) {\n      const cacheNodeId1 = realToCacheSpaceNodeIdMap.get(realNodeId1)!\n      const neighbors =\n        this.constructorParams.nodeEdgeMap!.get(realNodeId1) ?? []\n      for (const edge of neighbors) {\n        const realNodeId2 = edge.nodeIds.find((id) => id !== realNodeId1)!\n        if (this.sectionNodeIdSet.has(realNodeId2)) {\n          const cacheNodeId2 = realToCacheSpaceNodeIdMap.get(realNodeId2)!\n          const pair = [cacheNodeId1, cacheNodeId2].sort() as [\n            CacheSpaceNodeId,\n            CacheSpaceNodeId,\n          ]\n          const pairKey = `${pair[0]}-${pair[1]}`\n          if (!node_edge_map_set.has(pairKey)) {\n            node_edge_map.push(pair)\n            node_edge_map_set.add(pairKey)\n          }\n        }\n      }\n    }\n    // Sort the edge map for consistent hashing\n    node_edge_map.sort((a, b) => {\n      if (a[0] !== b[0]) return a[0].localeCompare(b[0])\n      return a[1].localeCompare(b[1])\n    })\n\n    const terminals: CacheKeyContent[\"terminals\"] = {}\n    const cacheSpaceToRealConnectionId = new Map<\n      CacheSpaceConnectionId,\n      string\n    >()\n\n    // Create a map to track connection indices for unique IDs\n    const connectionPairMap = new Map<string, number>()\n\n    for (const conn of this.constructorParams.sectionConnectionTerminals) {\n      const cacheStartNodeId = realToCacheSpaceNodeIdMap.get(conn.startNodeId)!\n      const cacheEndNodeId = realToCacheSpaceNodeIdMap.get(conn.endNodeId)!\n\n      // Determine the canonical order for the connection ID key and value\n      const [sortedStartId, sortedEndId] = [\n        cacheStartNodeId,\n        cacheEndNodeId,\n      ].sort()\n\n      // Create a unique key for this node pair\n      const pairKey = `${sortedStartId}->${sortedEndId}`\n      const pairIndex = connectionPairMap.get(pairKey) ?? 0\n      connectionPairMap.set(pairKey, pairIndex + 1)\n\n      // Create unique cache connection ID with index\n      const cacheSpaceConnectionId: CacheSpaceConnectionId = `${sortedStartId}->${sortedEndId}::${pairIndex}`\n\n      // Store the terminals using the canonical sorted order for the value as well\n      terminals[cacheSpaceConnectionId] = {\n        start: sortedStartId,\n        end: sortedEndId,\n      }\n      cacheSpaceToRealConnectionId.set(\n        cacheSpaceConnectionId, // Use the canonically sorted key\n        conn.connectionName,\n      )\n    }\n\n    const cacheKeyContent: CacheKeyContent = {\n      node_capacity_map,\n      node_edge_map,\n      terminals,\n    }\n\n    const cacheKey = `capacitypathing:${objectHash(cacheKeyContent)}`\n\n    const cacheToSolveSpaceTransform: CacheToHyperCapacityPathingTransform = {\n      cacheSpaceToRealConnectionId,\n      cacheSpaceToRealNodeId: cacheSpaceToRealNodeIdMap,\n    }\n\n    this.cacheKey = cacheKey\n    this.cacheToSolveSpaceTransform = cacheToSolveSpaceTransform\n    return { cacheKey, cacheToSolveSpaceTransform }\n  }\n\n  applyCachedSolution(\n    cachedSolution: CachedSolvedHyperCapacityPathingSection,\n  ): void {\n    if (!this.cacheToSolveSpaceTransform) {\n      console.error(\n        \"Cache transform not available, cannot apply cached solution.\",\n      )\n      // Potentially re-compute or treat as cache miss\n      this.failed = true // Or handle differently\n      return\n    }\n    if (!cachedSolution.success) {\n      this.failed = true\n      this.cacheHit = true // It was a hit, but the solution was a failure\n      return\n    }\n\n    this.cachedSectionConnectionTerminals = []\n    const { cacheSpaceToRealNodeId, cacheSpaceToRealConnectionId } =\n      this.cacheToSolveSpaceTransform! // Assert non-null as checked above\n\n    for (const [cacheConnId, cachePathNodeIds] of Object.entries(\n      cachedSolution.solutionPaths,\n    )) {\n      const realConnectionName = cacheSpaceToRealConnectionId.get(\n        cacheConnId as CacheSpaceConnectionId,\n      )\n      if (!realConnectionName) {\n        console.warn(`Could not find real connection name for ${cacheConnId}`)\n        continue\n      }\n\n      const originalTerminal =\n        this.constructorParams.sectionConnectionTerminals.find(\n          (t) => t.connectionName === realConnectionName,\n        )\n\n      if (!originalTerminal) {\n        console.warn(\n          `Could not find original terminal for connection name ${realConnectionName}`,\n        )\n        continue\n      }\n\n      const realPathNodes: CapacityMeshNode[] = cachePathNodeIds.map(\n        (cacheNodeId) => {\n          const realNodeId = cacheSpaceToRealNodeId.get(cacheNodeId)\n          if (!realNodeId) {\n            throw new Error(\n              `Could not map cache node ID ${cacheNodeId} to real node ID for connection ${realConnectionName}`,\n            )\n          }\n          const node = this.constructorParams.nodeMap!.get(realNodeId)\n          if (!node) {\n            throw new Error(\n              `Could not find node with ID ${realNodeId} in nodeMap for connection ${realConnectionName}`,\n            )\n          }\n          return node\n        },\n      )\n\n      this.cachedSectionConnectionTerminals.push({\n        ...originalTerminal,\n        path: realPathNodes,\n      })\n    }\n\n    // Ensure all original terminals are present, even if no path was found in cache (e.g. if cache format changes or is partial)\n    // This might be overly cautious or lead to unexpected behavior if a cached solution is intentionally partial.\n    // For now, we assume a cached solution is complete for the terminals it covers.\n    // If a terminal from constructorParams is not in cachedSolution.solutionPaths, it won't be added to cachedSectionConnectionTerminals.\n    // This matches the behavior of not setting a path for it.\n\n    this.sectionScore = cachedSolution.sectionScore\n    this.solved = true\n    this.cacheHit = true\n  }\n\n  attemptToUseCacheSync(): boolean {\n    this.hasAttemptedToUseCache = true\n    if (!this.cacheProvider?.isSyncCache) {\n      console.log(\n        \"Cache provider is not synchronous, skipping sync cache check.\",\n      )\n      return false\n    }\n\n    if (!this.cacheKey) {\n      this.computeCacheKeyAndTransform()\n    }\n\n    if (!this.cacheKey) {\n      console.error(\"Failed to compute cache key.\")\n      return false\n    }\n\n    try {\n      const cachedSolution = this.cacheProvider.getCachedSolutionSync(\n        this.cacheKey,\n      )\n\n      if (cachedSolution) {\n        this.applyCachedSolution(\n          cachedSolution as CachedSolvedHyperCapacityPathingSection,\n        )\n        return true\n      }\n    } catch (error) {\n      console.error(\"Error attempting to use cache:\", error)\n    }\n\n    return false\n  }\n\n  saveToCacheSync(): void {\n    if (!this.cacheKey) {\n      console.error(\"Cannot save to cache without cache key.\")\n      return\n    }\n\n    if (!this.cacheToSolveSpaceTransform) {\n      console.error(\n        \"Cache transform not available, cannot save solution to cache.\",\n      )\n      return\n    }\n\n    let cachedSolution: CachedSolvedHyperCapacityPathingSection\n\n    if (this.failed) {\n      cachedSolution = { success: false }\n    } else if (this.solved) {\n      const solutionPathsInCacheSpace: Record<\n        CacheSpaceConnectionId,\n        CacheSpaceNodeId[]\n      > = {}\n      const { cacheSpaceToRealNodeId, cacheSpaceToRealConnectionId } =\n        this.cacheToSolveSpaceTransform\n\n      // Create reverse maps for easier lookup\n      const realToCacheSpaceNodeId = new Map<string, CacheSpaceNodeId>()\n      for (const [cacheId, realId] of cacheSpaceToRealNodeId) {\n        realToCacheSpaceNodeId.set(realId, cacheId)\n      }\n\n      const realToCacheSpaceConnectionId = new Map<\n        string,\n        CacheSpaceConnectionId\n      >()\n      for (const [cacheConnId, realConnName] of cacheSpaceToRealConnectionId) {\n        realToCacheSpaceConnectionId.set(realConnName, cacheConnId)\n      }\n\n      const realSolutionPaths: Array<[string, string[]]> = []\n\n      if (super.sectionConnectionTerminals) {\n        for (const terminal of super.sectionConnectionTerminals) {\n          if (terminal.path && terminal.path.length > 0) {\n            const realPathNodeIds = terminal.path.map(\n              (node) => node.capacityMeshNodeId,\n            )\n            realSolutionPaths.push([terminal.connectionName, realPathNodeIds])\n          }\n        }\n      }\n\n      for (const [realConnectionName, realPathNodeIds] of realSolutionPaths) {\n        const cacheConnectionId =\n          realToCacheSpaceConnectionId.get(realConnectionName)\n        if (!cacheConnectionId) {\n          console.warn(\n            `Could not find cache space connection ID for ${realConnectionName} when saving to cache.`,\n          )\n          continue\n        }\n\n        const cachePathNodeIds = realPathNodeIds.map((realNodeId) => {\n          const cacheNodeId = realToCacheSpaceNodeId.get(realNodeId)\n          if (!cacheNodeId) {\n            throw new Error(\n              `Could not map real node ID ${realNodeId} to cache node ID for connection ${realConnectionName} when saving to cache.`,\n            )\n          }\n          return cacheNodeId\n        })\n        solutionPathsInCacheSpace[cacheConnectionId] = cachePathNodeIds\n      }\n\n      cachedSolution = {\n        success: true,\n        sectionScore: this.sectionScore,\n        solutionPaths: solutionPathsInCacheSpace,\n      }\n    } else {\n      // Not solved and not failed, so nothing to save yet.\n      return\n    }\n\n    try {\n      this.cacheProvider?.setCachedSolutionSync(this.cacheKey, cachedSolution)\n    } catch (error) {\n      console.error(\"Error saving solution to cache:\", error)\n    }\n  }\n\n  override get sectionConnectionTerminals():\n    | Array<{\n        connectionName: string\n        startNodeId: CapacityMeshNodeId\n        endNodeId: CapacityMeshNodeId\n        path?: CapacityMeshNode[]\n      }>\n    | undefined {\n    if (this.cacheHit && this.solved && this.cachedSectionConnectionTerminals) {\n      console.log(\"returning the cached section connection terminals\")\n      return this.cachedSectionConnectionTerminals\n    }\n    return super.sectionConnectionTerminals\n  }\n\n  visualize(): GraphicsObject {\n    if (!this.cacheHit) return super.visualize()\n\n    const graphics = visualizeSection({\n      sectionNodes: this.constructorParams.sectionNodes,\n      sectionEdges: this.constructorParams.sectionEdges,\n      sectionConnectionTerminals: this.cachedSectionConnectionTerminals!,\n      completedPaths: this.cachedSectionConnectionTerminals!.map((t) => ({\n        connectionName: t.connectionName,\n        path: t.path!,\n      })),\n      nodeMap: this.constructorParams.nodeMap!,\n      colorMap: this.constructorParams.colorMap!,\n      title: \"CachedHyperCapacityPathingSingleSectionSolver\",\n    })\n\n    return graphics\n  }\n}\n","import {\n  CapacityMeshEdge,\n  CapacityMeshNode,\n  CapacityMeshNodeId,\n  CapacityPath,\n  SimpleRouteJson,\n} from \"lib/types\"\nimport { BaseSolver } from \"../BaseSolver\"\nimport {\n  CapacityPathingSolver,\n  ConnectionPathWithNodes,\n} from \"../CapacityPathingSolver/CapacityPathingSolver\"\nimport { CapacityPathingGreedySolver } from \"./CapacityPathingGreedySolver\"\nimport { HyperCapacityPathingSingleSectionSolver } from \"./HyperCapacityPathingSingleSectionSolver\"\nimport { getTunedTotalCapacity1 } from \"lib/utils/getTunedTotalCapacity1\"\nimport { visualizeSection } from \"./visualizeSection\"\nimport {\n  calculateNodeProbabilityOfFailure,\n  computeSectionScore,\n} from \"./computeSectionScore\" // Added import\nimport {\n  CapacityPathingSingleSectionPathingSolver,\n  CapacityPathingSingleSectionSolver,\n} from \"./CapacityPathingSingleSectionSolver\"\nimport {\n  CapacityPathingSection,\n  computeSectionNodesTerminalsAndEdges,\n  SectionConnectionTerminal,\n} from \"./computeSectionNodesTerminalsAndEdges\"\nimport { getNodeEdgeMap } from \"../CapacityMeshSolver/getNodeEdgeMap\"\nimport { CachedHyperCapacityPathingSingleSectionSolver } from \"./CachedHyperCapacityPathingSingleSectionSolver\"\nimport { CacheProvider } from \"lib/cache/types\"\n\ntype CapacityMeshEdgeId = string\n\n/**\n * This solver solves for capacity paths by first solving with negative\n * capacities allowed, then re-solving problematic sections with a section\n * solver.\n */\nexport class CapacityPathingMultiSectionSolver extends BaseSolver {\n  simpleRouteJson: SimpleRouteJson\n  nodes: CapacityMeshNode[]\n  edges: CapacityMeshEdge[]\n  nodeEdgeMap: Map<CapacityMeshEdgeId, CapacityMeshEdge[]>\n  connectionsWithNodes: Array<ConnectionPathWithNodes> = [] // Initialize here\n  colorMap: Record<string, string>\n\n  initialSolver: CapacityPathingGreedySolver\n  cacheProvider?: CacheProvider | null\n\n  stage: \"initialization\" | \"section-optimization\" = \"initialization\"\n\n  nodeMap: Map<CapacityMeshNodeId, CapacityMeshNode> = new Map()\n  allNodeIdsSet: Set<CapacityMeshNodeId>\n  usedNodeCapacityMap: Map<CapacityMeshNodeId, number> = new Map()\n  totalNodeCapacityMap: Map<CapacityMeshNodeId, number> = new Map() // Added\n\n  nodeCapacityPercentMap: Map<CapacityMeshNodeId, number> = new Map()\n  nodeOptimizationAttemptCountMap: Map<CapacityMeshNodeId, number> = new Map()\n\n  currentSection: CapacityPathingSection | null = null\n  sectionSolver?:\n    | CapacityPathingSingleSectionSolver\n    | HyperCapacityPathingSingleSectionSolver\n    | null = null\n\n  currentScheduleIndex = 0\n\n  stats: {\n    successfulOptimizations: number\n    failedOptimizations: number\n    failedSectionSolvers: number\n    startingScore: number\n    scheduleScores: Array<{\n      maxExpansionDegrees: number\n      sectionAttempts: number\n      endingScore: number\n      endingHighestNodePf: number\n    }>\n    cacheHits: number\n    cacheMisses: number\n  }\n\n  // Adjusting this schedule is a trade-off between optimization speed and quality.\n  OPTIMIZATION_SCHEDULE = [\n    {\n      MAX_ATTEMPTS_PER_NODE: 1,\n      MAX_EXPANSION_DEGREES: 3,\n      MINIMUM_PROBABILITY_OF_FAILURE_TO_OPTIMIZE: 0.05,\n    },\n    {\n      MAX_ATTEMPTS_PER_NODE: 2,\n      MAX_EXPANSION_DEGREES: 5,\n      MINIMUM_PROBABILITY_OF_FAILURE_TO_OPTIMIZE: 0.2,\n    },\n    {\n      MAX_ATTEMPTS_PER_NODE: 3,\n      MAX_EXPANSION_DEGREES: 7,\n      MINIMUM_PROBABILITY_OF_FAILURE_TO_OPTIMIZE: 0.9,\n    },\n  ]\n\n  get currentSchedule() {\n    return this.OPTIMIZATION_SCHEDULE[this.currentScheduleIndex] ?? null\n  }\n\n  constructor(\n    params: ConstructorParameters<typeof CapacityPathingSolver>[0] & {\n      initialPathingSolver?: CapacityPathingGreedySolver\n      cacheProvider?: CacheProvider | null\n    },\n  ) {\n    super()\n    this.stats = {\n      successfulOptimizations: 0,\n      failedOptimizations: 0,\n      failedSectionSolvers: 0,\n      startingScore: 0,\n      scheduleScores: this.OPTIMIZATION_SCHEDULE.map(\n        ({ MAX_EXPANSION_DEGREES }) => ({\n          maxExpansionDegrees: MAX_EXPANSION_DEGREES,\n          endingScore: 0,\n          endingHighestNodePf: 0,\n          sectionAttempts: 0,\n        }),\n      ),\n      cacheHits: 0,\n      cacheMisses: 0,\n    }\n\n    this.MAX_ITERATIONS = params.MAX_ITERATIONS ?? 10e6\n    this.cacheProvider = params.cacheProvider\n    this.simpleRouteJson = params.simpleRouteJson\n    this.nodes = params.nodes\n    this.edges = params.edges\n    this.nodeEdgeMap = getNodeEdgeMap(this.edges)\n    this.colorMap = params.colorMap ?? {}\n    this.nodeMap = new Map(\n      this.nodes.map((node) => [node.capacityMeshNodeId, node]),\n    )\n    this.nodeEdgeMap = getNodeEdgeMap(this.edges)\n    this.initialSolver =\n      params.initialPathingSolver ||\n      new CapacityPathingGreedySolver({\n        simpleRouteJson: this.simpleRouteJson,\n        nodes: this.nodes,\n        edges: this.edges,\n        colorMap: this.colorMap,\n      })\n    this.activeSubSolver = this.initialSolver\n\n    // Calculate and store total capacity for each node (only needs to be done once)\n    for (const node of this.nodes) {\n      const totalCapacity = this.initialSolver.getTotalCapacity(node)\n      this.totalNodeCapacityMap.set(node.capacityMeshNodeId, totalCapacity)\n    }\n\n    this.allNodeIdsSet = new Set(this.nodes.map((n) => n.capacityMeshNodeId))\n  }\n\n  _stepInitialization() {\n    this.initialSolver?.step()\n    if (this.initialSolver?.failed) {\n      this.failed = true\n      this.error = this.initialSolver.error\n      return\n    }\n    if (this.initialSolver?.solved) {\n      // Initialize the class's usedNodeCapacityMap from the initial solver\n      this.usedNodeCapacityMap = new Map(this.initialSolver.usedNodeCapacityMap)\n\n      // Calculate initial capacity percentages and reset attempt counts\n      for (const node of this.nodes) {\n        const totalCapacity =\n          this.totalNodeCapacityMap.get(node.capacityMeshNodeId) ?? 0 // Use pre-calculated total capacity\n        const usedCapacity =\n          this.usedNodeCapacityMap.get(node.capacityMeshNodeId) ?? 0\n        const percentUsed = totalCapacity > 0 ? usedCapacity / totalCapacity : 0\n\n        this.nodeCapacityPercentMap.set(node.capacityMeshNodeId, percentUsed)\n        this.nodeOptimizationAttemptCountMap.set(node.capacityMeshNodeId, 0)\n      }\n\n      this.connectionsWithNodes = this.initialSolver.connectionsWithNodes\n      this.stats.startingScore = computeSectionScore({\n        totalNodeCapacityMap: this.totalNodeCapacityMap,\n        usedNodeCapacityMap: this.usedNodeCapacityMap,\n        nodeMap: this.nodeMap,\n        sectionNodeIds: this.allNodeIdsSet,\n      })\n      this.stage = \"section-optimization\"\n    }\n  }\n\n  _getNextNodeToOptimize(): CapacityMeshNodeId | null {\n    // Get the node with the highest % capacity used with no attempts\n    let highestNodePfDivAttempts = 0\n    let highestNodePf = 0\n    let nodeWithHighestPercentCapacityUsed: CapacityMeshNodeId | null = null\n    for (const node of this.nodes) {\n      if (node._containsTarget) continue\n      const attemptCount = this.nodeOptimizationAttemptCountMap.get(\n        node.capacityMeshNodeId,\n      )!\n      const totalCapacity = this.totalNodeCapacityMap.get(\n        node.capacityMeshNodeId,\n      )!\n      const nodePf = calculateNodeProbabilityOfFailure(\n        this.usedNodeCapacityMap.get(node.capacityMeshNodeId) ?? 0,\n        totalCapacity,\n        node.availableZ.length,\n      )\n      const nodePfDivAttempts = nodePf / (attemptCount + 1)\n      if (\n        attemptCount < this.currentSchedule.MAX_ATTEMPTS_PER_NODE &&\n        nodePfDivAttempts > highestNodePfDivAttempts &&\n        nodePf > this.currentSchedule.MINIMUM_PROBABILITY_OF_FAILURE_TO_OPTIMIZE\n      ) {\n        highestNodePfDivAttempts = nodePfDivAttempts\n        highestNodePf = nodePf\n        nodeWithHighestPercentCapacityUsed = node.capacityMeshNodeId\n      }\n    }\n    // console.log(`Highest node Pf: ${highestNodePf}`)\n    return nodeWithHighestPercentCapacityUsed\n  }\n\n  getOverallScore() {\n    let highestNodePf = 0\n    for (const node of this.nodes) {\n      if (node._containsTarget) continue\n      const totalCapacity = this.totalNodeCapacityMap.get(\n        node.capacityMeshNodeId,\n      )!\n      const nodePf = calculateNodeProbabilityOfFailure(\n        this.usedNodeCapacityMap.get(node.capacityMeshNodeId) ?? 0,\n        totalCapacity,\n        node.availableZ.length,\n      )\n\n      if (nodePf > highestNodePf) {\n        highestNodePf = nodePf\n      }\n    }\n    return {\n      highestNodePf,\n      score: computeSectionScore({\n        totalNodeCapacityMap: this.totalNodeCapacityMap,\n        usedNodeCapacityMap: this.usedNodeCapacityMap,\n        nodeMap: this.nodeMap,\n        sectionNodeIds: this.allNodeIdsSet,\n      }),\n    }\n  }\n\n  _stepSectionOptimization() {\n    if (!this.sectionSolver) {\n      const centerNodeId = this._getNextNodeToOptimize()\n      if (!centerNodeId) {\n        const { highestNodePf, score } = this.getOverallScore()\n        this.stats.scheduleScores[\n          this.currentScheduleIndex\n        ].endingHighestNodePf = highestNodePf\n        this.stats.scheduleScores[this.currentScheduleIndex].endingScore = score\n\n        // No more nodes to optimize\n        this.currentScheduleIndex++\n\n        if (!this.currentSchedule) {\n          this.solved = true\n        }\n        return\n      }\n\n      const section = computeSectionNodesTerminalsAndEdges({\n        centerNodeId,\n        connectionsWithNodes: this.connectionsWithNodes,\n        nodeMap: this.nodeMap,\n        edges: this.edges,\n        expansionDegrees: this.currentSchedule.MAX_EXPANSION_DEGREES, // Corrected\n        nodeEdgeMap: this.nodeEdgeMap,\n      })\n      this.stats.scheduleScores[this.currentScheduleIndex].sectionAttempts++\n      this.currentSection = section\n      this.sectionSolver = new CachedHyperCapacityPathingSingleSectionSolver({\n        sectionNodes: this.currentSection.sectionNodes,\n        sectionEdges: this.currentSection.sectionEdges,\n        sectionConnectionTerminals:\n          this.currentSection.sectionConnectionTerminals,\n        colorMap: this.colorMap,\n        centerNodeId: this.currentSection.centerNodeId,\n        nodeEdgeMap: this.nodeEdgeMap,\n        hyperParameters: {\n          EXPANSION_DEGREES: this.currentSchedule.MAX_EXPANSION_DEGREES,\n        },\n        cacheProvider: this.cacheProvider,\n      })\n\n      this.activeSubSolver = this.sectionSolver\n      this.nodeOptimizationAttemptCountMap.set(\n        centerNodeId,\n        (this.nodeOptimizationAttemptCountMap.get(centerNodeId) ?? 0) + 1,\n      )\n    }\n\n    this.sectionSolver!.step()\n\n    if (this.sectionSolver!.failed || this.sectionSolver!.solved) {\n      if (this.sectionSolver.cacheHit) {\n        this.stats.cacheHits++\n      } else {\n        this.stats.cacheMisses++\n      }\n    }\n\n    if (this.sectionSolver!.failed) {\n      // If the section solver fails, mark the node as attempted but don't update paths\n      // TODO: Consider more sophisticated failure handling? Maybe increase expansionDegrees?\n      console.warn(\n        `Section solver failed for node ${\n          this.currentSection!.centerNodeId\n        }. Error: ${this.sectionSolver.error}`,\n      )\n      this.stats.failedSectionSolvers++\n      this.stats.failedOptimizations++\n      this.sectionSolver = null\n      this.activeSubSolver = null\n      return // Try the next node in the next step\n    }\n\n    if (this.sectionSolver!.solved) {\n      const sectionConnectionTerminals =\n        this.sectionSolver.sectionConnectionTerminals\n      const sectionNodes = this.sectionSolver.sectionNodes\n      const centerNodeId = this.sectionSolver.centerNodeId\n\n      this.sectionSolver = null // Clear active solver regardless of merge outcome\n      this.activeSubSolver = null\n      if (!sectionConnectionTerminals) {\n        console.warn(\n          `Pathing sub-solver for section ${\n            this.currentSection!.centerNodeId\n          } did not complete successfully. Discarding results.`,\n        )\n        return // Skip scoring and merging\n      }\n\n      const sectionNodeIds = new Set(\n        sectionNodes.map((n) => n.capacityMeshNodeId),\n      )\n\n      // --- Calculate Before Score ---\n      const beforeScore = computeSectionScore({\n        totalNodeCapacityMap: this.totalNodeCapacityMap,\n        usedNodeCapacityMap: this.usedNodeCapacityMap,\n        nodeMap: this.nodeMap,\n        sectionNodeIds,\n      })\n\n      // --- Calculate After Score (Simulated) ---\n      // 1. Create a temporary capacity map reflecting the state *after* applying new paths\n      const afterUsedCapacityMap = new Map(this.usedNodeCapacityMap)\n      const newSectionPaths = sectionConnectionTerminals\n\n      // 2. Decrement capacity for original paths within the section\n      for (const terminal of newSectionPaths) {\n        const originalConnection = this.connectionsWithNodes.find(\n          (conn) => conn.connection.name === terminal.connectionName,\n        )\n        if (originalConnection?.path) {\n          for (const node of originalConnection.path) {\n            if (sectionNodeIds.has(node.capacityMeshNodeId)) {\n              const currentUsage =\n                afterUsedCapacityMap.get(node.capacityMeshNodeId) ?? 0\n              // Ensure usage doesn't go below zero if maps were somehow inconsistent\n              afterUsedCapacityMap.set(\n                node.capacityMeshNodeId,\n                Math.max(0, currentUsage - 1),\n              )\n            }\n          }\n        }\n      }\n\n      // 3. Increment capacity for new paths within the section\n      for (const terminal of newSectionPaths) {\n        if (terminal.path) {\n          for (const node of terminal.path) {\n            // Only consider nodes within the section for the temporary map\n            if (sectionNodeIds.has(node.capacityMeshNodeId)) {\n              afterUsedCapacityMap.set(\n                node.capacityMeshNodeId,\n                (afterUsedCapacityMap.get(node.capacityMeshNodeId) ?? 0) + 1,\n              )\n            }\n          }\n        }\n      }\n\n      // 4. Calculate the score with the simulated capacity map\n      const afterScore = computeSectionScore({\n        totalNodeCapacityMap: this.totalNodeCapacityMap,\n        usedNodeCapacityMap: afterUsedCapacityMap,\n        nodeMap: this.nodeMap,\n        sectionNodeIds,\n      })\n\n      // --- Compare and Merge ---\n      if (afterScore > beforeScore) {\n        this.stats.successfulOptimizations++\n        // console.log(\n        //   `Section ${\n        //     solvedSectionSolver.centerNodeId\n        //   } improved score (${beforeScore.toFixed(\n        //     2,\n        //   )} -> ${afterScore.toFixed(2)}). Merging results.`,\n        // )\n        // Section solver succeeded AND improved score, merge the results\n        this._mergeSolvedSectionPaths({\n          centerNodeId,\n          sectionConnectionTerminals,\n        }) // Pass the original section solver instance\n        this._recalculateNodeCapacityUsage() // Recalculate global capacity after merging\n      } else {\n        this.stats.failedOptimizations++\n        // console.log(\n        //   `Section ${\n        //     solvedSectionSolver.centerNodeId\n        //   } did not improve score (${beforeScore.toFixed(\n        //     2,\n        //   )} -> ${afterScore.toFixed(2)}). Discarding results.`,\n        // )\n        // Score did not improve, do not merge. Capacity remains unchanged.\n      }\n    }\n  }\n\n  /**\n   * Merges the paths found by a successful section solver back into the main\n   * connectionsWithNodes list.\n   */\n  private _mergeSolvedSectionPaths({\n    centerNodeId,\n    sectionConnectionTerminals,\n  }: {\n    centerNodeId: string\n    sectionConnectionTerminals: SectionConnectionTerminal[]\n  }) {\n    for (const solvedTerminal of sectionConnectionTerminals) {\n      if (!solvedTerminal.path) {\n        // Pathing might have failed for this specific connection within the section\n        console.warn(\n          `No path found for connection ${solvedTerminal.connectionName} in section ${centerNodeId}`,\n        )\n        continue\n      }\n\n      const originalConnection = this.connectionsWithNodes.find(\n        (conn) => conn.connection.name === solvedTerminal.connectionName,\n      )\n\n      if (!originalConnection || !originalConnection.path) {\n        console.warn(\n          `Original connection or path not found for ${solvedTerminal.connectionName} while merging section ${centerNodeId}`,\n        )\n        continue\n      }\n\n      const originalPath = originalConnection.path\n      const newSectionPath = solvedTerminal.path\n\n      // Find the indices in the original path corresponding to the section terminals\n      const startIndex = originalPath.findIndex(\n        (node) => node.capacityMeshNodeId === solvedTerminal.startNodeId,\n      )\n      const endIndex = originalPath.findIndex(\n        (node) => node.capacityMeshNodeId === solvedTerminal.endNodeId,\n      )\n\n      if (startIndex === -1 || endIndex === -1) {\n        console.warn(\n          `Could not find start/end nodes (${solvedTerminal.startNodeId}/${solvedTerminal.endNodeId}) in original path for ${solvedTerminal.connectionName}`,\n        )\n        continue\n      }\n\n      // Ensure start comes before end in the original path array\n      // (Path direction might be reversed relative to section definition)\n      const [actualStartIndex, actualEndIndex] =\n        startIndex <= endIndex ? [startIndex, endIndex] : [endIndex, startIndex]\n\n      // Construct the new path: part before section + new section path + part after section\n      const pathBefore = originalPath.slice(0, actualStartIndex)\n      const pathAfter = originalPath.slice(actualEndIndex + 1)\n\n      // The newSectionPath might be reversed relative to the original path direction.\n      // Check if the start of newSectionPath matches the node at actualStartIndex.\n      // If not, reverse newSectionPath.\n      let orientedNewSectionPath = newSectionPath\n      if (\n        newSectionPath.length > 0 &&\n        originalPath[actualStartIndex] && // Check if node exists\n        newSectionPath[0].capacityMeshNodeId !==\n          originalPath[actualStartIndex].capacityMeshNodeId\n      ) {\n        // It's possible the section path connects directly to the node *after* the end index\n        // or *before* the start index if the section boundary was tight.\n        // A more robust check compares the connection points.\n        // Let's assume for now the section solver respects the start/end node IDs provided.\n        // If the first node of the new path doesn't match the node at the start index,\n        // and the last node *does* match, then reverse.\n        if (\n          newSectionPath[newSectionPath.length - 1].capacityMeshNodeId ===\n          originalPath[actualStartIndex].capacityMeshNodeId\n        ) {\n          orientedNewSectionPath = [...newSectionPath].reverse()\n        } else {\n          // This case is problematic - the new path doesn't seem to connect correctly.\n          console.warn(\n            `New section path for ${solvedTerminal.connectionName} doesn't align with original path boundaries. Skipping merge for this connection.`,\n          )\n          continue // Skip merging this specific path\n        }\n      }\n\n      originalConnection.path = [\n        ...pathBefore,\n        ...orientedNewSectionPath,\n        ...pathAfter,\n      ]\n    }\n  }\n\n  /**\n   * Recalculates node capacity usage based on the current connectionsWithNodes\n   * and updates the nodeCapacityPercentMap.\n   */\n  private _recalculateNodeCapacityUsage() {\n    // Clear the existing map\n    this.usedNodeCapacityMap.clear()\n\n    // Sum capacity usage from all current paths into the class property\n    for (const conn of this.connectionsWithNodes) {\n      if (!conn.path) continue\n      for (const node of conn.path) {\n        this.usedNodeCapacityMap.set(\n          node.capacityMeshNodeId,\n          (this.usedNodeCapacityMap.get(node.capacityMeshNodeId) ?? 0) + 1,\n        )\n      }\n    }\n\n    // Update the percentage map using the updated class property and the total capacity map\n    for (const node of this.nodes) {\n      const totalCapacity =\n        this.totalNodeCapacityMap.get(node.capacityMeshNodeId) ?? 0 // Use stored total capacity\n      const usedCapacity =\n        this.usedNodeCapacityMap.get(node.capacityMeshNodeId) ?? 0 // Use class property\n      const percentUsed = totalCapacity > 0 ? usedCapacity / totalCapacity : 0 // Avoid division by zero\n\n      this.nodeCapacityPercentMap.set(node.capacityMeshNodeId, percentUsed)\n    }\n  }\n\n  getCapacityPaths(): CapacityPath[] {\n    const capacityPaths: CapacityPath[] = []\n    for (const connection of this.connectionsWithNodes) {\n      const path = connection.path\n      if (path) {\n        capacityPaths.push({\n          capacityPathId: connection.connection.name,\n          connectionName: connection.connection.name,\n          nodeIds: path.map((node) => node.capacityMeshNodeId),\n        })\n      }\n    }\n    return capacityPaths\n  }\n\n  _step() {\n    if (this.iterations >= this.MAX_ITERATIONS - 1) {\n      // We're just an optimizer so we can't fail\n      this.solved = true\n      return\n    }\n    if (this.stage === \"initialization\") {\n      this._stepInitialization()\n    } else if (this.stage === \"section-optimization\") {\n      this._stepSectionOptimization()\n    }\n  }\n\n  visualize() {\n    // Prepare completed paths data for visualization\n    const completedPathsForViz = this.connectionsWithNodes\n      .filter((conn) => conn.path && conn.path.length > 0)\n      .map((conn) => ({\n        connectionName: conn.connection.name,\n        path: conn.path!, // Assert path exists due to filter\n      }))\n\n    return visualizeSection({\n      nodeMap: this.nodeMap,\n      // Still show terminals for context, even if paths are drawn separately\n      sectionConnectionTerminals: this.connectionsWithNodes.map((conn) => ({\n        connectionName: conn.connection.name,\n        startNodeId: conn.path?.[0]?.capacityMeshNodeId!,\n        endNodeId: conn.path?.[conn.path.length - 1]?.capacityMeshNodeId!,\n        // path: conn.path // Optionally pass the path here too if visualizeSection uses it for terminals\n      })),\n      completedPaths: completedPathsForViz, // Pass the final paths\n      sectionNodes: this.nodes,\n      sectionEdges: this.edges,\n      colorMap: this.colorMap,\n      totalCapacityMap: this.totalNodeCapacityMap,\n      usedNodeCapacityMap: this.usedNodeCapacityMap,\n      nodeOpacity: 0.05,\n      title: \"Capacity Pathing Multi-Section Solver (Solved)\",\n    })\n\n    // // Visualization for intermediate steps remains the same\n    // return (\n    //   this.activeSubSolver?.activeSubSolver?.visualize() ??\n    //   this.activeSubSolver?.visualize() ??\n    //   this.initialSolver.visualize()\n    // )\n  }\n}\n","import { CapacityMeshNode } from \"lib/types/capacity-mesh-types\"\nimport { BaseSolver } from \"../BaseSolver\"\nimport { GraphicsObject } from \"graphics-debug\"\nimport { getTunedTotalCapacity1 } from \"lib/utils/getTunedTotalCapacity1\"\n\nexport class StrawSolver extends BaseSolver {\n  multiLayerNodes: CapacityMeshNode[]\n\n  strawNodes: CapacityMeshNode[]\n  skippedNodes: CapacityMeshNode[]\n\n  unprocessedNodes: CapacityMeshNode[]\n  strawSize: number\n\n  nodeIdCounter: number\n\n  constructor(params: {\n    nodes: CapacityMeshNode[]\n    strawSize?: number\n  }) {\n    super()\n    this.MAX_ITERATIONS = 100e3\n    this.strawSize = params.strawSize ?? 0.5\n    this.multiLayerNodes = []\n    this.strawNodes = []\n    this.skippedNodes = []\n    this.nodeIdCounter = 0\n    this.unprocessedNodes = []\n    for (const node of params.nodes) {\n      if (node.availableZ.length === 1) {\n        this.unprocessedNodes.push(node)\n      } else {\n        this.multiLayerNodes.push(node)\n      }\n    }\n  }\n\n  getCapacityOfMultiLayerNodesWithinBounds(bounds: {\n    minX: number\n    maxX: number\n    minY: number\n    maxY: number\n  }): number {\n    let totalCapacity = 0\n\n    for (const node of this.multiLayerNodes) {\n      // Calculate node bounds\n      const nodeMinX = node.center.x - node.width / 2\n      const nodeMaxX = node.center.x + node.width / 2\n      const nodeMinY = node.center.y - node.height / 2\n      const nodeMaxY = node.center.y + node.height / 2\n\n      // Calculate overlap area\n      const overlapMinX = Math.max(bounds.minX, nodeMinX)\n      const overlapMaxX = Math.min(bounds.maxX, nodeMaxX)\n      const overlapMinY = Math.max(bounds.minY, nodeMinY)\n      const overlapMaxY = Math.min(bounds.maxY, nodeMaxY)\n\n      // If there's an overlap\n      if (overlapMinX < overlapMaxX && overlapMinY < overlapMaxY) {\n        const overlapWidth = overlapMaxX - overlapMinX\n        const overlapHeight = overlapMaxY - overlapMinY\n        const overlapArea = overlapWidth * overlapHeight\n        const nodeArea = node.width * node.height\n\n        // Calculate proportion of node that overlaps\n        const proportion = overlapArea / nodeArea\n\n        // Add proportional capacity to total\n        totalCapacity += getTunedTotalCapacity1(node) * proportion\n      }\n    }\n\n    return totalCapacity\n  }\n\n  getSurroundingCapacities(node: CapacityMeshNode): {\n    leftSurroundingCapacity: number\n    rightSurroundingCapacity: number\n    topSurroundingCapacity: number\n    bottomSurroundingCapacity: number\n  } {\n    const searchDistance = Math.min(node.width, node.height)\n\n    const leftSurroundingCapacity =\n      this.getCapacityOfMultiLayerNodesWithinBounds({\n        minX: node.center.x - node.width / 2 - searchDistance,\n        maxX: node.center.x - node.width / 2,\n        minY: node.center.y - node.height / 2,\n        maxY: node.center.y + node.height / 2,\n      })\n\n    const rightSurroundingCapacity =\n      this.getCapacityOfMultiLayerNodesWithinBounds({\n        minX: node.center.x + node.width / 2,\n        maxX: node.center.x + node.width / 2 + searchDistance,\n        minY: node.center.y - node.height / 2,\n        maxY: node.center.y + node.height / 2,\n      })\n\n    const topSurroundingCapacity =\n      this.getCapacityOfMultiLayerNodesWithinBounds({\n        minX: node.center.x - node.width / 2,\n        maxX: node.center.x + node.width / 2,\n        minY: node.center.y - node.height / 2 - searchDistance,\n        maxY: node.center.y - node.height / 2,\n      })\n\n    const bottomSurroundingCapacity =\n      this.getCapacityOfMultiLayerNodesWithinBounds({\n        minX: node.center.x - node.width / 2,\n        maxX: node.center.x + node.width / 2,\n        minY: node.center.y + node.height / 2,\n        maxY: node.center.y + node.height / 2 + searchDistance,\n      })\n\n    return {\n      leftSurroundingCapacity,\n      rightSurroundingCapacity,\n      topSurroundingCapacity,\n      bottomSurroundingCapacity,\n    }\n  }\n  /**\n   * Creates straw nodes from a single-layer node based on surrounding capacities\n   */\n  createStrawsForNode(node: CapacityMeshNode): CapacityMeshNode[] {\n    const result: CapacityMeshNode[] = []\n    const {\n      leftSurroundingCapacity,\n      rightSurroundingCapacity,\n      topSurroundingCapacity,\n      bottomSurroundingCapacity,\n    } = this.getSurroundingCapacities(node)\n\n    // Decide whether to create horizontal or vertical straws\n    const horizontalCapacity =\n      leftSurroundingCapacity + rightSurroundingCapacity\n    const verticalCapacity = topSurroundingCapacity + bottomSurroundingCapacity\n\n    // Layer-specific preferred direction\n    // Layer 0 (top) prefers horizontal traces, Layer 1 (bottom) prefers vertical\n    const layerPrefersFactor = 1 // node.availableZ[0] === 0 ? 1.3 : 0.7\n\n    const effectiveHorizontalCapacity = horizontalCapacity * layerPrefersFactor\n\n    // Create straws based on dimensions and surrounding capacity\n    if (effectiveHorizontalCapacity > verticalCapacity) {\n      // Create horizontal straws\n      const numStraws = Math.floor(node.height / this.strawSize)\n      const strawHeight = node.height / numStraws\n\n      for (let i = 0; i < numStraws; i++) {\n        const strawCenterY =\n          node.center.y - node.height / 2 + i * strawHeight + strawHeight / 2\n\n        result.push({\n          capacityMeshNodeId: `${node.capacityMeshNodeId}_straw${i}`,\n          center: { x: node.center.x, y: strawCenterY },\n          width: node.width,\n          height: strawHeight,\n          layer: node.layer,\n          availableZ: [...node.availableZ],\n          _depth: node._depth,\n          _strawNode: true,\n          _strawParentCapacityMeshNodeId: node.capacityMeshNodeId,\n        })\n      }\n    } else {\n      // Create vertical straws\n      const numStraws = Math.floor(node.width / this.strawSize)\n      const strawWidth = node.width / numStraws\n\n      for (let i = 0; i < numStraws; i++) {\n        const strawCenterX =\n          node.center.x - node.width / 2 + i * strawWidth + strawWidth / 2\n\n        result.push({\n          capacityMeshNodeId: `${node.capacityMeshNodeId}_straw${i}`,\n          center: { x: strawCenterX, y: node.center.y },\n          width: strawWidth,\n          height: node.height,\n          layer: node.layer,\n          availableZ: [...node.availableZ],\n          _depth: node._depth,\n          _strawNode: true,\n          _strawParentCapacityMeshNodeId: node.capacityMeshNodeId,\n        })\n      }\n    }\n\n    return result\n  }\n\n  getResultNodes(): CapacityMeshNode[] {\n    return [...this.multiLayerNodes, ...this.strawNodes, ...this.skippedNodes]\n  }\n\n  _step() {\n    const rootNode = this.unprocessedNodes.pop()\n\n    if (!rootNode) {\n      this.solved = true\n      return\n    }\n\n    // Skip nodes that are too small to subdivide\n    if (rootNode.width < this.strawSize && rootNode.height < this.strawSize) {\n      this.skippedNodes.push(rootNode)\n      return\n    }\n\n    // Skip target nodes (keep them intact)\n    if (rootNode._containsTarget) {\n      this.skippedNodes.push(rootNode)\n      return\n    }\n\n    // Create straws for this node\n    const strawNodes = this.createStrawsForNode(rootNode)\n    this.strawNodes.push(...strawNodes)\n  }\n\n  visualize(): GraphicsObject {\n    const graphics: GraphicsObject = {\n      rects: [],\n      lines: [],\n      points: [],\n      circles: [],\n      title: \"Straw Solver\",\n    }\n\n    // Draw unprocessed nodes\n    for (const node of this.unprocessedNodes) {\n      graphics.rects!.push({\n        center: node.center,\n        width: node.width,\n        height: node.height,\n        fill: \"rgba(200, 200, 200, 0.5)\",\n        stroke: \"rgba(0, 0, 0, 0.5)\",\n        label: `${node.capacityMeshNodeId}\\nUnprocessed\\n${node.width}x${node.height}`,\n      })\n    }\n\n    // Draw straw nodes with different colors based on layer\n    for (const node of this.strawNodes) {\n      const color =\n        node.availableZ[0] === 0\n          ? \"rgba(0, 150, 255, 0.5)\"\n          : \"rgba(255, 100, 0, 0.5)\"\n\n      graphics.rects!.push({\n        center: node.center,\n        width: node.width,\n        height: node.height,\n        fill: color,\n        stroke: \"rgba(0, 0, 0, 0.5)\",\n        label: `${node.capacityMeshNodeId}\\nLayer: ${node.availableZ[0]}\\n${node.width}x${node.height}`,\n        layer: `z${node.availableZ.join(\",\")}`,\n      })\n    }\n\n    // Draw multi-layer nodes\n    for (const node of this.multiLayerNodes) {\n      graphics.rects!.push({\n        center: node.center,\n        width: node.width * 0.9,\n        height: node.height * 0.9,\n        fill: \"rgba(100, 255, 100, 0.5)\",\n        stroke: \"rgba(0, 0, 0, 0.5)\",\n        layer: `z${node.availableZ.join(\",\")}`,\n        label: `${node.capacityMeshNodeId}\\nLayers: ${node.availableZ.join(\",\")}\\n${node.width}x${node.height}`,\n      })\n    }\n\n    return graphics\n  }\n}\n","import { CapacityMeshNode } from \"../types\"\n\nexport function areNodesBordering(\n  node1: CapacityMeshNode,\n  node2: CapacityMeshNode,\n): boolean {\n  const n1Left = node1.center.x - node1.width / 2\n  const n1Right = node1.center.x + node1.width / 2\n  const n1Top = node1.center.y - node1.height / 2\n  const n1Bottom = node1.center.y + node1.height / 2\n\n  const n2Left = node2.center.x - node2.width / 2\n  const n2Right = node2.center.x + node2.width / 2\n  const n2Top = node2.center.y - node2.height / 2\n  const n2Bottom = node2.center.y + node2.height / 2\n\n  const epsilon = 0.001\n\n  const shareVerticalBorder =\n    (Math.abs(n1Right - n2Left) < epsilon ||\n      Math.abs(n1Left - n2Right) < epsilon) &&\n    Math.min(n1Bottom, n2Bottom) - Math.max(n1Top, n2Top) >= epsilon\n\n  const shareHorizontalBorder =\n    (Math.abs(n1Bottom - n2Top) < epsilon ||\n      Math.abs(n1Top - n2Bottom) < epsilon) &&\n    Math.min(n1Right, n2Right) - Math.max(n1Left, n2Left) >= epsilon\n\n  return shareVerticalBorder || shareHorizontalBorder\n}\n","import { CapacityMeshNode, CapacityMeshNodeId } from \"lib/types\"\n\nexport type BucketCoordinate = `${number}x${number}`\n\nexport class CapacityNodeTree {\n  buckets: Map<BucketCoordinate, CapacityMeshNode[]>\n  CELL_SIZE = 0.4\n\n  constructor(public nodes: CapacityMeshNode[]) {\n    this.buckets = new Map()\n    for (const node of nodes) {\n      const nodeMinX = node.center.x - node.width / 2\n      const nodeMinY = node.center.y - node.height / 2\n      const nodeMaxX = node.center.x + node.width / 2\n      const nodeMaxY = node.center.y + node.height / 2\n      for (let x = nodeMinX; x <= nodeMaxX; x += this.CELL_SIZE) {\n        for (let y = nodeMinY; y <= nodeMaxY; y += this.CELL_SIZE) {\n          const bucketKey = this.getBucketKey(x, y)\n          const bucket = this.buckets.get(bucketKey)\n          if (!bucket) {\n            this.buckets.set(bucketKey, [node])\n          } else {\n            bucket.push(node)\n          }\n        }\n      }\n    }\n  }\n\n  getBucketKey(x: number, y: number): BucketCoordinate {\n    return `${Math.floor(x / this.CELL_SIZE)}x${Math.floor(y / this.CELL_SIZE)}`\n  }\n\n  getNodesInArea(\n    centerX: number,\n    centerY: number,\n    width: number,\n    height: number,\n  ) {\n    const nodes: CapacityMeshNode[] = []\n    const alreadyAddedNodes = new Set<CapacityMeshNodeId>()\n    const minX = centerX - width / 2\n    const minY = centerY - height / 2\n    const maxX = centerX + width / 2\n    const maxY = centerY + height / 2\n    for (let x = minX; x <= maxX; x += this.CELL_SIZE) {\n      for (let y = minY; y <= maxY; y += this.CELL_SIZE) {\n        const bucketKey = this.getBucketKey(x, y)\n        const bucket = this.buckets.get(bucketKey) || []\n        for (const node of bucket) {\n          if (alreadyAddedNodes.has(node.capacityMeshNodeId)) continue\n          alreadyAddedNodes.add(node.capacityMeshNodeId)\n          nodes.push(node)\n        }\n      }\n    }\n    return nodes\n  }\n}\n","import { CapacityMeshNode, CapacityMeshNodeId } from \"lib/types\"\nimport { BaseSolver } from \"../BaseSolver\"\nimport { areNodesBordering } from \"lib/utils/areNodesBordering\"\nimport { GraphicsObject } from \"graphics-debug\"\nimport { createRectFromCapacityNode } from \"lib/utils/createRectFromCapacityNode\"\nimport { CapacityNodeTree } from \"lib/data-structures/CapacityNodeTree\"\n\nconst EPSILON = 0.005\n\n/**\n * Merges same layer nodes into larger nodes. Pre-processing stage necessary\n * for \"strawing\".\n */\nexport class SingleLayerNodeMergerSolver extends BaseSolver {\n  nodeMap: Map<CapacityMeshNodeId, CapacityMeshNode>\n  currentBatchNodeIds: CapacityMeshNodeId[]\n\n  absorbedNodeIds: Set<CapacityMeshNodeId>\n\n  nextBatchNodeIds: CapacityMeshNodeId[]\n  batchHadModifications: boolean\n\n  hasComputedAdjacentNodeIds: boolean = false\n\n  newNodes: CapacityMeshNode[]\n  constructor(nodes: CapacityMeshNode[]) {\n    super()\n    this.nodeMap = new Map()\n    this.MAX_ITERATIONS = 100_000\n    // TODO we probably don't need this map because we only care about\n    // nodes that need to be absorbed or processed\n    for (const node of nodes) {\n      this.nodeMap.set(node.capacityMeshNodeId, node)\n    }\n    this.newNodes = []\n    this.absorbedNodeIds = new Set()\n    const unprocessedNodesWithArea: Array<[CapacityMeshNode, number]> = []\n    for (const node of nodes) {\n      if (node.availableZ.length > 1) {\n        this.newNodes.push(node)\n        this.absorbedNodeIds.add(node.capacityMeshNodeId)\n      } else {\n        unprocessedNodesWithArea.push([node, node.width * node.height])\n      }\n    }\n    unprocessedNodesWithArea.sort((a, b) => a[1] - b[1])\n    for (const [node, area] of unprocessedNodesWithArea) {\n      const unprocessedNode = {\n        ...node,\n        center: { ...node.center },\n      }\n      this.nodeMap.set(node.capacityMeshNodeId, unprocessedNode)\n    }\n    this.currentBatchNodeIds = unprocessedNodesWithArea.map(\n      ([node]) => node.capacityMeshNodeId,\n    )\n    this.nextBatchNodeIds = []\n    this.batchHadModifications = false\n  }\n\n  computeAdjacentNodeIdsForFirstBatch(nodes: CapacityMeshNode[]) {\n    const nodeTrees = [\n      new CapacityNodeTree(nodes.filter((n) => n.availableZ[0] === 0)),\n      new CapacityNodeTree(nodes.filter((n) => n.availableZ[0] === 1)),\n    ]\n    for (const node of nodes) {\n      const adjacentNodes: CapacityMeshNode[] = []\n      const z = node.availableZ[0]\n\n      const nodesInArea = nodeTrees[z].getNodesInArea(\n        node.center.x,\n        node.center.y,\n        node.width * 4,\n        node.height * 4,\n      )\n\n      for (const unprocessedNode of nodesInArea) {\n        if (\n          unprocessedNode._containsTarget &&\n          unprocessedNode._targetConnectionName !== node._targetConnectionName\n        )\n          continue\n        // if (this.absorbedNodeIds.has(unprocessedNode.capacityMeshNodeId))\n        //   continue\n        if (unprocessedNode.capacityMeshNodeId === node.capacityMeshNodeId)\n          continue\n        if (!areNodesBordering(node, unprocessedNode)) continue\n\n        adjacentNodes.push(unprocessedNode)\n      }\n\n      node._adjacentNodeIds = adjacentNodes.map((n) => n.capacityMeshNodeId)\n    }\n  }\n\n  // getAdjacentSameLayerUnprocessedNodes1(rootNode: CapacityMeshNode) {\n  //   const adjacentNodes: CapacityMeshNode[] = []\n  //   for (const unprocessedNodeId of this.currentBatchNodeIds) {\n  //     const unprocessedNode = this.nodeMap.get(unprocessedNodeId)!\n  //     if (!areNodesBordering(rootNode, unprocessedNode)) continue\n  //     if (unprocessedNode.availableZ[0] !== rootNode.availableZ[0]) continue\n  //     if (\n  //       unprocessedNode._containsTarget &&\n  //       unprocessedNode._targetConnectionName !== rootNode._targetConnectionName\n  //     )\n  //       continue\n  //     if (this.absorbedNodeIds.has(unprocessedNodeId)) continue\n  //     adjacentNodes.push(unprocessedNode)\n  //   }\n  //   return adjacentNodes\n  // }\n\n  getAdjacentSameLayerUnprocessedNodes(rootNode: CapacityMeshNode) {\n    return this.getAdjacentSameLayerUnprocessedNodes2(rootNode)\n  }\n\n  getAdjacentSameLayerUnprocessedNodes2(rootNode: CapacityMeshNode) {\n    const adjacentNodes: CapacityMeshNode[] = []\n    const unprocessedAdjNodes: CapacityMeshNode[] = Array.from(\n      new Set(\n        (rootNode._adjacentNodeIds ?? []).map((a) => this.nodeMap.get(a)!),\n      ),\n    )\n\n    unprocessedAdjNodes.sort((a, b) => a.width * a.height - b.width * b.height)\n\n    for (const unprocessedNode of unprocessedAdjNodes) {\n      if (this.absorbedNodeIds.has(unprocessedNode.capacityMeshNodeId)) continue\n      adjacentNodes.push(unprocessedNode)\n    }\n\n    return adjacentNodes\n  }\n\n  _step() {\n    if (!this.hasComputedAdjacentNodeIds) {\n      this.computeAdjacentNodeIdsForFirstBatch(\n        this.currentBatchNodeIds.map((id) => this.nodeMap.get(id)!),\n      )\n      this.hasComputedAdjacentNodeIds = true\n    }\n    let rootNodeId = this.currentBatchNodeIds.pop()\n    while (rootNodeId && this.absorbedNodeIds.has(rootNodeId)) {\n      rootNodeId = this.currentBatchNodeIds.pop()\n    }\n\n    if (!rootNodeId) {\n      if (this.batchHadModifications) {\n        this.currentBatchNodeIds = this.nextBatchNodeIds.sort((a, b) => {\n          const A = this.nodeMap.get(a)!\n          const B = this.nodeMap.get(b)!\n          return A.width * A.height - B.width * B.height\n        })\n        this.nextBatchNodeIds = []\n        this.batchHadModifications = false\n        return\n      }\n\n      this.solved = true\n      this.newNodes.push(\n        ...this.nextBatchNodeIds.map((id) => this.nodeMap.get(id)!),\n      )\n      return\n    }\n\n    const rootNode = this.nodeMap.get(rootNodeId)!\n    let rootNodeHasGrown = false\n\n    const adjacentNodes = this.getAdjacentSameLayerUnprocessedNodes(rootNode)\n\n    if (adjacentNodes.length === 0) {\n      this.nextBatchNodeIds.push(rootNodeId)\n      return\n    }\n\n    const absorbAdjacentNodeIds = (nodesToAbsorb: CapacityMeshNode[]) => {\n      for (const adjNode of nodesToAbsorb) {\n        this.absorbedNodeIds.add(adjNode.capacityMeshNodeId)\n      }\n\n      rootNode._adjacentNodeIds = Array.from(\n        new Set(\n          [\n            ...(rootNode._adjacentNodeIds ?? []),\n            ...nodesToAbsorb.flatMap((n) => n._adjacentNodeIds ?? []),\n          ].filter((id) => !this.absorbedNodeIds.has(id)),\n        ),\n      )\n    }\n\n    // Handle adjacent nodes to the LEFT\n    const adjacentNodesToLeft = adjacentNodes.filter(\n      (adjNode) =>\n        adjNode.center.x < rootNode.center.x &&\n        Math.abs(adjNode.center.y - rootNode.center.y) < rootNode.height / 2,\n    )\n\n    if (adjacentNodesToLeft.length > 0) {\n      const { width: leftAdjNodeWidth, height: leftAdjNodeHeight } =\n        adjacentNodesToLeft[0]\n      const leftAdjNodesAreAllSameSize = adjacentNodesToLeft.every(\n        (adjNode) =>\n          adjNode.width === leftAdjNodeWidth &&\n          adjNode.height === leftAdjNodeHeight,\n      )\n\n      const leftAdjNodesTakeUpEntireHeight =\n        Math.abs(\n          adjacentNodesToLeft.reduce((acc, adjNode) => {\n            return acc + adjNode.height\n          }, 0) - rootNode.height,\n        ) < EPSILON\n\n      if (leftAdjNodesTakeUpEntireHeight && leftAdjNodesAreAllSameSize) {\n        rootNode.width += leftAdjNodeWidth\n        rootNode.center.x = rootNode.center.x - leftAdjNodeWidth / 2\n\n        absorbAdjacentNodeIds(adjacentNodesToLeft)\n\n        rootNodeHasGrown = true\n      }\n    }\n\n    // Handle adjacent nodes to the RIGHT\n    const adjacentNodesToRight = adjacentNodes.filter(\n      (adjNode) =>\n        adjNode.center.x > rootNode.center.x &&\n        Math.abs(adjNode.center.y - rootNode.center.y) < rootNode.height / 2,\n    )\n\n    if (adjacentNodesToRight.length > 0 && !rootNodeHasGrown) {\n      const { width: rightAdjNodeWidth, height: rightAdjNodeHeight } =\n        adjacentNodesToRight[0]\n      const rightAdjNodesAreAllSameSize = adjacentNodesToRight.every(\n        (adjNode) =>\n          adjNode.width === rightAdjNodeWidth &&\n          adjNode.height === rightAdjNodeHeight,\n      )\n\n      const rightAdjNodesTakeUpEntireHeight =\n        Math.abs(\n          adjacentNodesToRight.reduce((acc, adjNode) => {\n            return acc + adjNode.height\n          }, 0) - rootNode.height,\n        ) < EPSILON\n\n      if (rightAdjNodesTakeUpEntireHeight && rightAdjNodesAreAllSameSize) {\n        rootNode.width += rightAdjNodeWidth\n        rootNode.center.x = rootNode.center.x + rightAdjNodeWidth / 2\n\n        absorbAdjacentNodeIds(adjacentNodesToRight)\n\n        rootNodeHasGrown = true\n      }\n    }\n\n    // Handle adjacent nodes to the TOP\n    const adjacentNodesToTop = adjacentNodes.filter(\n      (adjNode) =>\n        adjNode.center.y > rootNode.center.y &&\n        Math.abs(adjNode.center.x - rootNode.center.x) < rootNode.width / 2,\n    )\n\n    if (adjacentNodesToTop.length > 0 && !rootNodeHasGrown) {\n      const { width: topAdjNodeWidth, height: topAdjNodeHeight } =\n        adjacentNodesToTop[0]\n      const topAdjNodesAreAllSameSize = adjacentNodesToTop.every(\n        (adjNode) =>\n          adjNode.width === topAdjNodeWidth &&\n          adjNode.height === topAdjNodeHeight,\n      )\n\n      const topAdjNodesTakeUpEntireWidth =\n        Math.abs(\n          adjacentNodesToTop.reduce((acc, adjNode) => {\n            return acc + adjNode.width\n          }, 0) - rootNode.width,\n        ) < EPSILON\n\n      if (topAdjNodesTakeUpEntireWidth && topAdjNodesAreAllSameSize) {\n        rootNode.height += topAdjNodeHeight\n        rootNode.center.y = rootNode.center.y + topAdjNodeHeight / 2\n\n        absorbAdjacentNodeIds(adjacentNodesToTop)\n\n        rootNodeHasGrown = true\n      }\n    }\n\n    // Handle adjacent nodes to the BOTTOM\n    const adjacentNodesToBottom = adjacentNodes.filter(\n      (adjNode) =>\n        adjNode.center.y < rootNode.center.y &&\n        Math.abs(adjNode.center.x - rootNode.center.x) < rootNode.width / 2,\n    )\n\n    if (adjacentNodesToBottom.length > 0 && !rootNodeHasGrown) {\n      const { width: bottomAdjNodeWidth, height: bottomAdjNodeHeight } =\n        adjacentNodesToBottom[0]\n      const bottomAdjNodesAreAllSameSize = adjacentNodesToBottom.every(\n        (adjNode) =>\n          adjNode.width === bottomAdjNodeWidth &&\n          adjNode.height === bottomAdjNodeHeight,\n      )\n\n      const bottomAdjNodesTakeUpEntireWidth =\n        Math.abs(\n          adjacentNodesToBottom.reduce((acc, adjNode) => {\n            return acc + adjNode.width\n          }, 0) - rootNode.width,\n        ) < EPSILON\n\n      if (bottomAdjNodesTakeUpEntireWidth && bottomAdjNodesAreAllSameSize) {\n        rootNode.height += bottomAdjNodeHeight\n        rootNode.center.y = rootNode.center.y - bottomAdjNodeHeight / 2\n\n        absorbAdjacentNodeIds(adjacentNodesToBottom)\n\n        rootNodeHasGrown = true\n      }\n    }\n\n    if (rootNodeHasGrown) {\n      this.batchHadModifications = true\n      this.currentBatchNodeIds.push(rootNodeId)\n    } else {\n      this.nextBatchNodeIds.unshift(rootNodeId)\n      // this.processedNodeIds.add(rootNodeId)\n      // this.newNodes.push(rootNode)\n    }\n  }\n\n  visualize(): GraphicsObject {\n    const graphics = {\n      circles: [],\n      lines: [],\n      points: [],\n      rects: [],\n      coordinateSystem: \"cartesian\",\n      title: \"Same Layer Node Merger\",\n    } as Required<GraphicsObject>\n\n    for (const node of this.newNodes) {\n      graphics.rects.push(createRectFromCapacityNode(node))\n    }\n\n    const nextNodeIdInBatch =\n      this.currentBatchNodeIds[this.currentBatchNodeIds.length - 1]\n    let adjacentNodes: CapacityMeshNode[] | undefined\n    if (nextNodeIdInBatch) {\n      adjacentNodes = this.getAdjacentSameLayerUnprocessedNodes(\n        this.nodeMap.get(nextNodeIdInBatch)!,\n      )\n    }\n\n    // Visualize unprocessed nodes with a different style\n    for (const nodeId of this.currentBatchNodeIds) {\n      const node = this.nodeMap.get(nodeId)\n      if (this.absorbedNodeIds.has(nodeId)) continue\n      if (node) {\n        const rect = createRectFromCapacityNode(node, {\n          rectMargin: 0.01,\n        })\n        if (nodeId === nextNodeIdInBatch) {\n          rect.stroke = \"rgba(0, 255, 0, 0.8)\" // Green for next node in batch\n        } else if (\n          adjacentNodes?.some(\n            (adjNode) => adjNode.capacityMeshNodeId === nodeId,\n          )\n        ) {\n          rect.stroke = \"rgba(128, 0, 128, 0.8)\" // Purple for adjacent nodes\n        } else {\n          rect.stroke = \"rgba(255, 165, 0, 0.8)\" // Orange border for other nodes\n        }\n        rect.layer = `z${node.availableZ.join(\",\")}`\n        rect.label = `${rect.label}\\n(unprocessed)`\n        graphics.rects.push(rect)\n      }\n    }\n\n    // Visualize next batch nodes with a different style\n    for (const nodeId of this.nextBatchNodeIds) {\n      const node = this.nodeMap.get(nodeId)\n      if (this.absorbedNodeIds.has(nodeId)) continue\n      if (node) {\n        const rect = createRectFromCapacityNode(node, {\n          rectMargin: 0.01,\n        })\n        rect.layer = `z${node.availableZ.join(\",\")}`\n        rect.stroke = \"rgba(0, 217, 255, 0.8)\" // Green border\n        rect.label = `${rect.label}\\nx: ${node.center.x}, y: ${node.center.y}\\n${node.width}x${node.height}\\n(next batch)`\n        graphics.rects.push(rect)\n      }\n    }\n\n    return graphics\n  }\n}\n","import { HighDensityIntraNodeRoute } from \"lib/types/high-density-types\"\nimport { BaseSolver } from \"../BaseSolver\"\nimport { Obstacle } from \"lib/types\"\nimport { calculate45DegreePaths } from \"lib/utils/calculate45DegreePaths\"\nimport { GraphicsObject } from \"graphics-debug\"\nimport { ConnectivityMap } from \"circuit-json-to-connectivity-map\"\n\ninterface Point {\n  x: number\n  y: number\n  z: number\n}\n\nexport class SingleSimplifiedPathSolver extends BaseSolver {\n  newRoute: HighDensityIntraNodeRoute[\"route\"]\n  newVias: HighDensityIntraNodeRoute[\"vias\"]\n\n  headIndex = 0\n  tailIndex = 0\n\n  inputRoute: HighDensityIntraNodeRoute\n  otherHdRoutes: HighDensityIntraNodeRoute[]\n  obstacles: Obstacle[]\n  connMap: ConnectivityMap\n  colorMap: Record<string, string>\n\n  constructor(params: {\n    inputRoute: HighDensityIntraNodeRoute\n    otherHdRoutes: HighDensityIntraNodeRoute[]\n    obstacles: Obstacle[]\n    connMap: ConnectivityMap\n    colorMap: Record<string, string>\n  }) {\n    super()\n\n    this.inputRoute = params.inputRoute\n    this.otherHdRoutes = params.otherHdRoutes\n    this.obstacles = params.obstacles\n    this.connMap = params.connMap\n    this.colorMap = params.colorMap\n\n    this.newRoute = [this.inputRoute.route[0]]\n    this.newVias = []\n  }\n\n  getConstructorParams() {\n    return {\n      inputRoute: this.inputRoute,\n      otherHdRoutes: this.otherHdRoutes,\n      obstacles: this.obstacles,\n      connMap: this.connMap.netMap,\n      colorMap: this.colorMap,\n    }\n  }\n\n  get simplifiedRoute(): HighDensityIntraNodeRoute {\n    return {\n      connectionName: this.inputRoute.connectionName,\n      traceThickness: this.inputRoute.traceThickness,\n      viaDiameter: this.inputRoute.viaDiameter,\n      route: this.newRoute,\n      vias: this.newVias,\n    }\n  }\n\n  isValidPath(pointsInRoute: Point[]): boolean {\n    // check that the segments don't intersect with any obstacles or other\n    // routes or vias\n    throw new Error(\"Not implemented\")\n  }\n\n  _step() {\n    // Each iteration, we're going to increase the head and make sure that\n    // there's a compatible simplified path from the tail to the head\n    // If there isn't a compatible simplified path, we add a segment to the new\n    // route from [tail, tail + (head - tail) / 2] then start our next iteration\n    // at tail = tail + Math.ceil((head - tail) / 2)\n    // If there is a Z change between the tail and the head, we stop the\n    // simplification for that segment (add to newRoute and newVias, set tail to\n    // head)\n    throw new Error(\"Not implemented\")\n  }\n\n  getVisualsForNewRouteAndObstacles() {\n    const graphics: Required<GraphicsObject> = {\n      lines: [],\n      points: [],\n      circles: [],\n      rects: [],\n      coordinateSystem: \"cartesian\",\n      title: \"Simplified Path Solver\",\n    }\n\n    // Visualize the original route in red\n    for (let i = 0; i < this.inputRoute.route.length - 1; i++) {\n      graphics.lines.push({\n        points: [\n          { x: this.inputRoute.route[i].x, y: this.inputRoute.route[i].y },\n          {\n            x: this.inputRoute.route[i + 1].x,\n            y: this.inputRoute.route[i + 1].y,\n          },\n        ],\n        strokeColor: \"rgba(255, 0, 0, 0.8)\",\n        strokeDash: this.inputRoute.route[i].z === 1 ? \"5, 5\" : undefined,\n        layer: `z${this.inputRoute.route[i].z.toString()}`,\n      })\n    }\n\n    // Visualize the simplified route in green\n    for (let i = 0; i < this.newRoute.length; i++) {\n      if (i < this.newRoute.length - 1) {\n        graphics.lines.push({\n          points: [\n            { x: this.newRoute[i].x, y: this.newRoute[i].y },\n            { x: this.newRoute[i + 1].x, y: this.newRoute[i + 1].y },\n          ],\n          strokeWidth: 0.15,\n          strokeColor: \"rgba(0, 255, 0, 0.8)\",\n          strokeDash: this.newRoute[i].z === 1 ? [0.4, 0.4] : undefined,\n          layer: `z${this.newRoute[i].z.toString()}`,\n        })\n      }\n      graphics.points.push({\n        x: this.newRoute[i].x,\n        y: this.newRoute[i].y,\n        color: \"rgba(0, 255, 0, 0.8)\",\n        label: `z: ${this.newRoute[i].z}`,\n        layer: `z${this.newRoute[i].z.toString()}`,\n      })\n    }\n\n    // // Visualize vias\n    for (const via of this.newVias) {\n      graphics.circles.push({\n        center: via,\n        radius: this.inputRoute.viaDiameter / 2,\n        fill: \"rgba(0, 0, 255, 0.5)\",\n      })\n    }\n\n    // Visualize obstacles\n    for (const obstacle of this.obstacles) {\n      graphics.rects.push({\n        center: obstacle.center,\n        width: obstacle.width,\n        height: obstacle.height,\n        fill: obstacle.layers?.includes(\"top\")\n          ? \"rgba(255, 0, 0, 0.3)\"\n          : obstacle.layers?.includes(\"bottom\")\n            ? \"rgba(0, 0, 255, 0.3)\"\n            : \"rgba(128, 128, 128, 0.3)\",\n      })\n    }\n\n    // Visualize other routes as obstacles (in purple)\n    for (const route of this.otherHdRoutes) {\n      for (let i = 0; i < route.route.length - 1; i++) {\n        graphics.lines.push({\n          points: [\n            { x: route.route[i].x, y: route.route[i].y },\n            { x: route.route[i + 1].x, y: route.route[i + 1].y },\n          ],\n          strokeWidth: 0.15,\n          strokeColor:\n            route.route[i].z === 0\n              ? \"rgba(255, 0, 255, 0.5)\" // top layer (purple)\n              : route.route[i].z === 1\n                ? \"rgba(128, 0, 128, 0.5)\" // inner layer (darker purple)\n                : \"rgba(0, 0, 255, 0.5)\", // bottom layer (blue)\n          layer: `z${route.route[i].z.toString()}`,\n        })\n      }\n    }\n\n    if (\"filteredObstaclePathSegments\" in this) {\n      const filteredObstaclePathSegments = this\n        .filteredObstaclePathSegments as Array<[Point, Point]>\n      for (const [start, end] of filteredObstaclePathSegments) {\n        graphics.lines.push({\n          points: [start, end],\n        })\n      }\n    }\n\n    return graphics\n  }\n}\n","interface Point {\n  x: number\n  y: number\n}\n\nexport const calculate45DegreePaths = (\n  pointA: Point,\n  pointB: Point,\n): Array<Array<Point>> => {\n  const result: Array<Array<Point>> = []\n  const dx = Math.abs(pointB.x - pointA.x)\n  const dy = Math.abs(pointB.y - pointA.y)\n  const signX = pointB.x > pointA.x ? 1 : -1\n  const signY = pointB.y > pointA.y ? 1 : -1\n\n  // Path 1: Horizontal then 45 degrees\n  const midPoint1: Point = {\n    x: pointB.x - signX * Math.abs(pointB.y - pointA.y),\n    y: pointA.y,\n  }\n  // Check if midpoint is within bounds\n  if (\n    (midPoint1.x - pointA.x) * signX >= 0 &&\n    (midPoint1.x - pointB.x) * signX <= 0\n  ) {\n    result.push([pointA, midPoint1, pointB])\n  }\n\n  // Path 2: Vertical then 45 degrees\n  const midPoint2: Point = {\n    x: pointA.x,\n    y: pointB.y - signY * Math.abs(pointB.x - pointA.x),\n  }\n  // Check if midpoint is within bounds\n  if (\n    (midPoint2.y - pointA.y) * signY >= 0 &&\n    (midPoint2.y - pointB.y) * signY <= 0\n  ) {\n    result.push([pointA, midPoint2, pointB])\n  }\n\n  // // Calculate 45-degree points\n  const minDist = Math.min(dx, dy)\n\n  // // Path 3: 45 degrees then horizontal\n  const midPoint3: Point = {\n    x: pointA.x + signX * minDist,\n    y: pointA.y + signY * minDist,\n  }\n  // Check if midpoint is within bounds\n  if (\n    (midPoint3.x - pointA.x) * signX >= 0 &&\n    (midPoint3.x - pointB.x) * signX <= 0 &&\n    (midPoint3.y - pointA.y) * signY >= 0 &&\n    (midPoint3.y - pointB.y) * signY <= 0\n  ) {\n    result.push([pointA, midPoint3, pointB])\n  }\n\n  return result\n}\n","interface Point {\n  x: number\n  y: number\n}\n\n/**\n * Calculates the minimum distance between two line segments.\n * @param A1 First point of the first line segment\n * @param A2 Second point of the first line segment\n * @param B1 First point of the second line segment\n * @param B2 Second point of the second line segment\n * @returns The minimum distance between the two line segments\n */\nexport function minimumDistanceBetweenSegments(\n  A1: Point,\n  A2: Point,\n  B1: Point,\n  B2: Point,\n): number {\n  // Check if segments intersect\n  if (segmentsIntersect(A1, A2, B1, B2)) {\n    return 0\n  }\n\n  // Calculate distances from each endpoint to the other segment\n  const distA1 = pointToSegmentDistance(A1, B1, B2)\n  const distA2 = pointToSegmentDistance(A2, B1, B2)\n  const distB1 = pointToSegmentDistance(B1, A1, A2)\n  const distB2 = pointToSegmentDistance(B2, A1, A2)\n\n  // Return the minimum of the four distances\n  return Math.min(distA1, distA2, distB1, distB2)\n}\n\n/**\n * Calculates the distance from a point to a line segment.\n * @param P The point\n * @param Q1 First point of the line segment\n * @param Q2 Second point of the line segment\n * @returns The minimum distance from point P to the line segment Q1Q2\n */\nfunction pointToSegmentDistance(P: Point, Q1: Point, Q2: Point): number {\n  const v = { x: Q2.x - Q1.x, y: Q2.y - Q1.y }\n  const w = { x: P.x - Q1.x, y: P.y - Q1.y }\n\n  // Calculate squared length of the segment\n  const c1 = dotProduct(w, v)\n  if (c1 <= 0) {\n    // Point is behind Q1\n    return distance(P, Q1)\n  }\n\n  const c2 = dotProduct(v, v)\n  if (c2 <= c1) {\n    // Point is beyond Q2\n    return distance(P, Q2)\n  }\n\n  // Point projects onto the segment\n  const b = c1 / c2\n  const Pb = {\n    x: Q1.x + b * v.x,\n    y: Q1.y + b * v.y,\n  }\n  return distance(P, Pb)\n}\n\n/**\n * Calculates the dot product of two vectors.\n */\nfunction dotProduct(\n  v1: { x: number; y: number },\n  v2: { x: number; y: number },\n): number {\n  return v1.x * v2.x + v1.y * v2.y\n}\n\n/**\n * Calculates the Euclidean distance between two points.\n */\nfunction distance(p1: Point, p2: Point): number {\n  const dx = p2.x - p1.x\n  const dy = p2.y - p1.y\n  return Math.sqrt(dx * dx + dy * dy)\n}\n\n/**\n * Determines the orientation of triplet (p, q, r).\n * @returns 0 if collinear, 1 if clockwise, 2 if counterclockwise\n */\nfunction orientation(p: Point, q: Point, r: Point): number {\n  const val = (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y)\n  if (val === 0) return 0 // collinear\n  return val > 0 ? 1 : 2 // clockwise or counterclockwise\n}\n\n/**\n * Checks if point q lies on segment pr.\n */\nfunction onSegment(p: Point, q: Point, r: Point): boolean {\n  return (\n    q.x <= Math.max(p.x, r.x) &&\n    q.x >= Math.min(p.x, r.x) &&\n    q.y <= Math.max(p.y, r.y) &&\n    q.y >= Math.min(p.y, r.y)\n  )\n}\n\n/**\n * Checks if two line segments intersect.\n */\nfunction segmentsIntersect(\n  A1: Point,\n  A2: Point,\n  B1: Point,\n  B2: Point,\n): boolean {\n  // Find the four orientations needed for general case\n  const o1 = orientation(A1, A2, B1)\n  const o2 = orientation(A1, A2, B2)\n  const o3 = orientation(B1, B2, A1)\n  const o4 = orientation(B1, B2, A2)\n\n  // General case\n  if (o1 !== o2 && o3 !== o4) return true\n\n  // Special Cases\n  // A1, A2 and B1 are collinear and B1 lies on segment A1A2\n  if (o1 === 0 && onSegment(A1, B1, A2)) return true\n\n  // A1, A2 and B2 are collinear and B2 lies on segment A1A2\n  if (o2 === 0 && onSegment(A1, B2, A2)) return true\n\n  // B1, B2 and A1 are collinear and A1 lies on segment B1B2\n  if (o3 === 0 && onSegment(B1, A1, B2)) return true\n\n  // B1, B2 and A2 are collinear and A2 lies on segment B1B2\n  if (o4 === 0 && onSegment(B1, A2, B2)) return true\n\n  return false // Doesn't fall in any of the above cases\n}\n","interface Point {\n  x: number\n  y: number\n  z: number\n}\n\ntype Segment = [Point, Point]\n\ntype SegmentWithId = [Point, Point, string]\n\nconst getSegmentBounds = (segment: Segment) => {\n  return {\n    minX: Math.min(segment[0].x, segment[1].x),\n    maxX: Math.max(segment[0].x, segment[1].x),\n    minY: Math.min(segment[0].y, segment[1].y),\n    maxY: Math.max(segment[0].y, segment[1].y),\n  }\n}\nexport type BucketCoordinate = `${number}x${number}`\n\nexport class SegmentTree {\n  buckets: Map<BucketCoordinate, SegmentWithId[]>\n  CELL_SIZE = 0.4\n  SEGMENT_MARGIN = 0.4 // traceThickness + obstacleMargin\n\n  constructor(public segments: Segment[]) {\n    this.buckets = new Map()\n    const segmentsById = new Map<string, Segment>() // Avoid adding duplicates if input has them\n\n    for (const segment of segments) {\n      const segmentKey = this.getSegmentKey(segment)\n      if (segmentsById.has(segmentKey)) continue // Skip duplicates in input\n      segmentsById.set(segmentKey, segment)\n\n      const bounds = getSegmentBounds(segment)\n\n      // Calculate min/max integer indices covered by the segment's bounds\n      const minIndexX = Math.floor(bounds.minX / this.CELL_SIZE)\n      const maxIndexX = Math.floor(bounds.maxX / this.CELL_SIZE)\n      const minIndexY = Math.floor(bounds.minY / this.CELL_SIZE)\n      const maxIndexY = Math.floor(bounds.maxY / this.CELL_SIZE)\n\n      // Iterate through the integer indices\n      for (let ix = minIndexX; ix <= maxIndexX; ix++) {\n        for (let iy = minIndexY; iy <= maxIndexY; iy++) {\n          const bucketKey = `${ix}x${iy}` as BucketCoordinate // Construct key from indices\n          const bucket = this.buckets.get(bucketKey)\n          const segmentWithId: SegmentWithId = [\n            segment[0],\n            segment[1],\n            segmentKey,\n          ]\n\n          if (!bucket) {\n            this.buckets.set(bucketKey, [segmentWithId])\n          } else {\n            // Optional: Check if segment already in this specific bucket if constructor might be called multiple times\n            // or if input segments could be complex overlaps. Usually not needed if input is processed once.\n            bucket.push(segmentWithId)\n          }\n        }\n      }\n    }\n  }\n\n  getBucketKey(x: number, y: number): BucketCoordinate {\n    return `${Math.floor(x / this.CELL_SIZE)}x${Math.floor(y / this.CELL_SIZE)}`\n  }\n\n  getSegmentKey(segment: Segment): string {\n    return `${segment[0].x}-${segment[0].y}-${segment[0].z}-${segment[1].x}-${segment[1].y}-${segment[1].z}`\n  }\n\n  getSegmentsThatCouldIntersect(A: Point, B: Point): SegmentWithId[] {\n    const segments: SegmentWithId[] = []\n    const alreadyAddedSegments = new Set<string>()\n\n    // Calculate the margined bounding box of the query segment\n    const minX = Math.min(A.x, B.x) - this.SEGMENT_MARGIN\n    const minY = Math.min(A.y, B.y) - this.SEGMENT_MARGIN\n    const maxX = Math.max(A.x, B.x) + this.SEGMENT_MARGIN\n    const maxY = Math.max(A.y, B.y) + this.SEGMENT_MARGIN\n\n    // Calculate min/max integer indices covered by the margined query bounds\n    const minIndexX = Math.floor(minX / this.CELL_SIZE)\n    const maxIndexX = Math.floor(maxX / this.CELL_SIZE)\n    const minIndexY = Math.floor(minY / this.CELL_SIZE)\n    const maxIndexY = Math.floor(maxY / this.CELL_SIZE)\n\n    // Iterate through the integer indices\n    for (let ix = minIndexX; ix <= maxIndexX; ix++) {\n      for (let iy = minIndexY; iy <= maxIndexY; iy++) {\n        const bucketKey = `${ix}x${iy}` as BucketCoordinate // Construct key from indices\n        const bucket = this.buckets.get(bucketKey)\n\n        if (bucket) {\n          // Check if bucket exists\n          for (const segment of bucket) {\n            const key = segment[2] // The segment key is stored at index 2\n            if (!alreadyAddedSegments.has(key)) {\n              alreadyAddedSegments.add(key)\n              segments.push(segment)\n            }\n          }\n        }\n      }\n    }\n    return segments\n  }\n}\n","import {\n  doSegmentsIntersect,\n  pointToSegmentDistance,\n} from \"@tscircuit/math-utils\"\nimport { HighDensityIntraNodeRoute } from \"lib/types/high-density-types\"\nimport { BaseSolver } from \"../BaseSolver\"\nimport { Obstacle } from \"lib/types\"\nimport { GraphicsObject } from \"graphics-debug\"\nimport { SingleSimplifiedPathSolver } from \"./SingleSimplifiedPathSolver\"\nimport { calculate45DegreePaths } from \"lib/utils/calculate45DegreePaths\"\nimport { minimumDistanceBetweenSegments } from \"lib/utils/minimumDistanceBetweenSegments\"\nimport { SegmentTree } from \"lib/data-structures/SegmentTree\"\nimport {\n  segmentToBoxMinDistance,\n  computeDistanceBetweenBoxes,\n  segmentToBoundsMinDistance,\n} from \"@tscircuit/math-utils\"\n\ninterface Point {\n  x: number\n  y: number\n  z: number\n}\n\ninterface PathSegment {\n  start: Point\n  end: Point\n  length: number\n  startDistance: number\n  endDistance: number\n}\n\nexport class SingleSimplifiedPathSolver5 extends SingleSimplifiedPathSolver {\n  private pathSegments: PathSegment[] = []\n  private totalPathLength: number = 0\n  private headDistanceAlongPath: number = 0\n  private tailDistanceAlongPath: number = 0\n  private minStepSize: number = 0.25 // Default step size, can be adjusted\n  private lastValidPath: Point[] | null = null // Store the current valid path\n  private lastValidPathHeadDistance: number = 0\n\n  /** Amount the step size is reduced when the step isn't possible */\n  STEP_SIZE_REDUCTION_FACTOR = 0.25\n  maxStepSize = 4\n  currentStepSize = this.maxStepSize\n  lastHeadMoveDistance = 0\n\n  cachedValidPathSegments: Set<string>\n\n  filteredObstacles: Obstacle[] = []\n  filteredObstaclePathSegments: Array<[Point, Point]> = []\n  filteredVias: Array<{ x: number; y: number; diameter: number }> = []\n\n  segmentTree!: SegmentTree\n\n  OBSTACLE_MARGIN = 0.1\n  TRACE_THICKNESS = 0.15\n\n  TAIL_JUMP_RATIO: number = 0.8\n\n  constructor(\n    params: ConstructorParameters<typeof SingleSimplifiedPathSolver>[0],\n  ) {\n    super(params)\n\n    this.cachedValidPathSegments = new Set()\n\n    // Handle empty or single-point routes\n    if (this.inputRoute.route.length <= 1) {\n      this.newRoute = [...this.inputRoute.route]\n      this.solved = true\n      return\n    }\n\n    const bounds = this.inputRoute.route.reduce(\n      (acc, point) => {\n        acc.minX = Math.min(acc.minX, point.x)\n        acc.maxX = Math.max(acc.maxX, point.x)\n        acc.minY = Math.min(acc.minY, point.y)\n        acc.maxY = Math.max(acc.maxY, point.y)\n        return acc\n      },\n      { minX: Infinity, maxX: -Infinity, minY: Infinity, maxY: -Infinity },\n    )\n    const boundsBox = {\n      center: {\n        x: (bounds.minX + bounds.maxX) / 2,\n        y: (bounds.minY + bounds.maxY) / 2,\n      },\n      width: bounds.maxX - bounds.minX,\n      height: bounds.maxY - bounds.minY,\n    }\n\n    this.filteredObstacles = this.obstacles\n      .filter(\n        (obstacle) =>\n          !obstacle.connectedTo.some((id) =>\n            this.connMap.areIdsConnected(this.inputRoute.connectionName, id),\n          ),\n      )\n      .filter((obstacle) => {\n        if (\n          obstacle.connectedTo.some((obsId) =>\n            this.connMap.areIdsConnected(this.inputRoute.connectionName, obsId),\n          )\n        ) {\n          return false\n        }\n\n        const { distance } = computeDistanceBetweenBoxes(boundsBox, obstacle)\n\n        if (distance < this.OBSTACLE_MARGIN + 0.5) {\n          return true\n        }\n\n        return false\n      })\n\n    this.filteredObstaclePathSegments = this.otherHdRoutes.flatMap(\n      (hdRoute) => {\n        if (\n          this.connMap.areIdsConnected(\n            this.inputRoute.connectionName,\n            hdRoute.connectionName,\n          )\n        ) {\n          return []\n        }\n\n        const route = hdRoute.route\n        const segments: Array<[Point, Point]> = []\n        for (let i = 0; i < route.length - 1; i++) {\n          const start = route[i]\n          const end = route[i + 1]\n\n          const minX = Math.min(start.x, end.x)\n          const maxX = Math.max(start.x, end.x)\n          const minY = Math.min(start.y, end.y)\n          const maxY = Math.max(start.y, end.y)\n\n          if (\n            minX <= bounds.maxX &&\n            maxX >= bounds.minX &&\n            minY <= bounds.maxY &&\n            maxY >= bounds.minY\n          ) {\n            segments.push([start, end])\n          }\n        }\n\n        return segments\n      },\n    )\n    this.segmentTree = new SegmentTree(this.filteredObstaclePathSegments)\n\n    this.filteredVias = this.otherHdRoutes.flatMap((hdRoute) => {\n      if (\n        this.connMap.areIdsConnected(\n          this.inputRoute.connectionName,\n          hdRoute.connectionName,\n        )\n      ) {\n        return []\n      }\n\n      const vias = hdRoute.vias\n      const filteredVias: Array<{ x: number; y: number; diameter: number }> = []\n      for (const via of vias) {\n        const margin =\n          this.OBSTACLE_MARGIN +\n          this.TRACE_THICKNESS / 2 +\n          hdRoute.viaDiameter / 2\n        const minX = via.x - margin\n        const maxX = via.x + margin\n        const minY = via.y - margin\n        const maxY = via.y + margin\n\n        if (\n          minX <= bounds.maxX &&\n          maxX >= bounds.minX &&\n          minY <= bounds.maxY &&\n          maxY >= bounds.minY\n        ) {\n          filteredVias.push({ ...via, diameter: hdRoute.viaDiameter })\n        }\n      }\n      return filteredVias\n    })\n\n    // Compute path segments and total length\n    this.computePathSegments()\n  }\n\n  // Compute the path segments and their distances\n  private computePathSegments() {\n    let cumulativeDistance = 0\n\n    for (let i = 0; i < this.inputRoute.route.length - 1; i++) {\n      const start = this.inputRoute.route[i]\n      const end = this.inputRoute.route[i + 1]\n\n      // Calculate segment length using Euclidean distance\n      const length =\n        Math.sqrt((end.x - start.x) ** 2 + (end.y - start.y) ** 2) + i / 10000\n\n      this.pathSegments.push({\n        start,\n        end,\n        length,\n        startDistance: cumulativeDistance,\n        endDistance: cumulativeDistance + length,\n      })\n\n      cumulativeDistance += length\n    }\n\n    this.totalPathLength = cumulativeDistance\n  }\n\n  // Helper to check if two points are the same\n  private arePointsEqual(p1: Point, p2: Point): boolean {\n    return p1.x === p2.x && p1.y === p2.y && p1.z === p2.z\n  }\n\n  // Get point at a specific distance along the path\n  private getPointAtDistance(distance: number): Point {\n    // Ensure distance is within bounds\n    distance = Math.max(0, Math.min(distance, this.totalPathLength))\n\n    // Find the segment that contains this distance\n    const segment = this.pathSegments.find(\n      (seg) => distance >= seg.startDistance && distance <= seg.endDistance,\n    )\n\n    if (!segment) {\n      // Fallback to last point if segment not found\n      return this.inputRoute.route[this.inputRoute.route.length - 1]\n    }\n\n    // Calculate interpolation factor (between 0 and 1)\n    const factor = (distance - segment.startDistance) / segment.length\n\n    // Interpolate the point\n    return {\n      x: segment.start.x + factor * (segment.end.x - segment.start.x),\n      y: segment.start.y + factor * (segment.end.y - segment.start.y),\n      z: factor < 0.5 ? segment.start.z : segment.end.z, // Z doesn't interpolate - use the segment's start z value\n    }\n  }\n\n  // Find nearest index in the original route for a given distance\n  private getNearestIndexForDistance(distance: number): number {\n    if (distance <= 0) return 0\n    if (distance >= this.totalPathLength)\n      return this.inputRoute.route.length - 1\n\n    // Find the segment that contains this distance\n    const segmentIndex = this.pathSegments.findIndex(\n      (seg) => distance >= seg.startDistance && distance <= seg.endDistance,\n    )\n\n    if (segmentIndex === -1) return 0\n\n    // If closer to the end of the segment, return the next index\n    const segment = this.pathSegments[segmentIndex]\n    const midDistance = (segment.startDistance + segment.endDistance) / 2\n\n    return distance > midDistance ? segmentIndex + 1 : segmentIndex\n  }\n\n  // Check if a path segment is valid\n  isValidPathSegment(start: Point, end: Point): boolean {\n    // Check if the segment intersects with any obstacle\n    for (const obstacle of this.filteredObstacles) {\n      if (!obstacle.zLayers?.includes(start.z)) {\n        continue\n      }\n\n      const distToObstacle = segmentToBoxMinDistance(start, end, obstacle)\n\n      // Check if the line might intersect with this obstacle's borders\n      if (distToObstacle < this.OBSTACLE_MARGIN + this.TRACE_THICKNESS / 2) {\n        return false\n      }\n    }\n\n    // Check if the segment intersects with any other route\n    const segmentsThatCouldIntersect =\n      this.segmentTree.getSegmentsThatCouldIntersect(start, end)\n    for (const [otherSegA, otherSegB, segId] of segmentsThatCouldIntersect) {\n      // Only check intersection if we're on the same layer\n      if (otherSegA.z === start.z && otherSegB.z === start.z) {\n        const distBetweenSegments = minimumDistanceBetweenSegments(\n          { x: start.x, y: start.y },\n          { x: end.x, y: end.y },\n          { x: otherSegA.x, y: otherSegA.y },\n          { x: otherSegB.x, y: otherSegB.y },\n        )\n        if (distBetweenSegments < this.OBSTACLE_MARGIN + this.TRACE_THICKNESS) {\n          return false\n        }\n      }\n    }\n\n    for (const via of this.filteredVias) {\n      if (\n        pointToSegmentDistance(via, start, end) <\n        this.OBSTACLE_MARGIN + via.diameter / 2 + this.TRACE_THICKNESS / 2\n      ) {\n        return false\n      }\n    }\n\n    return true\n  }\n\n  // Check if a path with multiple points is valid\n  isValidPath(pointsInRoute: Point[]): boolean {\n    if (pointsInRoute.length < 2) return true\n\n    // Check for layer changes - we don't allow simplifying across layer changes\n    for (let i = 0; i < pointsInRoute.length - 1; i++) {\n      if (pointsInRoute[i].z !== pointsInRoute[i + 1].z) {\n        return false\n      }\n    }\n\n    // Check each segment of the path\n    for (let i = 0; i < pointsInRoute.length - 1; i++) {\n      if (!this.isValidPathSegment(pointsInRoute[i], pointsInRoute[i + 1])) {\n        return false\n      }\n    }\n\n    return true\n  }\n\n  // Find a valid 45-degree path between two points\n  private find45DegreePath(start: Point, end: Point): Point[] | null {\n    // Skip if points are the same\n    if (this.arePointsEqual(start, end)) {\n      return [start]\n    }\n\n    // Skip 45-degree check if we're on different layers\n    if (start.z !== end.z) {\n      return null\n    }\n\n    // Calculate potential 45-degree paths\n    const possiblePaths = calculate45DegreePaths(\n      { x: start.x, y: start.y },\n      { x: end.x, y: end.y },\n    )\n\n    // Check each path for validity\n    for (const path of possiblePaths) {\n      // Convert the 2D points to 3D points with the correct z value\n      const fullPath = path.map((p) => ({ x: p.x, y: p.y, z: start.z }))\n\n      // Check if this path is valid\n      if (this.isValidPath(fullPath)) {\n        return fullPath\n      }\n    }\n\n    // No valid 45-degree path found\n    return null\n  }\n\n  // Add a path to the result, skipping the first point if it's already added\n  private addPathToResult(path: Point[]) {\n    if (path.length === 0) return\n\n    for (let i = 0; i < path.length; i++) {\n      // Skip the first point if it's already added\n      if (\n        i === 0 &&\n        this.newRoute.length > 0 &&\n        this.arePointsEqual(this.newRoute[this.newRoute.length - 1], path[i])\n      ) {\n        continue\n      }\n      this.newRoute.push(path[i])\n    }\n    this.currentStepSize = this.maxStepSize\n  }\n\n  moveHead(distance: number) {\n    this.lastHeadMoveDistance = distance\n    this.headDistanceAlongPath = Math.min(\n      this.headDistanceAlongPath + distance,\n      this.totalPathLength,\n    )\n  }\n\n  stepBackAndReduceStepSize() {\n    this.headDistanceAlongPath = Math.max(\n      this.tailDistanceAlongPath,\n      this.headDistanceAlongPath - this.lastHeadMoveDistance,\n    )\n    this.currentStepSize = Math.max(\n      this.minStepSize,\n      this.currentStepSize * this.STEP_SIZE_REDUCTION_FACTOR,\n    )\n  }\n\n  _step() {\n    const tailHasReachedEnd = this.tailDistanceAlongPath >= this.totalPathLength\n    const headHasReachedEnd = this.headDistanceAlongPath >= this.totalPathLength\n\n    if (tailHasReachedEnd) {\n      // Make sure to add the last point if needed\n      const lastPoint = this.inputRoute.route[this.inputRoute.route.length - 1]\n      if (\n        this.newRoute.length === 0 ||\n        !this.arePointsEqual(this.newRoute[this.newRoute.length - 1], lastPoint)\n      ) {\n        // TODO find path from tail to end w/ 45 degree paths\n        this.newRoute.push(lastPoint)\n      }\n      this.solved = true\n      return\n    }\n\n    if (headHasReachedEnd) {\n      const tailPoint = this.getPointAtDistance(this.tailDistanceAlongPath)\n      const endPoint = this.inputRoute.route[this.inputRoute.route.length - 1]\n\n      // Try to find a valid 45-degree path\n      const path45 = this.find45DegreePath(tailPoint, endPoint)\n\n      if (path45) {\n        // Add the path to the result\n        this.addPathToResult(path45)\n        this.solved = true\n        return\n      } else {\n        // No valid 45-degree path to the end,\n        // add the current path if any and continue with normal advance\n        if (this.lastValidPath) {\n          this.addPathToResult(this.lastValidPath)\n          this.lastValidPath = null\n          this.tailDistanceAlongPath = this.lastValidPathHeadDistance\n        } else {\n          this.newRoute.push(endPoint)\n          this.solved = true\n        }\n      }\n    }\n\n    // Increment head distance but don't go past the end of the path\n    this.moveHead(this.currentStepSize)\n\n    // Get the points between tail and head distances\n    const tailPoint = this.getPointAtDistance(this.tailDistanceAlongPath)\n    const headPoint = this.getPointAtDistance(this.headDistanceAlongPath)\n\n    // Check for layer changes between tail and head\n    const tailIndex = this.getNearestIndexForDistance(\n      this.tailDistanceAlongPath,\n    )\n    const headIndex = this.getNearestIndexForDistance(\n      this.headDistanceAlongPath,\n    )\n\n    // If there's a potential layer change in this segment\n    let layerChangeBtwHeadAndTail = false\n    let layerChangeAtDistance = -1\n\n    for (let i = tailIndex; i < headIndex; i++) {\n      if (\n        i + 1 < this.inputRoute.route.length &&\n        this.inputRoute.route[i].z !== this.inputRoute.route[i + 1].z\n      ) {\n        layerChangeBtwHeadAndTail = true\n        // Find the segment with the layer change\n        const changeSegmentIndex = i\n        layerChangeAtDistance =\n          this.pathSegments[changeSegmentIndex].startDistance\n        break\n      }\n    }\n\n    if (\n      layerChangeBtwHeadAndTail &&\n      this.lastHeadMoveDistance > this.minStepSize\n    ) {\n      this.stepBackAndReduceStepSize()\n      return\n    }\n\n    // If there's a layer change, handle it\n    // Inside the _step method, within the layer change handling block:\n    if (layerChangeBtwHeadAndTail && layerChangeAtDistance > 0) {\n      // Get the point *after* the layer change from the original route.\n      // This point's XY coordinates define the via location.\n      const indexAfterLayerChange =\n        this.getNearestIndexForDistance(layerChangeAtDistance) + 1\n      const pointAfterChange = this.inputRoute.route[indexAfterLayerChange]\n      const viaLocation = { x: pointAfterChange.x, y: pointAfterChange.y }\n\n      // 1. Add the last valid path found *before* the layer change.\n      if (this.lastValidPath) {\n        this.addPathToResult(this.lastValidPath)\n        this.lastValidPath = null // Clear it after adding\n      }\n\n      // 2. Ensure the route connects *exactly* to the via location on the *previous* layer.\n      const lastPointInNewRoute = this.newRoute[this.newRoute.length - 1]\n      if (\n        lastPointInNewRoute.x !== viaLocation.x ||\n        lastPointInNewRoute.y !== viaLocation.y\n      ) {\n        // Add a point explicitly connecting to the via XY on the layer we are *leaving*.\n        this.newRoute.push({\n          x: viaLocation.x,\n          y: viaLocation.y,\n          z: lastPointInNewRoute.z, // Use the Z of the layer we are leaving\n        })\n      }\n      // If the last point was already at the via location, its Z is correct, so we don't need an else.\n\n      // 3. Add the via itself.\n      this.newVias.push(viaLocation)\n\n      // 4. Add the point *after* the layer change, starting the segment on the *new* layer.\n      // Ensure this point also uses the precise via location and the *new* Z coordinate.\n      this.newRoute.push({\n        x: viaLocation.x,\n        y: viaLocation.y,\n        z: pointAfterChange.z, // Use the Z of the layer we are entering\n      })\n\n      // 5. Reset state for the next segment.\n      this.currentStepSize = this.maxStepSize\n\n      // Update tail to the start of the segment *after* the layer change point\n      const segmentIndexAfterChange = this.pathSegments.findIndex(\n        (seg) => seg.start === pointAfterChange,\n      )\n\n      if (segmentIndexAfterChange !== -1) {\n        this.tailDistanceAlongPath =\n          this.pathSegments[segmentIndexAfterChange].startDistance\n        this.headDistanceAlongPath = this.tailDistanceAlongPath // Reset head to tail\n        this.lastValidPath = null // Ensure lastValidPath is clear\n        this.lastValidPathHeadDistance = this.tailDistanceAlongPath\n      } else if (indexAfterLayerChange < this.inputRoute.route.length) {\n        // Fallback if the exact segment wasn't found but index is valid\n        // This might happen due to floating point comparisons if getPointAtDistance was used previously\n        console.warn(\n          \"Fallback used for tailDistanceAlongPath after layer change\",\n        )\n        const segment = this.pathSegments.find(\n          (seg) => seg.start === this.inputRoute.route[indexAfterLayerChange],\n        )\n        if (segment) {\n          this.tailDistanceAlongPath = segment.startDistance\n          this.headDistanceAlongPath = this.tailDistanceAlongPath\n          this.lastValidPath = null\n          this.lastValidPathHeadDistance = this.tailDistanceAlongPath\n        } else {\n          console.error(\n            \"Could not find segment start after layer change, path might be incomplete.\",\n          )\n          this.solved = true // Prevent infinite loop\n        }\n      } else {\n        // Layer change occurred at the very last point/segment.\n        console.warn(\"Layer change occurred at the end of the path.\")\n        // The last point on the new layer is already added. We are done.\n        this.solved = true\n      }\n\n      return // End the step after handling the layer change\n    }\n\n    // Try to find a valid 45-degree path from tail to head\n    const path45 = this.find45DegreePath(tailPoint, headPoint)\n\n    if (!path45 && this.lastHeadMoveDistance > this.minStepSize) {\n      this.stepBackAndReduceStepSize()\n      return\n    }\n\n    if (!path45 && !this.lastValidPath) {\n      const oldTailPoint = this.getPointAtDistance(this.tailDistanceAlongPath)\n\n      // Move tail and head forward by stepSize\n      this.tailDistanceAlongPath += this.minStepSize\n      this.moveHead(this.minStepSize)\n\n      const newTailIndex = this.getNearestIndexForDistance(\n        this.tailDistanceAlongPath,\n      )\n      const newTailPoint = this.inputRoute.route[newTailIndex]\n      const lastRoutePoint =\n        this.inputRoute.route[this.inputRoute.route.length - 1]\n\n      // Add the segment from old tail to new tail\n      if (\n        !this.arePointsEqual(oldTailPoint, newTailPoint) &&\n        !this.arePointsEqual(newTailPoint, lastRoutePoint)\n      ) {\n        this.newRoute.push(newTailPoint)\n      }\n\n      return\n    }\n\n    if (path45) {\n      // Valid 45-degree path found, store it and continue expanding\n      this.lastValidPath = path45\n      this.lastValidPathHeadDistance = this.headDistanceAlongPath\n      return\n    }\n\n    // No valid path found, use the last valid path and reset\n    if (this.lastValidPath) {\n      this.addPathToResult(this.lastValidPath)\n      this.lastValidPath = null\n      this.tailDistanceAlongPath = this.lastValidPathHeadDistance\n      this.moveHead(this.minStepSize)\n    }\n  }\n\n  visualize(): GraphicsObject {\n    const graphics = this.getVisualsForNewRouteAndObstacles()\n\n    // Highlight current head and tail positions\n    const tailPoint = this.getPointAtDistance(this.tailDistanceAlongPath)\n    const headPoint = this.getPointAtDistance(this.headDistanceAlongPath)\n\n    graphics.points.push({\n      x: tailPoint.x,\n      y: tailPoint.y,\n      color: \"yellow\",\n      label: [\"Tail\", `z: ${tailPoint.z}`].join(\"\\n\"),\n    })\n\n    graphics.points.push({\n      x: headPoint.x,\n      y: headPoint.y,\n      color: \"orange\",\n      label: [\"Head\", `z: ${headPoint.z}`].join(\"\\n\"),\n    })\n\n    const tentativeHead = this.getPointAtDistance(\n      this.headDistanceAlongPath + this.currentStepSize,\n    )\n    graphics.points.push({\n      x: tentativeHead.x,\n      y: tentativeHead.y,\n      color: \"red\",\n      label: [\"Tentative Head\", `z: ${tentativeHead.z}`].join(\"\\n\"),\n    })\n\n    // Add visualization of the path segments\n    let distance = 0\n    while (distance < this.totalPathLength) {\n      const point = this.getPointAtDistance(distance)\n      graphics.circles.push({\n        center: {\n          x: point.x,\n          y: point.y,\n        },\n        radius: 0.05,\n        fill: \"rgba(100, 100, 100, 0.5)\",\n      })\n      distance += this.totalPathLength / 20 // Show 20 markers along the path\n    }\n\n    // Visualize the current prospective 45-degree path from tail to head\n    if (this.lastValidPath && this.lastValidPath.length > 1) {\n      // Draw the path in a bright cyan color to make it stand out\n      for (let i = 0; i < this.lastValidPath.length - 1; i++) {\n        graphics.lines.push({\n          points: [\n            { x: this.lastValidPath[i].x, y: this.lastValidPath[i].y },\n            {\n              x: this.lastValidPath[i + 1].x,\n              y: this.lastValidPath[i + 1].y,\n            },\n          ],\n          strokeColor: \"rgba(0, 255, 255, 0.9)\", // Bright cyan\n          strokeDash: \"3, 3\", // Dashed line to indicate it's a prospective path\n        })\n      }\n    }\n\n    return graphics\n  }\n}\n","import { HighDensityIntraNodeRoute } from \"lib/types/high-density-types\"\nimport { BaseSolver } from \"../BaseSolver\"\nimport { Obstacle } from \"lib/types\"\nimport { GraphicsObject } from \"graphics-debug\"\nimport { combineVisualizations } from \"lib/utils/combineVisualizations\"\nimport { SingleSimplifiedPathSolver5 } from \"./SingleSimplifiedPathSolver5_Deg45\"\nimport { SingleSimplifiedPathSolver } from \"./SingleSimplifiedPathSolver\"\nimport { ConnectivityMap } from \"circuit-json-to-connectivity-map\"\n\nexport class MultiSimplifiedPathSolver extends BaseSolver {\n  simplifiedHdRoutes: HighDensityIntraNodeRoute[]\n\n  currentUnsimplifiedHdRouteIndex = 0\n\n  activeSubSolver: SingleSimplifiedPathSolver | null = null\n\n  unsimplifiedHdRoutes: HighDensityIntraNodeRoute[]\n  obstacles: Obstacle[]\n  connMap: ConnectivityMap\n  colorMap: Record<string, string>\n\n  constructor(params: {\n    unsimplifiedHdRoutes: HighDensityIntraNodeRoute[]\n    obstacles: Obstacle[]\n    connMap?: ConnectivityMap\n    colorMap?: Record<string, string>\n  }) {\n    super()\n    this.MAX_ITERATIONS = 100e6\n\n    this.unsimplifiedHdRoutes = params.unsimplifiedHdRoutes\n    this.obstacles = params.obstacles\n    this.connMap = params.connMap || new ConnectivityMap({})\n    this.colorMap = params.colorMap || {}\n\n    this.simplifiedHdRoutes = []\n  }\n\n  _step() {\n    const hdRoute =\n      this.unsimplifiedHdRoutes[this.currentUnsimplifiedHdRouteIndex]\n    if (!this.activeSubSolver) {\n      if (!hdRoute) {\n        this.solved = true\n        return\n      }\n\n      this.activeSubSolver = new SingleSimplifiedPathSolver5({\n        inputRoute: hdRoute,\n        otherHdRoutes: this.unsimplifiedHdRoutes\n          .slice(this.currentUnsimplifiedHdRouteIndex + 1)\n          .concat(this.simplifiedHdRoutes),\n        obstacles: this.obstacles,\n        connMap: this.connMap,\n        colorMap: this.colorMap,\n      })\n      this.currentUnsimplifiedHdRouteIndex++\n      return\n    }\n\n    this.activeSubSolver.step()\n    if (this.activeSubSolver.solved) {\n      this.simplifiedHdRoutes.push(this.activeSubSolver.simplifiedRoute)\n      this.activeSubSolver = null\n    }\n  }\n\n  visualize(): GraphicsObject {\n    if (this.activeSubSolver) {\n      return this.activeSubSolver.visualize()\n    }\n\n    const graphics: Required<GraphicsObject> = {\n      lines: [],\n      points: [],\n      circles: [],\n      rects: [],\n      coordinateSystem: \"cartesian\",\n      title: \"Multi Simplified Path Solver\",\n    }\n\n    // Visualize the original unsimplified routes in red with transparency\n    for (const route of this.unsimplifiedHdRoutes) {\n      if (\n        this.simplifiedHdRoutes.some(\n          (r) => r.connectionName === route.connectionName,\n        )\n      ) {\n        continue\n      }\n\n      for (let i = 0; i < route.route.length - 1; i++) {\n        graphics.lines.push({\n          points: [\n            { x: route.route[i].x, y: route.route[i].y },\n            { x: route.route[i + 1].x, y: route.route[i + 1].y },\n          ],\n          strokeColor:\n            route.route[i].z === 1\n              ? \"rgba(0, 0, 255, 0.4)\"\n              : \"rgba(255, 0, 0, 0.4)\",\n          strokeWidth: 0.15,\n          strokeDash: route.route[i].z === 1 ? [0.5, 0.5] : undefined,\n        })\n      }\n\n      // Draw vias for unsimplified routes\n      for (const via of route.vias || []) {\n        graphics.circles.push({\n          center: via,\n          radius: route.viaDiameter / 2 || 0.3, // Default radius if viaDiameter not specified\n          fill: \"rgba(0, 0, 255, 0.4)\",\n        })\n      }\n    }\n\n    // Visualize the simplified routes with colors from colorMap or gray if not found\n    for (const route of this.simplifiedHdRoutes) {\n      const routeColor =\n        this.colorMap?.[route.connectionName] || \"rgba(128, 128, 128, 0.8)\"\n\n      // Draw the route lines\n      for (let i = 0; i < route.route.length - 1; i++) {\n        graphics.lines.push({\n          points: [\n            { x: route.route[i].x, y: route.route[i].y },\n            { x: route.route[i + 1].x, y: route.route[i + 1].y },\n          ],\n          strokeWidth: 0.15,\n          strokeColor: routeColor,\n          strokeDash: route.route[i].z === 1 ? [0.5, 0.5] : undefined,\n          step: 1,\n        })\n      }\n\n      // Visualize vias\n      for (const via of route.vias || []) {\n        graphics.circles.push({\n          center: via,\n          radius: route.viaDiameter / 2,\n          fill: \"rgba(0, 0, 255, 0.5)\",\n          step: 1,\n        })\n      }\n    }\n\n    // Visualize the original unsimplified routes in red\n    for (const route of this.unsimplifiedHdRoutes) {\n      // Draw the route lines\n      for (let i = 0; i < route.route.length - 1; i++) {\n        graphics.lines.push({\n          points: [\n            { x: route.route[i].x, y: route.route[i].y },\n            { x: route.route[i + 1].x, y: route.route[i + 1].y },\n          ],\n          strokeWidth: 0.15,\n          strokeColor: \"rgba(255, 0, 0, 0.2)\",\n          strokeDash: [0.5, 0.5],\n          step: 0,\n          layer: `z${route.route[i].z.toString()}`,\n        })\n      }\n\n      // Add small circles at each point of the original route\n      for (const point of route.vias) {\n        graphics.circles.push({\n          center: { x: point.x, y: point.y },\n          radius: route.viaDiameter / 2,\n          fill: \"rgba(255, 0, 0, 0.2)\",\n          step: 0,\n        })\n      }\n    }\n\n    // Visualize obstacles\n    for (const obstacle of this.obstacles) {\n      graphics.rects.push({\n        center: obstacle.center,\n        width: obstacle.width,\n        height: obstacle.height,\n        fill: obstacle.layers?.includes(\"top\")\n          ? \"rgba(255, 0, 0, 0.3)\"\n          : obstacle.layers?.includes(\"bottom\")\n            ? \"rgba(0, 0, 255, 0.3)\"\n            : \"rgba(128, 128, 128, 0.3)\",\n      })\n    }\n\n    // Highlight the current route being processed\n    if (\n      this.currentUnsimplifiedHdRouteIndex < this.unsimplifiedHdRoutes.length\n    ) {\n      const currentRoute =\n        this.unsimplifiedHdRoutes[this.currentUnsimplifiedHdRouteIndex]\n\n      // Add a label to the first point of the current route\n      if (currentRoute.route.length > 0) {\n        graphics.circles.push({\n          center: {\n            x: currentRoute.route[0].x,\n            y: currentRoute.route[0].y,\n          },\n          radius: 0.2,\n          fill: \"yellow\",\n          label: \"Current\",\n        })\n      }\n    }\n\n    return graphics\n  }\n}\n","import type { GraphicsObject } from \"graphics-debug\"\nimport type {\n  CapacityMeshEdge,\n  CapacityMeshNode,\n  CapacityMeshNodeId,\n} from \"../../types/capacity-mesh-types\"\nimport { BaseSolver } from \"../BaseSolver\"\nimport { distance } from \"@tscircuit/math-utils\"\nimport { areNodesBordering } from \"lib/utils/areNodesBordering\"\n\nexport class CapacityMeshEdgeSolver extends BaseSolver {\n  public edges: Array<CapacityMeshEdge>\n\n  /** Only used for visualization, dynamically instantiated if necessary */\n  nodeMap?: Map<CapacityMeshNodeId, CapacityMeshNode>\n\n  constructor(public nodes: CapacityMeshNode[]) {\n    super()\n    this.edges = []\n  }\n\n  getNextCapacityMeshEdgeId() {\n    return `ce${this.edges.length}`\n  }\n\n  _step() {\n    this.edges = []\n    for (let i = 0; i < this.nodes.length; i++) {\n      for (let j = i + 1; j < this.nodes.length; j++) {\n        const strawNodesWithSameParent =\n          this.nodes[i]._strawNode &&\n          this.nodes[j]._strawNode &&\n          this.nodes[i]._strawParentCapacityMeshNodeId ===\n            this.nodes[j]._strawParentCapacityMeshNodeId\n        if (\n          !strawNodesWithSameParent &&\n          areNodesBordering(this.nodes[i], this.nodes[j]) &&\n          this.doNodesHaveSharedLayer(this.nodes[i], this.nodes[j])\n        ) {\n          this.edges.push({\n            capacityMeshEdgeId: this.getNextCapacityMeshEdgeId(),\n            nodeIds: [\n              this.nodes[i].capacityMeshNodeId,\n              this.nodes[j].capacityMeshNodeId,\n            ],\n          })\n        }\n      }\n    }\n\n    this.handleTargetNodes()\n\n    this.solved = true\n  }\n\n  handleTargetNodes() {\n    // If a target node is not connected to any other node, then it is \"inside\n    // an obstacle\" (this is the case almost 100% of the time when we place\n    // targets inside of PCB pads)\n    // To fix this we connect it to the nearest nodes without obstacles\n    const targetNodes = this.nodes.filter((node) => node._containsTarget)\n    for (const targetNode of targetNodes) {\n      const hasEdge = this.edges.some((edge) =>\n        edge.nodeIds.includes(targetNode.capacityMeshNodeId),\n      )\n      if (hasEdge) continue\n\n      let nearestNode: CapacityMeshNode | null = null\n      let nearestDistance = Infinity\n      for (const node of this.nodes) {\n        if (node._containsObstacle) continue\n        if (node._containsTarget) continue\n        const dist = distance(targetNode.center, node.center)\n        if (dist < nearestDistance) {\n          nearestDistance = dist\n          nearestNode = node\n        }\n      }\n      if (nearestNode) {\n        this.edges.push({\n          capacityMeshEdgeId: this.getNextCapacityMeshEdgeId(),\n          nodeIds: [\n            targetNode.capacityMeshNodeId,\n            nearestNode.capacityMeshNodeId,\n          ],\n        })\n      }\n    }\n  }\n\n  doNodesHaveSharedLayer(\n    node1: CapacityMeshNode,\n    node2: CapacityMeshNode,\n  ): boolean {\n    return node1.availableZ.some((z) => node2.availableZ.includes(z))\n  }\n\n  visualize(): GraphicsObject {\n    const edgeCount = new Map<string, number>()\n\n    for (const edge of this.edges) {\n      for (const nodeId of edge.nodeIds) {\n        edgeCount.set(nodeId, 1 + (edgeCount.get(nodeId) ?? 0))\n      }\n    }\n\n    const graphics: GraphicsObject = {\n      lines: [],\n      points: [],\n      rects: this.nodes.map((node) => {\n        const lowestZ = Math.min(...node.availableZ)\n        return {\n          width: Math.max(node.width - 2, node.width * 0.8),\n          height: Math.max(node.height - 2, node.height * 0.8),\n          center: {\n            x: node.center.x + lowestZ * node.width * 0.05,\n            y: node.center.y - lowestZ * node.width * 0.05,\n          },\n          fill: node._containsObstacle\n            ? \"rgba(255,0,0,0.1)\"\n            : ({\n                \"0,1\": \"rgba(0,0,0,0.1)\",\n                \"0\": \"rgba(0,200,200, 0.1)\",\n                \"1\": \"rgba(0,0,200, 0.1)\",\n              }[node.availableZ.join(\",\")] ?? \"rgba(0,200,200,0.1)\"),\n          label: [\n            node.capacityMeshNodeId,\n            `availableZ: ${node.availableZ.join(\",\")}`,\n            `target? ${node._containsTarget ?? false}`,\n            `obs? ${node._containsObstacle ?? false}`,\n            `conn: ${edgeCount.get(node.capacityMeshNodeId) ?? 0}`,\n          ].join(\"\\n\"),\n          layer: `z${node.availableZ.join(\",\")}`,\n        }\n      }),\n      circles: [],\n    }\n    if (!this.nodeMap) {\n      this.nodeMap = new Map<CapacityMeshNodeId, CapacityMeshNode>()\n      for (const node of this.nodes) {\n        this.nodeMap.set(node.capacityMeshNodeId, node)\n      }\n    }\n\n    for (const edge of this.edges) {\n      const node1 = this.nodeMap.get(edge.nodeIds[0])\n      const node2 = this.nodeMap.get(edge.nodeIds[1])\n      if (node1?.center && node2?.center) {\n        const lowestZ1 = Math.min(...node1.availableZ)\n        const lowestZ2 = Math.min(...node2.availableZ)\n        const nodeCenter1Adj = {\n          x: node1.center.x + lowestZ1 * node1.width * 0.05,\n          y: node1.center.y - lowestZ1 * node1.width * 0.05,\n        }\n        const nodeCenter2Adj = {\n          x: node2.center.x + lowestZ2 * node2.width * 0.05,\n          y: node2.center.y - lowestZ2 * node2.width * 0.05,\n        }\n\n        const availableZ = Array.from(\n          new Set([...node1.availableZ, ...node2.availableZ]),\n        ).sort()\n\n        graphics.lines!.push({\n          layer: `z${availableZ.join(\",\")}`,\n          points: [nodeCenter1Adj, nodeCenter2Adj],\n          strokeDash:\n            node1.availableZ.join(\",\") === node2.availableZ.join(\",\")\n              ? undefined\n              : \"10 5\",\n        })\n      }\n    }\n    return graphics\n  }\n}\n","import type { GraphicsObject } from \"graphics-debug\"\nimport type {\n  CapacityMeshEdge,\n  CapacityMeshNode,\n} from \"../../types/capacity-mesh-types\"\nimport { BaseSolver } from \"../BaseSolver\"\nimport { distance } from \"@tscircuit/math-utils\"\nimport { areNodesBordering } from \"lib/utils/areNodesBordering\"\nimport { CapacityMeshEdgeSolver } from \"./CapacityMeshEdgeSolver\"\nimport { CapacityNodeTree } from \"lib/data-structures/CapacityNodeTree\"\n\nexport class CapacityMeshEdgeSolver2_NodeTreeOptimization extends CapacityMeshEdgeSolver {\n  private nodeTree: CapacityNodeTree\n  private currentNodeIndex: number\n  private edgeSet: Set<string>\n\n  constructor(public nodes: CapacityMeshNode[]) {\n    super(nodes)\n    this.MAX_ITERATIONS = 10e6\n    this.nodeTree = new CapacityNodeTree(this.nodes)\n    this.currentNodeIndex = 0\n    this.edgeSet = new Set<string>()\n  }\n\n  _step() {\n    if (this.currentNodeIndex >= this.nodes.length) {\n      this.handleTargetNodes()\n      this.solved = true\n      return\n    }\n\n    const A = this.nodes[this.currentNodeIndex]\n    const maybeAdjNodes = this.nodeTree.getNodesInArea(\n      A.center.x,\n      A.center.y,\n      A.width * 2,\n      A.height * 2,\n    )\n\n    for (const B of maybeAdjNodes) {\n      const areBordering = areNodesBordering(A, B)\n      if (!areBordering) continue\n      const strawNodesWithSameParent =\n        A._strawNode &&\n        B._strawNode &&\n        A._strawParentCapacityMeshNodeId === B._strawParentCapacityMeshNodeId\n      if (\n        A.capacityMeshNodeId !== B.capacityMeshNodeId && // Don't connect a node to itself\n        !strawNodesWithSameParent &&\n        this.doNodesHaveSharedLayer(A, B) &&\n        !this.edgeSet.has(`${A.capacityMeshNodeId}-${B.capacityMeshNodeId}`)\n      ) {\n        this.edgeSet.add(`${A.capacityMeshNodeId}-${B.capacityMeshNodeId}`)\n        this.edgeSet.add(`${B.capacityMeshNodeId}-${A.capacityMeshNodeId}`)\n        this.edges.push({\n          capacityMeshEdgeId: this.getNextCapacityMeshEdgeId(),\n          nodeIds: [A.capacityMeshNodeId, B.capacityMeshNodeId],\n        })\n      }\n    }\n\n    this.currentNodeIndex++\n  }\n}\n","import {\n  CapacityMeshEdge,\n  CapacityMeshNode,\n  CapacityMeshNodeId,\n} from \"lib/types\"\nimport { BaseSolver } from \"../BaseSolver\"\nimport { GraphicsObject } from \"graphics-debug\"\nimport { safeTransparentize } from \"../colors\"\n\nexport class DeadEndSolver extends BaseSolver {\n  public removedNodeIds: Set<string>\n\n  private targetNodeIds: Set<string>\n  private leaves: string[]\n  private leavesIndex: number\n  private adjacencyList: Map<string, Set<string>>\n\n  /** Only used for visualization, dynamically instantiated if necessary */\n  nodeMap?: Map<CapacityMeshNodeId, CapacityMeshNode>\n\n  // Store the nodes and edges just for visualization purposes\n  private nodes: CapacityMeshNode[]\n  private edges: CapacityMeshEdge[]\n\n  constructor({\n    nodes,\n    edges,\n  }: {\n    nodes: CapacityMeshNode[]\n    edges: CapacityMeshEdge[]\n  }) {\n    super()\n\n    this.MAX_ITERATIONS = nodes.length\n\n    this.nodes = nodes\n    this.edges = edges\n\n    this.removedNodeIds = new Set()\n\n    this.targetNodeIds = new Set(\n      nodes.filter((n) => n._containsTarget).map((n) => n.capacityMeshNodeId),\n    )\n\n    this.adjacencyList = new Map(\n      nodes.map(({ capacityMeshNodeId }) => [capacityMeshNodeId, new Set()]),\n    )\n\n    // Build an adjacency list based on the edges\n    for (const {\n      nodeIds: [u, v],\n    } of edges) {\n      this.adjacencyList.get(u)!.add(v)\n      this.adjacencyList.get(v)!.add(u)\n    }\n\n    // Determine all nodes that have only a single link (leaves of a tree) and\n    //  are not a target.\n    this.leavesIndex = 0\n    this.leaves = [...this.adjacencyList.entries()]\n      .filter(([_, neighbours]) => neighbours.size === 1)\n      .filter(([nodeId, _]) => !this.targetNodeIds.has(nodeId))\n      .map(([nodeId, _]) => nodeId)\n  }\n\n  _step() {\n    if (this.leavesIndex === this.leaves.length) {\n      this.solved = true\n      return\n    }\n\n    const leaf = this.leaves[this.leavesIndex]\n\n    // Get the single neighbor of the leaf node\n    const [neighbor] = this.adjacencyList.get(leaf)!\n\n    const neighborsOfLeafNeighbor = this.adjacencyList.get(neighbor)!\n\n    // Remove the leaf from the adjacency list of the neighbor of the leaf.\n    // This is, by definition, the only entry in the adjacency map that links\n    // to the leaf. Hence, there is no other reference to the leaf and it will\n    // never be visited again.\n    neighborsOfLeafNeighbor.delete(leaf)\n\n    // Add the leaf to the list of removed ids\n    this.removedNodeIds.add(leaf)\n\n    // Check if the neighbour of the leaf has now become a leaf such that it can\n    // be removed in a future iteration.\n    if (\n      neighborsOfLeafNeighbor.size === 1 &&\n      !this.targetNodeIds.has(neighbor)\n    ) {\n      this.leaves.push(neighbor)\n    }\n\n    this.leavesIndex += 1\n\n    if (this.leavesIndex === this.leaves.length) {\n      this.solved = true\n    }\n  }\n\n  visualize(): GraphicsObject {\n    if (!this.nodeMap) {\n      this.nodeMap = new Map<CapacityMeshNodeId, CapacityMeshNode>()\n      for (const node of this.nodes) {\n        this.nodeMap.set(node.capacityMeshNodeId, node)\n      }\n    }\n\n    const edgeCount = new Map<string, number>()\n\n    for (const edge of this.edges) {\n      for (const nodeId of edge.nodeIds) {\n        edgeCount.set(nodeId, 1 + (edgeCount.get(nodeId) ?? 0))\n      }\n    }\n\n    const graphics: GraphicsObject = {\n      lines: [],\n      points: [],\n      rects: this.nodes.map((node) => {\n        const lowestZ = Math.min(...node.availableZ)\n        return {\n          width: Math.max(node.width - 2, node.width * 0.8),\n          height: Math.max(node.height - 2, node.height * 0.8),\n          center: {\n            x: node.center.x + lowestZ * node.width * 0.05,\n            y: node.center.y - lowestZ * node.width * 0.05,\n          },\n          fill: node._containsObstacle\n            ? \"rgba(255,0,0,0.1)\"\n            : ({\n                \"0,1\": \"rgba(0,0,0,0.1)\",\n                \"0\": \"rgba(0,200,200, 0.1)\",\n                \"1\": \"rgba(0,0,200, 0.1)\",\n              }[node.availableZ.join(\",\")] ?? \"rgba(0,200,200,0.1)\"),\n          label: [\n            node.capacityMeshNodeId,\n            `availableZ: ${node.availableZ.join(\",\")}`,\n            `target? ${node._containsTarget ?? false}`,\n            `obs? ${node._containsObstacle ?? false}`,\n            `conn: ${edgeCount.get(node.capacityMeshNodeId) ?? 0}`,\n          ].join(\"\\n\"),\n          layer: `z${node.availableZ.join(\",\")}`,\n        }\n      }),\n      circles: [],\n    }\n\n    for (const edge of this.edges) {\n      const node1 = this.nodeMap.get(edge.nodeIds[0])\n      const node2 = this.nodeMap.get(edge.nodeIds[1])\n      if (node1?.center && node2?.center) {\n        const lowestZ1 = Math.min(...node1.availableZ)\n        const lowestZ2 = Math.min(...node2.availableZ)\n        const nodeCenter1Adj = {\n          x: node1.center.x + lowestZ1 * node1.width * 0.05,\n          y: node1.center.y - lowestZ1 * node1.width * 0.05,\n        }\n        const nodeCenter2Adj = {\n          x: node2.center.x + lowestZ2 * node2.width * 0.05,\n          y: node2.center.y - lowestZ2 * node2.width * 0.05,\n        }\n\n        const availableZ = Array.from(\n          new Set([...node1.availableZ, ...node2.availableZ]),\n        ).sort()\n\n        graphics.lines!.push({\n          layer: `z${availableZ.join(\",\")}`,\n          points: [nodeCenter1Adj, nodeCenter2Adj],\n          strokeDash:\n            node1.availableZ.join(\",\") === node2.availableZ.join(\",\")\n              ? undefined\n              : \"10 5\",\n          strokeColor: edge.nodeIds.some((nodeId) =>\n            this.removedNodeIds.has(nodeId),\n          )\n            ? safeTransparentize(\"black\", 0.9)\n            : undefined,\n        })\n      }\n    }\n    return graphics\n  }\n}\n","import { doSegmentsIntersect } from \"@tscircuit/math-utils\" // Assuming this is available and correct\n\n// --- Interfaces and Types (Unchanged) ---\n\ninterface Point {\n  x: number\n  y: number\n  z: number // Kept for type compatibility, but calculations focus on X/Y\n}\n\ntype Point2D = { x: number; y: number } // Use Point2D for clarity in calculations\n\ntype Segment = [Point, Point]\n\nexport type HighDensityIntraNodeRoute = {\n  connectionName: string // Assuming this is unique per route\n  traceThickness: number\n  viaDiameter: number // Now used in conflict calculation\n  route: Array<{ x: number; y: number; z: number }>\n  vias: Array<{ x: number; y: number }> // Will be indexed\n}\nexport type HighDensityRoute = HighDensityIntraNodeRoute\n\n// --- Utility Functions (Unchanged) ---\n\nconst getSegmentBounds = (segment: Segment) => {\n  return {\n    minX: Math.min(segment[0].x, segment[1].x),\n    maxX: Math.max(segment[0].x, segment[1].x),\n    minY: Math.min(segment[0].y, segment[1].y),\n    maxY: Math.max(segment[0].y, segment[1].y),\n  }\n}\n\nexport type BucketCoordinate = `${number}x${number}`\n\n// --- Geometry Helper Functions (Unchanged, but ensure Point2D compatibility) ---\n\nfunction computeDistSq(p1: Point2D, p2: Point2D): number {\n  const dx = p1.x - p2.x\n  const dy = p1.y - p2.y\n  return dx * dx + dy * dy\n}\n\nfunction pointToSegmentDistanceSq(p: Point2D, a: Point2D, b: Point2D): number {\n  const l2 = computeDistSq(a, b)\n  if (l2 === 0) return computeDistSq(p, a) // Segment is a point\n  let t = ((p.x - a.x) * (b.x - a.x) + (p.y - a.y) * (b.y - a.y)) / l2\n  t = Math.max(0, Math.min(1, t))\n  const projection = {\n    x: a.x + t * (b.x - a.x),\n    y: a.y + t * (b.y - a.y),\n  }\n  return computeDistSq(p, projection)\n}\n\nfunction segmentToSegmentDistanceSq(\n  a: Point, // Keep Point for compatibility if doSegmentsIntersect needs z\n  b: Point,\n  c: Point,\n  d: Point,\n): number {\n  // Use the provided (or assumed imported) intersection function\n  if (doSegmentsIntersect(a, b, c, d)) {\n    return 0\n  }\n  // Convert to Point2D for distance calculations\n  const pA = { x: a.x, y: a.y }\n  const pB = { x: b.x, y: b.y }\n  const pC = { x: c.x, y: c.y }\n  const pD = { x: d.x, y: d.y }\n\n  return Math.min(\n    pointToSegmentDistanceSq(pA, pC, pD),\n    pointToSegmentDistanceSq(pB, pC, pD),\n    pointToSegmentDistanceSq(pC, pA, pB),\n    pointToSegmentDistanceSq(pD, pA, pB),\n  )\n}\n\n// --- New Interfaces for Bucket Contents ---\ninterface StoredSegment {\n  segmentId: string\n  segment: [Point, Point] // Keep original Point type if needed by other parts\n  parentRoute: HighDensityRoute\n}\n\ninterface StoredVia {\n  viaId: string // Unique identifier for the via within its route\n  x: number\n  y: number\n  parentRoute: HighDensityRoute\n}\n\n// --- Updated Spatial Index Class ---\n\nexport class HighDensityRouteSpatialIndex {\n  private segmentBuckets: Map<BucketCoordinate, StoredSegment[]>\n  private viaBuckets: Map<BucketCoordinate, StoredVia[]> // New: Store vias\n  private routes: Map<string, HighDensityRoute>\n  private CELL_SIZE: number\n\n  constructor(routes: HighDensityRoute[], cellSize: number = 1.0) {\n    // console.time(\"HighDensityRouteSpatialIndex Constructor\");\n    this.segmentBuckets = new Map()\n    this.viaBuckets = new Map() // Initialize via buckets\n    this.routes = new Map()\n    this.CELL_SIZE = cellSize\n    const epsilon = 1e-9 // For segment boundary checks\n\n    for (const route of routes) {\n      if (!route || !route.connectionName) {\n        console.warn(\"Skipping route with missing data:\", route)\n        continue\n      }\n      if (this.routes.has(route.connectionName)) {\n        console.warn(\n          `Skipping duplicate route connectionName: ${route.connectionName}`,\n        )\n        continue\n      }\n      this.routes.set(route.connectionName, route)\n\n      // --- Index Segments ---\n      if (route.route && route.route.length >= 2) {\n        for (let i = 0; i < route.route.length - 1; i++) {\n          const p1 = route.route[i]\n          const p2 = route.route[i + 1]\n          // Skip zero-length segments\n          if (p1.x === p2.x && p1.y === p2.y) continue\n\n          const segment: Segment = [p1, p2]\n          const bounds = getSegmentBounds(segment)\n\n          const segmentInfo: StoredSegment = {\n            segmentId: `${route.connectionName}-seg-${i}`,\n            segment: segment,\n            parentRoute: route,\n          }\n\n          const minIndexX = Math.floor(bounds.minX / this.CELL_SIZE)\n          const maxIndexX = Math.floor((bounds.maxX + epsilon) / this.CELL_SIZE)\n          const minIndexY = Math.floor(bounds.minY / this.CELL_SIZE)\n          const maxIndexY = Math.floor((bounds.maxY + epsilon) / this.CELL_SIZE)\n\n          for (let ix = minIndexX; ix <= maxIndexX; ix++) {\n            for (let iy = minIndexY; iy <= maxIndexY; iy++) {\n              const bucketKey = `${ix}x${iy}` as BucketCoordinate\n              let bucketList = this.segmentBuckets.get(bucketKey)\n              if (!bucketList) {\n                bucketList = []\n                this.segmentBuckets.set(bucketKey, bucketList)\n              }\n              bucketList.push(segmentInfo)\n            }\n          }\n        }\n      }\n\n      // --- Index Vias ---\n      if (route.vias && route.vias.length > 0) {\n        for (let i = 0; i < route.vias.length; i++) {\n          const via = route.vias[i]\n          if (via === undefined || via === null) continue // Basic check\n\n          const storedVia: StoredVia = {\n            viaId: `${route.connectionName}-via-${i}`,\n            x: via.x,\n            y: via.y,\n            parentRoute: route,\n          }\n\n          // Vias belong to a single bucket\n          const ix = Math.floor(via.x / this.CELL_SIZE)\n          const iy = Math.floor(via.y / this.CELL_SIZE)\n          const bucketKey = `${ix}x${iy}` as BucketCoordinate\n\n          let bucketList = this.viaBuckets.get(bucketKey)\n          if (!bucketList) {\n            bucketList = []\n            this.viaBuckets.set(bucketKey, bucketList)\n          }\n          bucketList.push(storedVia)\n        }\n      }\n    }\n    // console.timeEnd(\"HighDensityRouteSpatialIndex Constructor\");\n  }\n\n  /**\n   * Finds routes that potentially conflict with a given line segment within a margin.\n   * Checks both segments and vias.\n   * @param segmentStart Start point of the query segment.\n   * @param segmentEnd End point of the query segment.\n   * @param margin The minimum required clearance distance from the query segment's centerline.\n   * @returns An array of conflicting routes and their minimum distance to the segment.\n   */\n  getConflictingRoutesForSegment(\n    segmentStart: Point, // Keep Point for original Z data if needed elsewhere\n    segmentEnd: Point,\n    margin: number, // Minimum required clearance\n  ): Array<{ conflictingRoute: HighDensityRoute; distance: number }> {\n    const querySegment: Segment = [segmentStart, segmentEnd]\n    const bounds = getSegmentBounds(querySegment)\n\n    // --- Define search area including margin for both segments and vias ---\n    // Need to consider the maximum possible radius (trace/2 or via/2) + margin\n    // For simplicity, just use the provided margin for bucket search.\n    // Precise checks will use item-specific sizes.\n    const searchMinX = bounds.minX - margin\n    const searchMinY = bounds.minY - margin\n    const searchMaxX = bounds.maxX + margin\n    const searchMaxY = bounds.maxY + margin\n    const epsilon = 1e-9\n\n    const minIndexX = Math.floor(searchMinX / this.CELL_SIZE)\n    const maxIndexX = Math.floor((searchMaxX + epsilon) / this.CELL_SIZE)\n    const minIndexY = Math.floor(searchMinY / this.CELL_SIZE)\n    const maxIndexY = Math.floor((searchMaxY + epsilon) / this.CELL_SIZE)\n\n    // Use a map to store the minimum squared distance found *per route*\n    const conflictingRouteData = new Map<\n      string,\n      { route: HighDensityRoute; minDistSq: number }\n    >()\n    const checkedSegments = new Set<string>() // Store segmentId\n    const checkedVias = new Set<string>() // Store viaId\n\n    const queryP1: Point2D = { x: segmentStart.x, y: segmentStart.y }\n    const queryP2: Point2D = { x: segmentEnd.x, y: segmentEnd.y }\n\n    for (let ix = minIndexX; ix <= maxIndexX; ix++) {\n      for (let iy = minIndexY; iy <= maxIndexY; iy++) {\n        const bucketKey = `${ix}x${iy}` as BucketCoordinate\n\n        // --- Check Segments in Bucket ---\n        const segmentBucketList = this.segmentBuckets.get(bucketKey)\n        if (segmentBucketList) {\n          for (const segmentInfo of segmentBucketList) {\n            if (checkedSegments.has(segmentInfo.segmentId)) continue\n            checkedSegments.add(segmentInfo.segmentId)\n\n            const route = segmentInfo.parentRoute\n            const [p1, p2] = segmentInfo.segment // Original points\n\n            // Required separation distance from query centerline to segment edge\n            const requiredSeparation = margin + route.traceThickness / 2\n            const requiredSeparationSq = requiredSeparation * requiredSeparation\n\n            // Use original points for segmentToSegmentDistanceSq if it relies on the Point type\n            const distSq = segmentToSegmentDistanceSq(\n              segmentStart,\n              segmentEnd,\n              p1,\n              p2,\n            )\n\n            if (distSq < requiredSeparationSq) {\n              // Use < for strict clearance\n              const routeName = route.connectionName\n              const existing = conflictingRouteData.get(routeName)\n              if (!existing || distSq < existing.minDistSq) {\n                conflictingRouteData.set(routeName, {\n                  route,\n                  minDistSq: distSq,\n                })\n              }\n            }\n          }\n        }\n\n        // --- Check Vias in Bucket ---\n        const viaBucketList = this.viaBuckets.get(bucketKey)\n        if (viaBucketList) {\n          for (const viaInfo of viaBucketList) {\n            if (checkedVias.has(viaInfo.viaId)) continue\n            checkedVias.add(viaInfo.viaId)\n\n            const route = viaInfo.parentRoute\n            const viaPoint: Point2D = { x: viaInfo.x, y: viaInfo.y }\n\n            // Required separation distance from query centerline to via edge\n            const requiredSeparation = margin + route.viaDiameter / 2\n            const requiredSeparationSq = requiredSeparation * requiredSeparation\n\n            // Calculate distance from via center to the query segment\n            const distSq = pointToSegmentDistanceSq(viaPoint, queryP1, queryP2)\n\n            if (distSq < requiredSeparationSq) {\n              // Use < for strict clearance\n              const routeName = route.connectionName\n              const existing = conflictingRouteData.get(routeName)\n              if (!existing || distSq < existing.minDistSq) {\n                conflictingRouteData.set(routeName, {\n                  route,\n                  minDistSq: distSq,\n                })\n              }\n            }\n          }\n        }\n      }\n    }\n\n    // --- Convert map to results ---\n    const results: Array<{\n      conflictingRoute: HighDensityRoute\n      distance: number\n    }> = []\n    for (const data of conflictingRouteData.values()) {\n      // Distance reported is centerline-to-centerline (or point)\n      results.push({\n        conflictingRoute: data.route,\n        distance: Math.sqrt(data.minDistSq),\n      })\n    }\n\n    return results\n  }\n\n  /**\n   * Finds routes that pass near a given point within a margin.\n   * Checks both segments and vias.\n   * @param point The query point {x, y}. Z is ignored.\n   * @param margin The minimum required clearance distance from the query point.\n   * @returns An array of conflicting routes and their minimum distance to the point.\n   */\n  getConflictingRoutesNearPoint(\n    point: Point2D,\n    margin: number, // Minimum required clearance\n  ): Array<{ conflictingRoute: HighDensityRoute; distance: number }> {\n    // --- Define search area ---\n    const searchMinX = point.x - margin\n    const searchMinY = point.y - margin\n    const searchMaxX = point.x + margin\n    const searchMaxY = point.y + margin\n    const epsilon = 1e-9\n\n    const minIndexX = Math.floor(searchMinX / this.CELL_SIZE)\n    const maxIndexX = Math.floor((searchMaxX + epsilon) / this.CELL_SIZE) // Epsilon might not be strictly needed for point queries but harmless\n    const minIndexY = Math.floor(searchMinY / this.CELL_SIZE)\n    const maxIndexY = Math.floor((searchMaxY + epsilon) / this.CELL_SIZE)\n\n    const conflictingRouteData = new Map<\n      string,\n      { route: HighDensityRoute; minDistSq: number }\n    >()\n    const checkedSegments = new Set<string>()\n    const checkedVias = new Set<string>()\n\n    for (let ix = minIndexX; ix <= maxIndexX; ix++) {\n      for (let iy = minIndexY; iy <= maxIndexY; iy++) {\n        const bucketKey = `${ix}x${iy}` as BucketCoordinate\n\n        // --- Check Segments ---\n        const segmentBucketList = this.segmentBuckets.get(bucketKey)\n        if (segmentBucketList) {\n          for (const segmentInfo of segmentBucketList) {\n            if (checkedSegments.has(segmentInfo.segmentId)) continue\n            checkedSegments.add(segmentInfo.segmentId)\n\n            const route = segmentInfo.parentRoute\n            // Convert segment points to Point2D for distance calculation\n            const p1: Point2D = {\n              x: segmentInfo.segment[0].x,\n              y: segmentInfo.segment[0].y,\n            }\n            const p2: Point2D = {\n              x: segmentInfo.segment[1].x,\n              y: segmentInfo.segment[1].y,\n            }\n\n            const requiredSeparation = margin + route.traceThickness / 2\n            const requiredSeparationSq = requiredSeparation * requiredSeparation\n\n            const distSq = pointToSegmentDistanceSq(point, p1, p2)\n\n            if (distSq < requiredSeparationSq) {\n              // Use < for strict clearance\n              const routeName = route.connectionName\n              const existing = conflictingRouteData.get(routeName)\n              if (!existing || distSq < existing.minDistSq) {\n                conflictingRouteData.set(routeName, {\n                  route,\n                  minDistSq: distSq,\n                })\n              }\n            }\n          }\n        }\n\n        // --- Check Vias ---\n        const viaBucketList = this.viaBuckets.get(bucketKey)\n        if (viaBucketList) {\n          for (const viaInfo of viaBucketList) {\n            if (checkedVias.has(viaInfo.viaId)) continue\n            checkedVias.add(viaInfo.viaId)\n\n            const route = viaInfo.parentRoute\n            const viaPoint: Point2D = { x: viaInfo.x, y: viaInfo.y }\n\n            const requiredSeparation = margin + route.viaDiameter / 2\n            const requiredSeparationSq = requiredSeparation * requiredSeparation\n\n            const distSq = computeDistSq(point, viaPoint) // Point-to-point distance\n\n            if (distSq < requiredSeparationSq) {\n              // Use < for strict clearance\n              const routeName = route.connectionName\n              const existing = conflictingRouteData.get(routeName)\n              if (!existing || distSq < existing.minDistSq) {\n                conflictingRouteData.set(routeName, {\n                  route,\n                  minDistSq: distSq,\n                })\n              }\n            }\n          }\n        }\n      }\n    }\n\n    // --- Convert map to results ---\n    const results: Array<{\n      conflictingRoute: HighDensityRoute\n      distance: number\n    }> = []\n    for (const data of conflictingRouteData.values()) {\n      // Distance reported is point-to-segment-centerline or point-to-via-center\n      results.push({\n        conflictingRoute: data.route,\n        distance: Math.sqrt(data.minDistSq),\n      })\n    }\n\n    return results\n  }\n}\n","import { ObstacleSpatialHashIndex } from \"lib/data-structures/ObstacleTree\"\nimport { BaseSolver } from \"../BaseSolver\"\nimport {\n  HighDensityRoute,\n  HighDensityRouteSpatialIndex,\n} from \"lib/data-structures/HighDensityRouteSpatialIndex\"\nimport { segmentToBoxMinDistance } from \"@tscircuit/math-utils\"\nimport { GraphicsObject } from \"graphics-debug\"\n\ninterface RouteSection {\n  startIndex: number\n  endIndex: number\n  z: number\n  points: HighDensityRoute[\"route\"]\n}\n\nexport class SingleRouteUselessViaRemovalSolver extends BaseSolver {\n  obstacleSHI: ObstacleSpatialHashIndex\n  hdRouteSHI: HighDensityRouteSpatialIndex\n  unsimplifiedRoute: HighDensityRoute\n\n  routeSections: Array<RouteSection>\n\n  currentSectionIndex: number\n\n  TRACE_THICKNESS = 0.15\n  OBSTACLE_MARGIN = 0.1\n\n  constructor(params: {\n    obstacleSHI: ObstacleSpatialHashIndex\n    hdRouteSHI: HighDensityRouteSpatialIndex\n    unsimplifiedRoute: HighDensityRoute\n  }) {\n    super()\n    this.currentSectionIndex = 1\n    this.obstacleSHI = params.obstacleSHI\n    this.hdRouteSHI = params.hdRouteSHI\n    this.unsimplifiedRoute = params.unsimplifiedRoute\n\n    this.routeSections = this.breakRouteIntoSections(this.unsimplifiedRoute)\n  }\n\n  breakRouteIntoSections(route: HighDensityRoute) {\n    const routeSections: this[\"routeSections\"] = []\n    const routePoints = route.route\n    if (routePoints.length === 0) return []\n\n    let currentSection = {\n      startIndex: 0,\n      endIndex: -1,\n      z: routePoints[0].z,\n      points: [routePoints[0]],\n    }\n    for (let i = 1; i < routePoints.length; i++) {\n      if (routePoints[i].z === currentSection.z) {\n        currentSection.points.push(routePoints[i])\n      } else {\n        currentSection.endIndex = i - 1\n        routeSections.push(currentSection)\n        currentSection = {\n          startIndex: i,\n          endIndex: -1,\n          z: routePoints[i].z,\n          points: [routePoints[i]],\n        }\n      }\n    }\n    currentSection.endIndex = routePoints.length - 1\n    routeSections.push(currentSection)\n\n    return routeSections\n  }\n\n  _step() {\n    // We skip the first/last segment (since it's connected to the destination)\n    if (this.currentSectionIndex >= this.routeSections.length - 1) {\n      this.solved = true\n      return\n    }\n\n    const prevSection = this.routeSections[this.currentSectionIndex - 1]\n    const currentSection = this.routeSections[this.currentSectionIndex]\n    const nextSection = this.routeSections[this.currentSectionIndex + 1]\n    // console.log({\n    //   routeSections: this.routeSections,\n    //   prevSection,\n    //   currentSection,\n    //   nextSection,\n    // })\n\n    if (prevSection.z !== nextSection.z) {\n      // We only remove vias where there is a middle section that can be\n      // replaced by the layer of adjacent sections, if the adjacent sections\n      // don't have matching layers, a more complex algo is needed\n      this.currentSectionIndex++\n      return\n    }\n\n    const targetZ = prevSection.z\n\n    if (this.canSectionMoveToLayer({ currentSection, targetZ })) {\n      currentSection.z = targetZ\n      currentSection.points = currentSection.points.map((p) => ({\n        ...p,\n        z: targetZ,\n      }))\n      this.currentSectionIndex += 2\n      return\n    }\n\n    this.currentSectionIndex++\n    return\n  }\n\n  canSectionMoveToLayer({\n    currentSection,\n    targetZ,\n  }: {\n    currentSection: RouteSection\n    targetZ: number\n  }): boolean {\n    // Evaluate if the section layer can be changed without hitting anything\n    for (let i = 0; i < currentSection.points.length - 1; i++) {\n      const A = { ...currentSection.points[i], z: targetZ }\n      const B = { ...currentSection.points[i + 1], z: targetZ }\n\n      const conflictingRoutes = this.hdRouteSHI.getConflictingRoutesForSegment(\n        A,\n        B,\n        this.TRACE_THICKNESS,\n      )\n\n      for (const { conflictingRoute, distance } of conflictingRoutes) {\n        if (\n          conflictingRoute.connectionName ===\n          this.unsimplifiedRoute.connectionName\n        )\n          continue\n        // TODO connMap test\n        if (distance < this.TRACE_THICKNESS + conflictingRoute.traceThickness) {\n          return false\n        }\n      }\n\n      const segmentBox = {\n        centerX: (A.x + B.x) / 2,\n        centerY: (A.y + B.y) / 2,\n        width: Math.abs(A.x - B.x),\n        height: Math.abs(A.y - B.y),\n      }\n\n      // Obstacle check\n      const obstacles = this.obstacleSHI.searchArea(\n        segmentBox.centerX,\n        segmentBox.centerY,\n        segmentBox.width + (this.TRACE_THICKNESS + this.OBSTACLE_MARGIN) * 2, // Expand search width\n        segmentBox.height + (this.TRACE_THICKNESS + this.OBSTACLE_MARGIN) * 2, // Expand search height\n      )\n\n      for (const obstacle of obstacles) {\n        // TODO connMap test\n        const distToObstacle = segmentToBoxMinDistance(A, B, obstacle)\n\n        if (distToObstacle < this.TRACE_THICKNESS + this.OBSTACLE_MARGIN) {\n          return false\n        }\n      }\n    }\n\n    return true\n  }\n\n  getConstructorParams() {\n    return {\n      obstacleSHI: this.obstacleSHI,\n      hdRouteSHI: this.hdRouteSHI,\n      unsimplifiedRoute: this.unsimplifiedRoute,\n    }\n  }\n\n  getOptimizedHdRoute(): HighDensityRoute {\n    // TODO reconstruct the route from segments, we will need to recompute the\n    // vias\n    const route = this.routeSections.flatMap((section) => section.points)\n    const vias: HighDensityRoute[\"vias\"] = []\n    for (let i = 0; i < route.length - 1; i++) {\n      if (route[i].z !== route[i + 1].z) {\n        vias.push({\n          x: route[i].x,\n          y: route[i].y,\n        })\n      }\n    }\n    return {\n      connectionName: this.unsimplifiedRoute.connectionName,\n      route,\n      traceThickness: this.unsimplifiedRoute.traceThickness,\n      vias,\n      viaDiameter: this.unsimplifiedRoute.viaDiameter,\n    }\n  }\n  visualize(): GraphicsObject {\n    const graphics: Required<GraphicsObject> = {\n      circles: [],\n      lines: [],\n      points: [],\n      rects: [],\n      coordinateSystem: \"cartesian\",\n      title: \"Single Route Useless Via Removal Solver\",\n    }\n\n    // Draw the sections, draw the active section in orange\n\n    for (let i = 0; i < this.routeSections.length; i++) {\n      const section = this.routeSections[i]\n      graphics.lines.push({\n        points: section.points,\n        strokeWidth: this.TRACE_THICKNESS,\n        strokeColor:\n          i === this.currentSectionIndex\n            ? \"orange\"\n            : section.z === 0\n              ? \"red\"\n              : \"blue\",\n      })\n    }\n\n    return graphics\n  }\n}\n","import { ObstacleSpatialHashIndex } from \"lib/data-structures/ObstacleTree\"\nimport { SegmentTree } from \"lib/data-structures/SegmentTree\"\nimport { BaseSolver } from \"../BaseSolver\"\nimport { HighDensityRoute } from \"lib/types/high-density-types\"\nimport { Obstacle } from \"lib/types\"\nimport { GraphicsObject } from \"graphics-debug\"\nimport { mapZToLayerName } from \"lib/utils/mapZToLayerName\"\nimport { HighDensityRouteSpatialIndex } from \"lib/data-structures/HighDensityRouteSpatialIndex\"\nimport { SingleRouteUselessViaRemovalSolver } from \"./SingleRouteUselessViaRemovalSolver\"\n\nexport interface UselessViaRemovalSolverInput {\n  unsimplifiedHdRoutes: HighDensityRoute[]\n  obstacles: Obstacle[]\n  colorMap: Record<string, string>\n  layerCount: number\n}\n\nexport class UselessViaRemovalSolver extends BaseSolver {\n  unsimplifiedHdRoutes: HighDensityRoute[]\n  optimizedHdRoutes: HighDensityRoute[]\n  unprocessedRoutes: HighDensityRoute[]\n\n  activeSubSolver?: SingleRouteUselessViaRemovalSolver | null | undefined = null\n\n  obstacleSHI: ObstacleSpatialHashIndex | null = null\n  hdRouteSHI: HighDensityRouteSpatialIndex | null = null\n\n  constructor(private input: UselessViaRemovalSolverInput) {\n    super()\n    this.MAX_ITERATIONS = 1e6\n    this.unsimplifiedHdRoutes = input.unsimplifiedHdRoutes\n    this.optimizedHdRoutes = []\n    this.unprocessedRoutes = [...input.unsimplifiedHdRoutes]\n\n    this.obstacleSHI = new ObstacleSpatialHashIndex(\"flatbush\", input.obstacles)\n    this.hdRouteSHI = new HighDensityRouteSpatialIndex(\n      this.unsimplifiedHdRoutes,\n    )\n  }\n\n  _step() {\n    if (this.activeSubSolver) {\n      this.activeSubSolver.step()\n      if (this.activeSubSolver.solved) {\n        this.optimizedHdRoutes.push(this.activeSubSolver.getOptimizedHdRoute())\n        this.activeSubSolver = null\n      } else if (this.activeSubSolver.failed || this.activeSubSolver.error) {\n        this.error = this.activeSubSolver.error\n        this.failed = true\n      }\n      return\n    }\n\n    const unprocessedRoute = this.unprocessedRoutes.shift()\n    if (!unprocessedRoute) {\n      this.solved = true\n      return\n    }\n\n    this.activeSubSolver = new SingleRouteUselessViaRemovalSolver({\n      hdRouteSHI: this.hdRouteSHI!,\n      obstacleSHI: this.obstacleSHI!,\n      unsimplifiedRoute: unprocessedRoute,\n    })\n  }\n\n  getOptimizedHdRoutes(): HighDensityRoute[] | null {\n    return this.optimizedHdRoutes\n  }\n\n  visualize(): GraphicsObject {\n    const visualization: Required<GraphicsObject> = {\n      lines: [],\n      points: [],\n      rects: [],\n      circles: [],\n      coordinateSystem: \"cartesian\",\n      title: \"Useless Via Removal Solver\",\n    }\n\n    // Visualize obstacles\n    for (const obstacle of this.input.obstacles) {\n      let fillColor = \"rgba(128, 128, 128, 0.2)\" // Default faded gray\n      const strokeColor = \"rgba(128, 128, 128, 0.5)\"\n      const isOnLayer0 = obstacle.zLayers?.includes(0)\n      const isOnLayer1 = obstacle.zLayers?.includes(1)\n\n      if (isOnLayer0 && isOnLayer1) {\n        fillColor = \"rgba(128, 0, 128, 0.2)\" // Faded purple for both layers\n      } else if (isOnLayer0) {\n        fillColor = \"rgba(255, 0, 0, 0.2)\" // Faded red for layer 0\n      } else if (isOnLayer1) {\n        fillColor = \"rgba(0, 0, 255, 0.2)\" // Faded blue for layer 1\n      }\n\n      visualization.rects.push({\n        center: obstacle.center,\n        width: obstacle.width,\n        height: obstacle.height,\n        fill: fillColor,\n        label: `Obstacle (Z: ${obstacle.zLayers?.join(\", \")})`,\n      })\n    }\n\n    // Display each optimized route\n    for (const route of this.optimizedHdRoutes) {\n      // Skip routes with no points\n      if (route.route.length === 0) continue\n\n      const color = this.input.colorMap[route.connectionName] || \"#888888\"\n\n      // Add lines connecting route points on the same layer\n      for (let i = 0; i < route.route.length - 1; i++) {\n        const current = route.route[i]\n        const next = route.route[i + 1]\n\n        // Only draw segments that are on the same layer\n        if (current.z === next.z) {\n          visualization.lines.push({\n            points: [\n              { x: current.x, y: current.y },\n              { x: next.x, y: next.y },\n            ],\n            strokeColor: current.z === 0 ? \"red\" : \"blue\",\n            strokeWidth: route.traceThickness,\n            label: `${route.connectionName} (z=${current.z})`,\n          })\n        }\n      }\n\n      // Add circles for vias\n      for (const via of route.vias) {\n        visualization.circles.push({\n          center: { x: via.x, y: via.y },\n          radius: route.viaDiameter / 2,\n          fill: \"rgba(255, 0, 255, 0.5)\",\n          label: `${route.connectionName} via`,\n        })\n      }\n    }\n\n    if (this.activeSubSolver) {\n      visualization.lines.push(\n        ...(this.activeSubSolver.visualize().lines ?? []),\n      )\n    }\n\n    return visualization\n  }\n}\n","import type { GraphicsObject, Line } from \"graphics-debug\"\nimport { combineVisualizations } from \"../utils/combineVisualizations\"\nimport type {\n  CapacityMeshEdge,\n  CapacityMeshNode,\n  SimpleRouteJson,\n  SimplifiedPcbTrace,\n  SimplifiedPcbTraces,\n  TraceId,\n} from \"../types\"\nimport { BaseSolver } from \"./BaseSolver\"\nimport { CapacityMeshEdgeSolver } from \"./CapacityMeshSolver/CapacityMeshEdgeSolver\"\nimport { CapacityMeshNodeSolver } from \"./CapacityMeshSolver/CapacityMeshNodeSolver1\"\nimport { CapacityMeshNodeSolver2_NodeUnderObstacle } from \"./CapacityMeshSolver/CapacityMeshNodeSolver2_NodesUnderObstacles\"\nimport { CapacityPathingSolver } from \"./CapacityPathingSolver/CapacityPathingSolver\"\nimport { CapacityEdgeToPortSegmentSolver } from \"./CapacityMeshSolver/CapacityEdgeToPortSegmentSolver\"\nimport { getColorMap } from \"./colors\"\nimport { CapacitySegmentToPointSolver } from \"./CapacityMeshSolver/CapacitySegmentToPointSolver\"\nimport { HighDensitySolver } from \"./HighDensitySolver/HighDensitySolver\"\nimport type { NodePortSegment } from \"../types/capacity-edges-to-port-segments-types\"\nimport { CapacityPathingSolver2_AvoidLowCapacity } from \"./CapacityPathingSolver/CapacityPathingSolver2_AvoidLowCapacity\"\nimport { CapacityPathingSolver3_FlexibleNegativeCapacity_AvoidLowCapacity } from \"./CapacityPathingSolver/CapacityPathingSolver3_FlexibleNegativeCapacity_AvoidLowCapacity\"\nimport { CapacityPathingSolver4_FlexibleNegativeCapacity } from \"./CapacityPathingSolver/CapacityPathingSolver4_FlexibleNegativeCapacity_AvoidLowCapacity_FixedDistanceCost\"\nimport { ConnectivityMap } from \"circuit-json-to-connectivity-map\"\nimport { getConnectivityMapFromSimpleRouteJson } from \"lib/utils/getConnectivityMapFromSimpleRouteJson\"\nimport { CapacityNodeTargetMerger } from \"./CapacityNodeTargetMerger/CapacityNodeTargetMerger\"\nimport { CapacitySegmentPointOptimizer } from \"./CapacitySegmentPointOptimizer/CapacitySegmentPointOptimizer\"\nimport { calculateOptimalCapacityDepth } from \"../utils/getTunedTotalCapacity1\"\nimport { NetToPointPairsSolver } from \"./NetToPointPairsSolver/NetToPointPairsSolver\"\nimport { convertHdRouteToSimplifiedRoute } from \"lib/utils/convertHdRouteToSimplifiedRoute\"\nimport { mergeRouteSegments } from \"lib/utils/mergeRouteSegments\"\nimport { mapLayerNameToZ } from \"lib/utils/mapLayerNameToZ\"\nimport { MultipleHighDensityRouteStitchSolver } from \"./RouteStitchingSolver/MultipleHighDensityRouteStitchSolver\"\nimport { convertSrjToGraphicsObject } from \"lib/utils/convertSrjToGraphicsObject\"\nimport { UnravelMultiSectionSolver } from \"./UnravelSolver/UnravelMultiSectionSolver\"\nimport { CapacityPathingMultiSectionSolver } from \"./CapacityPathingSectionSolver/CapacityPathingMultiSectionSolver\" // Added import\nimport { StrawSolver } from \"./StrawSolver/StrawSolver\"\nimport { SingleLayerNodeMergerSolver } from \"./SingleLayerNodeMerger/SingleLayerNodeMergerSolver\"\nimport { CapacityNodeTargetMerger2 } from \"./CapacityNodeTargetMerger/CapacityNodeTargetMerger2\"\nimport { SingleSimplifiedPathSolver } from \"./SimplifiedPathSolver/SingleSimplifiedPathSolver\"\nimport { MultiSimplifiedPathSolver } from \"./SimplifiedPathSolver/MultiSimplifiedPathSolver\"\nimport {\n  HighDensityIntraNodeRoute,\n  HighDensityRoute,\n} from \"lib/types/high-density-types\"\nimport { CapacityMeshEdgeSolver2_NodeTreeOptimization } from \"./CapacityMeshSolver/CapacityMeshEdgeSolver2_NodeTreeOptimization\"\nimport { DeadEndSolver } from \"./DeadEndSolver/DeadEndSolver\"\nimport { UselessViaRemovalSolver } from \"./UselessViaRemovalSolver/UselessViaRemovalSolver\"\nimport { CapacityPathingSolver5 } from \"./CapacityPathingSolver/CapacityPathingSolver5\"\nimport { CapacityPathingGreedySolver } from \"./CapacityPathingSectionSolver/CapacityPathingGreedySolver\"\nimport { CacheProvider } from \"lib/cache/types\"\nimport { getGlobalInMemoryCache } from \"lib/cache/setupGlobalCaches\"\n\ninterface CapacityMeshSolverOptions {\n  capacityDepth?: number\n  targetMinCapacity?: number\n  cacheProvider?: CacheProvider | null\n}\n\ntype PipelineStep<T extends new (...args: any[]) => BaseSolver> = {\n  solverName: string\n  solverClass: T\n  getConstructorParams: (\n    instance: AutoroutingPipelineSolver,\n  ) => ConstructorParameters<T>\n  onSolved?: (instance: AutoroutingPipelineSolver) => void\n}\n\nfunction definePipelineStep<\n  T extends new (\n    ...args: any[]\n  ) => BaseSolver,\n  const P extends ConstructorParameters<T>,\n>(\n  solverName: keyof AutoroutingPipelineSolver,\n  solverClass: T,\n  getConstructorParams: (instance: AutoroutingPipelineSolver) => P,\n  opts: {\n    onSolved?: (instance: AutoroutingPipelineSolver) => void\n  } = {},\n): PipelineStep<T> {\n  return {\n    solverName,\n    solverClass,\n    getConstructorParams,\n    onSolved: opts.onSolved,\n  }\n}\n\nexport class AutoroutingPipelineSolver extends BaseSolver {\n  netToPointPairsSolver?: NetToPointPairsSolver\n  nodeSolver?: CapacityMeshNodeSolver\n  nodeTargetMerger?: CapacityNodeTargetMerger\n  edgeSolver?: CapacityMeshEdgeSolver\n  initialPathingSolver?: CapacityPathingGreedySolver\n  pathingOptimizer?: CapacityPathingMultiSectionSolver\n  edgeToPortSegmentSolver?: CapacityEdgeToPortSegmentSolver\n  colorMap: Record<string, string>\n  segmentToPointSolver?: CapacitySegmentToPointSolver\n  unravelMultiSectionSolver?: UnravelMultiSectionSolver\n  segmentToPointOptimizer?: CapacitySegmentPointOptimizer\n  highDensityRouteSolver?: HighDensitySolver\n  highDensityStitchSolver?: MultipleHighDensityRouteStitchSolver\n  singleLayerNodeMerger?: SingleLayerNodeMergerSolver\n  strawSolver?: StrawSolver\n  deadEndSolver?: DeadEndSolver\n  uselessViaRemovalSolver1?: UselessViaRemovalSolver\n  uselessViaRemovalSolver2?: UselessViaRemovalSolver\n  multiSimplifiedPathSolver1?: MultiSimplifiedPathSolver\n  multiSimplifiedPathSolver2?: MultiSimplifiedPathSolver\n\n  startTimeOfPhase: Record<string, number>\n  endTimeOfPhase: Record<string, number>\n  timeSpentOnPhase: Record<string, number>\n\n  activeSubSolver?: BaseSolver | null = null\n  connMap: ConnectivityMap\n  srjWithPointPairs?: SimpleRouteJson\n  capacityNodes: CapacityMeshNode[] | null = null\n  capacityEdges: CapacityMeshEdge[] | null = null\n\n  cacheProvider: CacheProvider | null = null\n\n  pipelineDef = [\n    definePipelineStep(\n      \"netToPointPairsSolver\",\n      NetToPointPairsSolver,\n      (cms) => [cms.srj, cms.colorMap],\n      {\n        onSolved: (cms) => {\n          cms.srjWithPointPairs =\n            cms.netToPointPairsSolver?.getNewSimpleRouteJson()\n          cms.colorMap = getColorMap(cms.srjWithPointPairs!, this.connMap)\n          cms.connMap = getConnectivityMapFromSimpleRouteJson(\n            cms.srjWithPointPairs!,\n          )\n        },\n      },\n    ),\n    definePipelineStep(\n      \"nodeSolver\",\n      CapacityMeshNodeSolver2_NodeUnderObstacle,\n      (cms) => [\n        cms.netToPointPairsSolver?.getNewSimpleRouteJson() || cms.srj,\n        cms.opts,\n      ],\n      {\n        onSolved: (cms) => {\n          cms.capacityNodes = cms.nodeSolver?.finishedNodes!\n        },\n      },\n    ),\n    // definePipelineStep(\"nodeTargetMerger\", CapacityNodeTargetMerger, (cms) => [\n    //   cms.nodeSolver?.finishedNodes || [],\n    //   cms.srj.obstacles,\n    //   cms.connMap,\n    // ]),\n    // definePipelineStep(\"nodeTargetMerger\", CapacityNodeTargetMerger2, (cms) => [\n    //   cms.nodeSolver?.finishedNodes || [],\n    //   cms.srj.obstacles,\n    //   cms.connMap,\n    //   cms.colorMap,\n    //   cms.srj.connections,\n    // ]),\n    definePipelineStep(\n      \"singleLayerNodeMerger\",\n      SingleLayerNodeMergerSolver,\n      (cms) => [cms.nodeSolver?.finishedNodes!],\n      {\n        onSolved: (cms) => {\n          cms.capacityNodes = cms.singleLayerNodeMerger?.newNodes!\n        },\n      },\n    ),\n    definePipelineStep(\n      \"strawSolver\",\n      StrawSolver,\n      (cms) => [{ nodes: cms.singleLayerNodeMerger?.newNodes! }],\n      {\n        onSolved: (cms) => {\n          cms.capacityNodes = cms.strawSolver?.getResultNodes()!\n        },\n      },\n    ),\n    definePipelineStep(\n      \"edgeSolver\",\n      CapacityMeshEdgeSolver2_NodeTreeOptimization,\n      (cms) => [cms.capacityNodes!],\n      {\n        onSolved: (cms) => {\n          cms.capacityEdges = cms.edgeSolver?.edges!\n        },\n      },\n    ),\n    definePipelineStep(\n      \"deadEndSolver\",\n      DeadEndSolver,\n      (cms) => [{ nodes: cms.capacityNodes!, edges: cms.capacityEdges! }],\n      {\n        onSolved: (cms) => {\n          const removedNodeIds = cms.deadEndSolver?.removedNodeIds!\n\n          cms.capacityNodes = cms.capacityNodes!.filter(\n            (n) => !removedNodeIds.has(n.capacityMeshNodeId),\n          )\n          cms.capacityEdges = cms.capacityEdges!.filter((e) =>\n            e.nodeIds.every((nodeId) => !removedNodeIds.has(nodeId)),\n          )\n        },\n      },\n    ),\n    definePipelineStep(\n      \"initialPathingSolver\",\n      CapacityPathingGreedySolver,\n      (cms) => [\n        {\n          simpleRouteJson: cms.srjWithPointPairs!,\n          nodes: cms.capacityNodes!,\n          edges: cms.capacityEdges || [],\n          colorMap: cms.colorMap,\n          hyperParameters: {\n            MAX_CAPACITY_FACTOR: 1,\n          },\n        },\n      ],\n    ),\n    definePipelineStep(\n      \"pathingOptimizer\",\n      // CapacityPathingSolver5,\n      CapacityPathingMultiSectionSolver,\n      (cms) => [\n        // Replaced solver class\n        {\n          initialPathingSolver: cms.initialPathingSolver,\n          simpleRouteJson: cms.srjWithPointPairs!,\n          nodes: cms.capacityNodes!,\n          edges: cms.capacityEdges || [],\n          colorMap: cms.colorMap,\n          cacheProvider: cms.cacheProvider,\n          hyperParameters: {\n            MAX_CAPACITY_FACTOR: 1,\n          },\n        },\n      ],\n    ),\n    definePipelineStep(\n      \"edgeToPortSegmentSolver\",\n      CapacityEdgeToPortSegmentSolver,\n      (cms) => [\n        {\n          nodes: cms.capacityNodes!,\n          edges: cms.capacityEdges || [],\n          capacityPaths: cms.pathingOptimizer?.getCapacityPaths() || [],\n          colorMap: cms.colorMap,\n        },\n      ],\n    ),\n    definePipelineStep(\n      \"segmentToPointSolver\",\n      CapacitySegmentToPointSolver,\n      (cms) => {\n        const allSegments: NodePortSegment[] = []\n        if (cms.edgeToPortSegmentSolver?.nodePortSegments) {\n          cms.edgeToPortSegmentSolver.nodePortSegments.forEach((segs) => {\n            allSegments.push(...segs)\n          })\n        }\n        return [\n          {\n            segments: allSegments,\n            colorMap: cms.colorMap,\n            nodes: cms.capacityNodes!,\n          },\n        ]\n      },\n    ),\n    // definePipelineStep(\n    //   \"segmentToPointOptimizer\",\n    //   CapacitySegmentPointOptimizer,\n    //   (cms) => [\n    //     {\n    //       assignedSegments: cms.segmentToPointSolver?.solvedSegments || [],\n    //       colorMap: cms.colorMap,\n    //       nodes: cms.nodeTargetMerger?.newNodes || [],\n    //     },\n    //   ],\n    // ),\n    definePipelineStep(\n      \"unravelMultiSectionSolver\",\n      UnravelMultiSectionSolver,\n      (cms) => [\n        {\n          assignedSegments: cms.segmentToPointSolver?.solvedSegments || [],\n          colorMap: cms.colorMap,\n          nodes: cms.capacityNodes!,\n          cacheProvider: this.cacheProvider,\n        },\n      ],\n    ),\n    definePipelineStep(\"highDensityRouteSolver\", HighDensitySolver, (cms) => [\n      {\n        nodePortPoints:\n          cms.unravelMultiSectionSolver?.getNodesWithPortPoints() ??\n          cms.segmentToPointOptimizer?.getNodesWithPortPoints() ??\n          [],\n        colorMap: cms.colorMap,\n        connMap: cms.connMap,\n      },\n    ]),\n    definePipelineStep(\n      \"highDensityStitchSolver\",\n      MultipleHighDensityRouteStitchSolver,\n      (cms) => [\n        {\n          connections: cms.srjWithPointPairs!.connections,\n          hdRoutes: cms.highDensityRouteSolver!.routes,\n          colorMap: cms.colorMap,\n          layerCount: cms.srj.layerCount,\n        },\n      ],\n    ),\n    definePipelineStep(\n      \"uselessViaRemovalSolver1\",\n      UselessViaRemovalSolver,\n      (cms) => [\n        {\n          unsimplifiedHdRoutes: cms.highDensityStitchSolver!.mergedHdRoutes,\n          obstacles: cms.srj.obstacles,\n          colorMap: cms.colorMap,\n          layerCount: cms.srj.layerCount,\n        },\n      ],\n    ),\n    definePipelineStep(\n      \"multiSimplifiedPathSolver1\",\n      MultiSimplifiedPathSolver,\n      (cms) => [\n        {\n          unsimplifiedHdRoutes:\n            cms.uselessViaRemovalSolver1?.getOptimizedHdRoutes() ||\n            cms.highDensityStitchSolver!.mergedHdRoutes,\n          obstacles: cms.srj.obstacles,\n          connMap: cms.connMap,\n          colorMap: cms.colorMap,\n        },\n      ],\n    ),\n    definePipelineStep(\n      \"uselessViaRemovalSolver2\",\n      UselessViaRemovalSolver,\n      (cms) => [\n        {\n          unsimplifiedHdRoutes:\n            cms.multiSimplifiedPathSolver1!.simplifiedHdRoutes,\n          obstacles: cms.srj.obstacles,\n          colorMap: cms.colorMap,\n          layerCount: cms.srj.layerCount,\n        },\n      ],\n    ),\n    definePipelineStep(\n      \"multiSimplifiedPathSolver2\",\n      MultiSimplifiedPathSolver,\n      (cms) => [\n        {\n          unsimplifiedHdRoutes:\n            cms.uselessViaRemovalSolver2?.getOptimizedHdRoutes()!,\n          obstacles: cms.srj.obstacles,\n          connMap: cms.connMap,\n          colorMap: cms.colorMap,\n        },\n      ],\n    ),\n  ]\n\n  constructor(\n    public srj: SimpleRouteJson,\n    public opts: CapacityMeshSolverOptions = {},\n  ) {\n    super()\n    this.MAX_ITERATIONS = 100e6\n\n    // If capacityDepth is not provided, calculate it automatically\n    if (opts.capacityDepth === undefined) {\n      // Calculate max width/height from bounds for initial node size\n      const boundsWidth = srj.bounds.maxX - srj.bounds.minX\n      const boundsHeight = srj.bounds.maxY - srj.bounds.minY\n      const maxWidthHeight = Math.max(boundsWidth, boundsHeight)\n\n      // Use the calculateOptimalCapacityDepth function to determine the right depth\n      const targetMinCapacity = opts.targetMinCapacity ?? 0.5\n      opts.capacityDepth = calculateOptimalCapacityDepth(\n        maxWidthHeight,\n        targetMinCapacity,\n      )\n    }\n\n    this.connMap = getConnectivityMapFromSimpleRouteJson(srj)\n    this.colorMap = getColorMap(srj, this.connMap)\n    this.cacheProvider =\n      opts.cacheProvider === undefined\n        ? getGlobalInMemoryCache()\n        : opts.cacheProvider === null\n          ? null\n          : opts.cacheProvider\n    this.startTimeOfPhase = {}\n    this.endTimeOfPhase = {}\n    this.timeSpentOnPhase = {}\n  }\n\n  currentPipelineStepIndex = 0\n  _step() {\n    const pipelineStepDef = this.pipelineDef[this.currentPipelineStepIndex]\n    if (!pipelineStepDef) {\n      this.solved = true\n      return\n    }\n\n    if (this.activeSubSolver) {\n      this.activeSubSolver.step()\n      if (this.activeSubSolver.solved) {\n        this.endTimeOfPhase[pipelineStepDef.solverName] = performance.now()\n        this.timeSpentOnPhase[pipelineStepDef.solverName] =\n          this.endTimeOfPhase[pipelineStepDef.solverName] -\n          this.startTimeOfPhase[pipelineStepDef.solverName]\n        pipelineStepDef.onSolved?.(this)\n        this.activeSubSolver = null\n        this.currentPipelineStepIndex++\n      } else if (this.activeSubSolver.failed) {\n        this.error = this.activeSubSolver?.error\n        this.failed = true\n        this.activeSubSolver = null\n      }\n      return\n    }\n\n    const constructorParams = pipelineStepDef.getConstructorParams(this)\n    // @ts-ignore\n    this.activeSubSolver = new pipelineStepDef.solverClass(...constructorParams)\n    ;(this as any)[pipelineStepDef.solverName] = this.activeSubSolver\n    this.timeSpentOnPhase[pipelineStepDef.solverName] = 0\n    this.startTimeOfPhase[pipelineStepDef.solverName] = performance.now()\n  }\n\n  solveUntilPhase(phase: string) {\n    while (this.getCurrentPhase() !== phase) {\n      this.step()\n    }\n  }\n\n  getCurrentPhase(): string {\n    return this.pipelineDef[this.currentPipelineStepIndex]?.solverName ?? \"none\"\n  }\n\n  visualize(): GraphicsObject {\n    if (!this.solved && this.activeSubSolver)\n      return this.activeSubSolver.visualize()\n    const netToPPSolver = this.netToPointPairsSolver?.visualize()\n    const nodeViz = this.nodeSolver?.visualize()\n    const nodeTargetMergerViz = this.nodeTargetMerger?.visualize()\n    const singleLayerNodeMergerViz = this.singleLayerNodeMerger?.visualize()\n    const strawSolverViz = this.strawSolver?.visualize()\n    const edgeViz = this.edgeSolver?.visualize()\n    const deadEndViz = this.deadEndSolver?.visualize()\n    const initialPathingViz = this.initialPathingSolver?.visualize()\n    const pathingOptimizerViz = this.pathingOptimizer?.visualize()\n    const edgeToPortSegmentViz = this.edgeToPortSegmentSolver?.visualize()\n    const segmentToPointViz = this.segmentToPointSolver?.visualize()\n    const segmentOptimizationViz =\n      this.unravelMultiSectionSolver?.visualize() ??\n      this.segmentToPointOptimizer?.visualize()\n    const highDensityViz = this.highDensityRouteSolver?.visualize()\n    const highDensityStitchViz = this.highDensityStitchSolver?.visualize()\n    const uselessViaRemovalViz1 = this.uselessViaRemovalSolver1?.visualize()\n    const uselessViaRemovalViz2 = this.uselessViaRemovalSolver2?.visualize()\n    const simplifiedPathSolverViz1 =\n      this.multiSimplifiedPathSolver1?.visualize()\n    const simplifiedPathSolverViz2 =\n      this.multiSimplifiedPathSolver2?.visualize()\n    const problemViz = {\n      points: [\n        ...this.srj.connections.flatMap((c) =>\n          c.pointsToConnect.map((p) => ({\n            ...p,\n            label: `${c.name} ${p.pcb_port_id ?? \"\"}`,\n          })),\n        ),\n      ],\n      rects: [\n        ...(this.srj.obstacles ?? []).map((o) => ({\n          ...o,\n          fill: o.layers?.includes(\"top\")\n            ? \"rgba(255,0,0,0.25)\"\n            : o.layers?.includes(\"bottom\")\n              ? \"rgba(0,0,255,0.25)\"\n              : \"rgba(255,0,0,0.25)\",\n          label: o.layers?.join(\", \"),\n        })),\n      ],\n      lines: [\n        {\n          points: [\n            // Add five points representing the bounds of the PCB\n            {\n              x: this.srj.bounds?.minX ?? -50,\n              y: this.srj.bounds?.minY ?? -50,\n            },\n            { x: this.srj.bounds?.maxX ?? 50, y: this.srj.bounds?.minY ?? -50 },\n            { x: this.srj.bounds?.maxX ?? 50, y: this.srj.bounds?.maxY ?? 50 },\n            { x: this.srj.bounds?.minX ?? -50, y: this.srj.bounds?.maxY ?? 50 },\n            {\n              x: this.srj.bounds?.minX ?? -50,\n              y: this.srj.bounds?.minY ?? -50,\n            }, // Close the rectangle\n          ],\n          strokeColor: \"rgba(255,0,0,0.25)\",\n        },\n      ],\n    } as GraphicsObject\n    const visualizations = [\n      problemViz,\n      netToPPSolver,\n      nodeViz,\n      nodeTargetMergerViz,\n      singleLayerNodeMergerViz,\n      strawSolverViz,\n      edgeViz,\n      deadEndViz,\n      initialPathingViz,\n      pathingOptimizerViz,\n      edgeToPortSegmentViz,\n      segmentToPointViz,\n      segmentOptimizationViz,\n      highDensityViz ? combineVisualizations(problemViz, highDensityViz) : null,\n      highDensityStitchViz,\n      uselessViaRemovalViz1,\n      simplifiedPathSolverViz1,\n      uselessViaRemovalViz2,\n      simplifiedPathSolverViz2,\n      this.solved\n        ? combineVisualizations(\n            problemViz,\n            convertSrjToGraphicsObject(this.getOutputSimpleRouteJson()),\n          )\n        : null,\n    ].filter(Boolean) as GraphicsObject[]\n    // return visualizations[visualizations.length - 1]\n    return combineVisualizations(...visualizations)\n  }\n\n  /**\n   * A lightweight version of the visualize method that can be used to stream\n   * progress\n   *\n   * We return the most relevant graphic for the stage:\n   * 1. netToPointPairs output\n   * 2. Capacity Planning Output\n   * 3. High Density Route Solver Output, max 200 lines\n   */\n  preview(): GraphicsObject {\n    if (this.highDensityRouteSolver) {\n      const lines: Line[] = []\n      for (let i = this.highDensityRouteSolver.routes.length - 1; i >= 0; i--) {\n        const route = this.highDensityRouteSolver.routes[i]\n        lines.push({\n          points: route.route.map((n) => ({\n            x: n.x,\n            y: n.y,\n          })),\n          strokeColor: this.colorMap[route.connectionName],\n        })\n        if (lines.length > 200) break\n      }\n      return { lines }\n    }\n\n    if (this.pathingOptimizer) {\n      const lines: Line[] = []\n      for (const connection of this.pathingOptimizer.connectionsWithNodes) {\n        if (!connection.path) continue\n        lines.push({\n          points: connection.path.map((n) => ({\n            x: n.center.x,\n            y: n.center.y,\n          })),\n          strokeColor: this.colorMap[connection.connection.name],\n        })\n      }\n      return { lines }\n    }\n\n    // This output is good as-is\n    if (this.netToPointPairsSolver) {\n      return this.netToPointPairsSolver?.visualize()\n    }\n\n    return {}\n  }\n\n  /**\n   * Get original connection name from connection name with MST suffix\n   * @param mstConnectionName The MST-suffixed connection name (e.g. \"connection1_mst0\")\n   * @returns The original connection name (e.g. \"connection1\")\n   */\n  private getOriginalConnectionName(mstConnectionName: string): string {\n    // MST connections are named like \"connection_mst0\", so extract the original name\n    const match = mstConnectionName.match(/^(.+?)_mst\\d+$/)\n    return match ? match[1] : mstConnectionName\n  }\n\n  _getOutputHdRoutes(): HighDensityRoute[] {\n    return (\n      this.multiSimplifiedPathSolver2?.simplifiedHdRoutes ??\n      this.uselessViaRemovalSolver2?.getOptimizedHdRoutes() ??\n      this.multiSimplifiedPathSolver1?.simplifiedHdRoutes ??\n      this.uselessViaRemovalSolver1?.getOptimizedHdRoutes() ??\n      this.highDensityStitchSolver!.mergedHdRoutes\n    )\n  }\n\n  /**\n   * Returns the SimpleRouteJson with routes converted to SimplifiedPcbTraces\n   */\n  getOutputSimplifiedPcbTraces(): SimplifiedPcbTraces {\n    if (!this.solved || !this.highDensityRouteSolver) {\n      throw new Error(\"Cannot get output before solving is complete\")\n    }\n\n    const traces: SimplifiedPcbTraces = []\n    const allHdRoutes = this._getOutputHdRoutes()\n\n    for (const connection of this.netToPointPairsSolver?.newConnections ?? []) {\n      const netConnectionName = this.srj.connections.find(\n        (c) => c.name === connection.name,\n      )?.netConnectionName\n\n      // Find all the hdRoutes that correspond to this connection\n      const hdRoutes = allHdRoutes.filter(\n        (r) => r.connectionName === connection.name,\n      )\n\n      for (let i = 0; i < hdRoutes.length; i++) {\n        const hdRoute = hdRoutes[i]\n        const simplifiedPcbTrace: SimplifiedPcbTrace = {\n          type: \"pcb_trace\",\n          pcb_trace_id: `${connection.name}_${i}`,\n          connection_name:\n            netConnectionName ??\n            this.getOriginalConnectionName(connection.name),\n          route: convertHdRouteToSimplifiedRoute(hdRoute, this.srj.layerCount),\n        }\n\n        traces.push(simplifiedPcbTrace)\n      }\n    }\n\n    return traces\n  }\n\n  getOutputSimpleRouteJson(): SimpleRouteJson {\n    return {\n      ...this.srj,\n      traces: this.getOutputSimplifiedPcbTraces(),\n    }\n  }\n}\n\n/** @deprecated Use AutoroutingPipelineSolver instead */\nexport const CapacityMeshSolver = AutoroutingPipelineSolver\nexport type CapacityMeshSolver = AutoroutingPipelineSolver\n"],"mappings":"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","names":["t","e","t","t","_isNativeReflectConstruct","_wrapNativeSuper","t","PolishedError","pxtoFactory","reduceHexValue","isRgb","isRgba","isHsl","isHsla","swap","distance","clamp","node","y_1","y_2","points","midpoint","path","optimalPath","distance","withinBounds","distance","CQUnit","EPSILON","distance","start","EPS","almostEqual","pointKey","cross","segmentIntersection","i","viaPositions","force","EPSILON","dx","dy","dSq","dist","fx","fy","EPSILON","distance","layerName","segmentPoints","nodeId","expected","found","distance","calculateNodeProbabilityOfFailure","calculateNodeProbabilityOfFailure","objectHash","objectHash","calculateNodeProbabilityOfFailure","EPSILON","pointToSegmentDistance","distance","orientation","onSegment","distance","tailPoint","path45","getSegmentBounds","distSq","distance"]}