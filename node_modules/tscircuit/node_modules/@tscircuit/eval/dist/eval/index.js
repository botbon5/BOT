// webworker/execution-context.ts
import { RootCircuit } from "@tscircuit/core";
import * as tscircuitCore from "@tscircuit/core";
import * as React from "react";
import * as jscadFiber from "jscad-fiber";
import * as tscircuitMathUtils from "@tscircuit/math-utils";

// node_modules/@tscircuit/parts-engine/lib/jlc-parts-engine.ts
var cache = /* @__PURE__ */ new Map();
var getJlcPartsCached = async (name, params) => {
  const paramString = new URLSearchParams({
    ...params,
    json: "true"
  }).toString();
  if (cache.has(paramString)) {
    return cache.get(paramString);
  }
  const response = await fetch(
    `https://jlcsearch.tscircuit.com/${name}/list?${paramString}`
  );
  const responseJson = await response.json();
  cache.set(paramString, responseJson);
  return responseJson;
};
var jlcPartsEngine = {
  findPart: async ({
    sourceComponent,
    footprinterString
  }) => {
    if (sourceComponent.type === "source_component" && sourceComponent.ftype === "simple_resistor") {
      const { resistors } = await getJlcPartsCached("resistors", {
        resistance: sourceComponent.display_resistance ?? sourceComponent.resistance,
        package: footprinterString
      });
      return {
        jlcpcb: (resistors ?? []).map((r) => `C${r.lcsc}`).slice(0, 3)
      };
    } else if (sourceComponent.type === "source_component" && sourceComponent.ftype === "simple_capacitor") {
      if (footprinterString?.includes("cap")) {
        footprinterString = footprinterString.replace("cap", "");
      }
      const { capacitors } = await getJlcPartsCached("capacitors", {
        capacitance: sourceComponent.display_capacitance ?? sourceComponent.capacitance,
        package: footprinterString
      });
      return {
        jlcpcb: (capacitors ?? []).map((c) => `C${c.lcsc}`).slice(0, 3)
      };
    } else if (sourceComponent.type === "source_component" && sourceComponent.ftype === "simple_pin_header") {
      let pitch;
      if (footprinterString?.includes("_p")) {
        pitch = Number(footprinterString.split("_p")[1]);
      }
      const { headers } = await getJlcPartsCached(
        "headers",
        pitch ? {
          pitch,
          num_pins: sourceComponent.pin_count,
          gender: sourceComponent.gender
        } : {
          num_pins: sourceComponent.pin_count,
          gender: sourceComponent.gender
        }
      );
      return {
        jlcpcb: (headers ?? []).map((h) => `C${h.lcsc}`).slice(0, 3)
      };
    } else if (sourceComponent.type === "source_component" && sourceComponent.ftype === "simple_potentiometer") {
      const { potentiometers } = await getJlcPartsCached("potentiometers", {
        resistance: sourceComponent.max_resistance,
        package: footprinterString
      });
      return {
        jlcpcb: (potentiometers ?? []).map((p) => `C${p.lcsc}`).slice(0, 3)
      };
    } else if (sourceComponent.type === "source_component" && sourceComponent.ftype === "simple_diode") {
      const { diodes } = await getJlcPartsCached("diodes", {
        package: footprinterString
      });
      return {
        jlcpcb: (diodes ?? []).map((d) => `C${d.lcsc}`).slice(0, 3)
      };
    } else if (sourceComponent.type === "source_component" && sourceComponent.ftype === "simple_chip") {
      const { chips } = await getJlcPartsCached("chips", {
        package: footprinterString
      });
      return {
        jlcpcb: (chips ?? []).map((c) => `C${c.lcsc}`).slice(0, 3)
      };
    } else if (sourceComponent.type === "source_component" && sourceComponent.ftype === "simple_transistor") {
      const { transistors } = await getJlcPartsCached("transistors", {
        package: footprinterString,
        transistor_type: sourceComponent.transistor_type
      });
      return {
        jlcpcb: (transistors ?? []).map((t) => `C${t.lcsc}`).slice(0, 3)
      };
    } else if (sourceComponent.type === "source_component" && sourceComponent.ftype === "simple_power_source") {
      const { power_sources } = await getJlcPartsCached("power_sources", {
        voltage: sourceComponent.voltage,
        package: footprinterString
      });
      return {
        jlcpcb: (power_sources ?? []).map((p) => `C${p.lcsc}`).slice(0, 3)
      };
    } else if (sourceComponent.type === "source_component" && sourceComponent.ftype === "simple_inductor") {
      const { inductors } = await getJlcPartsCached("inductors", {
        inductance: sourceComponent.inductance,
        package: footprinterString
      });
      return {
        jlcpcb: (inductors ?? []).map((i) => `C${i.lcsc}`).slice(0, 3)
      };
    } else if (sourceComponent.type === "source_component" && sourceComponent.ftype === "simple_crystal") {
      const { crystals } = await getJlcPartsCached("crystals", {
        frequency: sourceComponent.frequency,
        load_capacitance: sourceComponent.load_capacitance,
        package: footprinterString
      });
      return {
        jlcpcb: (crystals ?? []).map((c) => `C${c.lcsc}`).slice(0, 3)
      };
    } else if (sourceComponent.type === "source_component" && sourceComponent.ftype === "simple_mosfet") {
      const { mosfets } = await getJlcPartsCached("mosfets", {
        package: footprinterString,
        mosfet_mode: sourceComponent.mosfet_mode,
        channel_type: sourceComponent.channel_type
      });
      return {
        jlcpcb: (mosfets ?? []).map((m) => `C${m.lcsc}`).slice(0, 3)
      };
    } else if (sourceComponent.type === "source_component" && sourceComponent.ftype === "simple_resonator") {
      const { resonators } = await getJlcPartsCached("resonators", {
        frequency: sourceComponent.frequency,
        package: footprinterString
      });
      return {
        jlcpcb: (resonators ?? []).map((r) => `C${r.lcsc}`).slice(0, 3)
      };
    } else if (sourceComponent.type === "source_component" && sourceComponent.ftype === "simple_switch") {
      const { switches } = await getJlcPartsCached("switches", {
        switch_type: sourceComponent.type,
        package: footprinterString
      });
      return {
        jlcpcb: (switches ?? []).map((s) => `C${s.lcsc}`).slice(0, 3)
      };
    } else if (sourceComponent.type === "source_component" && sourceComponent.ftype === "simple_led") {
      const { leds } = await getJlcPartsCached("leds", {
        package: footprinterString
      });
      return {
        jlcpcb: (leds ?? []).map((l) => `C${l.lcsc}`).slice(0, 3)
      };
    } else if (sourceComponent.type === "source_component" && sourceComponent.ftype === "simple_fuse") {
      const { fuses } = await getJlcPartsCached("fuses", {
        package: footprinterString
      });
      return {
        jlcpcb: (fuses ?? []).map((l) => `C${l.lcsc}`).slice(0, 3)
      };
    }
    return {};
  }
};

// lib/getPlatformConfig.ts
var getPlatformConfig = () => ({
  partsEngine: jlcPartsEngine
});

// webworker/execution-context.ts
import Debug from "debug";
var debug = Debug("tsci:eval:execution-context");
function createExecutionContext(webWorkerConfiguration, opts = {}) {
  globalThis.React = React;
  const circuit = new RootCircuit({
    platform: opts.platform || getPlatformConfig()
  });
  if (opts.name) {
    circuit.name = opts.name;
  }
  return {
    fsMap: {},
    entrypoint: "",
    preSuppliedImports: {
      "@tscircuit/core": tscircuitCore,
      tscircuit: tscircuitCore,
      "@tscircuit/math-utils": tscircuitMathUtils,
      react: React,
      "jscad-fiber": jscadFiber,
      // This is usually used as a type import, we can remove the shim when we
      // ignore type imports in getImportsFromCode
      "@tscircuit/props": {}
    },
    circuit,
    ...webWorkerConfiguration
  };
}

// lib/runner/normalizeFsMap.ts
function normalizeFilePath(filePath) {
  let normFilePath = filePath;
  normFilePath = normFilePath.replace(/\\/g, "/");
  normFilePath = normFilePath.trim();
  if (normFilePath.startsWith("./")) {
    normFilePath = normFilePath.slice(2);
  }
  if (normFilePath.startsWith("/")) {
    normFilePath = normFilePath.slice(1);
  }
  return normFilePath;
}
function normalizeFsMap(fsMap) {
  const normalizedFsMap = {};
  for (const [fsPath, fileContent] of Object.entries(fsMap)) {
    normalizedFsMap[normalizeFilePath(fsPath)] = fileContent;
  }
  return normalizedFsMap;
}

// lib/runner/CircuitRunner.ts
import "react";

// lib/utils/dirname.ts
function dirname(path) {
  if (!path) return ".";
  const normalizedPath = path.replace(/\\/g, "/");
  const cleanPath = normalizedPath.replace(/\/+$/, "");
  if (cleanPath.indexOf("/") === -1) return ".";
  return cleanPath.substring(0, cleanPath.lastIndexOf("/")) || "/";
}

// lib/runner/resolveFilePath.ts
function resolveRelativePath(importPath, cwd) {
  if (importPath.startsWith("../")) {
    const parentDir = dirname(cwd);
    return resolveRelativePath(importPath.slice(3), parentDir);
  }
  if (importPath.startsWith("./")) {
    return resolveRelativePath(importPath.slice(2), cwd);
  }
  if (importPath.startsWith("/")) {
    return importPath.slice(1);
  }
  return `${cwd}/${importPath}`;
}
var resolveFilePath = (unknownFilePath, fsMapOrAllFilePaths, cwd) => {
  const resolvedPath = cwd ? resolveRelativePath(unknownFilePath, cwd) : unknownFilePath;
  const filePaths = new Set(
    Array.isArray(fsMapOrAllFilePaths) ? fsMapOrAllFilePaths : Object.keys(fsMapOrAllFilePaths)
  );
  if (filePaths.has(resolvedPath)) {
    return resolvedPath;
  }
  const normalizedFilePathMap = /* @__PURE__ */ new Map();
  for (const filePath of filePaths) {
    normalizedFilePathMap.set(normalizeFilePath(filePath), filePath);
  }
  const normalizedResolvedPath = normalizeFilePath(resolvedPath);
  if (normalizedFilePathMap.has(normalizedResolvedPath)) {
    return normalizedFilePathMap.get(normalizedResolvedPath);
  }
  const extension = ["tsx", "ts", "json", "js", "jsx"];
  for (const ext of extension) {
    const possibleFilePath = `${normalizedResolvedPath}.${ext}`;
    if (normalizedFilePathMap.has(possibleFilePath)) {
      return normalizedFilePathMap.get(possibleFilePath);
    }
  }
  if (!unknownFilePath.startsWith("./") && !unknownFilePath.startsWith("../")) {
    const normalizedUnknownFilePath = normalizeFilePath(unknownFilePath);
    if (normalizedFilePathMap.has(normalizedUnknownFilePath)) {
      return normalizedFilePathMap.get(normalizedUnknownFilePath);
    }
    for (const ext of extension) {
      const possibleFilePath = `${normalizedUnknownFilePath}.${ext}`;
      if (normalizedFilePathMap.has(possibleFilePath)) {
        return normalizedFilePathMap.get(possibleFilePath);
      }
    }
  }
  return null;
};
var resolveFilePathOrThrow = (unknownFilePath, fsMapOrAllFilePaths) => {
  const resolvedFilePath = resolveFilePath(unknownFilePath, fsMapOrAllFilePaths);
  if (!resolvedFilePath) {
    throw new Error(
      `File not found "${unknownFilePath}", available paths:

${Object.keys(fsMapOrAllFilePaths).join(", ")}`
    );
  }
  return resolvedFilePath;
};

// webworker/eval-compiled-js.ts
function evalCompiledJs(compiledCode, preSuppliedImports, cwd) {
  ;
  globalThis.__tscircuit_require = (name) => {
    const resolvedFilePath = resolveFilePath(name, preSuppliedImports, cwd);
    const hasResolvedFilePath = resolvedFilePath && preSuppliedImports[resolvedFilePath];
    if (!preSuppliedImports[name] && !hasResolvedFilePath) {
      throw new Error(`Import "${name}" not found ${cwd ? `in "${cwd}"` : ""}`);
    }
    const mod = preSuppliedImports[name] || preSuppliedImports[resolvedFilePath];
    return new Proxy(mod, {
      get(target, prop) {
        if (!(prop in target)) {
          if (prop === "default") {
            if (target.default !== void 0) {
              return target.default;
            }
            if (target.__esModule) {
              return void 0;
            }
            if (typeof target === "function" || typeof target === "object") {
              return target;
            }
            return void 0;
          }
          if (prop === "__esModule") {
            return true;
          }
          throw new Error(
            `Component "${String(prop)}" is not exported by "${name}"`
          );
        }
        return target[prop];
      }
    });
  };
  const functionBody = `
  var exports = {};
  var require = globalThis.__tscircuit_require;
  var module = { exports };
  var circuit = globalThis.__tscircuit_circuit;
  ${compiledCode};
  return module;`.trim();
  return Function(functionBody).call(globalThis);
}

// webworker/import-eval-path.ts
import "@babel/standalone";

// webworker/import-local-file.ts
import * as Babel from "@babel/standalone";

// lib/utils/get-imports-from-code.ts
var getImportsFromCode = (code) => {
  const importRegex = /^\s*import\s+(?:(?:[\w\s]+,\s*)?(?:\*\s+as\s+[\w\s]+|\{[\s\w,]+\}|\w+)\s+from\s+)?['"](.+?)['"]/gm;
  const imports = [];
  let match;
  while ((match = importRegex.exec(code)) !== null) {
    imports.push(match[1]);
  }
  const reExportRegex = /^\s*export\s+(?:\*|(?:\{[\s\w,]+\}))\s+from\s+['"](.+?)['"]/gm;
  let reExportMatch;
  while ((reExportMatch = reExportRegex.exec(code)) !== null) {
    imports.push(reExportMatch[1]);
  }
  return imports;
};

// webworker/import-local-file.ts
import Debug2 from "debug";
var debug2 = Debug2("tsci:eval:import-local-file");
var importLocalFile = async (importName, ctx, depth = 0) => {
  debug2("importLocalFile called with:", {
    importName
  });
  const { fsMap, preSuppliedImports } = ctx;
  const fsPath = resolveFilePathOrThrow(importName, fsMap);
  debug2("fsPath:", fsPath);
  if (!ctx.fsMap[fsPath]) {
    debug2("fsPath not found in fsMap:", fsPath);
    throw new Error(`File "${fsPath}" not found`);
  }
  const fileContent = fsMap[fsPath];
  debug2("fileContent:", fileContent?.slice(0, 100));
  if (fsPath.endsWith(".json")) {
    const jsonData = JSON.parse(fileContent);
    preSuppliedImports[fsPath] = {
      __esModule: true,
      default: jsonData
    };
  } else if (fsPath.endsWith(".tsx") || fsPath.endsWith(".ts")) {
    const importNames = getImportsFromCode(fileContent);
    for (const importName2 of importNames) {
      if (!preSuppliedImports[importName2]) {
        await importEvalPath(importName2, ctx, depth + 1, {
          cwd: dirname(fsPath)
        });
      }
    }
    const result = Babel.transform(fileContent, {
      presets: ["react", "typescript"],
      plugins: ["transform-modules-commonjs"],
      filename: "virtual.tsx"
    });
    if (!result || !result.code) {
      throw new Error("Failed to transform code");
    }
    try {
      debug2("evalCompiledJs called with:", {
        code: result.code?.slice(0, 100),
        dirname: dirname(fsPath)
      });
      const importRunResult = evalCompiledJs(
        result.code,
        preSuppliedImports,
        dirname(fsPath)
      );
      debug2("importRunResult:", {
        fsPath,
        importRunResult
      });
      preSuppliedImports[fsPath] = importRunResult.exports;
    } catch (error) {
      throw new Error(
        `Eval compiled js error for "${importName}": ${error.message}`
      );
    }
  } else if (fsPath.endsWith(".js")) {
    const result = Babel.transform(fileContent, {
      presets: ["env"],
      plugins: ["transform-modules-commonjs"],
      filename: fsPath
    });
    if (!result || !result.code) {
      throw new Error("Failed to transform JS code");
    }
    preSuppliedImports[fsPath] = evalCompiledJs(
      result.code,
      preSuppliedImports,
      dirname(fsPath)
    ).exports;
  } else {
    throw new Error(
      `Unsupported file extension "${fsPath.split(".").pop()}" for "${fsPath}"`
    );
  }
};

// webworker/import-snippet.ts
import "@babel/standalone";
async function importSnippet(importName, ctx, depth = 0) {
  const { preSuppliedImports } = ctx;
  const fullSnippetName = importName.replace("@tsci/", "").replace(".", "/");
  const { cjs, error } = await fetch(`${ctx.cjsRegistryUrl}/${fullSnippetName}`).then(async (res) => ({ cjs: await res.text(), error: null })).catch((e) => ({ error: e, cjs: null }));
  if (error) {
    console.error("Error fetching import", importName, error);
    return;
  }
  try {
    preSuppliedImports[importName] = evalCompiledJs(
      cjs,
      preSuppliedImports
    ).exports;
  } catch (e) {
    console.error("Error importing snippet", e);
  }
}

// lib/utils/resolve-node-module.ts
function createContext(modulePath, fsMap, basePath) {
  return {
    fsMap,
    extensions: [".js", ".jsx", ".ts", ".tsx", ".json"],
    basePath,
    modulePath
  };
}
function findPackageJson(nodeModulesPath, ctx) {
  const packageJsonPath = `${nodeModulesPath}/package.json`;
  if (!ctx.fsMap[packageJsonPath]) return null;
  try {
    return JSON.parse(ctx.fsMap[packageJsonPath]);
  } catch {
    return null;
  }
}
function tryResolveWithExtensions(path, ctx) {
  if (ctx.fsMap[path]) return path;
  for (const ext of ctx.extensions) {
    const pathWithExt = path.replace(/\.js$|\.jsx$/, "") + ext;
    if (ctx.fsMap[pathWithExt]) return pathWithExt;
  }
  return null;
}
function resolveExportPath(nodeModulesPath, exportPath, ctx) {
  const fullExportPath = `${nodeModulesPath}/${exportPath.replace(/^\.\//, "")}`;
  return tryResolveWithExtensions(fullExportPath, ctx);
}
function resolvePackageExports(nodeModulesPath, packageJson, remainingPath, ctx) {
  if (!packageJson.exports) return null;
  const defaultExport = packageJson.exports["."];
  if (remainingPath === "" && defaultExport) {
    if (typeof defaultExport === "string") {
      const resolved = resolveExportPath(nodeModulesPath, defaultExport, ctx);
      if (resolved) return resolved;
    }
  }
  const subpathExport = remainingPath ? packageJson.exports[`./${remainingPath}`] : null;
  if (subpathExport && typeof subpathExport === "string") {
    const resolved = resolveExportPath(nodeModulesPath, subpathExport, ctx);
    if (resolved) return resolved;
  }
  const importExport = packageJson.exports["import"];
  if (remainingPath === "" && importExport && typeof importExport === "string") {
    const resolved = resolveExportPath(nodeModulesPath, importExport, ctx);
    if (resolved) return resolved;
  }
  return null;
}
function resolvePackageEntryPoint(nodeModulesPath, packageJson, ctx) {
  const entryPoint = packageJson.module || packageJson.main || "index.js";
  const fullPath = `${nodeModulesPath}/${entryPoint}`;
  return tryResolveWithExtensions(fullPath, ctx);
}
function resolveRemainingPath(nodeModulesPath, remainingPath, ctx) {
  if (!remainingPath) {
    for (const ext of ctx.extensions) {
      const indexPath = `${nodeModulesPath}/index${ext}`;
      if (ctx.fsMap[indexPath]) return indexPath;
    }
    return null;
  }
  const fullPath = `${nodeModulesPath}/${remainingPath}`;
  const directMatch = tryResolveWithExtensions(fullPath, ctx);
  if (directMatch) return directMatch;
  for (const ext of ctx.extensions) {
    const indexPath = `${fullPath}/index${ext}`;
    if (ctx.fsMap[indexPath]) return indexPath;
  }
  return null;
}
function resolveNodeModuleInPath(searchPath, ctx) {
  const moduleParts = ctx.modulePath.split("/");
  const scope = moduleParts[0].startsWith("@") ? moduleParts.slice(0, 2).join("/") : moduleParts[0];
  const remainingPath = moduleParts.slice(scope.includes("/") ? 2 : 1).join("/");
  const nodeModulesPath = `${searchPath == "." ? "" : `${searchPath}/`}node_modules/${scope}`;
  const packageJson = findPackageJson(nodeModulesPath, ctx);
  if (packageJson) {
    const exportsResolution = resolvePackageExports(
      nodeModulesPath,
      packageJson,
      remainingPath,
      ctx
    );
    if (exportsResolution) return exportsResolution;
    const entryPointResolution = resolvePackageEntryPoint(
      nodeModulesPath,
      packageJson,
      ctx
    );
    if (entryPointResolution) return entryPointResolution;
  }
  const remainingPathResolution = resolveRemainingPath(
    nodeModulesPath,
    remainingPath,
    ctx
  );
  if (remainingPathResolution) return remainingPathResolution;
  const parentPath = dirname(searchPath);
  if (parentPath && parentPath !== searchPath) {
    return resolveNodeModuleInPath(parentPath, ctx);
  }
  return null;
}
function resolveNodeModule(modulePath, fsMap, basePath) {
  const ctx = createContext(modulePath, fsMap, basePath);
  return resolveNodeModuleInPath(ctx.basePath, ctx);
}

// webworker/import-node-module.ts
var importNodeModule = async (importName, ctx, depth = 0) => {
  const { preSuppliedImports } = ctx;
  if (preSuppliedImports[importName]) {
    return;
  }
  const resolvedNodeModulePath = resolveNodeModule(importName, ctx.fsMap, "");
  if (!resolvedNodeModulePath) {
    throw new Error(`Node module "${importName}" not found`);
  }
  await importLocalFile(resolvedNodeModulePath, ctx, depth);
  preSuppliedImports[importName] = preSuppliedImports[resolvedNodeModulePath];
  const unprefixedPath = resolvedNodeModulePath.replace(/^node_modules\//, "");
  preSuppliedImports[unprefixedPath] = preSuppliedImports[resolvedNodeModulePath];
  if (resolvedNodeModulePath.endsWith("/index.tsx") || resolvedNodeModulePath.endsWith("/index.ts") || resolvedNodeModulePath.endsWith("/index.js")) {
    const dirPath = resolvedNodeModulePath.replace(/\/index\.(tsx?|js)$/, "");
    const unprefixedDirPath = dirPath.replace(/^node_modules\//, "");
    preSuppliedImports[unprefixedDirPath] = preSuppliedImports[resolvedNodeModulePath];
    if (unprefixedDirPath.startsWith("@")) {
      const scopeParts = unprefixedDirPath.split("/");
      if (scopeParts.length >= 2) {
        const scopedName = `${scopeParts[0]}/${scopeParts[1]}`;
        preSuppliedImports[scopedName] = preSuppliedImports[resolvedNodeModulePath];
      }
    }
  }
};

// webworker/import-eval-path.ts
import Debug3 from "debug";
var debug3 = Debug3("tsci:eval:import-eval-path");
async function importEvalPath(importName, ctx, depth = 0, opts = {}) {
  debug3("importEvalPath called with:", {
    importName,
    depth,
    opts
  });
  debug3(`${"  ".repeat(depth)}\u27A1\uFE0F`, importName);
  const { preSuppliedImports } = ctx;
  if (preSuppliedImports[importName]) return;
  if (importName.startsWith("./") && preSuppliedImports[importName.slice(2)])
    return;
  if (depth > 5) {
    console.log("Max depth for imports reached");
    return;
  }
  const resolvedLocalImportPath = resolveFilePath(
    importName,
    ctx.fsMap,
    opts.cwd
  );
  if (resolvedLocalImportPath) {
    return importLocalFile(resolvedLocalImportPath, ctx, depth);
  }
  const resolvedNodeModulePath = resolveNodeModule(
    importName,
    ctx.fsMap,
    opts.cwd || ""
  );
  if (resolvedNodeModulePath) {
    return importNodeModule(importName, ctx, depth);
  }
  if (importName.startsWith("@tsci/")) {
    return importSnippet(importName, ctx, depth);
  }
  throw new Error(
    `Unresolved import "${importName}" ${opts.cwd ? `from directory "${opts.cwd}"` : ""}`
  );
}

// lib/runner/setupDefaultEntrypointIfNeeded.ts
import Debug4 from "debug";
var debug4 = Debug4("tsci:eval:setupDefaultEntrypointIfNeeded");
var setupDefaultEntrypointIfNeeded = (opts) => {
  if (!opts.entrypoint && !opts.mainComponentPath) {
    if ("index.tsx" in opts.fsMap) {
      opts.mainComponentPath = "index.tsx";
    } else if ("index.ts" in opts.fsMap) {
      opts.mainComponentPath = "index.ts";
    } else if (Object.keys(opts.fsMap).filter((k) => k.endsWith(".tsx")).length === 1) {
      opts.mainComponentPath = Object.keys(opts.fsMap)[0];
    } else if ("tscircuit.config.json" in opts.fsMap) {
      const configContent = opts.fsMap["tscircuit.config.json"];
      try {
        const config = JSON.parse(configContent);
        if (config.mainEntrypoint) {
          opts.entrypoint = config.mainEntrypoint;
        }
      } catch (e) {
        console.warn("Failed to parse tscircuit.config.json:", e);
      }
    } else {
      throw new Error(
        "Either entrypoint or mainComponentPath must be provided (no index file, could not infer entrypoint)"
      );
    }
  }
  if (!opts.entrypoint && opts.mainComponentPath) {
    opts.entrypoint = "entrypoint.tsx";
    const mainComponentCode = opts.fsMap[resolveFilePathOrThrow(opts.mainComponentPath, opts.fsMap)];
    if (!mainComponentCode) {
      throw new Error(
        `Main component path "${opts.mainComponentPath}" not found in fsMap. Available paths: ${Object.keys(opts.fsMap).join(", ")}`
      );
    }
    const hasExplicitBoard = mainComponentCode.includes("<board");
    const hasTsciImport = mainComponentCode.includes("@tsci/") || mainComponentCode.includes('from "@tsci');
    const shouldWrapInBoard = !hasExplicitBoard && !hasTsciImport;
    opts.fsMap[opts.entrypoint] = `
     import * as UserComponents from "./${opts.mainComponentPath}";
          
      ${opts.mainComponentName ? `
        const ComponentToRender = UserComponents["${opts.mainComponentName}"]
        ` : `const ComponentToRender = Object.entries(UserComponents)
        .filter(([name]) => !name.startsWith("use"))
        .map(([_, component]) => component)[0] || (() => null);`}

           ${debug4.enabled ? `
     console.log({ UserComponents })
     console.log("ComponentToRender " + ComponentToRender.toString(),  { ComponentToRender })
     ` : ""}

      circuit.add(
        ${shouldWrapInBoard ? `
          <board>
            <ComponentToRender name="U1" ${opts.mainComponentProps ? `{...${JSON.stringify(opts.mainComponentProps, null, 2)}}` : ""} />
          </board>
        ` : `
          <ComponentToRender ${opts.mainComponentProps ? `{...${JSON.stringify(opts.mainComponentProps, null, 2)}}` : ""} />
        `}
      );
`;
  }
  if (!opts.name && opts.mainComponentName) {
    opts.name = opts.mainComponentName;
  }
};

// lib/runner/CircuitRunner.ts
import Debug5 from "debug";
var debug5 = Debug5("tsci:eval:CircuitRunner");
var CircuitRunner = class {
  constructor(configuration = {}) {
    this._executionContext = null;
    this._circuitRunnerConfiguration = {
      snippetsApiBaseUrl: "https://registry-api.tscircuit.com",
      cjsRegistryUrl: "https://cjs.tscircuit.com",
      verbose: false
    };
    this._eventListeners = {};
    Object.assign(this._circuitRunnerConfiguration, configuration);
  }
  async executeWithFsMap(ogOpts) {
    const opts = { ...ogOpts };
    if (this._circuitRunnerConfiguration.verbose) {
      Debug5.enable("tsci:eval:*");
    }
    debug5("executeWithFsMap called with:", {
      entrypoint: opts.entrypoint,
      fsMapKeys: Object.keys(opts.fsMap),
      name: opts.name
    });
    setupDefaultEntrypointIfNeeded(opts);
    debug5("entrypoint after setupDefaultEntrypointIfNeeded:", {
      entrypoint: opts.entrypoint
    });
    this._executionContext = createExecutionContext(
      this._circuitRunnerConfiguration,
      {
        name: opts.name,
        platform: this._circuitRunnerConfiguration.platform
      }
    );
    this._bindEventListeners(this._executionContext.circuit);
    this._executionContext.fsMap = normalizeFsMap(opts.fsMap);
    if (!this._executionContext.fsMap[opts.entrypoint]) {
      throw new Error(`Entrypoint "${opts.entrypoint}" not found`);
    }
    ;
    globalThis.__tscircuit_circuit = this._executionContext.circuit;
    const entrypoint = opts.entrypoint.startsWith("./") ? opts.entrypoint : `./${opts.entrypoint}`;
    debug5("final entrypoint:", entrypoint);
    await importEvalPath(entrypoint, this._executionContext);
  }
  async execute(code, opts = {}) {
    if (this._circuitRunnerConfiguration.verbose) {
      console.log(
        "[CircuitRunner] execute called with code length:",
        code.length
      );
    }
    this._executionContext = createExecutionContext(
      this._circuitRunnerConfiguration,
      {
        ...opts,
        platform: this._circuitRunnerConfiguration.platform
      }
    );
    this._bindEventListeners(this._executionContext.circuit);
    this._executionContext.fsMap["entrypoint.tsx"] = code;
    globalThis.__tscircuit_circuit = this._executionContext.circuit;
    await importEvalPath("./entrypoint.tsx", this._executionContext);
  }
  on(event, callback) {
    var _a;
    (_a = this._eventListeners)[event] ?? (_a[event] = []);
    this._eventListeners[event].push(callback);
    this._executionContext?.circuit.on(event, callback);
  }
  async renderUntilSettled() {
    if (!this._executionContext) {
      throw new Error("No circuit has been created");
    }
    await this._executionContext.circuit.renderUntilSettled();
  }
  async getCircuitJson() {
    if (!this._executionContext) {
      throw new Error("No circuit has been created");
    }
    return this._executionContext.circuit.getCircuitJson();
  }
  clearEventListeners() {
    if (this._executionContext?.circuit) {
      for (const event in this._eventListeners) {
        for (const listener of this._eventListeners[event]) {
          const circuit = this._executionContext.circuit;
          circuit.removeListener?.(event, listener);
        }
      }
    }
    for (const event in this._eventListeners) {
      delete this._eventListeners[event];
    }
  }
  async kill() {
    this._executionContext = null;
  }
  async setSnippetsApiBaseUrl(baseUrl) {
    this._circuitRunnerConfiguration.snippetsApiBaseUrl = baseUrl;
  }
  async setPlatformConfig(platform) {
    this._circuitRunnerConfiguration.platform = platform;
  }
  _bindEventListeners(circuit) {
    for (const event in this._eventListeners) {
      for (const listener of this._eventListeners[event]) {
        circuit.on(event, listener);
      }
    }
  }
};

// lib/runner/runTscircuitCode.ts
async function runTscircuitCode(filesystemOrCodeString, opts) {
  if (typeof filesystemOrCodeString === "string" && !filesystemOrCodeString.includes("export")) {
    throw new Error(
      `The "export" keyword wasn't found in your provided code. You need to export a component in your code, e.g.

export default () => (
  <resistor name="R1" resistance="1k" />
)`
    );
  }
  const filesystem = typeof filesystemOrCodeString === "string" ? { "user-code.tsx": filesystemOrCodeString } : filesystemOrCodeString;
  const circuitRunner = new CircuitRunner();
  await circuitRunner.executeWithFsMap({
    fsMap: filesystem,
    ...opts
  });
  await circuitRunner.renderUntilSettled();
  return await circuitRunner.getCircuitJson();
}

// lib/runner/runTscircuitModule.ts
var runTscircuitModule = async (module, opts = {}) => {
  if (!module.startsWith("@")) {
    module = `@tsci/${module.replace(/\//, ".")}`;
  }
  const circuitJson = await runTscircuitCode(
    {
      // TODO handle exports that are not the default export by scanning
      // otherExports for components
      "user-code.tsx": `
    import Module, * as otherExports from "${module}";

    let exportName = "${opts.exportName ?? ""}"

    if ((!Module || typeof Module !== "function") && !Boolean(exportName)) {
      exportName = Object.keys(otherExports).filter(key => key[0] === key[0].toUpperCase() && typeof otherExports[key] === "function")[0]
    }

    const defaultExport = exportName ? otherExports[exportName] : Module

    if (!defaultExport) {
      throw new Error(\`No export found for module "\${module}" (tried "\${exportName ?? "default"}")\`)
    }

    export default defaultExport;
    `
    },
    {
      mainComponentProps: opts.props
    }
  );
  return circuitJson;
};
export {
  CircuitRunner,
  runTscircuitCode,
  runTscircuitModule
};
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsiLi4vLi4vd2Vid29ya2VyL2V4ZWN1dGlvbi1jb250ZXh0LnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AdHNjaXJjdWl0L3BhcnRzLWVuZ2luZS9saWIvamxjLXBhcnRzLWVuZ2luZS50cyIsICIuLi8uLi9saWIvZ2V0UGxhdGZvcm1Db25maWcudHMiLCAiLi4vLi4vbGliL3J1bm5lci9ub3JtYWxpemVGc01hcC50cyIsICIuLi8uLi9saWIvcnVubmVyL0NpcmN1aXRSdW5uZXIudHMiLCAiLi4vLi4vbGliL3V0aWxzL2Rpcm5hbWUudHMiLCAiLi4vLi4vbGliL3J1bm5lci9yZXNvbHZlRmlsZVBhdGgudHMiLCAiLi4vLi4vd2Vid29ya2VyL2V2YWwtY29tcGlsZWQtanMudHMiLCAiLi4vLi4vd2Vid29ya2VyL2ltcG9ydC1ldmFsLXBhdGgudHMiLCAiLi4vLi4vd2Vid29ya2VyL2ltcG9ydC1sb2NhbC1maWxlLnRzIiwgIi4uLy4uL2xpYi91dGlscy9nZXQtaW1wb3J0cy1mcm9tLWNvZGUudHMiLCAiLi4vLi4vd2Vid29ya2VyL2ltcG9ydC1zbmlwcGV0LnRzIiwgIi4uLy4uL2xpYi91dGlscy9yZXNvbHZlLW5vZGUtbW9kdWxlLnRzIiwgIi4uLy4uL3dlYndvcmtlci9pbXBvcnQtbm9kZS1tb2R1bGUudHMiLCAiLi4vLi4vbGliL3J1bm5lci9zZXR1cERlZmF1bHRFbnRyeXBvaW50SWZOZWVkZWQudHMiLCAiLi4vLi4vbGliL3J1bm5lci9ydW5Uc2NpcmN1aXRDb2RlLnRzIiwgIi4uLy4uL2xpYi9ydW5uZXIvcnVuVHNjaXJjdWl0TW9kdWxlLnRzIl0sCiAgInNvdXJjZXNDb250ZW50IjogWyJpbXBvcnQgeyBSb290Q2lyY3VpdCB9IGZyb20gXCJAdHNjaXJjdWl0L2NvcmVcIlxuaW1wb3J0IHR5cGUgeyBXZWJXb3JrZXJDb25maWd1cmF0aW9uIH0gZnJvbSBcImxpYi9zaGFyZWQvdHlwZXNcIlxuaW1wb3J0ICogYXMgdHNjaXJjdWl0Q29yZSBmcm9tIFwiQHRzY2lyY3VpdC9jb3JlXCJcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gXCJyZWFjdFwiXG5pbXBvcnQgKiBhcyBqc2NhZEZpYmVyIGZyb20gXCJqc2NhZC1maWJlclwiXG5pbXBvcnQgKiBhcyB0c2NpcmN1aXRNYXRoVXRpbHMgZnJvbSBcIkB0c2NpcmN1aXQvbWF0aC11dGlsc1wiXG5pbXBvcnQgdHlwZSB7IFBsYXRmb3JtQ29uZmlnIH0gZnJvbSBcIkB0c2NpcmN1aXQvcHJvcHNcIlxuaW1wb3J0IHsgZ2V0UGxhdGZvcm1Db25maWcgfSBmcm9tIFwibGliL2dldFBsYXRmb3JtQ29uZmlnXCJcbmltcG9ydCBEZWJ1ZyBmcm9tIFwiZGVidWdcIlxuXG5jb25zdCBkZWJ1ZyA9IERlYnVnKFwidHNjaTpldmFsOmV4ZWN1dGlvbi1jb250ZXh0XCIpXG5cbmV4cG9ydCBpbnRlcmZhY2UgRXhlY3V0aW9uQ29udGV4dCBleHRlbmRzIFdlYldvcmtlckNvbmZpZ3VyYXRpb24ge1xuICBmc01hcDogUmVjb3JkPHN0cmluZywgc3RyaW5nPlxuICBlbnRyeXBvaW50OiBzdHJpbmdcbiAgcHJlU3VwcGxpZWRJbXBvcnRzOiBSZWNvcmQ8c3RyaW5nLCBhbnk+XG4gIGNpcmN1aXQ6IFJvb3RDaXJjdWl0XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVFeGVjdXRpb25Db250ZXh0KFxuICB3ZWJXb3JrZXJDb25maWd1cmF0aW9uOiBXZWJXb3JrZXJDb25maWd1cmF0aW9uLFxuICBvcHRzOiB7XG4gICAgbmFtZT86IHN0cmluZ1xuICAgIHBsYXRmb3JtPzogUGxhdGZvcm1Db25maWdcbiAgfSA9IHt9LFxuKTogRXhlY3V0aW9uQ29udGV4dCB7XG4gIGdsb2JhbFRoaXMuUmVhY3QgPSBSZWFjdFxuXG4gIGNvbnN0IGNpcmN1aXQgPSBuZXcgUm9vdENpcmN1aXQoe1xuICAgIHBsYXRmb3JtOiBvcHRzLnBsYXRmb3JtIHx8IGdldFBsYXRmb3JtQ29uZmlnKCksXG4gIH0pXG5cbiAgaWYgKG9wdHMubmFtZSkge1xuICAgIGNpcmN1aXQubmFtZSA9IG9wdHMubmFtZVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBmc01hcDoge30sXG4gICAgZW50cnlwb2ludDogXCJcIixcbiAgICBwcmVTdXBwbGllZEltcG9ydHM6IHtcbiAgICAgIFwiQHRzY2lyY3VpdC9jb3JlXCI6IHRzY2lyY3VpdENvcmUsXG4gICAgICB0c2NpcmN1aXQ6IHRzY2lyY3VpdENvcmUsXG4gICAgICBcIkB0c2NpcmN1aXQvbWF0aC11dGlsc1wiOiB0c2NpcmN1aXRNYXRoVXRpbHMsXG4gICAgICByZWFjdDogUmVhY3QsXG4gICAgICBcImpzY2FkLWZpYmVyXCI6IGpzY2FkRmliZXIsXG5cbiAgICAgIC8vIFRoaXMgaXMgdXN1YWxseSB1c2VkIGFzIGEgdHlwZSBpbXBvcnQsIHdlIGNhbiByZW1vdmUgdGhlIHNoaW0gd2hlbiB3ZVxuICAgICAgLy8gaWdub3JlIHR5cGUgaW1wb3J0cyBpbiBnZXRJbXBvcnRzRnJvbUNvZGVcbiAgICAgIFwiQHRzY2lyY3VpdC9wcm9wc1wiOiB7fSxcbiAgICB9LFxuICAgIGNpcmN1aXQsXG4gICAgLi4ud2ViV29ya2VyQ29uZmlndXJhdGlvbixcbiAgfVxufVxuIiwgImltcG9ydCB0eXBlIHsgUGFydHNFbmdpbmUsIFN1cHBsaWVyUGFydE51bWJlcnMgfSBmcm9tIFwiQHRzY2lyY3VpdC9wcm9wc1wiXG5cbmNvbnN0IGNhY2hlID0gbmV3IE1hcDxzdHJpbmcsIGFueT4oKVxuXG5jb25zdCBnZXRKbGNQYXJ0c0NhY2hlZCA9IGFzeW5jIChuYW1lOiBhbnksIHBhcmFtczogYW55KSA9PiB7XG4gIGNvbnN0IHBhcmFtU3RyaW5nID0gbmV3IFVSTFNlYXJjaFBhcmFtcyh7XG4gICAgLi4ucGFyYW1zLFxuICAgIGpzb246IFwidHJ1ZVwiLFxuICB9KS50b1N0cmluZygpXG4gIGlmIChjYWNoZS5oYXMocGFyYW1TdHJpbmcpKSB7XG4gICAgcmV0dXJuIGNhY2hlLmdldChwYXJhbVN0cmluZylcbiAgfVxuICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKFxuICAgIGBodHRwczovL2psY3NlYXJjaC50c2NpcmN1aXQuY29tLyR7bmFtZX0vbGlzdD8ke3BhcmFtU3RyaW5nfWAsXG4gIClcbiAgY29uc3QgcmVzcG9uc2VKc29uID0gYXdhaXQgcmVzcG9uc2UuanNvbigpXG4gIGNhY2hlLnNldChwYXJhbVN0cmluZywgcmVzcG9uc2VKc29uKVxuICByZXR1cm4gcmVzcG9uc2VKc29uXG59XG5cbmV4cG9ydCBjb25zdCBqbGNQYXJ0c0VuZ2luZTogUGFydHNFbmdpbmUgPSB7XG4gIGZpbmRQYXJ0OiBhc3luYyAoe1xuICAgIHNvdXJjZUNvbXBvbmVudCxcbiAgICBmb290cHJpbnRlclN0cmluZyxcbiAgfSk6IFByb21pc2U8U3VwcGxpZXJQYXJ0TnVtYmVycz4gPT4ge1xuICAgIGlmIChcbiAgICAgIHNvdXJjZUNvbXBvbmVudC50eXBlID09PSBcInNvdXJjZV9jb21wb25lbnRcIiAmJlxuICAgICAgc291cmNlQ29tcG9uZW50LmZ0eXBlID09PSBcInNpbXBsZV9yZXNpc3RvclwiXG4gICAgKSB7XG4gICAgICBjb25zdCB7IHJlc2lzdG9ycyB9ID0gYXdhaXQgZ2V0SmxjUGFydHNDYWNoZWQoXCJyZXNpc3RvcnNcIiwge1xuICAgICAgICByZXNpc3RhbmNlOlxuICAgICAgICAgIHNvdXJjZUNvbXBvbmVudC5kaXNwbGF5X3Jlc2lzdGFuY2UgPz8gc291cmNlQ29tcG9uZW50LnJlc2lzdGFuY2UsXG4gICAgICAgIHBhY2thZ2U6IGZvb3RwcmludGVyU3RyaW5nLFxuICAgICAgfSlcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgamxjcGNiOiAocmVzaXN0b3JzID8/IFtdKS5tYXAoKHI6IGFueSkgPT4gYEMke3IubGNzY31gKS5zbGljZSgwLCAzKSxcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKFxuICAgICAgc291cmNlQ29tcG9uZW50LnR5cGUgPT09IFwic291cmNlX2NvbXBvbmVudFwiICYmXG4gICAgICBzb3VyY2VDb21wb25lbnQuZnR5cGUgPT09IFwic2ltcGxlX2NhcGFjaXRvclwiXG4gICAgKSB7XG4gICAgICBpZiAoZm9vdHByaW50ZXJTdHJpbmc/LmluY2x1ZGVzKFwiY2FwXCIpKSB7XG4gICAgICAgIGZvb3RwcmludGVyU3RyaW5nID0gZm9vdHByaW50ZXJTdHJpbmcucmVwbGFjZShcImNhcFwiLCBcIlwiKVxuICAgICAgfVxuICAgICAgY29uc3QgeyBjYXBhY2l0b3JzIH0gPSBhd2FpdCBnZXRKbGNQYXJ0c0NhY2hlZChcImNhcGFjaXRvcnNcIiwge1xuICAgICAgICBjYXBhY2l0YW5jZTpcbiAgICAgICAgICBzb3VyY2VDb21wb25lbnQuZGlzcGxheV9jYXBhY2l0YW5jZSA/PyBzb3VyY2VDb21wb25lbnQuY2FwYWNpdGFuY2UsXG4gICAgICAgIHBhY2thZ2U6IGZvb3RwcmludGVyU3RyaW5nLFxuICAgICAgfSlcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgamxjcGNiOiAoY2FwYWNpdG9ycyA/PyBbXSkubWFwKChjOiBhbnkpID0+IGBDJHtjLmxjc2N9YCkuc2xpY2UoMCwgMyksXG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChcbiAgICAgIHNvdXJjZUNvbXBvbmVudC50eXBlID09PSBcInNvdXJjZV9jb21wb25lbnRcIiAmJlxuICAgICAgc291cmNlQ29tcG9uZW50LmZ0eXBlID09PSBcInNpbXBsZV9waW5faGVhZGVyXCJcbiAgICApIHtcbiAgICAgIGxldCBwaXRjaDogbnVtYmVyIHwgdW5kZWZpbmVkXG4gICAgICBpZiAoZm9vdHByaW50ZXJTdHJpbmc/LmluY2x1ZGVzKFwiX3BcIikpIHtcbiAgICAgICAgcGl0Y2ggPSBOdW1iZXIoZm9vdHByaW50ZXJTdHJpbmcuc3BsaXQoXCJfcFwiKVsxXSlcbiAgICAgIH1cbiAgICAgIGNvbnN0IHsgaGVhZGVycyB9ID0gYXdhaXQgZ2V0SmxjUGFydHNDYWNoZWQoXG4gICAgICAgIFwiaGVhZGVyc1wiLFxuICAgICAgICBwaXRjaFxuICAgICAgICAgID8ge1xuICAgICAgICAgICAgICBwaXRjaDogcGl0Y2gsXG4gICAgICAgICAgICAgIG51bV9waW5zOiBzb3VyY2VDb21wb25lbnQucGluX2NvdW50LFxuICAgICAgICAgICAgICBnZW5kZXI6IHNvdXJjZUNvbXBvbmVudC5nZW5kZXIsXG4gICAgICAgICAgICB9XG4gICAgICAgICAgOiB7XG4gICAgICAgICAgICAgIG51bV9waW5zOiBzb3VyY2VDb21wb25lbnQucGluX2NvdW50LFxuICAgICAgICAgICAgICBnZW5kZXI6IHNvdXJjZUNvbXBvbmVudC5nZW5kZXIsXG4gICAgICAgICAgICB9LFxuICAgICAgKVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgamxjcGNiOiAoaGVhZGVycyA/PyBbXSkubWFwKChoOiBhbnkpID0+IGBDJHtoLmxjc2N9YCkuc2xpY2UoMCwgMyksXG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChcbiAgICAgIHNvdXJjZUNvbXBvbmVudC50eXBlID09PSBcInNvdXJjZV9jb21wb25lbnRcIiAmJlxuICAgICAgc291cmNlQ29tcG9uZW50LmZ0eXBlID09PSBcInNpbXBsZV9wb3RlbnRpb21ldGVyXCJcbiAgICApIHtcbiAgICAgIGNvbnN0IHsgcG90ZW50aW9tZXRlcnMgfSA9IGF3YWl0IGdldEpsY1BhcnRzQ2FjaGVkKFwicG90ZW50aW9tZXRlcnNcIiwge1xuICAgICAgICByZXNpc3RhbmNlOiBzb3VyY2VDb21wb25lbnQubWF4X3Jlc2lzdGFuY2UsXG4gICAgICAgIHBhY2thZ2U6IGZvb3RwcmludGVyU3RyaW5nLFxuICAgICAgfSlcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGpsY3BjYjogKHBvdGVudGlvbWV0ZXJzID8/IFtdKVxuICAgICAgICAgIC5tYXAoKHA6IGFueSkgPT4gYEMke3AubGNzY31gKVxuICAgICAgICAgIC5zbGljZSgwLCAzKSxcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKFxuICAgICAgc291cmNlQ29tcG9uZW50LnR5cGUgPT09IFwic291cmNlX2NvbXBvbmVudFwiICYmXG4gICAgICBzb3VyY2VDb21wb25lbnQuZnR5cGUgPT09IFwic2ltcGxlX2Rpb2RlXCJcbiAgICApIHtcbiAgICAgIGNvbnN0IHsgZGlvZGVzIH0gPSBhd2FpdCBnZXRKbGNQYXJ0c0NhY2hlZChcImRpb2Rlc1wiLCB7XG4gICAgICAgIHBhY2thZ2U6IGZvb3RwcmludGVyU3RyaW5nLFxuICAgICAgfSlcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGpsY3BjYjogKGRpb2RlcyA/PyBbXSkubWFwKChkOiBhbnkpID0+IGBDJHtkLmxjc2N9YCkuc2xpY2UoMCwgMyksXG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChcbiAgICAgIHNvdXJjZUNvbXBvbmVudC50eXBlID09PSBcInNvdXJjZV9jb21wb25lbnRcIiAmJlxuICAgICAgc291cmNlQ29tcG9uZW50LmZ0eXBlID09PSBcInNpbXBsZV9jaGlwXCJcbiAgICApIHtcbiAgICAgIGNvbnN0IHsgY2hpcHMgfSA9IGF3YWl0IGdldEpsY1BhcnRzQ2FjaGVkKFwiY2hpcHNcIiwge1xuICAgICAgICBwYWNrYWdlOiBmb290cHJpbnRlclN0cmluZyxcbiAgICAgIH0pXG4gICAgICByZXR1cm4ge1xuICAgICAgICBqbGNwY2I6IChjaGlwcyA/PyBbXSkubWFwKChjOiBhbnkpID0+IGBDJHtjLmxjc2N9YCkuc2xpY2UoMCwgMyksXG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChcbiAgICAgIHNvdXJjZUNvbXBvbmVudC50eXBlID09PSBcInNvdXJjZV9jb21wb25lbnRcIiAmJlxuICAgICAgc291cmNlQ29tcG9uZW50LmZ0eXBlID09PSBcInNpbXBsZV90cmFuc2lzdG9yXCJcbiAgICApIHtcbiAgICAgIGNvbnN0IHsgdHJhbnNpc3RvcnMgfSA9IGF3YWl0IGdldEpsY1BhcnRzQ2FjaGVkKFwidHJhbnNpc3RvcnNcIiwge1xuICAgICAgICBwYWNrYWdlOiBmb290cHJpbnRlclN0cmluZyxcbiAgICAgICAgdHJhbnNpc3Rvcl90eXBlOiBzb3VyY2VDb21wb25lbnQudHJhbnNpc3Rvcl90eXBlLFxuICAgICAgfSlcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGpsY3BjYjogKHRyYW5zaXN0b3JzID8/IFtdKS5tYXAoKHQ6IGFueSkgPT4gYEMke3QubGNzY31gKS5zbGljZSgwLCAzKSxcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKFxuICAgICAgc291cmNlQ29tcG9uZW50LnR5cGUgPT09IFwic291cmNlX2NvbXBvbmVudFwiICYmXG4gICAgICBzb3VyY2VDb21wb25lbnQuZnR5cGUgPT09IFwic2ltcGxlX3Bvd2VyX3NvdXJjZVwiXG4gICAgKSB7XG4gICAgICBjb25zdCB7IHBvd2VyX3NvdXJjZXMgfSA9IGF3YWl0IGdldEpsY1BhcnRzQ2FjaGVkKFwicG93ZXJfc291cmNlc1wiLCB7XG4gICAgICAgIHZvbHRhZ2U6IHNvdXJjZUNvbXBvbmVudC52b2x0YWdlLFxuICAgICAgICBwYWNrYWdlOiBmb290cHJpbnRlclN0cmluZyxcbiAgICAgIH0pXG4gICAgICByZXR1cm4ge1xuICAgICAgICBqbGNwY2I6IChwb3dlcl9zb3VyY2VzID8/IFtdKS5tYXAoKHA6IGFueSkgPT4gYEMke3AubGNzY31gKS5zbGljZSgwLCAzKSxcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKFxuICAgICAgc291cmNlQ29tcG9uZW50LnR5cGUgPT09IFwic291cmNlX2NvbXBvbmVudFwiICYmXG4gICAgICBzb3VyY2VDb21wb25lbnQuZnR5cGUgPT09IFwic2ltcGxlX2luZHVjdG9yXCJcbiAgICApIHtcbiAgICAgIGNvbnN0IHsgaW5kdWN0b3JzIH0gPSBhd2FpdCBnZXRKbGNQYXJ0c0NhY2hlZChcImluZHVjdG9yc1wiLCB7XG4gICAgICAgIGluZHVjdGFuY2U6IHNvdXJjZUNvbXBvbmVudC5pbmR1Y3RhbmNlLFxuICAgICAgICBwYWNrYWdlOiBmb290cHJpbnRlclN0cmluZyxcbiAgICAgIH0pXG4gICAgICByZXR1cm4ge1xuICAgICAgICBqbGNwY2I6IChpbmR1Y3RvcnMgPz8gW10pLm1hcCgoaTogYW55KSA9PiBgQyR7aS5sY3NjfWApLnNsaWNlKDAsIDMpLFxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoXG4gICAgICBzb3VyY2VDb21wb25lbnQudHlwZSA9PT0gXCJzb3VyY2VfY29tcG9uZW50XCIgJiZcbiAgICAgIHNvdXJjZUNvbXBvbmVudC5mdHlwZSA9PT0gXCJzaW1wbGVfY3J5c3RhbFwiXG4gICAgKSB7XG4gICAgICBjb25zdCB7IGNyeXN0YWxzIH0gPSBhd2FpdCBnZXRKbGNQYXJ0c0NhY2hlZChcImNyeXN0YWxzXCIsIHtcbiAgICAgICAgZnJlcXVlbmN5OiBzb3VyY2VDb21wb25lbnQuZnJlcXVlbmN5LFxuICAgICAgICBsb2FkX2NhcGFjaXRhbmNlOiBzb3VyY2VDb21wb25lbnQubG9hZF9jYXBhY2l0YW5jZSxcbiAgICAgICAgcGFja2FnZTogZm9vdHByaW50ZXJTdHJpbmcsXG4gICAgICB9KVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgamxjcGNiOiAoY3J5c3RhbHMgPz8gW10pLm1hcCgoYzogYW55KSA9PiBgQyR7Yy5sY3NjfWApLnNsaWNlKDAsIDMpLFxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoXG4gICAgICBzb3VyY2VDb21wb25lbnQudHlwZSA9PT0gXCJzb3VyY2VfY29tcG9uZW50XCIgJiZcbiAgICAgIHNvdXJjZUNvbXBvbmVudC5mdHlwZSA9PT0gXCJzaW1wbGVfbW9zZmV0XCJcbiAgICApIHtcbiAgICAgIGNvbnN0IHsgbW9zZmV0cyB9ID0gYXdhaXQgZ2V0SmxjUGFydHNDYWNoZWQoXCJtb3NmZXRzXCIsIHtcbiAgICAgICAgcGFja2FnZTogZm9vdHByaW50ZXJTdHJpbmcsXG4gICAgICAgIG1vc2ZldF9tb2RlOiBzb3VyY2VDb21wb25lbnQubW9zZmV0X21vZGUsXG4gICAgICAgIGNoYW5uZWxfdHlwZTogc291cmNlQ29tcG9uZW50LmNoYW5uZWxfdHlwZSxcbiAgICAgIH0pXG4gICAgICByZXR1cm4ge1xuICAgICAgICBqbGNwY2I6IChtb3NmZXRzID8/IFtdKS5tYXAoKG06IGFueSkgPT4gYEMke20ubGNzY31gKS5zbGljZSgwLCAzKSxcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKFxuICAgICAgc291cmNlQ29tcG9uZW50LnR5cGUgPT09IFwic291cmNlX2NvbXBvbmVudFwiICYmXG4gICAgICBzb3VyY2VDb21wb25lbnQuZnR5cGUgPT09IFwic2ltcGxlX3Jlc29uYXRvclwiXG4gICAgKSB7XG4gICAgICBjb25zdCB7IHJlc29uYXRvcnMgfSA9IGF3YWl0IGdldEpsY1BhcnRzQ2FjaGVkKFwicmVzb25hdG9yc1wiLCB7XG4gICAgICAgIGZyZXF1ZW5jeTogc291cmNlQ29tcG9uZW50LmZyZXF1ZW5jeSxcbiAgICAgICAgcGFja2FnZTogZm9vdHByaW50ZXJTdHJpbmcsXG4gICAgICB9KVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgamxjcGNiOiAocmVzb25hdG9ycyA/PyBbXSkubWFwKChyOiBhbnkpID0+IGBDJHtyLmxjc2N9YCkuc2xpY2UoMCwgMyksXG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChcbiAgICAgIHNvdXJjZUNvbXBvbmVudC50eXBlID09PSBcInNvdXJjZV9jb21wb25lbnRcIiAmJlxuICAgICAgc291cmNlQ29tcG9uZW50LmZ0eXBlID09PSBcInNpbXBsZV9zd2l0Y2hcIlxuICAgICkge1xuICAgICAgY29uc3QgeyBzd2l0Y2hlcyB9ID0gYXdhaXQgZ2V0SmxjUGFydHNDYWNoZWQoXCJzd2l0Y2hlc1wiLCB7XG4gICAgICAgIHN3aXRjaF90eXBlOiBzb3VyY2VDb21wb25lbnQudHlwZSxcbiAgICAgICAgcGFja2FnZTogZm9vdHByaW50ZXJTdHJpbmcsXG4gICAgICB9KVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgamxjcGNiOiAoc3dpdGNoZXMgPz8gW10pLm1hcCgoczogYW55KSA9PiBgQyR7cy5sY3NjfWApLnNsaWNlKDAsIDMpLFxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoXG4gICAgICBzb3VyY2VDb21wb25lbnQudHlwZSA9PT0gXCJzb3VyY2VfY29tcG9uZW50XCIgJiZcbiAgICAgIHNvdXJjZUNvbXBvbmVudC5mdHlwZSA9PT0gXCJzaW1wbGVfbGVkXCJcbiAgICApIHtcbiAgICAgIGNvbnN0IHsgbGVkcyB9ID0gYXdhaXQgZ2V0SmxjUGFydHNDYWNoZWQoXCJsZWRzXCIsIHtcbiAgICAgICAgcGFja2FnZTogZm9vdHByaW50ZXJTdHJpbmcsXG4gICAgICB9KVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgamxjcGNiOiAobGVkcyA/PyBbXSkubWFwKChsOiBhbnkpID0+IGBDJHtsLmxjc2N9YCkuc2xpY2UoMCwgMyksXG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChcbiAgICAgIHNvdXJjZUNvbXBvbmVudC50eXBlID09PSBcInNvdXJjZV9jb21wb25lbnRcIiAmJlxuICAgICAgc291cmNlQ29tcG9uZW50LmZ0eXBlID09PSBcInNpbXBsZV9mdXNlXCJcbiAgICApIHtcbiAgICAgIGNvbnN0IHsgZnVzZXMgfSA9IGF3YWl0IGdldEpsY1BhcnRzQ2FjaGVkKFwiZnVzZXNcIiwge1xuICAgICAgICBwYWNrYWdlOiBmb290cHJpbnRlclN0cmluZyxcbiAgICAgIH0pXG4gICAgICByZXR1cm4ge1xuICAgICAgICBqbGNwY2I6IChmdXNlcyA/PyBbXSkubWFwKChsOiBhbnkpID0+IGBDJHtsLmxjc2N9YCkuc2xpY2UoMCwgMyksXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7fVxuICB9LFxufVxuIiwgImltcG9ydCB0eXBlIHsgUGxhdGZvcm1Db25maWcgfSBmcm9tIFwiQHRzY2lyY3VpdC9wcm9wc1wiXG5pbXBvcnQgeyBqbGNQYXJ0c0VuZ2luZSB9IGZyb20gXCJAdHNjaXJjdWl0L3BhcnRzLWVuZ2luZVwiXG5cbmV4cG9ydCBjb25zdCBnZXRQbGF0Zm9ybUNvbmZpZyA9ICgpOiBQbGF0Zm9ybUNvbmZpZyA9PiAoe1xuICBwYXJ0c0VuZ2luZTogamxjUGFydHNFbmdpbmUsXG59KVxuIiwgImV4cG9ydCBmdW5jdGlvbiBub3JtYWxpemVGaWxlUGF0aChmaWxlUGF0aDogc3RyaW5nKSB7XG4gIGxldCBub3JtRmlsZVBhdGggPSBmaWxlUGF0aFxuICBub3JtRmlsZVBhdGggPSBub3JtRmlsZVBhdGgucmVwbGFjZSgvXFxcXC9nLCBcIi9cIilcbiAgbm9ybUZpbGVQYXRoID0gbm9ybUZpbGVQYXRoLnRyaW0oKVxuICBpZiAobm9ybUZpbGVQYXRoLnN0YXJ0c1dpdGgoXCIuL1wiKSkge1xuICAgIG5vcm1GaWxlUGF0aCA9IG5vcm1GaWxlUGF0aC5zbGljZSgyKVxuICB9XG4gIGlmIChub3JtRmlsZVBhdGguc3RhcnRzV2l0aChcIi9cIikpIHtcbiAgICBub3JtRmlsZVBhdGggPSBub3JtRmlsZVBhdGguc2xpY2UoMSlcbiAgfVxuICByZXR1cm4gbm9ybUZpbGVQYXRoXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBub3JtYWxpemVGc01hcChmc01hcDogUmVjb3JkPHN0cmluZywgc3RyaW5nPikge1xuICBjb25zdCBub3JtYWxpemVkRnNNYXA6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4gPSB7fVxuICBmb3IgKGNvbnN0IFtmc1BhdGgsIGZpbGVDb250ZW50XSBvZiBPYmplY3QuZW50cmllcyhmc01hcCkpIHtcbiAgICBub3JtYWxpemVkRnNNYXBbbm9ybWFsaXplRmlsZVBhdGgoZnNQYXRoKV0gPSBmaWxlQ29udGVudFxuICB9XG4gIHJldHVybiBub3JtYWxpemVkRnNNYXBcbn1cbiIsICJpbXBvcnQgdHlwZSB7IEFueUNpcmN1aXRFbGVtZW50IH0gZnJvbSBcImNpcmN1aXQtanNvblwiXG5pbXBvcnQgdHlwZSB7XG4gIENpcmN1aXRSdW5uZXJBcGksXG4gIENpcmN1aXRSdW5uZXJDb25maWd1cmF0aW9uLFxufSBmcm9tIFwibGliL3NoYXJlZC90eXBlc1wiXG5pbXBvcnQgdHlwZSB7IFBsYXRmb3JtQ29uZmlnIH0gZnJvbSBcIkB0c2NpcmN1aXQvcHJvcHNcIlxuaW1wb3J0IHsgY3JlYXRlRXhlY3V0aW9uQ29udGV4dCB9IGZyb20gXCIuLi8uLi93ZWJ3b3JrZXIvZXhlY3V0aW9uLWNvbnRleHRcIlxuaW1wb3J0IHsgbm9ybWFsaXplRnNNYXAgfSBmcm9tIFwiLi9ub3JtYWxpemVGc01hcFwiXG5pbXBvcnQgdHlwZSB7IFJvb3RDaXJjdWl0IH0gZnJvbSBcIkB0c2NpcmN1aXQvY29yZVwiXG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tIFwicmVhY3RcIlxuaW1wb3J0IHsgaW1wb3J0RXZhbFBhdGggfSBmcm9tIFwid2Vid29ya2VyL2ltcG9ydC1ldmFsLXBhdGhcIlxuaW1wb3J0IHsgc2V0dXBEZWZhdWx0RW50cnlwb2ludElmTmVlZGVkIH0gZnJvbSBcIi4vc2V0dXBEZWZhdWx0RW50cnlwb2ludElmTmVlZGVkXCJcbmltcG9ydCBEZWJ1ZyBmcm9tIFwiZGVidWdcIlxuXG5jb25zdCBkZWJ1ZyA9IERlYnVnKFwidHNjaTpldmFsOkNpcmN1aXRSdW5uZXJcIilcblxuZXhwb3J0IGNsYXNzIENpcmN1aXRSdW5uZXIgaW1wbGVtZW50cyBDaXJjdWl0UnVubmVyQXBpIHtcbiAgX2V4ZWN1dGlvbkNvbnRleHQ6IFJldHVyblR5cGU8dHlwZW9mIGNyZWF0ZUV4ZWN1dGlvbkNvbnRleHQ+IHwgbnVsbCA9IG51bGxcbiAgX2NpcmN1aXRSdW5uZXJDb25maWd1cmF0aW9uOiBDaXJjdWl0UnVubmVyQ29uZmlndXJhdGlvbiA9IHtcbiAgICBzbmlwcGV0c0FwaUJhc2VVcmw6IFwiaHR0cHM6Ly9yZWdpc3RyeS1hcGkudHNjaXJjdWl0LmNvbVwiLFxuICAgIGNqc1JlZ2lzdHJ5VXJsOiBcImh0dHBzOi8vY2pzLnRzY2lyY3VpdC5jb21cIixcbiAgICB2ZXJib3NlOiBmYWxzZSxcbiAgfVxuICBfZXZlbnRMaXN0ZW5lcnM6IFJlY29yZDxzdHJpbmcsICgoLi4uYXJnczogYW55W10pID0+IHZvaWQpW10+ID0ge31cblxuICBjb25zdHJ1Y3Rvcihjb25maWd1cmF0aW9uOiBQYXJ0aWFsPENpcmN1aXRSdW5uZXJDb25maWd1cmF0aW9uPiA9IHt9KSB7XG4gICAgT2JqZWN0LmFzc2lnbih0aGlzLl9jaXJjdWl0UnVubmVyQ29uZmlndXJhdGlvbiwgY29uZmlndXJhdGlvbilcbiAgfVxuXG4gIGFzeW5jIGV4ZWN1dGVXaXRoRnNNYXAob2dPcHRzOiB7XG4gICAgZW50cnlwb2ludD86IHN0cmluZ1xuICAgIG1haW5Db21wb25lbnRQYXRoPzogc3RyaW5nXG4gICAgbWFpbkNvbXBvbmVudE5hbWU/OiBzdHJpbmdcbiAgICBmc01hcDogUmVjb3JkPHN0cmluZywgc3RyaW5nPlxuICAgIG5hbWU/OiBzdHJpbmdcbiAgICBtYWluQ29tcG9uZW50UHJvcHM/OiBSZWNvcmQ8c3RyaW5nLCBhbnk+XG4gIH0pOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBjb25zdCBvcHRzID0geyAuLi5vZ09wdHMgfVxuXG4gICAgaWYgKHRoaXMuX2NpcmN1aXRSdW5uZXJDb25maWd1cmF0aW9uLnZlcmJvc2UpIHtcbiAgICAgIERlYnVnLmVuYWJsZShcInRzY2k6ZXZhbDoqXCIpXG4gICAgfVxuXG4gICAgZGVidWcoXCJleGVjdXRlV2l0aEZzTWFwIGNhbGxlZCB3aXRoOlwiLCB7XG4gICAgICBlbnRyeXBvaW50OiBvcHRzLmVudHJ5cG9pbnQsXG4gICAgICBmc01hcEtleXM6IE9iamVjdC5rZXlzKG9wdHMuZnNNYXApLFxuICAgICAgbmFtZTogb3B0cy5uYW1lLFxuICAgIH0pXG5cbiAgICBzZXR1cERlZmF1bHRFbnRyeXBvaW50SWZOZWVkZWQob3B0cylcblxuICAgIGRlYnVnKFwiZW50cnlwb2ludCBhZnRlciBzZXR1cERlZmF1bHRFbnRyeXBvaW50SWZOZWVkZWQ6XCIsIHtcbiAgICAgIGVudHJ5cG9pbnQ6IG9wdHMuZW50cnlwb2ludCxcbiAgICB9KVxuXG4gICAgdGhpcy5fZXhlY3V0aW9uQ29udGV4dCA9IGNyZWF0ZUV4ZWN1dGlvbkNvbnRleHQoXG4gICAgICB0aGlzLl9jaXJjdWl0UnVubmVyQ29uZmlndXJhdGlvbixcbiAgICAgIHtcbiAgICAgICAgbmFtZTogb3B0cy5uYW1lLFxuICAgICAgICBwbGF0Zm9ybTogdGhpcy5fY2lyY3VpdFJ1bm5lckNvbmZpZ3VyYXRpb24ucGxhdGZvcm0sXG4gICAgICB9LFxuICAgIClcbiAgICB0aGlzLl9iaW5kRXZlbnRMaXN0ZW5lcnModGhpcy5fZXhlY3V0aW9uQ29udGV4dC5jaXJjdWl0KVxuXG4gICAgdGhpcy5fZXhlY3V0aW9uQ29udGV4dC5mc01hcCA9IG5vcm1hbGl6ZUZzTWFwKG9wdHMuZnNNYXApXG4gICAgaWYgKCF0aGlzLl9leGVjdXRpb25Db250ZXh0LmZzTWFwW29wdHMuZW50cnlwb2ludCFdKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEVudHJ5cG9pbnQgXCIke29wdHMuZW50cnlwb2ludH1cIiBub3QgZm91bmRgKVxuICAgIH1cbiAgICA7KGdsb2JhbFRoaXMgYXMgYW55KS5fX3RzY2lyY3VpdF9jaXJjdWl0ID0gdGhpcy5fZXhlY3V0aW9uQ29udGV4dC5jaXJjdWl0XG5cbiAgICBjb25zdCBlbnRyeXBvaW50ID0gb3B0cy5lbnRyeXBvaW50IS5zdGFydHNXaXRoKFwiLi9cIilcbiAgICAgID8gb3B0cy5lbnRyeXBvaW50XG4gICAgICA6IGAuLyR7b3B0cy5lbnRyeXBvaW50fWBcblxuICAgIGRlYnVnKFwiZmluYWwgZW50cnlwb2ludDpcIiwgZW50cnlwb2ludClcbiAgICBhd2FpdCBpbXBvcnRFdmFsUGF0aChlbnRyeXBvaW50ISwgdGhpcy5fZXhlY3V0aW9uQ29udGV4dClcbiAgfVxuXG4gIGFzeW5jIGV4ZWN1dGUoY29kZTogc3RyaW5nLCBvcHRzOiB7IG5hbWU/OiBzdHJpbmcgfSA9IHt9KSB7XG4gICAgaWYgKHRoaXMuX2NpcmN1aXRSdW5uZXJDb25maWd1cmF0aW9uLnZlcmJvc2UpIHtcbiAgICAgIGNvbnNvbGUubG9nKFxuICAgICAgICBcIltDaXJjdWl0UnVubmVyXSBleGVjdXRlIGNhbGxlZCB3aXRoIGNvZGUgbGVuZ3RoOlwiLFxuICAgICAgICBjb2RlLmxlbmd0aCxcbiAgICAgIClcbiAgICB9XG5cbiAgICB0aGlzLl9leGVjdXRpb25Db250ZXh0ID0gY3JlYXRlRXhlY3V0aW9uQ29udGV4dChcbiAgICAgIHRoaXMuX2NpcmN1aXRSdW5uZXJDb25maWd1cmF0aW9uLFxuICAgICAge1xuICAgICAgICAuLi5vcHRzLFxuICAgICAgICBwbGF0Zm9ybTogdGhpcy5fY2lyY3VpdFJ1bm5lckNvbmZpZ3VyYXRpb24ucGxhdGZvcm0sXG4gICAgICB9LFxuICAgIClcbiAgICB0aGlzLl9iaW5kRXZlbnRMaXN0ZW5lcnModGhpcy5fZXhlY3V0aW9uQ29udGV4dC5jaXJjdWl0KVxuICAgIHRoaXMuX2V4ZWN1dGlvbkNvbnRleHQuZnNNYXBbXCJlbnRyeXBvaW50LnRzeFwiXSA9IGNvZGVcbiAgICA7KGdsb2JhbFRoaXMgYXMgYW55KS5fX3RzY2lyY3VpdF9jaXJjdWl0ID0gdGhpcy5fZXhlY3V0aW9uQ29udGV4dC5jaXJjdWl0XG5cbiAgICBhd2FpdCBpbXBvcnRFdmFsUGF0aChcIi4vZW50cnlwb2ludC50c3hcIiwgdGhpcy5fZXhlY3V0aW9uQ29udGV4dClcbiAgfVxuXG4gIG9uKGV2ZW50OiBzdHJpbmcsIGNhbGxiYWNrOiAoLi4uYXJnczogYW55W10pID0+IHZvaWQpIHtcbiAgICB0aGlzLl9ldmVudExpc3RlbmVyc1tldmVudF0gPz89IFtdXG4gICAgdGhpcy5fZXZlbnRMaXN0ZW5lcnNbZXZlbnRdLnB1c2goY2FsbGJhY2spXG4gICAgdGhpcy5fZXhlY3V0aW9uQ29udGV4dD8uY2lyY3VpdC5vbihldmVudCBhcyBhbnksIGNhbGxiYWNrKVxuICB9XG5cbiAgYXN5bmMgcmVuZGVyVW50aWxTZXR0bGVkKCk6IFByb21pc2U8dm9pZD4ge1xuICAgIGlmICghdGhpcy5fZXhlY3V0aW9uQ29udGV4dCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gY2lyY3VpdCBoYXMgYmVlbiBjcmVhdGVkXCIpXG4gICAgfVxuICAgIGF3YWl0IHRoaXMuX2V4ZWN1dGlvbkNvbnRleHQuY2lyY3VpdC5yZW5kZXJVbnRpbFNldHRsZWQoKVxuICB9XG5cbiAgYXN5bmMgZ2V0Q2lyY3VpdEpzb24oKTogUHJvbWlzZTxBbnlDaXJjdWl0RWxlbWVudFtdPiB7XG4gICAgaWYgKCF0aGlzLl9leGVjdXRpb25Db250ZXh0KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBjaXJjdWl0IGhhcyBiZWVuIGNyZWF0ZWRcIilcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2V4ZWN1dGlvbkNvbnRleHQuY2lyY3VpdC5nZXRDaXJjdWl0SnNvbigpXG4gIH1cblxuICBjbGVhckV2ZW50TGlzdGVuZXJzKCkge1xuICAgIGlmICh0aGlzLl9leGVjdXRpb25Db250ZXh0Py5jaXJjdWl0KSB7XG4gICAgICBmb3IgKGNvbnN0IGV2ZW50IGluIHRoaXMuX2V2ZW50TGlzdGVuZXJzKSB7XG4gICAgICAgIGZvciAoY29uc3QgbGlzdGVuZXIgb2YgdGhpcy5fZXZlbnRMaXN0ZW5lcnNbZXZlbnRdKSB7XG4gICAgICAgICAgY29uc3QgY2lyY3VpdCA9IHRoaXMuX2V4ZWN1dGlvbkNvbnRleHQuY2lyY3VpdCBhcyB1bmtub3duIGFzIHtcbiAgICAgICAgICAgIC8vIGJpb21lLWlnbm9yZSBsaW50L2NvbXBsZXhpdHkvbm9CYW5uZWRUeXBlczogPGV4cGxhbmF0aW9uPlxuICAgICAgICAgICAgcmVtb3ZlTGlzdGVuZXI/OiAoZXZlbnQ6IHN0cmluZywgbGlzdGVuZXI6IEZ1bmN0aW9uKSA9PiB2b2lkXG4gICAgICAgICAgfVxuICAgICAgICAgIGNpcmN1aXQucmVtb3ZlTGlzdGVuZXI/LihldmVudCwgbGlzdGVuZXIpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKGNvbnN0IGV2ZW50IGluIHRoaXMuX2V2ZW50TGlzdGVuZXJzKSB7XG4gICAgICBkZWxldGUgdGhpcy5fZXZlbnRMaXN0ZW5lcnNbZXZlbnRdXG4gICAgfVxuICB9XG5cbiAgYXN5bmMga2lsbCgpIHtcbiAgICAvLyBDbGVhbnVwIHJlc291cmNlc1xuICAgIHRoaXMuX2V4ZWN1dGlvbkNvbnRleHQgPSBudWxsXG4gIH1cblxuICBhc3luYyBzZXRTbmlwcGV0c0FwaUJhc2VVcmwoYmFzZVVybDogc3RyaW5nKSB7XG4gICAgdGhpcy5fY2lyY3VpdFJ1bm5lckNvbmZpZ3VyYXRpb24uc25pcHBldHNBcGlCYXNlVXJsID0gYmFzZVVybFxuICB9XG5cbiAgYXN5bmMgc2V0UGxhdGZvcm1Db25maWcocGxhdGZvcm06IFBsYXRmb3JtQ29uZmlnKSB7XG4gICAgdGhpcy5fY2lyY3VpdFJ1bm5lckNvbmZpZ3VyYXRpb24ucGxhdGZvcm0gPSBwbGF0Zm9ybVxuICB9XG5cbiAgcHJpdmF0ZSBfYmluZEV2ZW50TGlzdGVuZXJzKGNpcmN1aXQ6IFJvb3RDaXJjdWl0KSB7XG4gICAgZm9yIChjb25zdCBldmVudCBpbiB0aGlzLl9ldmVudExpc3RlbmVycykge1xuICAgICAgZm9yIChjb25zdCBsaXN0ZW5lciBvZiB0aGlzLl9ldmVudExpc3RlbmVyc1tldmVudF0pIHtcbiAgICAgICAgY2lyY3VpdC5vbihldmVudCBhcyBhbnksIGxpc3RlbmVyIGFzIGFueSlcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbiIsICIvKipcbiAqIFJldHVybnMgdGhlIGRpcmVjdG9yeSBuYW1lIG9mIGEgcGF0aCwgc2ltaWxhciB0byBOb2RlLmpzIHBhdGguZGlybmFtZVxuICogV29ya3Mgb24gYm90aCBVbml4IGFuZCBXaW5kb3dzIHBhdGhzXG4gKiBAcGFyYW0gcGF0aCBUaGUgcGF0aCB0byBleHRyYWN0IHRoZSBkaXJlY3RvcnkgZnJvbVxuICogQHJldHVybnMgVGhlIGRpcmVjdG9yeSBwYXJ0IG9mIHRoZSBwYXRoXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkaXJuYW1lKHBhdGg6IHN0cmluZyk6IHN0cmluZyB7XG4gIGlmICghcGF0aCkgcmV0dXJuIFwiLlwiXG5cbiAgLy8gTm9ybWFsaXplIHBhdGggc2VwYXJhdG9ycyB0byBmb3J3YXJkIHNsYXNoZXNcbiAgY29uc3Qgbm9ybWFsaXplZFBhdGggPSBwYXRoLnJlcGxhY2UoL1xcXFwvZywgXCIvXCIpXG5cbiAgLy8gUmVtb3ZlIHRyYWlsaW5nIHNsYXNoZXNcbiAgY29uc3QgY2xlYW5QYXRoID0gbm9ybWFsaXplZFBhdGgucmVwbGFjZSgvXFwvKyQvLCBcIlwiKVxuXG4gIC8vIElmIHRoZXJlIGFyZSBubyBzbGFzaGVzLCByZXR1cm4gXCIuXCJcbiAgaWYgKGNsZWFuUGF0aC5pbmRleE9mKFwiL1wiKSA9PT0gLTEpIHJldHVybiBcIi5cIlxuXG4gIC8vIFJldHVybiBldmVyeXRoaW5nIHVwIHRvIHRoZSBsYXN0IHNsYXNoXG4gIHJldHVybiBjbGVhblBhdGguc3Vic3RyaW5nKDAsIGNsZWFuUGF0aC5sYXN0SW5kZXhPZihcIi9cIikpIHx8IFwiL1wiXG59XG4iLCAiaW1wb3J0IHsgbm9ybWFsaXplRmlsZVBhdGggfSBmcm9tIFwiLi9ub3JtYWxpemVGc01hcFwiXG5pbXBvcnQgeyBkaXJuYW1lIH0gZnJvbSBcImxpYi91dGlscy9kaXJuYW1lXCJcblxuZnVuY3Rpb24gcmVzb2x2ZVJlbGF0aXZlUGF0aChpbXBvcnRQYXRoOiBzdHJpbmcsIGN3ZDogc3RyaW5nKTogc3RyaW5nIHtcbiAgLy8gSGFuZGxlIHBhcmVudCBkaXJlY3RvcnkgbmF2aWdhdGlvblxuICBpZiAoaW1wb3J0UGF0aC5zdGFydHNXaXRoKFwiLi4vXCIpKSB7XG4gICAgY29uc3QgcGFyZW50RGlyID0gZGlybmFtZShjd2QpXG4gICAgcmV0dXJuIHJlc29sdmVSZWxhdGl2ZVBhdGgoaW1wb3J0UGF0aC5zbGljZSgzKSwgcGFyZW50RGlyKVxuICB9XG4gIC8vIEhhbmRsZSBjdXJyZW50IGRpcmVjdG9yeVxuICBpZiAoaW1wb3J0UGF0aC5zdGFydHNXaXRoKFwiLi9cIikpIHtcbiAgICByZXR1cm4gcmVzb2x2ZVJlbGF0aXZlUGF0aChpbXBvcnRQYXRoLnNsaWNlKDIpLCBjd2QpXG4gIH1cbiAgLy8gSGFuZGxlIGFic29sdXRlIHBhdGhcbiAgaWYgKGltcG9ydFBhdGguc3RhcnRzV2l0aChcIi9cIikpIHtcbiAgICByZXR1cm4gaW1wb3J0UGF0aC5zbGljZSgxKVxuICB9XG4gIC8vIEhhbmRsZSByZWxhdGl2ZSBwYXRoXG4gIHJldHVybiBgJHtjd2R9LyR7aW1wb3J0UGF0aH1gXG59XG5cbmV4cG9ydCBjb25zdCByZXNvbHZlRmlsZVBhdGggPSAoXG4gIHVua25vd25GaWxlUGF0aDogc3RyaW5nLFxuICBmc01hcE9yQWxsRmlsZVBhdGhzOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+IHwgc3RyaW5nW10sXG4gIGN3ZD86IHN0cmluZyxcbikgPT4ge1xuICAvLyBIYW5kbGUgcGFyZW50IGRpcmVjdG9yeSBuYXZpZ2F0aW9uIHByb3Blcmx5XG4gIGNvbnN0IHJlc29sdmVkUGF0aCA9IGN3ZFxuICAgID8gcmVzb2x2ZVJlbGF0aXZlUGF0aCh1bmtub3duRmlsZVBhdGgsIGN3ZClcbiAgICA6IHVua25vd25GaWxlUGF0aFxuXG4gIGNvbnN0IGZpbGVQYXRocyA9IG5ldyBTZXQoXG4gICAgQXJyYXkuaXNBcnJheShmc01hcE9yQWxsRmlsZVBhdGhzKVxuICAgICAgPyBmc01hcE9yQWxsRmlsZVBhdGhzXG4gICAgICA6IE9iamVjdC5rZXlzKGZzTWFwT3JBbGxGaWxlUGF0aHMpLFxuICApXG5cbiAgaWYgKGZpbGVQYXRocy5oYXMocmVzb2x2ZWRQYXRoKSkge1xuICAgIHJldHVybiByZXNvbHZlZFBhdGhcbiAgfVxuXG4gIGNvbnN0IG5vcm1hbGl6ZWRGaWxlUGF0aE1hcCA9IG5ldyBNYXA8c3RyaW5nLCBzdHJpbmc+KClcbiAgZm9yIChjb25zdCBmaWxlUGF0aCBvZiBmaWxlUGF0aHMpIHtcbiAgICBub3JtYWxpemVkRmlsZVBhdGhNYXAuc2V0KG5vcm1hbGl6ZUZpbGVQYXRoKGZpbGVQYXRoKSwgZmlsZVBhdGgpXG4gIH1cblxuICBjb25zdCBub3JtYWxpemVkUmVzb2x2ZWRQYXRoID0gbm9ybWFsaXplRmlsZVBhdGgocmVzb2x2ZWRQYXRoKVxuXG4gIGlmIChub3JtYWxpemVkRmlsZVBhdGhNYXAuaGFzKG5vcm1hbGl6ZWRSZXNvbHZlZFBhdGgpKSB7XG4gICAgcmV0dXJuIG5vcm1hbGl6ZWRGaWxlUGF0aE1hcC5nZXQobm9ybWFsaXplZFJlc29sdmVkUGF0aCkhXG4gIH1cblxuICAvLyBTZWFyY2ggZm9yIGZpbGUgd2l0aCBhIHNldCBvZiBkaWZmZXJlbnQgZXh0ZW5zaW9uc1xuICBjb25zdCBleHRlbnNpb24gPSBbXCJ0c3hcIiwgXCJ0c1wiLCBcImpzb25cIiwgXCJqc1wiLCBcImpzeFwiXVxuICBmb3IgKGNvbnN0IGV4dCBvZiBleHRlbnNpb24pIHtcbiAgICBjb25zdCBwb3NzaWJsZUZpbGVQYXRoID0gYCR7bm9ybWFsaXplZFJlc29sdmVkUGF0aH0uJHtleHR9YFxuICAgIGlmIChub3JtYWxpemVkRmlsZVBhdGhNYXAuaGFzKHBvc3NpYmxlRmlsZVBhdGgpKSB7XG4gICAgICByZXR1cm4gbm9ybWFsaXplZEZpbGVQYXRoTWFwLmdldChwb3NzaWJsZUZpbGVQYXRoKSFcbiAgICB9XG4gIH1cblxuICAvLyBDaGVjayBpZiBpdCdzIGFuIGFic29sdXRlIGltcG9ydFxuICBpZiAoIXVua25vd25GaWxlUGF0aC5zdGFydHNXaXRoKFwiLi9cIikgJiYgIXVua25vd25GaWxlUGF0aC5zdGFydHNXaXRoKFwiLi4vXCIpKSB7XG4gICAgY29uc3Qgbm9ybWFsaXplZFVua25vd25GaWxlUGF0aCA9IG5vcm1hbGl6ZUZpbGVQYXRoKHVua25vd25GaWxlUGF0aClcbiAgICBpZiAobm9ybWFsaXplZEZpbGVQYXRoTWFwLmhhcyhub3JtYWxpemVkVW5rbm93bkZpbGVQYXRoKSkge1xuICAgICAgcmV0dXJuIG5vcm1hbGl6ZWRGaWxlUGF0aE1hcC5nZXQobm9ybWFsaXplZFVua25vd25GaWxlUGF0aCkhXG4gICAgfVxuICAgIGZvciAoY29uc3QgZXh0IG9mIGV4dGVuc2lvbikge1xuICAgICAgY29uc3QgcG9zc2libGVGaWxlUGF0aCA9IGAke25vcm1hbGl6ZWRVbmtub3duRmlsZVBhdGh9LiR7ZXh0fWBcbiAgICAgIGlmIChub3JtYWxpemVkRmlsZVBhdGhNYXAuaGFzKHBvc3NpYmxlRmlsZVBhdGgpKSB7XG4gICAgICAgIHJldHVybiBub3JtYWxpemVkRmlsZVBhdGhNYXAuZ2V0KHBvc3NpYmxlRmlsZVBhdGgpIVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBudWxsXG59XG5cbmV4cG9ydCBjb25zdCByZXNvbHZlRmlsZVBhdGhPclRocm93ID0gKFxuICB1bmtub3duRmlsZVBhdGg6IHN0cmluZyxcbiAgZnNNYXBPckFsbEZpbGVQYXRoczogUmVjb3JkPHN0cmluZywgc3RyaW5nPiB8IHN0cmluZ1tdLFxuKSA9PiB7XG4gIGNvbnN0IHJlc29sdmVkRmlsZVBhdGggPSByZXNvbHZlRmlsZVBhdGgodW5rbm93bkZpbGVQYXRoLCBmc01hcE9yQWxsRmlsZVBhdGhzKVxuICBpZiAoIXJlc29sdmVkRmlsZVBhdGgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBgRmlsZSBub3QgZm91bmQgXCIke3Vua25vd25GaWxlUGF0aH1cIiwgYXZhaWxhYmxlIHBhdGhzOlxcblxcbiR7T2JqZWN0LmtleXMoZnNNYXBPckFsbEZpbGVQYXRocykuam9pbihcIiwgXCIpfWAsXG4gICAgKVxuICB9XG4gIHJldHVybiByZXNvbHZlZEZpbGVQYXRoXG59XG4iLCAiaW1wb3J0IHsgcmVzb2x2ZUZpbGVQYXRoIH0gZnJvbSBcImxpYi9ydW5uZXIvcmVzb2x2ZUZpbGVQYXRoXCJcblxuZXhwb3J0IGZ1bmN0aW9uIGV2YWxDb21waWxlZEpzKFxuICBjb21waWxlZENvZGU6IHN0cmluZyxcbiAgcHJlU3VwcGxpZWRJbXBvcnRzOiBSZWNvcmQ8c3RyaW5nLCBhbnk+LFxuICBjd2Q/OiBzdHJpbmcsXG4pIHtcbiAgOyhnbG9iYWxUaGlzIGFzIGFueSkuX190c2NpcmN1aXRfcmVxdWlyZSA9IChuYW1lOiBzdHJpbmcpID0+IHtcbiAgICBjb25zdCByZXNvbHZlZEZpbGVQYXRoID0gcmVzb2x2ZUZpbGVQYXRoKG5hbWUsIHByZVN1cHBsaWVkSW1wb3J0cywgY3dkKVxuXG4gICAgY29uc3QgaGFzUmVzb2x2ZWRGaWxlUGF0aCA9XG4gICAgICByZXNvbHZlZEZpbGVQYXRoICYmIHByZVN1cHBsaWVkSW1wb3J0c1tyZXNvbHZlZEZpbGVQYXRoXVxuXG4gICAgaWYgKCFwcmVTdXBwbGllZEltcG9ydHNbbmFtZV0gJiYgIWhhc1Jlc29sdmVkRmlsZVBhdGgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgSW1wb3J0IFwiJHtuYW1lfVwiIG5vdCBmb3VuZCAke2N3ZCA/IGBpbiBcIiR7Y3dkfVwiYCA6IFwiXCJ9YClcbiAgICB9XG5cbiAgICBjb25zdCBtb2QgPVxuICAgICAgcHJlU3VwcGxpZWRJbXBvcnRzW25hbWVdIHx8IHByZVN1cHBsaWVkSW1wb3J0c1tyZXNvbHZlZEZpbGVQYXRoIV1cbiAgICByZXR1cm4gbmV3IFByb3h5KG1vZCwge1xuICAgICAgZ2V0KHRhcmdldCwgcHJvcCkge1xuICAgICAgICBpZiAoIShwcm9wIGluIHRhcmdldCkpIHtcbiAgICAgICAgICBpZiAocHJvcCA9PT0gXCJkZWZhdWx0XCIpIHtcbiAgICAgICAgICAgIGlmICh0YXJnZXQuZGVmYXVsdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIHJldHVybiB0YXJnZXQuZGVmYXVsdFxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodGFyZ2V0Ll9fZXNNb2R1bGUpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZFxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodHlwZW9mIHRhcmdldCA9PT0gXCJmdW5jdGlvblwiIHx8IHR5cGVvZiB0YXJnZXQgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRhcmdldFxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHByb3AgPT09IFwiX19lc01vZHVsZVwiKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgIGBDb21wb25lbnQgXCIke1N0cmluZyhwcm9wKX1cIiBpcyBub3QgZXhwb3J0ZWQgYnkgXCIke25hbWV9XCJgLFxuICAgICAgICAgIClcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0YXJnZXRbcHJvcCBhcyBrZXlvZiB0eXBlb2YgdGFyZ2V0XVxuICAgICAgfSxcbiAgICB9KVxuICB9XG5cbiAgY29uc3QgZnVuY3Rpb25Cb2R5ID0gYFxuICB2YXIgZXhwb3J0cyA9IHt9O1xuICB2YXIgcmVxdWlyZSA9IGdsb2JhbFRoaXMuX190c2NpcmN1aXRfcmVxdWlyZTtcbiAgdmFyIG1vZHVsZSA9IHsgZXhwb3J0cyB9O1xuICB2YXIgY2lyY3VpdCA9IGdsb2JhbFRoaXMuX190c2NpcmN1aXRfY2lyY3VpdDtcbiAgJHtjb21waWxlZENvZGV9O1xuICByZXR1cm4gbW9kdWxlO2AudHJpbSgpXG4gIHJldHVybiBGdW5jdGlvbihmdW5jdGlvbkJvZHkpLmNhbGwoZ2xvYmFsVGhpcylcbn1cbiIsICJpbXBvcnQgeyBldmFsQ29tcGlsZWRKcyB9IGZyb20gXCIuL2V2YWwtY29tcGlsZWQtanNcIlxuaW1wb3J0IHR5cGUgeyBFeGVjdXRpb25Db250ZXh0IH0gZnJvbSBcIi4vZXhlY3V0aW9uLWNvbnRleHRcIlxuaW1wb3J0ICogYXMgQmFiZWwgZnJvbSBcIkBiYWJlbC9zdGFuZGFsb25lXCJcbmltcG9ydCB7IGltcG9ydExvY2FsRmlsZSB9IGZyb20gXCIuL2ltcG9ydC1sb2NhbC1maWxlXCJcbmltcG9ydCB7IGltcG9ydFNuaXBwZXQgfSBmcm9tIFwiLi9pbXBvcnQtc25pcHBldFwiXG5pbXBvcnQgeyByZXNvbHZlRmlsZVBhdGggfSBmcm9tIFwibGliL3J1bm5lci9yZXNvbHZlRmlsZVBhdGhcIlxuaW1wb3J0IHsgcmVzb2x2ZU5vZGVNb2R1bGUgfSBmcm9tIFwibGliL3V0aWxzL3Jlc29sdmUtbm9kZS1tb2R1bGVcIlxuaW1wb3J0IHsgaW1wb3J0Tm9kZU1vZHVsZSB9IGZyb20gXCIuL2ltcG9ydC1ub2RlLW1vZHVsZVwiXG5pbXBvcnQgRGVidWcgZnJvbSBcImRlYnVnXCJcblxuY29uc3QgZGVidWcgPSBEZWJ1ZyhcInRzY2k6ZXZhbDppbXBvcnQtZXZhbC1wYXRoXCIpXG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBpbXBvcnRFdmFsUGF0aChcbiAgaW1wb3J0TmFtZTogc3RyaW5nLFxuICBjdHg6IEV4ZWN1dGlvbkNvbnRleHQsXG4gIGRlcHRoID0gMCxcbiAgb3B0czoge1xuICAgIGN3ZD86IHN0cmluZ1xuICB9ID0ge30sXG4pIHtcbiAgZGVidWcoXCJpbXBvcnRFdmFsUGF0aCBjYWxsZWQgd2l0aDpcIiwge1xuICAgIGltcG9ydE5hbWUsXG4gICAgZGVwdGgsXG4gICAgb3B0cyxcbiAgfSlcblxuICBkZWJ1ZyhgJHtcIiAgXCIucmVwZWF0KGRlcHRoKX1cdTI3QTFcdUZFMEZgLCBpbXBvcnROYW1lKVxuICBjb25zdCB7IHByZVN1cHBsaWVkSW1wb3J0cyB9ID0gY3R4XG5cbiAgaWYgKHByZVN1cHBsaWVkSW1wb3J0c1tpbXBvcnROYW1lXSkgcmV0dXJuXG4gIGlmIChpbXBvcnROYW1lLnN0YXJ0c1dpdGgoXCIuL1wiKSAmJiBwcmVTdXBwbGllZEltcG9ydHNbaW1wb3J0TmFtZS5zbGljZSgyKV0pXG4gICAgcmV0dXJuXG5cbiAgaWYgKGRlcHRoID4gNSkge1xuICAgIGNvbnNvbGUubG9nKFwiTWF4IGRlcHRoIGZvciBpbXBvcnRzIHJlYWNoZWRcIilcbiAgICByZXR1cm5cbiAgfVxuXG4gIGNvbnN0IHJlc29sdmVkTG9jYWxJbXBvcnRQYXRoID0gcmVzb2x2ZUZpbGVQYXRoKFxuICAgIGltcG9ydE5hbWUsXG4gICAgY3R4LmZzTWFwLFxuICAgIG9wdHMuY3dkLFxuICApXG4gIGlmIChyZXNvbHZlZExvY2FsSW1wb3J0UGF0aCkge1xuICAgIHJldHVybiBpbXBvcnRMb2NhbEZpbGUocmVzb2x2ZWRMb2NhbEltcG9ydFBhdGgsIGN0eCwgZGVwdGgpXG4gIH1cblxuICAvLyBUcnkgdG8gcmVzb2x2ZSBmcm9tIG5vZGVfbW9kdWxlc1xuICBjb25zdCByZXNvbHZlZE5vZGVNb2R1bGVQYXRoID0gcmVzb2x2ZU5vZGVNb2R1bGUoXG4gICAgaW1wb3J0TmFtZSxcbiAgICBjdHguZnNNYXAsXG4gICAgb3B0cy5jd2QgfHwgXCJcIixcbiAgKVxuICBpZiAocmVzb2x2ZWROb2RlTW9kdWxlUGF0aCkge1xuICAgIHJldHVybiBpbXBvcnROb2RlTW9kdWxlKGltcG9ydE5hbWUsIGN0eCwgZGVwdGgpXG4gIH1cblxuICBpZiAoaW1wb3J0TmFtZS5zdGFydHNXaXRoKFwiQHRzY2kvXCIpKSB7XG4gICAgcmV0dXJuIGltcG9ydFNuaXBwZXQoaW1wb3J0TmFtZSwgY3R4LCBkZXB0aClcbiAgfVxuXG4gIHRocm93IG5ldyBFcnJvcihcbiAgICBgVW5yZXNvbHZlZCBpbXBvcnQgXCIke2ltcG9ydE5hbWV9XCIgJHtvcHRzLmN3ZCA/IGBmcm9tIGRpcmVjdG9yeSBcIiR7b3B0cy5jd2R9XCJgIDogXCJcIn1gLFxuICApXG59XG4iLCAiaW1wb3J0ICogYXMgQmFiZWwgZnJvbSBcIkBiYWJlbC9zdGFuZGFsb25lXCJcbmltcG9ydCB7IHJlc29sdmVGaWxlUGF0aE9yVGhyb3cgfSBmcm9tIFwibGliL3J1bm5lci9yZXNvbHZlRmlsZVBhdGhcIlxuaW1wb3J0IHsgZGlybmFtZSB9IGZyb20gXCJsaWIvdXRpbHMvZGlybmFtZVwiXG5pbXBvcnQgeyBnZXRJbXBvcnRzRnJvbUNvZGUgfSBmcm9tIFwibGliL3V0aWxzL2dldC1pbXBvcnRzLWZyb20tY29kZVwiXG5pbXBvcnQgeyBldmFsQ29tcGlsZWRKcyB9IGZyb20gXCIuL2V2YWwtY29tcGlsZWQtanNcIlxuaW1wb3J0IHR5cGUgeyBFeGVjdXRpb25Db250ZXh0IH0gZnJvbSBcIi4vZXhlY3V0aW9uLWNvbnRleHRcIlxuaW1wb3J0IHsgaW1wb3J0RXZhbFBhdGggfSBmcm9tIFwiLi9pbXBvcnQtZXZhbC1wYXRoXCJcbmltcG9ydCBEZWJ1ZyBmcm9tIFwiZGVidWdcIlxuXG5jb25zdCBkZWJ1ZyA9IERlYnVnKFwidHNjaTpldmFsOmltcG9ydC1sb2NhbC1maWxlXCIpXG5cbmV4cG9ydCBjb25zdCBpbXBvcnRMb2NhbEZpbGUgPSBhc3luYyAoXG4gIGltcG9ydE5hbWU6IHN0cmluZyxcbiAgY3R4OiBFeGVjdXRpb25Db250ZXh0LFxuICBkZXB0aCA9IDAsXG4pID0+IHtcbiAgZGVidWcoXCJpbXBvcnRMb2NhbEZpbGUgY2FsbGVkIHdpdGg6XCIsIHtcbiAgICBpbXBvcnROYW1lLFxuICB9KVxuXG4gIGNvbnN0IHsgZnNNYXAsIHByZVN1cHBsaWVkSW1wb3J0cyB9ID0gY3R4XG5cbiAgY29uc3QgZnNQYXRoID0gcmVzb2x2ZUZpbGVQYXRoT3JUaHJvdyhpbXBvcnROYW1lLCBmc01hcClcbiAgZGVidWcoXCJmc1BhdGg6XCIsIGZzUGF0aClcbiAgaWYgKCFjdHguZnNNYXBbZnNQYXRoXSkge1xuICAgIGRlYnVnKFwiZnNQYXRoIG5vdCBmb3VuZCBpbiBmc01hcDpcIiwgZnNQYXRoKVxuICAgIHRocm93IG5ldyBFcnJvcihgRmlsZSBcIiR7ZnNQYXRofVwiIG5vdCBmb3VuZGApXG4gIH1cbiAgY29uc3QgZmlsZUNvbnRlbnQgPSBmc01hcFtmc1BhdGhdXG4gIGRlYnVnKFwiZmlsZUNvbnRlbnQ6XCIsIGZpbGVDb250ZW50Py5zbGljZSgwLCAxMDApKVxuICBpZiAoZnNQYXRoLmVuZHNXaXRoKFwiLmpzb25cIikpIHtcbiAgICBjb25zdCBqc29uRGF0YSA9IEpTT04ucGFyc2UoZmlsZUNvbnRlbnQpXG4gICAgcHJlU3VwcGxpZWRJbXBvcnRzW2ZzUGF0aF0gPSB7XG4gICAgICBfX2VzTW9kdWxlOiB0cnVlLFxuICAgICAgZGVmYXVsdDoganNvbkRhdGEsXG4gICAgfVxuICB9IGVsc2UgaWYgKGZzUGF0aC5lbmRzV2l0aChcIi50c3hcIikgfHwgZnNQYXRoLmVuZHNXaXRoKFwiLnRzXCIpKSB7XG4gICAgY29uc3QgaW1wb3J0TmFtZXMgPSBnZXRJbXBvcnRzRnJvbUNvZGUoZmlsZUNvbnRlbnQpXG5cbiAgICBmb3IgKGNvbnN0IGltcG9ydE5hbWUgb2YgaW1wb3J0TmFtZXMpIHtcbiAgICAgIGlmICghcHJlU3VwcGxpZWRJbXBvcnRzW2ltcG9ydE5hbWVdKSB7XG4gICAgICAgIGF3YWl0IGltcG9ydEV2YWxQYXRoKGltcG9ydE5hbWUsIGN0eCwgZGVwdGggKyAxLCB7XG4gICAgICAgICAgY3dkOiBkaXJuYW1lKGZzUGF0aCksXG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgcmVzdWx0ID0gQmFiZWwudHJhbnNmb3JtKGZpbGVDb250ZW50LCB7XG4gICAgICBwcmVzZXRzOiBbXCJyZWFjdFwiLCBcInR5cGVzY3JpcHRcIl0sXG4gICAgICBwbHVnaW5zOiBbXCJ0cmFuc2Zvcm0tbW9kdWxlcy1jb21tb25qc1wiXSxcbiAgICAgIGZpbGVuYW1lOiBcInZpcnR1YWwudHN4XCIsXG4gICAgfSlcblxuICAgIGlmICghcmVzdWx0IHx8ICFyZXN1bHQuY29kZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRmFpbGVkIHRvIHRyYW5zZm9ybSBjb2RlXCIpXG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIGRlYnVnKFwiZXZhbENvbXBpbGVkSnMgY2FsbGVkIHdpdGg6XCIsIHtcbiAgICAgICAgY29kZTogcmVzdWx0LmNvZGU/LnNsaWNlKDAsIDEwMCksXG4gICAgICAgIGRpcm5hbWU6IGRpcm5hbWUoZnNQYXRoKSxcbiAgICAgIH0pXG4gICAgICBjb25zdCBpbXBvcnRSdW5SZXN1bHQgPSBldmFsQ29tcGlsZWRKcyhcbiAgICAgICAgcmVzdWx0LmNvZGUsXG4gICAgICAgIHByZVN1cHBsaWVkSW1wb3J0cyxcbiAgICAgICAgZGlybmFtZShmc1BhdGgpLFxuICAgICAgKVxuICAgICAgZGVidWcoXCJpbXBvcnRSdW5SZXN1bHQ6XCIsIHtcbiAgICAgICAgZnNQYXRoLFxuICAgICAgICBpbXBvcnRSdW5SZXN1bHQsXG4gICAgICB9KVxuICAgICAgcHJlU3VwcGxpZWRJbXBvcnRzW2ZzUGF0aF0gPSBpbXBvcnRSdW5SZXN1bHQuZXhwb3J0c1xuICAgIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYEV2YWwgY29tcGlsZWQganMgZXJyb3IgZm9yIFwiJHtpbXBvcnROYW1lfVwiOiAke2Vycm9yLm1lc3NhZ2V9YCxcbiAgICAgIClcbiAgICB9XG4gIH0gZWxzZSBpZiAoZnNQYXRoLmVuZHNXaXRoKFwiLmpzXCIpKSB7XG4gICAgLy8gRm9yIC5qcyBmaWxlcywgZXNwZWNpYWxseSBmcm9tIG5vZGVfbW9kdWxlcywgd2UgbmVlZCB0byB0cmFuc2Zvcm0gdGhlbVxuICAgIGNvbnN0IHJlc3VsdCA9IEJhYmVsLnRyYW5zZm9ybShmaWxlQ29udGVudCwge1xuICAgICAgcHJlc2V0czogW1wiZW52XCJdLFxuICAgICAgcGx1Z2luczogW1widHJhbnNmb3JtLW1vZHVsZXMtY29tbW9uanNcIl0sXG4gICAgICBmaWxlbmFtZTogZnNQYXRoLFxuICAgIH0pXG5cbiAgICBpZiAoIXJlc3VsdCB8fCAhcmVzdWx0LmNvZGUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkZhaWxlZCB0byB0cmFuc2Zvcm0gSlMgY29kZVwiKVxuICAgIH1cblxuICAgIHByZVN1cHBsaWVkSW1wb3J0c1tmc1BhdGhdID0gZXZhbENvbXBpbGVkSnMoXG4gICAgICByZXN1bHQuY29kZSxcbiAgICAgIHByZVN1cHBsaWVkSW1wb3J0cyxcbiAgICAgIGRpcm5hbWUoZnNQYXRoKSxcbiAgICApLmV4cG9ydHNcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBgVW5zdXBwb3J0ZWQgZmlsZSBleHRlbnNpb24gXCIke2ZzUGF0aC5zcGxpdChcIi5cIikucG9wKCl9XCIgZm9yIFwiJHtmc1BhdGh9XCJgLFxuICAgIClcbiAgfVxufVxuIiwgImV4cG9ydCBjb25zdCBnZXRJbXBvcnRzRnJvbUNvZGUgPSAoY29kZTogc3RyaW5nKTogc3RyaW5nW10gPT4ge1xuICAvLyBNYXRjaCBiYXNpYyBpbXBvcnQgcGF0dGVybnMgaW5jbHVkaW5nIGNvbWJpbmVkIGRlZmF1bHQgYW5kIG5hbWVzcGFjZSBpbXBvcnRzXG4gIGNvbnN0IGltcG9ydFJlZ2V4ID1cbiAgICAvXlxccyppbXBvcnRcXHMrKD86KD86W1xcd1xcc10rLFxccyopPyg/OlxcKlxccythc1xccytbXFx3XFxzXSt8XFx7W1xcc1xcdyxdK1xcfXxcXHcrKVxccytmcm9tXFxzKyk/WydcIl0oLis/KVsnXCJdL2dtXG4gIGNvbnN0IGltcG9ydHM6IHN0cmluZ1tdID0gW11cbiAgbGV0IG1hdGNoOiBSZWdFeHBFeGVjQXJyYXkgfCBudWxsXG5cbiAgLy8gYmlvbWUtaWdub3JlIGxpbnQvc3VzcGljaW91cy9ub0Fzc2lnbkluRXhwcmVzc2lvbnM6IDxleHBsYW5hdGlvbj5cbiAgd2hpbGUgKChtYXRjaCA9IGltcG9ydFJlZ2V4LmV4ZWMoY29kZSkpICE9PSBudWxsKSB7XG4gICAgaW1wb3J0cy5wdXNoKG1hdGNoWzFdKVxuICB9XG5cbiAgLy8gTWF0Y2ggcmUtZXhwb3J0c1xuICBjb25zdCByZUV4cG9ydFJlZ2V4ID1cbiAgICAvXlxccypleHBvcnRcXHMrKD86XFwqfCg/Olxce1tcXHNcXHcsXStcXH0pKVxccytmcm9tXFxzK1snXCJdKC4rPylbJ1wiXS9nbVxuICBsZXQgcmVFeHBvcnRNYXRjaDogUmVnRXhwRXhlY0FycmF5IHwgbnVsbFxuICAvLyBiaW9tZS1pZ25vcmUgbGludC9zdXNwaWNpb3VzL25vQXNzaWduSW5FeHByZXNzaW9uczogPGV4cGxhbmF0aW9uPlxuICB3aGlsZSAoKHJlRXhwb3J0TWF0Y2ggPSByZUV4cG9ydFJlZ2V4LmV4ZWMoY29kZSkpICE9PSBudWxsKSB7XG4gICAgaW1wb3J0cy5wdXNoKHJlRXhwb3J0TWF0Y2hbMV0pXG4gIH1cblxuICByZXR1cm4gaW1wb3J0c1xufVxuIiwgImltcG9ydCB7IGV2YWxDb21waWxlZEpzIH0gZnJvbSBcIi4vZXZhbC1jb21waWxlZC1qc1wiXG5pbXBvcnQgdHlwZSB7IEV4ZWN1dGlvbkNvbnRleHQgfSBmcm9tIFwiLi9leGVjdXRpb24tY29udGV4dFwiXG5pbXBvcnQgKiBhcyBCYWJlbCBmcm9tIFwiQGJhYmVsL3N0YW5kYWxvbmVcIlxuaW1wb3J0IHsgaW1wb3J0TG9jYWxGaWxlIH0gZnJvbSBcIi4vaW1wb3J0LWxvY2FsLWZpbGVcIlxuaW1wb3J0IHsgaW1wb3J0RXZhbFBhdGggfSBmcm9tIFwiLi9pbXBvcnQtZXZhbC1wYXRoXCJcblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGltcG9ydFNuaXBwZXQoXG4gIGltcG9ydE5hbWU6IHN0cmluZyxcbiAgY3R4OiBFeGVjdXRpb25Db250ZXh0LFxuICBkZXB0aCA9IDAsXG4pIHtcbiAgY29uc3QgeyBwcmVTdXBwbGllZEltcG9ydHMgfSA9IGN0eFxuICBjb25zdCBmdWxsU25pcHBldE5hbWUgPSBpbXBvcnROYW1lLnJlcGxhY2UoXCJAdHNjaS9cIiwgXCJcIikucmVwbGFjZShcIi5cIiwgXCIvXCIpXG5cbiAgY29uc3QgeyBjanMsIGVycm9yIH0gPSBhd2FpdCBmZXRjaChgJHtjdHguY2pzUmVnaXN0cnlVcmx9LyR7ZnVsbFNuaXBwZXROYW1lfWApXG4gICAgLnRoZW4oYXN5bmMgKHJlcykgPT4gKHsgY2pzOiBhd2FpdCByZXMudGV4dCgpLCBlcnJvcjogbnVsbCB9KSlcbiAgICAuY2F0Y2goKGUpID0+ICh7IGVycm9yOiBlLCBjanM6IG51bGwgfSkpXG5cbiAgaWYgKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcihcIkVycm9yIGZldGNoaW5nIGltcG9ydFwiLCBpbXBvcnROYW1lLCBlcnJvcilcbiAgICByZXR1cm5cbiAgfVxuXG4gIHRyeSB7XG4gICAgcHJlU3VwcGxpZWRJbXBvcnRzW2ltcG9ydE5hbWVdID0gZXZhbENvbXBpbGVkSnMoXG4gICAgICBjanMhLFxuICAgICAgcHJlU3VwcGxpZWRJbXBvcnRzLFxuICAgICkuZXhwb3J0c1xuICB9IGNhdGNoIChlKSB7XG4gICAgY29uc29sZS5lcnJvcihcIkVycm9yIGltcG9ydGluZyBzbmlwcGV0XCIsIGUpXG4gIH1cbn1cbiIsICJpbXBvcnQgeyBkaXJuYW1lIH0gZnJvbSBcIi4vZGlybmFtZVwiXG5cbmludGVyZmFjZSBQYWNrYWdlSnNvbiB7XG4gIG1haW4/OiBzdHJpbmdcbiAgbW9kdWxlPzogc3RyaW5nXG4gIGV4cG9ydHM/OiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmcgfCBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+PlxufVxuXG5pbnRlcmZhY2UgTm9kZVJlc29sdXRpb25Db250ZXh0IHtcbiAgZnNNYXA6IFJlY29yZDxzdHJpbmcsIHN0cmluZz5cbiAgZXh0ZW5zaW9uczogc3RyaW5nW11cbiAgYmFzZVBhdGg6IHN0cmluZ1xuICBtb2R1bGVQYXRoOiBzdHJpbmdcbn1cblxuZnVuY3Rpb24gY3JlYXRlQ29udGV4dChcbiAgbW9kdWxlUGF0aDogc3RyaW5nLFxuICBmc01hcDogUmVjb3JkPHN0cmluZywgc3RyaW5nPixcbiAgYmFzZVBhdGg6IHN0cmluZyxcbik6IE5vZGVSZXNvbHV0aW9uQ29udGV4dCB7XG4gIHJldHVybiB7XG4gICAgZnNNYXAsXG4gICAgZXh0ZW5zaW9uczogW1wiLmpzXCIsIFwiLmpzeFwiLCBcIi50c1wiLCBcIi50c3hcIiwgXCIuanNvblwiXSxcbiAgICBiYXNlUGF0aCxcbiAgICBtb2R1bGVQYXRoLFxuICB9XG59XG5cbmZ1bmN0aW9uIGZpbmRQYWNrYWdlSnNvbihub2RlTW9kdWxlc1BhdGg6IHN0cmluZywgY3R4OiBOb2RlUmVzb2x1dGlvbkNvbnRleHQpIHtcbiAgY29uc3QgcGFja2FnZUpzb25QYXRoID0gYCR7bm9kZU1vZHVsZXNQYXRofS9wYWNrYWdlLmpzb25gXG4gIGlmICghY3R4LmZzTWFwW3BhY2thZ2VKc29uUGF0aF0pIHJldHVybiBudWxsXG4gIHRyeSB7XG4gICAgcmV0dXJuIEpTT04ucGFyc2UoY3R4LmZzTWFwW3BhY2thZ2VKc29uUGF0aF0pIGFzIFBhY2thZ2VKc29uXG4gIH0gY2F0Y2gge1xuICAgIHJldHVybiBudWxsXG4gIH1cbn1cblxuZnVuY3Rpb24gdHJ5UmVzb2x2ZVdpdGhFeHRlbnNpb25zKFxuICBwYXRoOiBzdHJpbmcsXG4gIGN0eDogTm9kZVJlc29sdXRpb25Db250ZXh0LFxuKTogc3RyaW5nIHwgbnVsbCB7XG4gIGlmIChjdHguZnNNYXBbcGF0aF0pIHJldHVybiBwYXRoXG5cbiAgZm9yIChjb25zdCBleHQgb2YgY3R4LmV4dGVuc2lvbnMpIHtcbiAgICBjb25zdCBwYXRoV2l0aEV4dCA9IHBhdGgucmVwbGFjZSgvXFwuanMkfFxcLmpzeCQvLCBcIlwiKSArIGV4dFxuICAgIGlmIChjdHguZnNNYXBbcGF0aFdpdGhFeHRdKSByZXR1cm4gcGF0aFdpdGhFeHRcbiAgfVxuICByZXR1cm4gbnVsbFxufVxuXG5mdW5jdGlvbiByZXNvbHZlRXhwb3J0UGF0aChcbiAgbm9kZU1vZHVsZXNQYXRoOiBzdHJpbmcsXG4gIGV4cG9ydFBhdGg6IHN0cmluZyxcbiAgY3R4OiBOb2RlUmVzb2x1dGlvbkNvbnRleHQsXG4pOiBzdHJpbmcgfCBudWxsIHtcbiAgY29uc3QgZnVsbEV4cG9ydFBhdGggPSBgJHtub2RlTW9kdWxlc1BhdGh9LyR7ZXhwb3J0UGF0aC5yZXBsYWNlKC9eXFwuXFwvLywgXCJcIil9YFxuICByZXR1cm4gdHJ5UmVzb2x2ZVdpdGhFeHRlbnNpb25zKGZ1bGxFeHBvcnRQYXRoLCBjdHgpXG59XG5cbmZ1bmN0aW9uIHJlc29sdmVQYWNrYWdlRXhwb3J0cyhcbiAgbm9kZU1vZHVsZXNQYXRoOiBzdHJpbmcsXG4gIHBhY2thZ2VKc29uOiBQYWNrYWdlSnNvbixcbiAgcmVtYWluaW5nUGF0aDogc3RyaW5nLFxuICBjdHg6IE5vZGVSZXNvbHV0aW9uQ29udGV4dCxcbik6IHN0cmluZyB8IG51bGwge1xuICBpZiAoIXBhY2thZ2VKc29uLmV4cG9ydHMpIHJldHVybiBudWxsXG5cbiAgLy8gSGFuZGxlIGRlZmF1bHQgZXhwb3J0IGNvbmRpdGlvblxuICBjb25zdCBkZWZhdWx0RXhwb3J0ID0gcGFja2FnZUpzb24uZXhwb3J0c1tcIi5cIl1cbiAgaWYgKHJlbWFpbmluZ1BhdGggPT09IFwiXCIgJiYgZGVmYXVsdEV4cG9ydCkge1xuICAgIGlmICh0eXBlb2YgZGVmYXVsdEV4cG9ydCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgY29uc3QgcmVzb2x2ZWQgPSByZXNvbHZlRXhwb3J0UGF0aChub2RlTW9kdWxlc1BhdGgsIGRlZmF1bHRFeHBvcnQsIGN0eClcbiAgICAgIGlmIChyZXNvbHZlZCkgcmV0dXJuIHJlc29sdmVkXG4gICAgfVxuICB9XG5cbiAgLy8gSGFuZGxlIHN1YnBhdGggZXhwb3J0c1xuICBjb25zdCBzdWJwYXRoRXhwb3J0ID0gcmVtYWluaW5nUGF0aFxuICAgID8gcGFja2FnZUpzb24uZXhwb3J0c1tgLi8ke3JlbWFpbmluZ1BhdGh9YF1cbiAgICA6IG51bGxcbiAgaWYgKHN1YnBhdGhFeHBvcnQgJiYgdHlwZW9mIHN1YnBhdGhFeHBvcnQgPT09IFwic3RyaW5nXCIpIHtcbiAgICBjb25zdCByZXNvbHZlZCA9IHJlc29sdmVFeHBvcnRQYXRoKG5vZGVNb2R1bGVzUGF0aCwgc3VicGF0aEV4cG9ydCwgY3R4KVxuICAgIGlmIChyZXNvbHZlZCkgcmV0dXJuIHJlc29sdmVkXG4gIH1cblxuICAvLyBIYW5kbGUgY29uZGl0aW9uYWwgZXhwb3J0c1xuICBjb25zdCBpbXBvcnRFeHBvcnQgPSBwYWNrYWdlSnNvbi5leHBvcnRzW1wiaW1wb3J0XCJdXG4gIGlmIChcbiAgICByZW1haW5pbmdQYXRoID09PSBcIlwiICYmXG4gICAgaW1wb3J0RXhwb3J0ICYmXG4gICAgdHlwZW9mIGltcG9ydEV4cG9ydCA9PT0gXCJzdHJpbmdcIlxuICApIHtcbiAgICBjb25zdCByZXNvbHZlZCA9IHJlc29sdmVFeHBvcnRQYXRoKG5vZGVNb2R1bGVzUGF0aCwgaW1wb3J0RXhwb3J0LCBjdHgpXG4gICAgaWYgKHJlc29sdmVkKSByZXR1cm4gcmVzb2x2ZWRcbiAgfVxuXG4gIHJldHVybiBudWxsXG59XG5cbmZ1bmN0aW9uIHJlc29sdmVQYWNrYWdlRW50cnlQb2ludChcbiAgbm9kZU1vZHVsZXNQYXRoOiBzdHJpbmcsXG4gIHBhY2thZ2VKc29uOiBQYWNrYWdlSnNvbixcbiAgY3R4OiBOb2RlUmVzb2x1dGlvbkNvbnRleHQsXG4pOiBzdHJpbmcgfCBudWxsIHtcbiAgY29uc3QgZW50cnlQb2ludCA9IHBhY2thZ2VKc29uLm1vZHVsZSB8fCBwYWNrYWdlSnNvbi5tYWluIHx8IFwiaW5kZXguanNcIlxuICBjb25zdCBmdWxsUGF0aCA9IGAke25vZGVNb2R1bGVzUGF0aH0vJHtlbnRyeVBvaW50fWBcbiAgcmV0dXJuIHRyeVJlc29sdmVXaXRoRXh0ZW5zaW9ucyhmdWxsUGF0aCwgY3R4KVxufVxuXG5mdW5jdGlvbiByZXNvbHZlUmVtYWluaW5nUGF0aChcbiAgbm9kZU1vZHVsZXNQYXRoOiBzdHJpbmcsXG4gIHJlbWFpbmluZ1BhdGg6IHN0cmluZyxcbiAgY3R4OiBOb2RlUmVzb2x1dGlvbkNvbnRleHQsXG4pOiBzdHJpbmcgfCBudWxsIHtcbiAgaWYgKCFyZW1haW5pbmdQYXRoKSB7XG4gICAgLy8gVHJ5IGluZGV4IGZpbGVzIGluIHRoZSBtb2R1bGUgcm9vdFxuICAgIGZvciAoY29uc3QgZXh0IG9mIGN0eC5leHRlbnNpb25zKSB7XG4gICAgICBjb25zdCBpbmRleFBhdGggPSBgJHtub2RlTW9kdWxlc1BhdGh9L2luZGV4JHtleHR9YFxuICAgICAgaWYgKGN0eC5mc01hcFtpbmRleFBhdGhdKSByZXR1cm4gaW5kZXhQYXRoXG4gICAgfVxuICAgIHJldHVybiBudWxsXG4gIH1cblxuICBjb25zdCBmdWxsUGF0aCA9IGAke25vZGVNb2R1bGVzUGF0aH0vJHtyZW1haW5pbmdQYXRofWBcbiAgY29uc3QgZGlyZWN0TWF0Y2ggPSB0cnlSZXNvbHZlV2l0aEV4dGVuc2lvbnMoZnVsbFBhdGgsIGN0eClcbiAgaWYgKGRpcmVjdE1hdGNoKSByZXR1cm4gZGlyZWN0TWF0Y2hcblxuICAvLyBUcnkgaW5kZXggZmlsZXNcbiAgZm9yIChjb25zdCBleHQgb2YgY3R4LmV4dGVuc2lvbnMpIHtcbiAgICBjb25zdCBpbmRleFBhdGggPSBgJHtmdWxsUGF0aH0vaW5kZXgke2V4dH1gXG4gICAgaWYgKGN0eC5mc01hcFtpbmRleFBhdGhdKSByZXR1cm4gaW5kZXhQYXRoXG4gIH1cbiAgcmV0dXJuIG51bGxcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZU5vZGVNb2R1bGVJblBhdGgoXG4gIHNlYXJjaFBhdGg6IHN0cmluZyxcbiAgY3R4OiBOb2RlUmVzb2x1dGlvbkNvbnRleHQsXG4pOiBzdHJpbmcgfCBudWxsIHtcbiAgY29uc3QgbW9kdWxlUGFydHMgPSBjdHgubW9kdWxlUGF0aC5zcGxpdChcIi9cIilcbiAgY29uc3Qgc2NvcGUgPSBtb2R1bGVQYXJ0c1swXS5zdGFydHNXaXRoKFwiQFwiKVxuICAgID8gbW9kdWxlUGFydHMuc2xpY2UoMCwgMikuam9pbihcIi9cIilcbiAgICA6IG1vZHVsZVBhcnRzWzBdXG4gIGNvbnN0IHJlbWFpbmluZ1BhdGggPSBtb2R1bGVQYXJ0cy5zbGljZShzY29wZS5pbmNsdWRlcyhcIi9cIikgPyAyIDogMSkuam9pbihcIi9cIilcbiAgY29uc3Qgbm9kZU1vZHVsZXNQYXRoID0gYCR7c2VhcmNoUGF0aCA9PSBcIi5cIiA/IFwiXCIgOiBgJHtzZWFyY2hQYXRofS9gfW5vZGVfbW9kdWxlcy8ke3Njb3BlfWBcblxuICAvLyBUcnkgdG8gZmluZCBwYWNrYWdlLmpzb25cbiAgY29uc3QgcGFja2FnZUpzb24gPSBmaW5kUGFja2FnZUpzb24obm9kZU1vZHVsZXNQYXRoLCBjdHgpXG4gIGlmIChwYWNrYWdlSnNvbikge1xuICAgIC8vIFRyeSByZXNvbHZpbmcgdGhyb3VnaCBleHBvcnRzIGZpZWxkXG4gICAgY29uc3QgZXhwb3J0c1Jlc29sdXRpb24gPSByZXNvbHZlUGFja2FnZUV4cG9ydHMoXG4gICAgICBub2RlTW9kdWxlc1BhdGgsXG4gICAgICBwYWNrYWdlSnNvbixcbiAgICAgIHJlbWFpbmluZ1BhdGgsXG4gICAgICBjdHgsXG4gICAgKVxuICAgIGlmIChleHBvcnRzUmVzb2x1dGlvbikgcmV0dXJuIGV4cG9ydHNSZXNvbHV0aW9uXG5cbiAgICAvLyBUcnkgcmVzb2x2aW5nIHRocm91Z2ggbWFpbi9tb2R1bGUgZmllbGRzXG4gICAgY29uc3QgZW50cnlQb2ludFJlc29sdXRpb24gPSByZXNvbHZlUGFja2FnZUVudHJ5UG9pbnQoXG4gICAgICBub2RlTW9kdWxlc1BhdGgsXG4gICAgICBwYWNrYWdlSnNvbixcbiAgICAgIGN0eCxcbiAgICApXG4gICAgaWYgKGVudHJ5UG9pbnRSZXNvbHV0aW9uKSByZXR1cm4gZW50cnlQb2ludFJlc29sdXRpb25cbiAgfVxuXG4gIC8vIFRyeSByZXNvbHZpbmcgcmVtYWluaW5nIHBhdGhcbiAgY29uc3QgcmVtYWluaW5nUGF0aFJlc29sdXRpb24gPSByZXNvbHZlUmVtYWluaW5nUGF0aChcbiAgICBub2RlTW9kdWxlc1BhdGgsXG4gICAgcmVtYWluaW5nUGF0aCxcbiAgICBjdHgsXG4gIClcbiAgaWYgKHJlbWFpbmluZ1BhdGhSZXNvbHV0aW9uKSByZXR1cm4gcmVtYWluaW5nUGF0aFJlc29sdXRpb25cblxuICAvLyBJZiBub3QgZm91bmQgYW5kIHdlIGhhdmUgYSBwYXJlbnQgZGlyZWN0b3J5LCB0cnkgdGhlcmVcbiAgY29uc3QgcGFyZW50UGF0aCA9IGRpcm5hbWUoc2VhcmNoUGF0aClcbiAgaWYgKHBhcmVudFBhdGggJiYgcGFyZW50UGF0aCAhPT0gc2VhcmNoUGF0aCkge1xuICAgIHJldHVybiByZXNvbHZlTm9kZU1vZHVsZUluUGF0aChwYXJlbnRQYXRoLCBjdHgpXG4gIH1cblxuICByZXR1cm4gbnVsbFxufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVzb2x2ZU5vZGVNb2R1bGUoXG4gIG1vZHVsZVBhdGg6IHN0cmluZyxcbiAgZnNNYXA6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4sXG4gIGJhc2VQYXRoOiBzdHJpbmcsXG4pOiBzdHJpbmcgfCBudWxsIHtcbiAgY29uc3QgY3R4ID0gY3JlYXRlQ29udGV4dChtb2R1bGVQYXRoLCBmc01hcCwgYmFzZVBhdGgpXG4gIHJldHVybiByZXNvbHZlTm9kZU1vZHVsZUluUGF0aChjdHguYmFzZVBhdGgsIGN0eClcbn1cbiIsICJpbXBvcnQgeyByZXNvbHZlTm9kZU1vZHVsZSB9IGZyb20gXCJsaWIvdXRpbHMvcmVzb2x2ZS1ub2RlLW1vZHVsZVwiXG5pbXBvcnQgdHlwZSB7IEV4ZWN1dGlvbkNvbnRleHQgfSBmcm9tIFwiLi9leGVjdXRpb24tY29udGV4dFwiXG5pbXBvcnQgeyBpbXBvcnRMb2NhbEZpbGUgfSBmcm9tIFwiLi9pbXBvcnQtbG9jYWwtZmlsZVwiXG5cbmV4cG9ydCBjb25zdCBpbXBvcnROb2RlTW9kdWxlID0gYXN5bmMgKFxuICBpbXBvcnROYW1lOiBzdHJpbmcsXG4gIGN0eDogRXhlY3V0aW9uQ29udGV4dCxcbiAgZGVwdGggPSAwLFxuKSA9PiB7XG4gIGNvbnN0IHsgcHJlU3VwcGxpZWRJbXBvcnRzIH0gPSBjdHhcblxuICBpZiAocHJlU3VwcGxpZWRJbXBvcnRzW2ltcG9ydE5hbWVdKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICBjb25zdCByZXNvbHZlZE5vZGVNb2R1bGVQYXRoID0gcmVzb2x2ZU5vZGVNb2R1bGUoaW1wb3J0TmFtZSwgY3R4LmZzTWFwLCBcIlwiKVxuXG4gIGlmICghcmVzb2x2ZWROb2RlTW9kdWxlUGF0aCkge1xuICAgIHRocm93IG5ldyBFcnJvcihgTm9kZSBtb2R1bGUgXCIke2ltcG9ydE5hbWV9XCIgbm90IGZvdW5kYClcbiAgfVxuXG4gIC8vIFVzZSBpbXBvcnRMb2NhbEZpbGUgdG8gaGFuZGxlIHRoZSBub2RlIG1vZHVsZVxuICBhd2FpdCBpbXBvcnRMb2NhbEZpbGUocmVzb2x2ZWROb2RlTW9kdWxlUGF0aCwgY3R4LCBkZXB0aClcblxuICAvLyBNYXAgdGhlIG9yaWdpbmFsIGltcG9ydCBuYW1lIHRvIHRoZSByZXNvbHZlZCBtb2R1bGUncyBleHBvcnRzXG4gIHByZVN1cHBsaWVkSW1wb3J0c1tpbXBvcnROYW1lXSA9IHByZVN1cHBsaWVkSW1wb3J0c1tyZXNvbHZlZE5vZGVNb2R1bGVQYXRoXVxuXG4gIC8vIE1hcCB3aXRob3V0IG5vZGVfbW9kdWxlcyBwcmVmaXggZm9yIGRpcmVjdCBpbXBvcnRzXG4gIGNvbnN0IHVucHJlZml4ZWRQYXRoID0gcmVzb2x2ZWROb2RlTW9kdWxlUGF0aC5yZXBsYWNlKC9ebm9kZV9tb2R1bGVzXFwvLywgXCJcIilcbiAgcHJlU3VwcGxpZWRJbXBvcnRzW3VucHJlZml4ZWRQYXRoXSA9XG4gICAgcHJlU3VwcGxpZWRJbXBvcnRzW3Jlc29sdmVkTm9kZU1vZHVsZVBhdGhdXG5cbiAgLy8gSGFuZGxlIGluZGV4IGZpbGVzIHNwZWNpYWxseVxuICBpZiAoXG4gICAgcmVzb2x2ZWROb2RlTW9kdWxlUGF0aC5lbmRzV2l0aChcIi9pbmRleC50c3hcIikgfHxcbiAgICByZXNvbHZlZE5vZGVNb2R1bGVQYXRoLmVuZHNXaXRoKFwiL2luZGV4LnRzXCIpIHx8XG4gICAgcmVzb2x2ZWROb2RlTW9kdWxlUGF0aC5lbmRzV2l0aChcIi9pbmRleC5qc1wiKVxuICApIHtcbiAgICBjb25zdCBkaXJQYXRoID0gcmVzb2x2ZWROb2RlTW9kdWxlUGF0aC5yZXBsYWNlKC9cXC9pbmRleFxcLih0c3g/fGpzKSQvLCBcIlwiKVxuICAgIGNvbnN0IHVucHJlZml4ZWREaXJQYXRoID0gZGlyUGF0aC5yZXBsYWNlKC9ebm9kZV9tb2R1bGVzXFwvLywgXCJcIilcbiAgICBwcmVTdXBwbGllZEltcG9ydHNbdW5wcmVmaXhlZERpclBhdGhdID1cbiAgICAgIHByZVN1cHBsaWVkSW1wb3J0c1tyZXNvbHZlZE5vZGVNb2R1bGVQYXRoXVxuXG4gICAgLy8gSGFuZGxlIHNjb3BlZCBwYWNrYWdlc1xuICAgIGlmICh1bnByZWZpeGVkRGlyUGF0aC5zdGFydHNXaXRoKFwiQFwiKSkge1xuICAgICAgY29uc3Qgc2NvcGVQYXJ0cyA9IHVucHJlZml4ZWREaXJQYXRoLnNwbGl0KFwiL1wiKVxuICAgICAgaWYgKHNjb3BlUGFydHMubGVuZ3RoID49IDIpIHtcbiAgICAgICAgY29uc3Qgc2NvcGVkTmFtZSA9IGAke3Njb3BlUGFydHNbMF19LyR7c2NvcGVQYXJ0c1sxXX1gXG4gICAgICAgIHByZVN1cHBsaWVkSW1wb3J0c1tzY29wZWROYW1lXSA9XG4gICAgICAgICAgcHJlU3VwcGxpZWRJbXBvcnRzW3Jlc29sdmVkTm9kZU1vZHVsZVBhdGhdXG4gICAgICB9XG4gICAgfVxuICB9XG59XG4iLCAiaW1wb3J0IHsgcmVzb2x2ZUZpbGVQYXRoT3JUaHJvdyB9IGZyb20gXCIuL3Jlc29sdmVGaWxlUGF0aFwiXG5pbXBvcnQgRGVidWcgZnJvbSBcImRlYnVnXCJcblxuY29uc3QgZGVidWcgPSBEZWJ1ZyhcInRzY2k6ZXZhbDpzZXR1cERlZmF1bHRFbnRyeXBvaW50SWZOZWVkZWRcIilcblxuZXhwb3J0IGNvbnN0IHNldHVwRGVmYXVsdEVudHJ5cG9pbnRJZk5lZWRlZCA9IChvcHRzOiB7XG4gIGVudHJ5cG9pbnQ/OiBzdHJpbmdcbiAgZnNNYXA6IFJlY29yZDxzdHJpbmcsIHN0cmluZz5cbiAgbWFpbkNvbXBvbmVudFBhdGg/OiBzdHJpbmdcbiAgbWFpbkNvbXBvbmVudE5hbWU/OiBzdHJpbmdcbiAgbmFtZT86IHN0cmluZ1xuICBtYWluQ29tcG9uZW50UHJvcHM/OiBSZWNvcmQ8c3RyaW5nLCBhbnk+XG59KSA9PiB7XG4gIGlmICghb3B0cy5lbnRyeXBvaW50ICYmICFvcHRzLm1haW5Db21wb25lbnRQYXRoKSB7XG4gICAgaWYgKFwiaW5kZXgudHN4XCIgaW4gb3B0cy5mc01hcCkge1xuICAgICAgb3B0cy5tYWluQ29tcG9uZW50UGF0aCA9IFwiaW5kZXgudHN4XCJcbiAgICB9IGVsc2UgaWYgKFwiaW5kZXgudHNcIiBpbiBvcHRzLmZzTWFwKSB7XG4gICAgICBvcHRzLm1haW5Db21wb25lbnRQYXRoID0gXCJpbmRleC50c1wiXG4gICAgfSBlbHNlIGlmIChcbiAgICAgIE9iamVjdC5rZXlzKG9wdHMuZnNNYXApLmZpbHRlcigoaykgPT4gay5lbmRzV2l0aChcIi50c3hcIikpLmxlbmd0aCA9PT0gMVxuICAgICkge1xuICAgICAgb3B0cy5tYWluQ29tcG9uZW50UGF0aCA9IE9iamVjdC5rZXlzKG9wdHMuZnNNYXApWzBdXG4gICAgfSBlbHNlIGlmIChcInRzY2lyY3VpdC5jb25maWcuanNvblwiIGluIG9wdHMuZnNNYXApIHtcbiAgICAgIGNvbnN0IGNvbmZpZ0NvbnRlbnQgPSBvcHRzLmZzTWFwW1widHNjaXJjdWl0LmNvbmZpZy5qc29uXCJdXG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBjb25maWcgPSBKU09OLnBhcnNlKGNvbmZpZ0NvbnRlbnQpXG4gICAgICAgIGlmIChjb25maWcubWFpbkVudHJ5cG9pbnQpIHtcbiAgICAgICAgICBvcHRzLmVudHJ5cG9pbnQgPSBjb25maWcubWFpbkVudHJ5cG9pbnRcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjb25zb2xlLndhcm4oXCJGYWlsZWQgdG8gcGFyc2UgdHNjaXJjdWl0LmNvbmZpZy5qc29uOlwiLCBlKVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIFwiRWl0aGVyIGVudHJ5cG9pbnQgb3IgbWFpbkNvbXBvbmVudFBhdGggbXVzdCBiZSBwcm92aWRlZCAobm8gaW5kZXggZmlsZSwgY291bGQgbm90IGluZmVyIGVudHJ5cG9pbnQpXCIsXG4gICAgICApXG4gICAgfVxuICB9XG5cbiAgaWYgKCFvcHRzLmVudHJ5cG9pbnQgJiYgb3B0cy5tYWluQ29tcG9uZW50UGF0aCkge1xuICAgIG9wdHMuZW50cnlwb2ludCA9IFwiZW50cnlwb2ludC50c3hcIlxuICAgIGNvbnN0IG1haW5Db21wb25lbnRDb2RlID1cbiAgICAgIG9wdHMuZnNNYXBbcmVzb2x2ZUZpbGVQYXRoT3JUaHJvdyhvcHRzLm1haW5Db21wb25lbnRQYXRoLCBvcHRzLmZzTWFwKV1cbiAgICBpZiAoIW1haW5Db21wb25lbnRDb2RlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBNYWluIGNvbXBvbmVudCBwYXRoIFwiJHtvcHRzLm1haW5Db21wb25lbnRQYXRofVwiIG5vdCBmb3VuZCBpbiBmc01hcC4gQXZhaWxhYmxlIHBhdGhzOiAke09iamVjdC5rZXlzKG9wdHMuZnNNYXApLmpvaW4oXCIsIFwiKX1gLFxuICAgICAgKVxuICAgIH1cblxuICAgIGNvbnN0IGhhc0V4cGxpY2l0Qm9hcmQgPSBtYWluQ29tcG9uZW50Q29kZS5pbmNsdWRlcyhcIjxib2FyZFwiKVxuICAgIGNvbnN0IGhhc1RzY2lJbXBvcnQgPVxuICAgICAgbWFpbkNvbXBvbmVudENvZGUuaW5jbHVkZXMoXCJAdHNjaS9cIikgfHxcbiAgICAgIG1haW5Db21wb25lbnRDb2RlLmluY2x1ZGVzKCdmcm9tIFwiQHRzY2knKVxuICAgIGNvbnN0IHNob3VsZFdyYXBJbkJvYXJkID0gIWhhc0V4cGxpY2l0Qm9hcmQgJiYgIWhhc1RzY2lJbXBvcnRcblxuICAgIG9wdHMuZnNNYXBbb3B0cy5lbnRyeXBvaW50XSA9IGBcbiAgICAgaW1wb3J0ICogYXMgVXNlckNvbXBvbmVudHMgZnJvbSBcIi4vJHtvcHRzLm1haW5Db21wb25lbnRQYXRofVwiO1xuICAgICAgICAgIFxuICAgICAgJHtcbiAgICAgICAgb3B0cy5tYWluQ29tcG9uZW50TmFtZVxuICAgICAgICAgID8gYFxuICAgICAgICBjb25zdCBDb21wb25lbnRUb1JlbmRlciA9IFVzZXJDb21wb25lbnRzW1wiJHtvcHRzLm1haW5Db21wb25lbnROYW1lfVwiXVxuICAgICAgICBgXG4gICAgICAgICAgOiBgY29uc3QgQ29tcG9uZW50VG9SZW5kZXIgPSBPYmplY3QuZW50cmllcyhVc2VyQ29tcG9uZW50cylcbiAgICAgICAgLmZpbHRlcigoW25hbWVdKSA9PiAhbmFtZS5zdGFydHNXaXRoKFwidXNlXCIpKVxuICAgICAgICAubWFwKChbXywgY29tcG9uZW50XSkgPT4gY29tcG9uZW50KVswXSB8fCAoKCkgPT4gbnVsbCk7YFxuICAgICAgfVxuXG4gICAgICAgICAgICR7XG4gICAgICAgICAgICAgZGVidWcuZW5hYmxlZFxuICAgICAgICAgICAgICAgPyBgXG4gICAgIGNvbnNvbGUubG9nKHsgVXNlckNvbXBvbmVudHMgfSlcbiAgICAgY29uc29sZS5sb2coXCJDb21wb25lbnRUb1JlbmRlciBcIiArIENvbXBvbmVudFRvUmVuZGVyLnRvU3RyaW5nKCksICB7IENvbXBvbmVudFRvUmVuZGVyIH0pXG4gICAgIGBcbiAgICAgICAgICAgICAgIDogXCJcIlxuICAgICAgICAgICB9XG5cbiAgICAgIGNpcmN1aXQuYWRkKFxuICAgICAgICAke1xuICAgICAgICAgIHNob3VsZFdyYXBJbkJvYXJkXG4gICAgICAgICAgICA/IGBcbiAgICAgICAgICA8Ym9hcmQ+XG4gICAgICAgICAgICA8Q29tcG9uZW50VG9SZW5kZXIgbmFtZT1cIlUxXCIgJHtvcHRzLm1haW5Db21wb25lbnRQcm9wcyA/IGB7Li4uJHtKU09OLnN0cmluZ2lmeShvcHRzLm1haW5Db21wb25lbnRQcm9wcywgbnVsbCwgMil9fWAgOiBcIlwifSAvPlxuICAgICAgICAgIDwvYm9hcmQ+XG4gICAgICAgIGBcbiAgICAgICAgICAgIDogYFxuICAgICAgICAgIDxDb21wb25lbnRUb1JlbmRlciAke29wdHMubWFpbkNvbXBvbmVudFByb3BzID8gYHsuLi4ke0pTT04uc3RyaW5naWZ5KG9wdHMubWFpbkNvbXBvbmVudFByb3BzLCBudWxsLCAyKX19YCA6IFwiXCJ9IC8+XG4gICAgICAgIGBcbiAgICAgICAgfVxuICAgICAgKTtcbmBcbiAgfVxuXG4gIGlmICghb3B0cy5uYW1lICYmIG9wdHMubWFpbkNvbXBvbmVudE5hbWUpIHtcbiAgICBvcHRzLm5hbWUgPSBvcHRzLm1haW5Db21wb25lbnROYW1lXG4gIH1cbn1cbiIsICJpbXBvcnQgeyBDaXJjdWl0UnVubmVyIH0gZnJvbSBcIi4vQ2lyY3VpdFJ1bm5lclwiXG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBydW5Uc2NpcmN1aXRDb2RlKFxuICBmaWxlc3lzdGVtT3JDb2RlU3RyaW5nOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+IHwgc3RyaW5nLFxuICBvcHRzPzogT21pdDxQYXJhbWV0ZXJzPENpcmN1aXRSdW5uZXJbXCJleGVjdXRlV2l0aEZzTWFwXCJdPlswXSwgXCJmc01hcFwiPixcbikge1xuICBpZiAoXG4gICAgdHlwZW9mIGZpbGVzeXN0ZW1PckNvZGVTdHJpbmcgPT09IFwic3RyaW5nXCIgJiZcbiAgICAhZmlsZXN5c3RlbU9yQ29kZVN0cmluZy5pbmNsdWRlcyhcImV4cG9ydFwiKVxuICApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBgVGhlIFwiZXhwb3J0XCIga2V5d29yZCB3YXNuJ3QgZm91bmQgaW4geW91ciBwcm92aWRlZCBjb2RlLiBZb3UgbmVlZCB0byBleHBvcnQgYSBjb21wb25lbnQgaW4geW91ciBjb2RlLCBlLmcuXFxuXFxuZXhwb3J0IGRlZmF1bHQgKCkgPT4gKFxcbiAgPHJlc2lzdG9yIG5hbWU9XCJSMVwiIHJlc2lzdGFuY2U9XCIxa1wiIC8+XFxuKWAsXG4gICAgKVxuICB9XG4gIGNvbnN0IGZpbGVzeXN0ZW0gPVxuICAgIHR5cGVvZiBmaWxlc3lzdGVtT3JDb2RlU3RyaW5nID09PSBcInN0cmluZ1wiXG4gICAgICA/IHsgXCJ1c2VyLWNvZGUudHN4XCI6IGZpbGVzeXN0ZW1PckNvZGVTdHJpbmcgfVxuICAgICAgOiBmaWxlc3lzdGVtT3JDb2RlU3RyaW5nXG5cbiAgY29uc3QgY2lyY3VpdFJ1bm5lciA9IG5ldyBDaXJjdWl0UnVubmVyKClcblxuICBhd2FpdCBjaXJjdWl0UnVubmVyLmV4ZWN1dGVXaXRoRnNNYXAoe1xuICAgIGZzTWFwOiBmaWxlc3lzdGVtLFxuICAgIC4uLm9wdHMsXG4gIH0pXG5cbiAgYXdhaXQgY2lyY3VpdFJ1bm5lci5yZW5kZXJVbnRpbFNldHRsZWQoKVxuXG4gIHJldHVybiBhd2FpdCBjaXJjdWl0UnVubmVyLmdldENpcmN1aXRKc29uKClcbn1cbiIsICJpbXBvcnQgeyBydW5Uc2NpcmN1aXRDb2RlIH0gZnJvbSBcIi4vcnVuVHNjaXJjdWl0Q29kZVwiXG5cbmV4cG9ydCBjb25zdCBydW5Uc2NpcmN1aXRNb2R1bGUgPSBhc3luYyAoXG4gIG1vZHVsZTogc3RyaW5nLFxuICBvcHRzOiB7IHByb3BzPzogUmVjb3JkPHN0cmluZywgYW55PjsgZXhwb3J0TmFtZT86IHN0cmluZyB9ID0ge30sXG4pID0+IHtcbiAgaWYgKCFtb2R1bGUuc3RhcnRzV2l0aChcIkBcIikpIHtcbiAgICBtb2R1bGUgPSBgQHRzY2kvJHttb2R1bGUucmVwbGFjZSgvXFwvLywgXCIuXCIpfWBcbiAgfVxuICBjb25zdCBjaXJjdWl0SnNvbiA9IGF3YWl0IHJ1blRzY2lyY3VpdENvZGUoXG4gICAge1xuICAgICAgLy8gVE9ETyBoYW5kbGUgZXhwb3J0cyB0aGF0IGFyZSBub3QgdGhlIGRlZmF1bHQgZXhwb3J0IGJ5IHNjYW5uaW5nXG4gICAgICAvLyBvdGhlckV4cG9ydHMgZm9yIGNvbXBvbmVudHNcbiAgICAgIFwidXNlci1jb2RlLnRzeFwiOiBgXG4gICAgaW1wb3J0IE1vZHVsZSwgKiBhcyBvdGhlckV4cG9ydHMgZnJvbSBcIiR7bW9kdWxlfVwiO1xuXG4gICAgbGV0IGV4cG9ydE5hbWUgPSBcIiR7b3B0cy5leHBvcnROYW1lID8/IFwiXCJ9XCJcblxuICAgIGlmICgoIU1vZHVsZSB8fCB0eXBlb2YgTW9kdWxlICE9PSBcImZ1bmN0aW9uXCIpICYmICFCb29sZWFuKGV4cG9ydE5hbWUpKSB7XG4gICAgICBleHBvcnROYW1lID0gT2JqZWN0LmtleXMob3RoZXJFeHBvcnRzKS5maWx0ZXIoa2V5ID0+IGtleVswXSA9PT0ga2V5WzBdLnRvVXBwZXJDYXNlKCkgJiYgdHlwZW9mIG90aGVyRXhwb3J0c1trZXldID09PSBcImZ1bmN0aW9uXCIpWzBdXG4gICAgfVxuXG4gICAgY29uc3QgZGVmYXVsdEV4cG9ydCA9IGV4cG9ydE5hbWUgPyBvdGhlckV4cG9ydHNbZXhwb3J0TmFtZV0gOiBNb2R1bGVcblxuICAgIGlmICghZGVmYXVsdEV4cG9ydCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxcYE5vIGV4cG9ydCBmb3VuZCBmb3IgbW9kdWxlIFwiXFwke21vZHVsZX1cIiAodHJpZWQgXCJcXCR7ZXhwb3J0TmFtZSA/PyBcImRlZmF1bHRcIn1cIilcXGApXG4gICAgfVxuXG4gICAgZXhwb3J0IGRlZmF1bHQgZGVmYXVsdEV4cG9ydDtcbiAgICBgLFxuICAgIH0sXG4gICAge1xuICAgICAgbWFpbkNvbXBvbmVudFByb3BzOiBvcHRzLnByb3BzLFxuICAgIH0sXG4gIClcbiAgcmV0dXJuIGNpcmN1aXRKc29uXG59XG4iXSwKICAibWFwcGluZ3MiOiAiO0FBQUEsU0FBUyxtQkFBbUI7QUFFNUIsWUFBWSxtQkFBbUI7QUFDL0IsWUFBWSxXQUFXO0FBQ3ZCLFlBQVksZ0JBQWdCO0FBQzVCLFlBQVksd0JBQXdCOzs7QUNIcEMsSUFBTSxRQUFRLG9CQUFJLElBQWlCO0FBRW5DLElBQU0sb0JBQW9CLE9BQU8sTUFBVyxXQUFnQjtBQUMxRCxRQUFNLGNBQWMsSUFBSSxnQkFBZ0I7QUFBQSxJQUN0QyxHQUFHO0FBQUEsSUFDSCxNQUFNO0FBQUEsRUFDUixDQUFDLEVBQUUsU0FBUztBQUNaLE1BQUksTUFBTSxJQUFJLFdBQVcsR0FBRztBQUMxQixXQUFPLE1BQU0sSUFBSSxXQUFXO0FBQUEsRUFDOUI7QUFDQSxRQUFNLFdBQVcsTUFBTTtBQUFBLElBQ3JCLG1DQUFtQyxJQUFJLFNBQVMsV0FBVztBQUFBLEVBQzdEO0FBQ0EsUUFBTSxlQUFlLE1BQU0sU0FBUyxLQUFLO0FBQ3pDLFFBQU0sSUFBSSxhQUFhLFlBQVk7QUFDbkMsU0FBTztBQUNUO0FB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bEQsZ0JBQU0sVUFBVSxLQUFLLGtCQUFrQjtBQUl2QyxrQkFBUSxpQkFBaUIsT0FBTyxRQUFRO0FBQUEsUUFDMUM7QUFBQSxNQUNGO0FBQUEsSUFDRjtBQUVBLGVBQVcsU0FBUyxLQUFLLGlCQUFpQjtBQUN4QyxhQUFPLEtBQUssZ0JBQWdCLEtBQUs7QUFBQSxJQUNuQztBQUFBLEVBQ0Y7QUFBQSxFQUVBLE1BQU0sT0FBTztBQUVYLFNBQUssb0JBQW9CO0FBQUEsRUFDM0I7QUFBQSxFQUVBLE1BQU0sc0JBQXNCLFNBQWlCO0FBQzNDLFNBQUssNEJBQTRCLHFCQUFxQjtBQUFBLEVBQ3hEO0FBQUEsRUFFQSxNQUFNLGtCQUFrQixVQUEwQjtBQUNoRCxTQUFLLDRCQUE0QixXQUFXO0FBQUEsRUFDOUM7QUFBQSxFQUVRLG9CQUFvQixTQUFzQjtBQUNoRCxlQUFXLFNBQVMsS0FBSyxpQkFBaUI7QUFDeEMsaUJBQVcsWUFBWSxLQUFLLGdCQUFnQixLQUFLLEdBQUc7QUFDbEQsZ0JBQVEsR0FBRyxPQUFjLFFBQWU7QUFBQSxNQUMxQztBQUFBLElBQ0Y7QUFBQSxFQUNGO0FBQ0Y7OztBVzVKQSxlQUFzQixpQkFDcEIsd0JBQ0EsTUFDQTtBQUNBLE1BQ0UsT0FBTywyQkFBMkIsWUFDbEMsQ0FBQyx1QkFBdUIsU0FBUyxRQUFRLEdBQ3pDO0FBQ0EsVUFBTSxJQUFJO0FBQUEsTUFDUjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsSUFDRjtBQUFBLEVBQ0Y7QUFDQSxRQUFNLGFBQ0osT0FBTywyQkFBMkIsV0FDOUIsRUFBRSxpQkFBaUIsdUJBQXVCLElBQzFDO0FBRU4sUUFBTSxnQkFBZ0IsSUFBSSxjQUFjO0FBRXhDLFFBQU0sY0FBYyxpQkFBaUI7QUFBQSxJQUNuQyxPQUFPO0FBQUEsSUFDUCxHQUFHO0FBQUEsRUFDTCxDQUFDO0FBRUQsUUFBTSxjQUFjLG1CQUFtQjtBQUV2QyxTQUFPLE1BQU0sY0FBYyxlQUFlO0FBQzVDOzs7QUMzQk8sSUFBTSxxQkFBcUIsT0FDaEMsUUFDQSxPQUE2RCxDQUFDLE1BQzNEO0FBQ0gsTUFBSSxDQUFDLE9BQU8sV0FBVyxHQUFHLEdBQUc7QUFDM0IsYUFBUyxTQUFTLE9BQU8sUUFBUSxNQUFNLEdBQUcsQ0FBQztBQUFBLEVBQzdDO0FBQ0EsUUFBTSxjQUFjLE1BQU07QUFBQSxJQUN4QjtBQUFBO0FBQUE7QUFBQSxNQUdFLGlCQUFpQjtBQUFBLDZDQUNzQixNQUFNO0FBQUE7QUFBQSx3QkFFM0IsS0FBSyxjQUFjLEVBQUU7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLElBY3pDO0FBQUEsSUFDQTtBQUFBLE1BQ0Usb0JBQW9CLEtBQUs7QUFBQSxJQUMzQjtBQUFBLEVBQ0Y7QUFDQSxTQUFPO0FBQ1Q7IiwKICAibmFtZXMiOiBbIkRlYnVnIiwgImRlYnVnIiwgImltcG9ydE5hbWUiLCAiRGVidWciLCAiZGVidWciLCAiRGVidWciLCAiZGVidWciLCAiRGVidWciLCAiZGVidWciXQp9Cg==