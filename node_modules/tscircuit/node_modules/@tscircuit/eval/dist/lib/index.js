// webworker/execution-context.ts
import { RootCircuit } from "@tscircuit/core";
import * as tscircuitCore from "@tscircuit/core";
import * as React from "react";
import * as jscadFiber from "jscad-fiber";
import * as tscircuitMathUtils from "@tscircuit/math-utils";

// node_modules/@tscircuit/parts-engine/lib/jlc-parts-engine.ts
var cache = /* @__PURE__ */ new Map();
var getJlcPartsCached = async (name, params) => {
  const paramString = new URLSearchParams({
    ...params,
    json: "true"
  }).toString();
  if (cache.has(paramString)) {
    return cache.get(paramString);
  }
  const response = await fetch(
    `https://jlcsearch.tscircuit.com/${name}/list?${paramString}`
  );
  const responseJson = await response.json();
  cache.set(paramString, responseJson);
  return responseJson;
};
var jlcPartsEngine = {
  findPart: async ({
    sourceComponent,
    footprinterString
  }) => {
    if (sourceComponent.type === "source_component" && sourceComponent.ftype === "simple_resistor") {
      const { resistors } = await getJlcPartsCached("resistors", {
        resistance: sourceComponent.display_resistance ?? sourceComponent.resistance,
        package: footprinterString
      });
      return {
        jlcpcb: (resistors ?? []).map((r) => `C${r.lcsc}`).slice(0, 3)
      };
    } else if (sourceComponent.type === "source_component" && sourceComponent.ftype === "simple_capacitor") {
      if (footprinterString?.includes("cap")) {
        footprinterString = footprinterString.replace("cap", "");
      }
      const { capacitors } = await getJlcPartsCached("capacitors", {
        capacitance: sourceComponent.display_capacitance ?? sourceComponent.capacitance,
        package: footprinterString
      });
      return {
        jlcpcb: (capacitors ?? []).map((c) => `C${c.lcsc}`).slice(0, 3)
      };
    } else if (sourceComponent.type === "source_component" && sourceComponent.ftype === "simple_pin_header") {
      let pitch;
      if (footprinterString?.includes("_p")) {
        pitch = Number(footprinterString.split("_p")[1]);
      }
      const { headers } = await getJlcPartsCached(
        "headers",
        pitch ? {
          pitch,
          num_pins: sourceComponent.pin_count,
          gender: sourceComponent.gender
        } : {
          num_pins: sourceComponent.pin_count,
          gender: sourceComponent.gender
        }
      );
      return {
        jlcpcb: (headers ?? []).map((h) => `C${h.lcsc}`).slice(0, 3)
      };
    } else if (sourceComponent.type === "source_component" && sourceComponent.ftype === "simple_potentiometer") {
      const { potentiometers } = await getJlcPartsCached("potentiometers", {
        resistance: sourceComponent.max_resistance,
        package: footprinterString
      });
      return {
        jlcpcb: (potentiometers ?? []).map((p) => `C${p.lcsc}`).slice(0, 3)
      };
    } else if (sourceComponent.type === "source_component" && sourceComponent.ftype === "simple_diode") {
      const { diodes } = await getJlcPartsCached("diodes", {
        package: footprinterString
      });
      return {
        jlcpcb: (diodes ?? []).map((d) => `C${d.lcsc}`).slice(0, 3)
      };
    } else if (sourceComponent.type === "source_component" && sourceComponent.ftype === "simple_chip") {
      const { chips } = await getJlcPartsCached("chips", {
        package: footprinterString
      });
      return {
        jlcpcb: (chips ?? []).map((c) => `C${c.lcsc}`).slice(0, 3)
      };
    } else if (sourceComponent.type === "source_component" && sourceComponent.ftype === "simple_transistor") {
      const { transistors } = await getJlcPartsCached("transistors", {
        package: footprinterString,
        transistor_type: sourceComponent.transistor_type
      });
      return {
        jlcpcb: (transistors ?? []).map((t) => `C${t.lcsc}`).slice(0, 3)
      };
    } else if (sourceComponent.type === "source_component" && sourceComponent.ftype === "simple_power_source") {
      const { power_sources } = await getJlcPartsCached("power_sources", {
        voltage: sourceComponent.voltage,
        package: footprinterString
      });
      return {
        jlcpcb: (power_sources ?? []).map((p) => `C${p.lcsc}`).slice(0, 3)
      };
    } else if (sourceComponent.type === "source_component" && sourceComponent.ftype === "simple_inductor") {
      const { inductors } = await getJlcPartsCached("inductors", {
        inductance: sourceComponent.inductance,
        package: footprinterString
      });
      return {
        jlcpcb: (inductors ?? []).map((i) => `C${i.lcsc}`).slice(0, 3)
      };
    } else if (sourceComponent.type === "source_component" && sourceComponent.ftype === "simple_crystal") {
      const { crystals } = await getJlcPartsCached("crystals", {
        frequency: sourceComponent.frequency,
        load_capacitance: sourceComponent.load_capacitance,
        package: footprinterString
      });
      return {
        jlcpcb: (crystals ?? []).map((c) => `C${c.lcsc}`).slice(0, 3)
      };
    } else if (sourceComponent.type === "source_component" && sourceComponent.ftype === "simple_mosfet") {
      const { mosfets } = await getJlcPartsCached("mosfets", {
        package: footprinterString,
        mosfet_mode: sourceComponent.mosfet_mode,
        channel_type: sourceComponent.channel_type
      });
      return {
        jlcpcb: (mosfets ?? []).map((m) => `C${m.lcsc}`).slice(0, 3)
      };
    } else if (sourceComponent.type === "source_component" && sourceComponent.ftype === "simple_resonator") {
      const { resonators } = await getJlcPartsCached("resonators", {
        frequency: sourceComponent.frequency,
        package: footprinterString
      });
      return {
        jlcpcb: (resonators ?? []).map((r) => `C${r.lcsc}`).slice(0, 3)
      };
    } else if (sourceComponent.type === "source_component" && sourceComponent.ftype === "simple_switch") {
      const { switches } = await getJlcPartsCached("switches", {
        switch_type: sourceComponent.type,
        package: footprinterString
      });
      return {
        jlcpcb: (switches ?? []).map((s) => `C${s.lcsc}`).slice(0, 3)
      };
    } else if (sourceComponent.type === "source_component" && sourceComponent.ftype === "simple_led") {
      const { leds } = await getJlcPartsCached("leds", {
        package: footprinterString
      });
      return {
        jlcpcb: (leds ?? []).map((l) => `C${l.lcsc}`).slice(0, 3)
      };
    } else if (sourceComponent.type === "source_component" && sourceComponent.ftype === "simple_fuse") {
      const { fuses } = await getJlcPartsCached("fuses", {
        package: footprinterString
      });
      return {
        jlcpcb: (fuses ?? []).map((l) => `C${l.lcsc}`).slice(0, 3)
      };
    }
    return {};
  }
};

// lib/getPlatformConfig.ts
var getPlatformConfig = () => ({
  partsEngine: jlcPartsEngine
});

// webworker/execution-context.ts
import Debug from "debug";
var debug = Debug("tsci:eval:execution-context");
function createExecutionContext(webWorkerConfiguration, opts = {}) {
  globalThis.React = React;
  const circuit = new RootCircuit({
    platform: opts.platform || getPlatformConfig()
  });
  if (opts.name) {
    circuit.name = opts.name;
  }
  return {
    fsMap: {},
    entrypoint: "",
    preSuppliedImports: {
      "@tscircuit/core": tscircuitCore,
      tscircuit: tscircuitCore,
      "@tscircuit/math-utils": tscircuitMathUtils,
      react: React,
      "jscad-fiber": jscadFiber,
      // This is usually used as a type import, we can remove the shim when we
      // ignore type imports in getImportsFromCode
      "@tscircuit/props": {}
    },
    circuit,
    ...webWorkerConfiguration
  };
}

// lib/runner/normalizeFsMap.ts
function normalizeFilePath(filePath) {
  let normFilePath = filePath;
  normFilePath = normFilePath.replace(/\\/g, "/");
  normFilePath = normFilePath.trim();
  if (normFilePath.startsWith("./")) {
    normFilePath = normFilePath.slice(2);
  }
  if (normFilePath.startsWith("/")) {
    normFilePath = normFilePath.slice(1);
  }
  return normFilePath;
}
function normalizeFsMap(fsMap) {
  const normalizedFsMap = {};
  for (const [fsPath, fileContent] of Object.entries(fsMap)) {
    normalizedFsMap[normalizeFilePath(fsPath)] = fileContent;
  }
  return normalizedFsMap;
}

// lib/runner/CircuitRunner.ts
import "react";

// lib/utils/dirname.ts
function dirname(path) {
  if (!path) return ".";
  const normalizedPath = path.replace(/\\/g, "/");
  const cleanPath = normalizedPath.replace(/\/+$/, "");
  if (cleanPath.indexOf("/") === -1) return ".";
  return cleanPath.substring(0, cleanPath.lastIndexOf("/")) || "/";
}

// lib/runner/resolveFilePath.ts
function resolveRelativePath(importPath, cwd) {
  if (importPath.startsWith("../")) {
    const parentDir = dirname(cwd);
    return resolveRelativePath(importPath.slice(3), parentDir);
  }
  if (importPath.startsWith("./")) {
    return resolveRelativePath(importPath.slice(2), cwd);
  }
  if (importPath.startsWith("/")) {
    return importPath.slice(1);
  }
  return `${cwd}/${importPath}`;
}
var resolveFilePath = (unknownFilePath, fsMapOrAllFilePaths, cwd) => {
  const resolvedPath = cwd ? resolveRelativePath(unknownFilePath, cwd) : unknownFilePath;
  const filePaths = new Set(
    Array.isArray(fsMapOrAllFilePaths) ? fsMapOrAllFilePaths : Object.keys(fsMapOrAllFilePaths)
  );
  if (filePaths.has(resolvedPath)) {
    return resolvedPath;
  }
  const normalizedFilePathMap = /* @__PURE__ */ new Map();
  for (const filePath of filePaths) {
    normalizedFilePathMap.set(normalizeFilePath(filePath), filePath);
  }
  const normalizedResolvedPath = normalizeFilePath(resolvedPath);
  if (normalizedFilePathMap.has(normalizedResolvedPath)) {
    return normalizedFilePathMap.get(normalizedResolvedPath);
  }
  const extension = ["tsx", "ts", "json", "js", "jsx"];
  for (const ext of extension) {
    const possibleFilePath = `${normalizedResolvedPath}.${ext}`;
    if (normalizedFilePathMap.has(possibleFilePath)) {
      return normalizedFilePathMap.get(possibleFilePath);
    }
  }
  if (!unknownFilePath.startsWith("./") && !unknownFilePath.startsWith("../")) {
    const normalizedUnknownFilePath = normalizeFilePath(unknownFilePath);
    if (normalizedFilePathMap.has(normalizedUnknownFilePath)) {
      return normalizedFilePathMap.get(normalizedUnknownFilePath);
    }
    for (const ext of extension) {
      const possibleFilePath = `${normalizedUnknownFilePath}.${ext}`;
      if (normalizedFilePathMap.has(possibleFilePath)) {
        return normalizedFilePathMap.get(possibleFilePath);
      }
    }
  }
  return null;
};
var resolveFilePathOrThrow = (unknownFilePath, fsMapOrAllFilePaths) => {
  const resolvedFilePath = resolveFilePath(unknownFilePath, fsMapOrAllFilePaths);
  if (!resolvedFilePath) {
    throw new Error(
      `File not found "${unknownFilePath}", available paths:

${Object.keys(fsMapOrAllFilePaths).join(", ")}`
    );
  }
  return resolvedFilePath;
};

// webworker/eval-compiled-js.ts
function evalCompiledJs(compiledCode, preSuppliedImports, cwd) {
  ;
  globalThis.__tscircuit_require = (name) => {
    const resolvedFilePath = resolveFilePath(name, preSuppliedImports, cwd);
    const hasResolvedFilePath = resolvedFilePath && preSuppliedImports[resolvedFilePath];
    if (!preSuppliedImports[name] && !hasResolvedFilePath) {
      throw new Error(`Import "${name}" not found ${cwd ? `in "${cwd}"` : ""}`);
    }
    const mod = preSuppliedImports[name] || preSuppliedImports[resolvedFilePath];
    return new Proxy(mod, {
      get(target, prop) {
        if (!(prop in target)) {
          if (prop === "default") {
            if (target.default !== void 0) {
              return target.default;
            }
            if (target.__esModule) {
              return void 0;
            }
            if (typeof target === "function" || typeof target === "object") {
              return target;
            }
            return void 0;
          }
          if (prop === "__esModule") {
            return true;
          }
          throw new Error(
            `Component "${String(prop)}" is not exported by "${name}"`
          );
        }
        return target[prop];
      }
    });
  };
  const functionBody = `
  var exports = {};
  var require = globalThis.__tscircuit_require;
  var module = { exports };
  var circuit = globalThis.__tscircuit_circuit;
  ${compiledCode};
  return module;`.trim();
  return Function(functionBody).call(globalThis);
}

// webworker/import-eval-path.ts
import "@babel/standalone";

// webworker/import-local-file.ts
import * as Babel from "@babel/standalone";

// lib/utils/get-imports-from-code.ts
var getImportsFromCode = (code) => {
  const importRegex = /^\s*import\s+(?:(?:[\w\s]+,\s*)?(?:\*\s+as\s+[\w\s]+|\{[\s\w,]+\}|\w+)\s+from\s+)?['"](.+?)['"]/gm;
  const imports = [];
  let match;
  while ((match = importRegex.exec(code)) !== null) {
    imports.push(match[1]);
  }
  const reExportRegex = /^\s*export\s+(?:\*|(?:\{[\s\w,]+\}))\s+from\s+['"](.+?)['"]/gm;
  let reExportMatch;
  while ((reExportMatch = reExportRegex.exec(code)) !== null) {
    imports.push(reExportMatch[1]);
  }
  return imports;
};

// webworker/import-local-file.ts
import Debug2 from "debug";
var debug2 = Debug2("tsci:eval:import-local-file");
var importLocalFile = async (importName, ctx, depth = 0) => {
  debug2("importLocalFile called with:", {
    importName
  });
  const { fsMap, preSuppliedImports } = ctx;
  const fsPath = resolveFilePathOrThrow(importName, fsMap);
  debug2("fsPath:", fsPath);
  if (!ctx.fsMap[fsPath]) {
    debug2("fsPath not found in fsMap:", fsPath);
    throw new Error(`File "${fsPath}" not found`);
  }
  const fileContent = fsMap[fsPath];
  debug2("fileContent:", fileContent?.slice(0, 100));
  if (fsPath.endsWith(".json")) {
    const jsonData = JSON.parse(fileContent);
    preSuppliedImports[fsPath] = {
      __esModule: true,
      default: jsonData
    };
  } else if (fsPath.endsWith(".tsx") || fsPath.endsWith(".ts")) {
    const importNames = getImportsFromCode(fileContent);
    for (const importName2 of importNames) {
      if (!preSuppliedImports[importName2]) {
        await importEvalPath(importName2, ctx, depth + 1, {
          cwd: dirname(fsPath)
        });
      }
    }
    const result = Babel.transform(fileContent, {
      presets: ["react", "typescript"],
      plugins: ["transform-modules-commonjs"],
      filename: "virtual.tsx"
    });
    if (!result || !result.code) {
      throw new Error("Failed to transform code");
    }
    try {
      debug2("evalCompiledJs called with:", {
        code: result.code?.slice(0, 100),
        dirname: dirname(fsPath)
      });
      const importRunResult = evalCompiledJs(
        result.code,
        preSuppliedImports,
        dirname(fsPath)
      );
      debug2("importRunResult:", {
        fsPath,
        importRunResult
      });
      preSuppliedImports[fsPath] = importRunResult.exports;
    } catch (error) {
      throw new Error(
        `Eval compiled js error for "${importName}": ${error.message}`
      );
    }
  } else if (fsPath.endsWith(".js")) {
    const result = Babel.transform(fileContent, {
      presets: ["env"],
      plugins: ["transform-modules-commonjs"],
      filename: fsPath
    });
    if (!result || !result.code) {
      throw new Error("Failed to transform JS code");
    }
    preSuppliedImports[fsPath] = evalCompiledJs(
      result.code,
      preSuppliedImports,
      dirname(fsPath)
    ).exports;
  } else {
    throw new Error(
      `Unsupported file extension "${fsPath.split(".").pop()}" for "${fsPath}"`
    );
  }
};

// webworker/import-snippet.ts
import "@babel/standalone";
async function importSnippet(importName, ctx, depth = 0) {
  const { preSuppliedImports } = ctx;
  const fullSnippetName = importName.replace("@tsci/", "").replace(".", "/");
  const { cjs, error } = await fetch(`${ctx.cjsRegistryUrl}/${fullSnippetName}`).then(async (res) => ({ cjs: await res.text(), error: null })).catch((e) => ({ error: e, cjs: null }));
  if (error) {
    console.error("Error fetching import", importName, error);
    return;
  }
  try {
    preSuppliedImports[importName] = evalCompiledJs(
      cjs,
      preSuppliedImports
    ).exports;
  } catch (e) {
    console.error("Error importing snippet", e);
  }
}

// lib/utils/resolve-node-module.ts
function createContext(modulePath, fsMap, basePath) {
  return {
    fsMap,
    extensions: [".js", ".jsx", ".ts", ".tsx", ".json"],
    basePath,
    modulePath
  };
}
function findPackageJson(nodeModulesPath, ctx) {
  const packageJsonPath = `${nodeModulesPath}/package.json`;
  if (!ctx.fsMap[packageJsonPath]) return null;
  try {
    return JSON.parse(ctx.fsMap[packageJsonPath]);
  } catch {
    return null;
  }
}
function tryResolveWithExtensions(path, ctx) {
  if (ctx.fsMap[path]) return path;
  for (const ext of ctx.extensions) {
    const pathWithExt = path.replace(/\.js$|\.jsx$/, "") + ext;
    if (ctx.fsMap[pathWithExt]) return pathWithExt;
  }
  return null;
}
function resolveExportPath(nodeModulesPath, exportPath, ctx) {
  const fullExportPath = `${nodeModulesPath}/${exportPath.replace(/^\.\//, "")}`;
  return tryResolveWithExtensions(fullExportPath, ctx);
}
function resolvePackageExports(nodeModulesPath, packageJson, remainingPath, ctx) {
  if (!packageJson.exports) return null;
  const defaultExport = packageJson.exports["."];
  if (remainingPath === "" && defaultExport) {
    if (typeof defaultExport === "string") {
      const resolved = resolveExportPath(nodeModulesPath, defaultExport, ctx);
      if (resolved) return resolved;
    }
  }
  const subpathExport = remainingPath ? packageJson.exports[`./${remainingPath}`] : null;
  if (subpathExport && typeof subpathExport === "string") {
    const resolved = resolveExportPath(nodeModulesPath, subpathExport, ctx);
    if (resolved) return resolved;
  }
  const importExport = packageJson.exports["import"];
  if (remainingPath === "" && importExport && typeof importExport === "string") {
    const resolved = resolveExportPath(nodeModulesPath, importExport, ctx);
    if (resolved) return resolved;
  }
  return null;
}
function resolvePackageEntryPoint(nodeModulesPath, packageJson, ctx) {
  const entryPoint = packageJson.module || packageJson.main || "index.js";
  const fullPath = `${nodeModulesPath}/${entryPoint}`;
  return tryResolveWithExtensions(fullPath, ctx);
}
function resolveRemainingPath(nodeModulesPath, remainingPath, ctx) {
  if (!remainingPath) {
    for (const ext of ctx.extensions) {
      const indexPath = `${nodeModulesPath}/index${ext}`;
      if (ctx.fsMap[indexPath]) return indexPath;
    }
    return null;
  }
  const fullPath = `${nodeModulesPath}/${remainingPath}`;
  const directMatch = tryResolveWithExtensions(fullPath, ctx);
  if (directMatch) return directMatch;
  for (const ext of ctx.extensions) {
    const indexPath = `${fullPath}/index${ext}`;
    if (ctx.fsMap[indexPath]) return indexPath;
  }
  return null;
}
function resolveNodeModuleInPath(searchPath, ctx) {
  const moduleParts = ctx.modulePath.split("/");
  const scope = moduleParts[0].startsWith("@") ? moduleParts.slice(0, 2).join("/") : moduleParts[0];
  const remainingPath = moduleParts.slice(scope.includes("/") ? 2 : 1).join("/");
  const nodeModulesPath = `${searchPath == "." ? "" : `${searchPath}/`}node_modules/${scope}`;
  const packageJson = findPackageJson(nodeModulesPath, ctx);
  if (packageJson) {
    const exportsResolution = resolvePackageExports(
      nodeModulesPath,
      packageJson,
      remainingPath,
      ctx
    );
    if (exportsResolution) return exportsResolution;
    const entryPointResolution = resolvePackageEntryPoint(
      nodeModulesPath,
      packageJson,
      ctx
    );
    if (entryPointResolution) return entryPointResolution;
  }
  const remainingPathResolution = resolveRemainingPath(
    nodeModulesPath,
    remainingPath,
    ctx
  );
  if (remainingPathResolution) return remainingPathResolution;
  const parentPath = dirname(searchPath);
  if (parentPath && parentPath !== searchPath) {
    return resolveNodeModuleInPath(parentPath, ctx);
  }
  return null;
}
function resolveNodeModule(modulePath, fsMap, basePath) {
  const ctx = createContext(modulePath, fsMap, basePath);
  return resolveNodeModuleInPath(ctx.basePath, ctx);
}

// webworker/import-node-module.ts
var importNodeModule = async (importName, ctx, depth = 0) => {
  const { preSuppliedImports } = ctx;
  if (preSuppliedImports[importName]) {
    return;
  }
  const resolvedNodeModulePath = resolveNodeModule(importName, ctx.fsMap, "");
  if (!resolvedNodeModulePath) {
    throw new Error(`Node module "${importName}" not found`);
  }
  await importLocalFile(resolvedNodeModulePath, ctx, depth);
  preSuppliedImports[importName] = preSuppliedImports[resolvedNodeModulePath];
  const unprefixedPath = resolvedNodeModulePath.replace(/^node_modules\//, "");
  preSuppliedImports[unprefixedPath] = preSuppliedImports[resolvedNodeModulePath];
  if (resolvedNodeModulePath.endsWith("/index.tsx") || resolvedNodeModulePath.endsWith("/index.ts") || resolvedNodeModulePath.endsWith("/index.js")) {
    const dirPath = resolvedNodeModulePath.replace(/\/index\.(tsx?|js)$/, "");
    const unprefixedDirPath = dirPath.replace(/^node_modules\//, "");
    preSuppliedImports[unprefixedDirPath] = preSuppliedImports[resolvedNodeModulePath];
    if (unprefixedDirPath.startsWith("@")) {
      const scopeParts = unprefixedDirPath.split("/");
      if (scopeParts.length >= 2) {
        const scopedName = `${scopeParts[0]}/${scopeParts[1]}`;
        preSuppliedImports[scopedName] = preSuppliedImports[resolvedNodeModulePath];
      }
    }
  }
};

// webworker/import-eval-path.ts
import Debug3 from "debug";
var debug3 = Debug3("tsci:eval:import-eval-path");
async function importEvalPath(importName, ctx, depth = 0, opts = {}) {
  debug3("importEvalPath called with:", {
    importName,
    depth,
    opts
  });
  debug3(`${"  ".repeat(depth)}\u27A1\uFE0F`, importName);
  const { preSuppliedImports } = ctx;
  if (preSuppliedImports[importName]) return;
  if (importName.startsWith("./") && preSuppliedImports[importName.slice(2)])
    return;
  if (depth > 5) {
    console.log("Max depth for imports reached");
    return;
  }
  const resolvedLocalImportPath = resolveFilePath(
    importName,
    ctx.fsMap,
    opts.cwd
  );
  if (resolvedLocalImportPath) {
    return importLocalFile(resolvedLocalImportPath, ctx, depth);
  }
  const resolvedNodeModulePath = resolveNodeModule(
    importName,
    ctx.fsMap,
    opts.cwd || ""
  );
  if (resolvedNodeModulePath) {
    return importNodeModule(importName, ctx, depth);
  }
  if (importName.startsWith("@tsci/")) {
    return importSnippet(importName, ctx, depth);
  }
  throw new Error(
    `Unresolved import "${importName}" ${opts.cwd ? `from directory "${opts.cwd}"` : ""}`
  );
}

// lib/runner/setupDefaultEntrypointIfNeeded.ts
import Debug4 from "debug";
var debug4 = Debug4("tsci:eval:setupDefaultEntrypointIfNeeded");
var setupDefaultEntrypointIfNeeded = (opts) => {
  if (!opts.entrypoint && !opts.mainComponentPath) {
    if ("index.tsx" in opts.fsMap) {
      opts.mainComponentPath = "index.tsx";
    } else if ("index.ts" in opts.fsMap) {
      opts.mainComponentPath = "index.ts";
    } else if (Object.keys(opts.fsMap).filter((k) => k.endsWith(".tsx")).length === 1) {
      opts.mainComponentPath = Object.keys(opts.fsMap)[0];
    } else if ("tscircuit.config.json" in opts.fsMap) {
      const configContent = opts.fsMap["tscircuit.config.json"];
      try {
        const config = JSON.parse(configContent);
        if (config.mainEntrypoint) {
          opts.entrypoint = config.mainEntrypoint;
        }
      } catch (e) {
        console.warn("Failed to parse tscircuit.config.json:", e);
      }
    } else {
      throw new Error(
        "Either entrypoint or mainComponentPath must be provided (no index file, could not infer entrypoint)"
      );
    }
  }
  if (!opts.entrypoint && opts.mainComponentPath) {
    opts.entrypoint = "entrypoint.tsx";
    const mainComponentCode = opts.fsMap[resolveFilePathOrThrow(opts.mainComponentPath, opts.fsMap)];
    if (!mainComponentCode) {
      throw new Error(
        `Main component path "${opts.mainComponentPath}" not found in fsMap. Available paths: ${Object.keys(opts.fsMap).join(", ")}`
      );
    }
    const hasExplicitBoard = mainComponentCode.includes("<board");
    const hasTsciImport = mainComponentCode.includes("@tsci/") || mainComponentCode.includes('from "@tsci');
    const shouldWrapInBoard = !hasExplicitBoard && !hasTsciImport;
    opts.fsMap[opts.entrypoint] = `
     import * as UserComponents from "./${opts.mainComponentPath}";
          
      ${opts.mainComponentName ? `
        const ComponentToRender = UserComponents["${opts.mainComponentName}"]
        ` : `const ComponentToRender = Object.entries(UserComponents)
        .filter(([name]) => !name.startsWith("use"))
        .map(([_, component]) => component)[0] || (() => null);`}

           ${debug4.enabled ? `
     console.log({ UserComponents })
     console.log("ComponentToRender " + ComponentToRender.toString(),  { ComponentToRender })
     ` : ""}

      circuit.add(
        ${shouldWrapInBoard ? `
          <board>
            <ComponentToRender name="U1" ${opts.mainComponentProps ? `{...${JSON.stringify(opts.mainComponentProps, null, 2)}}` : ""} />
          </board>
        ` : `
          <ComponentToRender ${opts.mainComponentProps ? `{...${JSON.stringify(opts.mainComponentProps, null, 2)}}` : ""} />
        `}
      );
`;
  }
  if (!opts.name && opts.mainComponentName) {
    opts.name = opts.mainComponentName;
  }
};

// lib/runner/CircuitRunner.ts
import Debug5 from "debug";
var debug5 = Debug5("tsci:eval:CircuitRunner");
var CircuitRunner = class {
  constructor(configuration = {}) {
    this._executionContext = null;
    this._circuitRunnerConfiguration = {
      snippetsApiBaseUrl: "https://registry-api.tscircuit.com",
      cjsRegistryUrl: "https://cjs.tscircuit.com",
      verbose: false
    };
    this._eventListeners = {};
    Object.assign(this._circuitRunnerConfiguration, configuration);
  }
  async executeWithFsMap(ogOpts) {
    const opts = { ...ogOpts };
    if (this._circuitRunnerConfiguration.verbose) {
      Debug5.enable("tsci:eval:*");
    }
    debug5("executeWithFsMap called with:", {
      entrypoint: opts.entrypoint,
      fsMapKeys: Object.keys(opts.fsMap),
      name: opts.name
    });
    setupDefaultEntrypointIfNeeded(opts);
    debug5("entrypoint after setupDefaultEntrypointIfNeeded:", {
      entrypoint: opts.entrypoint
    });
    this._executionContext = createExecutionContext(
      this._circuitRunnerConfiguration,
      {
        name: opts.name,
        platform: this._circuitRunnerConfiguration.platform
      }
    );
    this._bindEventListeners(this._executionContext.circuit);
    this._executionContext.fsMap = normalizeFsMap(opts.fsMap);
    if (!this._executionContext.fsMap[opts.entrypoint]) {
      throw new Error(`Entrypoint "${opts.entrypoint}" not found`);
    }
    ;
    globalThis.__tscircuit_circuit = this._executionContext.circuit;
    const entrypoint = opts.entrypoint.startsWith("./") ? opts.entrypoint : `./${opts.entrypoint}`;
    debug5("final entrypoint:", entrypoint);
    await importEvalPath(entrypoint, this._executionContext);
  }
  async execute(code, opts = {}) {
    if (this._circuitRunnerConfiguration.verbose) {
      console.log(
        "[CircuitRunner] execute called with code length:",
        code.length
      );
    }
    this._executionContext = createExecutionContext(
      this._circuitRunnerConfiguration,
      {
        ...opts,
        platform: this._circuitRunnerConfiguration.platform
      }
    );
    this._bindEventListeners(this._executionContext.circuit);
    this._executionContext.fsMap["entrypoint.tsx"] = code;
    globalThis.__tscircuit_circuit = this._executionContext.circuit;
    await importEvalPath("./entrypoint.tsx", this._executionContext);
  }
  on(event, callback) {
    var _a;
    (_a = this._eventListeners)[event] ?? (_a[event] = []);
    this._eventListeners[event].push(callback);
    this._executionContext?.circuit.on(event, callback);
  }
  async renderUntilSettled() {
    if (!this._executionContext) {
      throw new Error("No circuit has been created");
    }
    await this._executionContext.circuit.renderUntilSettled();
  }
  async getCircuitJson() {
    if (!this._executionContext) {
      throw new Error("No circuit has been created");
    }
    return this._executionContext.circuit.getCircuitJson();
  }
  clearEventListeners() {
    if (this._executionContext?.circuit) {
      for (const event in this._eventListeners) {
        for (const listener of this._eventListeners[event]) {
          const circuit = this._executionContext.circuit;
          circuit.removeListener?.(event, listener);
        }
      }
    }
    for (const event in this._eventListeners) {
      delete this._eventListeners[event];
    }
  }
  async kill() {
    this._executionContext = null;
  }
  async setSnippetsApiBaseUrl(baseUrl) {
    this._circuitRunnerConfiguration.snippetsApiBaseUrl = baseUrl;
  }
  async setPlatformConfig(platform) {
    this._circuitRunnerConfiguration.platform = platform;
  }
  _bindEventListeners(circuit) {
    for (const event in this._eventListeners) {
      for (const listener of this._eventListeners[event]) {
        circuit.on(event, listener);
      }
    }
  }
};

// lib/runner/runTscircuitCode.ts
async function runTscircuitCode(filesystemOrCodeString, opts) {
  if (typeof filesystemOrCodeString === "string" && !filesystemOrCodeString.includes("export")) {
    throw new Error(
      `The "export" keyword wasn't found in your provided code. You need to export a component in your code, e.g.

export default () => (
  <resistor name="R1" resistance="1k" />
)`
    );
  }
  const filesystem = typeof filesystemOrCodeString === "string" ? { "user-code.tsx": filesystemOrCodeString } : filesystemOrCodeString;
  const circuitRunner = new CircuitRunner();
  await circuitRunner.executeWithFsMap({
    fsMap: filesystem,
    ...opts
  });
  await circuitRunner.renderUntilSettled();
  return await circuitRunner.getCircuitJson();
}

// lib/runner/runTscircuitModule.ts
var runTscircuitModule = async (module, opts = {}) => {
  if (!module.startsWith("@")) {
    module = `@tsci/${module.replace(/\//, ".")}`;
  }
  const circuitJson = await runTscircuitCode(
    {
      // TODO handle exports that are not the default export by scanning
      // otherExports for components
      "user-code.tsx": `
    import Module, * as otherExports from "${module}";

    let exportName = "${opts.exportName ?? ""}"

    if ((!Module || typeof Module !== "function") && !Boolean(exportName)) {
      exportName = Object.keys(otherExports).filter(key => key[0] === key[0].toUpperCase() && typeof otherExports[key] === "function")[0]
    }

    const defaultExport = exportName ? otherExports[exportName] : Module

    if (!defaultExport) {
      throw new Error(\`No export found for module "\${module}" (tried "\${exportName ?? "default"}")\`)
    }

    export default defaultExport;
    `
    },
    {
      mainComponentProps: opts.props
    }
  );
  return circuitJson;
};

// lib/worker.ts
import * as Comlink from "comlink";
var createCircuitWebWorker = async (configuration) => {
  const existingWorker = globalThis.TSCIRCUIT_GLOBAL_CIRCUIT_WORKER;
  if (existingWorker && typeof existingWorker.kill === "function") {
    if (configuration.verbose) {
      console.log("[Worker] Killing previous global worker instance...");
    }
    try {
      await existingWorker.kill();
    } catch (e) {
      if (configuration.verbose) {
        console.warn(
          "[Worker] Error killing previous global worker instance:",
          e
        );
      }
      if (globalThis.TSCIRCUIT_GLOBAL_CIRCUIT_WORKER === existingWorker) {
        globalThis.TSCIRCUIT_GLOBAL_CIRCUIT_WORKER = void 0;
      }
    }
  }
  if (configuration.verbose) {
    console.log(
      "[Worker] Creating circuit web worker with config:",
      configuration
    );
  }
  let workerBlobUrl = configuration.webWorkerBlobUrl ?? configuration.webWorkerUrl;
  if (!workerBlobUrl) {
    const cdnUrl = `https://cdn.jsdelivr.net/npm/@tscircuit/eval@${configuration.evalVersion ?? "latest"}/dist/webworker/entrypoint.js`;
    const workerBlob = await fetch(cdnUrl).then((res) => res.blob());
    workerBlobUrl = URL.createObjectURL(workerBlob);
  }
  const rawWorker = new Worker(workerBlobUrl, { type: "module" });
  const comlinkWorker = Comlink.wrap(rawWorker);
  if (configuration.snippetsApiBaseUrl) {
    await comlinkWorker.setSnippetsApiBaseUrl(configuration.snippetsApiBaseUrl);
  }
  if (configuration.platform) {
    await comlinkWorker.setPlatformConfig(configuration.platform);
  }
  let isTerminated = false;
  const wrapper = {
    clearEventListeners: comlinkWorker.clearEventListeners.bind(comlinkWorker),
    execute: async (...args) => {
      if (isTerminated) {
        throw new Error("CircuitWebWorker was terminated, can't execute");
      }
      return comlinkWorker.execute.bind(comlinkWorker)(...args);
    },
    executeWithFsMap: async (...args) => {
      if (isTerminated) {
        throw new Error(
          "CircuitWebWorker was terminated, can't executeWithFsMap"
        );
      }
      return comlinkWorker.executeWithFsMap.bind(comlinkWorker)(...args);
    },
    renderUntilSettled: comlinkWorker.renderUntilSettled.bind(comlinkWorker),
    getCircuitJson: comlinkWorker.getCircuitJson.bind(comlinkWorker),
    on: (event, callback) => {
      const proxiedCallback = Comlink.proxy(callback);
      comlinkWorker.on(event, proxiedCallback);
    },
    kill: async () => {
      comlinkWorker[Comlink.releaseProxy]();
      rawWorker.terminate();
      isTerminated = true;
      if (globalThis.TSCIRCUIT_GLOBAL_CIRCUIT_WORKER === wrapper) {
        globalThis.TSCIRCUIT_GLOBAL_CIRCUIT_WORKER = void 0;
      }
    }
  };
  globalThis.TSCIRCUIT_GLOBAL_CIRCUIT_WORKER = wrapper;
  return wrapper;
};

// lib/getPossibleEntrypointComponentPaths.ts
var getPossibleEntrypointComponentPaths = (fsMap) => {
  const normalizedFsMap = {};
  for (const [path, content] of Object.entries(fsMap)) {
    normalizedFsMap[normalizeFilePath(path)] = content;
  }
  const possible = /* @__PURE__ */ new Set();
  if ("tscircuit.config.json" in normalizedFsMap) {
    try {
      const config = JSON.parse(normalizedFsMap["tscircuit.config.json"]);
      if (typeof config.mainEntrypoint === "string") {
        possible.add(normalizeFilePath(config.mainEntrypoint));
      }
    } catch {
    }
  }
  if (normalizedFsMap["index.tsx"]) possible.add("index.tsx");
  if (normalizedFsMap["index.ts"]) possible.add("index.ts");
  const circuitFiles = Object.keys(normalizedFsMap).filter(
    (k) => k.endsWith(".circuit.tsx")
  );
  for (const file of circuitFiles) {
    possible.add(file);
  }
  const tsxFiles = Object.keys(normalizedFsMap).filter(
    (k) => k.endsWith(".tsx")
  );
  if (tsxFiles.length === 1) {
    possible.add(tsxFiles[0]);
  }
  return Array.from(possible);
};
export {
  CircuitRunner,
  createCircuitWebWorker,
  getImportsFromCode,
  getPossibleEntrypointComponentPaths,
  runTscircuitCode,
  runTscircuitModule
};
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsiLi4vLi4vd2Vid29ya2VyL2V4ZWN1dGlvbi1jb250ZXh0LnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AdHNjaXJjdWl0L3BhcnRzLWVuZ2luZS9saWIvamxjLXBhcnRzLWVuZ2luZS50cyIsICIuLi8uLi9saWIvZ2V0UGxhdGZvcm1Db25maWcudHMiLCAiLi4vLi4vbGliL3J1bm5lci9ub3JtYWxpemVGc01hcC50cyIsICIuLi8uLi9saWIvcnVubmVyL0NpcmN1aXRSdW5uZXIudHMiLCAiLi4vLi4vbGliL3V0aWxzL2Rpcm5hbWUudHMiLCAiLi4vLi4vbGliL3J1bm5lci9yZXNvbHZlRmlsZVBhdGgudHMiLCAiLi4vLi4vd2Vid29ya2VyL2V2YWwtY29tcGlsZWQtanMudHMiLCAiLi4vLi4vd2Vid29ya2VyL2ltcG9ydC1ldmFsLXBhdGgudHMiLCAiLi4vLi4vd2Vid29ya2VyL2ltcG9ydC1sb2NhbC1maWxlLnRzIiwgIi4uLy4uL2xpYi91dGlscy9nZXQtaW1wb3J0cy1mcm9tLWNvZGUudHMiLCAiLi4vLi4vd2Vid29ya2VyL2ltcG9ydC1zbmlwcGV0LnRzIiwgIi4uLy4uL2xpYi91dGlscy9yZXNvbHZlLW5vZGUtbW9kdWxlLnRzIiwgIi4uLy4uL3dlYndvcmtlci9pbXBvcnQtbm9kZS1tb2R1bGUudHMiLCAiLi4vLi4vbGliL3J1bm5lci9zZXR1cERlZmF1bHRFbnRyeXBvaW50SWZOZWVkZWQudHMiLCAiLi4vLi4vbGliL3J1bm5lci9ydW5Uc2NpcmN1aXRDb2RlLnRzIiwgIi4uLy4uL2xpYi9ydW5uZXIvcnVuVHNjaXJjdWl0TW9kdWxlLnRzIiwgIi4uLy4uL2xpYi93b3JrZXIudHMiLCAiLi4vLi4vbGliL2dldFBvc3NpYmxlRW50cnlwb2ludENvbXBvbmVudFBhdGhzLnRzIl0sCiAgInNvdXJjZXNDb250ZW50IjogWyJpbXBvcnQgeyBSb290Q2lyY3VpdCB9IGZyb20gXCJAdHNjaXJjdWl0L2NvcmVcIlxuaW1wb3J0IHR5cGUgeyBXZWJXb3JrZXJDb25maWd1cmF0aW9uIH0gZnJvbSBcImxpYi9zaGFyZWQvdHlwZXNcIlxuaW1wb3J0ICogYXMgdHNjaXJjdWl0Q29yZSBmcm9tIFwiQHRzY2lyY3VpdC9jb3JlXCJcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gXCJyZWFjdFwiXG5pbXBvcnQgKiBhcyBqc2NhZEZpYmVyIGZyb20gXCJqc2NhZC1maWJlclwiXG5pbXBvcnQgKiBhcyB0c2NpcmN1aXRNYXRoVXRpbHMgZnJvbSBcIkB0c2NpcmN1aXQvbWF0aC11dGlsc1wiXG5pbXBvcnQgdHlwZSB7IFBsYXRmb3JtQ29uZmlnIH0gZnJvbSBcIkB0c2NpcmN1aXQvcHJvcHNcIlxuaW1wb3J0IHsgZ2V0UGxhdGZvcm1Db25maWcgfSBmcm9tIFwibGliL2dldFBsYXRmb3JtQ29uZmlnXCJcbmltcG9ydCBEZWJ1ZyBmcm9tIFwiZGVidWdcIlxuXG5jb25zdCBkZWJ1ZyA9IERlYnVnKFwidHNjaTpldmFsOmV4ZWN1dGlvbi1jb250ZXh0XCIpXG5cbmV4cG9ydCBpbnRlcmZhY2UgRXhlY3V0aW9uQ29udGV4dCBleHRlbmRzIFdlYldvcmtlckNvbmZpZ3VyYXRpb24ge1xuICBmc01hcDogUmVjb3JkPHN0cmluZywgc3RyaW5nPlxuICBlbnRyeXBvaW50OiBzdHJpbmdcbiAgcHJlU3VwcGxpZWRJbXBvcnRzOiBSZWNvcmQ8c3RyaW5nLCBhbnk+XG4gIGNpcmN1aXQ6IFJvb3RDaXJjdWl0XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVFeGVjdXRpb25Db250ZXh0KFxuICB3ZWJXb3JrZXJDb25maWd1cmF0aW9uOiBXZWJXb3JrZXJDb25maWd1cmF0aW9uLFxuICBvcHRzOiB7XG4gICAgbmFtZT86IHN0cmluZ1xuICAgIHBsYXRmb3JtPzogUGxhdGZvcm1Db25maWdcbiAgfSA9IHt9LFxuKTogRXhlY3V0aW9uQ29udGV4dCB7XG4gIGdsb2JhbFRoaXMuUmVhY3QgPSBSZWFjdFxuXG4gIGNvbnN0IGNpcmN1aXQgPSBuZXcgUm9vdENpcmN1aXQoe1xuICAgIHBsYXRmb3JtOiBvcHRzLnBsYXRmb3JtIHx8IGdldFBsYXRmb3JtQ29uZmlnKCksXG4gIH0pXG5cbiAgaWYgKG9wdHMubmFtZSkge1xuICAgIGNpcmN1aXQubmFtZSA9IG9wdHMubmFtZVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBmc01hcDoge30sXG4gICAgZW50cnlwb2ludDogXCJcIixcbiAgICBwcmVTdXBwbGllZEltcG9ydHM6IHtcbiAgICAgIFwiQHRzY2lyY3VpdC9jb3JlXCI6IHRzY2lyY3VpdENvcmUsXG4gICAgICB0c2NpcmN1aXQ6IHRzY2lyY3VpdENvcmUsXG4gICAgICBcIkB0c2NpcmN1aXQvbWF0aC11dGlsc1wiOiB0c2NpcmN1aXRNYXRoVXRpbHMsXG4gICAgICByZWFjdDogUmVhY3QsXG4gICAgICBcImpzY2FkLWZpYmVyXCI6IGpzY2FkRmliZXIsXG5cbiAgICAgIC8vIFRoaXMgaXMgdXN1YWxseSB1c2VkIGFzIGEgdHlwZSBpbXBvcnQsIHdlIGNhbiByZW1vdmUgdGhlIHNoaW0gd2hlbiB3ZVxuICAgICAgLy8gaWdub3JlIHR5cGUgaW1wb3J0cyBpbiBnZXRJbXBvcnRzRnJvbUNvZGVcbiAgICAgIFwiQHRzY2lyY3VpdC9wcm9wc1wiOiB7fSxcbiAgICB9LFxuICAgIGNpcmN1aXQsXG4gICAgLi4ud2ViV29ya2VyQ29uZmlndXJhdGlvbixcbiAgfVxufVxuIiwgImltcG9ydCB0eXBlIHsgUGFydHNFbmdpbmUsIFN1cHBsaWVyUGFydE51bWJlcnMgfSBmcm9tIFwiQHRzY2lyY3VpdC9wcm9wc1wiXG5cbmNvbnN0IGNhY2hlID0gbmV3IE1hcDxzdHJpbmcsIGFueT4oKVxuXG5jb25zdCBnZXRKbGNQYXJ0c0NhY2hlZCA9IGFzeW5jIChuYW1lOiBhbnksIHBhcmFtczogYW55KSA9PiB7XG4gIGNvbnN0IHBhcmFtU3RyaW5nID0gbmV3IFVSTFNlYXJjaFBhcmFtcyh7XG4gICAgLi4ucGFyYW1zLFxuICAgIGpzb246IFwidHJ1ZVwiLFxuICB9KS50b1N0cmluZygpXG4gIGlmIChjYWNoZS5oYXMocGFyYW1TdHJpbmcpKSB7XG4gICAgcmV0dXJuIGNhY2hlLmdldChwYXJhbVN0cmluZylcbiAgfVxuICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKFxuICAgIGBodHRwczovL2psY3NlYXJjaC50c2NpcmN1aXQuY29tLyR7bmFtZX0vbGlzdD8ke3BhcmFtU3RyaW5nfWAsXG4gIClcbiAgY29uc3QgcmVzcG9uc2VKc29uID0gYXdhaXQgcmVzcG9uc2UuanNvbigpXG4gIGNhY2hlLnNldChwYXJhbVN0cmluZywgcmVzcG9uc2VKc29uKVxuICByZXR1cm4gcmVzcG9uc2VKc29uXG59XG5cbmV4cG9ydCBjb25zdCBqbGNQYXJ0c0VuZ2luZTogUGFydHNFbmdpbmUgPSB7XG4gIGZpbmRQYXJ0OiBhc3luYyAoe1xuICAgIHNvdXJjZUNvbXBvbmVudCxcbiAgICBmb290cHJpbnRlclN0cmluZyxcbiAgfSk6IFByb21pc2U8U3VwcGxpZXJQYXJ0TnVtYmVycz4gPT4ge1xuICAgIGlmIChcbiAgICAgIHNvdXJjZUNvbXBvbmVudC50eXBlID09PSBcInNvdXJjZV9jb21wb25lbnRcIiAmJlxuICAgICAgc291cmNlQ29tcG9uZW50LmZ0eXBlID09PSBcInNpbXBsZV9yZXNpc3RvclwiXG4gICAgKSB7XG4gICAgICBjb25zdCB7IHJlc2lzdG9ycyB9ID0gYXdhaXQgZ2V0SmxjUGFydHNDYWNoZWQoXCJyZXNpc3RvcnNcIiwge1xuICAgICAgICByZXNpc3RhbmNlOlxuICAgICAgICAgIHNvdXJjZUNvbXBvbmVudC5kaXNwbGF5X3Jlc2lzdGFuY2UgPz8gc291cmNlQ29tcG9uZW50LnJlc2lzdGFuY2UsXG4gICAgICAgIHBhY2thZ2U6IGZvb3RwcmludGVyU3RyaW5nLFxuICAgICAgfSlcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgamxjcGNiOiAocmVzaXN0b3JzID8/IFtdKS5tYXAoKHI6IGFueSkgPT4gYEMke3IubGNzY31gKS5zbGljZSgwLCAzKSxcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKFxuICAgICAgc291cmNlQ29tcG9uZW50LnR5cGUgPT09IFwic291cmNlX2NvbXBvbmVudFwiICYmXG4gICAgICBzb3VyY2VDb21wb25lbnQuZnR5cGUgPT09IFwic2ltcGxlX2NhcGFjaXRvclwiXG4gICAgKSB7XG4gICAgICBpZiAoZm9vdHByaW50ZXJTdHJpbmc/LmluY2x1ZGVzKFwiY2FwXCIpKSB7XG4gICAgICAgIGZvb3RwcmludGVyU3RyaW5nID0gZm9vdHByaW50ZXJTdHJpbmcucmVwbGFjZShcImNhcFwiLCBcIlwiKVxuICAgICAgfVxuICAgICAgY29uc3QgeyBjYXBhY2l0b3JzIH0gPSBhd2FpdCBnZXRKbGNQYXJ0c0NhY2hlZChcImNhcGFjaXRvcnNcIiwge1xuICAgICAgICBjYXBhY2l0YW5jZTpcbiAgICAgICAgICBzb3VyY2VDb21wb25lbnQuZGlzcGxheV9jYXBhY2l0YW5jZSA/PyBzb3VyY2VDb21wb25lbnQuY2FwYWNpdGFuY2UsXG4gICAgICAgIHBhY2thZ2U6IGZvb3RwcmludGVyU3RyaW5nLFxuICAgICAgfSlcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgamxjcGNiOiAoY2FwYWNpdG9ycyA/PyBbXSkubWFwKChjOiBhbnkpID0+IGBDJHtjLmxjc2N9YCkuc2xpY2UoMCwgMyksXG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChcbiAgICAgIHNvdXJjZUNvbXBvbmVudC50eXBlID09PSBcInNvdXJjZV9jb21wb25lbnRcIiAmJlxuICAgICAgc291cmNlQ29tcG9uZW50LmZ0eXBlID09PSBcInNpbXBsZV9waW5faGVhZGVyXCJcbiAgICApIHtcbiAgICAgIGxldCBwaXRjaDogbnVtYmVyIHwgdW5kZWZpbmVkXG4gICAgICBpZiAoZm9vdHByaW50ZXJTdHJpbmc/LmluY2x1ZGVzKFwiX3BcIikpIHtcbiAgICAgICAgcGl0Y2ggPSBOdW1iZXIoZm9vdHByaW50ZXJTdHJpbmcuc3BsaXQoXCJfcFwiKVsxXSlcbiAgICAgIH1cbiAgICAgIGNvbnN0IHsgaGVhZGVycyB9ID0gYXdhaXQgZ2V0SmxjUGFydHNDYWNoZWQoXG4gICAgICAgIFwiaGVhZGVyc1wiLFxuICAgICAgICBwaXRjaFxuICAgICAgICAgID8ge1xuICAgICAgICAgICAgICBwaXRjaDogcGl0Y2gsXG4gICAgICAgICAgICAgIG51bV9waW5zOiBzb3VyY2VDb21wb25lbnQucGluX2NvdW50LFxuICAgICAgICAgICAgICBnZW5kZXI6IHNvdXJjZUNvbXBvbmVudC5nZW5kZXIsXG4gICAgICAgICAgICB9XG4gICAgICAgICAgOiB7XG4gICAgICAgICAgICAgIG51bV9waW5zOiBzb3VyY2VDb21wb25lbnQucGluX2NvdW50LFxuICAgICAgICAgICAgICBnZW5kZXI6IHNvdXJjZUNvbXBvbmVudC5nZW5kZXIsXG4gICAgICAgICAgICB9LFxuICAgICAgKVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgamxjcGNiOiAoaGVhZGVycyA/PyBbXSkubWFwKChoOiBhbnkpID0+IGBDJHtoLmxjc2N9YCkuc2xpY2UoMCwgMyksXG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChcbiAgICAgIHNvdXJjZUNvbXBvbmVudC50eXBlID09PSBcInNvdXJjZV9jb21wb25lbnRcIiAmJlxuICAgICAgc291cmNlQ29tcG9uZW50LmZ0eXBlID09PSBcInNpbXBsZV9wb3RlbnRpb21ldGVyXCJcbiAgICApIHtcbiAgICAgIGNvbnN0IHsgcG90ZW50aW9tZXRlcnMgfSA9IGF3YWl0IGdldEpsY1BhcnRzQ2FjaGVkKFwicG90ZW50aW9tZXRlcnNcIiwge1xuICAgICAgICByZXNpc3RhbmNlOiBzb3VyY2VDb21wb25lbnQubWF4X3Jlc2lzdGFuY2UsXG4gICAgICAgIHBhY2thZ2U6IGZvb3RwcmludGVyU3RyaW5nLFxuICAgICAgfSlcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGpsY3BjYjogKHBvdGVudGlvbWV0ZXJzID8/IFtdKVxuICAgICAgICAgIC5tYXAoKHA6IGFueSkgPT4gYEMke3AubGNzY31gKVxuICAgICAgICAgIC5zbGljZSgwLCAzKSxcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKFxuICAgICAgc291cmNlQ29tcG9uZW50LnR5cGUgPT09IFwic291cmNlX2NvbXBvbmVudFwiICYmXG4gICAgICBzb3VyY2VDb21wb25lbnQuZnR5cGUgPT09IFwic2ltcGxlX2Rpb2RlXCJcbiAgICApIHtcbiAgICAgIGNvbnN0IHsgZGlvZGVzIH0gPSBhd2FpdCBnZXRKbGNQYXJ0c0NhY2hlZChcImRpb2Rlc1wiLCB7XG4gICAgICAgIHBhY2thZ2U6IGZvb3RwcmludGVyU3RyaW5nLFxuICAgICAgfSlcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGpsY3BjYjogKGRpb2RlcyA/PyBbXSkubWFwKChkOiBhbnkpID0+IGBDJHtkLmxjc2N9YCkuc2xpY2UoMCwgMyksXG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChcbiAgICAgIHNvdXJjZUNvbXBvbmVudC50eXBlID09PSBcInNvdXJjZV9jb21wb25lbnRcIiAmJlxuICAgICAgc291cmNlQ29tcG9uZW50LmZ0eXBlID09PSBcInNpbXBsZV9jaGlwXCJcbiAgICApIHtcbiAgICAgIGNvbnN0IHsgY2hpcHMgfSA9IGF3YWl0IGdldEpsY1BhcnRzQ2FjaGVkKFwiY2hpcHNcIiwge1xuICAgICAgICBwYWNrYWdlOiBmb290cHJpbnRlclN0cmluZyxcbiAgICAgIH0pXG4gICAgICByZXR1cm4ge1xuICAgICAgICBqbGNwY2I6IChjaGlwcyA/PyBbXSkubWFwKChjOiBhbnkpID0+IGBDJHtjLmxjc2N9YCkuc2xpY2UoMCwgMyksXG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChcbiAgICAgIHNvdXJjZUNvbXBvbmVudC50eXBlID09PSBcInNvdXJjZV9jb21wb25lbnRcIiAmJlxuICAgICAgc291cmNlQ29tcG9uZW50LmZ0eXBlID09PSBcInNpbXBsZV90cmFuc2lzdG9yXCJcbiAgICApIHtcbiAgICAgIGNvbnN0IHsgdHJhbnNpc3RvcnMgfSA9IGF3YWl0IGdldEpsY1BhcnRzQ2FjaGVkKFwidHJhbnNpc3RvcnNcIiwge1xuICAgICAgICBwYWNrYWdlOiBmb290cHJpbnRlclN0cmluZyxcbiAgICAgICAgdHJhbnNpc3Rvcl90eXBlOiBzb3VyY2VDb21wb25lbnQudHJhbnNpc3Rvcl90eXBlLFxuICAgICAgfSlcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGpsY3BjYjogKHRyYW5zaXN0b3JzID8/IFtdKS5tYXAoKHQ6IGFueSkgPT4gYEMke3QubGNzY31gKS5zbGljZSgwLCAzKSxcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKFxuICAgICAgc291cmNlQ29tcG9uZW50LnR5cGUgPT09IFwic291cmNlX2NvbXBvbmVudFwiICYmXG4gICAgICBzb3VyY2VDb21wb25lbnQuZnR5cGUgPT09IFwic2ltcGxlX3Bvd2VyX3NvdXJjZVwiXG4gICAgKSB7XG4gICAgICBjb25zdCB7IHBvd2VyX3NvdXJjZXMgfSA9IGF3YWl0IGdldEpsY1BhcnRzQ2FjaGVkKFwicG93ZXJfc291cmNlc1wiLCB7XG4gICAgICAgIHZvbHRhZ2U6IHNvdXJjZUNvbXBvbmVudC52b2x0YWdlLFxuICAgICAgICBwYWNrYWdlOiBmb290cHJpbnRlclN0cmluZyxcbiAgICAgIH0pXG4gICAgICByZXR1cm4ge1xuICAgICAgICBqbGNwY2I6IChwb3dlcl9zb3VyY2VzID8/IFtdKS5tYXAoKHA6IGFueSkgPT4gYEMke3AubGNzY31gKS5zbGljZSgwLCAzKSxcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKFxuICAgICAgc291cmNlQ29tcG9uZW50LnR5cGUgPT09IFwic291cmNlX2NvbXBvbmVudFwiICYmXG4gICAgICBzb3VyY2VDb21wb25lbnQuZnR5cGUgPT09IFwic2ltcGxlX2luZHVjdG9yXCJcbiAgICApIHtcbiAgICAgIGNvbnN0IHsgaW5kdWN0b3JzIH0gPSBhd2FpdCBnZXRKbGNQYXJ0c0NhY2hlZChcImluZHVjdG9yc1wiLCB7XG4gICAgICAgIGluZHVjdGFuY2U6IHNvdXJjZUNvbXBvbmVudC5pbmR1Y3RhbmNlLFxuICAgICAgICBwYWNrYWdlOiBmb290cHJpbnRlclN0cmluZyxcbiAgICAgIH0pXG4gICAgICByZXR1cm4ge1xuICAgICAgICBqbGNwY2I6IChpbmR1Y3RvcnMgPz8gW10pLm1hcCgoaTogYW55KSA9PiBgQyR7aS5sY3NjfWApLnNsaWNlKDAsIDMpLFxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoXG4gICAgICBzb3VyY2VDb21wb25lbnQudHlwZSA9PT0gXCJzb3VyY2VfY29tcG9uZW50XCIgJiZcbiAgICAgIHNvdXJjZUNvbXBvbmVudC5mdHlwZSA9PT0gXCJzaW1wbGVfY3J5c3RhbFwiXG4gICAgKSB7XG4gICAgICBjb25zdCB7IGNyeXN0YWxzIH0gPSBhd2FpdCBnZXRKbGNQYXJ0c0NhY2hlZChcImNyeXN0YWxzXCIsIHtcbiAgICAgICAgZnJlcXVlbmN5OiBzb3VyY2VDb21wb25lbnQuZnJlcXVlbmN5LFxuICAgICAgICBsb2FkX2NhcGFjaXRhbmNlOiBzb3VyY2VDb21wb25lbnQubG9hZF9jYXBhY2l0YW5jZSxcbiAgICAgICAgcGFja2FnZTogZm9vdHByaW50ZXJTdHJpbmcsXG4gICAgICB9KVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgamxjcGNiOiAoY3J5c3RhbHMgPz8gW10pLm1hcCgoYzogYW55KSA9PiBgQyR7Yy5sY3NjfWApLnNsaWNlKDAsIDMpLFxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoXG4gICAgICBzb3VyY2VDb21wb25lbnQudHlwZSA9PT0gXCJzb3VyY2VfY29tcG9uZW50XCIgJiZcbiAgICAgIHNvdXJjZUNvbXBvbmVudC5mdHlwZSA9PT0gXCJzaW1wbGVfbW9zZmV0XCJcbiAgICApIHtcbiAgICAgIGNvbnN0IHsgbW9zZmV0cyB9ID0gYXdhaXQgZ2V0SmxjUGFydHNDYWNoZWQoXCJtb3NmZXRzXCIsIHtcbiAgICAgICAgcGFja2FnZTogZm9vdHByaW50ZXJTdHJpbmcsXG4gICAgICAgIG1vc2ZldF9tb2RlOiBzb3VyY2VDb21wb25lbnQubW9zZmV0X21vZGUsXG4gICAgICAgIGNoYW5uZWxfdHlwZTogc291cmNlQ29tcG9uZW50LmNoYW5uZWxfdHlwZSxcbiAgICAgIH0pXG4gICAgICByZXR1cm4ge1xuICAgICAgICBqbGNwY2I6IChtb3NmZXRzID8/IFtdKS5tYXAoKG06IGFueSkgPT4gYEMke20ubGNzY31gKS5zbGljZSgwLCAzKSxcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKFxuICAgICAgc291cmNlQ29tcG9uZW50LnR5cGUgPT09IFwic291cmNlX2NvbXBvbmVudFwiICYmXG4gICAgICBzb3VyY2VDb21wb25lbnQuZnR5cGUgPT09IFwic2ltcGxlX3Jlc29uYXRvclwiXG4gICAgKSB7XG4gICAgICBjb25zdCB7IHJlc29uYXRvcnMgfSA9IGF3YWl0IGdldEpsY1BhcnRzQ2FjaGVkKFwicmVzb25hdG9yc1wiLCB7XG4gICAgICAgIGZyZXF1ZW5jeTogc291cmNlQ29tcG9uZW50LmZyZXF1ZW5jeSxcbiAgICAgICAgcGFja2FnZTogZm9vdHByaW50ZXJTdHJpbmcsXG4gICAgICB9KVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgamxjcGNiOiAocmVzb25hdG9ycyA/PyBbXSkubWFwKChyOiBhbnkpID0+IGBDJHtyLmxjc2N9YCkuc2xpY2UoMCwgMyksXG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChcbiAgICAgIHNvdXJjZUNvbXBvbmVudC50eXBlID09PSBcInNvdXJjZV9jb21wb25lbnRcIiAmJlxuICAgICAgc291cmNlQ29tcG9uZW50LmZ0eXBlID09PSBcInNpbXBsZV9zd2l0Y2hcIlxuICAgICkge1xuICAgICAgY29uc3QgeyBzd2l0Y2hlcyB9ID0gYXdhaXQgZ2V0SmxjUGFydHNDYWNoZWQoXCJzd2l0Y2hlc1wiLCB7XG4gICAgICAgIHN3aXRjaF90eXBlOiBzb3VyY2VDb21wb25lbnQudHlwZSxcbiAgICAgICAgcGFja2FnZTogZm9vdHByaW50ZXJTdHJpbmcsXG4gICAgICB9KVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgamxjcGNiOiAoc3dpdGNoZXMgPz8gW10pLm1hcCgoczogYW55KSA9PiBgQyR7cy5sY3NjfWApLnNsaWNlKDAsIDMpLFxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoXG4gICAgICBzb3VyY2VDb21wb25lbnQudHlwZSA9PT0gXCJzb3VyY2VfY29tcG9uZW50XCIgJiZcbiAgICAgIHNvdXJjZUNvbXBvbmVudC5mdHlwZSA9PT0gXCJzaW1wbGVfbGVkXCJcbiAgICApIHtcbiAgICAgIGNvbnN0IHsgbGVkcyB9ID0gYXdhaXQgZ2V0SmxjUGFydHNDYWNoZWQoXCJsZWRzXCIsIHtcbiAgICAgICAgcGFja2FnZTogZm9vdHByaW50ZXJTdHJpbmcsXG4gICAgICB9KVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgamxjcGNiOiAobGVkcyA/PyBbXSkubWFwKChsOiBhbnkpID0+IGBDJHtsLmxjc2N9YCkuc2xpY2UoMCwgMyksXG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChcbiAgICAgIHNvdXJjZUNvbXBvbmVudC50eXBlID09PSBcInNvdXJjZV9jb21wb25lbnRcIiAmJlxuICAgICAgc291cmNlQ29tcG9uZW50LmZ0eXBlID09PSBcInNpbXBsZV9mdXNlXCJcbiAgICApIHtcbiAgICAgIGNvbnN0IHsgZnVzZXMgfSA9IGF3YWl0IGdldEpsY1BhcnRzQ2FjaGVkKFwiZnVzZXNcIiwge1xuICAgICAgICBwYWNrYWdlOiBmb290cHJpbnRlclN0cmluZyxcbiAgICAgIH0pXG4gICAgICByZXR1cm4ge1xuICAgICAgICBqbGNwY2I6IChmdXNlcyA/PyBbXSkubWFwKChsOiBhbnkpID0+IGBDJHtsLmxjc2N9YCkuc2xpY2UoMCwgMyksXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7fVxuICB9LFxufVxuIiwgImltcG9ydCB0eXBlIHsgUGxhdGZvcm1Db25maWcgfSBmcm9tIFwiQHRzY2lyY3VpdC9wcm9wc1wiXG5pbXBvcnQgeyBqbGNQYXJ0c0VuZ2luZSB9IGZyb20gXCJAdHNjaXJjdWl0L3BhcnRzLWVuZ2luZVwiXG5cbmV4cG9ydCBjb25zdCBnZXRQbGF0Zm9ybUNvbmZpZyA9ICgpOiBQbGF0Zm9ybUNvbmZpZyA9PiAoe1xuICBwYXJ0c0VuZ2luZTogamxjUGFydHNFbmdpbmUsXG59KVxuIiwgImV4cG9ydCBmdW5jdGlvbiBub3JtYWxpemVGaWxlUGF0aChmaWxlUGF0aDogc3RyaW5nKSB7XG4gIGxldCBub3JtRmlsZVBhdGggPSBmaWxlUGF0aFxuICBub3JtRmlsZVBhdGggPSBub3JtRmlsZVBhdGgucmVwbGFjZSgvXFxcXC9nLCBcIi9cIilcbiAgbm9ybUZpbGVQYXRoID0gbm9ybUZpbGVQYXRoLnRyaW0oKVxuICBpZiAobm9ybUZpbGVQYXRoLnN0YXJ0c1dpdGgoXCIuL1wiKSkge1xuICAgIG5vcm1GaWxlUGF0aCA9IG5vcm1GaWxlUGF0aC5zbGljZSgyKVxuICB9XG4gIGlmIChub3JtRmlsZVBhdGguc3RhcnRzV2l0aChcIi9cIikpIHtcbiAgICBub3JtRmlsZVBhdGggPSBub3JtRmlsZVBhdGguc2xpY2UoMSlcbiAgfVxuICByZXR1cm4gbm9ybUZpbGVQYXRoXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBub3JtYWxpemVGc01hcChmc01hcDogUmVjb3JkPHN0cmluZywgc3RyaW5nPikge1xuICBjb25zdCBub3JtYWxpemVkRnNNYXA6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4gPSB7fVxuICBmb3IgKGNvbnN0IFtmc1BhdGgsIGZpbGVDb250ZW50XSBvZiBPYmplY3QuZW50cmllcyhmc01hcCkpIHtcbiAgICBub3JtYWxpemVkRnNNYXBbbm9ybWFsaXplRmlsZVBhdGgoZnNQYXRoKV0gPSBmaWxlQ29udGVudFxuICB9XG4gIHJldHVybiBub3JtYWxpemVkRnNNYXBcbn1cbiIsICJpbXBvcnQgdHlwZSB7IEFueUNpcmN1aXRFbGVtZW50IH0gZnJvbSBcImNpcmN1aXQtanNvblwiXG5pbXBvcnQgdHlwZSB7XG4gIENpcmN1aXRSdW5uZXJBcGksXG4gIENpcmN1aXRSdW5uZXJDb25maWd1cmF0aW9uLFxufSBmcm9tIFwibGliL3NoYXJlZC90eXBlc1wiXG5pbXBvcnQgdHlwZSB7IFBsYXRmb3JtQ29uZmlnIH0gZnJvbSBcIkB0c2NpcmN1aXQvcHJvcHNcIlxuaW1wb3J0IHsgY3JlYXRlRXhlY3V0aW9uQ29udGV4dCB9IGZyb20gXCIuLi8uLi93ZWJ3b3JrZXIvZXhlY3V0aW9uLWNvbnRleHRcIlxuaW1wb3J0IHsgbm9ybWFsaXplRnNNYXAgfSBmcm9tIFwiLi9ub3JtYWxpemVGc01hcFwiXG5pbXBvcnQgdHlwZSB7IFJvb3RDaXJjdWl0IH0gZnJvbSBcIkB0c2NpcmN1aXQvY29yZVwiXG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tIFwicmVhY3RcIlxuaW1wb3J0IHsgaW1wb3J0RXZhbFBhdGggfSBmcm9tIFwid2Vid29ya2VyL2ltcG9ydC1ldmFsLXBhdGhcIlxuaW1wb3J0IHsgc2V0dXBEZWZhdWx0RW50cnlwb2ludElmTmVlZGVkIH0gZnJvbSBcIi4vc2V0dXBEZWZhdWx0RW50cnlwb2ludElmTmVlZGVkXCJcbmltcG9ydCBEZWJ1ZyBmcm9tIFwiZGVidWdcIlxuXG5jb25zdCBkZWJ1ZyA9IERlYnVnKFwidHNjaTpldmFsOkNpcmN1aXRSdW5uZXJcIilcblxuZXhwb3J0IGNsYXNzIENpcmN1aXRSdW5uZXIgaW1wbGVtZW50cyBDaXJjdWl0UnVubmVyQXBpIHtcbiAgX2V4ZWN1dGlvbkNvbnRleHQ6IFJldHVyblR5cGU8dHlwZW9mIGNyZWF0ZUV4ZWN1dGlvbkNvbnRleHQ+IHwgbnVsbCA9IG51bGxcbiAgX2NpcmN1aXRSdW5uZXJDb25maWd1cmF0aW9uOiBDaXJjdWl0UnVubmVyQ29uZmlndXJhdGlvbiA9IHtcbiAgICBzbmlwcGV0c0FwaUJhc2VVcmw6IFwiaHR0cHM6Ly9yZWdpc3RyeS1hcGkudHNjaXJjdWl0LmNvbVwiLFxuICAgIGNqc1JlZ2lzdHJ5VXJsOiBcImh0dHBzOi8vY2pzLnRzY2lyY3VpdC5jb21cIixcbiAgICB2ZXJib3NlOiBmYWxzZSxcbiAgfVxuICBfZXZlbnRMaXN0ZW5lcnM6IFJlY29yZDxzdHJpbmcsICgoLi4uYXJnczogYW55W10pID0+IHZvaWQpW10+ID0ge31cblxuICBjb25zdHJ1Y3Rvcihjb25maWd1cmF0aW9uOiBQYXJ0aWFsPENpcmN1aXRSdW5uZXJDb25maWd1cmF0aW9uPiA9IHt9KSB7XG4gICAgT2JqZWN0LmFzc2lnbih0aGlzLl9jaXJjdWl0UnVubmVyQ29uZmlndXJhdGlvbiwgY29uZmlndXJhdGlvbilcbiAgfVxuXG4gIGFzeW5jIGV4ZWN1dGVXaXRoRnNNYXAob2dPcHRzOiB7XG4gICAgZW50cnlwb2ludD86IHN0cmluZ1xuICAgIG1haW5Db21wb25lbnRQYXRoPzogc3RyaW5nXG4gICAgbWFpbkNvbXBvbmVudE5hbWU/OiBzdHJpbmdcbiAgICBmc01hcDogUmVjb3JkPHN0cmluZywgc3RyaW5nPlxuICAgIG5hbWU/OiBzdHJpbmdcbiAgICBtYWluQ29tcG9uZW50UHJvcHM/OiBSZWNvcmQ8c3RyaW5nLCBhbnk+XG4gIH0pOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBjb25zdCBvcHRzID0geyAuLi5vZ09wdHMgfVxuXG4gICAgaWYgKHRoaXMuX2NpcmN1aXRSdW5uZXJDb25maWd1cmF0aW9uLnZlcmJvc2UpIHtcbiAgICAgIERlYnVnLmVuYWJsZShcInRzY2k6ZXZhbDoqXCIpXG4gICAgfVxuXG4gICAgZGVidWcoXCJleGVjdXRlV2l0aEZzTWFwIGNhbGxlZCB3aXRoOlwiLCB7XG4gICAgICBlbnRyeXBvaW50OiBvcHRzLmVudHJ5cG9pbnQsXG4gICAgICBmc01hcEtleXM6IE9iamVjdC5rZXlzKG9wdHMuZnNNYXApLFxuICAgICAgbmFtZTogb3B0cy5uYW1lLFxuICAgIH0pXG5cbiAgICBzZXR1cERlZmF1bHRFbnRyeXBvaW50SWZOZWVkZWQob3B0cylcblxuICAgIGRlYnVnKFwiZW50cnlwb2ludCBhZnRlciBzZXR1cERlZmF1bHRFbnRyeXBvaW50SWZOZWVkZWQ6XCIsIHtcbiAgICAgIGVudHJ5cG9pbnQ6IG9wdHMuZW50cnlwb2ludCxcbiAgICB9KVxuXG4gICAgdGhpcy5fZXhlY3V0aW9uQ29udGV4dCA9IGNyZWF0ZUV4ZWN1dGlvbkNvbnRleHQoXG4gICAgICB0aGlzLl9jaXJjdWl0UnVubmVyQ29uZmlndXJhdGlvbixcbiAgICAgIHtcbiAgICAgICAgbmFtZTogb3B0cy5uYW1lLFxuICAgICAgICBwbGF0Zm9ybTogdGhpcy5fY2lyY3VpdFJ1bm5lckNvbmZpZ3VyYXRpb24ucGxhdGZvcm0sXG4gICAgICB9LFxuICAgIClcbiAgICB0aGlzLl9iaW5kRXZlbnRMaXN0ZW5lcnModGhpcy5fZXhlY3V0aW9uQ29udGV4dC5jaXJjdWl0KVxuXG4gICAgdGhpcy5fZXhlY3V0aW9uQ29udGV4dC5mc01hcCA9IG5vcm1hbGl6ZUZzTWFwKG9wdHMuZnNNYXApXG4gICAgaWYgKCF0aGlzLl9leGVjdXRpb25Db250ZXh0LmZzTWFwW29wdHMuZW50cnlwb2ludCFdKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEVudHJ5cG9pbnQgXCIke29wdHMuZW50cnlwb2ludH1cIiBub3QgZm91bmRgKVxuICAgIH1cbiAgICA7KGdsb2JhbFRoaXMgYXMgYW55KS5fX3RzY2lyY3VpdF9jaXJjdWl0ID0gdGhpcy5fZXhlY3V0aW9uQ29udGV4dC5jaXJjdWl0XG5cbiAgICBjb25zdCBlbnRyeXBvaW50ID0gb3B0cy5lbnRyeXBvaW50IS5zdGFydHNXaXRoKFwiLi9cIilcbiAgICAgID8gb3B0cy5lbnRyeXBvaW50XG4gICAgICA6IGAuLyR7b3B0cy5lbnRyeXBvaW50fWBcblxuICAgIGRlYnVnKFwiZmluYWwgZW50cnlwb2ludDpcIiwgZW50cnlwb2ludClcbiAgICBhd2FpdCBpbXBvcnRFdmFsUGF0aChlbnRyeXBvaW50ISwgdGhpcy5fZXhlY3V0aW9uQ29udGV4dClcbiAgfVxuXG4gIGFzeW5jIGV4ZWN1dGUoY29kZTogc3RyaW5nLCBvcHRzOiB7IG5hbWU/OiBzdHJpbmcgfSA9IHt9KSB7XG4gICAgaWYgKHRoaXMuX2NpcmN1aXRSdW5uZXJDb25maWd1cmF0aW9uLnZlcmJvc2UpIHtcbiAgICAgIGNvbnNvbGUubG9nKFxuICAgICAgICBcIltDaXJjdWl0UnVubmVyXSBleGVjdXRlIGNhbGxlZCB3aXRoIGNvZGUgbGVuZ3RoOlwiLFxuICAgICAgICBjb2RlLmxlbmd0aCxcbiAgICAgIClcbiAgICB9XG5cbiAgICB0aGlzLl9leGVjdXRpb25Db250ZXh0ID0gY3JlYXRlRXhlY3V0aW9uQ29udGV4dChcbiAgICAgIHRoaXMuX2NpcmN1aXRSdW5uZXJDb25maWd1cmF0aW9uLFxuICAgICAge1xuICAgICAgICAuLi5vcHRzLFxuICAgICAgICBwbGF0Zm9ybTogdGhpcy5fY2lyY3VpdFJ1bm5lckNvbmZpZ3VyYXRpb24ucGxhdGZvcm0sXG4gICAgICB9LFxuICAgIClcbiAgICB0aGlzLl9iaW5kRXZlbnRMaXN0ZW5lcnModGhpcy5fZXhlY3V0aW9uQ29udGV4dC5jaXJjdWl0KVxuICAgIHRoaXMuX2V4ZWN1dGlvbkNvbnRleHQuZnNNYXBbXCJlbnRyeXBvaW50LnRzeFwiXSA9IGNvZGVcbiAgICA7KGdsb2JhbFRoaXMgYXMgYW55KS5fX3RzY2lyY3VpdF9jaXJjdWl0ID0gdGhpcy5fZXhlY3V0aW9uQ29udGV4dC5jaXJjdWl0XG5cbiAgICBhd2FpdCBpbXBvcnRFdmFsUGF0aChcIi4vZW50cnlwb2ludC50c3hcIiwgdGhpcy5fZXhlY3V0aW9uQ29udGV4dClcbiAgfVxuXG4gIG9uKGV2ZW50OiBzdHJpbmcsIGNhbGxiYWNrOiAoLi4uYXJnczogYW55W10pID0+IHZvaWQpIHtcbiAgICB0aGlzLl9ldmVudExpc3RlbmVyc1tldmVudF0gPz89IFtdXG4gICAgdGhpcy5fZXZlbnRMaXN0ZW5lcnNbZXZlbnRdLnB1c2goY2FsbGJhY2spXG4gICAgdGhpcy5fZXhlY3V0aW9uQ29udGV4dD8uY2lyY3VpdC5vbihldmVudCBhcyBhbnksIGNhbGxiYWNrKVxuICB9XG5cbiAgYXN5bmMgcmVuZGVyVW50aWxTZXR0bGVkKCk6IFByb21pc2U8dm9pZD4ge1xuICAgIGlmICghdGhpcy5fZXhlY3V0aW9uQ29udGV4dCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gY2lyY3VpdCBoYXMgYmVlbiBjcmVhdGVkXCIpXG4gICAgfVxuICAgIGF3YWl0IHRoaXMuX2V4ZWN1dGlvbkNvbnRleHQuY2lyY3VpdC5yZW5kZXJVbnRpbFNldHRsZWQoKVxuICB9XG5cbiAgYXN5bmMgZ2V0Q2lyY3VpdEpzb24oKTogUHJvbWlzZTxBbnlDaXJjdWl0RWxlbWVudFtdPiB7XG4gICAgaWYgKCF0aGlzLl9leGVjdXRpb25Db250ZXh0KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBjaXJjdWl0IGhhcyBiZWVuIGNyZWF0ZWRcIilcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2V4ZWN1dGlvbkNvbnRleHQuY2lyY3VpdC5nZXRDaXJjdWl0SnNvbigpXG4gIH1cblxuICBjbGVhckV2ZW50TGlzdGVuZXJzKCkge1xuICAgIGlmICh0aGlzLl9leGVjdXRpb25Db250ZXh0Py5jaXJjdWl0KSB7XG4gICAgICBmb3IgKGNvbnN0IGV2ZW50IGluIHRoaXMuX2V2ZW50TGlzdGVuZXJzKSB7XG4gICAgICAgIGZvciAoY29uc3QgbGlzdGVuZXIgb2YgdGhpcy5fZXZlbnRMaXN0ZW5lcnNbZXZlbnRdKSB7XG4gICAgICAgICAgY29uc3QgY2lyY3VpdCA9IHRoaXMuX2V4ZWN1dGlvbkNvbnRleHQuY2lyY3VpdCBhcyB1bmtub3duIGFzIHtcbiAgICAgICAgICAgIC8vIGJpb21lLWlnbm9yZSBsaW50L2NvbXBsZXhpdHkvbm9CYW5uZWRUeXBlczogPGV4cGxhbmF0aW9uPlxuICAgICAgICAgICAgcmVtb3ZlTGlzdGVuZXI/OiAoZXZlbnQ6IHN0cmluZywgbGlzdGVuZXI6IEZ1bmN0aW9uKSA9PiB2b2lkXG4gICAgICAgICAgfVxuICAgICAgICAgIGNpcmN1aXQucmVtb3ZlTGlzdGVuZXI/LihldmVudCwgbGlzdGVuZXIpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKGNvbnN0IGV2ZW50IGluIHRoaXMuX2V2ZW50TGlzdGVuZXJzKSB7XG4gICAgICBkZWxldGUgdGhpcy5fZXZlbnRMaXN0ZW5lcnNbZXZlbnRdXG4gICAgfVxuICB9XG5cbiAgYXN5bmMga2lsbCgpIHtcbiAgICAvLyBDbGVhbnVwIHJlc291cmNlc1xuICAgIHRoaXMuX2V4ZWN1dGlvbkNvbnRleHQgPSBudWxsXG4gIH1cblxuICBhc3luYyBzZXRTbmlwcGV0c0FwaUJhc2VVcmwoYmFzZVVybDogc3RyaW5nKSB7XG4gICAgdGhpcy5fY2lyY3VpdFJ1bm5lckNvbmZpZ3VyYXRpb24uc25pcHBldHNBcGlCYXNlVXJsID0gYmFzZVVybFxuICB9XG5cbiAgYXN5bmMgc2V0UGxhdGZvcm1Db25maWcocGxhdGZvcm06IFBsYXRmb3JtQ29uZmlnKSB7XG4gICAgdGhpcy5fY2lyY3VpdFJ1bm5lckNvbmZpZ3VyYXRpb24ucGxhdGZvcm0gPSBwbGF0Zm9ybVxuICB9XG5cbiAgcHJpdmF0ZSBfYmluZEV2ZW50TGlzdGVuZXJzKGNpcmN1aXQ6IFJvb3RDaXJjdWl0KSB7XG4gICAgZm9yIChjb25zdCBldmVudCBpbiB0aGlzLl9ldmVudExpc3RlbmVycykge1xuICAgICAgZm9yIChjb25zdCBsaXN0ZW5lciBvZiB0aGlzLl9ldmVudExpc3RlbmVyc1tldmVudF0pIHtcbiAgICAgICAgY2lyY3VpdC5vbihldmVudCBhcyBhbnksIGxpc3RlbmVyIGFzIGFueSlcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbiIsICIvKipcbiAqIFJldHVybnMgdGhlIGRpcmVjdG9yeSBuYW1lIG9mIGEgcGF0aCwgc2ltaWxhciB0byBOb2RlLmpzIHBhdGguZGlybmFtZVxuICogV29ya3Mgb24gYm90aCBVbml4IGFuZCBXaW5kb3dzIHBhdGhzXG4gKiBAcGFyYW0gcGF0aCBUaGUgcGF0aCB0byBleHRyYWN0IHRoZSBkaXJlY3RvcnkgZnJvbVxuICogQHJldHVybnMgVGhlIGRpcmVjdG9yeSBwYXJ0IG9mIHRoZSBwYXRoXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkaXJuYW1lKHBhdGg6IHN0cmluZyk6IHN0cmluZyB7XG4gIGlmICghcGF0aCkgcmV0dXJuIFwiLlwiXG5cbiAgLy8gTm9ybWFsaXplIHBhdGggc2VwYXJhdG9ycyB0byBmb3J3YXJkIHNsYXNoZXNcbiAgY29uc3Qgbm9ybWFsaXplZFBhdGggPSBwYXRoLnJlcGxhY2UoL1xcXFwvZywgXCIvXCIpXG5cbiAgLy8gUmVtb3ZlIHRyYWlsaW5nIHNsYXNoZXNcbiAgY29uc3QgY2xlYW5QYXRoID0gbm9ybWFsaXplZFBhdGgucmVwbGFjZSgvXFwvKyQvLCBcIlwiKVxuXG4gIC8vIElmIHRoZXJlIGFyZSBubyBzbGFzaGVzLCByZXR1cm4gXCIuXCJcbiAgaWYgKGNsZWFuUGF0aC5pbmRleE9mKFwiL1wiKSA9PT0gLTEpIHJldHVybiBcIi5cIlxuXG4gIC8vIFJldHVybiBldmVyeXRoaW5nIHVwIHRvIHRoZSBsYXN0IHNsYXNoXG4gIHJldHVybiBjbGVhblBhdGguc3Vic3RyaW5nKDAsIGNsZWFuUGF0aC5sYXN0SW5kZXhPZihcIi9cIikpIHx8IFwiL1wiXG59XG4iLCAiaW1wb3J0IHsgbm9ybWFsaXplRmlsZVBhdGggfSBmcm9tIFwiLi9ub3JtYWxpemVGc01hcFwiXG5pbXBvcnQgeyBkaXJuYW1lIH0gZnJvbSBcImxpYi91dGlscy9kaXJuYW1lXCJcblxuZnVuY3Rpb24gcmVzb2x2ZVJlbGF0aXZlUGF0aChpbXBvcnRQYXRoOiBzdHJpbmcsIGN3ZDogc3RyaW5nKTogc3RyaW5nIHtcbiAgLy8gSGFuZGxlIHBhcmVudCBkaXJlY3RvcnkgbmF2aWdhdGlvblxuICBpZiAoaW1wb3J0UGF0aC5zdGFydHNXaXRoKFwiLi4vXCIpKSB7XG4gICAgY29uc3QgcGFyZW50RGlyID0gZGlybmFtZShjd2QpXG4gICAgcmV0dXJuIHJlc29sdmVSZWxhdGl2ZVBhdGgoaW1wb3J0UGF0aC5zbGljZSgzKSwgcGFyZW50RGlyKVxuICB9XG4gIC8vIEhhbmRsZSBjdXJyZW50IGRpcmVjdG9yeVxuICBpZiAoaW1wb3J0UGF0aC5zdGFydHNXaXRoKFwiLi9cIikpIHtcbiAgICByZXR1cm4gcmVzb2x2ZVJlbGF0aXZlUGF0aChpbXBvcnRQYXRoLnNsaWNlKDIpLCBjd2QpXG4gIH1cbiAgLy8gSGFuZGxlIGFic29sdXRlIHBhdGhcbiAgaWYgKGltcG9ydFBhdGguc3RhcnRzV2l0aChcIi9cIikpIHtcbiAgICByZXR1cm4gaW1wb3J0UGF0aC5zbGljZSgxKVxuICB9XG4gIC8vIEhhbmRsZSByZWxhdGl2ZSBwYXRoXG4gIHJldHVybiBgJHtjd2R9LyR7aW1wb3J0UGF0aH1gXG59XG5cbmV4cG9ydCBjb25zdCByZXNvbHZlRmlsZVBhdGggPSAoXG4gIHVua25vd25GaWxlUGF0aDogc3RyaW5nLFxuICBmc01hcE9yQWxsRmlsZVBhdGhzOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+IHwgc3RyaW5nW10sXG4gIGN3ZD86IHN0cmluZyxcbikgPT4ge1xuICAvLyBIYW5kbGUgcGFyZW50IGRpcmVjdG9yeSBuYXZpZ2F0aW9uIHByb3Blcmx5XG4gIGNvbnN0IHJlc29sdmVkUGF0aCA9IGN3ZFxuICAgID8gcmVzb2x2ZVJlbGF0aXZlUGF0aCh1bmtub3duRmlsZVBhdGgsIGN3ZClcbiAgICA6IHVua25vd25GaWxlUGF0aFxuXG4gIGNvbnN0IGZpbGVQYXRocyA9IG5ldyBTZXQoXG4gICAgQXJyYXkuaXNBcnJheShmc01hcE9yQWxsRmlsZVBhdGhzKVxuICAgICAgPyBmc01hcE9yQWxsRmlsZVBhdGhzXG4gICAgICA6IE9iamVjdC5rZXlzKGZzTWFwT3JBbGxGaWxlUGF0aHMpLFxuICApXG5cbiAgaWYgKGZpbGVQYXRocy5oYXMocmVzb2x2ZWRQYXRoKSkge1xuICAgIHJldHVybiByZXNvbHZlZFBhdGhcbiAgfVxuXG4gIGNvbnN0IG5vcm1hbGl6ZWRGaWxlUGF0aE1hcCA9IG5ldyBNYXA8c3RyaW5nLCBzdHJpbmc+KClcbiAgZm9yIChjb25zdCBmaWxlUGF0aCBvZiBmaWxlUGF0aHMpIHtcbiAgICBub3JtYWxpemVkRmlsZVBhdGhNYXAuc2V0KG5vcm1hbGl6ZUZpbGVQYXRoKGZpbGVQYXRoKSwgZmlsZVBhdGgpXG4gIH1cblxuICBjb25zdCBub3JtYWxpemVkUmVzb2x2ZWRQYXRoID0gbm9ybWFsaXplRmlsZVBhdGgocmVzb2x2ZWRQYXRoKVxuXG4gIGlmIChub3JtYWxpemVkRmlsZVBhdGhNYXAuaGFzKG5vcm1hbGl6ZWRSZXNvbHZlZFBhdGgpKSB7XG4gICAgcmV0dXJuIG5vcm1hbGl6ZWRGaWxlUGF0aE1hcC5nZXQobm9ybWFsaXplZFJlc29sdmVkUGF0aCkhXG4gIH1cblxuICAvLyBTZWFyY2ggZm9yIGZpbGUgd2l0aCBhIHNldCBvZiBkaWZmZXJlbnQgZXh0ZW5zaW9uc1xuICBjb25zdCBleHRlbnNpb24gPSBbXCJ0c3hcIiwgXCJ0c1wiLCBcImpzb25cIiwgXCJqc1wiLCBcImpzeFwiXVxuICBmb3IgKGNvbnN0IGV4dCBvZiBleHRlbnNpb24pIHtcbiAgICBjb25zdCBwb3NzaWJsZUZpbGVQYXRoID0gYCR7bm9ybWFsaXplZFJlc29sdmVkUGF0aH0uJHtleHR9YFxuICAgIGlmIChub3JtYWxpemVkRmlsZVBhdGhNYXAuaGFzKHBvc3NpYmxlRmlsZVBhdGgpKSB7XG4gICAgICByZXR1cm4gbm9ybWFsaXplZEZpbGVQYXRoTWFwLmdldChwb3NzaWJsZUZpbGVQYXRoKSFcbiAgICB9XG4gIH1cblxuICAvLyBDaGVjayBpZiBpdCdzIGFuIGFic29sdXRlIGltcG9ydFxuICBpZiAoIXVua25vd25GaWxlUGF0aC5zdGFydHNXaXRoKFwiLi9cIikgJiYgIXVua25vd25GaWxlUGF0aC5zdGFydHNXaXRoKFwiLi4vXCIpKSB7XG4gICAgY29uc3Qgbm9ybWFsaXplZFVua25vd25GaWxlUGF0aCA9IG5vcm1hbGl6ZUZpbGVQYXRoKHVua25vd25GaWxlUGF0aClcbiAgICBpZiAobm9ybWFsaXplZEZpbGVQYXRoTWFwLmhhcyhub3JtYWxpemVkVW5rbm93bkZpbGVQYXRoKSkge1xuICAgICAgcmV0dXJuIG5vcm1hbGl6ZWRGaWxlUGF0aE1hcC5nZXQobm9ybWFsaXplZFVua25vd25GaWxlUGF0aCkhXG4gICAgfVxuICAgIGZvciAoY29uc3QgZXh0IG9mIGV4dGVuc2lvbikge1xuICAgICAgY29uc3QgcG9zc2libGVGaWxlUGF0aCA9IGAke25vcm1hbGl6ZWRVbmtub3duRmlsZVBhdGh9LiR7ZXh0fWBcbiAgICAgIGlmIChub3JtYWxpemVkRmlsZVBhdGhNYXAuaGFzKHBvc3NpYmxlRmlsZVBhdGgpKSB7XG4gICAgICAgIHJldHVybiBub3JtYWxpemVkRmlsZVBhdGhNYXAuZ2V0KHBvc3NpYmxlRmlsZVBhdGgpIVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBudWxsXG59XG5cbmV4cG9ydCBjb25zdCByZXNvbHZlRmlsZVBhdGhPclRocm93ID0gKFxuICB1bmtub3duRmlsZVBhdGg6IHN0cmluZyxcbiAgZnNNYXBPckFsbEZpbGVQYXRoczogUmVjb3JkPHN0cmluZywgc3RyaW5nPiB8IHN0cmluZ1tdLFxuKSA9PiB7XG4gIGNvbnN0IHJlc29sdmVkRmlsZVBhdGggPSByZXNvbHZlRmlsZVBhdGgodW5rbm93bkZpbGVQYXRoLCBmc01hcE9yQWxsRmlsZVBhdGhzKVxuICBpZiAoIXJlc29sdmVkRmlsZVBhdGgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBgRmlsZSBub3QgZm91bmQgXCIke3Vua25vd25GaWxlUGF0aH1cIiwgYXZhaWxhYmxlIHBhdGhzOlxcblxcbiR7T2JqZWN0LmtleXMoZnNNYXBPckFsbEZpbGVQYXRocykuam9pbihcIiwgXCIpfWAsXG4gICAgKVxuICB9XG4gIHJldHVybiByZXNvbHZlZEZpbGVQYXRoXG59XG4iLCAiaW1wb3J0IHsgcmVzb2x2ZUZpbGVQYXRoIH0gZnJvbSBcImxpYi9ydW5uZXIvcmVzb2x2ZUZpbGVQYXRoXCJcblxuZXhwb3J0IGZ1bmN0aW9uIGV2YWxDb21waWxlZEpzKFxuICBjb21waWxlZENvZGU6IHN0cmluZyxcbiAgcHJlU3VwcGxpZWRJbXBvcnRzOiBSZWNvcmQ8c3RyaW5nLCBhbnk+LFxuICBjd2Q/OiBzdHJpbmcsXG4pIHtcbiAgOyhnbG9iYWxUaGlzIGFzIGFueSkuX190c2NpcmN1aXRfcmVxdWlyZSA9IChuYW1lOiBzdHJpbmcpID0+IHtcbiAgICBjb25zdCByZXNvbHZlZEZpbGVQYXRoID0gcmVzb2x2ZUZpbGVQYXRoKG5hbWUsIHByZVN1cHBsaWVkSW1wb3J0cywgY3dkKVxuXG4gICAgY29uc3QgaGFzUmVzb2x2ZWRGaWxlUGF0aCA9XG4gICAgICByZXNvbHZlZEZpbGVQYXRoICYmIHByZVN1cHBsaWVkSW1wb3J0c1tyZXNvbHZlZEZpbGVQYXRoXVxuXG4gICAgaWYgKCFwcmVTdXBwbGllZEltcG9ydHNbbmFtZV0gJiYgIWhhc1Jlc29sdmVkRmlsZVBhdGgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgSW1wb3J0IFwiJHtuYW1lfVwiIG5vdCBmb3VuZCAke2N3ZCA/IGBpbiBcIiR7Y3dkfVwiYCA6IFwiXCJ9YClcbiAgICB9XG5cbiAgICBjb25zdCBtb2QgPVxuICAgICAgcHJlU3VwcGxpZWRJbXBvcnRzW25hbWVdIHx8IHByZVN1cHBsaWVkSW1wb3J0c1tyZXNvbHZlZEZpbGVQYXRoIV1cbiAgICByZXR1cm4gbmV3IFByb3h5KG1vZCwge1xuICAgICAgZ2V0KHRhcmdldCwgcHJvcCkge1xuICAgICAgICBpZiAoIShwcm9wIGluIHRhcmdldCkpIHtcbiAgICAgICAgICBpZiAocHJvcCA9PT0gXCJkZWZhdWx0XCIpIHtcbiAgICAgICAgICAgIGlmICh0YXJnZXQuZGVmYXVsdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIHJldHVybiB0YXJnZXQuZGVmYXVsdFxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodGFyZ2V0Ll9fZXNNb2R1bGUpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZFxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodHlwZW9mIHRhcmdldCA9PT0gXCJmdW5jdGlvblwiIHx8IHR5cGVvZiB0YXJnZXQgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRhcmdldFxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHByb3AgPT09IFwiX19lc01vZHVsZVwiKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgIGBDb21wb25lbnQgXCIke1N0cmluZyhwcm9wKX1cIiBpcyBub3QgZXhwb3J0ZWQgYnkgXCIke25hbWV9XCJgLFxuICAgICAgICAgIClcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0YXJnZXRbcHJvcCBhcyBrZXlvZiB0eXBlb2YgdGFyZ2V0XVxuICAgICAgfSxcbiAgICB9KVxuICB9XG5cbiAgY29uc3QgZnVuY3Rpb25Cb2R5ID0gYFxuICB2YXIgZXhwb3J0cyA9IHt9O1xuICB2YXIgcmVxdWlyZSA9IGdsb2JhbFRoaXMuX190c2NpcmN1aXRfcmVxdWlyZTtcbiAgdmFyIG1vZHVsZSA9IHsgZXhwb3J0cyB9O1xuICB2YXIgY2lyY3VpdCA9IGdsb2JhbFRoaXMuX190c2NpcmN1aXRfY2lyY3VpdDtcbiAgJHtjb21waWxlZENvZGV9O1xuICByZXR1cm4gbW9kdWxlO2AudHJpbSgpXG4gIHJldHVybiBGdW5jdGlvbihmdW5jdGlvbkJvZHkpLmNhbGwoZ2xvYmFsVGhpcylcbn1cbiIsICJpbXBvcnQgeyBldmFsQ29tcGlsZWRKcyB9IGZyb20gXCIuL2V2YWwtY29tcGlsZWQtanNcIlxuaW1wb3J0IHR5cGUgeyBFeGVjdXRpb25Db250ZXh0IH0gZnJvbSBcIi4vZXhlY3V0aW9uLWNvbnRleHRcIlxuaW1wb3J0ICogYXMgQmFiZWwgZnJvbSBcIkBiYWJlbC9zdGFuZGFsb25lXCJcbmltcG9ydCB7IGltcG9ydExvY2FsRmlsZSB9IGZyb20gXCIuL2ltcG9ydC1sb2NhbC1maWxlXCJcbmltcG9ydCB7IGltcG9ydFNuaXBwZXQgfSBmcm9tIFwiLi9pbXBvcnQtc25pcHBldFwiXG5pbXBvcnQgeyByZXNvbHZlRmlsZVBhdGggfSBmcm9tIFwibGliL3J1bm5lci9yZXNvbHZlRmlsZVBhdGhcIlxuaW1wb3J0IHsgcmVzb2x2ZU5vZGVNb2R1bGUgfSBmcm9tIFwibGliL3V0aWxzL3Jlc29sdmUtbm9kZS1tb2R1bGVcIlxuaW1wb3J0IHsgaW1wb3J0Tm9kZU1vZHVsZSB9IGZyb20gXCIuL2ltcG9ydC1ub2RlLW1vZHVsZVwiXG5pbXBvcnQgRGVidWcgZnJvbSBcImRlYnVnXCJcblxuY29uc3QgZGVidWcgPSBEZWJ1ZyhcInRzY2k6ZXZhbDppbXBvcnQtZXZhbC1wYXRoXCIpXG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBpbXBvcnRFdmFsUGF0aChcbiAgaW1wb3J0TmFtZTogc3RyaW5nLFxuICBjdHg6IEV4ZWN1dGlvbkNvbnRleHQsXG4gIGRlcHRoID0gMCxcbiAgb3B0czoge1xuICAgIGN3ZD86IHN0cmluZ1xuICB9ID0ge30sXG4pIHtcbiAgZGVidWcoXCJpbXBvcnRFdmFsUGF0aCBjYWxsZWQgd2l0aDpcIiwge1xuICAgIGltcG9ydE5hbWUsXG4gICAgZGVwdGgsXG4gICAgb3B0cyxcbiAgfSlcblxuICBkZWJ1ZyhgJHtcIiAgXCIucmVwZWF0KGRlcHRoKX1cdTI3QTFcdUZFMEZgLCBpbXBvcnROYW1lKVxuICBjb25zdCB7IHByZVN1cHBsaWVkSW1wb3J0cyB9ID0gY3R4XG5cbiAgaWYgKHByZVN1cHBsaWVkSW1wb3J0c1tpbXBvcnROYW1lXSkgcmV0dXJuXG4gIGlmIChpbXBvcnROYW1lLnN0YXJ0c1dpdGgoXCIuL1wiKSAmJiBwcmVTdXBwbGllZEltcG9ydHNbaW1wb3J0TmFtZS5zbGljZSgyKV0pXG4gICAgcmV0dXJuXG5cbiAgaWYgKGRlcHRoID4gNSkge1xuICAgIGNvbnNvbGUubG9nKFwiTWF4IGRlcHRoIGZvciBpbXBvcnRzIHJlYWNoZWRcIilcbiAgICByZXR1cm5cbiAgfVxuXG4gIGNvbnN0IHJlc29sdmVkTG9jYWxJbXBvcnRQYXRoID0gcmVzb2x2ZUZpbGVQYXRoKFxuICAgIGltcG9ydE5hbWUsXG4gICAgY3R4LmZzTWFwLFxuICAgIG9wdHMuY3dkLFxuICApXG4gIGlmIChyZXNvbHZlZExvY2FsSW1wb3J0UGF0aCkge1xuICAgIHJldHVybiBpbXBvcnRMb2NhbEZpbGUocmVzb2x2ZWRMb2NhbEltcG9ydFBhdGgsIGN0eCwgZGVwdGgpXG4gIH1cblxuICAvLyBUcnkgdG8gcmVzb2x2ZSBmcm9tIG5vZGVfbW9kdWxlc1xuICBjb25zdCByZXNvbHZlZE5vZGVNb2R1bGVQYXRoID0gcmVzb2x2ZU5vZGVNb2R1bGUoXG4gICAgaW1wb3J0TmFtZSxcbiAgICBjdHguZnNNYXAsXG4gICAgb3B0cy5jd2QgfHwgXCJcIixcbiAgKVxuICBpZiAocmVzb2x2ZWROb2RlTW9kdWxlUGF0aCkge1xuICAgIHJldHVybiBpbXBvcnROb2RlTW9kdWxlKGltcG9ydE5hbWUsIGN0eCwgZGVwdGgpXG4gIH1cblxuICBpZiAoaW1wb3J0TmFtZS5zdGFydHNXaXRoKFwiQHRzY2kvXCIpKSB7XG4gICAgcmV0dXJuIGltcG9ydFNuaXBwZXQoaW1wb3J0TmFtZSwgY3R4LCBkZXB0aClcbiAgfVxuXG4gIHRocm93IG5ldyBFcnJvcihcbiAgICBgVW5yZXNvbHZlZCBpbXBvcnQgXCIke2ltcG9ydE5hbWV9XCIgJHtvcHRzLmN3ZCA/IGBmcm9tIGRpcmVjdG9yeSBcIiR7b3B0cy5jd2R9XCJgIDogXCJcIn1gLFxuICApXG59XG4iLCAiaW1wb3J0ICogYXMgQmFiZWwgZnJvbSBcIkBiYWJlbC9zdGFuZGFsb25lXCJcbmltcG9ydCB7IHJlc29sdmVGaWxlUGF0aE9yVGhyb3cgfSBmcm9tIFwibGliL3J1bm5lci9yZXNvbHZlRmlsZVBhdGhcIlxuaW1wb3J0IHsgZGlybmFtZSB9IGZyb20gXCJsaWIvdXRpbHMvZGlybmFtZVwiXG5pbXBvcnQgeyBnZXRJbXBvcnRzRnJvbUNvZGUgfSBmcm9tIFwibGliL3V0aWxzL2dldC1pbXBvcnRzLWZyb20tY29kZVwiXG5pbXBvcnQgeyBldmFsQ29tcGlsZWRKcyB9IGZyb20gXCIuL2V2YWwtY29tcGlsZWQtanNcIlxuaW1wb3J0IHR5cGUgeyBFeGVjdXRpb25Db250ZXh0IH0gZnJvbSBcIi4vZXhlY3V0aW9uLWNvbnRleHRcIlxuaW1wb3J0IHsgaW1wb3J0RXZhbFBhdGggfSBmcm9tIFwiLi9pbXBvcnQtZXZhbC1wYXRoXCJcbmltcG9ydCBEZWJ1ZyBmcm9tIFwiZGVidWdcIlxuXG5jb25zdCBkZWJ1ZyA9IERlYnVnKFwidHNjaTpldmFsOmltcG9ydC1sb2NhbC1maWxlXCIpXG5cbmV4cG9ydCBjb25zdCBpbXBvcnRMb2NhbEZpbGUgPSBhc3luYyAoXG4gIGltcG9ydE5hbWU6IHN0cmluZyxcbiAgY3R4OiBFeGVjdXRpb25Db250ZXh0LFxuICBkZXB0aCA9IDAsXG4pID0+IHtcbiAgZGVidWcoXCJpbXBvcnRMb2NhbEZpbGUgY2FsbGVkIHdpdGg6XCIsIHtcbiAgICBpbXBvcnROYW1lLFxuICB9KVxuXG4gIGNvbnN0IHsgZnNNYXAsIHByZVN1cHBsaWVkSW1wb3J0cyB9ID0gY3R4XG5cbiAgY29uc3QgZnNQYXRoID0gcmVzb2x2ZUZpbGVQYXRoT3JUaHJvdyhpbXBvcnROYW1lLCBmc01hcClcbiAgZGVidWcoXCJmc1BhdGg6XCIsIGZzUGF0aClcbiAgaWYgKCFjdHguZnNNYXBbZnNQYXRoXSkge1xuICAgIGRlYnVnKFwiZnNQYXRoIG5vdCBmb3VuZCBpbiBmc01hcDpcIiwgZnNQYXRoKVxuICAgIHRocm93IG5ldyBFcnJvcihgRmlsZSBcIiR7ZnNQYXRofVwiIG5vdCBmb3VuZGApXG4gIH1cbiAgY29uc3QgZmlsZUNvbnRlbnQgPSBmc01hcFtmc1BhdGhdXG4gIGRlYnVnKFwiZmlsZUNvbnRlbnQ6XCIsIGZpbGVDb250ZW50Py5zbGljZSgwLCAxMDApKVxuICBpZiAoZnNQYXRoLmVuZHNXaXRoKFwiLmpzb25cIikpIHtcbiAgICBjb25zdCBqc29uRGF0YSA9IEpTT04ucGFyc2UoZmlsZUNvbnRlbnQpXG4gICAgcHJlU3VwcGxpZWRJbXBvcnRzW2ZzUGF0aF0gPSB7XG4gICAgICBfX2VzTW9kdWxlOiB0cnVlLFxuICAgICAgZGVmYXVsdDoganNvbkRhdGEsXG4gICAgfVxuICB9IGVsc2UgaWYgKGZzUGF0aC5lbmRzV2l0aChcIi50c3hcIikgfHwgZnNQYXRoLmVuZHNXaXRoKFwiLnRzXCIpKSB7XG4gICAgY29uc3QgaW1wb3J0TmFtZXMgPSBnZXRJbXBvcnRzRnJvbUNvZGUoZmlsZUNvbnRlbnQpXG5cbiAgICBmb3IgKGNvbnN0IGltcG9ydE5hbWUgb2YgaW1wb3J0TmFtZXMpIHtcbiAgICAgIGlmICghcHJlU3VwcGxpZWRJbXBvcnRzW2ltcG9ydE5hbWVdKSB7XG4gICAgICAgIGF3YWl0IGltcG9ydEV2YWxQYXRoKGltcG9ydE5hbWUsIGN0eCwgZGVwdGggKyAxLCB7XG4gICAgICAgICAgY3dkOiBkaXJuYW1lKGZzUGF0aCksXG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgcmVzdWx0ID0gQmFiZWwudHJhbnNmb3JtKGZpbGVDb250ZW50LCB7XG4gICAgICBwcmVzZXRzOiBbXCJyZWFjdFwiLCBcInR5cGVzY3JpcHRcIl0sXG4gICAgICBwbHVnaW5zOiBbXCJ0cmFuc2Zvcm0tbW9kdWxlcy1jb21tb25qc1wiXSxcbiAgICAgIGZpbGVuYW1lOiBcInZpcnR1YWwudHN4XCIsXG4gICAgfSlcblxuICAgIGlmICghcmVzdWx0IHx8ICFyZXN1bHQuY29kZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRmFpbGVkIHRvIHRyYW5zZm9ybSBjb2RlXCIpXG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIGRlYnVnKFwiZXZhbENvbXBpbGVkSnMgY2FsbGVkIHdpdGg6XCIsIHtcbiAgICAgICAgY29kZTogcmVzdWx0LmNvZGU/LnNsaWNlKDAsIDEwMCksXG4gICAgICAgIGRpcm5hbWU6IGRpcm5hbWUoZnNQYXRoKSxcbiAgICAgIH0pXG4gICAgICBjb25zdCBpbXBvcnRSdW5SZXN1bHQgPSBldmFsQ29tcGlsZWRKcyhcbiAgICAgICAgcmVzdWx0LmNvZGUsXG4gICAgICAgIHByZVN1cHBsaWVkSW1wb3J0cyxcbiAgICAgICAgZGlybmFtZShmc1BhdGgpLFxuICAgICAgKVxuICAgICAgZGVidWcoXCJpbXBvcnRSdW5SZXN1bHQ6XCIsIHtcbiAgICAgICAgZnNQYXRoLFxuICAgICAgICBpbXBvcnRSdW5SZXN1bHQsXG4gICAgICB9KVxuICAgICAgcHJlU3VwcGxpZWRJbXBvcnRzW2ZzUGF0aF0gPSBpbXBvcnRSdW5SZXN1bHQuZXhwb3J0c1xuICAgIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYEV2YWwgY29tcGlsZWQganMgZXJyb3IgZm9yIFwiJHtpbXBvcnROYW1lfVwiOiAke2Vycm9yLm1lc3NhZ2V9YCxcbiAgICAgIClcbiAgICB9XG4gIH0gZWxzZSBpZiAoZnNQYXRoLmVuZHNXaXRoKFwiLmpzXCIpKSB7XG4gICAgLy8gRm9yIC5qcyBmaWxlcywgZXNwZWNpYWxseSBmcm9tIG5vZGVfbW9kdWxlcywgd2UgbmVlZCB0byB0cmFuc2Zvcm0gdGhlbVxuICAgIGNvbnN0IHJlc3VsdCA9IEJhYmVsLnRyYW5zZm9ybShmaWxlQ29udGVudCwge1xuICAgICAgcHJlc2V0czogW1wiZW52XCJdLFxuICAgICAgcGx1Z2luczogW1widHJhbnNmb3JtLW1vZHVsZXMtY29tbW9uanNcIl0sXG4gICAgICBmaWxlbmFtZTogZnNQYXRoLFxuICAgIH0pXG5cbiAgICBpZiAoIXJlc3VsdCB8fCAhcmVzdWx0LmNvZGUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkZhaWxlZCB0byB0cmFuc2Zvcm0gSlMgY29kZVwiKVxuICAgIH1cblxuICAgIHByZVN1cHBsaWVkSW1wb3J0c1tmc1BhdGhdID0gZXZhbENvbXBpbGVkSnMoXG4gICAgICByZXN1bHQuY29kZSxcbiAgICAgIHByZVN1cHBsaWVkSW1wb3J0cyxcbiAgICAgIGRpcm5hbWUoZnNQYXRoKSxcbiAgICApLmV4cG9ydHNcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBgVW5zdXBwb3J0ZWQgZmlsZSBleHRlbnNpb24gXCIke2ZzUGF0aC5zcGxpdChcIi5cIikucG9wKCl9XCIgZm9yIFwiJHtmc1BhdGh9XCJgLFxuICAgIClcbiAgfVxufVxuIiwgImV4cG9ydCBjb25zdCBnZXRJbXBvcnRzRnJvbUNvZGUgPSAoY29kZTogc3RyaW5nKTogc3RyaW5nW10gPT4ge1xuICAvLyBNYXRjaCBiYXNpYyBpbXBvcnQgcGF0dGVybnMgaW5jbHVkaW5nIGNvbWJpbmVkIGRlZmF1bHQgYW5kIG5hbWVzcGFjZSBpbXBvcnRzXG4gIGNvbnN0IGltcG9ydFJlZ2V4ID1cbiAgICAvXlxccyppbXBvcnRcXHMrKD86KD86W1xcd1xcc10rLFxccyopPyg/OlxcKlxccythc1xccytbXFx3XFxzXSt8XFx7W1xcc1xcdyxdK1xcfXxcXHcrKVxccytmcm9tXFxzKyk/WydcIl0oLis/KVsnXCJdL2dtXG4gIGNvbnN0IGltcG9ydHM6IHN0cmluZ1tdID0gW11cbiAgbGV0IG1hdGNoOiBSZWdFeHBFeGVjQXJyYXkgfCBudWxsXG5cbiAgLy8gYmlvbWUtaWdub3JlIGxpbnQvc3VzcGljaW91cy9ub0Fzc2lnbkluRXhwcmVzc2lvbnM6IDxleHBsYW5hdGlvbj5cbiAgd2hpbGUgKChtYXRjaCA9IGltcG9ydFJlZ2V4LmV4ZWMoY29kZSkpICE9PSBudWxsKSB7XG4gICAgaW1wb3J0cy5wdXNoKG1hdGNoWzFdKVxuICB9XG5cbiAgLy8gTWF0Y2ggcmUtZXhwb3J0c1xuICBjb25zdCByZUV4cG9ydFJlZ2V4ID1cbiAgICAvXlxccypleHBvcnRcXHMrKD86XFwqfCg/Olxce1tcXHNcXHcsXStcXH0pKVxccytmcm9tXFxzK1snXCJdKC4rPylbJ1wiXS9nbVxuICBsZXQgcmVFeHBvcnRNYXRjaDogUmVnRXhwRXhlY0FycmF5IHwgbnVsbFxuICAvLyBiaW9tZS1pZ25vcmUgbGludC9zdXNwaWNpb3VzL25vQXNzaWduSW5FeHByZXNzaW9uczogPGV4cGxhbmF0aW9uPlxuICB3aGlsZSAoKHJlRXhwb3J0TWF0Y2ggPSByZUV4cG9ydFJlZ2V4LmV4ZWMoY29kZSkpICE9PSBudWxsKSB7XG4gICAgaW1wb3J0cy5wdXNoKHJlRXhwb3J0TWF0Y2hbMV0pXG4gIH1cblxuICByZXR1cm4gaW1wb3J0c1xufVxuIiwgImltcG9ydCB7IGV2YWxDb21waWxlZEpzIH0gZnJvbSBcIi4vZXZhbC1jb21waWxlZC1qc1wiXG5pbXBvcnQgdHlwZSB7IEV4ZWN1dGlvbkNvbnRleHQgfSBmcm9tIFwiLi9leGVjdXRpb24tY29udGV4dFwiXG5pbXBvcnQgKiBhcyBCYWJlbCBmcm9tIFwiQGJhYmVsL3N0YW5kYWxvbmVcIlxuaW1wb3J0IHsgaW1wb3J0TG9jYWxGaWxlIH0gZnJvbSBcIi4vaW1wb3J0LWxvY2FsLWZpbGVcIlxuaW1wb3J0IHsgaW1wb3J0RXZhbFBhdGggfSBmcm9tIFwiLi9pbXBvcnQtZXZhbC1wYXRoXCJcblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGltcG9ydFNuaXBwZXQoXG4gIGltcG9ydE5hbWU6IHN0cmluZyxcbiAgY3R4OiBFeGVjdXRpb25Db250ZXh0LFxuICBkZXB0aCA9IDAsXG4pIHtcbiAgY29uc3QgeyBwcmVTdXBwbGllZEltcG9ydHMgfSA9IGN0eFxuICBjb25zdCBmdWxsU25pcHBldE5hbWUgPSBpbXBvcnROYW1lLnJlcGxhY2UoXCJAdHNjaS9cIiwgXCJcIikucmVwbGFjZShcIi5cIiwgXCIvXCIpXG5cbiAgY29uc3QgeyBjanMsIGVycm9yIH0gPSBhd2FpdCBmZXRjaChgJHtjdHguY2pzUmVnaXN0cnlVcmx9LyR7ZnVsbFNuaXBwZXROYW1lfWApXG4gICAgLnRoZW4oYXN5bmMgKHJlcykgPT4gKHsgY2pzOiBhd2FpdCByZXMudGV4dCgpLCBlcnJvcjogbnVsbCB9KSlcbiAgICAuY2F0Y2goKGUpID0+ICh7IGVycm9yOiBlLCBjanM6IG51bGwgfSkpXG5cbiAgaWYgKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcihcIkVycm9yIGZldGNoaW5nIGltcG9ydFwiLCBpbXBvcnROYW1lLCBlcnJvcilcbiAgICByZXR1cm5cbiAgfVxuXG4gIHRyeSB7XG4gICAgcHJlU3VwcGxpZWRJbXBvcnRzW2ltcG9ydE5hbWVdID0gZXZhbENvbXBpbGVkSnMoXG4gICAgICBjanMhLFxuICAgICAgcHJlU3VwcGxpZWRJbXBvcnRzLFxuICAgICkuZXhwb3J0c1xuICB9IGNhdGNoIChlKSB7XG4gICAgY29uc29sZS5lcnJvcihcIkVycm9yIGltcG9ydGluZyBzbmlwcGV0XCIsIGUpXG4gIH1cbn1cbiIsICJpbXBvcnQgeyBkaXJuYW1lIH0gZnJvbSBcIi4vZGlybmFtZVwiXG5cbmludGVyZmFjZSBQYWNrYWdlSnNvbiB7XG4gIG1haW4/OiBzdHJpbmdcbiAgbW9kdWxlPzogc3RyaW5nXG4gIGV4cG9ydHM/OiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmcgfCBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+PlxufVxuXG5pbnRlcmZhY2UgTm9kZVJlc29sdXRpb25Db250ZXh0IHtcbiAgZnNNYXA6IFJlY29yZDxzdHJpbmcsIHN0cmluZz5cbiAgZXh0ZW5zaW9uczogc3RyaW5nW11cbiAgYmFzZVBhdGg6IHN0cmluZ1xuICBtb2R1bGVQYXRoOiBzdHJpbmdcbn1cblxuZnVuY3Rpb24gY3JlYXRlQ29udGV4dChcbiAgbW9kdWxlUGF0aDogc3RyaW5nLFxuICBmc01hcDogUmVjb3JkPHN0cmluZywgc3RyaW5nPixcbiAgYmFzZVBhdGg6IHN0cmluZyxcbik6IE5vZGVSZXNvbHV0aW9uQ29udGV4dCB7XG4gIHJldHVybiB7XG4gICAgZnNNYXAsXG4gICAgZXh0ZW5zaW9uczogW1wiLmpzXCIsIFwiLmpzeFwiLCBcIi50c1wiLCBcIi50c3hcIiwgXCIuanNvblwiXSxcbiAgICBiYXNlUGF0aCxcbiAgICBtb2R1bGVQYXRoLFxuICB9XG59XG5cbmZ1bmN0aW9uIGZpbmRQYWNrYWdlSnNvbihub2RlTW9kdWxlc1BhdGg6IHN0cmluZywgY3R4OiBOb2RlUmVzb2x1dGlvbkNvbnRleHQpIHtcbiAgY29uc3QgcGFja2FnZUpzb25QYXRoID0gYCR7bm9kZU1vZHVsZXNQYXRofS9wYWNrYWdlLmpzb25gXG4gIGlmICghY3R4LmZzTWFwW3BhY2thZ2VKc29uUGF0aF0pIHJldHVybiBudWxsXG4gIHRyeSB7XG4gICAgcmV0dXJuIEpTT04ucGFyc2UoY3R4LmZzTWFwW3BhY2thZ2VKc29uUGF0aF0pIGFzIFBhY2thZ2VKc29uXG4gIH0gY2F0Y2gge1xuICAgIHJldHVybiBudWxsXG4gIH1cbn1cblxuZnVuY3Rpb24gdHJ5UmVzb2x2ZVdpdGhFeHRlbnNpb25zKFxuICBwYXRoOiBzdHJpbmcsXG4gIGN0eDogTm9kZVJlc29sdXRpb25Db250ZXh0LFxuKTogc3RyaW5nIHwgbnVsbCB7XG4gIGlmIChjdHguZnNNYXBbcGF0aF0pIHJldHVybiBwYXRoXG5cbiAgZm9yIChjb25zdCBleHQgb2YgY3R4LmV4dGVuc2lvbnMpIHtcbiAgICBjb25zdCBwYXRoV2l0aEV4dCA9IHBhdGgucmVwbGFjZSgvXFwuanMkfFxcLmpzeCQvLCBcIlwiKSArIGV4dFxuICAgIGlmIChjdHguZnNNYXBbcGF0aFdpdGhFeHRdKSByZXR1cm4gcGF0aFdpdGhFeHRcbiAgfVxuICByZXR1cm4gbnVsbFxufVxuXG5mdW5jdGlvbiByZXNvbHZlRXhwb3J0UGF0aChcbiAgbm9kZU1vZHVsZXNQYXRoOiBzdHJpbmcsXG4gIGV4cG9ydFBhdGg6IHN0cmluZyxcbiAgY3R4OiBOb2RlUmVzb2x1dGlvbkNvbnRleHQsXG4pOiBzdHJpbmcgfCBudWxsIHtcbiAgY29uc3QgZnVsbEV4cG9ydFBhdGggPSBgJHtub2RlTW9kdWxlc1BhdGh9LyR7ZXhwb3J0UGF0aC5yZXBsYWNlKC9eXFwuXFwvLywgXCJcIil9YFxuICByZXR1cm4gdHJ5UmVzb2x2ZVdpdGhFeHRlbnNpb25zKGZ1bGxFeHBvcnRQYXRoLCBjdHgpXG59XG5cbmZ1bmN0aW9uIHJlc29sdmVQYWNrYWdlRXhwb3J0cyhcbiAgbm9kZU1vZHVsZXNQYXRoOiBzdHJpbmcsXG4gIHBhY2thZ2VKc29uOiBQYWNrYWdlSnNvbixcbiAgcmVtYWluaW5nUGF0aDogc3RyaW5nLFxuICBjdHg6IE5vZGVSZXNvbHV0aW9uQ29udGV4dCxcbik6IHN0cmluZyB8IG51bGwge1xuICBpZiAoIXBhY2thZ2VKc29uLmV4cG9ydHMpIHJldHVybiBudWxsXG5cbiAgLy8gSGFuZGxlIGRlZmF1bHQgZXhwb3J0IGNvbmRpdGlvblxuICBjb25zdCBkZWZhdWx0RXhwb3J0ID0gcGFja2FnZUpzb24uZXhwb3J0c1tcIi5cIl1cbiAgaWYgKHJlbWFpbmluZ1BhdGggPT09IFwiXCIgJiYgZGVmYXVsdEV4cG9ydCkge1xuICAgIGlmICh0eXBlb2YgZGVmYXVsdEV4cG9ydCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgY29uc3QgcmVzb2x2ZWQgPSByZXNvbHZlRXhwb3J0UGF0aChub2RlTW9kdWxlc1BhdGgsIGRlZmF1bHRFeHBvcnQsIGN0eClcbiAgICAgIGlmIChyZXNvbHZlZCkgcmV0dXJuIHJlc29sdmVkXG4gICAgfVxuICB9XG5cbiAgLy8gSGFuZGxlIHN1YnBhdGggZXhwb3J0c1xuICBjb25zdCBzdWJwYXRoRXhwb3J0ID0gcmVtYWluaW5nUGF0aFxuICAgID8gcGFja2FnZUpzb24uZXhwb3J0c1tgLi8ke3JlbWFpbmluZ1BhdGh9YF1cbiAgICA6IG51bGxcbiAgaWYgKHN1YnBhdGhFeHBvcnQgJiYgdHlwZW9mIHN1YnBhdGhFeHBvcnQgPT09IFwic3RyaW5nXCIpIHtcbiAgICBjb25zdCByZXNvbHZlZCA9IHJlc29sdmVFeHBvcnRQYXRoKG5vZGVNb2R1bGVzUGF0aCwgc3VicGF0aEV4cG9ydCwgY3R4KVxuICAgIGlmIChyZXNvbHZlZCkgcmV0dXJuIHJlc29sdmVkXG4gIH1cblxuICAvLyBIYW5kbGUgY29uZGl0aW9uYWwgZXhwb3J0c1xuICBjb25zdCBpbXBvcnRFeHBvcnQgPSBwYWNrYWdlSnNvbi5leHBvcnRzW1wiaW1wb3J0XCJdXG4gIGlmIChcbiAgICByZW1haW5pbmdQYXRoID09PSBcIlwiICYmXG4gICAgaW1wb3J0RXhwb3J0ICYmXG4gICAgdHlwZW9mIGltcG9ydEV4cG9ydCA9PT0gXCJzdHJpbmdcIlxuICApIHtcbiAgICBjb25zdCByZXNvbHZlZCA9IHJlc29sdmVFeHBvcnRQYXRoKG5vZGVNb2R1bGVzUGF0aCwgaW1wb3J0RXhwb3J0LCBjdHgpXG4gICAgaWYgKHJlc29sdmVkKSByZXR1cm4gcmVzb2x2ZWRcbiAgfVxuXG4gIHJldHVybiBudWxsXG59XG5cbmZ1bmN0aW9uIHJlc29sdmVQYWNrYWdlRW50cnlQb2ludChcbiAgbm9kZU1vZHVsZXNQYXRoOiBzdHJpbmcsXG4gIHBhY2thZ2VKc29uOiBQYWNrYWdlSnNvbixcbiAgY3R4OiBOb2RlUmVzb2x1dGlvbkNvbnRleHQsXG4pOiBzdHJpbmcgfCBudWxsIHtcbiAgY29uc3QgZW50cnlQb2ludCA9IHBhY2thZ2VKc29uLm1vZHVsZSB8fCBwYWNrYWdlSnNvbi5tYWluIHx8IFwiaW5kZXguanNcIlxuICBjb25zdCBmdWxsUGF0aCA9IGAke25vZGVNb2R1bGVzUGF0aH0vJHtlbnRyeVBvaW50fWBcbiAgcmV0dXJuIHRyeVJlc29sdmVXaXRoRXh0ZW5zaW9ucyhmdWxsUGF0aCwgY3R4KVxufVxuXG5mdW5jdGlvbiByZXNvbHZlUmVtYWluaW5nUGF0aChcbiAgbm9kZU1vZHVsZXNQYXRoOiBzdHJpbmcsXG4gIHJlbWFpbmluZ1BhdGg6IHN0cmluZyxcbiAgY3R4OiBOb2RlUmVzb2x1dGlvbkNvbnRleHQsXG4pOiBzdHJpbmcgfCBudWxsIHtcbiAgaWYgKCFyZW1haW5pbmdQYXRoKSB7XG4gICAgLy8gVHJ5IGluZGV4IGZpbGVzIGluIHRoZSBtb2R1bGUgcm9vdFxuICAgIGZvciAoY29uc3QgZXh0IG9mIGN0eC5leHRlbnNpb25zKSB7XG4gICAgICBjb25zdCBpbmRleFBhdGggPSBgJHtub2RlTW9kdWxlc1BhdGh9L2luZGV4JHtleHR9YFxuICAgICAgaWYgKGN0eC5mc01hcFtpbmRleFBhdGhdKSByZXR1cm4gaW5kZXhQYXRoXG4gICAgfVxuICAgIHJldHVybiBudWxsXG4gIH1cblxuICBjb25zdCBmdWxsUGF0aCA9IGAke25vZGVNb2R1bGVzUGF0aH0vJHtyZW1haW5pbmdQYXRofWBcbiAgY29uc3QgZGlyZWN0TWF0Y2ggPSB0cnlSZXNvbHZlV2l0aEV4dGVuc2lvbnMoZnVsbFBhdGgsIGN0eClcbiAgaWYgKGRpcmVjdE1hdGNoKSByZXR1cm4gZGlyZWN0TWF0Y2hcblxuICAvLyBUcnkgaW5kZXggZmlsZXNcbiAgZm9yIChjb25zdCBleHQgb2YgY3R4LmV4dGVuc2lvbnMpIHtcbiAgICBjb25zdCBpbmRleFBhdGggPSBgJHtmdWxsUGF0aH0vaW5kZXgke2V4dH1gXG4gICAgaWYgKGN0eC5mc01hcFtpbmRleFBhdGhdKSByZXR1cm4gaW5kZXhQYXRoXG4gIH1cbiAgcmV0dXJuIG51bGxcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZU5vZGVNb2R1bGVJblBhdGgoXG4gIHNlYXJjaFBhdGg6IHN0cmluZyxcbiAgY3R4OiBOb2RlUmVzb2x1dGlvbkNvbnRleHQsXG4pOiBzdHJpbmcgfCBudWxsIHtcbiAgY29uc3QgbW9kdWxlUGFydHMgPSBjdHgubW9kdWxlUGF0aC5zcGxpdChcIi9cIilcbiAgY29uc3Qgc2NvcGUgPSBtb2R1bGVQYXJ0c1swXS5zdGFydHNXaXRoKFwiQFwiKVxuICAgID8gbW9kdWxlUGFydHMuc2xpY2UoMCwgMikuam9pbihcIi9cIilcbiAgICA6IG1vZHVsZVBhcnRzWzBdXG4gIGNvbnN0IHJlbWFpbmluZ1BhdGggPSBtb2R1bGVQYXJ0cy5zbGljZShzY29wZS5pbmNsdWRlcyhcIi9cIikgPyAyIDogMSkuam9pbihcIi9cIilcbiAgY29uc3Qgbm9kZU1vZHVsZXNQYXRoID0gYCR7c2VhcmNoUGF0aCA9PSBcIi5cIiA/IFwiXCIgOiBgJHtzZWFyY2hQYXRofS9gfW5vZGVfbW9kdWxlcy8ke3Njb3BlfWBcblxuICAvLyBUcnkgdG8gZmluZCBwYWNrYWdlLmpzb25cbiAgY29uc3QgcGFja2FnZUpzb24gPSBmaW5kUGFja2FnZUpzb24obm9kZU1vZHVsZXNQYXRoLCBjdHgpXG4gIGlmIChwYWNrYWdlSnNvbikge1xuICAgIC8vIFRyeSByZXNvbHZpbmcgdGhyb3VnaCBleHBvcnRzIGZpZWxkXG4gICAgY29uc3QgZXhwb3J0c1Jlc29sdXRpb24gPSByZXNvbHZlUGFja2FnZUV4cG9ydHMoXG4gICAgICBub2RlTW9kdWxlc1BhdGgsXG4gICAgICBwYWNrYWdlSnNvbixcbiAgICAgIHJlbWFpbmluZ1BhdGgsXG4gICAgICBjdHgsXG4gICAgKVxuICAgIGlmIChleHBvcnRzUmVzb2x1dGlvbikgcmV0dXJuIGV4cG9ydHNSZXNvbHV0aW9uXG5cbiAgICAvLyBUcnkgcmVzb2x2aW5nIHRocm91Z2ggbWFpbi9tb2R1bGUgZmllbGRzXG4gICAgY29uc3QgZW50cnlQb2ludFJlc29sdXRpb24gPSByZXNvbHZlUGFja2FnZUVudHJ5UG9pbnQoXG4gICAgICBub2RlTW9kdWxlc1BhdGgsXG4gICAgICBwYWNrYWdlSnNvbixcbiAgICAgIGN0eCxcbiAgICApXG4gICAgaWYgKGVudHJ5UG9pbnRSZXNvbHV0aW9uKSByZXR1cm4gZW50cnlQb2ludFJlc29sdXRpb25cbiAgfVxuXG4gIC8vIFRyeSByZXNvbHZpbmcgcmVtYWluaW5nIHBhdGhcbiAgY29uc3QgcmVtYWluaW5nUGF0aFJlc29sdXRpb24gPSByZXNvbHZlUmVtYWluaW5nUGF0aChcbiAgICBub2RlTW9kdWxlc1BhdGgsXG4gICAgcmVtYWluaW5nUGF0aCxcbiAgICBjdHgsXG4gIClcbiAgaWYgKHJlbWFpbmluZ1BhdGhSZXNvbHV0aW9uKSByZXR1cm4gcmVtYWluaW5nUGF0aFJlc29sdXRpb25cblxuICAvLyBJZiBub3QgZm91bmQgYW5kIHdlIGhhdmUgYSBwYXJlbnQgZGlyZWN0b3J5LCB0cnkgdGhlcmVcbiAgY29uc3QgcGFyZW50UGF0aCA9IGRpcm5hbWUoc2VhcmNoUGF0aClcbiAgaWYgKHBhcmVudFBhdGggJiYgcGFyZW50UGF0aCAhPT0gc2VhcmNoUGF0aCkge1xuICAgIHJldHVybiByZXNvbHZlTm9kZU1vZHVsZUluUGF0aChwYXJlbnRQYXRoLCBjdHgpXG4gIH1cblxuICByZXR1cm4gbnVsbFxufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVzb2x2ZU5vZGVNb2R1bGUoXG4gIG1vZHVsZVBhdGg6IHN0cmluZyxcbiAgZnNNYXA6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4sXG4gIGJhc2VQYXRoOiBzdHJpbmcsXG4pOiBzdHJpbmcgfCBudWxsIHtcbiAgY29uc3QgY3R4ID0gY3JlYXRlQ29udGV4dChtb2R1bGVQYXRoLCBmc01hcCwgYmFzZVBhdGgpXG4gIHJldHVybiByZXNvbHZlTm9kZU1vZHVsZUluUGF0aChjdHguYmFzZVBhdGgsIGN0eClcbn1cbiIsICJpbXBvcnQgeyByZXNvbHZlTm9kZU1vZHVsZSB9IGZyb20gXCJsaWIvdXRpbHMvcmVzb2x2ZS1ub2RlLW1vZHVsZVwiXG5pbXBvcnQgdHlwZSB7IEV4ZWN1dGlvbkNvbnRleHQgfSBmcm9tIFwiLi9leGVjdXRpb24tY29udGV4dFwiXG5pbXBvcnQgeyBpbXBvcnRMb2NhbEZpbGUgfSBmcm9tIFwiLi9pbXBvcnQtbG9jYWwtZmlsZVwiXG5cbmV4cG9ydCBjb25zdCBpbXBvcnROb2RlTW9kdWxlID0gYXN5bmMgKFxuICBpbXBvcnROYW1lOiBzdHJpbmcsXG4gIGN0eDogRXhlY3V0aW9uQ29udGV4dCxcbiAgZGVwdGggPSAwLFxuKSA9PiB7XG4gIGNvbnN0IHsgcHJlU3VwcGxpZWRJbXBvcnRzIH0gPSBjdHhcblxuICBpZiAocHJlU3VwcGxpZWRJbXBvcnRzW2ltcG9ydE5hbWVdKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICBjb25zdCByZXNvbHZlZE5vZGVNb2R1bGVQYXRoID0gcmVzb2x2ZU5vZGVNb2R1bGUoaW1wb3J0TmFtZSwgY3R4LmZzTWFwLCBcIlwiKVxuXG4gIGlmICghcmVzb2x2ZWROb2RlTW9kdWxlUGF0aCkge1xuICAgIHRocm93IG5ldyBFcnJvcihgTm9kZSBtb2R1bGUgXCIke2ltcG9ydE5hbWV9XCIgbm90IGZvdW5kYClcbiAgfVxuXG4gIC8vIFVzZSBpbXBvcnRMb2NhbEZpbGUgdG8gaGFuZGxlIHRoZSBub2RlIG1vZHVsZVxuICBhd2FpdCBpbXBvcnRMb2NhbEZpbGUocmVzb2x2ZWROb2RlTW9kdWxlUGF0aCwgY3R4LCBkZXB0aClcblxuICAvLyBNYXAgdGhlIG9yaWdpbmFsIGltcG9ydCBuYW1lIHRvIHRoZSByZXNvbHZlZCBtb2R1bGUncyBleHBvcnRzXG4gIHByZVN1cHBsaWVkSW1wb3J0c1tpbXBvcnROYW1lXSA9IHByZVN1cHBsaWVkSW1wb3J0c1tyZXNvbHZlZE5vZGVNb2R1bGVQYXRoXVxuXG4gIC8vIE1hcCB3aXRob3V0IG5vZGVfbW9kdWxlcyBwcmVmaXggZm9yIGRpcmVjdCBpbXBvcnRzXG4gIGNvbnN0IHVucHJlZml4ZWRQYXRoID0gcmVzb2x2ZWROb2RlTW9kdWxlUGF0aC5yZXBsYWNlKC9ebm9kZV9tb2R1bGVzXFwvLywgXCJcIilcbiAgcHJlU3VwcGxpZWRJbXBvcnRzW3VucHJlZml4ZWRQYXRoXSA9XG4gICAgcHJlU3VwcGxpZWRJbXBvcnRzW3Jlc29sdmVkTm9kZU1vZHVsZVBhdGhdXG5cbiAgLy8gSGFuZGxlIGluZGV4IGZpbGVzIHNwZWNpYWxseVxuICBpZiAoXG4gICAgcmVzb2x2ZWROb2RlTW9kdWxlUGF0aC5lbmRzV2l0aChcIi9pbmRleC50c3hcIikgfHxcbiAgICByZXNvbHZlZE5vZGVNb2R1bGVQYXRoLmVuZHNXaXRoKFwiL2luZGV4LnRzXCIpIHx8XG4gICAgcmVzb2x2ZWROb2RlTW9kdWxlUGF0aC5lbmRzV2l0aChcIi9pbmRleC5qc1wiKVxuICApIHtcbiAgICBjb25zdCBkaXJQYXRoID0gcmVzb2x2ZWROb2RlTW9kdWxlUGF0aC5yZXBsYWNlKC9cXC9pbmRleFxcLih0c3g/fGpzKSQvLCBcIlwiKVxuICAgIGNvbnN0IHVucHJlZml4ZWREaXJQYXRoID0gZGlyUGF0aC5yZXBsYWNlKC9ebm9kZV9tb2R1bGVzXFwvLywgXCJcIilcbiAgICBwcmVTdXBwbGllZEltcG9ydHNbdW5wcmVmaXhlZERpclBhdGhdID1cbiAgICAgIHByZVN1cHBsaWVkSW1wb3J0c1tyZXNvbHZlZE5vZGVNb2R1bGVQYXRoXVxuXG4gICAgLy8gSGFuZGxlIHNjb3BlZCBwYWNrYWdlc1xuICAgIGlmICh1bnByZWZpeGVkRGlyUGF0aC5zdGFydHNXaXRoKFwiQFwiKSkge1xuICAgICAgY29uc3Qgc2NvcGVQYXJ0cyA9IHVucHJlZml4ZWREaXJQYXRoLnNwbGl0KFwiL1wiKVxuICAgICAgaWYgKHNjb3BlUGFydHMubGVuZ3RoID49IDIpIHtcbiAgICAgICAgY29uc3Qgc2NvcGVkTmFtZSA9IGAke3Njb3BlUGFydHNbMF19LyR7c2NvcGVQYXJ0c1sxXX1gXG4gICAgICAgIHByZVN1cHBsaWVkSW1wb3J0c1tzY29wZWROYW1lXSA9XG4gICAgICAgICAgcHJlU3VwcGxpZWRJbXBvcnRzW3Jlc29sdmVkTm9kZU1vZHVsZVBhdGhdXG4gICAgICB9XG4gICAgfVxuICB9XG59XG4iLCAiaW1wb3J0IHsgcmVzb2x2ZUZpbGVQYXRoT3JUaHJvdyB9IGZyb20gXCIuL3Jlc29sdmVGaWxlUGF0aFwiXG5pbXBvcnQgRGVidWcgZnJvbSBcImRlYnVnXCJcblxuY29uc3QgZGVidWcgPSBEZWJ1ZyhcInRzY2k6ZXZhbDpzZXR1cERlZmF1bHRFbnRyeXBvaW50SWZOZWVkZWRcIilcblxuZXhwb3J0IGNvbnN0IHNldHVwRGVmYXVsdEVudHJ5cG9pbnRJZk5lZWRlZCA9IChvcHRzOiB7XG4gIGVudHJ5cG9pbnQ/OiBzdHJpbmdcbiAgZnNNYXA6IFJlY29yZDxzdHJpbmcsIHN0cmluZz5cbiAgbWFpbkNvbXBvbmVudFBhdGg/OiBzdHJpbmdcbiAgbWFpbkNvbXBvbmVudE5hbWU/OiBzdHJpbmdcbiAgbmFtZT86IHN0cmluZ1xuICBtYWluQ29tcG9uZW50UHJvcHM/OiBSZWNvcmQ8c3RyaW5nLCBhbnk+XG59KSA9PiB7XG4gIGlmICghb3B0cy5lbnRyeXBvaW50ICYmICFvcHRzLm1haW5Db21wb25lbnRQYXRoKSB7XG4gICAgaWYgKFwiaW5kZXgudHN4XCIgaW4gb3B0cy5mc01hcCkge1xuICAgICAgb3B0cy5tYWluQ29tcG9uZW50UGF0aCA9IFwiaW5kZXgudHN4XCJcbiAgICB9IGVsc2UgaWYgKFwiaW5kZXgudHNcIiBpbiBvcHRzLmZzTWFwKSB7XG4gICAgICBvcHRzLm1haW5Db21wb25lbnRQYXRoID0gXCJpbmRleC50c1wiXG4gICAgfSBlbHNlIGlmIChcbiAgICAgIE9iamVjdC5rZXlzKG9wdHMuZnNNYXApLmZpbHRlcigoaykgPT4gay5lbmRzV2l0aChcIi50c3hcIikpLmxlbmd0aCA9PT0gMVxuICAgICkge1xuICAgICAgb3B0cy5tYWluQ29tcG9uZW50UGF0aCA9IE9iamVjdC5rZXlzKG9wdHMuZnNNYXApWzBdXG4gICAgfSBlbHNlIGlmIChcInRzY2lyY3VpdC5jb25maWcuanNvblwiIGluIG9wdHMuZnNNYXApIHtcbiAgICAgIGNvbnN0IGNvbmZpZ0NvbnRlbnQgPSBvcHRzLmZzTWFwW1widHNjaXJjdWl0LmNvbmZpZy5qc29uXCJdXG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBjb25maWcgPSBKU09OLnBhcnNlKGNvbmZpZ0NvbnRlbnQpXG4gICAgICAgIGlmIChjb25maWcubWFpbkVudHJ5cG9pbnQpIHtcbiAgICAgICAgICBvcHRzLmVudHJ5cG9pbnQgPSBjb25maWcubWFpbkVudHJ5cG9pbnRcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjb25zb2xlLndhcm4oXCJGYWlsZWQgdG8gcGFyc2UgdHNjaXJjdWl0LmNvbmZpZy5qc29uOlwiLCBlKVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIFwiRWl0aGVyIGVudHJ5cG9pbnQgb3IgbWFpbkNvbXBvbmVudFBhdGggbXVzdCBiZSBwcm92aWRlZCAobm8gaW5kZXggZmlsZSwgY291bGQgbm90IGluZmVyIGVudHJ5cG9pbnQpXCIsXG4gICAgICApXG4gICAgfVxuICB9XG5cbiAgaWYgKCFvcHRzLmVudHJ5cG9pbnQgJiYgb3B0cy5tYWluQ29tcG9uZW50UGF0aCkge1xuICAgIG9wdHMuZW50cnlwb2ludCA9IFwiZW50cnlwb2ludC50c3hcIlxuICAgIGNvbnN0IG1haW5Db21wb25lbnRDb2RlID1cbiAgICAgIG9wdHMuZnNNYXBbcmVzb2x2ZUZpbGVQYXRoT3JUaHJvdyhvcHRzLm1haW5Db21wb25lbnRQYXRoLCBvcHRzLmZzTWFwKV1cbiAgICBpZiAoIW1haW5Db21wb25lbnRDb2RlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBNYWluIGNvbXBvbmVudCBwYXRoIFwiJHtvcHRzLm1haW5Db21wb25lbnRQYXRofVwiIG5vdCBmb3VuZCBpbiBmc01hcC4gQXZhaWxhYmxlIHBhdGhzOiAke09iamVjdC5rZXlzKG9wdHMuZnNNYXApLmpvaW4oXCIsIFwiKX1gLFxuICAgICAgKVxuICAgIH1cblxuICAgIGNvbnN0IGhhc0V4cGxpY2l0Qm9hcmQgPSBtYWluQ29tcG9uZW50Q29kZS5pbmNsdWRlcyhcIjxib2FyZFwiKVxuICAgIGNvbnN0IGhhc1RzY2lJbXBvcnQgPVxuICAgICAgbWFpbkNvbXBvbmVudENvZGUuaW5jbHVkZXMoXCJAdHNjaS9cIikgfHxcbiAgICAgIG1haW5Db21wb25lbnRDb2RlLmluY2x1ZGVzKCdmcm9tIFwiQHRzY2knKVxuICAgIGNvbnN0IHNob3VsZFdyYXBJbkJvYXJkID0gIWhhc0V4cGxpY2l0Qm9hcmQgJiYgIWhhc1RzY2lJbXBvcnRcblxuICAgIG9wdHMuZnNNYXBbb3B0cy5lbnRyeXBvaW50XSA9IGBcbiAgICAgaW1wb3J0ICogYXMgVXNlckNvbXBvbmVudHMgZnJvbSBcIi4vJHtvcHRzLm1haW5Db21wb25lbnRQYXRofVwiO1xuICAgICAgICAgIFxuICAgICAgJHtcbiAgICAgICAgb3B0cy5tYWluQ29tcG9uZW50TmFtZVxuICAgICAgICAgID8gYFxuICAgICAgICBjb25zdCBDb21wb25lbnRUb1JlbmRlciA9IFVzZXJDb21wb25lbnRzW1wiJHtvcHRzLm1haW5Db21wb25lbnROYW1lfVwiXVxuICAgICAgICBgXG4gICAgICAgICAgOiBgY29uc3QgQ29tcG9uZW50VG9SZW5kZXIgPSBPYmplY3QuZW50cmllcyhVc2VyQ29tcG9uZW50cylcbiAgICAgICAgLmZpbHRlcigoW25hbWVdKSA9PiAhbmFtZS5zdGFydHNXaXRoKFwidXNlXCIpKVxuICAgICAgICAubWFwKChbXywgY29tcG9uZW50XSkgPT4gY29tcG9uZW50KVswXSB8fCAoKCkgPT4gbnVsbCk7YFxuICAgICAgfVxuXG4gICAgICAgICAgICR7XG4gICAgICAgICAgICAgZGVidWcuZW5hYmxlZFxuICAgICAgICAgICAgICAgPyBgXG4gICAgIGNvbnNvbGUubG9nKHsgVXNlckNvbXBvbmVudHMgfSlcbiAgICAgY29uc29sZS5sb2coXCJDb21wb25lbnRUb1JlbmRlciBcIiArIENvbXBvbmVudFRvUmVuZGVyLnRvU3RyaW5nKCksICB7IENvbXBvbmVudFRvUmVuZGVyIH0pXG4gICAgIGBcbiAgICAgICAgICAgICAgIDogXCJcIlxuICAgICAgICAgICB9XG5cbiAgICAgIGNpcmN1aXQuYWRkKFxuICAgICAgICAke1xuICAgICAgICAgIHNob3VsZFdyYXBJbkJvYXJkXG4gICAgICAgICAgICA/IGBcbiAgICAgICAgICA8Ym9hcmQ+XG4gICAgICAgICAgICA8Q29tcG9uZW50VG9SZW5kZXIgbmFtZT1cIlUxXCIgJHtvcHRzLm1haW5Db21wb25lbnRQcm9wcyA/IGB7Li4uJHtKU09OLnN0cmluZ2lmeShvcHRzLm1haW5Db21wb25lbnRQcm9wcywgbnVsbCwgMil9fWAgOiBcIlwifSAvPlxuICAgICAgICAgIDwvYm9hcmQ+XG4gICAgICAgIGBcbiAgICAgICAgICAgIDogYFxuICAgICAgICAgIDxDb21wb25lbnRUb1JlbmRlciAke29wdHMubWFpbkNvbXBvbmVudFByb3BzID8gYHsuLi4ke0pTT04uc3RyaW5naWZ5KG9wdHMubWFpbkNvbXBvbmVudFByb3BzLCBudWxsLCAyKX19YCA6IFwiXCJ9IC8+XG4gICAgICAgIGBcbiAgICAgICAgfVxuICAgICAgKTtcbmBcbiAgfVxuXG4gIGlmICghb3B0cy5uYW1lICYmIG9wdHMubWFpbkNvbXBvbmVudE5hbWUpIHtcbiAgICBvcHRzLm5hbWUgPSBvcHRzLm1haW5Db21wb25lbnROYW1lXG4gIH1cbn1cbiIsICJpbXBvcnQgeyBDaXJjdWl0UnVubmVyIH0gZnJvbSBcIi4vQ2lyY3VpdFJ1bm5lclwiXG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBydW5Uc2NpcmN1aXRDb2RlKFxuICBmaWxlc3lzdGVtT3JDb2RlU3RyaW5nOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+IHwgc3RyaW5nLFxuICBvcHRzPzogT21pdDxQYXJhbWV0ZXJzPENpcmN1aXRSdW5uZXJbXCJleGVjdXRlV2l0aEZzTWFwXCJdPlswXSwgXCJmc01hcFwiPixcbikge1xuICBpZiAoXG4gICAgdHlwZW9mIGZpbGVzeXN0ZW1PckNvZGVTdHJpbmcgPT09IFwic3RyaW5nXCIgJiZcbiAgICAhZmlsZXN5c3RlbU9yQ29kZVN0cmluZy5pbmNsdWRlcyhcImV4cG9ydFwiKVxuICApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBgVGhlIFwiZXhwb3J0XCIga2V5d29yZCB3YXNuJ3QgZm91bmQgaW4geW91ciBwcm92aWRlZCBjb2RlLiBZb3UgbmVlZCB0byBleHBvcnQgYSBjb21wb25lbnQgaW4geW91ciBjb2RlLCBlLmcuXFxuXFxuZXhwb3J0IGRlZmF1bHQgKCkgPT4gKFxcbiAgPHJlc2lzdG9yIG5hbWU9XCJSMVwiIHJlc2lzdGFuY2U9XCIxa1wiIC8+XFxuKWAsXG4gICAgKVxuICB9XG4gIGNvbnN0IGZpbGVzeXN0ZW0gPVxuICAgIHR5cGVvZiBmaWxlc3lzdGVtT3JDb2RlU3RyaW5nID09PSBcInN0cmluZ1wiXG4gICAgICA/IHsgXCJ1c2VyLWNvZGUudHN4XCI6IGZpbGVzeXN0ZW1PckNvZGVTdHJpbmcgfVxuICAgICAgOiBmaWxlc3lzdGVtT3JDb2RlU3RyaW5nXG5cbiAgY29uc3QgY2lyY3VpdFJ1bm5lciA9IG5ldyBDaXJjdWl0UnVubmVyKClcblxuICBhd2FpdCBjaXJjdWl0UnVubmVyLmV4ZWN1dGVXaXRoRnNNYXAoe1xuICAgIGZzTWFwOiBmaWxlc3lzdGVtLFxuICAgIC4uLm9wdHMsXG4gIH0pXG5cbiAgYXdhaXQgY2lyY3VpdFJ1bm5lci5yZW5kZXJVbnRpbFNldHRsZWQoKVxuXG4gIHJldHVybiBhd2FpdCBjaXJjdWl0UnVubmVyLmdldENpcmN1aXRKc29uKClcbn1cbiIsICJpbXBvcnQgeyBydW5Uc2NpcmN1aXRDb2RlIH0gZnJvbSBcIi4vcnVuVHNjaXJjdWl0Q29kZVwiXG5cbmV4cG9ydCBjb25zdCBydW5Uc2NpcmN1aXRNb2R1bGUgPSBhc3luYyAoXG4gIG1vZHVsZTogc3RyaW5nLFxuICBvcHRzOiB7IHByb3BzPzogUmVjb3JkPHN0cmluZywgYW55PjsgZXhwb3J0TmFtZT86IHN0cmluZyB9ID0ge30sXG4pID0+IHtcbiAgaWYgKCFtb2R1bGUuc3RhcnRzV2l0aChcIkBcIikpIHtcbiAgICBtb2R1bGUgPSBgQHRzY2kvJHttb2R1bGUucmVwbGFjZSgvXFwvLywgXCIuXCIpfWBcbiAgfVxuICBjb25zdCBjaXJjdWl0SnNvbiA9IGF3YWl0IHJ1blRzY2lyY3VpdENvZGUoXG4gICAge1xuICAgICAgLy8gVE9ETyBoYW5kbGUgZXhwb3J0cyB0aGF0IGFyZSBub3QgdGhlIGRlZmF1bHQgZXhwb3J0IGJ5IHNjYW5uaW5nXG4gICAgICAvLyBvdGhlckV4cG9ydHMgZm9yIGNvbXBvbmVudHNcbiAgICAgIFwidXNlci1jb2RlLnRzeFwiOiBgXG4gICAgaW1wb3J0IE1vZHVsZSwgKiBhcyBvdGhlckV4cG9ydHMgZnJvbSBcIiR7bW9kdWxlfVwiO1xuXG4gICAgbGV0IGV4cG9ydE5hbWUgPSBcIiR7b3B0cy5leHBvcnROYW1lID8/IFwiXCJ9XCJcblxuICAgIGlmICgoIU1vZHVsZSB8fCB0eXBlb2YgTW9kdWxlICE9PSBcImZ1bmN0aW9uXCIpICYmICFCb29sZWFuKGV4cG9ydE5hbWUpKSB7XG4gICAgICBleHBvcnROYW1lID0gT2JqZWN0LmtleXMob3RoZXJFeHBvcnRzKS5maWx0ZXIoa2V5ID0+IGtleVswXSA9PT0ga2V5WzBdLnRvVXBwZXJDYXNlKCkgJiYgdHlwZW9mIG90aGVyRXhwb3J0c1trZXldID09PSBcImZ1bmN0aW9uXCIpWzBdXG4gICAgfVxuXG4gICAgY29uc3QgZGVmYXVsdEV4cG9ydCA9IGV4cG9ydE5hbWUgPyBvdGhlckV4cG9ydHNbZXhwb3J0TmFtZV0gOiBNb2R1bGVcblxuICAgIGlmICghZGVmYXVsdEV4cG9ydCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxcYE5vIGV4cG9ydCBmb3VuZCBmb3IgbW9kdWxlIFwiXFwke21vZHVsZX1cIiAodHJpZWQgXCJcXCR7ZXhwb3J0TmFtZSA/PyBcImRlZmF1bHRcIn1cIilcXGApXG4gICAgfVxuXG4gICAgZXhwb3J0IGRlZmF1bHQgZGVmYXVsdEV4cG9ydDtcbiAgICBgLFxuICAgIH0sXG4gICAge1xuICAgICAgbWFpbkNvbXBvbmVudFByb3BzOiBvcHRzLnByb3BzLFxuICAgIH0sXG4gIClcbiAgcmV0dXJuIGNpcmN1aXRKc29uXG59XG4iLCAiaW1wb3J0ICogYXMgQ29tbGluayBmcm9tIFwiY29tbGlua1wiXG5leHBvcnQgKiBmcm9tIFwiLi91dGlscy9pbmRleFwiXG5pbXBvcnQgdHlwZSB7XG4gIEludGVybmFsV2ViV29ya2VyQXBpLFxuICBXZWJXb3JrZXJDb25maWd1cmF0aW9uLFxuICBDaXJjdWl0V2ViV29ya2VyLFxufSBmcm9tIFwiLi9zaGFyZWQvdHlwZXNcIlxuaW1wb3J0IHR5cGUgeyBSb290Q2lyY3VpdEV2ZW50TmFtZSB9IGZyb20gXCJAdHNjaXJjdWl0L2NvcmVcIlxuXG5leHBvcnQgdHlwZSB7IENpcmN1aXRXZWJXb3JrZXIsIFdlYldvcmtlckNvbmZpZ3VyYXRpb24gfVxuXG5kZWNsYXJlIGdsb2JhbCB7XG4gIGludGVyZmFjZSBXaW5kb3cge1xuICAgIFRTQ0lSQ1VJVF9HTE9CQUxfQ0lSQ1VJVF9XT1JLRVI6IENpcmN1aXRXZWJXb3JrZXIgfCB1bmRlZmluZWRcbiAgfVxuICB2YXIgVFNDSVJDVUlUX0dMT0JBTF9DSVJDVUlUX1dPUktFUjogQ2lyY3VpdFdlYldvcmtlciB8IHVuZGVmaW5lZFxufVxuXG5leHBvcnQgY29uc3QgY3JlYXRlQ2lyY3VpdFdlYldvcmtlciA9IGFzeW5jIChcbiAgY29uZmlndXJhdGlvbjogUGFydGlhbDxXZWJXb3JrZXJDb25maWd1cmF0aW9uPixcbik6IFByb21pc2U8Q2lyY3VpdFdlYldvcmtlcj4gPT4ge1xuICAvLyBLaWxsIGV4aXN0aW5nIGdsb2JhbCB3b3JrZXIgaW5zdGFuY2UgaWYgcHJlc2VudFxuICBjb25zdCBleGlzdGluZ1dvcmtlciA9IGdsb2JhbFRoaXMuVFNDSVJDVUlUX0dMT0JBTF9DSVJDVUlUX1dPUktFUlxuICBpZiAoZXhpc3RpbmdXb3JrZXIgJiYgdHlwZW9mIGV4aXN0aW5nV29ya2VyLmtpbGwgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIGlmIChjb25maWd1cmF0aW9uLnZlcmJvc2UpIHtcbiAgICAgIGNvbnNvbGUubG9nKFwiW1dvcmtlcl0gS2lsbGluZyBwcmV2aW91cyBnbG9iYWwgd29ya2VyIGluc3RhbmNlLi4uXCIpXG4gICAgfVxuICAgIHRyeSB7XG4gICAgICBhd2FpdCBleGlzdGluZ1dvcmtlci5raWxsKClcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBpZiAoY29uZmlndXJhdGlvbi52ZXJib3NlKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICBcIltXb3JrZXJdIEVycm9yIGtpbGxpbmcgcHJldmlvdXMgZ2xvYmFsIHdvcmtlciBpbnN0YW5jZTpcIixcbiAgICAgICAgICBlLFxuICAgICAgICApXG4gICAgICB9XG4gICAgICAvLyBFbnN1cmUgdGhlIGtleSBpcyBjbGVhcmVkIGV2ZW4gaWYga2lsbCB0aHJvd3MgYW4gZXJyb3JcbiAgICAgIGlmIChnbG9iYWxUaGlzLlRTQ0lSQ1VJVF9HTE9CQUxfQ0lSQ1VJVF9XT1JLRVIgPT09IGV4aXN0aW5nV29ya2VyKSB7XG4gICAgICAgIGdsb2JhbFRoaXMuVFNDSVJDVUlUX0dMT0JBTF9DSVJDVUlUX1dPUktFUiA9IHVuZGVmaW5lZFxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChjb25maWd1cmF0aW9uLnZlcmJvc2UpIHtcbiAgICBjb25zb2xlLmxvZyhcbiAgICAgIFwiW1dvcmtlcl0gQ3JlYXRpbmcgY2lyY3VpdCB3ZWIgd29ya2VyIHdpdGggY29uZmlnOlwiLFxuICAgICAgY29uZmlndXJhdGlvbixcbiAgICApXG4gIH1cblxuICBsZXQgd29ya2VyQmxvYlVybCA9XG4gICAgY29uZmlndXJhdGlvbi53ZWJXb3JrZXJCbG9iVXJsID8/IGNvbmZpZ3VyYXRpb24ud2ViV29ya2VyVXJsXG5cbiAgaWYgKCF3b3JrZXJCbG9iVXJsKSB7XG4gICAgY29uc3QgY2RuVXJsID0gYGh0dHBzOi8vY2RuLmpzZGVsaXZyLm5ldC9ucG0vQHRzY2lyY3VpdC9ldmFsQCR7Y29uZmlndXJhdGlvbi5ldmFsVmVyc2lvbiA/PyBcImxhdGVzdFwifS9kaXN0L3dlYndvcmtlci9lbnRyeXBvaW50LmpzYFxuXG4gICAgY29uc3Qgd29ya2VyQmxvYiA9IGF3YWl0IGZldGNoKGNkblVybCkudGhlbigocmVzKSA9PiByZXMuYmxvYigpKVxuICAgIHdvcmtlckJsb2JVcmwgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKHdvcmtlckJsb2IpXG4gIH1cblxuICBjb25zdCByYXdXb3JrZXIgPSBuZXcgV29ya2VyKHdvcmtlckJsb2JVcmwsIHsgdHlwZTogXCJtb2R1bGVcIiB9KVxuICBjb25zdCBjb21saW5rV29ya2VyID0gQ29tbGluay53cmFwPEludGVybmFsV2ViV29ya2VyQXBpPihyYXdXb3JrZXIpXG5cbiAgaWYgKGNvbmZpZ3VyYXRpb24uc25pcHBldHNBcGlCYXNlVXJsKSB7XG4gICAgYXdhaXQgY29tbGlua1dvcmtlci5zZXRTbmlwcGV0c0FwaUJhc2VVcmwoY29uZmlndXJhdGlvbi5zbmlwcGV0c0FwaUJhc2VVcmwpXG4gIH1cbiAgaWYgKGNvbmZpZ3VyYXRpb24ucGxhdGZvcm0pIHtcbiAgICBhd2FpdCBjb21saW5rV29ya2VyLnNldFBsYXRmb3JtQ29uZmlnKGNvbmZpZ3VyYXRpb24ucGxhdGZvcm0pXG4gIH1cblxuICBsZXQgaXNUZXJtaW5hdGVkID0gZmFsc2VcblxuICAvLyBDcmVhdGUgYSB3cmFwcGVyIHRoYXQgaGFuZGxlcyBldmVudHMgZGlyZWN0bHkgdGhyb3VnaCBjaXJjdWl0IGluc3RhbmNlXG4gIGNvbnN0IHdyYXBwZXI6IENpcmN1aXRXZWJXb3JrZXIgPSB7XG4gICAgY2xlYXJFdmVudExpc3RlbmVyczogY29tbGlua1dvcmtlci5jbGVhckV2ZW50TGlzdGVuZXJzLmJpbmQoY29tbGlua1dvcmtlciksXG4gICAgZXhlY3V0ZTogYXN5bmMgKC4uLmFyZ3MpID0+IHtcbiAgICAgIGlmIChpc1Rlcm1pbmF0ZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2lyY3VpdFdlYldvcmtlciB3YXMgdGVybWluYXRlZCwgY2FuJ3QgZXhlY3V0ZVwiKVxuICAgICAgfVxuICAgICAgcmV0dXJuIGNvbWxpbmtXb3JrZXIuZXhlY3V0ZS5iaW5kKGNvbWxpbmtXb3JrZXIpKC4uLmFyZ3MpXG4gICAgfSxcbiAgICBleGVjdXRlV2l0aEZzTWFwOiBhc3luYyAoLi4uYXJncykgPT4ge1xuICAgICAgaWYgKGlzVGVybWluYXRlZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgXCJDaXJjdWl0V2ViV29ya2VyIHdhcyB0ZXJtaW5hdGVkLCBjYW4ndCBleGVjdXRlV2l0aEZzTWFwXCIsXG4gICAgICAgIClcbiAgICAgIH1cbiAgICAgIHJldHVybiBjb21saW5rV29ya2VyLmV4ZWN1dGVXaXRoRnNNYXAuYmluZChjb21saW5rV29ya2VyKSguLi5hcmdzKVxuICAgIH0sXG4gICAgcmVuZGVyVW50aWxTZXR0bGVkOiBjb21saW5rV29ya2VyLnJlbmRlclVudGlsU2V0dGxlZC5iaW5kKGNvbWxpbmtXb3JrZXIpLFxuICAgIGdldENpcmN1aXRKc29uOiBjb21saW5rV29ya2VyLmdldENpcmN1aXRKc29uLmJpbmQoY29tbGlua1dvcmtlciksXG4gICAgb246IChldmVudDogc3RyaW5nLCBjYWxsYmFjazogKC4uLmFyZ3M6IGFueVtdKSA9PiB2b2lkKSA9PiB7XG4gICAgICBjb25zdCBwcm94aWVkQ2FsbGJhY2sgPSBDb21saW5rLnByb3h5KGNhbGxiYWNrKVxuICAgICAgY29tbGlua1dvcmtlci5vbihldmVudCBhcyBSb290Q2lyY3VpdEV2ZW50TmFtZSwgcHJveGllZENhbGxiYWNrKVxuICAgIH0sXG4gICAga2lsbDogYXN5bmMgKCkgPT4ge1xuICAgICAgY29tbGlua1dvcmtlcltDb21saW5rLnJlbGVhc2VQcm94eV0oKVxuICAgICAgcmF3V29ya2VyLnRlcm1pbmF0ZSgpXG4gICAgICBpc1Rlcm1pbmF0ZWQgPSB0cnVlXG4gICAgICBpZiAoZ2xvYmFsVGhpcy5UU0NJUkNVSVRfR0xPQkFMX0NJUkNVSVRfV09SS0VSID09PSB3cmFwcGVyKSB7XG4gICAgICAgIGdsb2JhbFRoaXMuVFNDSVJDVUlUX0dMT0JBTF9DSVJDVUlUX1dPUktFUiA9IHVuZGVmaW5lZFxuICAgICAgfVxuICAgIH0sXG4gIH1cbiAgZ2xvYmFsVGhpcy5UU0NJUkNVSVRfR0xPQkFMX0NJUkNVSVRfV09SS0VSID0gd3JhcHBlclxuICByZXR1cm4gd3JhcHBlclxufVxuIiwgImltcG9ydCB7IG5vcm1hbGl6ZUZpbGVQYXRoIH0gZnJvbSBcIi4vcnVubmVyL25vcm1hbGl6ZUZzTWFwXCJcblxuZXhwb3J0IGNvbnN0IGdldFBvc3NpYmxlRW50cnlwb2ludENvbXBvbmVudFBhdGhzID0gKFxuICBmc01hcDogUmVjb3JkPHN0cmluZywgc3RyaW5nPixcbik6IHN0cmluZ1tdID0+IHtcbiAgY29uc3Qgbm9ybWFsaXplZEZzTWFwOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+ID0ge31cbiAgZm9yIChjb25zdCBbcGF0aCwgY29udGVudF0gb2YgT2JqZWN0LmVudHJpZXMoZnNNYXApKSB7XG4gICAgbm9ybWFsaXplZEZzTWFwW25vcm1hbGl6ZUZpbGVQYXRoKHBhdGgpXSA9IGNvbnRlbnRcbiAgfVxuXG4gIGNvbnN0IHBvc3NpYmxlID0gbmV3IFNldDxzdHJpbmc+KClcblxuICBpZiAoXCJ0c2NpcmN1aXQuY29uZmlnLmpzb25cIiBpbiBub3JtYWxpemVkRnNNYXApIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgY29uZmlnID0gSlNPTi5wYXJzZShub3JtYWxpemVkRnNNYXBbXCJ0c2NpcmN1aXQuY29uZmlnLmpzb25cIl0pXG4gICAgICBpZiAodHlwZW9mIGNvbmZpZy5tYWluRW50cnlwb2ludCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBwb3NzaWJsZS5hZGQobm9ybWFsaXplRmlsZVBhdGgoY29uZmlnLm1haW5FbnRyeXBvaW50KSlcbiAgICAgIH1cbiAgICB9IGNhdGNoIHtcbiAgICAgIC8qIGlnbm9yZSAqL1xuICAgIH1cbiAgfVxuXG4gIGlmIChub3JtYWxpemVkRnNNYXBbXCJpbmRleC50c3hcIl0pIHBvc3NpYmxlLmFkZChcImluZGV4LnRzeFwiKVxuICBpZiAobm9ybWFsaXplZEZzTWFwW1wiaW5kZXgudHNcIl0pIHBvc3NpYmxlLmFkZChcImluZGV4LnRzXCIpXG5cbiAgY29uc3QgY2lyY3VpdEZpbGVzID0gT2JqZWN0LmtleXMobm9ybWFsaXplZEZzTWFwKS5maWx0ZXIoKGspID0+XG4gICAgay5lbmRzV2l0aChcIi5jaXJjdWl0LnRzeFwiKSxcbiAgKVxuICBmb3IgKGNvbnN0IGZpbGUgb2YgY2lyY3VpdEZpbGVzKSB7XG4gICAgcG9zc2libGUuYWRkKGZpbGUpXG4gIH1cblxuICBjb25zdCB0c3hGaWxlcyA9IE9iamVjdC5rZXlzKG5vcm1hbGl6ZWRGc01hcCkuZmlsdGVyKChrKSA9PlxuICAgIGsuZW5kc1dpdGgoXCIudHN4XCIpLFxuICApXG4gIGlmICh0c3hGaWxlcy5sZW5ndGggPT09IDEpIHtcbiAgICBwb3NzaWJsZS5hZGQodHN4RmlsZXNbMF0pXG4gIH1cblxuICByZXR1cm4gQXJyYXkuZnJvbShwb3NzaWJsZSlcbn1cbiJdLAogICJtYXBwaW5ncyI6ICI7QUFBQSxTQUFTLG1CQUFtQjtBQUU1QixZQUFZLG1CQUFtQjtBQUMvQixZQUFZLFdBQVc7QUFDdkIsWUFBWSxnQkFBZ0I7QUFDNUIsWUFBWSx3QkFBd0I7OztBQ0hwQyxJQUFNLFFBQVEsb0JBQUksSUFBaUI7QUFFbkMsSUFBTSxvQkFBb0IsT0FBTyxNQUFXLFdBQWdCO0FBQzFELFFBQU0sY0FBYyxJQUFJLGdCQUFnQjtBQUFBLElBQ3RDLEdBQUc7QUFBQSxJQUNILE1BQU07QUFBQSxFQUNSLENBQUMsRUFBRSxTQUFTO0FBQ1osTUFBSSxNQUFNLElBQUksV0FBVyxHQUFHO0FBQzFCLFdBQU8sTUFBTSxJQUFJLFdBQVc7QUFBQSxFQUM5QjtBQUNBLFFBQU0sV0FBVyxNQUFNO0FBQUEsSUFDckIsbUNBQW1DLElBQUksU0FBUyxXQUFXO0FBQUEsRUFDN0Q7QUFDQSxRQUFNLGVBQWUsTUFBTSxTQUFTLEtBQUs7QUFDekMsUUFBTSxJQUFJLGFBQWEsWUFBWTtBQUNuQyxTQUFPO0FBQ1Q7QUFFTyxJQUFNLGlCQUE4QjtBQUFBLEVBQ3pDLFVBQVUsT0FBTztBQUFBLElBQ2Y7QUFBQSxJQUNBO0FBQUEsRUFDRixNQUFvQztBQUNsQyxRQUNFLGdCQUFnQixTQUFTLHNCQUN6QixnQkFBZ0IsVUFBVSxtQkFDMUI7QUFDQSxZQUFNLEVBQUUsVUFBVSxJQUFJLE1BQU0sa0JBQWtCLGFBQWE7QUFBQSxRQUN6RCxZQUNFLGdCQUFnQixzQkFBc0IsZ0JBQWdCO0FBQUEsUUFDeEQsU0FBUztBQUFBLE1BQ1gsQ0FBQztBQUVELGFBQU87QUFBQSxRQUNMLFNBQVMsYUFBYSxDQUFDLEdBQUcsSUFBSSxDQUFDLE1BQVcsSUFBSSxFQUFFLElBQUksRUFBRSxFQUFFLE1BQU0sR0FBRyxDQUFDO0FBQUEsTUFDcEU7QUFBQSxJQUNGLFdBQ0UsZ0JBQWdC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QUNsRSxVQUFJLE9BQU8sT0FBTyxtQkFBbUIsVUFBVTtBQUM3QyxpQkFBUyxJQUFJLGtCQUFrQixPQUFPLGNBQWMsQ0FBQztBQUFBLE1BQ3ZEO0FBQUEsSUFDRixRQUFRO0FBQUEsSUFFUjtBQUFBLEVBQ0Y7QUFFQSxNQUFJLGdCQUFnQixXQUFXLEVBQUcsVUFBUyxJQUFJLFdBQVc7QUFDMUQsTUFBSSxnQkFBZ0IsVUFBVSxFQUFHLFVBQVMsSUFBSSxVQUFVO0FBRXhELFFBQU0sZUFBZSxPQUFPLEtBQUssZUFBZSxFQUFFO0FBQUEsSUFBTyxDQUFDLE1BQ3hELEVBQUUsU0FBUyxjQUFjO0FBQUEsRUFDM0I7QUFDQSxhQUFXLFFBQVEsY0FBYztBQUMvQixhQUFTLElBQUksSUFBSTtBQUFBLEVBQ25CO0FBRUEsUUFBTSxXQUFXLE9BQU8sS0FBSyxlQUFlLEVBQUU7QUFBQSxJQUFPLENBQUMsTUFDcEQsRUFBRSxTQUFTLE1BQU07QUFBQSxFQUNuQjtBQUNBLE1BQUksU0FBUyxXQUFXLEdBQUc7QUFDekIsYUFBUyxJQUFJLFNBQVMsQ0FBQyxDQUFDO0FBQUEsRUFDMUI7QUFFQSxTQUFPLE1BQU0sS0FBSyxRQUFRO0FBQzVCOyIsCiAgIm5hbWVzIjogWyJEZWJ1ZyIsICJkZWJ1ZyIsICJpbXBvcnROYW1lIiwgIkRlYnVnIiwgImRlYnVnIiwgIkRlYnVnIiwgImRlYnVnIiwgIkRlYnVnIiwgImRlYnVnIl0KfQo=