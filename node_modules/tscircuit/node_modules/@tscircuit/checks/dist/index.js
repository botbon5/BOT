// lib/add-start-and-end-port-ids-if-missing.ts
function distance(x1, y1, x2, y2) {
  return Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);
}
var addStartAndEndPortIdsIfMissing = (soup) => {
  const pcbPorts = soup.filter((item) => item.type === "pcb_port");
  const pcbSmtPads = soup.filter(
    (item) => item.type === "pcb_smtpad"
  );
  const pcbTraces = soup.filter((item) => item.type === "pcb_trace");
  function findPortIdOverlappingPoint(point, options = {}) {
    const traceWidth = options.traceWidth || 0;
    const directPort = pcbPorts.find(
      (port) => distance(port.x, port.y, point.x, point.y) < 0.01
    );
    if (directPort) return directPort.pcb_port_id;
    if (options.isFirstOrLastPoint) {
      const smtPad = pcbSmtPads.find((pad) => {
        if (pad.shape === "rect") {
          return Math.abs(point.x - pad.x) < pad.width / 2 + traceWidth / 2 && Math.abs(point.y - pad.y) < pad.height / 2 + traceWidth / 2;
        } else if (pad.shape === "circle") {
          return distance(point.x, point.y, pad.x, pad.y) < pad.radius;
        }
      });
      if (smtPad) return smtPad.pcb_port_id ?? null;
    }
    return null;
  }
  for (const trace of pcbTraces) {
    for (let index = 0; index < trace.route.length; index++) {
      const segment = trace.route[index];
      const isFirstOrLastPoint = index === 0 || index === trace.route.length - 1;
      if (segment.route_type === "wire") {
        if (!segment.start_pcb_port_id && index === 0) {
          const startPortId = findPortIdOverlappingPoint(segment, {
            isFirstOrLastPoint,
            traceWidth: segment.width
          });
          if (startPortId) {
            segment.start_pcb_port_id = startPortId;
          }
        }
        if (!segment.end_pcb_port_id && index === trace.route.length - 1) {
          const endPortId = findPortIdOverlappingPoint(segment, {
            isFirstOrLastPoint,
            traceWidth: segment.width
          });
          if (endPortId) {
            segment.end_pcb_port_id = endPortId;
          }
        }
      }
    }
  }
};

// lib/check-each-pcb-port-connected.ts
import { getReadableNameForPcbPort } from "@tscircuit/circuit-json-util";
function checkEachPcbPortConnected(soup) {
  addStartAndEndPortIdsIfMissing(soup);
  const pcbPorts = soup.filter((item) => item.type === "pcb_port");
  const pcbTraces = soup.filter((item) => item.type === "pcb_trace");
  const sourceTraces = soup.filter(
    (item) => item.type === "source_trace"
  );
  const errors = [];
  for (const port of pcbPorts) {
    const connectedTraces = pcbTraces.filter(
      (trace) => trace.route.some(
        (segment) => segment.route_type === "wire" && (segment.start_pcb_port_id === port.pcb_port_id || segment.end_pcb_port_id === port.pcb_port_id)
      )
    );
    const sourceTrace = sourceTraces.find(
      (trace) => trace.connected_source_port_ids?.includes(port.source_port_id)
    );
    const hasSourceTraceWithConnections = sourceTrace && sourceTrace.connected_source_port_ids?.length > 0;
    if (connectedTraces.length === 0 && hasSourceTraceWithConnections) {
      errors.push({
        type: "pcb_trace_error",
        message: `pcb_trace_error: PCB port ${getReadableNameForPcbPort(soup, port.pcb_port_id)} is not connected by a PCB trace`,
        source_trace_id: sourceTrace.source_trace_id,
        error_type: "pcb_trace_error",
        pcb_trace_id: "",
        pcb_trace_error_id: "",
        pcb_component_ids: [],
        pcb_port_ids: [port.pcb_port_id]
      });
    }
  }
  return errors;
}

// lib/check-each-pcb-trace-non-overlapping/check-each-pcb-trace-non-overlapping.ts
import { getReadableNameForElement, cju } from "@tscircuit/circuit-json-util";

// lib/data-structures/SpatialIndex.ts
var SpatialObjectIndex = class {
  buckets;
  objectsById;
  getBounds;
  getId;
  CELL_SIZE = 0.4;
  constructor({
    objects,
    getBounds,
    getId,
    CELL_SIZE
  }) {
    this.buckets = /* @__PURE__ */ new Map();
    this.objectsById = /* @__PURE__ */ new Map();
    this.getBounds = getBounds;
    this.getId = getId ?? (() => this._getNextId());
    this.CELL_SIZE = CELL_SIZE ?? this.CELL_SIZE;
    for (const obj of objects) {
      this.addObject(obj);
    }
  }
  _idCounter = 0;
  _getNextId() {
    return `${this._idCounter++}`;
  }
  addObject(obj) {
    const bounds = this.getBounds(obj);
    const spatialIndexId = this.getId(obj);
    const objWithId = { ...obj, spatialIndexId };
    this.objectsById.set(spatialIndexId, objWithId);
    const minBucketX = Math.floor(bounds.minX / this.CELL_SIZE);
    const minBucketY = Math.floor(bounds.minY / this.CELL_SIZE);
    const maxBucketX = Math.floor(bounds.maxX / this.CELL_SIZE);
    const maxBucketY = Math.floor(bounds.maxY / this.CELL_SIZE);
    for (let bx = minBucketX; bx <= maxBucketX; bx++) {
      for (let by = minBucketY; by <= maxBucketY; by++) {
        const bucketKey = `${bx}x${by}`;
        const bucket = this.buckets.get(bucketKey);
        if (!bucket) {
          this.buckets.set(bucketKey, [objWithId]);
        } else {
          bucket.push(objWithId);
        }
      }
    }
  }
  removeObject(id) {
    const obj = this.objectsById.get(id);
    if (!obj) return false;
    this.objectsById.delete(id);
    const bounds = this.getBounds(obj);
    const minBucketX = Math.floor(bounds.minX / this.CELL_SIZE);
    const minBucketY = Math.floor(bounds.minY / this.CELL_SIZE);
    const maxBucketX = Math.floor(bounds.maxX / this.CELL_SIZE);
    const maxBucketY = Math.floor(bounds.maxY / this.CELL_SIZE);
    for (let bx = minBucketX; bx <= maxBucketX; bx++) {
      for (let by = minBucketY; by <= maxBucketY; by++) {
        const bucketKey = `${bx}x${by}`;
        const bucket = this.buckets.get(bucketKey);
        if (bucket) {
          const index = bucket.findIndex((item) => item.spatialIndexId === id);
          if (index !== -1) {
            bucket.splice(index, 1);
            if (bucket.length === 0) {
              this.buckets.delete(bucketKey);
            }
          }
        }
      }
    }
    return true;
  }
  getBucketKey(x, y) {
    return `${Math.floor(x / this.CELL_SIZE)}x${Math.floor(y / this.CELL_SIZE)}`;
  }
  getObjectsInBounds(bounds, margin = 0) {
    const objects = [];
    const addedIds = /* @__PURE__ */ new Set();
    const minBucketX = Math.floor((bounds.minX - margin) / this.CELL_SIZE);
    const minBucketY = Math.floor((bounds.minY - margin) / this.CELL_SIZE);
    const maxBucketX = Math.floor((bounds.maxX + margin) / this.CELL_SIZE);
    const maxBucketY = Math.floor((bounds.maxY + margin) / this.CELL_SIZE);
    for (let bx = minBucketX; bx <= maxBucketX; bx++) {
      for (let by = minBucketY; by <= maxBucketY; by++) {
        const bucketKey = `${bx}x${by}`;
        const bucket = this.buckets.get(bucketKey) || [];
        for (const obj of bucket) {
          const id = obj.spatialIndexId;
          if (addedIds.has(id)) continue;
          addedIds.add(id);
          objects.push(obj);
        }
      }
    }
    return objects;
  }
};

// lib/check-each-pcb-trace-non-overlapping/check-each-pcb-trace-non-overlapping.ts
import {
  getFullConnectivityMapFromCircuitJson
} from "circuit-json-to-connectivity-map";

// lib/check-each-pcb-trace-non-overlapping/getCollidableBounds.ts
import { getBoundsOfPcbElements } from "@tscircuit/circuit-json-util";
var getCollidableBounds = (collidable) => {
  if (collidable.type === "pcb_trace_segment") {
    return {
      minX: Math.min(collidable.x1, collidable.x2),
      minY: Math.min(collidable.y1, collidable.y2),
      maxX: Math.max(collidable.x1, collidable.x2),
      maxY: Math.max(collidable.y1, collidable.y2)
    };
  }
  return getBoundsOfPcbElements([collidable]);
};

// lib/check-each-pcb-trace-non-overlapping/check-each-pcb-trace-non-overlapping.ts
import {
  segmentToBoundsMinDistance,
  segmentToCircleMinDistance
} from "@tscircuit/math-utils";

// lib/drc-defaults.ts
var DEFAULT_TRACE_MARGIN = 0.1;
var DEFAULT_TRACE_THICKNESS = 0.15;
var DEFAULT_VIA_BOARD_MARGIN = 0.3;
var DEFAULT_SAME_NET_VIA_MARGIN = 0.2;
var EPSILON = 5e-3;

// lib/check-each-pcb-trace-non-overlapping/getPcbPortIdsConnectedToTraces.ts
function getPcbPortIdsConnectedToTrace(trace) {
  const connectedPcbPorts = /* @__PURE__ */ new Set();
  for (const segment of trace.route) {
    if (segment.route_type === "wire") {
      if (segment.start_pcb_port_id)
        connectedPcbPorts.add(segment.start_pcb_port_id);
      if (segment.end_pcb_port_id)
        connectedPcbPorts.add(segment.end_pcb_port_id);
    }
  }
  return Array.from(connectedPcbPorts);
}
function getPcbPortIdsConnectedToTraces(traces) {
  const connectedPorts = /* @__PURE__ */ new Set();
  for (const trace of traces) {
    for (const portId of getPcbPortIdsConnectedToTrace(trace)) {
      connectedPorts.add(portId);
    }
  }
  return Array.from(connectedPorts);
}

// lib/check-each-pcb-trace-non-overlapping/check-each-pcb-trace-non-overlapping.ts
import { segmentToSegmentMinDistance } from "@tscircuit/math-utils";
import { getPrimaryId } from "@tscircuit/circuit-json-util";

// lib/check-each-pcb-trace-non-overlapping/getClosestPointBetweenSegments.ts
var getClosestPointBetweenSegments = (segmentA, segmentB) => {
  const a1 = { x: segmentA.x1, y: segmentA.y1 };
  const a2 = { x: segmentA.x2, y: segmentA.y2 };
  const b1 = { x: segmentB.x1, y: segmentB.y1 };
  const b2 = { x: segmentB.x2, y: segmentB.y2 };
  const va = { x: a2.x - a1.x, y: a2.y - a1.y };
  const vb = { x: b2.x - b1.x, y: b2.y - b1.y };
  const lenSqrA = va.x * va.x + va.y * va.y;
  const lenSqrB = vb.x * vb.x + vb.y * vb.y;
  if (lenSqrA === 0 || lenSqrB === 0) {
    if (lenSqrA === 0 && lenSqrB === 0) {
      return {
        x: (a1.x + b1.x) / 2,
        y: (a1.y + b1.y) / 2
      };
    }
    if (lenSqrA === 0) {
      const t2 = clamp(
        ((a1.x - b1.x) * vb.x + (a1.y - b1.y) * vb.y) / lenSqrB,
        0,
        1
      );
      const closestOnB2 = {
        x: b1.x + t2 * vb.x,
        y: b1.y + t2 * vb.y
      };
      return {
        x: (a1.x + closestOnB2.x) / 2,
        y: (a1.y + closestOnB2.y) / 2
      };
    }
    const t = clamp(
      ((b1.x - a1.x) * va.x + (b1.y - a1.y) * va.y) / lenSqrA,
      0,
      1
    );
    const closestOnA2 = {
      x: a1.x + t * va.x,
      y: a1.y + t * va.y
    };
    return {
      x: (closestOnA2.x + b1.x) / 2,
      y: (closestOnA2.y + b1.y) / 2
    };
  }
  const w = { x: a1.x - b1.x, y: a1.y - b1.y };
  const dotAA = va.x * va.x + va.y * va.y;
  const dotAB = va.x * vb.x + va.y * vb.y;
  const dotAW = va.x * w.x + va.y * w.y;
  const dotBB = vb.x * vb.x + vb.y * vb.y;
  const dotBW = vb.x * w.x + vb.y * w.y;
  const denominator = dotAA * dotBB - dotAB * dotAB;
  if (denominator < 1e-10) {
    return closestPointsParallelSegments(
      a1,
      a2,
      b1,
      b2,
      va,
      vb,
      lenSqrA,
      lenSqrB
    );
  }
  let tA = (dotAB * dotBW - dotBB * dotAW) / denominator;
  let tB = (dotAA * dotBW - dotAB * dotAW) / denominator;
  tA = clamp(tA, 0, 1);
  tB = clamp(tB, 0, 1);
  tB = (tA * dotAB + dotBW) / dotBB;
  tB = clamp(tB, 0, 1);
  tA = (tB * dotAB - dotAW) / dotAA;
  tA = clamp(tA, 0, 1);
  const closestOnA = {
    x: a1.x + tA * va.x,
    y: a1.y + tA * va.y
  };
  const closestOnB = {
    x: b1.x + tB * vb.x,
    y: b1.y + tB * vb.y
  };
  const dx = closestOnA.x - closestOnB.x;
  const dy = closestOnA.y - closestOnB.y;
  const distance4 = Math.sqrt(dx * dx + dy * dy);
  const averagePoint = {
    x: (closestOnA.x + closestOnB.x) / 2,
    y: (closestOnA.y + closestOnB.y) / 2
  };
  return averagePoint;
};
var closestPointsParallelSegments = (a1, a2, b1, b2, va, vb, lenSqrA, lenSqrB) => {
  let tA = ((b1.x - a1.x) * va.x + (b1.y - a1.y) * va.y) / lenSqrA;
  tA = clamp(tA, 0, 1);
  const pointOnA1 = { x: a1.x + tA * va.x, y: a1.y + tA * va.y };
  let tA2 = ((b2.x - a1.x) * va.x + (b2.y - a1.y) * va.y) / lenSqrA;
  tA2 = clamp(tA2, 0, 1);
  const pointOnA2 = { x: a1.x + tA2 * va.x, y: a1.y + tA2 * va.y };
  let tB = ((a1.x - b1.x) * vb.x + (a1.y - b1.y) * vb.y) / lenSqrB;
  tB = clamp(tB, 0, 1);
  const pointOnB1 = { x: b1.x + tB * vb.x, y: b1.y + tB * vb.y };
  let tB2 = ((a2.x - b1.x) * vb.x + (a2.y - b1.y) * vb.y) / lenSqrB;
  tB2 = clamp(tB2, 0, 1);
  const pointOnB2 = { x: b1.x + tB2 * vb.x, y: b1.y + tB2 * vb.y };
  const distances = [
    {
      pointA: pointOnA1,
      pointB: b1,
      distance: Math.sqrt(
        (pointOnA1.x - b1.x) ** 2 + (pointOnA1.y - b1.y) ** 2
      )
    },
    {
      pointA: pointOnA2,
      pointB: b2,
      distance: Math.sqrt(
        (pointOnA2.x - b2.x) ** 2 + (pointOnA2.y - b2.y) ** 2
      )
    },
    {
      pointA: a1,
      pointB: pointOnB1,
      distance: Math.sqrt(
        (a1.x - pointOnB1.x) ** 2 + (a1.y - pointOnB1.y) ** 2
      )
    },
    {
      pointA: a2,
      pointB: pointOnB2,
      distance: Math.sqrt(
        (a2.x - pointOnB2.x) ** 2 + (a2.y - pointOnB2.y) ** 2
      )
    }
  ];
  const closestPair = distances.reduce(
    (closest, current) => current.distance < closest.distance ? current : closest
  );
  return {
    x: (closestPair.pointA.x + closestPair.pointB.x) / 2,
    y: (closestPair.pointA.y + closestPair.pointB.y) / 2
  };
};
var clamp = (value, min, max) => {
  return Math.max(min, Math.min(max, value));
};

// lib/check-each-pcb-trace-non-overlapping/getRadiusOfCircuitJsonElement.ts
var getRadiusOfCircuitJsonElement = (obj) => {
  if (obj.type === "pcb_via") {
    return obj.outer_diameter / 2;
  }
  if (obj.type === "pcb_plated_hole" && obj.shape === "circle") {
    return obj.outer_diameter / 2;
  }
  if (obj.type === "pcb_hole" && obj.hole_shape === "circle") {
    return obj.hole_diameter / 2;
  }
  if (obj.type === "pcb_smtpad" && obj.shape === "circle") {
    return obj.radius;
  }
  throw new Error(
    `Could not determine radius of element: ${JSON.stringify(obj)}`
  );
};

// lib/check-each-pcb-trace-non-overlapping/getClosestPointBetweenSegmentAndBounds.ts
var getClosestPointBetweenSegmentAndBounds = (segment, bounds) => {
  const p1 = { x: segment.x1, y: segment.y1 };
  const p2 = { x: segment.x2, y: segment.y2 };
  const minX = bounds.minX;
  const minY = bounds.minY;
  const maxX = bounds.maxX;
  const maxY = bounds.maxY;
  if (p1.x === p2.x && p1.y === p2.y) {
    const closestX = Math.max(minX, Math.min(maxX, p1.x));
    const closestY = Math.max(minY, Math.min(maxY, p1.y));
    if (closestX === p1.x && closestY === p1.y) {
      return { x: p1.x, y: p1.y };
    }
    return { x: closestX, y: closestY };
  }
  const dx = p2.x - p1.x;
  const dy = p2.y - p1.y;
  const tMinX = dx !== 0 ? (minX - p1.x) / dx : Number.NEGATIVE_INFINITY;
  const tMaxX = dx !== 0 ? (maxX - p1.x) / dx : Number.POSITIVE_INFINITY;
  const tMinY = dy !== 0 ? (minY - p1.y) / dy : Number.NEGATIVE_INFINITY;
  const tMaxY = dy !== 0 ? (maxY - p1.y) / dy : Number.POSITIVE_INFINITY;
  const tEnter = Math.max(Math.min(tMinX, tMaxX), Math.min(tMinY, tMaxY));
  const tExit = Math.min(Math.max(tMinX, tMaxX), Math.max(tMinY, tMaxY));
  if (tEnter <= tExit && tExit >= 0 && tEnter <= 1) {
    const t = Math.max(0, Math.min(1, tEnter));
    return {
      x: p1.x + t * dx,
      y: p1.y + t * dy
    };
  }
  const closestToP1 = {
    x: Math.max(minX, Math.min(maxX, p1.x)),
    y: Math.max(minY, Math.min(maxY, p1.y))
  };
  const closestToP2 = {
    x: Math.max(minX, Math.min(maxX, p2.x)),
    y: Math.max(minY, Math.min(maxY, p2.y))
  };
  const distToP1Squared = (closestToP1.x - p1.x) ** 2 + (closestToP1.y - p1.y) ** 2;
  const distToP2Squared = (closestToP2.x - p2.x) ** 2 + (closestToP2.y - p2.y) ** 2;
  const edges = [
    { start: { x: minX, y: minY }, end: { x: maxX, y: minY } },
    // Bottom edge
    { start: { x: maxX, y: minY }, end: { x: maxX, y: maxY } },
    // Right edge
    { start: { x: maxX, y: maxY }, end: { x: minX, y: maxY } },
    // Top edge
    { start: { x: minX, y: maxY }, end: { x: minX, y: minY } }
    // Left edge
  ];
  let minDistance = Math.min(distToP1Squared, distToP2Squared);
  let closestPoint = distToP1Squared <= distToP2Squared ? closestToP1 : closestToP2;
  const clamp2 = (value, min, max) => {
    return Math.max(min, Math.min(max, value));
  };
  for (const edge of edges) {
    const va = { x: p2.x - p1.x, y: p2.y - p1.y };
    const vb = { x: edge.end.x - edge.start.x, y: edge.end.y - edge.start.y };
    const w = { x: p1.x - edge.start.x, y: p1.y - edge.start.y };
    const dotAA = va.x * va.x + va.y * va.y;
    const dotAB = va.x * vb.x + va.y * vb.y;
    const dotAW = va.x * w.x + va.y * w.y;
    const dotBB = vb.x * vb.x + vb.y * vb.y;
    const dotBW = vb.x * w.x + vb.y * w.y;
    const denominator = dotAA * dotBB - dotAB * dotAB;
    if (Math.abs(denominator) < 1e-10) continue;
    let tA = (dotAB * dotBW - dotBB * dotAW) / denominator;
    let tB = (dotAA * dotBW - dotAB * dotAW) / denominator;
    tA = clamp2(tA, 0, 1);
    tB = clamp2(tB, 0, 1);
    const closestOnSegment = {
      x: p1.x + tA * va.x,
      y: p1.y + tA * va.y
    };
    const closestOnEdge = {
      x: edge.start.x + tB * vb.x,
      y: edge.start.y + tB * vb.y
    };
    const dx2 = closestOnSegment.x - closestOnEdge.x;
    const dy2 = closestOnSegment.y - closestOnEdge.y;
    const distSquared = dx2 * dx2 + dy2 * dy2;
    if (distSquared < minDistance) {
      minDistance = distSquared;
      closestPoint = {
        x: (closestOnSegment.x + closestOnEdge.x) / 2,
        y: (closestOnSegment.y + closestOnEdge.y) / 2
      };
    }
  }
  return closestPoint;
};

// lib/util/getLayersOfPcbElement.ts
import { all_layers } from "circuit-json";
function getLayersOfPcbElement(obj) {
  if (obj.type === "pcb_trace_segment") {
    return [obj.layer];
  }
  if (obj.type === "pcb_smtpad") {
    return [obj.layer];
  }
  if (obj.type === "pcb_plated_hole") {
    return Array.isArray(obj.layers) ? obj.layers : [...all_layers];
  }
  if (obj.type === "pcb_hole") {
    return [...all_layers];
  }
  if (obj.type === "pcb_via") {
    return Array.isArray(obj.layers) ? obj.layers : [...all_layers];
  }
  if (obj.type === "pcb_keepout") {
    return Array.isArray(obj.layers) ? obj.layers : [];
  }
  return [];
}

// lib/check-each-pcb-trace-non-overlapping/check-each-pcb-trace-non-overlapping.ts
function checkEachPcbTraceNonOverlapping(circuitJson, {
  connMap
} = {}) {
  const errors = [];
  connMap ??= getFullConnectivityMapFromCircuitJson(circuitJson);
  const pcbTraces = cju(circuitJson).pcb_trace.list();
  const pcbTraceSegments = pcbTraces.flatMap((pcbTrace) => {
    const segments = [];
    for (let i = 0; i < pcbTrace.route.length - 1; i++) {
      const p1 = pcbTrace.route[i];
      const p2 = pcbTrace.route[i + 1];
      if (p1.route_type !== "wire") continue;
      if (p2.route_type !== "wire") continue;
      if (p1.layer !== p2.layer) continue;
      segments.push({
        type: "pcb_trace_segment",
        pcb_trace_id: pcbTrace.pcb_trace_id,
        _pcbTrace: pcbTrace,
        thickness: "width" in p1 ? p1.width : "width" in p2 ? p2.width : DEFAULT_TRACE_THICKNESS,
        layer: p1.layer,
        x1: p1.x,
        y1: p1.y,
        x2: p2.x,
        y2: p2.y
      });
    }
    return segments;
  });
  const pcbSmtPads = cju(circuitJson).pcb_smtpad.list();
  const pcbPlatedHoles = cju(circuitJson).pcb_plated_hole.list();
  const pcbHoles = cju(circuitJson).pcb_hole.list();
  const pcbVias = cju(circuitJson).pcb_via.list();
  const pcbKeepouts = cju(circuitJson).pcb_keepout.list();
  const allObjects = [
    ...pcbTraceSegments,
    ...pcbSmtPads,
    ...pcbPlatedHoles,
    ...pcbHoles,
    ...pcbVias,
    ...pcbKeepouts
  ];
  const spatialIndex = new SpatialObjectIndex({
    objects: allObjects,
    getBounds: getCollidableBounds
  });
  const getReadableName = (id) => getReadableNameForElement(circuitJson, id);
  const errorIds = /* @__PURE__ */ new Set();
  for (const segmentA of pcbTraceSegments) {
    const requiredMargin = DEFAULT_TRACE_MARGIN;
    const bounds = getCollidableBounds(segmentA);
    const nearbyObjects = spatialIndex.getObjectsInBounds(
      bounds,
      requiredMargin + segmentA.thickness / 2
    );
    if (segmentA.x1 === segmentA.x2 && segmentA.y1 === segmentA.y2) continue;
    for (const obj of nearbyObjects) {
      if (!getLayersOfPcbElement(obj).includes(segmentA.layer)) {
        continue;
      }
      if (obj.type === "pcb_trace_segment") {
        const segmentB = obj;
        if (segmentA.layer !== segmentB.layer) continue;
        if (connMap.areIdsConnected(segmentA.pcb_trace_id, segmentB.pcb_trace_id))
          continue;
        const gap2 = segmentToSegmentMinDistance(
          { x: segmentA.x1, y: segmentA.y1 },
          { x: segmentA.x2, y: segmentA.y2 },
          { x: segmentB.x1, y: segmentB.y1 },
          { x: segmentB.x2, y: segmentB.y2 }
        ) - segmentA.thickness / 2 - segmentB.thickness / 2;
        if (gap2 > DEFAULT_TRACE_MARGIN - EPSILON) continue;
        const pcb_trace_error_id = `overlap_${segmentA.pcb_trace_id}_${segmentB.pcb_trace_id}`;
        const pcb_trace_error_id_reverse = `overlap_${segmentB.pcb_trace_id}_${segmentA.pcb_trace_id}`;
        if (errorIds.has(pcb_trace_error_id)) continue;
        if (errorIds.has(pcb_trace_error_id_reverse)) continue;
        errorIds.add(pcb_trace_error_id);
        errors.push({
          type: "pcb_trace_error",
          error_type: "pcb_trace_error",
          message: `PCB trace ${getReadableName(segmentA.pcb_trace_id)} overlaps with ${getReadableName(segmentB.pcb_trace_id)} ${gap2 < 0 ? "(accidental contact)" : `(gap: ${gap2.toFixed(3)}mm)`}`,
          pcb_trace_id: segmentA.pcb_trace_id,
          source_trace_id: "",
          pcb_trace_error_id,
          pcb_component_ids: [],
          center: getClosestPointBetweenSegments(segmentA, segmentB),
          pcb_port_ids: getPcbPortIdsConnectedToTraces([
            segmentA._pcbTrace,
            segmentB._pcbTrace
          ])
        });
        continue;
      }
      const primaryObjId = getPrimaryId(obj);
      if (connMap.areIdsConnected(
        segmentA.pcb_trace_id,
        "pcb_trace_id" in obj ? obj.pcb_trace_id : primaryObjId
      ))
        continue;
      const isCircular = obj.type === "pcb_via" || obj.type === "pcb_plated_hole" && obj.shape === "circle" || obj.type === "pcb_hole" || obj.type === "pcb_smtpad" && obj.shape === "circle";
      if (isCircular) {
        const radius = getRadiusOfCircuitJsonElement(obj);
        const distance4 = segmentToCircleMinDistance(
          { x: segmentA.x1, y: segmentA.y1 },
          { x: segmentA.x2, y: segmentA.y2 },
          { x: obj.x, y: obj.y, radius }
        );
        const gap2 = distance4 - segmentA.thickness / 2;
        if (gap2 > DEFAULT_TRACE_MARGIN - EPSILON) continue;
        const pcb_trace_error_id = `overlap_${segmentA.pcb_trace_id}_${primaryObjId}`;
        if (errorIds.has(pcb_trace_error_id)) continue;
        errorIds.add(pcb_trace_error_id);
        errors.push({
          type: "pcb_trace_error",
          error_type: "pcb_trace_error",
          message: `PCB trace ${getReadableName(segmentA.pcb_trace_id)} overlaps with ${obj.type} "${getReadableName(getPrimaryId(obj))}" ${gap2 < 0 ? "(accidental contact)" : `(gap: ${gap2.toFixed(3)}mm)`}`,
          pcb_trace_id: segmentA.pcb_trace_id,
          center: getClosestPointBetweenSegmentAndBounds(
            segmentA,
            getCollidableBounds(obj)
          ),
          source_trace_id: "",
          pcb_trace_error_id,
          pcb_component_ids: [
            "pcb_component_id" in obj ? obj.pcb_component_id : void 0
          ].filter(Boolean),
          pcb_port_ids: [
            ...getPcbPortIdsConnectedToTraces([segmentA._pcbTrace]),
            "pcb_port_id" in obj ? obj.pcb_port_id : void 0
          ].filter(Boolean)
        });
      }
      const gap = segmentToBoundsMinDistance(
        { x: segmentA.x1, y: segmentA.y1 },
        { x: segmentA.x2, y: segmentA.y2 },
        getCollidableBounds(obj)
      ) - segmentA.thickness / 2;
      if (gap + EPSILON < requiredMargin) {
        const pcb_trace_error_id = `overlap_${segmentA.pcb_trace_id}_${primaryObjId}`;
        if (errorIds.has(pcb_trace_error_id)) continue;
        errorIds.add(pcb_trace_error_id);
        errors.push({
          type: "pcb_trace_error",
          error_type: "pcb_trace_error",
          message: `PCB trace ${getReadableName(segmentA.pcb_trace_id)} overlaps with ${obj.type} "${getReadableName(getPrimaryId(obj))}" ${gap < 0 ? "(accidental contact)" : `(gap: ${gap.toFixed(3)}mm)`}`,
          pcb_trace_id: segmentA.pcb_trace_id,
          source_trace_id: "",
          pcb_trace_error_id,
          pcb_component_ids: [
            "pcb_component_id" in obj ? obj.pcb_component_id : void 0
          ].filter(Boolean),
          center: getClosestPointBetweenSegmentAndBounds(
            segmentA,
            getCollidableBounds(obj)
          ),
          pcb_port_ids: [
            ...getPcbPortIdsConnectedToTraces([segmentA._pcbTrace]),
            "pcb_port_id" in obj ? obj.pcb_port_id : void 0
          ].filter(Boolean)
        });
      }
    }
  }
  return errors;
}

// lib/net-manager.ts
var NetManager = class {
  networks = /* @__PURE__ */ new Set();
  setConnected(nodes) {
    if (nodes.length < 2) return;
    let targetNetwork = null;
    for (const network of this.networks) {
      for (const node of nodes) {
        if (network.has(node)) {
          if (targetNetwork === null) {
            targetNetwork = network;
          } else if (targetNetwork !== network) {
            for (const mergeNode of network) {
              targetNetwork.add(mergeNode);
            }
            this.networks.delete(network);
          }
          break;
        }
      }
      if (targetNetwork !== null && targetNetwork !== network) break;
    }
    if (targetNetwork === null) {
      targetNetwork = new Set(nodes);
      this.networks.add(targetNetwork);
    } else {
      for (const node of nodes) {
        targetNetwork.add(node);
      }
    }
  }
  isConnected(nodes) {
    if (nodes.length < 2) return true;
    for (const network of this.networks) {
      if (nodes.every((node) => network.has(node))) {
        return true;
      }
    }
    return false;
  }
};

// lib/check-pcb-components-out-of-board/checkViasOffBoard.ts
import { getReadableNameForElement as getReadableNameForElement2 } from "@tscircuit/circuit-json-util";
function checkViasOffBoard(circuitJson) {
  const board = circuitJson.find((el) => el.type === "pcb_board");
  if (!board) return [];
  const vias = circuitJson.filter((el) => el.type === "pcb_via");
  if (vias.length === 0) return [];
  const boardMinX = board.center.x - board.width / 2;
  const boardMaxX = board.center.x + board.width / 2;
  const boardMinY = board.center.y - board.height / 2;
  const boardMaxY = board.center.y + board.height / 2;
  const errors = [];
  for (const via of vias) {
    const viaRadius = via.outer_diameter / 2;
    const viaMinX = via.x - viaRadius;
    const viaMaxX = via.x + viaRadius;
    const viaMinY = via.y - viaRadius;
    const viaMaxY = via.y + viaRadius;
    if (viaMinX < boardMinX + DEFAULT_VIA_BOARD_MARGIN || viaMaxX > boardMaxX - DEFAULT_VIA_BOARD_MARGIN || viaMinY < boardMinY + DEFAULT_VIA_BOARD_MARGIN || viaMaxY > boardMaxY - DEFAULT_VIA_BOARD_MARGIN) {
      const viaName = getReadableNameForElement2(circuitJson, via.pcb_via_id);
      errors.push({
        type: "pcb_placement_error",
        pcb_placement_error_id: `out_of_board_${via.pcb_via_id}`,
        message: `Via ${viaName} is outside or crossing the board boundary`,
        error_type: "pcb_placement_error"
      });
    }
  }
  return errors;
}

// lib/check-same-net-via-spacing.ts
import { getReadableNameForElement as getReadableNameForElement3 } from "@tscircuit/circuit-json-util";
import {
  getFullConnectivityMapFromCircuitJson as getFullConnectivityMapFromCircuitJson2
} from "circuit-json-to-connectivity-map";
function distance2(a, b) {
  return Math.hypot(a.x - b.x, a.y - b.y);
}
function checkSameNetViaSpacing(circuitJson, {
  connMap,
  minSpacing = DEFAULT_SAME_NET_VIA_MARGIN
} = {}) {
  const vias = circuitJson.filter((el) => el.type === "pcb_via");
  if (vias.length < 2) return [];
  connMap ??= getFullConnectivityMapFromCircuitJson2(circuitJson);
  const errors = [];
  const reported = /* @__PURE__ */ new Set();
  for (let i = 0; i < vias.length; i++) {
    for (let j = i + 1; j < vias.length; j++) {
      const viaA = vias[i];
      const viaB = vias[j];
      if (!connMap.areIdsConnected(viaA.pcb_via_id, viaB.pcb_via_id)) continue;
      const gap = distance2(viaA, viaB) - viaA.outer_diameter / 2 - viaB.outer_diameter / 2;
      if (gap + EPSILON >= minSpacing) continue;
      const pairId = [viaA.pcb_via_id, viaB.pcb_via_id].sort().join("_");
      if (reported.has(pairId)) continue;
      reported.add(pairId);
      errors.push({
        type: "pcb_placement_error",
        pcb_placement_error_id: `same_net_vias_close_${pairId}`,
        message: `Vias ${getReadableNameForElement3(
          circuitJson,
          viaA.pcb_via_id
        )} and ${getReadableNameForElement3(
          circuitJson,
          viaB.pcb_via_id
        )} are too close together (gap: ${gap.toFixed(3)}mm)`,
        error_type: "pcb_placement_error"
      });
    }
  }
  return errors;
}

// lib/check-trace-spacing.ts
import { getReadableNameForElement as getReadableNameForElement4 } from "@tscircuit/circuit-json-util";
import { segmentToSegmentMinDistance as segmentToSegmentMinDistance2 } from "@tscircuit/math-utils";
function checkTraceSpacing(circuitJson, { minSpacing = DEFAULT_TRACE_MARGIN } = {}) {
  const traces = circuitJson.filter(
    (el) => el.type === "pcb_trace"
  );
  const segments = [];
  for (const trace of traces) {
    for (let i = 0; i < trace.route.length - 1; i++) {
      const a = trace.route[i];
      const b = trace.route[i + 1];
      if (a.route_type !== "wire" || b.route_type !== "wire") continue;
      if (a.layer !== b.layer) continue;
      const thickness = "width" in a ? a.width : "width" in b ? b.width : DEFAULT_TRACE_THICKNESS;
      segments.push({
        pcb_trace_id: trace.pcb_trace_id,
        layer: a.layer,
        thickness,
        x1: a.x,
        y1: a.y,
        x2: b.x,
        y2: b.y
      });
    }
  }
  const errors = [];
  for (let i = 0; i < segments.length; i++) {
    for (let j = i + 1; j < segments.length; j++) {
      const segA = segments[i];
      const segB = segments[j];
      if (segA.pcb_trace_id === segB.pcb_trace_id) continue;
      if (segA.layer !== segB.layer) continue;
      const distance4 = segmentToSegmentMinDistance2(
        { x: segA.x1, y: segA.y1 },
        { x: segA.x2, y: segA.y2 },
        { x: segB.x1, y: segB.y1 },
        { x: segB.x2, y: segB.y2 }
      );
      const gap = distance4 - segA.thickness / 2 - segB.thickness / 2;
      if (gap + EPSILON >= minSpacing) continue;
      errors.push({
        type: "pcb_trace_error",
        error_type: "pcb_trace_error",
        message: `PCB trace ${getReadableNameForElement4(
          circuitJson,
          segA.pcb_trace_id
        )} is too close to ${getReadableNameForElement4(
          circuitJson,
          segB.pcb_trace_id
        )} (gap: ${gap.toFixed(3)}mm)`,
        pcb_trace_id: segA.pcb_trace_id,
        pcb_trace_error_id: `trace_spacing_${segA.pcb_trace_id}_${segB.pcb_trace_id}`,
        source_trace_id: "",
        pcb_component_ids: [],
        pcb_port_ids: []
      });
    }
  }
  return errors;
}

// lib/check-pcb-components-out-of-board/checkPcbComponentsOutOfBoard.ts
function checkPcbComponentsOutOfBoard(circuitJson) {
  const board = circuitJson.find((el) => el.type === "pcb_board");
  if (!board) return [];
  const components = circuitJson.filter((el) => el.type === "pcb_component");
  const boardMinX = board.center.x - board.width / 2;
  const boardMaxX = board.center.x + board.width / 2;
  const boardMinY = board.center.y - board.height / 2;
  const boardMaxY = board.center.y + board.height / 2;
  const errors = [];
  for (const comp of components) {
    const minX = comp.center.x - comp.width / 2;
    const maxX = comp.center.x + comp.width / 2;
    const minY = comp.center.y - comp.height / 2;
    const maxY = comp.center.y + comp.height / 2;
    if (minX < boardMinX || maxX > boardMaxX || minY < boardMinY || maxY > boardMaxY) {
      const sourceComponent = circuitJson.find(
        (el) => el.type === "source_component" && el.source_component_id === comp.source_component_id
      );
      const componentType = (sourceComponent?.ftype || "unknown").replace(
        /^simple_/,
        ""
      );
      errors.push({
        type: "pcb_placement_error",
        pcb_placement_error_id: `out_of_board_${comp.pcb_component_id}`,
        message: `Component ${componentType}[${sourceComponent.name}] out of board`,
        error_type: "pcb_placement_error"
      });
    }
  }
  return errors;
}

// lib/check-traces-are-contiguous/is-point-in-pad.ts
function distance3(x1, y1, x2, y2) {
  return Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);
}
function isPointInPad(point, pad) {
  if (pad.type === "pcb_smtpad") {
    if (pad.shape === "circle") {
      return distance3(point.x, point.y, pad.x, pad.y) <= pad.radius;
    }
    if (pad.shape === "rect") {
      const halfWidth = pad.width / 2;
      const halfHeight = pad.height / 2;
      return Math.abs(point.x - pad.x) <= halfWidth && Math.abs(point.y - pad.y) <= halfHeight;
    }
    if (pad.shape === "rotated_rect") {
      const dx = point.x - pad.x;
      const dy = point.y - pad.y;
      const angle = -pad.ccw_rotation;
      const rotatedX = dx * Math.cos(angle) - dy * Math.sin(angle);
      const rotatedY = dx * Math.sin(angle) + dy * Math.cos(angle);
      return Math.abs(rotatedX) <= pad.width / 2 && Math.abs(rotatedY) <= pad.height / 2;
    }
    if (pad.shape === "pill") {
      const halfWidth = pad.width / 2;
      const halfHeight = pad.height / 2;
      const radius = pad.radius;
      if (Math.abs(point.x - pad.x) <= halfWidth - radius && Math.abs(point.y - pad.y) <= halfHeight) {
        return true;
      }
      const cornerX = Math.max(
        Math.abs(point.x - pad.x) - (halfWidth - radius),
        0
      );
      const cornerY = Math.max(
        Math.abs(point.y - pad.y) - (halfHeight - radius),
        0
      );
      return cornerX * cornerX + cornerY * cornerY <= radius * radius;
    }
  }
  if (pad.type === "pcb_plated_hole") {
    if (pad.shape === "circle") {
      return distance3(point.x, point.y, pad.x, pad.y) <= pad.outer_diameter / 2;
    }
    if (pad.shape === "oval" || pad.shape === "pill") {
      return Math.abs(point.x - pad.x) <= pad.outer_width / 2 && Math.abs(point.y - pad.y) <= pad.outer_height / 2;
    }
    if (pad.shape === "circular_hole_with_rect_pad") {
      return Math.abs(point.x - pad.x) <= pad.rect_pad_width / 2 && Math.abs(point.y - pad.y) <= pad.rect_pad_height / 2;
    }
    if (pad.shape === "pill_hole_with_rect_pad") {
      return Math.abs(point.x - pad.x) <= pad.rect_pad_width / 2 && Math.abs(point.y - pad.y) <= pad.rect_pad_height / 2;
    }
  }
  return false;
}

// lib/check-traces-are-contiguous/check-traces-are-contiguous.ts
import { getReadableNameForPcbPort as getReadableNameForPcbPort2 } from "@tscircuit/circuit-json-util";
function checkTracesAreContiguous(circuitJson) {
  const errors = [];
  const pcbPorts = circuitJson.filter(
    (el) => el.type === "pcb_port"
  );
  const pcbTraces = circuitJson.filter(
    (el) => el.type === "pcb_trace"
  );
  const sourceTraces = circuitJson.filter(
    (el) => el.type === "source_trace"
  );
  const pcbSmtPads = circuitJson.filter(
    (el) => el.type === "pcb_smtpad"
  );
  const pcbPlatedHoles = circuitJson.filter(
    (el) => el.type === "pcb_plated_hole"
  );
  const padMap = /* @__PURE__ */ new Map();
  for (const pad of pcbSmtPads) {
    if (pad.pcb_port_id) {
      padMap.set(pad.pcb_port_id, pad);
    }
  }
  for (const hole of pcbPlatedHoles) {
    if (hole.pcb_port_id) {
      padMap.set(hole.pcb_port_id, hole);
    }
  }
  for (const trace of pcbTraces) {
    if (trace.route.length === 0) continue;
    const firstPoint = trace.route[0];
    const lastPoint = trace.route[trace.route.length - 1];
    const sourceTrace = sourceTraces.find(
      (st) => st.source_trace_id === trace.source_trace_id
    );
    if (!sourceTrace) continue;
    const expectedPorts = pcbPorts.filter(
      (port) => sourceTrace.connected_source_port_ids?.includes(port.source_port_id)
    );
    for (let i = 1; i < trace.route.length - 1; i++) {
      const prevPoint = trace.route[i - 1];
      const currentPoint = trace.route[i];
      const nextPoint = trace.route[i + 1];
      if (currentPoint.route_type === "via") {
        const prevIsWire = prevPoint.route_type === "wire";
        const nextIsWire = nextPoint.route_type === "wire";
        if (prevIsWire && nextIsWire) {
          const prevAligned = Math.abs(prevPoint.x - currentPoint.x) < 1e-3 && Math.abs(prevPoint.y - currentPoint.y) < 1e-3;
          const nextAligned = Math.abs(nextPoint.x - currentPoint.x) < 1e-3 && Math.abs(nextPoint.y - currentPoint.y) < 1e-3;
          if (!prevAligned || !nextAligned) {
            const traceName = sourceTrace.display_name;
            errors.push({
              type: "pcb_trace_error",
              message: `Via in trace [${traceName}] is misaligned at position {x: ${currentPoint.x}, y: ${currentPoint.y}}.`,
              source_trace_id: sourceTrace.source_trace_id,
              error_type: "pcb_trace_error",
              pcb_trace_id: trace.pcb_trace_id,
              pcb_trace_error_id: "",
              pcb_component_ids: [],
              pcb_port_ids: []
            });
          }
        }
      }
    }
    for (const port of expectedPorts) {
      if (!port.pcb_port_id) continue;
      const pad = padMap.get(port.pcb_port_id);
      if (!pad) continue;
      const isFirstPointConnected = firstPoint.route_type === "wire" && isPointInPad({ x: firstPoint.x, y: firstPoint.y }, pad);
      const isLastPointConnected = lastPoint.route_type === "wire" && isPointInPad({ x: lastPoint.x, y: lastPoint.y }, pad);
      if (!isFirstPointConnected && !isLastPointConnected) {
        const traceName = sourceTrace.display_name;
        const portName = getReadableNameForPcbPort2(
          circuitJson,
          port.pcb_port_id
        ).replace("pcb_port", "");
        const padType = pad.type.replace(/pcb_/, "");
        errors.push({
          type: "pcb_trace_error",
          message: `Trace [${traceName}] is missing a connection to ${padType}${portName}`,
          source_trace_id: sourceTrace.source_trace_id,
          error_type: "pcb_trace_error",
          pcb_trace_id: trace.pcb_trace_id,
          pcb_trace_error_id: "",
          pcb_component_ids: [],
          pcb_port_ids: [port.pcb_port_id]
        });
      }
    }
  }
  return errors;
}

// lib/run-all-checks.ts
async function runAllChecks(circuitJson) {
  return [
    ...checkEachPcbPortConnected(circuitJson),
    ...checkEachPcbTraceNonOverlapping(circuitJson),
    ...checkSameNetViaSpacing(circuitJson),
    ...checkViasOffBoard(circuitJson),
    ...checkPcbComponentsOutOfBoard(circuitJson),
    ...checkTracesAreContiguous(circuitJson)
  ];
}
export {
  NetManager,
  checkEachPcbPortConnected,
  checkEachPcbTraceNonOverlapping,
  checkSameNetViaSpacing,
  checkTraceSpacing,
  checkViasOffBoard,
  runAllChecks
};
//# sourceMappingURL=index.js.map