{"version":3,"sources":["../lib/add-start-and-end-port-ids-if-missing.ts","../lib/check-each-pcb-port-connected.ts","../lib/check-each-pcb-trace-non-overlapping/check-each-pcb-trace-non-overlapping.ts","../lib/data-structures/SpatialIndex.ts","../lib/check-each-pcb-trace-non-overlapping/getCollidableBounds.ts","../lib/drc-defaults.ts","../lib/check-each-pcb-trace-non-overlapping/getPcbPortIdsConnectedToTraces.ts","../lib/check-each-pcb-trace-non-overlapping/getClosestPointBetweenSegments.ts","../lib/check-each-pcb-trace-non-overlapping/getRadiusOfCircuitJsonElement.ts","../lib/check-each-pcb-trace-non-overlapping/getClosestPointBetweenSegmentAndBounds.ts","../lib/util/getLayersOfPcbElement.ts","../lib/net-manager.ts","../lib/check-pcb-components-out-of-board/checkViasOffBoard.ts","../lib/check-same-net-via-spacing.ts","../lib/check-trace-spacing.ts","../lib/check-pcb-components-out-of-board/checkPcbComponentsOutOfBoard.ts","../lib/check-traces-are-contiguous/is-point-in-pad.ts","../lib/check-traces-are-contiguous/check-traces-are-contiguous.ts","../lib/run-all-checks.ts"],"sourcesContent":["import type {\n  PcbPort,\n  PcbTrace,\n  AnyCircuitElement,\n  PcbSmtPad,\n} from \"circuit-json\"\n\nfunction distance(x1: number, y1: number, x2: number, y2: number): number {\n  return Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2)\n}\n\n/**\n * HACK: this whole method and all usage of it is a hack because of this issue:\n * https://github.com/tscircuit/tscircuit/issues/291\n */\nexport const addStartAndEndPortIdsIfMissing = (\n  soup: AnyCircuitElement[],\n): void => {\n  const pcbPorts: PcbPort[] = soup.filter((item) => item.type === \"pcb_port\")\n  const pcbSmtPads: PcbSmtPad[] = soup.filter(\n    (item) => item.type === \"pcb_smtpad\",\n  )\n  const pcbTraces: PcbTrace[] = soup.filter((item) => item.type === \"pcb_trace\")\n\n  function findPortIdOverlappingPoint(\n    point: {\n      x: number\n      y: number\n    },\n    options: { isFirstOrLastPoint?: boolean; traceWidth?: number } = {},\n  ): string | null {\n    const traceWidth = options.traceWidth || 0\n    const directPort = pcbPorts.find(\n      (port) => distance(port.x, port.y, point.x, point.y) < 0.01,\n    )\n    if (directPort) return directPort.pcb_port_id\n\n    // If it starts or ends inside an smtpad, we'll connect it to the por\n    if (options.isFirstOrLastPoint) {\n      const smtPad = pcbSmtPads.find((pad) => {\n        if (pad.shape === \"rect\") {\n          return (\n            Math.abs(point.x - pad.x) < pad.width / 2 + traceWidth / 2 &&\n            Math.abs(point.y - pad.y) < pad.height / 2 + traceWidth / 2\n          )\n          // biome-ignore lint/style/noUselessElse: <explanation>\n        } else if (pad.shape === \"circle\") {\n          return distance(point.x, point.y, pad.x, pad.y) < pad.radius\n        }\n      })\n      if (smtPad) return smtPad.pcb_port_id ?? null\n    }\n\n    return null\n  }\n\n  // Add start_pcb_port_id and end_pcb_port_id if not present\n  for (const trace of pcbTraces) {\n    for (let index = 0; index < trace.route.length; index++) {\n      const segment = trace.route[index]\n      const isFirstOrLastPoint = index === 0 || index === trace.route.length - 1\n      if (segment.route_type === \"wire\") {\n        if (!segment.start_pcb_port_id && index === 0) {\n          const startPortId = findPortIdOverlappingPoint(segment, {\n            isFirstOrLastPoint,\n            traceWidth: segment.width,\n          })\n          if (startPortId) {\n            segment.start_pcb_port_id = startPortId\n          }\n        }\n        if (!segment.end_pcb_port_id && index === trace.route.length - 1) {\n          const endPortId = findPortIdOverlappingPoint(segment, {\n            isFirstOrLastPoint,\n            traceWidth: segment.width,\n          })\n          if (endPortId) {\n            segment.end_pcb_port_id = endPortId\n          }\n        }\n      }\n    }\n  }\n}\n","import type {\n  PcbPort,\n  PcbTrace,\n  SourceTrace,\n  AnyCircuitElement,\n  PcbTraceError,\n} from \"circuit-json\"\nimport { addStartAndEndPortIdsIfMissing } from \"./add-start-and-end-port-ids-if-missing\"\nimport { getReadableNameForPcbPort } from \"@tscircuit/circuit-json-util\"\n\nfunction checkEachPcbPortConnected(soup: AnyCircuitElement[]): PcbTraceError[] {\n  addStartAndEndPortIdsIfMissing(soup)\n  const pcbPorts: PcbPort[] = soup.filter((item) => item.type === \"pcb_port\")\n  const pcbTraces: PcbTrace[] = soup.filter((item) => item.type === \"pcb_trace\")\n  const sourceTraces: SourceTrace[] = soup.filter(\n    (item) => item.type === \"source_trace\",\n  )\n  const errors: PcbTraceError[] = []\n\n  for (const port of pcbPorts) {\n    const connectedTraces = pcbTraces.filter((trace) =>\n      trace.route.some(\n        (segment: any) =>\n          segment.route_type === \"wire\" &&\n          (segment.start_pcb_port_id === port.pcb_port_id ||\n            segment.end_pcb_port_id === port.pcb_port_id),\n      ),\n    )\n\n    const sourceTrace = sourceTraces.find((trace) =>\n      trace.connected_source_port_ids?.includes(port.source_port_id),\n    )\n\n    const hasSourceTraceWithConnections =\n      sourceTrace && sourceTrace.connected_source_port_ids?.length > 0\n\n    if (connectedTraces.length === 0 && hasSourceTraceWithConnections) {\n      errors.push({\n        type: \"pcb_trace_error\",\n        message: `pcb_trace_error: PCB port ${getReadableNameForPcbPort(soup, port.pcb_port_id)} is not connected by a PCB trace`,\n        source_trace_id: sourceTrace.source_trace_id,\n        error_type: \"pcb_trace_error\",\n        pcb_trace_id: \"\",\n        pcb_trace_error_id: \"\",\n        pcb_component_ids: [],\n        pcb_port_ids: [port.pcb_port_id],\n      })\n    }\n  }\n\n  return errors\n}\n\nexport { checkEachPcbPortConnected }\n","import type { AnyCircuitElement, PcbTraceError } from \"circuit-json\"\nimport { getReadableNameForElement, cju } from \"@tscircuit/circuit-json-util\"\nimport {\n  SpatialObjectIndex,\n  type Bounds,\n} from \"lib/data-structures/SpatialIndex\"\nimport {\n  getFullConnectivityMapFromCircuitJson,\n  type ConnectivityMap,\n} from \"circuit-json-to-connectivity-map\"\nimport {\n  getCollidableBounds,\n  type Collidable,\n  type PcbTraceSegment,\n} from \"./getCollidableBounds\"\nimport {\n  segmentToBoundsMinDistance,\n  segmentToCircleMinDistance,\n} from \"@tscircuit/math-utils\"\nimport {\n  DEFAULT_TRACE_MARGIN,\n  DEFAULT_TRACE_THICKNESS,\n  EPSILON,\n} from \"lib/drc-defaults\"\nimport { getPcbPortIdsConnectedToTraces } from \"./getPcbPortIdsConnectedToTraces\"\nimport { segmentToSegmentMinDistance } from \"@tscircuit/math-utils\"\nimport { areBoundsOverlapping } from \"./areBoundsOverlapping\"\nimport { getPrimaryId } from \"@tscircuit/circuit-json-util\"\nimport { getCenterOfBoundsPair } from \"./getCenterOfBoundsPair\"\nimport { getClosestPointBetweenSegments } from \"./getClosestPointBetweenSegments\"\nimport { getCenterOfBounds } from \"./getCenterOfBounds\"\nimport { getRadiusOfCircuitJsonElement } from \"./getRadiusOfCircuitJsonElement\"\nimport { getClosestPointBetweenSegmentAndBounds } from \"./getClosestPointBetweenSegmentAndBounds\"\nimport { getLayersOfPcbElement } from \"../util/getLayersOfPcbElement\"\n\nexport function checkEachPcbTraceNonOverlapping(\n  circuitJson: AnyCircuitElement[],\n  {\n    connMap,\n  }: {\n    connMap?: ConnectivityMap\n  } = {},\n): PcbTraceError[] {\n  const errors: PcbTraceError[] = []\n  connMap ??= getFullConnectivityMapFromCircuitJson(circuitJson)\n\n  const pcbTraces = cju(circuitJson).pcb_trace.list()\n  const pcbTraceSegments = pcbTraces.flatMap((pcbTrace) => {\n    const segments: PcbTraceSegment[] = []\n    for (let i = 0; i < pcbTrace.route.length - 1; i++) {\n      const p1 = pcbTrace.route[i]\n      const p2 = pcbTrace.route[i + 1]\n      if (p1.route_type !== \"wire\") continue\n      if (p2.route_type !== \"wire\") continue\n      if (p1.layer !== p2.layer) continue\n      segments.push({\n        type: \"pcb_trace_segment\",\n        pcb_trace_id: pcbTrace.pcb_trace_id,\n        _pcbTrace: pcbTrace,\n        thickness:\n          \"width\" in p1\n            ? p1.width\n            : \"width\" in p2\n              ? p2.width\n              : DEFAULT_TRACE_THICKNESS,\n        layer: p1.layer,\n        x1: p1.x,\n        y1: p1.y,\n        x2: p2.x,\n        y2: p2.y,\n      } as PcbTraceSegment)\n    }\n    return segments\n  })\n  const pcbSmtPads = cju(circuitJson).pcb_smtpad.list()\n  const pcbPlatedHoles = cju(circuitJson).pcb_plated_hole.list()\n  const pcbHoles = cju(circuitJson).pcb_hole.list()\n  const pcbVias = cju(circuitJson).pcb_via.list()\n  const pcbKeepouts = cju(circuitJson).pcb_keepout.list()\n\n  const allObjects: Collidable[] = [\n    ...pcbTraceSegments,\n    ...pcbSmtPads,\n    ...pcbPlatedHoles,\n    ...pcbHoles,\n    ...pcbVias,\n    ...pcbKeepouts,\n  ]\n\n  const spatialIndex = new SpatialObjectIndex<Collidable>({\n    objects: allObjects,\n    getBounds: getCollidableBounds,\n  })\n\n  const getReadableName = (id: string) =>\n    getReadableNameForElement(circuitJson, id)\n\n  const errorIds = new Set<string>()\n\n  // For each segment, check it if overlaps with anything collidable\n  for (const segmentA of pcbTraceSegments) {\n    const requiredMargin = DEFAULT_TRACE_MARGIN\n    const bounds = getCollidableBounds(segmentA)\n    const nearbyObjects = spatialIndex.getObjectsInBounds(\n      bounds,\n      requiredMargin + segmentA.thickness / 2,\n    )\n    if (segmentA.x1 === segmentA.x2 && segmentA.y1 === segmentA.y2) continue\n\n    for (const obj of nearbyObjects) {\n      // ignore obstacles not on the trace's layer (except vias)\n      if (!getLayersOfPcbElement(obj).includes(segmentA.layer)) {\n        continue\n      }\n      if (obj.type === \"pcb_trace_segment\") {\n        const segmentB = obj\n\n        if (segmentA.layer !== segmentB.layer) continue\n\n        // Check if the segments are overlapping\n        if (\n          connMap.areIdsConnected(segmentA.pcb_trace_id, segmentB.pcb_trace_id)\n        )\n          continue\n\n        const gap =\n          segmentToSegmentMinDistance(\n            { x: segmentA.x1, y: segmentA.y1 },\n            { x: segmentA.x2, y: segmentA.y2 },\n            { x: segmentB.x1, y: segmentB.y1 },\n            { x: segmentB.x2, y: segmentB.y2 },\n          ) -\n          segmentA.thickness / 2 -\n          segmentB.thickness / 2\n        if (gap > DEFAULT_TRACE_MARGIN - EPSILON) continue\n\n        const pcb_trace_error_id = `overlap_${segmentA.pcb_trace_id}_${segmentB.pcb_trace_id}`\n        const pcb_trace_error_id_reverse = `overlap_${segmentB.pcb_trace_id}_${segmentA.pcb_trace_id}`\n        if (errorIds.has(pcb_trace_error_id)) continue\n        if (errorIds.has(pcb_trace_error_id_reverse)) continue\n\n        errorIds.add(pcb_trace_error_id)\n        errors.push({\n          type: \"pcb_trace_error\",\n          error_type: \"pcb_trace_error\",\n          message: `PCB trace ${getReadableName(segmentA.pcb_trace_id)} overlaps with ${getReadableName(segmentB.pcb_trace_id)} ${gap < 0 ? \"(accidental contact)\" : `(gap: ${gap.toFixed(3)}mm)`}`,\n          pcb_trace_id: segmentA.pcb_trace_id,\n          source_trace_id: \"\",\n          pcb_trace_error_id,\n          pcb_component_ids: [],\n          center: getClosestPointBetweenSegments(segmentA, segmentB),\n          pcb_port_ids: getPcbPortIdsConnectedToTraces([\n            segmentA._pcbTrace,\n            segmentB._pcbTrace,\n          ]),\n        })\n        continue\n      }\n\n      const primaryObjId = getPrimaryId(obj as any)\n      if (\n        connMap.areIdsConnected(\n          segmentA.pcb_trace_id,\n          \"pcb_trace_id\" in obj ? (obj.pcb_trace_id as string) : primaryObjId,\n        )\n      )\n        continue\n\n      const isCircular =\n        obj.type === \"pcb_via\" ||\n        (obj.type === \"pcb_plated_hole\" && obj.shape === \"circle\") ||\n        obj.type === \"pcb_hole\" ||\n        (obj.type === \"pcb_smtpad\" && obj.shape === \"circle\")\n\n      if (isCircular) {\n        const radius = getRadiusOfCircuitJsonElement(obj)\n        const distance = segmentToCircleMinDistance(\n          { x: segmentA.x1, y: segmentA.y1 },\n          { x: segmentA.x2, y: segmentA.y2 },\n          { x: obj.x, y: obj.y, radius },\n        )\n        const gap = distance - segmentA.thickness / 2\n        if (gap > DEFAULT_TRACE_MARGIN - EPSILON) continue\n\n        const pcb_trace_error_id = `overlap_${segmentA.pcb_trace_id}_${primaryObjId}`\n        if (errorIds.has(pcb_trace_error_id)) continue\n        errorIds.add(pcb_trace_error_id)\n        errors.push({\n          type: \"pcb_trace_error\",\n          error_type: \"pcb_trace_error\",\n          message: `PCB trace ${getReadableName(segmentA.pcb_trace_id)} overlaps with ${obj.type} \"${getReadableName(getPrimaryId(obj as any))}\" ${gap < 0 ? \"(accidental contact)\" : `(gap: ${gap.toFixed(3)}mm)`}`,\n          pcb_trace_id: segmentA.pcb_trace_id,\n          center: getClosestPointBetweenSegmentAndBounds(\n            segmentA,\n            getCollidableBounds(obj),\n          ),\n          source_trace_id: \"\",\n          pcb_trace_error_id,\n          pcb_component_ids: [\n            \"pcb_component_id\" in obj\n              ? (obj.pcb_component_id as string)\n              : undefined,\n          ].filter(Boolean) as string[],\n          pcb_port_ids: [\n            ...getPcbPortIdsConnectedToTraces([segmentA._pcbTrace]),\n            \"pcb_port_id\" in obj ? obj.pcb_port_id : undefined,\n          ].filter(Boolean) as string[],\n        })\n      }\n\n      // Handle generic case of hitting the bounds of any collidable obstacle\n      // using the bounds of the collidable obstacle\n      const gap =\n        segmentToBoundsMinDistance(\n          { x: segmentA.x1, y: segmentA.y1 },\n          { x: segmentA.x2, y: segmentA.y2 },\n          getCollidableBounds(obj),\n        ) -\n        segmentA.thickness / 2\n      if (gap + EPSILON < requiredMargin) {\n        const pcb_trace_error_id = `overlap_${segmentA.pcb_trace_id}_${primaryObjId}`\n        if (errorIds.has(pcb_trace_error_id)) continue\n        errorIds.add(pcb_trace_error_id)\n        errors.push({\n          type: \"pcb_trace_error\",\n          error_type: \"pcb_trace_error\",\n          message: `PCB trace ${getReadableName(segmentA.pcb_trace_id)} overlaps with ${obj.type} \"${getReadableName(getPrimaryId(obj as any))}\" ${gap < 0 ? \"(accidental contact)\" : `(gap: ${gap.toFixed(3)}mm)`}`,\n          pcb_trace_id: segmentA.pcb_trace_id,\n          source_trace_id: \"\",\n          pcb_trace_error_id,\n          pcb_component_ids: [\n            \"pcb_component_id\" in obj ? obj.pcb_component_id : undefined,\n          ].filter(Boolean) as string[],\n          center: getClosestPointBetweenSegmentAndBounds(\n            segmentA,\n            getCollidableBounds(obj),\n          ),\n          pcb_port_ids: [\n            ...getPcbPortIdsConnectedToTraces([segmentA._pcbTrace]),\n            \"pcb_port_id\" in obj ? obj.pcb_port_id : undefined,\n          ].filter(Boolean) as string[],\n        })\n      }\n    }\n  }\n  return errors\n}\n","export type BucketCoordinate = `${number}x${number}`\n\nexport interface Bounds {\n  minX: number\n  minY: number\n  maxX: number\n  maxY: number\n}\n\nexport type GetBoundsFn<T> = (obj: T) => Bounds\nexport type GetIdFn<T> = (obj: T) => string\n\nexport class SpatialObjectIndex<T> {\n  buckets: Map<BucketCoordinate, Array<T & { spatialIndexId: string }>>\n  objectsById: Map<string, T & { spatialIndexId: string }>\n  getBounds: GetBoundsFn<T>\n  getId: GetIdFn<T>\n  CELL_SIZE = 0.4\n\n  constructor({\n    objects,\n    getBounds,\n    getId,\n    CELL_SIZE,\n  }: {\n    objects: T[]\n    getBounds: GetBoundsFn<T>\n    getId?: GetIdFn<T>\n    CELL_SIZE?: number\n  }) {\n    this.buckets = new Map()\n    this.objectsById = new Map()\n    this.getBounds = getBounds\n    this.getId = getId ?? (() => this._getNextId())\n    this.CELL_SIZE = CELL_SIZE ?? this.CELL_SIZE\n\n    for (const obj of objects) {\n      this.addObject(obj)\n    }\n  }\n\n  _idCounter = 0\n  _getNextId(): string {\n    return `${this._idCounter++}`\n  }\n\n  addObject(obj: T): void {\n    const bounds = this.getBounds(obj)\n    const spatialIndexId = this.getId(obj)\n    const objWithId = { ...obj, spatialIndexId } as T & {\n      spatialIndexId: string\n    }\n\n    // Store in objectsById for quick lookup\n    this.objectsById.set(spatialIndexId, objWithId)\n\n    // Calculate the bucket coordinates that cover the object's bounds\n    const minBucketX = Math.floor(bounds.minX / this.CELL_SIZE)\n    const minBucketY = Math.floor(bounds.minY / this.CELL_SIZE)\n    const maxBucketX = Math.floor(bounds.maxX / this.CELL_SIZE)\n    const maxBucketY = Math.floor(bounds.maxY / this.CELL_SIZE)\n\n    // Add the object to all buckets it intersects with\n    for (let bx = minBucketX; bx <= maxBucketX; bx++) {\n      for (let by = minBucketY; by <= maxBucketY; by++) {\n        const bucketKey = `${bx}x${by}` as BucketCoordinate\n        const bucket = this.buckets.get(bucketKey)\n        if (!bucket) {\n          this.buckets.set(bucketKey, [objWithId])\n        } else {\n          bucket.push(objWithId)\n        }\n      }\n    }\n  }\n\n  removeObject(id: string): boolean {\n    const obj = this.objectsById.get(id)\n    if (!obj) return false\n\n    // Remove from objectsById\n    this.objectsById.delete(id)\n\n    // Calculate the bucket coordinates that cover the object's bounds\n    const bounds = this.getBounds(obj)\n    const minBucketX = Math.floor(bounds.minX / this.CELL_SIZE)\n    const minBucketY = Math.floor(bounds.minY / this.CELL_SIZE)\n    const maxBucketX = Math.floor(bounds.maxX / this.CELL_SIZE)\n    const maxBucketY = Math.floor(bounds.maxY / this.CELL_SIZE)\n\n    // Remove the object from all buckets it might be in\n    for (let bx = minBucketX; bx <= maxBucketX; bx++) {\n      for (let by = minBucketY; by <= maxBucketY; by++) {\n        const bucketKey = `${bx}x${by}` as BucketCoordinate\n        const bucket = this.buckets.get(bucketKey)\n        if (bucket) {\n          const index = bucket.findIndex((item) => item.spatialIndexId === id)\n          if (index !== -1) {\n            bucket.splice(index, 1)\n            if (bucket.length === 0) {\n              this.buckets.delete(bucketKey)\n            }\n          }\n        }\n      }\n    }\n\n    return true\n  }\n\n  getBucketKey(x: number, y: number): BucketCoordinate {\n    return `${Math.floor(x / this.CELL_SIZE)}x${Math.floor(y / this.CELL_SIZE)}`\n  }\n\n  getObjectsInBounds(bounds: Bounds, margin = 0): T[] {\n    const objects: T[] = []\n    const addedIds = new Set<string>()\n\n    // Calculate the bucket coordinates that cover the requested bounds with margin\n    const minBucketX = Math.floor((bounds.minX - margin) / this.CELL_SIZE)\n    const minBucketY = Math.floor((bounds.minY - margin) / this.CELL_SIZE)\n    const maxBucketX = Math.floor((bounds.maxX + margin) / this.CELL_SIZE)\n    const maxBucketY = Math.floor((bounds.maxY + margin) / this.CELL_SIZE)\n\n    // Collect objects from all buckets that intersect the bounds\n    for (let bx = minBucketX; bx <= maxBucketX; bx++) {\n      for (let by = minBucketY; by <= maxBucketY; by++) {\n        const bucketKey = `${bx}x${by}` as BucketCoordinate\n        const bucket = this.buckets.get(bucketKey) || []\n\n        for (const obj of bucket) {\n          const id = obj.spatialIndexId\n          if (addedIds.has(id)) continue\n\n          addedIds.add(id)\n          objects.push(obj)\n        }\n      }\n    }\n\n    return objects\n  }\n}\n","import { getBoundsOfPcbElements } from \"@tscircuit/circuit-json-util\"\nimport type {\n  AnyCircuitElement,\n  PcbHole,\n  PCBKeepout,\n  PcbPlatedHole,\n  PcbSmtPad,\n  PcbTrace,\n  PcbTraceError,\n  PcbVia,\n} from \"circuit-json\"\n\ninterface Bounds {\n  minX: number\n  minY: number\n  maxX: number\n  maxY: number\n}\n\nexport type PcbTraceSegment = {\n  type: \"pcb_trace_segment\"\n  _pcbTrace: PcbTrace\n  pcb_trace_id: string\n  thickness: number\n  layer: string\n  x1: number\n  y1: number\n  x2: number\n  y2: number\n}\n\nexport type Collidable =\n  | PcbTraceSegment\n  | PcbSmtPad\n  | PcbPlatedHole\n  | PcbHole\n  | PcbVia\n  | PCBKeepout\n\nexport const getCollidableBounds = (collidable: Collidable): Bounds => {\n  if (collidable.type === \"pcb_trace_segment\") {\n    return {\n      minX: Math.min(collidable.x1, collidable.x2),\n      minY: Math.min(collidable.y1, collidable.y2),\n      maxX: Math.max(collidable.x1, collidable.x2),\n      maxY: Math.max(collidable.y1, collidable.y2),\n    }\n  }\n  return getBoundsOfPcbElements([collidable as any])\n}\n","export const DEFAULT_TRACE_MARGIN = 0.1\nexport const DEFAULT_TRACE_THICKNESS = 0.15\nexport const DEFAULT_VIA_DIAMETER = 0.6\nexport const DEFAULT_VIA_BOARD_MARGIN = 0.3\n\nexport const DEFAULT_SAME_NET_VIA_MARGIN = 0.2\n\nexport const EPSILON = 0.005\n","import type { PcbTrace } from \"circuit-json\"\n\nexport function getPcbPortIdsConnectedToTrace(trace: PcbTrace) {\n  const connectedPcbPorts = new Set<string>()\n  for (const segment of trace.route) {\n    if (segment.route_type === \"wire\") {\n      if (segment.start_pcb_port_id)\n        connectedPcbPorts.add(segment.start_pcb_port_id)\n      if (segment.end_pcb_port_id)\n        connectedPcbPorts.add(segment.end_pcb_port_id)\n    }\n  }\n\n  return Array.from(connectedPcbPorts)\n}\n\nexport function getPcbPortIdsConnectedToTraces(traces: PcbTrace[]) {\n  const connectedPorts = new Set<string>()\n  for (const trace of traces) {\n    for (const portId of getPcbPortIdsConnectedToTrace(trace)) {\n      connectedPorts.add(portId)\n    }\n  }\n  return Array.from(connectedPorts)\n}\n","import type { PcbTraceSegment } from \"./getCollidableBounds\"\n\nexport const getClosestPointBetweenSegments = (\n  segmentA: PcbTraceSegment,\n  segmentB: PcbTraceSegment,\n): { x: number; y: number } => {\n  // Define points for each segment\n  const a1 = { x: segmentA.x1, y: segmentA.y1 }\n  const a2 = { x: segmentA.x2, y: segmentA.y2 }\n  const b1 = { x: segmentB.x1, y: segmentB.y1 }\n  const b2 = { x: segmentB.x2, y: segmentB.y2 }\n\n  // Calculate direction vectors for each segment\n  const va = { x: a2.x - a1.x, y: a2.y - a1.y }\n  const vb = { x: b2.x - b1.x, y: b2.y - b1.y }\n\n  // Calculate squared lengths of segments\n  const lenSqrA = va.x * va.x + va.y * va.y\n  const lenSqrB = vb.x * vb.x + vb.y * vb.y\n\n  // If either segment is a point (zero length), handle as special case\n  if (lenSqrA === 0 || lenSqrB === 0) {\n    if (lenSqrA === 0 && lenSqrB === 0) {\n      // Both segments are points, return the distance between them\n      // Calculate the average point\n      return {\n        x: (a1.x + b1.x) / 2,\n        y: (a1.y + b1.y) / 2,\n      }\n    }\n    if (lenSqrA === 0) {\n      // First segment is a point, find closest point on second segment\n      const t = clamp(\n        ((a1.x - b1.x) * vb.x + (a1.y - b1.y) * vb.y) / lenSqrB,\n        0,\n        1,\n      )\n      const closestOnB = {\n        x: b1.x + t * vb.x,\n        y: b1.y + t * vb.y,\n      }\n      // Calculate the average point\n      return {\n        x: (a1.x + closestOnB.x) / 2,\n        y: (a1.y + closestOnB.y) / 2,\n      }\n    }\n    // Second segment is a point, find closest point on first segment\n    const t = clamp(\n      ((b1.x - a1.x) * va.x + (b1.y - a1.y) * va.y) / lenSqrA,\n      0,\n      1,\n    )\n    const closestOnA = {\n      x: a1.x + t * va.x,\n      y: a1.y + t * va.y,\n    }\n    // Calculate the average point\n    return {\n      x: (closestOnA.x + b1.x) / 2,\n      y: (closestOnA.y + b1.y) / 2,\n    }\n  }\n\n  // Vector between segment starting points\n  const w = { x: a1.x - b1.x, y: a1.y - b1.y }\n\n  // Calculate dot products\n  const dotAA = va.x * va.x + va.y * va.y\n  const dotAB = va.x * vb.x + va.y * vb.y\n  const dotAW = va.x * w.x + va.y * w.y\n  const dotBB = vb.x * vb.x + vb.y * vb.y\n  const dotBW = vb.x * w.x + vb.y * w.y\n\n  // Calculate parametric positions (t values) along each segment\n  const denominator = dotAA * dotBB - dotAB * dotAB\n\n  // If segments are parallel, handle separately\n  if (denominator < 1e-10) {\n    return closestPointsParallelSegments(\n      a1,\n      a2,\n      b1,\n      b2,\n      va,\n      vb,\n      lenSqrA,\n      lenSqrB,\n    )\n  }\n\n  // Calculate parameters for closest points\n  let tA = (dotAB * dotBW - dotBB * dotAW) / denominator\n  let tB = (dotAA * dotBW - dotAB * dotAW) / denominator\n\n  // Clamp parameters to segment bounds\n  tA = clamp(tA, 0, 1)\n  tB = clamp(tB, 0, 1)\n\n  // Recalculate tB if tA was clamped\n  tB = (tA * dotAB + dotBW) / dotBB\n  tB = clamp(tB, 0, 1)\n\n  // Recalculate tA if tB was clamped\n  tA = (tB * dotAB - dotAW) / dotAA\n  tA = clamp(tA, 0, 1)\n\n  // Calculate closest points on each segment\n  const closestOnA = {\n    x: a1.x + tA * va.x,\n    y: a1.y + tA * va.y,\n  }\n\n  const closestOnB = {\n    x: b1.x + tB * vb.x,\n    y: b1.y + tB * vb.y,\n  }\n\n  // Calculate distance between closest points\n  const dx = closestOnA.x - closestOnB.x\n  const dy = closestOnA.y - closestOnB.y\n  const distance = Math.sqrt(dx * dx + dy * dy)\n\n  // Calculate the average of the closest points\n  const averagePoint = {\n    x: (closestOnA.x + closestOnB.x) / 2,\n    y: (closestOnA.y + closestOnB.y) / 2,\n  }\n\n  return averagePoint\n}\n\n// Helper function for handling parallel segments\nconst closestPointsParallelSegments = (\n  a1: { x: number; y: number },\n  a2: { x: number; y: number },\n  b1: { x: number; y: number },\n  b2: { x: number; y: number },\n  va: { x: number; y: number },\n  vb: { x: number; y: number },\n  lenSqrA: number,\n  lenSqrB: number,\n) => {\n  // Project b1 onto segment A\n  let tA = ((b1.x - a1.x) * va.x + (b1.y - a1.y) * va.y) / lenSqrA\n  tA = clamp(tA, 0, 1)\n  const pointOnA1 = { x: a1.x + tA * va.x, y: a1.y + tA * va.y }\n\n  // Project b2 onto segment A\n  let tA2 = ((b2.x - a1.x) * va.x + (b2.y - a1.y) * va.y) / lenSqrA\n  tA2 = clamp(tA2, 0, 1)\n  const pointOnA2 = { x: a1.x + tA2 * va.x, y: a1.y + tA2 * va.y }\n\n  // Project a1 onto segment B\n  let tB = ((a1.x - b1.x) * vb.x + (a1.y - b1.y) * vb.y) / lenSqrB\n  tB = clamp(tB, 0, 1)\n  const pointOnB1 = { x: b1.x + tB * vb.x, y: b1.y + tB * vb.y }\n\n  // Project a2 onto segment B\n  let tB2 = ((a2.x - b1.x) * vb.x + (a2.y - b1.y) * vb.y) / lenSqrB\n  tB2 = clamp(tB2, 0, 1)\n  const pointOnB2 = { x: b1.x + tB2 * vb.x, y: b1.y + tB2 * vb.y }\n\n  // Calculate all possible distances between end points and their projections\n  const distances = [\n    {\n      pointA: pointOnA1,\n      pointB: b1,\n      distance: Math.sqrt(\n        (pointOnA1.x - b1.x) ** 2 + (pointOnA1.y - b1.y) ** 2,\n      ),\n    },\n    {\n      pointA: pointOnA2,\n      pointB: b2,\n      distance: Math.sqrt(\n        (pointOnA2.x - b2.x) ** 2 + (pointOnA2.y - b2.y) ** 2,\n      ),\n    },\n    {\n      pointA: a1,\n      pointB: pointOnB1,\n      distance: Math.sqrt(\n        (a1.x - pointOnB1.x) ** 2 + (a1.y - pointOnB1.y) ** 2,\n      ),\n    },\n    {\n      pointA: a2,\n      pointB: pointOnB2,\n      distance: Math.sqrt(\n        (a2.x - pointOnB2.x) ** 2 + (a2.y - pointOnB2.y) ** 2,\n      ),\n    },\n  ]\n\n  // Find closest pair\n  const closestPair = distances.reduce((closest, current) =>\n    current.distance < closest.distance ? current : closest,\n  )\n\n  // Calculate the average of the closest points\n  return {\n    x: (closestPair.pointA.x + closestPair.pointB.x) / 2,\n    y: (closestPair.pointA.y + closestPair.pointB.y) / 2,\n  }\n}\n\n// Helper function to clamp a value between min and max\nconst clamp = (value: number, min: number, max: number): number => {\n  return Math.max(min, Math.min(max, value))\n}\n","import type {\n  AnyCircuitElement,\n  PcbHole,\n  PcbPlatedHole,\n  PcbVia,\n  PcbSmtPad,\n} from \"circuit-json\"\n\nexport const getRadiusOfCircuitJsonElement = (\n  obj: PcbVia | PcbPlatedHole | PcbHole | PcbSmtPad,\n) => {\n  if (obj.type === \"pcb_via\") {\n    return obj.outer_diameter / 2\n  }\n  if (obj.type === \"pcb_plated_hole\" && obj.shape === \"circle\") {\n    return obj.outer_diameter / 2\n  }\n  if (obj.type === \"pcb_hole\" && obj.hole_shape === \"circle\") {\n    return obj.hole_diameter / 2\n  }\n  if (obj.type === \"pcb_smtpad\" && obj.shape === \"circle\") {\n    return obj.radius\n  }\n  throw new Error(\n    `Could not determine radius of element: ${JSON.stringify(obj)}`,\n  )\n}\n","import type { Bounds } from \"lib/data-structures/SpatialIndex\"\nimport type { PcbTraceSegment } from \"./getCollidableBounds\"\n\nexport const getClosestPointBetweenSegmentAndBounds = (\n  segment: PcbTraceSegment,\n  bounds: Bounds,\n): { x: number; y: number } => {\n  // Define segment points\n  const p1 = { x: segment.x1, y: segment.y1 }\n  const p2 = { x: segment.x2, y: segment.y2 }\n\n  // Define bounds corners\n  const minX = bounds.minX\n  const minY = bounds.minY\n  const maxX = bounds.maxX\n  const maxY = bounds.maxY\n\n  // Check if segment is a point\n  if (p1.x === p2.x && p1.y === p2.y) {\n    // For a point, find the closest point on the bounds\n    const closestX = Math.max(minX, Math.min(maxX, p1.x))\n    const closestY = Math.max(minY, Math.min(maxY, p1.y))\n\n    // If the point is inside the bounds, return the point itself\n    if (closestX === p1.x && closestY === p1.y) {\n      return { x: p1.x, y: p1.y }\n    }\n\n    // Otherwise, return the closest point on the bounds\n    return { x: closestX, y: closestY }\n  }\n\n  // Calculate direction vector of the segment\n  const dx = p2.x - p1.x\n  const dy = p2.y - p1.y\n\n  // Calculate parameter values for intersection with each boundary\n  const tMinX = dx !== 0 ? (minX - p1.x) / dx : Number.NEGATIVE_INFINITY\n  const tMaxX = dx !== 0 ? (maxX - p1.x) / dx : Number.POSITIVE_INFINITY\n  const tMinY = dy !== 0 ? (minY - p1.y) / dy : Number.NEGATIVE_INFINITY\n  const tMaxY = dy !== 0 ? (maxY - p1.y) / dy : Number.POSITIVE_INFINITY\n\n  // Find the entering and exiting parameters\n  const tEnter = Math.max(Math.min(tMinX, tMaxX), Math.min(tMinY, tMaxY))\n  const tExit = Math.min(Math.max(tMinX, tMaxX), Math.max(tMinY, tMaxY))\n\n  // Check if segment intersects the bounds\n  if (tEnter <= tExit && tExit >= 0 && tEnter <= 1) {\n    // Segment intersects bounds, clamp parameter to segment\n    const t = Math.max(0, Math.min(1, tEnter))\n    return {\n      x: p1.x + t * dx,\n      y: p1.y + t * dy,\n    }\n  }\n\n  // Segment doesn't intersect bounds, find closest point\n  // Check each endpoint of the segment against the bounds\n  const closestToP1 = {\n    x: Math.max(minX, Math.min(maxX, p1.x)),\n    y: Math.max(minY, Math.min(maxY, p1.y)),\n  }\n\n  const closestToP2 = {\n    x: Math.max(minX, Math.min(maxX, p2.x)),\n    y: Math.max(minY, Math.min(maxY, p2.y)),\n  }\n\n  // Calculate distances\n  const distToP1Squared =\n    (closestToP1.x - p1.x) ** 2 + (closestToP1.y - p1.y) ** 2\n  const distToP2Squared =\n    (closestToP2.x - p2.x) ** 2 + (closestToP2.y - p2.y) ** 2\n\n  // Check each edge of the bounds against the segment\n  const edges = [\n    { start: { x: minX, y: minY }, end: { x: maxX, y: minY } }, // Bottom edge\n    { start: { x: maxX, y: minY }, end: { x: maxX, y: maxY } }, // Right edge\n    { start: { x: maxX, y: maxY }, end: { x: minX, y: maxY } }, // Top edge\n    { start: { x: minX, y: maxY }, end: { x: minX, y: minY } }, // Left edge\n  ]\n\n  let minDistance = Math.min(distToP1Squared, distToP2Squared)\n  let closestPoint =\n    distToP1Squared <= distToP2Squared ? closestToP1 : closestToP2\n\n  // Helper function to clamp a value between min and max\n  const clamp = (value: number, min: number, max: number): number => {\n    return Math.max(min, Math.min(max, value))\n  }\n\n  // Check each edge\n  for (const edge of edges) {\n    // Calculate direction vectors\n    const va = { x: p2.x - p1.x, y: p2.y - p1.y }\n    const vb = { x: edge.end.x - edge.start.x, y: edge.end.y - edge.start.y }\n    const w = { x: p1.x - edge.start.x, y: p1.y - edge.start.y }\n\n    // Calculate dot products\n    const dotAA = va.x * va.x + va.y * va.y\n    const dotAB = va.x * vb.x + va.y * vb.y\n    const dotAW = va.x * w.x + va.y * w.y\n    const dotBB = vb.x * vb.x + vb.y * vb.y\n    const dotBW = vb.x * w.x + vb.y * w.y\n\n    // Calculate parameters for closest points\n    const denominator = dotAA * dotBB - dotAB * dotAB\n\n    // Skip if lines are parallel\n    if (Math.abs(denominator) < 1e-10) continue\n\n    let tA = (dotAB * dotBW - dotBB * dotAW) / denominator\n    let tB = (dotAA * dotBW - dotAB * dotAW) / denominator\n\n    // Clamp parameters to segment bounds\n    tA = clamp(tA, 0, 1)\n    tB = clamp(tB, 0, 1)\n\n    // Calculate closest points\n    const closestOnSegment = {\n      x: p1.x + tA * va.x,\n      y: p1.y + tA * va.y,\n    }\n\n    const closestOnEdge = {\n      x: edge.start.x + tB * vb.x,\n      y: edge.start.y + tB * vb.y,\n    }\n\n    // Calculate distance\n    const dx = closestOnSegment.x - closestOnEdge.x\n    const dy = closestOnSegment.y - closestOnEdge.y\n    const distSquared = dx * dx + dy * dy\n\n    // Update if this is closer\n    if (distSquared < minDistance) {\n      minDistance = distSquared\n      closestPoint = {\n        x: (closestOnSegment.x + closestOnEdge.x) / 2,\n        y: (closestOnSegment.y + closestOnEdge.y) / 2,\n      }\n    }\n  }\n\n  return closestPoint\n}\n","import type { Collidable } from \"lib/check-each-pcb-trace-non-overlapping/getCollidableBounds\"\nimport { all_layers } from \"circuit-json\"\n\nexport function getLayersOfPcbElement(obj: Collidable): string[] {\n  if (obj.type === \"pcb_trace_segment\") {\n    return [obj.layer]\n  }\n  if (obj.type === \"pcb_smtpad\") {\n    return [obj.layer]\n  }\n  if (obj.type === \"pcb_plated_hole\") {\n    return Array.isArray(obj.layers) ? obj.layers : [...all_layers]\n  }\n  if (obj.type === \"pcb_hole\") {\n    return [...all_layers]\n  }\n  if (obj.type === \"pcb_via\") {\n    return Array.isArray(obj.layers) ? obj.layers : [...all_layers]\n  }\n  if (obj.type === \"pcb_keepout\") {\n    return Array.isArray(obj.layers) ? obj.layers : []\n  }\n  return []\n}\n","export class NetManager {\n  private networks: Set<Set<string>> = new Set()\n\n  setConnected(nodes: string[]): void {\n    if (nodes.length < 2) return\n\n    let targetNetwork: Set<string> | null = null\n\n    // Check if any of the nodes are already in a network\n    for (const network of this.networks) {\n      for (const node of nodes) {\n        if (network.has(node)) {\n          if (targetNetwork === null) {\n            targetNetwork = network\n          } else if (targetNetwork !== network) {\n            // Merge networks\n            for (const mergeNode of network) {\n              targetNetwork.add(mergeNode)\n            }\n            this.networks.delete(network)\n          }\n          break\n        }\n      }\n      if (targetNetwork !== null && targetNetwork !== network) break\n    }\n\n    // If no existing network found, create a new one\n    if (targetNetwork === null) {\n      targetNetwork = new Set(nodes)\n      this.networks.add(targetNetwork)\n    } else {\n      // Add all nodes to the target network\n      for (const node of nodes) {\n        targetNetwork.add(node)\n      }\n    }\n  }\n\n  isConnected(nodes: string[]): boolean {\n    if (nodes.length < 2) return true\n\n    for (const network of this.networks) {\n      if (nodes.every((node) => network.has(node))) {\n        return true\n      }\n    }\n\n    return false\n  }\n}\n","import type {\n  AnyCircuitElement,\n  PcbBoard,\n  PcbVia,\n  PcbPlacementError,\n} from \"circuit-json\"\nimport { getReadableNameForElement } from \"@tscircuit/circuit-json-util\"\nimport { DEFAULT_VIA_BOARD_MARGIN } from \"lib/drc-defaults\"\n\nexport function checkViasOffBoard(\n  circuitJson: AnyCircuitElement[],\n): PcbPlacementError[] {\n  const board = circuitJson.find((el) => el.type === \"pcb_board\") as PcbBoard\n\n  if (!board) return []\n\n  const vias = circuitJson.filter((el) => el.type === \"pcb_via\") as PcbVia[]\n\n  if (vias.length === 0) return []\n\n  const boardMinX = board.center.x - board.width / 2\n  const boardMaxX = board.center.x + board.width / 2\n  const boardMinY = board.center.y - board.height / 2\n  const boardMaxY = board.center.y + board.height / 2\n\n  const errors: PcbPlacementError[] = []\n\n  for (const via of vias) {\n    const viaRadius = via.outer_diameter / 2\n    const viaMinX = via.x - viaRadius\n    const viaMaxX = via.x + viaRadius\n    const viaMinY = via.y - viaRadius\n    const viaMaxY = via.y + viaRadius\n\n    if (\n      viaMinX < boardMinX + DEFAULT_VIA_BOARD_MARGIN ||\n      viaMaxX > boardMaxX - DEFAULT_VIA_BOARD_MARGIN ||\n      viaMinY < boardMinY + DEFAULT_VIA_BOARD_MARGIN ||\n      viaMaxY > boardMaxY - DEFAULT_VIA_BOARD_MARGIN\n    ) {\n      const viaName = getReadableNameForElement(circuitJson, via.pcb_via_id)\n      errors.push({\n        type: \"pcb_placement_error\",\n        pcb_placement_error_id: `out_of_board_${via.pcb_via_id}`,\n        message: `Via ${viaName} is outside or crossing the board boundary`,\n        error_type: \"pcb_placement_error\",\n      })\n    }\n  }\n\n  return errors\n}\n","import type { AnyCircuitElement, PcbVia, PcbPlacementError } from \"circuit-json\"\nimport { getReadableNameForElement } from \"@tscircuit/circuit-json-util\"\nimport {\n  getFullConnectivityMapFromCircuitJson,\n  type ConnectivityMap,\n} from \"circuit-json-to-connectivity-map\"\nimport { DEFAULT_SAME_NET_VIA_MARGIN, EPSILON } from \"lib/drc-defaults\"\n\nfunction distance(a: PcbVia, b: PcbVia): number {\n  return Math.hypot(a.x - b.x, a.y - b.y)\n}\n\nexport function checkSameNetViaSpacing(\n  circuitJson: AnyCircuitElement[],\n  {\n    connMap,\n    minSpacing = DEFAULT_SAME_NET_VIA_MARGIN,\n  }: { connMap?: ConnectivityMap; minSpacing?: number } = {},\n): PcbPlacementError[] {\n  const vias = circuitJson.filter((el) => el.type === \"pcb_via\") as PcbVia[]\n  if (vias.length < 2) return []\n  connMap ??= getFullConnectivityMapFromCircuitJson(circuitJson)\n  const errors: PcbPlacementError[] = []\n  const reported = new Set<string>()\n\n  for (let i = 0; i < vias.length; i++) {\n    for (let j = i + 1; j < vias.length; j++) {\n      const viaA = vias[i]\n      const viaB = vias[j]\n      if (!connMap.areIdsConnected(viaA.pcb_via_id, viaB.pcb_via_id)) continue\n      const gap =\n        distance(viaA, viaB) - viaA.outer_diameter / 2 - viaB.outer_diameter / 2\n      if (gap + EPSILON >= minSpacing) continue\n      const pairId = [viaA.pcb_via_id, viaB.pcb_via_id].sort().join(\"_\")\n      if (reported.has(pairId)) continue\n      reported.add(pairId)\n      errors.push({\n        type: \"pcb_placement_error\",\n        pcb_placement_error_id: `same_net_vias_close_${pairId}`,\n        message: `Vias ${getReadableNameForElement(\n          circuitJson,\n          viaA.pcb_via_id,\n        )} and ${getReadableNameForElement(\n          circuitJson,\n          viaB.pcb_via_id,\n        )} are too close together (gap: ${gap.toFixed(3)}mm)`,\n        error_type: \"pcb_placement_error\",\n      })\n    }\n  }\n\n  return errors\n}\n","import type { AnyCircuitElement, PcbTrace, PcbTraceError } from \"circuit-json\"\nimport { getReadableNameForElement } from \"@tscircuit/circuit-json-util\"\nimport { segmentToSegmentMinDistance } from \"@tscircuit/math-utils\"\nimport {\n  DEFAULT_TRACE_MARGIN,\n  DEFAULT_TRACE_THICKNESS,\n  EPSILON,\n} from \"lib/drc-defaults\"\n\ninterface TraceSegment {\n  pcb_trace_id: string\n  layer: string\n  thickness: number\n  x1: number\n  y1: number\n  x2: number\n  y2: number\n}\n\nexport function checkTraceSpacing(\n  circuitJson: AnyCircuitElement[],\n  { minSpacing = DEFAULT_TRACE_MARGIN }: { minSpacing?: number } = {},\n): PcbTraceError[] {\n  const traces = circuitJson.filter(\n    (el) => el.type === \"pcb_trace\",\n  ) as PcbTrace[]\n  const segments: TraceSegment[] = []\n\n  for (const trace of traces) {\n    for (let i = 0; i < trace.route.length - 1; i++) {\n      const a = trace.route[i]\n      const b = trace.route[i + 1]\n      if (a.route_type !== \"wire\" || b.route_type !== \"wire\") continue\n      if (a.layer !== b.layer) continue\n      const thickness =\n        \"width\" in a\n          ? (a as any).width\n          : \"width\" in b\n            ? (b as any).width\n            : DEFAULT_TRACE_THICKNESS\n      segments.push({\n        pcb_trace_id: trace.pcb_trace_id,\n        layer: a.layer,\n        thickness,\n        x1: a.x,\n        y1: a.y,\n        x2: b.x,\n        y2: b.y,\n      })\n    }\n  }\n\n  const errors: PcbTraceError[] = []\n\n  for (let i = 0; i < segments.length; i++) {\n    for (let j = i + 1; j < segments.length; j++) {\n      const segA = segments[i]\n      const segB = segments[j]\n      if (segA.pcb_trace_id === segB.pcb_trace_id) continue\n      if (segA.layer !== segB.layer) continue\n      const distance = segmentToSegmentMinDistance(\n        { x: segA.x1, y: segA.y1 },\n        { x: segA.x2, y: segA.y2 },\n        { x: segB.x1, y: segB.y1 },\n        { x: segB.x2, y: segB.y2 },\n      )\n      const gap = distance - segA.thickness / 2 - segB.thickness / 2\n      if (gap + EPSILON >= minSpacing) continue\n      errors.push({\n        type: \"pcb_trace_error\",\n        error_type: \"pcb_trace_error\",\n        message: `PCB trace ${getReadableNameForElement(\n          circuitJson,\n          segA.pcb_trace_id,\n        )} is too close to ${getReadableNameForElement(\n          circuitJson,\n          segB.pcb_trace_id,\n        )} (gap: ${gap.toFixed(3)}mm)`,\n        pcb_trace_id: segA.pcb_trace_id,\n        pcb_trace_error_id: `trace_spacing_${segA.pcb_trace_id}_${segB.pcb_trace_id}`,\n        source_trace_id: \"\",\n        pcb_component_ids: [],\n        pcb_port_ids: [],\n      })\n    }\n  }\n\n  return errors\n}\n","import type {\n  AnyCircuitElement,\n  PcbBoard,\n  PcbPlacementError,\n} from \"circuit-json\"\n\nexport function checkPcbComponentsOutOfBoard(\n  circuitJson: AnyCircuitElement[],\n): PcbPlacementError[] {\n  const board = circuitJson.find((el) => el.type === \"pcb_board\") as PcbBoard\n\n  if (!board) return []\n\n  const components = circuitJson.filter((el) => el.type === \"pcb_component\")\n\n  const boardMinX = board.center.x - board.width / 2\n  const boardMaxX = board.center.x + board.width / 2\n  const boardMinY = board.center.y - board.height / 2\n  const boardMaxY = board.center.y + board.height / 2\n\n  const errors: PcbPlacementError[] = []\n\n  for (const comp of components) {\n    const minX = comp.center.x - comp.width / 2\n    const maxX = comp.center.x + comp.width / 2\n    const minY = comp.center.y - comp.height / 2\n    const maxY = comp.center.y + comp.height / 2\n\n    if (\n      minX < boardMinX ||\n      maxX > boardMaxX ||\n      minY < boardMinY ||\n      maxY > boardMaxY\n    ) {\n      const sourceComponent = circuitJson.find(\n        (el) =>\n          el.type === \"source_component\" &&\n          el.source_component_id === comp.source_component_id,\n      ) as any\n      const componentType = (sourceComponent?.ftype || \"unknown\").replace(\n        /^simple_/,\n        \"\",\n      )\n      errors.push({\n        type: \"pcb_placement_error\",\n        pcb_placement_error_id: `out_of_board_${comp.pcb_component_id}`,\n        message: `Component ${componentType}[${sourceComponent!.name}] out of board`,\n        error_type: \"pcb_placement_error\",\n      })\n    }\n  }\n\n  return errors\n}\n","import type { PcbSmtPad, PcbPlatedHole } from \"circuit-json\"\n\nfunction distance(x1: number, y1: number, x2: number, y2: number): number {\n  return Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2)\n}\n\nexport function isPointInPad(\n  point: { x: number; y: number },\n  pad: PcbSmtPad | PcbPlatedHole,\n): boolean {\n  if (pad.type === \"pcb_smtpad\") {\n    if (pad.shape === \"circle\") {\n      return distance(point.x, point.y, pad.x, pad.y) <= pad.radius\n    }\n\n    if (pad.shape === \"rect\") {\n      const halfWidth = pad.width / 2\n      const halfHeight = pad.height / 2\n      return (\n        Math.abs(point.x - pad.x) <= halfWidth &&\n        Math.abs(point.y - pad.y) <= halfHeight\n      )\n    }\n\n    if (pad.shape === \"rotated_rect\") {\n      const dx = point.x - pad.x\n      const dy = point.y - pad.y\n      const angle = -pad.ccw_rotation\n      const rotatedX = dx * Math.cos(angle) - dy * Math.sin(angle)\n      const rotatedY = dx * Math.sin(angle) + dy * Math.cos(angle)\n      return (\n        Math.abs(rotatedX) <= pad.width / 2 &&\n        Math.abs(rotatedY) <= pad.height / 2\n      )\n    }\n\n    if (pad.shape === \"pill\") {\n      const halfWidth = pad.width / 2\n      const halfHeight = pad.height / 2\n      const radius = pad.radius\n\n      if (\n        Math.abs(point.x - pad.x) <= halfWidth - radius &&\n        Math.abs(point.y - pad.y) <= halfHeight\n      ) {\n        return true\n      }\n\n      const cornerX = Math.max(\n        Math.abs(point.x - pad.x) - (halfWidth - radius),\n        0,\n      )\n      const cornerY = Math.max(\n        Math.abs(point.y - pad.y) - (halfHeight - radius),\n        0,\n      )\n      return cornerX * cornerX + cornerY * cornerY <= radius * radius\n    }\n  }\n\n  if (pad.type === \"pcb_plated_hole\") {\n    if (pad.shape === \"circle\") {\n      return distance(point.x, point.y, pad.x, pad.y) <= pad.outer_diameter / 2\n    }\n\n    if (pad.shape === \"oval\" || pad.shape === \"pill\") {\n      return (\n        Math.abs(point.x - pad.x) <= pad.outer_width / 2 &&\n        Math.abs(point.y - pad.y) <= pad.outer_height / 2\n      )\n    }\n\n    if (pad.shape === \"circular_hole_with_rect_pad\") {\n      return (\n        Math.abs(point.x - pad.x) <= pad.rect_pad_width / 2 &&\n        Math.abs(point.y - pad.y) <= pad.rect_pad_height / 2\n      )\n    }\n\n    if (pad.shape === \"pill_hole_with_rect_pad\") {\n      return (\n        Math.abs(point.x - pad.x) <= pad.rect_pad_width / 2 &&\n        Math.abs(point.y - pad.y) <= pad.rect_pad_height / 2\n      )\n    }\n  }\n\n  return false\n}\n","import type {\n  AnyCircuitElement,\n  PcbTraceError,\n  PcbPort,\n  PcbTrace,\n  SourceTrace,\n  PcbSmtPad,\n  PcbPlatedHole,\n} from \"circuit-json\"\nimport { isPointInPad } from \"./is-point-in-pad\"\nimport { getReadableNameForPcbPort } from \"@tscircuit/circuit-json-util\"\n\nfunction checkTracesAreContiguous(\n  circuitJson: AnyCircuitElement[],\n): PcbTraceError[] {\n  const errors: PcbTraceError[] = []\n\n  const pcbPorts = circuitJson.filter(\n    (el) => el.type === \"pcb_port\",\n  ) as PcbPort[]\n  const pcbTraces = circuitJson.filter(\n    (el) => el.type === \"pcb_trace\",\n  ) as PcbTrace[]\n  const sourceTraces = circuitJson.filter(\n    (el) => el.type === \"source_trace\",\n  ) as SourceTrace[]\n  const pcbSmtPads = circuitJson.filter(\n    (el) => el.type === \"pcb_smtpad\",\n  ) as PcbSmtPad[]\n  const pcbPlatedHoles = circuitJson.filter(\n    (el) => el.type === \"pcb_plated_hole\",\n  ) as PcbPlatedHole[]\n\n  const padMap = new Map<string, PcbSmtPad | PcbPlatedHole>()\n\n  for (const pad of pcbSmtPads) {\n    if (pad.pcb_port_id) {\n      padMap.set(pad.pcb_port_id, pad)\n    }\n  }\n\n  for (const hole of pcbPlatedHoles) {\n    if (hole.pcb_port_id) {\n      padMap.set(hole.pcb_port_id, hole)\n    }\n  }\n\n  for (const trace of pcbTraces) {\n    if (trace.route.length === 0) continue\n\n    const firstPoint = trace.route[0]\n    const lastPoint = trace.route[trace.route.length - 1]\n\n    const sourceTrace = sourceTraces.find(\n      (st) => st.source_trace_id === trace.source_trace_id,\n    )\n\n    if (!sourceTrace) continue\n\n    const expectedPorts = pcbPorts.filter((port) =>\n      sourceTrace.connected_source_port_ids?.includes(port.source_port_id),\n    )\n\n    for (let i = 1; i < trace.route.length - 1; i++) {\n      const prevPoint = trace.route[i - 1]\n      const currentPoint = trace.route[i]\n      const nextPoint = trace.route[i + 1]\n\n      if (currentPoint.route_type === \"via\") {\n        const prevIsWire = prevPoint.route_type === \"wire\"\n        const nextIsWire = nextPoint.route_type === \"wire\"\n\n        if (prevIsWire && nextIsWire) {\n          const prevAligned =\n            Math.abs(prevPoint.x - currentPoint.x) < 0.001 &&\n            Math.abs(prevPoint.y - currentPoint.y) < 0.001\n\n          const nextAligned =\n            Math.abs(nextPoint.x - currentPoint.x) < 0.001 &&\n            Math.abs(nextPoint.y - currentPoint.y) < 0.001\n\n          if (!prevAligned || !nextAligned) {\n            const traceName = sourceTrace.display_name\n            errors.push({\n              type: \"pcb_trace_error\",\n              message: `Via in trace [${traceName}] is misaligned at position {x: ${currentPoint.x}, y: ${currentPoint.y}}.`,\n              source_trace_id: sourceTrace.source_trace_id,\n              error_type: \"pcb_trace_error\",\n              pcb_trace_id: trace.pcb_trace_id,\n              pcb_trace_error_id: \"\",\n              pcb_component_ids: [],\n              pcb_port_ids: [],\n            })\n          }\n        }\n      }\n    }\n\n    for (const port of expectedPorts) {\n      if (!port.pcb_port_id) continue\n\n      const pad = padMap.get(port.pcb_port_id)\n\n      if (!pad) continue\n\n      const isFirstPointConnected =\n        firstPoint.route_type === \"wire\" &&\n        isPointInPad({ x: firstPoint.x, y: firstPoint.y }, pad)\n\n      const isLastPointConnected =\n        lastPoint.route_type === \"wire\" &&\n        isPointInPad({ x: lastPoint.x, y: lastPoint.y }, pad)\n\n      if (!isFirstPointConnected && !isLastPointConnected) {\n        const traceName = sourceTrace.display_name\n        const portName = getReadableNameForPcbPort(\n          circuitJson,\n          port.pcb_port_id,\n        ).replace(\"pcb_port\", \"\")\n        const padType = pad.type.replace(/pcb_/, \"\")\n        errors.push({\n          type: \"pcb_trace_error\",\n          message: `Trace [${traceName}] is missing a connection to ${padType}${portName}`,\n          source_trace_id: sourceTrace.source_trace_id,\n          error_type: \"pcb_trace_error\",\n          pcb_trace_id: trace.pcb_trace_id,\n          pcb_trace_error_id: \"\",\n          pcb_component_ids: [],\n          pcb_port_ids: [port.pcb_port_id],\n        })\n      }\n    }\n  }\n\n  return errors\n}\n\nexport { checkTracesAreContiguous }\n","import { checkEachPcbPortConnected } from \"./check-each-pcb-port-connected\"\nimport { checkEachPcbTraceNonOverlapping } from \"./check-each-pcb-trace-non-overlapping/check-each-pcb-trace-non-overlapping\"\nimport { checkSameNetViaSpacing } from \"./check-same-net-via-spacing\"\nimport { checkViasOffBoard } from \"./check-pcb-components-out-of-board/checkViasOffBoard\"\nimport { checkPcbComponentsOutOfBoard } from \"./check-pcb-components-out-of-board/checkPcbComponentsOutOfBoard\"\nimport { checkTracesAreContiguous } from \"./check-traces-are-contiguous/check-traces-are-contiguous\"\n\nexport async function runAllChecks(circuitJson: any[]) {\n  return [\n    ...checkEachPcbPortConnected(circuitJson),\n    ...checkEachPcbTraceNonOverlapping(circuitJson),\n    ...checkSameNetViaSpacing(circuitJson),\n    ...checkViasOffBoard(circuitJson),\n    ...checkPcbComponentsOutOfBoard(circuitJson),\n    ...checkTracesAreContiguous(circuitJson),\n  ]\n}\n"],"mappings":";AAOA,SAAS,SAAS,IAAY,IAAY,IAAY,IAAoB;AACxE,SAAO,KAAK,MAAM,KAAK,OAAO,KAAK,KAAK,OAAO,CAAC;AAClD;AAMO,IAAM,iCAAiC,CAC5C,SACS;AACT,QAAM,WAAsB,KAAK,OAAO,CAAC,SAAS,KAAK,SAAS,UAAU;AAC1E,QAAM,aAA0B,KAAK;AAAA,IACnC,CAAC,SAAS,KAAK,SAAS;AAAA,EAC1B;AACA,QAAM,YAAwB,KAAK,OAAO,CAAC,SAAS,KAAK,SAAS,WAAW;AAE7E,WAAS,2BACP,OAIA,UAAiE,CAAC,GACnD;AACf,UAAM,aAAa,QAAQ,cAAc;AACzC,UAAM,aAAa,SAAS;AAAA,MAC1B,CAAC,SAAS,SAAS,KAAK,GAAG,KAAK,GAAG,MAAM,GAAG,MAAM,CAAC,IAAI;AAAA,IACzD;AACA,QAAI,WAAY,QAAO,WAAW;AAGlC,QAAI,QAAQ,oBAAoB;AAC9B,YAAM,SAAS,WAAW,KAAK,CAAC,QAAQ;AACtC,YAAI,IAAI,UAAU,QAAQ;AACxB,iBACE,KAAK,IAAI,MAAM,IAAI,IAAI,CAAC,IAAI,IAAI,QAAQ,IAAI,aAAa,KACzD,KAAK,IAAI,MAAM,IAAI,IAAI,CAAC,IAAI,IAAI,SAAS,IAAI,aAAa;AAAA,QAG9D,WAAW,IAAI,UAAU,UAAU;AACjC,iBAAO,SAAS,MAAM,GAAG,MAAM,GAAG,IAAI,GAAG,IAAI,CAAC,IAAI,IAAI;AAAA,QACxD;AAAA,MACF,CAAC;AACD,UAAI,OAAQ,QAAO,OAAO,eAAe;AAAA,IAC3C;AAEA,WAAO;AAAA,EACT;AAGA,aAAW,SAAS,WAAW;AAC7B,aAAS,QAAQ,GAAG,QAAQ,MAAM,MAAM,QAAQ,SAAS;AACvD,YAAM,UAAU,MAAM,MAAM,KAAK;AACjC,YAAM,qBAAqB,UAAU,KAAK,UAAU,MAAM,MAAM,SAAS;AACzE,UAAI,QAAQ,eAAe,QAAQ;AACjC,YAAI,CAAC,QAAQ,qBAAqB,UAAU,GAAG;AAC7C,gBAAM,cAAc,2BAA2B,SAAS;AAAA,YACtD;AAAA,YACA,YAAY,QAAQ;AAAA,UACtB,CAAC;AACD,cAAI,aAAa;AACf,oBAAQ,oBAAoB;AAAA,UAC9B;AAAA,QACF;AACA,YAAI,CAAC,QAAQ,mBAAmB,UAAU,MAAM,MAAM,SAAS,GAAG;AAChE,gBAAM,YAAY,2BAA2B,SAAS;AAAA,YACpD;AAAA,YACA,YAAY,QAAQ;AAAA,UACtB,CAAC;AACD,cAAI,WAAW;AACb,oBAAQ,kBAAkB;AAAA,UAC5B;AAAA,QACF;AAAA,MACF;AAAA,IACF;AAAA,EACF;AACF;;;AC3EA,SAAS,iCAAiC;AAE1C,SAAS,0BAA0B,MAA4C;AAC7E,iCAA+B,IAAI;AACnC,QAAM,WAAsB,KAAK,OAAO,CAAC,SAAS,KAAK,SAAS,UAAU;AAC1E,QAAM,YAAwB,KAAK,OAAO,CAAC,SAAS,KAAK,SAAS,WAAW;AAC7E,QAAM,eAA8B,KAAK;AAAA,IACvC,CAAC,SAAS,KAAK,SAAS;AAAA,EAC1B;AACA,QAAM,SAA0B,CAAC;AAEjC,aAAW,QAAQ,UAAU;AAC3B,UAAM,kBAAkB,UAAU;AAAA,MAAO,CAAC,UACxC,MAAM,MAAM;AAAA,QACV,CAAC,YACC,QAAQ,eAAe,WACtB,QAAQ,sBAAsB,KAAK,eAClC,QAAQ,oBAAoB,KAAK;AAAA,MACvC;AAAA,IACF;AAEA,UAAM,cAAc,aAAa;AAAA,MAAK,CAAC,UACrC,MAAM,2BAA2B,SAAS,KAAK,cAAc;AAAA,IAC/D;AAEA,UAAM,gCACJ,eAAe,YAAY,2BAA2B,SAAS;AAEjE,QAAI,gBAAgB,WAAW,KAAK,+BAA+B;AACjE,aAAO,KAAK;AAAA,QACV,MAAM;AAAA,QACN,SAAS,6BAA6B,0BAA0B,MAAM,KAAK,WAAW,CAAC;AAAA,QACvF,iBAAiB,YAAY;AAAA,QAC7B,YAAY;AAAA,QACZ,cAAc;AAAA,QACd,oBAAoB;AAAA,QACpB,mBAAmB,CAAC;AAAA,QACpB,cAAc,CAAC,KAAK,WAAW;AAAA,MACjC,CAAC;AAAA,IACH;AAAA,EACF;AAEA,SAAO;AACT;;;AClDA,SAAS,2BAA2B,WAAW;;;ACWxC,IAAM,qBAAN,MAA4B;AAAA,EACjC;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA,YAAY;AAAA,EAEZ,YAAY;AAAA,IACV;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACF,GAKG;AACD,SAAK,UAAU,oBAAI,IAAI;AACvB,SAAK,cAAc,oBAAI,IAAI;AAC3B,SAAK,YAAY;AACjB,SAAK,QAAQ,UAAU,MAAM,KAAK,WAAW;AAC7C,SAAK,YAAY,aAAa,KAAK;AAEnC,eAAW,OAAO,SAAS;AACzB,WAAK,UAAU,GAAG;AAAA,IACpB;AAAA,EACF;AAAA,EAEA,aAAa;AAAA,EACb,aAAqB;AACnB,WAAO,GAAG,KAAK,YAAY;AAAA,EAC7B;AAAA,EAEA,UAAU,KAAc;AACtB,UAAM,SAAS,KAAK,UAAU,GAAG;AACjC,UAAM,iBAAiB,KAAK,MAAM,GAAG;AACrC,UAAM,YAAY,EAAE,GAAG,KAAK,eAAe;AAK3C,SAAK,YAAY,IAAI,gBAAgB,SAAS;AAG9C,UAAM,aAAa,KAAK,MAAM,OAAO,OAAO,KAAK,SAAS;AAC1D,UAAM,aAAa,KAAK,MAAM,OAAO,OAAO,KAAK,SAAS;AAC1D,UAAM,aAAa,KAAK,MAAM,OAAO,OAAO,KAAK,SAAS;AAC1D,UAAM,aAAa,KAAK,MAAM,OAAO,OAAO,KAAK,SAAS;AAG1D,aAAS,KAAK,YAAY,MAAM,YAAY,MAAM;AAChD,eAAS,KAAK,YAAY,MAAM,YAAY,MAAM;AAChD,cAAM,YAAY,GAAG,EAAE,IAAI,EAAE;AAC7B,cAAM,SAAS,KAAK,QAAQ,IAAI,SAAS;AACzC,YAAI,CAAC,QAAQ;AACX,eAAK,QAAQ,IAAI,WAAW,CAAC,SAAS,CAAC;AAAA,QACzC,OAAO;AACL,iBAAO,KAAK,SAAS;AAAA,QACvB;AAAA,MACF;AAAA,IACF;AAAA,EACF;AAAA,EAEA,aAAa,IAAqB;AAChC,UAAM,MAAM,KAAK,YAAY,IAAI,EAAE;AACnC,QAAI,CAAC,IAAK,QAAO;AAGjB,SAAK,YAAY,OAAO,EAAE;AAG1B,UAAM,SAAS,KAAK,UAAU,GAAG;AACjC,UAAM,aAAa,KAAK,MAAM,OAAO,OAAO,KAAK,SAAS;AAC1D,UAAM,aAAa,KAAK,MAAM,OAAO,OAAO,KAAK,SAAS;AAC1D,UAAM,aAAa,KAAK,MAAM,OAAO,OAAO,KAAK,SAAS;AAC1D,UAAM,aAAa,KAAK,MAAM,OAAO,OAAO,KAAK,SAAS;AAG1D,aAAS,KAAK,YAAY,MAAM,YAAY,MAAM;AAChD,eAAS,KAAK,YAAY,MAAM,YAAY,MAAM;AAChD,cAAM,YAAY,GAAG,EAAE,IAAI,EAAE;AAC7B,cAAM,SAAS,KAAK,QAAQ,IAAI,SAAS;AACzC,YAAI,QAAQ;AACV,gBAAM,QAAQ,OAAO,UAAU,CAAC,SAAS,KAAK,mBAAmB,EAAE;AACnE,cAAI,UAAU,IAAI;AAChB,mBAAO,OAAO,OAAO,CAAC;AACtB,gBAAI,OAAO,WAAW,GAAG;AACvB,mBAAK,QAAQ,OAAO,SAAS;AAAA,YAC/B;AAAA,UACF;AAAA,QACF;AAAA,MACF;AAAA,IACF;AAEA,WAAO;AAAA,EACT;AAAA,EAEA,aAAa,GAAW,GAA6B;AACnD,WAAO,GAAG,KAAK,MAAM,IAAI,KAAK,SAAS,CAAC,IAAI,KAAK,MAAM,IAAI,KAAK,SAAS,CAAC;AAAA,EAC5E;AAAA,EAEA,mBAAmB,QAAgB,SAAS,GAAQ;AAClD,UAAM,UAAe,CAAC;AACtB,UAAM,WAAW,oBAAI,IAAY;AAGjC,UAAM,aAAa,KAAK,OAAO,OAAO,OAAO,UAAU,KAAK,SAAS;AACrE,UAAM,aAAa,KAAK,OAAO,OAAO,OAAO,UAAU,KAAK,SAAS;AACrE,UAAM,aAAa,KAAK,OAAO,OAAO,OAAO,UAAU,KAAK,SAAS;AACrE,UAAM,aAAa,KAAK,OAAO,OAAO,OAAO,UAAU,KAAK,SAAS;AAGrE,aAAS,KAAK,YAAY,MAAM,YAAY,MAAM;AAChD,eAAS,KAAK,YAAY,MAAM,YAAY,MAAM;AAChD,cAAM,YAAY,GAAG,EAAE,IAAI,EAAE;AAC7B,cAAM,SAAS,KAAK,QAAQ,IAAI,SAAS,KAAK,CAAC;AAE/C,mBAAW,OAAO,QAAQ;AACxB,gBAAM,KAAK,IAAI;AACf,cAAI,SAAS,IAAI,EAAE,EAAG;AAEtB,mBAAS,IAAI,EAAE;AACf,kBAAQ,KAAK,GAAG;AAAA,QAClB;AAAA,MACF;AAAA,IACF;AAEA,WAAO;AAAA,EACT;AACF;;;ADxIA;AAAA,EACE;AAAA,OAEK;;;AETP,SAAS,8BAA8B;AAuChC,IAAM,sBAAsB,CAAC,eAAmC;AACrE,MAAI,WAAW,SAAS,qBAAqB;AAC3C,WAAO;AAAA,MACL,MAAM,KAAK,IAAI,WAAW,IAAI,WAAW,EAAE;AAAA,MAC3C,MAAM,KAAK,IAAI,WAAW,IAAI,WAAW,EAAE;AAAA,MAC3C,MAAM,KAAK,IAAI,WAAW,IAAI,WAAW,EAAE;AAAA,MAC3C,MAAM,KAAK,IAAI,WAAW,IAAI,WAAW,EAAE;AAAA,IAC7C;AAAA,EACF;AACA,SAAO,uBAAuB,CAAC,UAAiB,CAAC;AACnD;;;AFlCA;AAAA,EACE;AAAA,EACA;AAAA,OACK;;;AGlBA,IAAM,uBAAuB;AAC7B,IAAM,0BAA0B;AAEhC,IAAM,2BAA2B;AAEjC,IAAM,8BAA8B;AAEpC,IAAM,UAAU;;;ACLhB,SAAS,8BAA8B,OAAiB;AAC7D,QAAM,oBAAoB,oBAAI,IAAY;AAC1C,aAAW,WAAW,MAAM,OAAO;AACjC,QAAI,QAAQ,eAAe,QAAQ;AACjC,UAAI,QAAQ;AACV,0BAAkB,IAAI,QAAQ,iBAAiB;AACjD,UAAI,QAAQ;AACV,0BAAkB,IAAI,QAAQ,eAAe;AAAA,IACjD;AAAA,EACF;AAEA,SAAO,MAAM,KAAK,iBAAiB;AACrC;AAEO,SAAS,+BAA+B,QAAoB;AACjE,QAAM,iBAAiB,oBAAI,IAAY;AACvC,aAAW,SAAS,QAAQ;AAC1B,eAAW,UAAU,8BAA8B,KAAK,GAAG;AACzD,qBAAe,IAAI,MAAM;AAAA,IAC3B;AAAA,EACF;AACA,SAAO,MAAM,KAAK,cAAc;AAClC;;;AJCA,SAAS,mCAAmC;AAE5C,SAAS,oBAAoB;;;AKzBtB,IAAM,iCAAiC,CAC5C,UACA,aAC6B;AAE7B,QAAM,KAAK,EAAE,GAAG,SAAS,IAAI,GAAG,SAAS,GAAG;AAC5C,QAAM,KAAK,EAAE,GAAG,SAAS,IAAI,GAAG,SAAS,GAAG;AAC5C,QAAM,KAAK,EAAE,GAAG,SAAS,IAAI,GAAG,SAAS,GAAG;AAC5C,QAAM,KAAK,EAAE,GAAG,SAAS,IAAI,GAAG,SAAS,GAAG;AAG5C,QAAM,KAAK,EAAE,GAAG,GAAG,IAAI,GAAG,GAAG,GAAG,GAAG,IAAI,GAAG,EAAE;AAC5C,QAAM,KAAK,EAAE,GAAG,GAAG,IAAI,GAAG,GAAG,GAAG,GAAG,IAAI,GAAG,EAAE;AAG5C,QAAM,UAAU,GAAG,IAAI,GAAG,IAAI,GAAG,IAAI,GAAG;AACxC,QAAM,UAAU,GAAG,IAAI,GAAG,IAAI,GAAG,IAAI,GAAG;AAGxC,MAAI,YAAY,KAAK,YAAY,GAAG;AAClC,QAAI,YAAY,KAAK,YAAY,GAAG;AAGlC,aAAO;AAAA,QACL,IAAI,GAAG,IAAI,GAAG,KAAK;AAAA,QACnB,IAAI,GAAG,IAAI,GAAG,KAAK;AAAA,MACrB;AAAA,IACF;AACA,QAAI,YAAY,GAAG;AAEjB,YAAMA,KAAI;AAAA,UACN,GAAG,IAAI,GAAG,KAAK,GAAG,KAAK,GAAG,IAAI,GAAG,KAAK,GAAG,KAAK;AAAA,QAChD;AAAA,QACA;AAAA,MACF;AACA,YAAMC,cAAa;AAAA,QACjB,GAAG,GAAG,IAAID,KAAI,GAAG;AAAA,QACjB,GAAG,GAAG,IAAIA,KAAI,GAAG;AAAA,MACnB;AAEA,aAAO;AAAA,QACL,IAAI,GAAG,IAAIC,YAAW,KAAK;AAAA,QAC3B,IAAI,GAAG,IAAIA,YAAW,KAAK;AAAA,MAC7B;AAAA,IACF;AAEA,UAAM,IAAI;AAAA,QACN,GAAG,IAAI,GAAG,KAAK,GAAG,KAAK,GAAG,IAAI,GAAG,KAAK,GAAG,KAAK;AAAA,MAChD;AAAA,MACA;AAAA,IACF;AACA,UAAMC,cAAa;AAAA,MACjB,GAAG,GAAG,IAAI,IAAI,GAAG;AAAA,MACjB,GAAG,GAAG,IAAI,IAAI,GAAG;AAAA,IACnB;AAEA,WAAO;AAAA,MACL,IAAIA,YAAW,IAAI,GAAG,KAAK;AAAA,MAC3B,IAAIA,YAAW,IAAI,GAAG,KAAK;AAAA,IAC7B;AAAA,EACF;AAGA,QAAM,IAAI,EAAE,GAAG,GAAG,IAAI,GAAG,GAAG,GAAG,GAAG,IAAI,GAAG,EAAE;AAG3C,QAAM,QAAQ,GAAG,IAAI,GAAG,IAAI,GAAG,IAAI,GAAG;AACtC,QAAM,QAAQ,GAAG,IAAI,GAAG,IAAI,GAAG,IAAI,GAAG;AACtC,QAAM,QAAQ,GAAG,IAAI,EAAE,IAAI,GAAG,IAAI,EAAE;AACpC,QAAM,QAAQ,GAAG,IAAI,GAAG,IAAI,GAAG,IAAI,GAAG;AACtC,QAAM,QAAQ,GAAG,IAAI,EAAE,IAAI,GAAG,IAAI,EAAE;AAGpC,QAAM,cAAc,QAAQ,QAAQ,QAAQ;AAG5C,MAAI,cAAc,OAAO;AACvB,WAAO;AAAA,MACL;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,IACF;AAAA,EACF;AAGA,MAAI,MAAM,QAAQ,QAAQ,QAAQ,SAAS;AAC3C,MAAI,MAAM,QAAQ,QAAQ,QAAQ,SAAS;AAG3C,OAAK,MAAM,IAAI,GAAG,CAAC;AACnB,OAAK,MAAM,IAAI,GAAG,CAAC;AAGnB,QAAM,KAAK,QAAQ,SAAS;AAC5B,OAAK,MAAM,IAAI,GAAG,CAAC;AAGnB,QAAM,KAAK,QAAQ,SAAS;AAC5B,OAAK,MAAM,IAAI,GAAG,CAAC;AAGnB,QAAM,aAAa;AAAA,IACjB,GAAG,GAAG,IAAI,KAAK,GAAG;AAAA,IAClB,GAAG,GAAG,IAAI,KAAK,GAAG;AAAA,EACpB;AAEA,QAAM,aAAa;AAAA,IACjB,GAAG,GAAG,IAAI,KAAK,GAAG;AAAA,IAClB,GAAG,GAAG,IAAI,KAAK,GAAG;AAAA,EACpB;AAGA,QAAM,KAAK,WAAW,IAAI,WAAW;AACrC,QAAM,KAAK,WAAW,IAAI,WAAW;AACrC,QAAMC,YAAW,KAAK,KAAK,KAAK,KAAK,KAAK,EAAE;AAG5C,QAAM,eAAe;AAAA,IACnB,IAAI,WAAW,IAAI,WAAW,KAAK;AAAA,IACnC,IAAI,WAAW,IAAI,WAAW,KAAK;AAAA,EACrC;AAEA,SAAO;AACT;AAGA,IAAM,gCAAgC,CACpC,IACA,IACA,IACA,IACA,IACA,IACA,SACA,YACG;AAEH,MAAI,OAAO,GAAG,IAAI,GAAG,KAAK,GAAG,KAAK,GAAG,IAAI,GAAG,KAAK,GAAG,KAAK;AACzD,OAAK,MAAM,IAAI,GAAG,CAAC;AACnB,QAAM,YAAY,EAAE,GAAG,GAAG,IAAI,KAAK,GAAG,GAAG,GAAG,GAAG,IAAI,KAAK,GAAG,EAAE;AAG7D,MAAI,QAAQ,GAAG,IAAI,GAAG,KAAK,GAAG,KAAK,GAAG,IAAI,GAAG,KAAK,GAAG,KAAK;AAC1D,QAAM,MAAM,KAAK,GAAG,CAAC;AACrB,QAAM,YAAY,EAAE,GAAG,GAAG,IAAI,MAAM,GAAG,GAAG,GAAG,GAAG,IAAI,MAAM,GAAG,EAAE;AAG/D,MAAI,OAAO,GAAG,IAAI,GAAG,KAAK,GAAG,KAAK,GAAG,IAAI,GAAG,KAAK,GAAG,KAAK;AACzD,OAAK,MAAM,IAAI,GAAG,CAAC;AACnB,QAAM,YAAY,EAAE,GAAG,GAAG,IAAI,KAAK,GAAG,GAAG,GAAG,GAAG,IAAI,KAAK,GAAG,EAAE;AAG7D,MAAI,QAAQ,GAAG,IAAI,GAAG,KAAK,GAAG,KAAK,GAAG,IAAI,GAAG,KAAK,GAAG,KAAK;AAC1D,QAAM,MAAM,KAAK,GAAG,CAAC;AACrB,QAAM,YAAY,EAAE,GAAG,GAAG,IAAI,MAAM,GAAG,GAAG,GAAG,GAAG,IAAI,MAAM,GAAG,EAAE;AAG/D,QAAM,YAAY;AAAA,IAChB;AAAA,MACE,QAAQ;AAAA,MACR,QAAQ;AAAA,MACR,UAAU,KAAK;AAAA,SACZ,UAAU,IAAI,GAAG,MAAM,KAAK,UAAU,IAAI,GAAG,MAAM;AAAA,MACtD;AAAA,IACF;AAAA,IACA;AAAA,MACE,QAAQ;AAAA,MACR,QAAQ;AAAA,MACR,UAAU,KAAK;AAAA,SACZ,UAAU,IAAI,GAAG,MAAM,KAAK,UAAU,IAAI,GAAG,MAAM;AAAA,MACtD;AAAA,IACF;AAAA,IACA;AAAA,MACE,QAAQ;AAAA,MACR,QAAQ;AAAA,MACR,UAAU,KAAK;AAAA,SACZ,GAAG,IAAI,UAAU,MAAM,KAAK,GAAG,IAAI,UAAU,MAAM;AAAA,MACtD;AAAA,IACF;AAAA,IACA;AAAA,MACE,QAAQ;AAAA,MACR,QAAQ;AAAA,MACR,UAAU,KAAK;AAAA,SACZ,GAAG,IAAI,UAAU,MAAM,KAAK,GAAG,IAAI,UAAU,MAAM;AAAA,MACtD;AAAA,IACF;AAAA,EACF;AAGA,QAAM,cAAc,UAAU;AAAA,IAAO,CAAC,SAAS,YAC7C,QAAQ,WAAW,QAAQ,WAAW,UAAU;AAAA,EAClD;AAGA,SAAO;AAAA,IACL,IAAI,YAAY,OAAO,IAAI,YAAY,OAAO,KAAK;AAAA,IACnD,IAAI,YAAY,OAAO,IAAI,YAAY,OAAO,KAAK;AAAA,EACrD;AACF;AAGA,IAAM,QAAQ,CAAC,OAAe,KAAa,QAAwB;AACjE,SAAO,KAAK,IAAI,KAAK,KAAK,IAAI,KAAK,KAAK,CAAC;AAC3C;;;AC1MO,IAAM,gCAAgC,CAC3C,QACG;AACH,MAAI,IAAI,SAAS,WAAW;AAC1B,WAAO,IAAI,iBAAiB;AAAA,EAC9B;AACA,MAAI,IAAI,SAAS,qBAAqB,IAAI,UAAU,UAAU;AAC5D,WAAO,IAAI,iBAAiB;AAAA,EAC9B;AACA,MAAI,IAAI,SAAS,cAAc,IAAI,eAAe,UAAU;AAC1D,WAAO,IAAI,gBAAgB;AAAA,EAC7B;AACA,MAAI,IAAI,SAAS,gBAAgB,IAAI,UAAU,UAAU;AACvD,WAAO,IAAI;AAAA,EACb;AACA,QAAM,IAAI;AAAA,IACR,0CAA0C,KAAK,UAAU,GAAG,CAAC;AAAA,EAC/D;AACF;;;ACvBO,IAAM,yCAAyC,CACpD,SACA,WAC6B;AAE7B,QAAM,KAAK,EAAE,GAAG,QAAQ,IAAI,GAAG,QAAQ,GAAG;AAC1C,QAAM,KAAK,EAAE,GAAG,QAAQ,IAAI,GAAG,QAAQ,GAAG;AAG1C,QAAM,OAAO,OAAO;AACpB,QAAM,OAAO,OAAO;AACpB,QAAM,OAAO,OAAO;AACpB,QAAM,OAAO,OAAO;AAGpB,MAAI,GAAG,MAAM,GAAG,KAAK,GAAG,MAAM,GAAG,GAAG;AAElC,UAAM,WAAW,KAAK,IAAI,MAAM,KAAK,IAAI,MAAM,GAAG,CAAC,CAAC;AACpD,UAAM,WAAW,KAAK,IAAI,MAAM,KAAK,IAAI,MAAM,GAAG,CAAC,CAAC;AAGpD,QAAI,aAAa,GAAG,KAAK,aAAa,GAAG,GAAG;AAC1C,aAAO,EAAE,GAAG,GAAG,GAAG,GAAG,GAAG,EAAE;AAAA,IAC5B;AAGA,WAAO,EAAE,GAAG,UAAU,GAAG,SAAS;AAAA,EACpC;AAGA,QAAM,KAAK,GAAG,IAAI,GAAG;AACrB,QAAM,KAAK,GAAG,IAAI,GAAG;AAGrB,QAAM,QAAQ,OAAO,KAAK,OAAO,GAAG,KAAK,KAAK,OAAO;AACrD,QAAM,QAAQ,OAAO,KAAK,OAAO,GAAG,KAAK,KAAK,OAAO;AACrD,QAAM,QAAQ,OAAO,KAAK,OAAO,GAAG,KAAK,KAAK,OAAO;AACrD,QAAM,QAAQ,OAAO,KAAK,OAAO,GAAG,KAAK,KAAK,OAAO;AAGrD,QAAM,SAAS,KAAK,IAAI,KAAK,IAAI,OAAO,KAAK,GAAG,KAAK,IAAI,OAAO,KAAK,CAAC;AACtE,QAAM,QAAQ,KAAK,IAAI,KAAK,IAAI,OAAO,KAAK,GAAG,KAAK,IAAI,OAAO,KAAK,CAAC;AAGrE,MAAI,UAAU,SAAS,SAAS,KAAK,UAAU,GAAG;AAEhD,UAAM,IAAI,KAAK,IAAI,GAAG,KAAK,IAAI,GAAG,MAAM,CAAC;AACzC,WAAO;AAAA,MACL,GAAG,GAAG,IAAI,IAAI;AAAA,MACd,GAAG,GAAG,IAAI,IAAI;AAAA,IAChB;AAAA,EACF;AAIA,QAAM,cAAc;AAAA,IAClB,GAAG,KAAK,IAAI,MAAM,KAAK,IAAI,MAAM,GAAG,CAAC,CAAC;AAAA,IACtC,GAAG,KAAK,IAAI,MAAM,KAAK,IAAI,MAAM,GAAG,CAAC,CAAC;AAAA,EACxC;AAEA,QAAM,cAAc;AAAA,IAClB,GAAG,KAAK,IAAI,MAAM,KAAK,IAAI,MAAM,GAAG,CAAC,CAAC;AAAA,IACtC,GAAG,KAAK,IAAI,MAAM,KAAK,IAAI,MAAM,GAAG,CAAC,CAAC;AAAA,EACxC;AAGA,QAAM,mBACH,YAAY,IAAI,GAAG,MAAM,KAAK,YAAY,IAAI,GAAG,MAAM;AAC1D,QAAM,mBACH,YAAY,IAAI,GAAG,MAAM,KAAK,YAAY,IAAI,GAAG,MAAM;AAG1D,QAAM,QAAQ;AAAA,IACZ,EAAE,OAAO,EAAE,GAAG,MAAM,GAAG,KAAK,GAAG,KAAK,EAAE,GAAG,MAAM,GAAG,KAAK,EAAE;AAAA;AAAA,IACzD,EAAE,OAAO,EAAE,GAAG,MAAM,GAAG,KAAK,GAAG,KAAK,EAAE,GAAG,MAAM,GAAG,KAAK,EAAE;AAAA;AAAA,IACzD,EAAE,OAAO,EAAE,GAAG,MAAM,GAAG,KAAK,GAAG,KAAK,EAAE,GAAG,MAAM,GAAG,KAAK,EAAE;AAAA;AAAA,IACzD,EAAE,OAAO,EAAE,GAAG,MAAM,GAAG,KAAK,GAAG,KAAK,EAAE,GAAG,MAAM,GAAG,KAAK,EAAE;AAAA;AAAA,EAC3D;AAEA,MAAI,cAAc,KAAK,IAAI,iBAAiB,eAAe;AAC3D,MAAI,eACF,mBAAmB,kBAAkB,cAAc;AAGrD,QAAMC,SAAQ,CAAC,OAAe,KAAa,QAAwB;AACjE,WAAO,KAAK,IAAI,KAAK,KAAK,IAAI,KAAK,KAAK,CAAC;AAAA,EAC3C;AAGA,aAAW,QAAQ,OAAO;AAExB,UAAM,KAAK,EAAE,GAAG,GAAG,IAAI,GAAG,GAAG,GAAG,GAAG,IAAI,GAAG,EAAE;AAC5C,UAAM,KAAK,EAAE,GAAG,KAAK,IAAI,IAAI,KAAK,MAAM,GAAG,GAAG,KAAK,IAAI,IAAI,KAAK,MAAM,EAAE;AACxE,UAAM,IAAI,EAAE,GAAG,GAAG,IAAI,KAAK,MAAM,GAAG,GAAG,GAAG,IAAI,KAAK,MAAM,EAAE;AAG3D,UAAM,QAAQ,GAAG,IAAI,GAAG,IAAI,GAAG,IAAI,GAAG;AACtC,UAAM,QAAQ,GAAG,IAAI,GAAG,IAAI,GAAG,IAAI,GAAG;AACtC,UAAM,QAAQ,GAAG,IAAI,EAAE,IAAI,GAAG,IAAI,EAAE;AACpC,UAAM,QAAQ,GAAG,IAAI,GAAG,IAAI,GAAG,IAAI,GAAG;AACtC,UAAM,QAAQ,GAAG,IAAI,EAAE,IAAI,GAAG,IAAI,EAAE;AAGpC,UAAM,cAAc,QAAQ,QAAQ,QAAQ;AAG5C,QAAI,KAAK,IAAI,WAAW,IAAI,MAAO;AAEnC,QAAI,MAAM,QAAQ,QAAQ,QAAQ,SAAS;AAC3C,QAAI,MAAM,QAAQ,QAAQ,QAAQ,SAAS;AAG3C,SAAKA,OAAM,IAAI,GAAG,CAAC;AACnB,SAAKA,OAAM,IAAI,GAAG,CAAC;AAGnB,UAAM,mBAAmB;AAAA,MACvB,GAAG,GAAG,IAAI,KAAK,GAAG;AAAA,MAClB,GAAG,GAAG,IAAI,KAAK,GAAG;AAAA,IACpB;AAEA,UAAM,gBAAgB;AAAA,MACpB,GAAG,KAAK,MAAM,IAAI,KAAK,GAAG;AAAA,MAC1B,GAAG,KAAK,MAAM,IAAI,KAAK,GAAG;AAAA,IAC5B;AAGA,UAAMC,MAAK,iBAAiB,IAAI,cAAc;AAC9C,UAAMC,MAAK,iBAAiB,IAAI,cAAc;AAC9C,UAAM,cAAcD,MAAKA,MAAKC,MAAKA;AAGnC,QAAI,cAAc,aAAa;AAC7B,oBAAc;AACd,qBAAe;AAAA,QACb,IAAI,iBAAiB,IAAI,cAAc,KAAK;AAAA,QAC5C,IAAI,iBAAiB,IAAI,cAAc,KAAK;AAAA,MAC9C;AAAA,IACF;AAAA,EACF;AAEA,SAAO;AACT;;;AChJA,SAAS,kBAAkB;AAEpB,SAAS,sBAAsB,KAA2B;AAC/D,MAAI,IAAI,SAAS,qBAAqB;AACpC,WAAO,CAAC,IAAI,KAAK;AAAA,EACnB;AACA,MAAI,IAAI,SAAS,cAAc;AAC7B,WAAO,CAAC,IAAI,KAAK;AAAA,EACnB;AACA,MAAI,IAAI,SAAS,mBAAmB;AAClC,WAAO,MAAM,QAAQ,IAAI,MAAM,IAAI,IAAI,SAAS,CAAC,GAAG,UAAU;AAAA,EAChE;AACA,MAAI,IAAI,SAAS,YAAY;AAC3B,WAAO,CAAC,GAAG,UAAU;AAAA,EACvB;AACA,MAAI,IAAI,SAAS,WAAW;AAC1B,WAAO,MAAM,QAAQ,IAAI,MAAM,IAAI,IAAI,SAAS,CAAC,GAAG,UAAU;AAAA,EAChE;AACA,MAAI,IAAI,SAAS,eAAe;AAC9B,WAAO,MAAM,QAAQ,IAAI,MAAM,IAAI,IAAI,SAAS,CAAC;AAAA,EACnD;AACA,SAAO,CAAC;AACV;;;ARYO,SAAS,gCACd,aACA;AAAA,EACE;AACF,IAEI,CAAC,GACY;AACjB,QAAM,SAA0B,CAAC;AACjC,cAAY,sCAAsC,WAAW;AAE7D,QAAM,YAAY,IAAI,WAAW,EAAE,UAAU,KAAK;AAClD,QAAM,mBAAmB,UAAU,QAAQ,CAAC,aAAa;AACvD,UAAM,WAA8B,CAAC;AACrC,aAAS,IAAI,GAAG,IAAI,SAAS,MAAM,SAAS,GAAG,KAAK;AAClD,YAAM,KAAK,SAAS,MAAM,CAAC;AAC3B,YAAM,KAAK,SAAS,MAAM,IAAI,CAAC;AAC/B,UAAI,GAAG,eAAe,OAAQ;AAC9B,UAAI,GAAG,eAAe,OAAQ;AAC9B,UAAI,GAAG,UAAU,GAAG,MAAO;AAC3B,eAAS,KAAK;AAAA,QACZ,MAAM;AAAA,QACN,cAAc,SAAS;AAAA,QACvB,WAAW;AAAA,QACX,WACE,WAAW,KACP,GAAG,QACH,WAAW,KACT,GAAG,QACH;AAAA,QACR,OAAO,GAAG;AAAA,QACV,IAAI,GAAG;AAAA,QACP,IAAI,GAAG;AAAA,QACP,IAAI,GAAG;AAAA,QACP,IAAI,GAAG;AAAA,MACT,CAAoB;AAAA,IACtB;AACA,WAAO;AAAA,EACT,CAAC;AACD,QAAM,aAAa,IAAI,WAAW,EAAE,WAAW,KAAK;AACpD,QAAM,iBAAiB,IAAI,WAAW,EAAE,gBAAgB,KAAK;AAC7D,QAAM,WAAW,IAAI,WAAW,EAAE,SAAS,KAAK;AAChD,QAAM,UAAU,IAAI,WAAW,EAAE,QAAQ,KAAK;AAC9C,QAAM,cAAc,IAAI,WAAW,EAAE,YAAY,KAAK;AAEtD,QAAM,aAA2B;AAAA,IAC/B,GAAG;AAAA,IACH,GAAG;AAAA,IACH,GAAG;AAAA,IACH,GAAG;AAAA,IACH,GAAG;AAAA,IACH,GAAG;AAAA,EACL;AAEA,QAAM,eAAe,IAAI,mBAA+B;AAAA,IACtD,SAAS;AAAA,IACT,WAAW;AAAA,EACb,CAAC;AAED,QAAM,kBAAkB,CAAC,OACvB,0BAA0B,aAAa,EAAE;AAE3C,QAAM,WAAW,oBAAI,IAAY;AAGjC,aAAW,YAAY,kBAAkB;AACvC,UAAM,iBAAiB;AACvB,UAAM,SAAS,oBAAoB,QAAQ;AAC3C,UAAM,gBAAgB,aAAa;AAAA,MACjC;AAAA,MACA,iBAAiB,SAAS,YAAY;AAAA,IACxC;AACA,QAAI,SAAS,OAAO,SAAS,MAAM,SAAS,OAAO,SAAS,GAAI;AAEhE,eAAW,OAAO,eAAe;AAE/B,UAAI,CAAC,sBAAsB,GAAG,EAAE,SAAS,SAAS,KAAK,GAAG;AACxD;AAAA,MACF;AACA,UAAI,IAAI,SAAS,qBAAqB;AACpC,cAAM,WAAW;AAEjB,YAAI,SAAS,UAAU,SAAS,MAAO;AAGvC,YACE,QAAQ,gBAAgB,SAAS,cAAc,SAAS,YAAY;AAEpE;AAEF,cAAMC,OACJ;AAAA,UACE,EAAE,GAAG,SAAS,IAAI,GAAG,SAAS,GAAG;AAAA,UACjC,EAAE,GAAG,SAAS,IAAI,GAAG,SAAS,GAAG;AAAA,UACjC,EAAE,GAAG,SAAS,IAAI,GAAG,SAAS,GAAG;AAAA,UACjC,EAAE,GAAG,SAAS,IAAI,GAAG,SAAS,GAAG;AAAA,QACnC,IACA,SAAS,YAAY,IACrB,SAAS,YAAY;AACvB,YAAIA,OAAM,uBAAuB,QAAS;AAE1C,cAAM,qBAAqB,WAAW,SAAS,YAAY,IAAI,SAAS,YAAY;AACpF,cAAM,6BAA6B,WAAW,SAAS,YAAY,IAAI,SAAS,YAAY;AAC5F,YAAI,SAAS,IAAI,kBAAkB,EAAG;AACtC,YAAI,SAAS,IAAI,0BAA0B,EAAG;AAE9C,iBAAS,IAAI,kBAAkB;AAC/B,eAAO,KAAK;AAAA,UACV,MAAM;AAAA,UACN,YAAY;AAAA,UACZ,SAAS,aAAa,gBAAgB,SAAS,YAAY,CAAC,kBAAkB,gBAAgB,SAAS,YAAY,CAAC,IAAIA,OAAM,IAAI,yBAAyB,SAASA,KAAI,QAAQ,CAAC,CAAC,KAAK;AAAA,UACvL,cAAc,SAAS;AAAA,UACvB,iBAAiB;AAAA,UACjB;AAAA,UACA,mBAAmB,CAAC;AAAA,UACpB,QAAQ,+BAA+B,UAAU,QAAQ;AAAA,UACzD,cAAc,+BAA+B;AAAA,YAC3C,SAAS;AAAA,YACT,SAAS;AAAA,UACX,CAAC;AAAA,QACH,CAAC;AACD;AAAA,MACF;AAEA,YAAM,eAAe,aAAa,GAAU;AAC5C,UACE,QAAQ;AAAA,QACN,SAAS;AAAA,QACT,kBAAkB,MAAO,IAAI,eAA0B;AAAA,MACzD;AAEA;AAEF,YAAM,aACJ,IAAI,SAAS,aACZ,IAAI,SAAS,qBAAqB,IAAI,UAAU,YACjD,IAAI,SAAS,cACZ,IAAI,SAAS,gBAAgB,IAAI,UAAU;AAE9C,UAAI,YAAY;AACd,cAAM,SAAS,8BAA8B,GAAG;AAChD,cAAMC,YAAW;AAAA,UACf,EAAE,GAAG,SAAS,IAAI,GAAG,SAAS,GAAG;AAAA,UACjC,EAAE,GAAG,SAAS,IAAI,GAAG,SAAS,GAAG;AAAA,UACjC,EAAE,GAAG,IAAI,GAAG,GAAG,IAAI,GAAG,OAAO;AAAA,QAC/B;AACA,cAAMD,OAAMC,YAAW,SAAS,YAAY;AAC5C,YAAID,OAAM,uBAAuB,QAAS;AAE1C,cAAM,qBAAqB,WAAW,SAAS,YAAY,IAAI,YAAY;AAC3E,YAAI,SAAS,IAAI,kBAAkB,EAAG;AACtC,iBAAS,IAAI,kBAAkB;AAC/B,eAAO,KAAK;AAAA,UACV,MAAM;AAAA,UACN,YAAY;AAAA,UACZ,SAAS,aAAa,gBAAgB,SAAS,YAAY,CAAC,kBAAkB,IAAI,IAAI,KAAK,gBAAgB,aAAa,GAAU,CAAC,CAAC,KAAKA,OAAM,IAAI,yBAAyB,SAASA,KAAI,QAAQ,CAAC,CAAC,KAAK;AAAA,UACxM,cAAc,SAAS;AAAA,UACvB,QAAQ;AAAA,YACN;AAAA,YACA,oBAAoB,GAAG;AAAA,UACzB;AAAA,UACA,iBAAiB;AAAA,UACjB;AAAA,UACA,mBAAmB;AAAA,YACjB,sBAAsB,MACjB,IAAI,mBACL;AAAA,UACN,EAAE,OAAO,OAAO;AAAA,UAChB,cAAc;AAAA,YACZ,GAAG,+BAA+B,CAAC,SAAS,SAAS,CAAC;AAAA,YACtD,iBAAiB,MAAM,IAAI,cAAc;AAAA,UAC3C,EAAE,OAAO,OAAO;AAAA,QAClB,CAAC;AAAA,MACH;AAIA,YAAM,MACJ;AAAA,QACE,EAAE,GAAG,SAAS,IAAI,GAAG,SAAS,GAAG;AAAA,QACjC,EAAE,GAAG,SAAS,IAAI,GAAG,SAAS,GAAG;AAAA,QACjC,oBAAoB,GAAG;AAAA,MACzB,IACA,SAAS,YAAY;AACvB,UAAI,MAAM,UAAU,gBAAgB;AAClC,cAAM,qBAAqB,WAAW,SAAS,YAAY,IAAI,YAAY;AAC3E,YAAI,SAAS,IAAI,kBAAkB,EAAG;AACtC,iBAAS,IAAI,kBAAkB;AAC/B,eAAO,KAAK;AAAA,UACV,MAAM;AAAA,UACN,YAAY;AAAA,UACZ,SAAS,aAAa,gBAAgB,SAAS,YAAY,CAAC,kBAAkB,IAAI,IAAI,KAAK,gBAAgB,aAAa,GAAU,CAAC,CAAC,KAAK,MAAM,IAAI,yBAAyB,SAAS,IAAI,QAAQ,CAAC,CAAC,KAAK;AAAA,UACxM,cAAc,SAAS;AAAA,UACvB,iBAAiB;AAAA,UACjB;AAAA,UACA,mBAAmB;AAAA,YACjB,sBAAsB,MAAM,IAAI,mBAAmB;AAAA,UACrD,EAAE,OAAO,OAAO;AAAA,UAChB,QAAQ;AAAA,YACN;AAAA,YACA,oBAAoB,GAAG;AAAA,UACzB;AAAA,UACA,cAAc;AAAA,YACZ,GAAG,+BAA+B,CAAC,SAAS,SAAS,CAAC;AAAA,YACtD,iBAAiB,MAAM,IAAI,cAAc;AAAA,UAC3C,EAAE,OAAO,OAAO;AAAA,QAClB,CAAC;AAAA,MACH;AAAA,IACF;AAAA,EACF;AACA,SAAO;AACT;;;AStPO,IAAM,aAAN,MAAiB;AAAA,EACd,WAA6B,oBAAI,IAAI;AAAA,EAE7C,aAAa,OAAuB;AAClC,QAAI,MAAM,SAAS,EAAG;AAEtB,QAAI,gBAAoC;AAGxC,eAAW,WAAW,KAAK,UAAU;AACnC,iBAAW,QAAQ,OAAO;AACxB,YAAI,QAAQ,IAAI,IAAI,GAAG;AACrB,cAAI,kBAAkB,MAAM;AAC1B,4BAAgB;AAAA,UAClB,WAAW,kBAAkB,SAAS;AAEpC,uBAAW,aAAa,SAAS;AAC/B,4BAAc,IAAI,SAAS;AAAA,YAC7B;AACA,iBAAK,SAAS,OAAO,OAAO;AAAA,UAC9B;AACA;AAAA,QACF;AAAA,MACF;AACA,UAAI,kBAAkB,QAAQ,kBAAkB,QAAS;AAAA,IAC3D;AAGA,QAAI,kBAAkB,MAAM;AAC1B,sBAAgB,IAAI,IAAI,KAAK;AAC7B,WAAK,SAAS,IAAI,aAAa;AAAA,IACjC,OAAO;AAEL,iBAAW,QAAQ,OAAO;AACxB,sBAAc,IAAI,IAAI;AAAA,MACxB;AAAA,IACF;AAAA,EACF;AAAA,EAEA,YAAY,OAA0B;AACpC,QAAI,MAAM,SAAS,EAAG,QAAO;AAE7B,eAAW,WAAW,KAAK,UAAU;AACnC,UAAI,MAAM,MAAM,CAAC,SAAS,QAAQ,IAAI,IAAI,CAAC,GAAG;AAC5C,eAAO;AAAA,MACT;AAAA,IACF;AAEA,WAAO;AAAA,EACT;AACF;;;AC5CA,SAAS,6BAAAE,kCAAiC;AAGnC,SAAS,kBACd,aACqB;AACrB,QAAM,QAAQ,YAAY,KAAK,CAAC,OAAO,GAAG,SAAS,WAAW;AAE9D,MAAI,CAAC,MAAO,QAAO,CAAC;AAEpB,QAAM,OAAO,YAAY,OAAO,CAAC,OAAO,GAAG,SAAS,SAAS;AAE7D,MAAI,KAAK,WAAW,EAAG,QAAO,CAAC;AAE/B,QAAM,YAAY,MAAM,OAAO,IAAI,MAAM,QAAQ;AACjD,QAAM,YAAY,MAAM,OAAO,IAAI,MAAM,QAAQ;AACjD,QAAM,YAAY,MAAM,OAAO,IAAI,MAAM,SAAS;AAClD,QAAM,YAAY,MAAM,OAAO,IAAI,MAAM,SAAS;AAElD,QAAM,SAA8B,CAAC;AAErC,aAAW,OAAO,MAAM;AACtB,UAAM,YAAY,IAAI,iBAAiB;AACvC,UAAM,UAAU,IAAI,IAAI;AACxB,UAAM,UAAU,IAAI,IAAI;AACxB,UAAM,UAAU,IAAI,IAAI;AACxB,UAAM,UAAU,IAAI,IAAI;AAExB,QACE,UAAU,YAAY,4BACtB,UAAU,YAAY,4BACtB,UAAU,YAAY,4BACtB,UAAU,YAAY,0BACtB;AACA,YAAM,UAAUC,2BAA0B,aAAa,IAAI,UAAU;AACrE,aAAO,KAAK;AAAA,QACV,MAAM;AAAA,QACN,wBAAwB,gBAAgB,IAAI,UAAU;AAAA,QACtD,SAAS,OAAO,OAAO;AAAA,QACvB,YAAY;AAAA,MACd,CAAC;AAAA,IACH;AAAA,EACF;AAEA,SAAO;AACT;;;AClDA,SAAS,6BAAAC,kCAAiC;AAC1C;AAAA,EACE,yCAAAC;AAAA,OAEK;AAGP,SAASC,UAAS,GAAW,GAAmB;AAC9C,SAAO,KAAK,MAAM,EAAE,IAAI,EAAE,GAAG,EAAE,IAAI,EAAE,CAAC;AACxC;AAEO,SAAS,uBACd,aACA;AAAA,EACE;AAAA,EACA,aAAa;AACf,IAAwD,CAAC,GACpC;AACrB,QAAM,OAAO,YAAY,OAAO,CAAC,OAAO,GAAG,SAAS,SAAS;AAC7D,MAAI,KAAK,SAAS,EAAG,QAAO,CAAC;AAC7B,cAAYC,uCAAsC,WAAW;AAC7D,QAAM,SAA8B,CAAC;AACrC,QAAM,WAAW,oBAAI,IAAY;AAEjC,WAAS,IAAI,GAAG,IAAI,KAAK,QAAQ,KAAK;AACpC,aAAS,IAAI,IAAI,GAAG,IAAI,KAAK,QAAQ,KAAK;AACxC,YAAM,OAAO,KAAK,CAAC;AACnB,YAAM,OAAO,KAAK,CAAC;AACnB,UAAI,CAAC,QAAQ,gBAAgB,KAAK,YAAY,KAAK,UAAU,EAAG;AAChE,YAAM,MACJD,UAAS,MAAM,IAAI,IAAI,KAAK,iBAAiB,IAAI,KAAK,iBAAiB;AACzE,UAAI,MAAM,WAAW,WAAY;AACjC,YAAM,SAAS,CAAC,KAAK,YAAY,KAAK,UAAU,EAAE,KAAK,EAAE,KAAK,GAAG;AACjE,UAAI,SAAS,IAAI,MAAM,EAAG;AAC1B,eAAS,IAAI,MAAM;AACnB,aAAO,KAAK;AAAA,QACV,MAAM;AAAA,QACN,wBAAwB,uBAAuB,MAAM;AAAA,QACrD,SAAS,QAAQE;AAAA,UACf;AAAA,UACA,KAAK;AAAA,QACP,CAAC,QAAQA;AAAA,UACP;AAAA,UACA,KAAK;AAAA,QACP,CAAC,iCAAiC,IAAI,QAAQ,CAAC,CAAC;AAAA,QAChD,YAAY;AAAA,MACd,CAAC;AAAA,IACH;AAAA,EACF;AAEA,SAAO;AACT;;;ACnDA,SAAS,6BAAAC,kCAAiC;AAC1C,SAAS,+BAAAC,oCAAmC;AAiBrC,SAAS,kBACd,aACA,EAAE,aAAa,qBAAqB,IAA6B,CAAC,GACjD;AACjB,QAAM,SAAS,YAAY;AAAA,IACzB,CAAC,OAAO,GAAG,SAAS;AAAA,EACtB;AACA,QAAM,WAA2B,CAAC;AAElC,aAAW,SAAS,QAAQ;AAC1B,aAAS,IAAI,GAAG,IAAI,MAAM,MAAM,SAAS,GAAG,KAAK;AAC/C,YAAM,IAAI,MAAM,MAAM,CAAC;AACvB,YAAM,IAAI,MAAM,MAAM,IAAI,CAAC;AAC3B,UAAI,EAAE,eAAe,UAAU,EAAE,eAAe,OAAQ;AACxD,UAAI,EAAE,UAAU,EAAE,MAAO;AACzB,YAAM,YACJ,WAAW,IACN,EAAU,QACX,WAAW,IACR,EAAU,QACX;AACR,eAAS,KAAK;AAAA,QACZ,cAAc,MAAM;AAAA,QACpB,OAAO,EAAE;AAAA,QACT;AAAA,QACA,IAAI,EAAE;AAAA,QACN,IAAI,EAAE;AAAA,QACN,IAAI,EAAE;AAAA,QACN,IAAI,EAAE;AAAA,MACR,CAAC;AAAA,IACH;AAAA,EACF;AAEA,QAAM,SAA0B,CAAC;AAEjC,WAAS,IAAI,GAAG,IAAI,SAAS,QAAQ,KAAK;AACxC,aAAS,IAAI,IAAI,GAAG,IAAI,SAAS,QAAQ,KAAK;AAC5C,YAAM,OAAO,SAAS,CAAC;AACvB,YAAM,OAAO,SAAS,CAAC;AACvB,UAAI,KAAK,iBAAiB,KAAK,aAAc;AAC7C,UAAI,KAAK,UAAU,KAAK,MAAO;AAC/B,YAAMC,YAAWC;AAAA,QACf,EAAE,GAAG,KAAK,IAAI,GAAG,KAAK,GAAG;AAAA,QACzB,EAAE,GAAG,KAAK,IAAI,GAAG,KAAK,GAAG;AAAA,QACzB,EAAE,GAAG,KAAK,IAAI,GAAG,KAAK,GAAG;AAAA,QACzB,EAAE,GAAG,KAAK,IAAI,GAAG,KAAK,GAAG;AAAA,MAC3B;AACA,YAAM,MAAMD,YAAW,KAAK,YAAY,IAAI,KAAK,YAAY;AAC7D,UAAI,MAAM,WAAW,WAAY;AACjC,aAAO,KAAK;AAAA,QACV,MAAM;AAAA,QACN,YAAY;AAAA,QACZ,SAAS,aAAaE;AAAA,UACpB;AAAA,UACA,KAAK;AAAA,QACP,CAAC,oBAAoBA;AAAA,UACnB;AAAA,UACA,KAAK;AAAA,QACP,CAAC,UAAU,IAAI,QAAQ,CAAC,CAAC;AAAA,QACzB,cAAc,KAAK;AAAA,QACnB,oBAAoB,iBAAiB,KAAK,YAAY,IAAI,KAAK,YAAY;AAAA,QAC3E,iBAAiB;AAAA,QACjB,mBAAmB,CAAC;AAAA,QACpB,cAAc,CAAC;AAAA,MACjB,CAAC;AAAA,IACH;AAAA,EACF;AAEA,SAAO;AACT;;;AClFO,SAAS,6BACd,aACqB;AACrB,QAAM,QAAQ,YAAY,KAAK,CAAC,OAAO,GAAG,SAAS,WAAW;AAE9D,MAAI,CAAC,MAAO,QAAO,CAAC;AAEpB,QAAM,aAAa,YAAY,OAAO,CAAC,OAAO,GAAG,SAAS,eAAe;AAEzE,QAAM,YAAY,MAAM,OAAO,IAAI,MAAM,QAAQ;AACjD,QAAM,YAAY,MAAM,OAAO,IAAI,MAAM,QAAQ;AACjD,QAAM,YAAY,MAAM,OAAO,IAAI,MAAM,SAAS;AAClD,QAAM,YAAY,MAAM,OAAO,IAAI,MAAM,SAAS;AAElD,QAAM,SAA8B,CAAC;AAErC,aAAW,QAAQ,YAAY;AAC7B,UAAM,OAAO,KAAK,OAAO,IAAI,KAAK,QAAQ;AAC1C,UAAM,OAAO,KAAK,OAAO,IAAI,KAAK,QAAQ;AAC1C,UAAM,OAAO,KAAK,OAAO,IAAI,KAAK,SAAS;AAC3C,UAAM,OAAO,KAAK,OAAO,IAAI,KAAK,SAAS;AAE3C,QACE,OAAO,aACP,OAAO,aACP,OAAO,aACP,OAAO,WACP;AACA,YAAM,kBAAkB,YAAY;AAAA,QAClC,CAAC,OACC,GAAG,SAAS,sBACZ,GAAG,wBAAwB,KAAK;AAAA,MACpC;AACA,YAAM,iBAAiB,iBAAiB,SAAS,WAAW;AAAA,QAC1D;AAAA,QACA;AAAA,MACF;AACA,aAAO,KAAK;AAAA,QACV,MAAM;AAAA,QACN,wBAAwB,gBAAgB,KAAK,gBAAgB;AAAA,QAC7D,SAAS,aAAa,aAAa,IAAI,gBAAiB,IAAI;AAAA,QAC5D,YAAY;AAAA,MACd,CAAC;AAAA,IACH;AAAA,EACF;AAEA,SAAO;AACT;;;ACnDA,SAASC,UAAS,IAAY,IAAY,IAAY,IAAoB;AACxE,SAAO,KAAK,MAAM,KAAK,OAAO,KAAK,KAAK,OAAO,CAAC;AAClD;AAEO,SAAS,aACd,OACA,KACS;AACT,MAAI,IAAI,SAAS,cAAc;AAC7B,QAAI,IAAI,UAAU,UAAU;AAC1B,aAAOA,UAAS,MAAM,GAAG,MAAM,GAAG,IAAI,GAAG,IAAI,CAAC,KAAK,IAAI;AAAA,IACzD;AAEA,QAAI,IAAI,UAAU,QAAQ;AACxB,YAAM,YAAY,IAAI,QAAQ;AAC9B,YAAM,aAAa,IAAI,SAAS;AAChC,aACE,KAAK,IAAI,MAAM,IAAI,IAAI,CAAC,KAAK,aAC7B,KAAK,IAAI,MAAM,IAAI,IAAI,CAAC,KAAK;AAAA,IAEjC;AAEA,QAAI,IAAI,UAAU,gBAAgB;AAChC,YAAM,KAAK,MAAM,IAAI,IAAI;AACzB,YAAM,KAAK,MAAM,IAAI,IAAI;AACzB,YAAM,QAAQ,CAAC,IAAI;AACnB,YAAM,WAAW,KAAK,KAAK,IAAI,KAAK,IAAI,KAAK,KAAK,IAAI,KAAK;AAC3D,YAAM,WAAW,KAAK,KAAK,IAAI,KAAK,IAAI,KAAK,KAAK,IAAI,KAAK;AAC3D,aACE,KAAK,IAAI,QAAQ,KAAK,IAAI,QAAQ,KAClC,KAAK,IAAI,QAAQ,KAAK,IAAI,SAAS;AAAA,IAEvC;AAEA,QAAI,IAAI,UAAU,QAAQ;AACxB,YAAM,YAAY,IAAI,QAAQ;AAC9B,YAAM,aAAa,IAAI,SAAS;AAChC,YAAM,SAAS,IAAI;AAEnB,UACE,KAAK,IAAI,MAAM,IAAI,IAAI,CAAC,KAAK,YAAY,UACzC,KAAK,IAAI,MAAM,IAAI,IAAI,CAAC,KAAK,YAC7B;AACA,eAAO;AAAA,MACT;AAEA,YAAM,UAAU,KAAK;AAAA,QACnB,KAAK,IAAI,MAAM,IAAI,IAAI,CAAC,KAAK,YAAY;AAAA,QACzC;AAAA,MACF;AACA,YAAM,UAAU,KAAK;AAAA,QACnB,KAAK,IAAI,MAAM,IAAI,IAAI,CAAC,KAAK,aAAa;AAAA,QAC1C;AAAA,MACF;AACA,aAAO,UAAU,UAAU,UAAU,WAAW,SAAS;AAAA,IAC3D;AAAA,EACF;AAEA,MAAI,IAAI,SAAS,mBAAmB;AAClC,QAAI,IAAI,UAAU,UAAU;AAC1B,aAAOA,UAAS,MAAM,GAAG,MAAM,GAAG,IAAI,GAAG,IAAI,CAAC,KAAK,IAAI,iBAAiB;AAAA,IAC1E;AAEA,QAAI,IAAI,UAAU,UAAU,IAAI,UAAU,QAAQ;AAChD,aACE,KAAK,IAAI,MAAM,IAAI,IAAI,CAAC,KAAK,IAAI,cAAc,KAC/C,KAAK,IAAI,MAAM,IAAI,IAAI,CAAC,KAAK,IAAI,eAAe;AAAA,IAEpD;AAEA,QAAI,IAAI,UAAU,+BAA+B;AAC/C,aACE,KAAK,IAAI,MAAM,IAAI,IAAI,CAAC,KAAK,IAAI,iBAAiB,KAClD,KAAK,IAAI,MAAM,IAAI,IAAI,CAAC,KAAK,IAAI,kBAAkB;AAAA,IAEvD;AAEA,QAAI,IAAI,UAAU,2BAA2B;AAC3C,aACE,KAAK,IAAI,MAAM,IAAI,IAAI,CAAC,KAAK,IAAI,iBAAiB,KAClD,KAAK,IAAI,MAAM,IAAI,IAAI,CAAC,KAAK,IAAI,kBAAkB;AAAA,IAEvD;AAAA,EACF;AAEA,SAAO;AACT;;;AC9EA,SAAS,6BAAAC,kCAAiC;AAE1C,SAAS,yBACP,aACiB;AACjB,QAAM,SAA0B,CAAC;AAEjC,QAAM,WAAW,YAAY;AAAA,IAC3B,CAAC,OAAO,GAAG,SAAS;AAAA,EACtB;AACA,QAAM,YAAY,YAAY;AAAA,IAC5B,CAAC,OAAO,GAAG,SAAS;AAAA,EACtB;AACA,QAAM,eAAe,YAAY;AAAA,IAC/B,CAAC,OAAO,GAAG,SAAS;AAAA,EACtB;AACA,QAAM,aAAa,YAAY;AAAA,IAC7B,CAAC,OAAO,GAAG,SAAS;AAAA,EACtB;AACA,QAAM,iBAAiB,YAAY;AAAA,IACjC,CAAC,OAAO,GAAG,SAAS;AAAA,EACtB;AAEA,QAAM,SAAS,oBAAI,IAAuC;AAE1D,aAAW,OAAO,YAAY;AAC5B,QAAI,IAAI,aAAa;AACnB,aAAO,IAAI,IAAI,aAAa,GAAG;AAAA,IACjC;AAAA,EACF;AAEA,aAAW,QAAQ,gBAAgB;AACjC,QAAI,KAAK,aAAa;AACpB,aAAO,IAAI,KAAK,aAAa,IAAI;AAAA,IACnC;AAAA,EACF;AAEA,aAAW,SAAS,WAAW;AAC7B,QAAI,MAAM,MAAM,WAAW,EAAG;AAE9B,UAAM,aAAa,MAAM,MAAM,CAAC;AAChC,UAAM,YAAY,MAAM,MAAM,MAAM,MAAM,SAAS,CAAC;AAEpD,UAAM,cAAc,aAAa;AAAA,MAC/B,CAAC,OAAO,GAAG,oBAAoB,MAAM;AAAA,IACvC;AAEA,QAAI,CAAC,YAAa;AAElB,UAAM,gBAAgB,SAAS;AAAA,MAAO,CAAC,SACrC,YAAY,2BAA2B,SAAS,KAAK,cAAc;AAAA,IACrE;AAEA,aAAS,IAAI,GAAG,IAAI,MAAM,MAAM,SAAS,GAAG,KAAK;AAC/C,YAAM,YAAY,MAAM,MAAM,IAAI,CAAC;AACnC,YAAM,eAAe,MAAM,MAAM,CAAC;AAClC,YAAM,YAAY,MAAM,MAAM,IAAI,CAAC;AAEnC,UAAI,aAAa,eAAe,OAAO;AACrC,cAAM,aAAa,UAAU,eAAe;AAC5C,cAAM,aAAa,UAAU,eAAe;AAE5C,YAAI,cAAc,YAAY;AAC5B,gBAAM,cACJ,KAAK,IAAI,UAAU,IAAI,aAAa,CAAC,IAAI,QACzC,KAAK,IAAI,UAAU,IAAI,aAAa,CAAC,IAAI;AAE3C,gBAAM,cACJ,KAAK,IAAI,UAAU,IAAI,aAAa,CAAC,IAAI,QACzC,KAAK,IAAI,UAAU,IAAI,aAAa,CAAC,IAAI;AAE3C,cAAI,CAAC,eAAe,CAAC,aAAa;AAChC,kBAAM,YAAY,YAAY;AAC9B,mBAAO,KAAK;AAAA,cACV,MAAM;AAAA,cACN,SAAS,iBAAiB,SAAS,mCAAmC,aAAa,CAAC,QAAQ,aAAa,CAAC;AAAA,cAC1G,iBAAiB,YAAY;AAAA,cAC7B,YAAY;AAAA,cACZ,cAAc,MAAM;AAAA,cACpB,oBAAoB;AAAA,cACpB,mBAAmB,CAAC;AAAA,cACpB,cAAc,CAAC;AAAA,YACjB,CAAC;AAAA,UACH;AAAA,QACF;AAAA,MACF;AAAA,IACF;AAEA,eAAW,QAAQ,eAAe;AAChC,UAAI,CAAC,KAAK,YAAa;AAEvB,YAAM,MAAM,OAAO,IAAI,KAAK,WAAW;AAEvC,UAAI,CAAC,IAAK;AAEV,YAAM,wBACJ,WAAW,eAAe,UAC1B,aAAa,EAAE,GAAG,WAAW,GAAG,GAAG,WAAW,EAAE,GAAG,GAAG;AAExD,YAAM,uBACJ,UAAU,eAAe,UACzB,aAAa,EAAE,GAAG,UAAU,GAAG,GAAG,UAAU,EAAE,GAAG,GAAG;AAEtD,UAAI,CAAC,yBAAyB,CAAC,sBAAsB;AACnD,cAAM,YAAY,YAAY;AAC9B,cAAM,WAAWA;AAAA,UACf;AAAA,UACA,KAAK;AAAA,QACP,EAAE,QAAQ,YAAY,EAAE;AACxB,cAAM,UAAU,IAAI,KAAK,QAAQ,QAAQ,EAAE;AAC3C,eAAO,KAAK;AAAA,UACV,MAAM;AAAA,UACN,SAAS,UAAU,SAAS,gCAAgC,OAAO,GAAG,QAAQ;AAAA,UAC9E,iBAAiB,YAAY;AAAA,UAC7B,YAAY;AAAA,UACZ,cAAc,MAAM;AAAA,UACpB,oBAAoB;AAAA,UACpB,mBAAmB,CAAC;AAAA,UACpB,cAAc,CAAC,KAAK,WAAW;AAAA,QACjC,CAAC;AAAA,MACH;AAAA,IACF;AAAA,EACF;AAEA,SAAO;AACT;;;AChIA,eAAsB,aAAa,aAAoB;AACrD,SAAO;AAAA,IACL,GAAG,0BAA0B,WAAW;AAAA,IACxC,GAAG,gCAAgC,WAAW;AAAA,IAC9C,GAAG,uBAAuB,WAAW;AAAA,IACrC,GAAG,kBAAkB,WAAW;AAAA,IAChC,GAAG,6BAA6B,WAAW;AAAA,IAC3C,GAAG,yBAAyB,WAAW;AAAA,EACzC;AACF;","names":["t","closestOnB","closestOnA","distance","clamp","dx","dy","gap","distance","getReadableNameForElement","getReadableNameForElement","getReadableNameForElement","getFullConnectivityMapFromCircuitJson","distance","getFullConnectivityMapFromCircuitJson","getReadableNameForElement","getReadableNameForElement","segmentToSegmentMinDistance","distance","segmentToSegmentMinDistance","getReadableNameForElement","distance","getReadableNameForPcbPort"]}