{"version":3,"sources":["../v2/lib/util.ts","../v2/lib/GeneralizedAstar.ts","../../../module/lib/solver-utils/getObstaclesFromRoute.ts","../v2/lib/ObstacleList.ts","../../../module/lib/solver-postprocessing/remove-path-loops.ts","../../../module/lib/solver-postprocessing/add-vias-when-layer-changes.ts","../v2/lib/shortenPathWithShortcuts.ts","../v2/lib/getDistanceToOvercomeObstacle.ts","../v2/lib/IJumpAutorouter.ts","../../../module/lib/solver-utils/getSimpleRouteJson.ts","../../../module/lib/solver-utils/generateApproximatingRects.ts","../../../module/lib/solver-utils/getObstaclesFromCircuitJson.ts","../../../module/lib/solver-utils/timer.ts","../../../module/lib/solver-utils/getAlternativeGoalBoxes.ts","../v2/lib/IJumpMultiMarginAutorouter.ts","../../multi-layer-ijump/util.ts","../../multi-layer-ijump/ObstacleList3d.ts","../../multi-layer-ijump/MultilayerIjump.ts","../../multi-layer-ijump/index.ts","../v2/index.ts"],"sourcesContent":["import type { Direction, Point } from \"./types\"\n\nexport const clamp = (min: number, max: number, value: number) => {\n  return Math.min(Math.max(min, value), max)\n}\n\nexport const manDist = (a: Point, b: Point): number => {\n  return Math.abs(a.x - b.x) + Math.abs(a.y - b.y)\n}\n\nexport const dist = (a: Point, b: Point): number => {\n  return ((a.x - b.x) ** 2 + (a.y - b.y) ** 2) ** 0.5\n}\n\nexport const dirFromAToB = (a: Point, b: Point): { dx: number; dy: number } => {\n  const dx = b.x - a.x\n  const dy = b.y - a.y\n\n  if (Math.abs(dx) > Math.abs(dy)) {\n    return { dx: Math.sign(dx), dy: 0 }\n  } else {\n    return { dx: 0, dy: Math.sign(dy) }\n  }\n}\n\nexport const distAlongDir = (A: Point, B: Point, dir: Direction): number => {\n  return (\n    Math.abs(A.x - B.x) * Math.abs(dir.dx) +\n    Math.abs(A.y - B.y) * Math.abs(dir.dy)\n  )\n}\n\nexport const nodeName = (node: Point, GRID_STEP: number = 0.1): string =>\n  `${Math.round(node.x / GRID_STEP)},${Math.round(node.y / GRID_STEP)}`\n","import type { AnySoupElement, LayerRef, PCBSMTPad } from \"circuit-json\"\n// import { QuadtreeObstacleList } from \"./QuadtreeObstacleList\"\nimport type { Node, Point, PointWithObstacleHit } from \"./types\"\nimport { manDist, nodeName } from \"./util\"\n\nimport Debug from \"debug\"\nimport type {\n  Obstacle,\n  SimpleRouteConnection,\n  SimpleRouteJson,\n  SimplifiedPcbTrace,\n} from \"solver-utils\"\nimport { getObstaclesFromRoute } from \"solver-utils/getObstaclesFromRoute\"\nimport { ObstacleList } from \"./ObstacleList\"\nimport { removePathLoops } from \"solver-postprocessing/remove-path-loops\"\nimport { addViasWhenLayerChanges } from \"solver-postprocessing/add-vias-when-layer-changes\"\nimport type { AnyCircuitElement } from \"circuit-json\"\nimport { shortenPathWithShortcuts } from \"./shortenPathWithShortcuts\"\nimport type { ObstacleList3d } from \"algos/multi-layer-ijump/ObstacleList3d\"\n\nconst debug = Debug(\"autorouting-dataset:astar\")\n\nexport interface PointWithLayer extends Point {\n  layer: string\n}\n\nexport type ConnectionSolveResult =\n  | { solved: false; connectionName: string }\n  | { solved: true; connectionName: string; route: PointWithLayer[] }\n\nexport class GeneralizedAstarAutorouter {\n  openSet: Node[] = []\n  closedSet: Set<string> = new Set()\n  debug = false\n\n  debugSolutions?: Record<string, AnyCircuitElement[]>\n  debugMessage: string | null = null\n  debugTraceCount: number = 0\n\n  input: SimpleRouteJson\n  obstacles?: ObstacleList\n  allObstacles: Obstacle[]\n  startNode?: Node\n  goalPoint?: Point & { l: number }\n  GRID_STEP: number\n  OBSTACLE_MARGIN: number\n  MAX_ITERATIONS: number\n  isRemovePathLoopsEnabled: boolean\n  isShortenPathWithShortcutsEnabled: boolean\n  /**\n   * Setting this greater than 1 makes the algorithm find suboptimal paths and\n   * act more greedy, but at greatly improves performance.\n   *\n   * Recommended value is between 1.1 and 1.5\n   */\n  GREEDY_MULTIPLIER = 1.1\n\n  iterations: number = -1\n\n  constructor(opts: {\n    input: SimpleRouteJson\n    startNode?: Node\n    goalPoint?: Point\n    GRID_STEP?: number\n    OBSTACLE_MARGIN?: number\n    MAX_ITERATIONS?: number\n    isRemovePathLoopsEnabled?: boolean\n    isShortenPathWithShortcutsEnabled?: boolean\n    debug?: boolean\n  }) {\n    this.input = opts.input\n    this.allObstacles = opts.input.obstacles\n    this.startNode = opts.startNode\n    this.goalPoint = opts.goalPoint\n      ? ({ l: 0, ...opts.goalPoint } as any)\n      : undefined\n    this.GRID_STEP = opts.GRID_STEP ?? 0.1\n    this.OBSTACLE_MARGIN = opts.OBSTACLE_MARGIN ?? 0.15\n    this.MAX_ITERATIONS = opts.MAX_ITERATIONS ?? 100\n    this.debug = opts.debug ?? debug.enabled\n    this.isRemovePathLoopsEnabled = opts.isRemovePathLoopsEnabled ?? false\n    this.isShortenPathWithShortcutsEnabled =\n      opts.isShortenPathWithShortcutsEnabled ?? false\n    if (this.debug) {\n      debug.enabled = true\n    }\n\n    if (debug.enabled) {\n      this.debugSolutions = {}\n      this.debugMessage = \"\"\n    }\n  }\n\n  /**\n   * Return points of interest for this node. Don't worry about checking if\n   * points are already visited. You must check that these neighbors are valid\n   * (not inside an obstacle)\n   *\n   * In a simple grid, this is just the 4 neighbors surrounding the node.\n   *\n   * In ijump-astar, this is the 2-4 surrounding intersections\n   */\n  getNeighbors(node: Node): Array<PointWithObstacleHit> {\n    return []\n  }\n\n  isSameNode(a: Point, b: Point): boolean {\n    return manDist(a, b) < this.GRID_STEP\n  }\n\n  /**\n   * Compute the cost of this path. In normal astar, this is just the length of\n   * the path, but you can override this term to penalize paths that are more\n   * complex.\n   */\n  computeG(current: Node, neighbor: Point): number {\n    return current.g + manDist(current, neighbor)\n  }\n\n  computeH(node: Point): number {\n    return manDist(node, this.goalPoint!)\n  }\n\n  getNodeName(node: Point): string {\n    return nodeName(node, this.GRID_STEP)\n  }\n\n  solveOneStep(): {\n    solved: boolean\n    current: Node\n    newNeighbors: Node[]\n  } {\n    this.iterations += 1\n    const { openSet, closedSet, GRID_STEP, goalPoint } = this\n    openSet.sort((a, b) => a.f - b.f)\n\n    const current = openSet.shift()!\n    const goalDist = this.computeH(current)\n    if (goalDist <= GRID_STEP * 2) {\n      return {\n        solved: true,\n        current,\n        newNeighbors: [],\n      }\n    }\n\n    this.closedSet.add(this.getNodeName(current))\n\n    let newNeighbors: Node[] = []\n    for (const neighbor of this.getNeighbors(current)) {\n      if (closedSet.has(this.getNodeName(neighbor))) continue\n\n      const tentativeG = this.computeG(current, neighbor)\n\n      const existingNeighbor = this.openSet.find((n) =>\n        this.isSameNode(n, neighbor),\n      )\n\n      if (!existingNeighbor || tentativeG < existingNeighbor.g) {\n        const h = this.computeH(neighbor)\n\n        const f = tentativeG + h * this.GREEDY_MULTIPLIER\n\n        const neighborNode: Node = {\n          ...neighbor,\n          g: tentativeG,\n          h,\n          f,\n          obstacleHit: neighbor.obstacleHit ?? undefined,\n          manDistFromParent: manDist(current, neighbor), // redundant compute...\n          nodesInPath: current.nodesInPath + 1,\n          parent: current,\n          enterMarginCost: neighbor.enterMarginCost,\n          travelMarginCostFactor: neighbor.travelMarginCostFactor,\n        }\n\n        openSet.push(neighborNode)\n        newNeighbors.push(neighborNode)\n      }\n    }\n\n    if (debug.enabled) {\n      openSet.sort((a, b) => a.f - b.f)\n      this.drawDebugSolution({ current, newNeighbors })\n    }\n\n    return {\n      solved: false,\n      current,\n      newNeighbors,\n    }\n  }\n\n  getStartNode(connection: SimpleRouteConnection): Node {\n    return {\n      x: connection.pointsToConnect[0].x,\n      y: connection.pointsToConnect[0].y,\n      manDistFromParent: 0,\n      f: 0,\n      g: 0,\n      h: 0,\n      nodesInPath: 0,\n      parent: null,\n    }\n  }\n\n  layerToIndex(layer: string): number {\n    return 0\n  }\n  indexToLayer(index: number): string {\n    return \"top\"\n  }\n\n  /**\n   * Add a preprocessing step before solving a connection to do adjust points\n   * based on previous iterations. For example, if a previous connection solved\n   * for a trace on the same net, you may want to preprocess the connection to\n   * solve for an easier start and end point\n   *\n   * The simplest way to do this is to run getConnectionWithAlternativeGoalBoxes\n   * with any pcb_traces created by previous iterations\n   */\n  preprocessConnectionBeforeSolving(\n    connection: SimpleRouteConnection,\n  ): SimpleRouteConnection {\n    return connection\n  }\n\n  solveConnection(connection: SimpleRouteConnection): ConnectionSolveResult {\n    if (connection.pointsToConnect.length > 2) {\n      throw new Error(\n        \"GeneralizedAstarAutorouter doesn't currently support 2+ points in a connection\",\n      )\n    }\n    connection = this.preprocessConnectionBeforeSolving(connection)\n\n    const { pointsToConnect } = connection\n\n    this.iterations = 0\n    this.closedSet = new Set()\n    this.startNode = this.getStartNode(connection)\n    this.goalPoint = {\n      ...pointsToConnect[pointsToConnect.length - 1],\n      l: this.layerToIndex(pointsToConnect[pointsToConnect.length - 1].layer),\n    }\n    this.openSet = [this.startNode]\n\n    while (this.iterations < this.MAX_ITERATIONS) {\n      const { solved, current } = this.solveOneStep()\n\n      if (solved) {\n        let route: PointWithLayer[] = []\n        let node: Node | null = current\n        while (node) {\n          const l: number | undefined = (node as any).l\n          route.unshift({\n            x: node.x,\n            y: node.y,\n            // TODO: this layer should be included as part of the node\n            layer:\n              l !== undefined ? this.indexToLayer(l) : pointsToConnect[0].layer,\n          })\n          node = node.parent\n        }\n\n        if (debug.enabled) {\n          this.debugMessage += `t${this.debugTraceCount}: ${this.iterations} iterations\\n`\n        }\n\n        if (this.isRemovePathLoopsEnabled) {\n          route = removePathLoops(route)\n        }\n\n        if (this.isShortenPathWithShortcutsEnabled) {\n          route = shortenPathWithShortcuts(route, (A, B) => {\n            if (A.x === B.x && A.y === B.y) return false\n            const collision = (\n              this.obstacles as ObstacleList3d\n            ).getOrthoDirectionCollisionInfo(\n              {\n                x: A.x,\n                y: A.y,\n                l: this.layerToIndex(A.layer) ?? 0,\n              },\n              {\n                dx: Math.sign(B.x - A.x),\n                dy: Math.sign(B.y - A.y),\n                dl: 0,\n              },\n              {\n                margin: 0.05,\n              },\n            )\n            const dist = Math.sqrt((A.x - B.x) ** 2 + (A.y - B.y) ** 2)\n            return collision.wallDistance < dist\n          })\n        }\n\n        return { solved: true, route, connectionName: connection.name }\n      }\n\n      if (this.openSet.length === 0) {\n        break\n      }\n    }\n\n    if (debug.enabled) {\n      this.debugMessage += `t${this.debugTraceCount}: ${this.iterations} iterations (failed)\\n`\n    }\n\n    return { solved: false, connectionName: connection.name }\n  }\n\n  createObstacleList({\n    dominantLayer,\n    connection,\n    obstaclesFromTraces,\n  }: {\n    dominantLayer?: string\n    connection: SimpleRouteConnection\n    obstaclesFromTraces: Obstacle[]\n  }): ObstacleList {\n    return new ObstacleList(\n      this.allObstacles\n        .filter((obstacle) => !obstacle.connectedTo.includes(connection.name))\n        // TODO obstacles on different layers should be filtered inside\n        // the algorithm, not for the entire connection, this is a hack in\n        // relation to https://github.com/tscircuit/tscircuit/issues/432\n        .filter((obstacle) => obstacle.layers.includes(dominantLayer as any))\n        .concat(obstaclesFromTraces ?? []),\n    )\n  }\n\n  /**\n   * Override this to implement smoothing strategies or incorporate new traces\n   * into a connectivity map\n   */\n  postprocessConnectionSolveResult(\n    connection: SimpleRouteConnection,\n    result: ConnectionSolveResult,\n  ): ConnectionSolveResult {\n    return result\n  }\n\n  /**\n   * By default, this will solve the connections in the order they are given,\n   * and add obstacles for each successfully solved connection. Override this\n   * to implement \"rip and replace\" rerouting strategies.\n   */\n  solve(): ConnectionSolveResult[] {\n    const solutions: ConnectionSolveResult[] = []\n    const obstaclesFromTraces: Obstacle[] = []\n    this.debugTraceCount = 0\n    for (const connection of this.input.connections) {\n      const dominantLayer = connection.pointsToConnect[0].layer ?? \"top\"\n      this.debugTraceCount += 1\n      this.obstacles = this.createObstacleList({\n        dominantLayer,\n        connection,\n        obstaclesFromTraces,\n      })\n      let result = this.solveConnection(connection)\n      result = this.postprocessConnectionSolveResult(connection, result)\n      solutions.push(result)\n\n      if (debug.enabled) {\n        this.drawDebugTraceObstacles(obstaclesFromTraces)\n      }\n\n      if (result.solved) {\n        obstaclesFromTraces.push(\n          ...getObstaclesFromRoute(\n            result.route.map((p) => ({\n              x: p.x,\n              y: p.y,\n              layer: p.layer ?? dominantLayer,\n            })),\n            connection.name,\n          ),\n        )\n      }\n    }\n\n    return solutions\n  }\n\n  solveAndMapToTraces(): SimplifiedPcbTrace[] {\n    const solutions = this.solve()\n\n    return solutions.flatMap((solution): SimplifiedPcbTrace[] => {\n      if (!solution.solved) return []\n      return [\n        {\n          type: \"pcb_trace\" as const,\n          pcb_trace_id: `pcb_trace_for_${solution.connectionName}`,\n          route: addViasWhenLayerChanges(\n            solution.route.map((point) => ({\n              route_type: \"wire\" as const,\n              x: point.x,\n              y: point.y,\n              width: this.input.minTraceWidth,\n              layer: point.layer as LayerRef,\n            })),\n          ),\n        },\n      ]\n    })\n  }\n\n  getDebugGroup(): string | null {\n    const dgn = `t${this.debugTraceCount}_iter[${this.iterations - 1}]`\n    if (this.iterations < 30) return dgn\n    if (this.iterations < 100 && this.iterations % 10 === 0) return dgn\n    if (this.iterations < 1000 && this.iterations % 100 === 0) return dgn\n    if (!this.debugSolutions) return dgn\n    return null\n  }\n\n  drawDebugTraceObstacles(obstacles: Obstacle[]) {\n    const { debugTraceCount, debugSolutions } = this\n    for (const key in debugSolutions) {\n      if (key.startsWith(`t${debugTraceCount}_`)) {\n        debugSolutions[key].push(\n          ...obstacles.map(\n            (obstacle, i) =>\n              ({\n                type: \"pcb_smtpad\",\n                pcb_component_id: \"\",\n                layer: obstacle.layers[0],\n                width: obstacle.width,\n                shape: \"rect\",\n                x: obstacle.center.x,\n                y: obstacle.center.y,\n                pcb_smtpad_id: `trace_obstacle_${i}`,\n                height: obstacle.height,\n              }) as PCBSMTPad,\n          ),\n        )\n      }\n    }\n  }\n\n  drawDebugSolution({\n    current,\n    newNeighbors,\n  }: {\n    current: Node\n    newNeighbors: Node[]\n  }) {\n    const debugGroup = this.getDebugGroup()\n    if (!debugGroup) return\n\n    const { openSet, debugTraceCount, debugSolutions } = this\n\n    debugSolutions![debugGroup] ??= []\n    const debugSolution = debugSolutions![debugGroup]!\n\n    debugSolution.push({\n      type: \"pcb_fabrication_note_text\",\n      pcb_fabrication_note_text_id: `debug_note_${current.x}_${current.y}`,\n      font: \"tscircuit2024\",\n      font_size: 0.25,\n      text: \"X\" + (current.l !== undefined ? current.l : \"\"),\n      pcb_component_id: \"\",\n      layer: \"top\",\n      anchor_position: {\n        x: current.x,\n        y: current.y,\n      },\n      anchor_alignment: \"center\",\n    })\n    // Add all the openSet as small diamonds\n    for (let i = 0; i < openSet.length; i++) {\n      const node = openSet[i]\n      debugSolution.push({\n        type: \"pcb_fabrication_note_path\",\n        pcb_component_id: \"\",\n        pcb_fabrication_note_path_id: `note_path_${node.x}_${node.y}`,\n        layer: \"top\",\n        route: [\n          [0, 0.05],\n          [0.05, 0],\n          [0, -0.05],\n          [-0.05, 0],\n          [0, 0.05],\n        ].map(([dx, dy]) => ({\n          x: node.x + dx,\n          y: node.y + dy,\n        })),\n        stroke_width: 0.01,\n      })\n      // Add text that indicates the order of this point\n      debugSolution.push({\n        type: \"pcb_fabrication_note_text\",\n        pcb_fabrication_note_text_id: `debug_note_${node.x}_${node.y}`,\n        font: \"tscircuit2024\",\n        font_size: 0.03,\n        text: i.toString(),\n        pcb_component_id: \"\",\n        layer: \"top\",\n        anchor_position: {\n          x: node.x,\n          y: node.y,\n        },\n        anchor_alignment: \"center\",\n      })\n    }\n\n    if (current.parent) {\n      const path: Node[] = []\n      let p: Node | null = current\n      while (p) {\n        path.unshift(p)\n        p = p.parent\n      }\n      debugSolution!.push({\n        type: \"pcb_fabrication_note_path\",\n        pcb_component_id: \"\",\n        pcb_fabrication_note_path_id: `note_path_${current.x}_${current.y}`,\n        layer: \"top\",\n        route: path,\n        stroke_width: 0.01,\n      })\n    }\n  }\n}\n","import type { Obstacle } from \"autorouting-dataset/lib/types\"\n\ninterface PointWithLayer {\n  x: number\n  y: number\n  layer: string\n}\n\nconst isCloseTo = (a: number, b: number) => Math.abs(a - b) < 0.0001\n\nexport const getObstaclesFromRoute = (\n  route: PointWithLayer[],\n  source_trace_id: string,\n  { viaDiameter = 0.5 }: { viaDiameter?: number } = {},\n): Obstacle[] => {\n  const obstacles: Obstacle[] = []\n  for (let i = 0; i < route.length - 1; i++) {\n    const [start, end] = [route[i], route[i + 1]]\n    const prev = i - 1 >= 0 ? route[i - 1] : null\n\n    const isHorz = isCloseTo(start.y, end.y)\n    const isVert = isCloseTo(start.x, end.x)\n\n    if (!isHorz && !isVert) {\n      throw new Error(\n        `getObstaclesFromTrace currently only supports horizontal and vertical traces (not diagonals) Conflicting trace: ${source_trace_id}, start: (${start.x}, ${start.y}), end: (${end.x}, ${end.y})`,\n      )\n    }\n\n    const obstacle: Obstacle = {\n      type: \"rect\",\n      layers: [start.layer],\n      center: {\n        x: (start.x + end.x) / 2,\n        y: (start.y + end.y) / 2,\n      },\n      width: isHorz ? Math.abs(start.x - end.x) : 0.1, // TODO use route width\n      height: isVert ? Math.abs(start.y - end.y) : 0.1, // TODO use route width\n      connectedTo: [source_trace_id],\n    }\n\n    obstacles.push(obstacle)\n\n    if (prev && prev.layer === start.layer && start.layer !== end.layer) {\n      const via: Obstacle = {\n        type: \"rect\",\n        layers: [start.layer, end.layer],\n        center: {\n          x: start.x,\n          y: start.y,\n        },\n        connectedTo: [source_trace_id],\n        width: viaDiameter,\n        height: viaDiameter,\n      }\n      obstacles.push(via)\n    }\n  }\n  return obstacles\n}\n","import type { Obstacle, ObstacleWithEdges } from \"solver-utils\"\nimport type {\n  Direction,\n  DirectionDistances,\n  DirectionWithCollisionInfo,\n  Point,\n} from \"./types\"\n\n/**\n * A list of obstacles with functions for fast lookups, this default implementation\n * has no optimizations, you should override this class to implement faster lookups\n */\nexport class ObstacleList {\n  protected obstacles: ObstacleWithEdges[]\n  protected GRID_STEP = 0.1\n\n  constructor(obstacles: Array<Obstacle>) {\n    this.obstacles = obstacles.map((obstacle) => ({\n      ...obstacle,\n      left: obstacle.center.x - obstacle.width / 2,\n      right: obstacle.center.x + obstacle.width / 2,\n      top: obstacle.center.y + obstacle.height / 2,\n      bottom: obstacle.center.y - obstacle.height / 2,\n    }))\n  }\n\n  getObstacleAt(x: number, y: number, m?: number): Obstacle | null {\n    m ??= this.GRID_STEP\n    for (const obstacle of this.obstacles) {\n      const halfWidth = obstacle.width / 2 + m\n      const halfHeight = obstacle.height / 2 + m\n      if (\n        x >= obstacle.center.x - halfWidth &&\n        x <= obstacle.center.x + halfWidth &&\n        y >= obstacle.center.y - halfHeight &&\n        y <= obstacle.center.y + halfHeight\n      ) {\n        return obstacle\n      }\n    }\n    return null\n  }\n\n  isObstacleAt(x: number, y: number, m?: number): boolean {\n    return this.getObstacleAt(x, y, m) !== null\n  }\n\n  getDirectionDistancesToNearestObstacle(\n    x: number,\n    y: number,\n  ): DirectionDistances {\n    const { GRID_STEP } = this\n    const result: DirectionDistances = {\n      left: Infinity,\n      top: Infinity,\n      bottom: Infinity,\n      right: Infinity,\n    }\n\n    for (const obstacle of this.obstacles) {\n      if (obstacle.type === \"rect\") {\n        const left = obstacle.center.x - obstacle.width / 2 - GRID_STEP\n        const right = obstacle.center.x + obstacle.width / 2 + GRID_STEP\n        const top = obstacle.center.y + obstacle.height / 2 + GRID_STEP\n        const bottom = obstacle.center.y - obstacle.height / 2 - GRID_STEP\n\n        // Check left\n        if (y >= bottom && y <= top && x > left) {\n          result.left = Math.min(result.left, x - right)\n        }\n\n        // Check right\n        if (y >= bottom && y <= top && x < right) {\n          result.right = Math.min(result.right, left - x)\n        }\n\n        // Check top\n        if (x >= left && x <= right && y < top) {\n          result.top = Math.min(result.top, bottom - y)\n        }\n\n        // Check bottom\n        if (x >= left && x <= right && y > bottom) {\n          result.bottom = Math.min(result.bottom, y - top)\n        }\n      }\n    }\n\n    return result\n  }\n\n  getOrthoDirectionCollisionInfo(\n    point: Point,\n    dir: Direction,\n    { margin = 0 }: { margin?: number } = {},\n  ): DirectionWithCollisionInfo {\n    const { x, y } = point\n    const { dx, dy } = dir\n    let minDistance = Infinity\n    let collisionObstacle: ObstacleWithEdges | null = null\n\n    for (const obstacle of this.obstacles) {\n      const leftMargin = obstacle.left - margin\n      const rightMargin = obstacle.right + margin\n      const topMargin = obstacle.top + margin\n      const bottomMargin = obstacle.bottom - margin\n\n      let distance: number | null = null\n\n      if (dx === 1 && dy === 0) {\n        // Right\n        if (y > bottomMargin && y < topMargin && x < obstacle.left) {\n          distance = obstacle.left - x\n        }\n      } else if (dx === -1 && dy === 0) {\n        // Left\n        if (y > bottomMargin && y < topMargin && x > obstacle.right) {\n          distance = x - obstacle.right\n        }\n      } else if (dx === 0 && dy === 1) {\n        // Up\n        if (x > leftMargin && x < rightMargin && y < obstacle.bottom) {\n          distance = obstacle.bottom - y\n        }\n      } else if (dx === 0 && dy === -1) {\n        // Down\n        if (x > leftMargin && x < rightMargin && y > obstacle.top) {\n          distance = y - obstacle.top\n        }\n      }\n\n      if (distance !== null && distance < minDistance) {\n        minDistance = distance\n        collisionObstacle = obstacle\n      }\n    }\n\n    return {\n      dx,\n      dy,\n      wallDistance: minDistance,\n      obstacle: collisionObstacle as ObstacleWithEdges,\n    }\n  }\n\n  getObstaclesOverlappingRegion(region: {\n    minX: number\n    minY: number\n    maxX: number\n    maxY: number\n  }): ObstacleWithEdges[] {\n    const obstacles: ObstacleWithEdges[] = []\n    for (const obstacle of this.obstacles) {\n      const { left, right, top, bottom } = obstacle\n\n      if (\n        left <= region.maxX &&\n        right >= region.minX &&\n        top <= region.maxY &&\n        bottom >= region.minY\n      ) {\n        obstacles.push(obstacle)\n      }\n    }\n\n    return obstacles\n  }\n}\n","import type { Point } from \"../types\"\n\ninterface PointWithLayer {\n  x: number\n  y: number\n  layer: string\n  route_type?: string\n}\n\nexport function removePathLoops<T extends PointWithLayer>(path: T[]): T[] {\n  if (path.length < 4) return path // No loops possible with less than 4 points\n\n  const result: PointWithLayer[] = [{ ...path[0] }]\n  let currentLayer = path[0].layer\n\n  for (let i = 1; i < path.length; i++) {\n    const currentSegment = { start: path[i - 1], end: path[i] }\n    const isVia =\n      path[i].route_type === \"via\" || path[i - 1].route_type === \"via\"\n\n    // Handle layer changes\n    if (path[i].layer !== currentLayer || isVia) {\n      result.push({ ...path[i] })\n      currentLayer = path[i].layer\n      continue\n    }\n\n    let intersectionFound = false\n    let intersectionPoint: PointWithLayer | null = null\n    let intersectionIndex = -1\n\n    // Check for intersections with all previous segments\n    for (let j = 0; j < result.length - 1; j++) {\n      const previousSegment = { start: result[j], end: result[j + 1] }\n      if (previousSegment.start.layer !== currentSegment.start.layer) {\n        continue\n      }\n      // Only check intersections on the same layer\n      if (previousSegment.start.layer === currentSegment.start.layer) {\n        const intersection = findIntersection(previousSegment, currentSegment)\n        if (intersection) {\n          intersectionFound = true\n          intersectionPoint = {\n            ...intersection,\n            layer: currentLayer,\n          }\n          intersectionIndex = j\n          break\n        }\n      }\n    }\n\n    if (intersectionFound && intersectionPoint) {\n      // Remove the loop\n      result.splice(intersectionIndex + 1)\n      // Add the intersection point\n      result.push(intersectionPoint)\n    }\n\n    // Add the current point if it's not the same as the last point in result\n    const lastPoint = result[result.length - 1]\n    if (lastPoint.x !== path[i].x || lastPoint.y !== path[i].y) {\n      result.push(path[i])\n    }\n  }\n\n  return result as T[]\n}\n\nfunction findIntersection(\n  segment1: { start: Point; end: Point },\n  segment2: { start: Point; end: Point },\n): Point | null {\n  // Check if segments are parallel\n  if (\n    (segment1.start.x === segment1.end.x &&\n      segment2.start.x === segment2.end.x) ||\n    (segment1.start.y === segment1.end.y && segment2.start.y === segment2.end.y)\n  ) {\n    return null\n  }\n\n  // Find intersection point\n  let intersectionPoint: Point\n\n  if (segment1.start.x === segment1.end.x) {\n    const x = segment1.start.x\n    const y = segment2.start.y\n    intersectionPoint = { ...segment1.start, x, y }\n  } else {\n    const x = segment2.start.x\n    const y = segment1.start.y\n    intersectionPoint = { ...segment1.start, x, y }\n  }\n\n  // Check if intersection point is within both segments\n  if (\n    isPointInSegment(intersectionPoint, segment1) &&\n    isPointInSegment(intersectionPoint, segment2)\n  ) {\n    return intersectionPoint\n  }\n\n  return null\n}\n\nfunction isPointInSegment(\n  point: Point,\n  segment: { start: Point; end: Point },\n): boolean {\n  return (\n    point.x >= Math.min(segment.start.x, segment.end.x) &&\n    point.x <= Math.max(segment.start.x, segment.end.x) &&\n    point.y >= Math.min(segment.start.y, segment.end.y) &&\n    point.y <= Math.max(segment.start.y, segment.end.y)\n  )\n}\n","import type { SimplifiedPcbTrace } from \"../types\"\n\nexport type RouteItem = SimplifiedPcbTrace[\"route\"][number]\n\nexport function addViasWhenLayerChanges(route: RouteItem[]): RouteItem[] {\n  const newRoute: RouteItem[] = [route[0]]\n\n  for (let i = 1; i < route.length - 1; i++) {\n    const [prev, current, next] = [route[i - 1], route[i], route[i + 1]]\n\n    newRoute.push(current)\n\n    if (\n      current.route_type !== \"wire\" ||\n      prev.route_type !== \"wire\" ||\n      next.route_type !== \"wire\"\n    )\n      continue\n\n    if (prev.layer === current.layer && current.layer !== next.layer) {\n      newRoute.push({\n        route_type: \"via\",\n        from_layer: current.layer,\n        to_layer: next.layer,\n        x: current.x,\n        y: current.y,\n      })\n    }\n  }\n  newRoute.push(route[route.length - 1])\n\n  return newRoute\n}\n","import { current } from \"circuit-json\"\nimport type { PointWithLayer as Point } from \"./GeneralizedAstar\"\nimport Debug from \"debug\"\n\nconst debug = Debug(\"autorouter:shortenPathWithShortcuts\")\n\nexport function shortenPathWithShortcuts(\n  route: Point[],\n  checkIfObstacleBetweenPoints: (start: Point, end: Point) => boolean,\n): Point[] {\n  if (route.length <= 2) {\n    return route\n  }\n\n  const shortened: Point[] = [route[0]]\n\n  for (let i = 1; i < route.length; i++) {\n    // can i extend this segment to a future segment?\n    const currentSegment = {\n      start: shortened[shortened.length - 1],\n      end: route[i],\n    }\n    let skipToIndex = -1\n    const currentSegmentIsVertical =\n      currentSegment.start.x === currentSegment.end.x\n    const currentSegmentIsHorizontal =\n      currentSegment.start.y === currentSegment.end.y\n    for (let j = i + 1; j < route.length; j++) {\n      if (j <= skipToIndex) continue\n      const futureSegment = {\n        start: route[j],\n        end: route[j + 1],\n      }\n      if (!futureSegment.end) continue\n      const futureSegmentIsVertical =\n        futureSegment.start.x === futureSegment.end.x\n      const futureSegmentIsHorizontal =\n        futureSegment.start.y === futureSegment.end.y\n\n      const bothVertical = currentSegmentIsVertical && futureSegmentIsVertical\n      const bothHorizontal =\n        currentSegmentIsHorizontal && futureSegmentIsHorizontal\n\n      if (bothHorizontal && bothVertical) continue\n      const segmentsAreParallel = bothVertical || bothHorizontal\n\n      if (!segmentsAreParallel) continue\n\n      let overlapping = false\n\n      const currentMinX = Math.min(currentSegment.start.x, currentSegment.end.x)\n      const currentMaxX = Math.max(currentSegment.start.x, currentSegment.end.x)\n      const futureMinX = Math.min(futureSegment.start.x, futureSegment.end.x)\n      const futureMaxX = Math.max(futureSegment.start.x, futureSegment.end.x)\n\n      const currentMinY = Math.min(currentSegment.start.y, currentSegment.end.y)\n      const currentMaxY = Math.max(currentSegment.start.y, currentSegment.end.y)\n      const futureMinY = Math.min(futureSegment.start.y, futureSegment.end.y)\n      const futureMaxY = Math.max(futureSegment.start.y, futureSegment.end.y)\n\n      if (bothHorizontal) {\n        overlapping = currentMinX <= futureMaxX && currentMaxX >= futureMinX\n      } else if (bothVertical) {\n        overlapping = currentMinY <= futureMaxY && currentMaxY >= futureMinY\n      }\n\n      if (!overlapping) continue\n\n      const candidateShortcuts: Point[] = []\n\n      const pointBeforeShortcut = shortened[shortened.length - 1]\n      const pointAfterShortcut = route[j + 2]\n      if (!pointAfterShortcut) continue\n\n      if (\n        bothHorizontal &&\n        futureMinX < currentMaxX &&\n        pointAfterShortcut.x === futureMinX\n      ) {\n        candidateShortcuts.push({\n          x: futureMinX,\n          y: currentSegment.start.y,\n          layer: currentSegment.start.layer,\n        })\n      }\n      if (\n        bothHorizontal &&\n        futureMaxX > currentMinX &&\n        pointAfterShortcut.x === futureMaxX\n      ) {\n        candidateShortcuts.push({\n          x: futureMaxX,\n          y: currentSegment.start.y,\n          layer: currentSegment.start.layer,\n        })\n      }\n      if (\n        bothVertical &&\n        futureMinY < currentMaxY &&\n        pointAfterShortcut.y === futureMinY\n      ) {\n        candidateShortcuts.push({\n          x: currentSegment.start.x,\n          y: futureMinY,\n          layer: currentSegment.start.layer,\n        })\n      }\n      if (\n        bothVertical &&\n        futureMaxY > currentMinY &&\n        pointAfterShortcut.y === futureMaxY\n      ) {\n        candidateShortcuts.push({\n          x: currentSegment.start.x,\n          y: futureMaxY,\n          layer: currentSegment.start.layer,\n        })\n      }\n\n      let shortcutPoint: Point | null = null\n\n      for (const candidateShortcut of candidateShortcuts) {\n        if (\n          checkIfObstacleBetweenPoints(\n            pointBeforeShortcut,\n            candidateShortcut,\n          ) ||\n          checkIfObstacleBetweenPoints(pointAfterShortcut, candidateShortcut)\n        ) {\n          continue\n        }\n\n        shortcutPoint = candidateShortcut\n        break\n      }\n\n      if (!shortcutPoint) continue\n\n      shortened.push(shortcutPoint)\n      i = j + 1\n      skipToIndex = j + 1\n      break\n    }\n\n    if (skipToIndex === -1) {\n      shortened.push(route[i])\n    }\n  }\n\n  if (shortened[shortened.length - 1] !== route[route.length - 1]) {\n    shortened.push(route[route.length - 1])\n  }\n\n  return shortened\n}\n","import type { Obstacle } from \"solver-utils\"\nimport Debug from \"debug\"\nimport type {\n  Direction,\n  DirectionWithWallDistance,\n  PointWithWallDistance,\n} from \"./types\"\nimport type { ObstacleList } from \"./ObstacleList\"\n\nconst debug = Debug(\n  \"autorouting-dataset:infinite-grid-ijump-astar:get-distance-to-overcome-obstacle\",\n)\n\nexport function getDistanceToOvercomeObstacle({\n  node,\n  travelDir,\n  wallDir,\n  obstacle,\n  obstacles,\n  obstaclesInRow = 0,\n  OBSTACLE_MARGIN = 0.15,\n  SHOULD_DETECT_CONJOINED_OBSTACLES = false,\n  MAX_CONJOINED_OBSTACLES = 20,\n}: {\n  node: { x: number; y: number }\n  travelDir: DirectionWithWallDistance\n  wallDir: DirectionWithWallDistance\n  obstacle: Obstacle\n  obstacles: ObstacleList\n  OBSTACLE_MARGIN: number\n  SHOULD_DETECT_CONJOINED_OBSTACLES?: boolean\n  MAX_CONJOINED_OBSTACLES?: number\n  obstaclesInRow?: number\n}): number {\n  let distToOvercomeObstacle: number\n  if (travelDir.dx === 0) {\n    if (travelDir.dy > 0) {\n      distToOvercomeObstacle = obstacle.center.y + obstacle.height / 2 - node.y\n    } else {\n      distToOvercomeObstacle =\n        node.y - (obstacle.center.y - obstacle.height / 2)\n    }\n  } else {\n    if (travelDir.dx > 0) {\n      distToOvercomeObstacle = obstacle.center.x + obstacle.width / 2 - node.x\n    } else {\n      distToOvercomeObstacle = node.x - (obstacle.center.x - obstacle.width / 2)\n    }\n  }\n  distToOvercomeObstacle += OBSTACLE_MARGIN // + GRID_STEP\n\n  if (\n    SHOULD_DETECT_CONJOINED_OBSTACLES &&\n    obstaclesInRow < MAX_CONJOINED_OBSTACLES\n  ) {\n    // TODO: we need to detect all possible obstacles between the wallDistance\n    // and the node at the end of the distToOvercomeObstacle, there could be\n    // multiple obstacles that could interrupt the path of the node at it's\n    // next turn\n    // http://localhost:3080/problem/traces/18#t2_iter[14] is a great example\n    // of a path being too close because of a bad distToOvercomeObstacle b/c\n    // of missing detection of obstacles within the wallDistance\n    const obstacleAtEnd = obstacles.getObstacleAt(\n      node.x +\n        travelDir.dx * distToOvercomeObstacle +\n        wallDir.dx * (wallDir.wallDistance + 0.001),\n      node.y +\n        travelDir.dy * distToOvercomeObstacle +\n        wallDir.dy * (wallDir.wallDistance + 0.001),\n    )\n    // const obstaclesAtEnd = obstacles.getObstaclesOverlappingRegion({\n    //   minX: node.x + travelDir.dx * distToOvercomeObstacle,\n    //   minY: node.y + travelDir.dy * distToOvercomeObstacle,\n    //   maxX:\n    //     node.x +\n    //     travelDir.dx * distToOvercomeObstacle +\n    //     wallDir.dx * wallDir.wallDistance,\n    //   maxY:\n    //     node.y +\n    //     travelDir.dy * distToOvercomeObstacle +\n    //     wallDir.dy * wallDir.wallDistance,\n    // })\n\n    if (obstacleAtEnd === obstacle) {\n      return distToOvercomeObstacle\n      // TODO Not sure why this happens, it does happen often\n      throw new Error(\n        \"obstacleAtEnd === obstacle, we're bad at computing overcoming distance because it didn't overcome the obstacle\",\n      )\n    }\n\n    if (obstacleAtEnd && obstacleAtEnd.type === \"rect\") {\n      // Make sure obstacle cannot block the path if the path is extended, this\n      // is guaranteed if the obstacleAtEnd's dimension orthogonal to the path\n      // we're traveling is smaller or equal to the previous obstacle's\n      // orthogonal dimension\n      // Said another way: The path could be blocked if the next conjoined\n      // obstacle is bigger and is extending in the same direction as the path\n      // https://github.com/tscircuit/autorouting-dataset/issues/31\n      const extendingAlongXAxis = travelDir.dy === 0\n      const o1OrthoDim = extendingAlongXAxis ? obstacle.height : obstacle.width\n      const o2OrthoDim = extendingAlongXAxis\n        ? obstacleAtEnd.height\n        : obstacleAtEnd.width\n\n      if (o2OrthoDim > o1OrthoDim) {\n        debug(\"next obstacle on path is bigger, not trying to overcome it\")\n        return distToOvercomeObstacle\n      }\n\n      const endObstacleDistToOvercome = getDistanceToOvercomeObstacle({\n        node: {\n          x: node.x + travelDir.dx * distToOvercomeObstacle,\n          y: node.y + travelDir.dy * distToOvercomeObstacle,\n        },\n        travelDir: travelDir,\n        wallDir: wallDir,\n        obstacle: obstacleAtEnd,\n        obstacles,\n        obstaclesInRow: obstaclesInRow + 1,\n        SHOULD_DETECT_CONJOINED_OBSTACLES,\n        MAX_CONJOINED_OBSTACLES,\n        OBSTACLE_MARGIN,\n      })\n      distToOvercomeObstacle += endObstacleDistToOvercome\n    }\n  }\n\n  return distToOvercomeObstacle\n}\n","import { GeneralizedAstarAutorouter } from \"./GeneralizedAstar\"\nimport type {\n  Direction,\n  DirectionWithCollisionInfo,\n  DirectionWithWallDistance,\n  Node,\n  Point,\n  PointWithObstacleHit,\n  PointWithWallDistance,\n} from \"./types\"\nimport { clamp, dirFromAToB, dist, distAlongDir } from \"./util\"\nimport { getDistanceToOvercomeObstacle } from \"./getDistanceToOvercomeObstacle\"\n\nexport class IJumpAutorouter extends GeneralizedAstarAutorouter {\n  MAX_ITERATIONS: number = 200\n\n  getNeighbors(node: Node): Array<PointWithObstacleHit> {\n    const obstacles = this.obstacles!\n    const goalPoint = this.goalPoint!\n\n    /**\n     * This is considered \"forward\" if we were to continue from the parent,\n     * through the current node.\n     */\n    let forwardDir: Direction\n    if (!node.parent) {\n      forwardDir = dirFromAToB(node, goalPoint)\n    } else {\n      forwardDir = dirFromAToB(node.parent, node)\n    }\n\n    /**\n     * Get the 2-3 next directions (excluding backwards direction), and\n     * excluding the forward direction if we just ran into a wall\n     */\n    const travelDirs1 = [\n      { dx: 0, dy: 1 },\n      { dx: 1, dy: 0 },\n      { dx: 0, dy: -1 },\n      { dx: -1, dy: 0 },\n    ]\n      .filter((dir) => {\n        // If we have a parent, don't go backwards towards the parent\n        if (dir.dx === forwardDir.dx * -1 && dir.dy === forwardDir.dy * -1) {\n          return false\n        } else if (\n          dir.dx === forwardDir.dx &&\n          dir.dy === forwardDir.dy &&\n          node.parent?.obstacleHit\n        ) {\n          return false\n        }\n        return true\n      })\n      .map((dir) =>\n        obstacles.getOrthoDirectionCollisionInfo(node, dir, {\n          margin: this.OBSTACLE_MARGIN,\n        }),\n      )\n      // Filter out directions that are too close to the wall\n      .filter((dir) => dir.wallDistance >= this.OBSTACLE_MARGIN)\n\n    /**\n     * Figure out how far to travel. There are a couple reasons we would stop\n     * traveling:\n     * - A different direction opened up while we were traveling (the obstacle\n     *   our parent hit was overcome)\n     * - We hit a wall\n     * - We passed the goal along the travel direction\n     */\n    const travelDirs2: Array<\n      DirectionWithCollisionInfo & { travelDistance: number }\n    > = []\n    for (const travelDir of travelDirs1) {\n      let overcomeDistance: number | null = null\n      if (node?.obstacleHit) {\n        overcomeDistance = getDistanceToOvercomeObstacle({\n          node,\n          travelDir,\n          wallDir: { ...forwardDir, wallDistance: this.OBSTACLE_MARGIN },\n          obstacle: node.obstacleHit,\n          obstacles,\n          OBSTACLE_MARGIN: this.OBSTACLE_MARGIN,\n          SHOULD_DETECT_CONJOINED_OBSTACLES: true,\n        })\n      }\n\n      const goalDistAlongTravelDir = distAlongDir(node, goalPoint, travelDir)\n      const isGoalInTravelDir =\n        (travelDir.dx === 0 ||\n          Math.sign(goalPoint.x - node.x) === travelDir.dx) &&\n        (travelDir.dy === 0 || Math.sign(goalPoint.y - node.y) === travelDir.dy)\n\n      if (\n        goalDistAlongTravelDir < travelDir.wallDistance &&\n        goalDistAlongTravelDir > 0 &&\n        isGoalInTravelDir\n      ) {\n        travelDirs2.push({\n          ...travelDir,\n          travelDistance: goalDistAlongTravelDir,\n        })\n      } else if (\n        overcomeDistance !== null &&\n        overcomeDistance < travelDir.wallDistance\n      ) {\n        travelDirs2.push({\n          ...travelDir,\n          travelDistance: overcomeDistance,\n        })\n      } else if (travelDir.wallDistance !== Infinity) {\n        travelDirs2.push({\n          ...travelDir,\n          travelDistance: travelDir.wallDistance - this.OBSTACLE_MARGIN,\n        })\n      }\n    }\n\n    return (\n      travelDirs2\n        // If an obstacle fails this check, we messed up computing neighbors\n        // Currently this happens when we overcome obstacles and there's a\n        // different obstacle in the travel direction\n        .filter((dir) => {\n          return !obstacles.isObstacleAt(\n            node.x + dir.dx * dir.travelDistance,\n            node.y + dir.dy * dir.travelDistance,\n          )\n        })\n        .map((dir) => ({\n          x: node.x + dir.dx * dir.travelDistance,\n          y: node.y + dir.dy * dir.travelDistance,\n          obstacleHit: dir.obstacle,\n        }))\n    )\n  }\n}\n","import type { SimpleRouteConnection, SimpleRouteJson } from \"./SimpleRouteJson\"\nimport { su } from \"@tscircuit/soup-util\"\nimport type { Obstacle } from \"../types\"\nimport { getObstaclesFromCircuitJson } from \"./getObstaclesFromCircuitJson\"\nimport { getConnectionWithAlternativeGoalBoxes } from \"./getAlternativeGoalBoxes\"\nimport type { ConnectionWithGoalAlternatives } from \"./ConnectionWithAlternatives\"\nimport {\n  ConnectivityMap,\n  getFullConnectivityMapFromCircuitJson,\n  PcbConnectivityMap,\n} from \"circuit-json-to-connectivity-map\"\nimport type { AnyCircuitElement } from \"circuit-json\"\n\nexport const getSimpleRouteJson = (\n  circuitJson: AnyCircuitElement[],\n  opts: {\n    layerCount?: number\n    optimizeWithGoalBoxes?: boolean\n    connMap?: ConnectivityMap\n  } = {},\n): SimpleRouteJson => {\n  const routeJson: SimpleRouteJson = {\n    minTraceWidth: 0.1,\n  } as Partial<SimpleRouteJson> as any\n\n  routeJson.layerCount = opts.layerCount ?? 1\n\n  // Derive obstacles from pcb_smtpad, pcb_hole, and pcb_plated_hole\n  routeJson.obstacles = getObstaclesFromCircuitJson(circuitJson, opts.connMap)\n\n  // Derive connections using source_traces, source_ports, source_nets\n  routeJson.connections = []\n  for (const element of circuitJson) {\n    if (element.type === \"source_trace\") {\n      let connection: ConnectionWithGoalAlternatives | SimpleRouteConnection = {\n        name: element.source_trace_id,\n        pointsToConnect: element.connected_source_port_ids.map((portId) => {\n          const pcb_port = su(circuitJson).pcb_port.getWhere({\n            source_port_id: portId,\n          })\n          if (!pcb_port) {\n            throw new Error(\n              `Could not find pcb_port for source_port_id \"${portId}\"`,\n            )\n          }\n          return {\n            x: pcb_port.x,\n            y: pcb_port.y,\n            layer: pcb_port.layers?.[0] ?? \"top\",\n            pcb_port_id: pcb_port.pcb_port_id,\n          }\n        }),\n      }\n\n      if (opts.optimizeWithGoalBoxes) {\n        const pcbConnMap = new PcbConnectivityMap(circuitJson)\n        connection = getConnectionWithAlternativeGoalBoxes({\n          connection,\n          pcbConnMap,\n        })\n      }\n\n      routeJson.connections.push(connection)\n\n      // Check if any points are inside obstacles\n      markObstaclesAsConnected(\n        routeJson.obstacles,\n        connection.pointsToConnect,\n        connection.name,\n      )\n    }\n  }\n\n  const bounds = {\n    minX: Infinity,\n    maxX: -Infinity,\n    minY: Infinity,\n    maxY: -Infinity,\n  }\n  for (const obstacle of routeJson.obstacles) {\n    bounds.minX = Math.min(bounds.minX, obstacle.center.x - obstacle.width / 2)\n    bounds.maxX = Math.max(bounds.maxX, obstacle.center.x + obstacle.width / 2)\n    bounds.minY = Math.min(bounds.minY, obstacle.center.y - obstacle.height / 2)\n    bounds.maxY = Math.max(bounds.maxY, obstacle.center.y + obstacle.height / 2)\n  }\n  for (const connection of routeJson.connections) {\n    for (const point of connection.pointsToConnect) {\n      bounds.minX = Math.min(bounds.minX, point.x)\n      bounds.maxX = Math.max(bounds.maxX, point.x)\n      bounds.minY = Math.min(bounds.minY, point.y)\n      bounds.maxY = Math.max(bounds.maxY, point.y)\n    }\n  }\n  routeJson.bounds = bounds\n\n  return routeJson\n}\n\nexport const markObstaclesAsConnected = (\n  obstacles: Obstacle[],\n  pointsToConnect: Array<{ x: number; y: number }>,\n  connectionName: string,\n) => {\n  for (const point of pointsToConnect) {\n    for (const obstacle of obstacles) {\n      if (isPointInsideObstacle(point, obstacle)) {\n        obstacle.connectedTo.push(connectionName)\n      }\n    }\n  }\n}\n\n// Helper function to check if a point is inside an obstacle\nexport function isPointInsideObstacle(\n  point: { x: number; y: number },\n  obstacle: {\n    type: string\n    center: { x: number; y: number }\n    width: number\n    height: number\n  },\n): boolean {\n  const halfWidth = obstacle.width / 2\n  const halfHeight = obstacle.height / 2\n\n  if (obstacle.type === \"rect\") {\n    return (\n      point.x >= obstacle.center.x - halfWidth &&\n      point.x <= obstacle.center.x + halfWidth &&\n      point.y >= obstacle.center.y - halfHeight &&\n      point.y <= obstacle.center.y + halfHeight\n    )\n  } else if (obstacle.type === \"oval\") {\n    const normalizedX = (point.x - obstacle.center.x) / halfWidth\n    const normalizedY = (point.y - obstacle.center.y) / halfHeight\n    return normalizedX * normalizedX + normalizedY * normalizedY <= 1\n  }\n\n  return false\n}\n","interface Point {\n  x: number\n  y: number\n}\n\nexport interface RotatedRect {\n  center: Point\n  width: number\n  height: number\n  rotation: number\n}\n\ninterface Rect {\n  center: Point\n  width: number\n  height: number\n}\n\nexport function generateApproximatingRects(\n  rotatedRect: RotatedRect,\n  numRects: number = 4,\n): Rect[] {\n  const { center, width, height, rotation } = rotatedRect\n  const rects: Rect[] = []\n\n  const angleRad = (rotation * Math.PI) / 180\n  const cosAngle = Math.cos(angleRad)\n  const sinAngle = Math.sin(angleRad)\n\n  const normalizedRotation = ((rotation % 360) + 360) % 360\n  const sliceAlongWidth =\n    height <= width\n      ? (normalizedRotation >= 45 && normalizedRotation < 135) ||\n        (normalizedRotation >= 225 && normalizedRotation < 315)\n      : (normalizedRotation >= 135 && normalizedRotation < 225) ||\n        normalizedRotation >= 315 ||\n        normalizedRotation < 45\n\n  if (sliceAlongWidth) {\n    const sliceWidth = width / numRects\n\n    for (let i = 0; i < numRects; i++) {\n      const x = (i - numRects / 2 + 0.5) * sliceWidth\n\n      const rotatedX = -x * cosAngle\n      const rotatedY = -x * sinAngle\n\n      const coverageWidth = sliceWidth * 1.1\n      const coverageHeight =\n        Math.abs(height * cosAngle) + Math.abs(sliceWidth * sinAngle)\n\n      rects.push({\n        center: {\n          x: center.x + rotatedX,\n          y: center.y + rotatedY,\n        },\n        width: coverageWidth,\n        height: coverageHeight,\n      })\n    }\n  } else {\n    const sliceHeight = height / numRects\n\n    for (let i = 0; i < numRects; i++) {\n      const y = (i - numRects / 2 + 0.5) * sliceHeight\n\n      const rotatedX = -y * sinAngle\n      const rotatedY = y * cosAngle\n\n      const coverageWidth =\n        Math.abs(width * cosAngle) + Math.abs(sliceHeight * sinAngle)\n      const coverageHeight = sliceHeight * 1.1\n\n      rects.push({\n        center: {\n          x: center.x + rotatedX,\n          y: center.y + rotatedY,\n        },\n        width: coverageWidth,\n        height: coverageHeight,\n      })\n    }\n  }\n\n  return rects\n}\n","import type { Obstacle } from \"../types\"\nimport { getObstaclesFromRoute } from \"./getObstaclesFromRoute\"\nimport type { ConnectivityMap } from \"circuit-json-to-connectivity-map\"\nimport type { AnyCircuitElement } from \"circuit-json\"\nimport {\n  generateApproximatingRects,\n  type RotatedRect,\n} from \"./generateApproximatingRects\"\n\nconst EVERY_LAYER = [\"top\", \"inner1\", \"inner2\", \"bottom\"]\n\nexport const getObstaclesFromCircuitJson = (\n  soup: AnyCircuitElement[],\n  connMap?: ConnectivityMap,\n) => {\n  const withNetId = (idList: string[]) =>\n    connMap\n      ? idList.concat(\n          idList.map((id) => connMap?.getNetConnectedToId(id)!).filter(Boolean),\n        )\n      : idList\n  const obstacles: Obstacle[] = []\n  for (const element of soup) {\n    if (element.type === \"pcb_smtpad\") {\n      if (element.shape === \"circle\") {\n        obstacles.push({\n          // @ts-ignore\n          type: \"oval\",\n          layers: [element.layer],\n          center: {\n            x: element.x,\n            y: element.y,\n          },\n          width: element.radius * 2,\n          height: element.radius * 2,\n          connectedTo: withNetId([element.pcb_smtpad_id]),\n        })\n      } else if (element.shape === \"rect\") {\n        obstacles.push({\n          type: \"rect\",\n          layers: [element.layer],\n          center: {\n            x: element.x,\n            y: element.y,\n          },\n          width: element.width,\n          height: element.height,\n          connectedTo: withNetId([element.pcb_smtpad_id]),\n        })\n      } else if (element.shape === \"rotated_rect\") {\n        const rotatedRect: RotatedRect = {\n          center: { x: element.x, y: element.y },\n          width: element.width,\n          height: element.height,\n          rotation: element.ccw_rotation,\n        }\n        const approximatingRects = generateApproximatingRects(rotatedRect)\n        for (const rect of approximatingRects) {\n          obstacles.push({\n            type: \"rect\",\n            layers: [element.layer],\n            center: rect.center,\n            width: rect.width,\n            height: rect.height,\n            connectedTo: withNetId([element.pcb_smtpad_id]),\n          })\n        }\n      }\n    } else if (element.type === \"pcb_keepout\") {\n      if (element.shape === \"circle\") {\n        obstacles.push({\n          // @ts-ignore\n          type: \"oval\",\n          layers: element.layers,\n          center: {\n            x: element.center.x,\n            y: element.center.y,\n          },\n          width: element.radius * 2,\n          height: element.radius * 2,\n          connectedTo: [],\n        })\n      } else if (element.shape === \"rect\") {\n        obstacles.push({\n          type: \"rect\",\n          layers: element.layers,\n          center: {\n            x: element.center.x,\n            y: element.center.y,\n          },\n          width: element.width,\n          height: element.height,\n          connectedTo: [],\n        })\n      }\n    } else if (element.type === \"pcb_hole\") {\n      if (element.hole_shape === \"oval\") {\n        obstacles.push({\n          // @ts-ignore\n          type: \"oval\",\n          center: {\n            x: element.x,\n            y: element.y,\n          },\n          width: element.hole_width,\n          height: element.hole_height,\n          connectedTo: [],\n        })\n      } else if (element.hole_shape === \"square\") {\n        obstacles.push({\n          type: \"rect\",\n          layers: EVERY_LAYER,\n          center: {\n            x: element.x,\n            y: element.y,\n          },\n          width: element.hole_diameter,\n          height: element.hole_diameter,\n          connectedTo: [],\n        })\n      } else if (\n        // @ts-ignore\n        element.hole_shape === \"round\" ||\n        element.hole_shape === \"circle\"\n      ) {\n        obstacles.push({\n          type: \"rect\",\n          layers: EVERY_LAYER,\n          center: {\n            x: element.x,\n            y: element.y,\n          },\n          width: element.hole_diameter,\n          height: element.hole_diameter,\n          connectedTo: [],\n        })\n      }\n    } else if (element.type === \"pcb_plated_hole\") {\n      if (element.shape === \"circle\") {\n        obstacles.push({\n          // @ts-ignore\n          type: \"oval\",\n          layers: EVERY_LAYER,\n          center: {\n            x: element.x,\n            y: element.y,\n          },\n          width: element.outer_diameter,\n          height: element.outer_diameter,\n          connectedTo: withNetId([element.pcb_plated_hole_id]),\n        })\n      } else if (element.shape === \"oval\" || element.shape === \"pill\") {\n        obstacles.push({\n          // @ts-ignore\n          type: \"oval\",\n          layers: EVERY_LAYER,\n          center: {\n            x: element.x,\n            y: element.y,\n          },\n          width: element.outer_width,\n          height: element.outer_height,\n          connectedTo: withNetId([element.pcb_plated_hole_id]),\n        })\n      }\n    } else if (element.type === \"pcb_trace\") {\n      const traceObstacles = getObstaclesFromRoute(\n        element.route.map((rp) => ({\n          x: rp.x,\n          y: rp.y,\n          layer: \"layer\" in rp ? rp.layer : rp.from_layer,\n        })),\n        element.source_trace_id!,\n      )\n      obstacles.push(...traceObstacles)\n    } else if (element.type === \"pcb_via\") {\n      obstacles.push({\n        type: \"rect\",\n        layers: element.layers,\n        center: {\n          x: element.x,\n          y: element.y,\n        },\n        connectedTo: [], // TODO we can associate source_ports with this via\n        width: element.outer_diameter,\n        height: element.outer_diameter,\n      })\n    }\n  }\n  return obstacles\n}\n","import now from \"performance-now\"\n\ninterface TimerEntry {\n  label: string\n  start: number\n  end?: number\n}\n\nexport class Timer {\n  private timers: Map<string, TimerEntry[]> = new Map()\n  private activeTimers: TimerEntry[] = []\n  private logOnEnd: boolean\n\n  constructor(options: { logOnEnd?: boolean } = {}) {\n    this.logOnEnd = options.logOnEnd || false\n  }\n\n  start(label: string): void {\n    const entry: TimerEntry = {\n      label,\n      start: now(),\n    }\n    this.activeTimers.push(entry)\n\n    if (!this.timers.has(label)) {\n      this.timers.set(label, [])\n    }\n    this.timers.get(label)!.push(entry)\n  }\n\n  end(label?: string): void {\n    if (this.activeTimers.length === 0) {\n      return\n    }\n\n    const endTime = now()\n    let timerToEnd: TimerEntry\n\n    if (label) {\n      const index = this.activeTimers.findLastIndex(\n        (timer) => timer.label === label,\n      )\n      if (index === -1) {\n        console.warn(`Timer \"${label}\" was never started`)\n        return\n      }\n      timerToEnd = this.activeTimers[index]\n      this.activeTimers.splice(index, 1)\n    } else {\n      timerToEnd = this.activeTimers.pop()!\n    }\n\n    timerToEnd.end = endTime\n    const duration = timerToEnd.end - timerToEnd.start\n\n    if (this.logOnEnd) {\n      console.log(`${timerToEnd.label}: ${duration.toFixed(3)}ms`)\n    }\n  }\n\n  logAll(): void {\n    for (const [label, timers] of this.timers.entries()) {\n      const completedTimers = timers.filter((timer) => timer.end !== undefined)\n      if (completedTimers.length === 0) {\n        console.warn(`No completed timings for \"${label}\"`)\n        continue\n      }\n\n      const totalTime = completedTimers.reduce(\n        (acc, timer) => acc + (timer.end! - timer.start),\n        0,\n      )\n      const avgTime = totalTime / completedTimers.length\n      console.log(\n        `${label}: ${avgTime.toFixed(3)}ms (${completedTimers.length}/${timers.length} calls)`,\n      )\n    }\n\n    if (this.activeTimers.length > 0) {\n      console.warn(\n        \"There are still active timers:\",\n        this.activeTimers.map((timer) => timer.label).join(\", \"),\n      )\n    }\n  }\n\n  reset(): void {\n    this.timers.clear()\n    this.activeTimers = []\n  }\n}\n","import type { AnyCircuitElement as AnySoupElement } from \"circuit-json\"\nimport {\n  getObstaclesFromCircuitJson,\n  type Obstacle,\n  type PointWithLayer,\n  type SimpleRouteConnection,\n  type SimpleRouteJson,\n} from \"solver-utils\"\nimport {\n  type ConnectivityMap,\n  getFullConnectivityMapFromCircuitJson,\n  PcbConnectivityMap,\n} from \"circuit-json-to-connectivity-map\"\nimport type { ConnectionWithGoalAlternatives } from \"./ConnectionWithAlternatives\"\nimport { findNearestPointsBetweenBoxSets } from \"@tscircuit/math-utils/nearest-box\"\n\n/**\n * Given an element id, returns a list of obstacles that are an\n * alternative to reaching the goal element.\n *\n * These can then be analyzed to find potentially shorter routes\n */\nexport function getAlternativeGoalBoxes(params: {\n  pcbConnMap: PcbConnectivityMap\n  goalElementId: string\n}): Obstacle[] {\n  const { pcbConnMap, goalElementId } = params\n\n  if (!goalElementId.startsWith(\"pcb_port_\")) {\n    throw new Error(\n      `Currently alternative goal boxes must have a goal id with prefix \"pcb_port_\" (got ${goalElementId})`,\n    )\n  }\n\n  const goalTraces = pcbConnMap.getAllTracesConnectedToPort(goalElementId)\n\n  return getObstaclesFromCircuitJson(goalTraces).map((obs) => ({\n    ...obs,\n    connectedTo: [goalElementId],\n  }))\n}\n\nexport const getConnectionWithAlternativeGoalBoxes = (params: {\n  connection: SimpleRouteConnection\n  pcbConnMap: PcbConnectivityMap\n}): ConnectionWithGoalAlternatives => {\n  let { connection, pcbConnMap } = params\n\n  if (connection.pointsToConnect.length !== 2) {\n    throw new Error(\n      `Connection must have exactly 2 points for alternative goal boxes (got ${connection.pointsToConnect.length})`,\n    )\n  }\n\n  const [a, b] = connection.pointsToConnect\n\n  // TODO fix only one of them needs to have a pcb port id defined, or even\n  // neither of them and we return an empty goal box array\n  if (!a.pcb_port_id || !b.pcb_port_id) {\n    throw new Error(\n      `Connection points must have pcb_port_id for alternative goal box calculation (got ${a.pcb_port_id} and ${b.pcb_port_id})`,\n    )\n  }\n\n  const goalBoxesA = getAlternativeGoalBoxes({\n    goalElementId: a.pcb_port_id,\n    pcbConnMap,\n  }).concat([\n    {\n      center: a,\n      width: 0.01,\n      height: 0.01,\n      connectedTo: [a.pcb_port_id],\n      layers: [a.layer],\n      type: \"rect\",\n    },\n  ])\n  const goalBoxesB = getAlternativeGoalBoxes({\n    goalElementId: b.pcb_port_id,\n    pcbConnMap,\n  }).concat([\n    {\n      center: b,\n      width: 0.01,\n      height: 0.01,\n      connectedTo: [b.pcb_port_id],\n      layers: [b.layer],\n      type: \"rect\",\n    },\n  ])\n\n  if (goalBoxesA.length <= 1 && goalBoxesB.length <= 1) {\n    return {\n      ...connection,\n      startPoint: a,\n      endPoint: b,\n      goalBoxes: [],\n    }\n  }\n\n  // Find new points to connect based on the alternative goal boxes\n  const nearestPoints = findNearestPointsBetweenBoxSets(goalBoxesA, goalBoxesB)\n\n  let startPoint: PointWithLayer\n  let endPoint: PointWithLayer\n  let goalBoxes: Obstacle[]\n\n  if (goalBoxesA.length >= goalBoxesB.length) {\n    startPoint = { ...b, ...nearestPoints.pointB }\n    endPoint = { ...a, ...nearestPoints.pointA }\n    goalBoxes = goalBoxesA\n  } else {\n    startPoint = { ...a, ...nearestPoints.pointA }\n    endPoint = { ...b, ...nearestPoints.pointB }\n    goalBoxes = goalBoxesB\n  }\n\n  return {\n    startPoint,\n    endPoint,\n    goalBoxes,\n    name: connection.name,\n    pointsToConnect: [startPoint, endPoint],\n  }\n}\n","import { GeneralizedAstarAutorouter } from \"./GeneralizedAstar\"\nimport type {\n  Direction,\n  DirectionWithCollisionInfo,\n  DirectionWithWallDistance,\n  Node,\n  Point,\n  PointWithObstacleHit,\n  PointWithWallDistance,\n} from \"./types\"\nimport { clamp, dirFromAToB, dist, distAlongDir, manDist } from \"./util\"\nimport { getDistanceToOvercomeObstacle } from \"./getDistanceToOvercomeObstacle\"\n\nexport class IJumpMultiMarginAutorouter extends GeneralizedAstarAutorouter {\n  MAX_ITERATIONS: number = 500\n\n  /**\n   * For a multi-margin autorouter, we penalize traveling close to the wall\n   *\n   * The best way to compute cost is to multiple the travelMargin cost factor by\n   * the distance traveled by along the wall and add the enterMargin cost factor\n   * whenever we enter a new margin\n   *\n   * MUST BE ORDERED FROM HIGHEST MARGIN TO LOWEST (TODO sort in constructor)\n   */\n  marginsWithCosts: Array<{\n    margin: number\n    enterCost: number\n    travelCostFactor: number\n  }> = [\n    {\n      margin: 1,\n      enterCost: 0,\n      travelCostFactor: 1,\n    },\n    {\n      margin: 0.15,\n      enterCost: 10,\n      travelCostFactor: 2,\n    },\n  ]\n\n  get largestMargin() {\n    return this.marginsWithCosts[0].margin\n  }\n\n  computeG(current: Node, neighbor: Point): number {\n    return (\n      current.g +\n      manDist(current, neighbor) * (current.travelMarginCostFactor ?? 1) +\n      ((neighbor as any).enterMarginCost ?? 0)\n    )\n  }\n\n  getNeighbors(node: Node): Array<PointWithObstacleHit> {\n    const obstacles = this.obstacles!\n    const goalPoint = this.goalPoint!\n\n    /**\n     * This is considered \"forward\" if we were to continue from the parent,\n     * through the current node.\n     */\n    let forwardDir: Direction\n    if (!node.parent) {\n      forwardDir = dirFromAToB(node, goalPoint)\n    } else {\n      forwardDir = dirFromAToB(node.parent, node)\n    }\n\n    /**\n     * Get the 2-3 next directions (excluding backwards direction), and\n     * excluding the forward direction if we just ran into a wall\n     */\n    const travelDirs1 = [\n      { dx: 0, dy: 1 },\n      { dx: 1, dy: 0 },\n      { dx: 0, dy: -1 },\n      { dx: -1, dy: 0 },\n    ]\n      .filter((dir) => {\n        // If we have a parent, don't go backwards towards the parent\n        if (dir.dx === forwardDir.dx * -1 && dir.dy === forwardDir.dy * -1) {\n          return false\n        } else if (\n          dir.dx === forwardDir.dx &&\n          dir.dy === forwardDir.dy &&\n          node.parent?.obstacleHit\n        ) {\n          return false\n        }\n        return true\n      })\n      .map((dir) =>\n        obstacles.getOrthoDirectionCollisionInfo(node, dir, {\n          margin: this.OBSTACLE_MARGIN,\n        }),\n      )\n      // Filter out directions that are too close to the wall\n      .filter((dir) => dir.wallDistance >= this.OBSTACLE_MARGIN)\n\n    /**\n     * Figure out how far to travel. There are a couple reasons we would stop\n     * traveling:\n     * - A different direction opened up while we were traveling (the obstacle\n     *   our parent hit was overcome)\n     * - We hit a wall\n     * - We passed the goal along the travel direction\n     */\n    const travelDirs2: Array<\n      DirectionWithCollisionInfo & {\n        travelDistance: number\n        travelMarginCostFactor: number\n        enterMarginCost: number\n      }\n    > = []\n    for (const travelDir of travelDirs1) {\n      let overcomeDistance: number | null = null\n      if (node?.obstacleHit) {\n        overcomeDistance = getDistanceToOvercomeObstacle({\n          node,\n          travelDir,\n          wallDir: { ...forwardDir, wallDistance: this.OBSTACLE_MARGIN },\n          obstacle: node.obstacleHit,\n          obstacles,\n          OBSTACLE_MARGIN: this.OBSTACLE_MARGIN,\n          SHOULD_DETECT_CONJOINED_OBSTACLES: true,\n        })\n      }\n\n      const goalDistAlongTravelDir = distAlongDir(node, goalPoint, travelDir)\n      const isGoalInTravelDir =\n        (travelDir.dx === 0 ||\n          Math.sign(goalPoint.x - node.x) === travelDir.dx) &&\n        (travelDir.dy === 0 || Math.sign(goalPoint.y - node.y) === travelDir.dy)\n\n      if (\n        goalDistAlongTravelDir < travelDir.wallDistance &&\n        goalDistAlongTravelDir > 0 &&\n        isGoalInTravelDir\n      ) {\n        travelDirs2.push({\n          ...travelDir,\n          travelDistance: goalDistAlongTravelDir,\n          enterMarginCost: 0,\n          travelMarginCostFactor: 1,\n        })\n      } else if (\n        overcomeDistance !== null &&\n        overcomeDistance < travelDir.wallDistance\n      ) {\n        for (const { margin, enterCost, travelCostFactor } of this\n          .marginsWithCosts) {\n          if (\n            overcomeDistance - this.OBSTACLE_MARGIN + margin * 2 <\n            travelDir.wallDistance\n          ) {\n            travelDirs2.push({\n              ...travelDir,\n              travelDistance: overcomeDistance - this.OBSTACLE_MARGIN + margin,\n              enterMarginCost: enterCost,\n              travelMarginCostFactor: travelCostFactor,\n            })\n          }\n        }\n        if (travelDir.wallDistance === Infinity) {\n          travelDirs2.push({\n            ...travelDir,\n            travelDistance: goalDistAlongTravelDir,\n            enterMarginCost: 0,\n            travelMarginCostFactor: 1,\n          })\n        } else if (travelDir.wallDistance > this.largestMargin) {\n          for (const { margin, enterCost, travelCostFactor } of this\n            .marginsWithCosts) {\n            if (travelDir.wallDistance > this.largestMargin + margin) {\n              travelDirs2.push({\n                ...travelDir,\n                travelDistance: travelDir.wallDistance - margin,\n                enterMarginCost: enterCost,\n                travelMarginCostFactor: travelCostFactor,\n              })\n            }\n          }\n        }\n      } else if (travelDir.wallDistance !== Infinity) {\n        for (const { margin, enterCost, travelCostFactor } of this\n          .marginsWithCosts) {\n          if (travelDir.wallDistance > margin) {\n            travelDirs2.push({\n              ...travelDir,\n              travelDistance: travelDir.wallDistance - margin,\n              enterMarginCost: enterCost,\n              travelMarginCostFactor: travelCostFactor,\n            })\n          }\n        }\n      }\n    }\n\n    return (\n      travelDirs2\n        // If an obstacle fails this check, we messed up computing neighbors\n        // Currently this happens when we overcome obstacles and there's a\n        // different obstacle in the travel direction\n        .filter((dir) => {\n          return !obstacles.isObstacleAt(\n            node.x + dir.dx * dir.travelDistance,\n            node.y + dir.dy * dir.travelDistance,\n          )\n        })\n        .map((dir) => ({\n          x: node.x + dir.dx * dir.travelDistance,\n          y: node.y + dir.dy * dir.travelDistance,\n          obstacleHit: dir.obstacle,\n          travelMarginCostFactor: dir.travelMarginCostFactor,\n          enterMarginCost: dir.enterMarginCost,\n        }))\n    )\n  }\n}\n","import type { Point3d, Direction3d } from \"./types\"\n\nexport function dirFromAToB(nodeA: Point3d, nodeB: Point3d): Direction3d {\n  const dx = nodeB.x > nodeA.x ? 1 : nodeB.x < nodeA.x ? -1 : 0\n  const dy = nodeB.y > nodeA.y ? 1 : nodeB.y < nodeA.y ? -1 : 0\n  const dl = nodeB.l > nodeA.l ? 1 : nodeB.l < nodeA.l ? -1 : 0\n  return { dx, dy, dl }\n}\n\nexport function manDist(a: Point3d, b: Point3d): number {\n  return Math.abs(a.x - b.x) + Math.abs(a.y - b.y) + Math.abs(a.l - b.l)\n}\n\nexport const LAYER_COUNT_INDEX_MAP: Record<number, string[]> = {\n  1: [\"top\"],\n  2: [\"top\", \"bottom\"],\n  4: [\"top\", \"inner1\", \"inner2\", \"bottom\"],\n}\n\nexport const getLayerNamesForLayerCount = (layerCount: number): string[] => {\n  return LAYER_COUNT_INDEX_MAP[layerCount]\n}\n\nexport function getLayerIndex(layerCount: number, layer: string): number {\n  const layerArray = LAYER_COUNT_INDEX_MAP[layerCount]\n  const index = layerArray.indexOf(layer)\n  if (index === -1) {\n    throw new Error(\n      `Invalid layer for getLayerIndex (for layerCount === ${layerCount}): \"${layer}\"`,\n    )\n  }\n  return index\n}\n\nexport function indexToLayer(layerCount: number, index: number): string {\n  const layerArray = LAYER_COUNT_INDEX_MAP[layerCount]\n  const layer = layerArray[index]\n  if (!layer) {\n    throw new Error(\n      `Invalid index for indexToLayer (for layerCount === ${layerCount}): \"${index}\"`,\n    )\n  }\n  return layer\n}\n","// ObstacleList3d.ts\n\nimport type { Obstacle, ObstacleWithEdges } from \"solver-utils\"\nimport type {\n  Direction3d,\n  DirectionDistances3d,\n  DirectionWithCollisionInfo3d,\n  ObstacleWithEdges3d,\n  Point3d,\n} from \"./types\"\nimport { getLayerIndex, getLayerNamesForLayerCount } from \"./util\"\nimport { ObstacleList } from \"algos/infinite-grid-ijump-astar/v2/lib/ObstacleList\"\n\n/**\n * A list of obstacles with functions for fast lookups, this default implementation\n * has no optimizations, you should override this class to implement faster lookups\n */\nexport class ObstacleList3d extends ObstacleList {\n  obstacles: ObstacleWithEdges3d[]\n  GRID_STEP = 0.1\n  layerCount: number\n\n  constructor(layerCount: number, obstacles: Array<Obstacle>) {\n    super([])\n    this.layerCount = layerCount\n    const availableLayers = getLayerNamesForLayerCount(layerCount)\n    this.obstacles = obstacles.flatMap((obstacle) =>\n      obstacle.layers\n        .filter((layer) => availableLayers.includes(layer))\n        .map((layer) => ({\n          ...obstacle,\n          left: obstacle.center.x - obstacle.width / 2,\n          right: obstacle.center.x + obstacle.width / 2,\n          top: obstacle.center.y + obstacle.height / 2,\n          bottom: obstacle.center.y - obstacle.height / 2,\n          l: getLayerIndex(layerCount, layer),\n        })),\n    )\n  }\n\n  getObstacleAt(x: number, y: number, l: number, m?: number): Obstacle | null {\n    m ??= this.GRID_STEP\n    for (const obstacle of this.obstacles) {\n      if (obstacle.l !== l) continue // Only consider obstacles on the same layer\n      const halfWidth = obstacle.width / 2 + m\n      const halfHeight = obstacle.height / 2 + m\n      if (\n        x >= obstacle.center.x - halfWidth &&\n        x <= obstacle.center.x + halfWidth &&\n        y >= obstacle.center.y - halfHeight &&\n        y <= obstacle.center.y + halfHeight\n      ) {\n        return obstacle\n      }\n    }\n    return null\n  }\n\n  isObstacleAt(x: number, y: number, l: number, m?: number): boolean {\n    return this.getObstacleAt(x, y, l, m) !== null\n  }\n\n  getDirectionDistancesToNearestObstacle3d(\n    x: number,\n    y: number,\n    l: number,\n  ): DirectionDistances3d {\n    const { GRID_STEP } = this\n    const result: DirectionDistances3d = {\n      left: Infinity,\n      top: Infinity,\n      bottom: Infinity,\n      right: Infinity,\n    }\n\n    for (const obstacle of this.obstacles) {\n      if (obstacle.l !== l) continue // Only consider obstacles on the same layer\n      if (obstacle.type === \"rect\") {\n        const left = obstacle.center.x - obstacle.width / 2 - GRID_STEP\n        const right = obstacle.center.x + obstacle.width / 2 + GRID_STEP\n        const top = obstacle.center.y + obstacle.height / 2 + GRID_STEP\n        const bottom = obstacle.center.y - obstacle.height / 2 - GRID_STEP\n\n        // Check left\n        if (y >= bottom && y <= top && x > left) {\n          result.left = Math.min(result.left, x - right)\n        }\n\n        // Check right\n        if (y >= bottom && y <= top && x < right) {\n          result.right = Math.min(result.right, left - x)\n        }\n\n        // Check top\n        if (x >= left && x <= right && y < top) {\n          result.top = Math.min(result.top, bottom - y)\n        }\n\n        // Check bottom\n        if (x >= left && x <= right && y > bottom) {\n          result.bottom = Math.min(result.bottom, y - top)\n        }\n      }\n    }\n\n    return result\n  }\n\n  getOrthoDirectionCollisionInfo(\n    point: Point3d,\n    dir: Direction3d,\n    { margin = 0 }: { margin?: number } = {},\n  ): DirectionWithCollisionInfo3d {\n    const { x, y, l } = point\n    const { dx, dy, dl } = dir\n    let minDistance = Infinity\n    let collisionObstacle: ObstacleWithEdges | null = null\n\n    if (dl !== 0) {\n      // Moving between layers\n      const newLayer = l + dl\n      // Check if there's an obstacle at the same (x, y) on the new layer\n      if (this.isObstacleAt(x, y, newLayer, margin)) {\n        minDistance = 1 // Distance to obstacle is 1 (layer change)\n        collisionObstacle = this.getObstacleAt(\n          x,\n          y,\n          newLayer,\n          margin,\n        ) as ObstacleWithEdges\n      } else {\n        minDistance = 1 // Distance to move to the next layer\n      }\n\n      return {\n        dx,\n        dy,\n        dl,\n        wallDistance: minDistance,\n        obstacle: collisionObstacle,\n      }\n    } else {\n      // Moving within the same layer\n      for (const obstacle of this.obstacles) {\n        if (obstacle.l !== l) continue // Only consider obstacles on the same layer\n\n        const leftMargin = obstacle.left - margin\n        const rightMargin = obstacle.right + margin\n        const topMargin = obstacle.top + margin\n        const bottomMargin = obstacle.bottom - margin\n\n        let distance: number | null = null\n\n        if (dx === 1 && dy === 0) {\n          // Right\n          if (y > bottomMargin && y < topMargin && x < obstacle.left) {\n            distance = obstacle.left - x\n          }\n        } else if (dx === -1 && dy === 0) {\n          // Left\n          if (y > bottomMargin && y < topMargin && x > obstacle.right) {\n            distance = x - obstacle.right\n          }\n        } else if (dx === 0 && dy === 1) {\n          // Up\n          if (x > leftMargin && x < rightMargin && y < obstacle.bottom) {\n            distance = obstacle.bottom - y\n          }\n        } else if (dx === 0 && dy === -1) {\n          // Down\n          if (x > leftMargin && x < rightMargin && y > obstacle.top) {\n            distance = y - obstacle.top\n          }\n        }\n\n        if (distance !== null && distance < minDistance) {\n          minDistance = distance\n          collisionObstacle = obstacle\n        }\n      }\n\n      return {\n        dx,\n        dy,\n        dl: 0,\n        wallDistance: minDistance,\n        obstacle: collisionObstacle as ObstacleWithEdges,\n      }\n    }\n  }\n\n  getObstaclesOverlappingRegion(region: {\n    minX: number\n    minY: number\n    maxX: number\n    maxY: number\n    l: number // Layer to check\n  }): ObstacleWithEdges[] {\n    const obstacles: ObstacleWithEdges[] = []\n    for (const obstacle of this.obstacles) {\n      if (obstacle.l !== region.l) continue // Only consider obstacles on the specified layer\n      const { left, right, top, bottom } = obstacle\n\n      if (\n        left <= region.maxX &&\n        right >= region.minX &&\n        top >= region.minY &&\n        bottom <= region.maxY\n      ) {\n        obstacles.push(obstacle)\n      }\n    }\n\n    return obstacles\n  }\n}\n","import {\n  GeneralizedAstarAutorouter,\n  type ConnectionSolveResult,\n} from \"algos/infinite-grid-ijump-astar/v2/lib/GeneralizedAstar\"\nimport { getDistanceToOvercomeObstacle } from \"algos/infinite-grid-ijump-astar/v2/lib/getDistanceToOvercomeObstacle\"\nimport type {\n  Direction,\n  Point,\n  PointWithObstacleHit,\n  Node,\n  DirectionWithCollisionInfo,\n} from \"algos/infinite-grid-ijump-astar/v2/lib/types\"\nimport {\n  distAlongDir,\n  manDist,\n  nodeName,\n} from \"algos/infinite-grid-ijump-astar/v2/lib/util\"\nimport type {\n  Direction3d,\n  DirectionWithCollisionInfo3d,\n  Node3d,\n  Point3dWithObstacleHit,\n} from \"./types\"\nimport { dirFromAToB, getLayerIndex, indexToLayer } from \"./util\"\nimport type {\n  SimpleRouteConnection,\n  SimpleRouteJson,\n} from \"autorouting-dataset/lib/solver-utils/SimpleRouteJson\"\nimport { ObstacleList3d } from \"./ObstacleList3d\"\nimport type { Obstacle } from \"autorouting-dataset/lib/types\"\nimport {\n  PcbConnectivityMap,\n  type ConnectivityMap,\n} from \"circuit-json-to-connectivity-map\"\nimport type { ConnectionWithGoalAlternatives } from \"autorouting-dataset/lib/solver-utils/ConnectionWithAlternatives\"\nimport { nanoid } from \"nanoid\"\nimport type { LayerRef, PCBTrace } from \"circuit-json\"\nimport {\n  getAlternativeGoalBoxes,\n  getConnectionWithAlternativeGoalBoxes,\n} from \"autorouting-dataset/lib/solver-utils/getAlternativeGoalBoxes\"\n\nexport class MultilayerIjump extends GeneralizedAstarAutorouter {\n  MAX_ITERATIONS: number = 500\n  VIA_COST: number = 4 // Define the cost for changing layers\n  VIA_DIAMETER: number = 0.5\n  allowLayerChange: boolean = true // Flag to allow layer changes\n  layerCount: number\n  obstacles: ObstacleList3d\n  optimizeWithGoalBoxes: boolean\n  /**\n   * Use this to convert ids into \"net ids\", obstacles will have a net id in\n   * their connectedTo array most of the time\n   */\n  connMap: ConnectivityMap | undefined\n\n  /**\n   * Use this to track what traces have been connected to a net while routing,\n   * this is required for generating alternative goal boxes while routing\n   */\n  pcbConnMap: PcbConnectivityMap\n\n  GOAL_RUSH_FACTOR: number = 1.1\n\n  // TODO we need to travel far enough away from the goal so that we're not\n  // hitting a pad, which means we need to know the bounds of the goal\n  // The simplest way to do this is to change SimpleJsonInput to include a\n  // goalViaMargin, set this.goalViaMargin then add that value here\n  defaultGoalViaMargin = 0.5\n\n  /**\n   * For a multi-margin autorouter, we penalize traveling close to the wall\n   *\n   * The best way to compute cost is to multiple the travelMargin cost factor by\n   * the distance traveled by along the wall and add the enterMargin cost factor\n   * whenever we enter a new margin\n   *\n   * MUST BE ORDERED FROM HIGHEST MARGIN TO LOWEST (TODO sort in constructor)\n   */\n  marginsWithCosts: Array<{\n    margin: number\n    enterCost: number\n    travelCostFactor: number\n  }>\n\n  get largestMargin() {\n    return this.marginsWithCosts[0].margin\n  }\n\n  constructor(opts: {\n    input: SimpleRouteJson\n    startNode?: Node\n    goalPoint?: Point\n    GRID_STEP?: number\n    OBSTACLE_MARGIN?: number\n    MAX_ITERATIONS?: number\n    VIA_COST?: number\n    isRemovePathLoopsEnabled?: boolean\n    isShortenPathWithShortcutsEnabled?: boolean\n    connMap?: ConnectivityMap\n    pcbConnMap?: PcbConnectivityMap\n    optimizeWithGoalBoxes?: boolean\n    marginsWithCosts?: Array<{\n      margin: number\n      enterCost: number\n      travelCostFactor: number\n    }>\n    debug?: boolean\n  }) {\n    super(opts)\n    this.layerCount = opts.input.layerCount ?? 2\n    this.MAX_ITERATIONS = opts.MAX_ITERATIONS ?? this.MAX_ITERATIONS\n    this.VIA_COST = opts.VIA_COST ?? this.VIA_COST\n    this.connMap = opts.connMap\n    this.pcbConnMap = opts.pcbConnMap ?? new PcbConnectivityMap()\n    this.optimizeWithGoalBoxes = opts.optimizeWithGoalBoxes ?? false\n    // obstacle lists are created when solving currently\n    this.obstacles = null as any // new ObstacleList3d(this.layerCount, this.allObstacles)\n\n    this.marginsWithCosts = opts.marginsWithCosts ?? [\n      {\n        margin: 1,\n        enterCost: 0,\n        travelCostFactor: 1,\n      },\n      {\n        margin: this.OBSTACLE_MARGIN,\n        enterCost: 10,\n        travelCostFactor: 2,\n      },\n    ]\n  }\n\n  preprocessConnectionBeforeSolving(\n    connection: SimpleRouteConnection,\n  ): ConnectionWithGoalAlternatives {\n    if (!this.optimizeWithGoalBoxes) return connection as any\n    return getConnectionWithAlternativeGoalBoxes({\n      connection,\n      pcbConnMap: this.pcbConnMap!,\n    })\n  }\n\n  /**\n   * Add solved traces to pcbConnMap\n   */\n  postprocessConnectionSolveResult(\n    connection: SimpleRouteConnection,\n    result: ConnectionSolveResult,\n  ): ConnectionSolveResult {\n    if (!result.solved) return result\n\n    // Add the trace to the pcbConnMap\n    if (this.optimizeWithGoalBoxes) {\n      const traceRoute = result.route.map(\n        (rp) =>\n          ({\n            x: rp.x,\n            y: rp.y,\n            route_type: \"wire\",\n            layer: rp.layer as LayerRef,\n            width: this.input.minTraceWidth,\n          }) as Extract<PCBTrace[\"route\"][number], { route_type: \"wire\" }>,\n      )\n      traceRoute[0].start_pcb_port_id =\n        connection.pointsToConnect[0].pcb_port_id\n      traceRoute[traceRoute.length - 1].end_pcb_port_id =\n        connection.pointsToConnect[1].pcb_port_id\n\n      this.pcbConnMap.addTrace({\n        type: \"pcb_trace\",\n        pcb_trace_id: `postprocess_trace_${nanoid(8)}`,\n        route: traceRoute,\n      })\n    }\n\n    return result\n  }\n\n  createObstacleList({\n    dominantLayer,\n    connection,\n    obstaclesFromTraces,\n  }: {\n    dominantLayer?: string\n    connection: SimpleRouteConnection\n    obstaclesFromTraces: Obstacle[]\n  }): ObstacleList3d {\n    const bestConnectionId = this.connMap\n      ? this.connMap.getNetConnectedToId(connection.name)\n      : connection.name\n\n    if (!bestConnectionId) {\n      throw new Error(\n        `The connection.name \"${connection.name}\" wasn't present in the full connectivity map`,\n      )\n    }\n\n    return new ObstacleList3d(\n      this.layerCount,\n      this.allObstacles\n        .filter((obstacle) => !obstacle.connectedTo.includes(bestConnectionId))\n        .concat(obstaclesFromTraces ?? []),\n    )\n  }\n\n  computeG(current: Node3d, neighbor: Node3d): number {\n    let cost =\n      current.g +\n      manDist(current, neighbor) * (current.travelMarginCostFactor ?? 1) +\n      (neighbor.enterMarginCost ?? 0)\n    if (neighbor.l ?? -1 !== current.l ?? -1) {\n      cost += this.VIA_COST\n    }\n    return cost\n  }\n\n  computeH(node: Node3d): number {\n    const dx = Math.abs(node.x - this.goalPoint!.x)\n    const dy = Math.abs(node.y - this.goalPoint!.y)\n    const dl = Math.abs(node.l - (this.goalPoint as any).l)\n    return (dx + dy) ** this.GOAL_RUSH_FACTOR + dl * this.VIA_COST\n  }\n\n  getStartNode(connection: SimpleRouteConnection): Node3d {\n    return {\n      ...super.getStartNode(connection),\n      l: this.layerToIndex(connection.pointsToConnect[0].layer),\n    } as any\n  }\n\n  layerToIndex(layer: string): number {\n    return getLayerIndex(this.layerCount, layer)\n  }\n  indexToLayer(index: number): string {\n    return indexToLayer(this.layerCount, index)\n  }\n\n  getNodeName(node: Node3d): string {\n    return `${nodeName(node, this.GRID_STEP)}-${node.l ?? 0}`\n  }\n\n  hasSpaceForVia(layers: number[], point: Point) {\n    return layers.every(\n      (l) =>\n        this.obstacles.getObstaclesOverlappingRegion({\n          minX: point.x - this.VIA_DIAMETER / 2 - this.OBSTACLE_MARGIN,\n          minY: point.y - this.VIA_DIAMETER / 2 - this.OBSTACLE_MARGIN,\n          maxX: point.x + this.VIA_DIAMETER / 2 + this.OBSTACLE_MARGIN,\n          maxY: point.y + this.VIA_DIAMETER / 2 + this.OBSTACLE_MARGIN,\n          l,\n        }).length === 0,\n    )\n  }\n\n  getNeighborsSurroundingGoal(node: Node3d): Array<Point3dWithObstacleHit> {\n    const obstacles = this.obstacles!\n    const goalPoint: Node3d = this.goalPoint! as any\n\n    const neighbors: Array<Point3dWithObstacleHit> = []\n\n    const travelDirs: Array<Direction3d> = [\n      { dx: 1, dy: 0, dl: 0 },\n      { dx: -1, dy: 0, dl: 0 },\n      { dx: 0, dy: 1, dl: 0 },\n      { dx: 0, dy: -1, dl: 0 },\n    ]\n\n    const travelDistance =\n      this.VIA_DIAMETER + this.OBSTACLE_MARGIN + this.defaultGoalViaMargin\n\n    for (const dir of travelDirs) {\n      const candidateNeighbor = {\n        x: node.x + dir.dx * travelDistance,\n        y: node.y + dir.dy * travelDistance,\n        l: node.l + dir.dl,\n        obstacleHit: null,\n      }\n      if (!this.hasSpaceForVia([node.l, goalPoint.l], candidateNeighbor)) {\n        continue\n      }\n\n      neighbors.push(candidateNeighbor)\n    }\n\n    return neighbors\n  }\n\n  getNeighbors(node: Node3d): Array<Point3dWithObstacleHit> {\n    const obstacles = this.obstacles!\n    const goalPoint: Node3d = this.goalPoint! as any\n\n    const goalDistIgnoringLayer = manDist(node, goalPoint)\n\n    // Edgecase: If we're on top of the goal but we're on the wrong layer, we\n    // should add points around the goal point to try to via up\n    if (goalDistIgnoringLayer <= this.OBSTACLE_MARGIN) {\n      return this.getNeighborsSurroundingGoal(node)\n    }\n\n    /**\n     * This is considered \"forward\" if we were to continue from the parent,\n     * through the current node.\n     */\n    let forwardDir: Direction3d\n    if (!node.parent) {\n      forwardDir = dirFromAToB(node, goalPoint)\n    } else {\n      forwardDir = dirFromAToB(node.parent, node)\n    }\n\n    /**\n     * Get the possible next directions (excluding backwards direction), and\n     * excluding the forward direction if we just ran into a wall\n     */\n    const travelDirs1: Array<Direction3d> = [\n      { dx: 0, dy: 1, dl: 0 },\n      { dx: 1, dy: 0, dl: 0 },\n      { dx: 0, dy: -1, dl: 0 },\n      { dx: -1, dy: 0, dl: 0 },\n    ]\n\n    const isFarEnoughFromGoalToChangeLayer =\n      goalDistIgnoringLayer > this.VIA_DIAMETER + this.OBSTACLE_MARGIN\n    const isFarEnoughFromStartToChangeLayer =\n      manDist(node, this.startNode!) > this.VIA_DIAMETER + this.OBSTACLE_MARGIN\n\n    if (\n      this.allowLayerChange &&\n      isFarEnoughFromGoalToChangeLayer &&\n      isFarEnoughFromStartToChangeLayer\n    ) {\n      if (node.l < this.layerCount - 1) {\n        travelDirs1.push({ dx: 0, dy: 0, dl: 1 })\n      }\n      if (node.l > 0) {\n        travelDirs1.push({ dx: 0, dy: 0, dl: -1 })\n      }\n    }\n\n    const travelDirs2 = travelDirs1\n      .filter((dir) => {\n        // If we have a parent, don't go backwards towards the parent\n        if (\n          dir.dx === forwardDir.dx * -1 &&\n          dir.dy === forwardDir.dy * -1 &&\n          dir.dl === forwardDir.dl * -1\n        ) {\n          return false\n        } else if (\n          dir.dx === forwardDir.dx &&\n          dir.dy === forwardDir.dy &&\n          dir.dl === forwardDir.dl &&\n          node.parent?.obstacleHit\n        ) {\n          return false\n        }\n        return true\n      })\n      .map((dir) => {\n        const collisionInfo = obstacles.getOrthoDirectionCollisionInfo(\n          node,\n          dir,\n          {\n            margin: this.OBSTACLE_MARGIN,\n          },\n        )\n\n        return collisionInfo\n      })\n      // Filter out directions that are too close to the wall\n      .filter((dir) => !(dir.wallDistance < this.OBSTACLE_MARGIN))\n\n    /**\n     * Figure out how far to travel. There are a couple reasons we would stop\n     * traveling:\n     * - A different direction opened up while we were traveling (the obstacle\n     *   our parent hit was overcome)\n     * - We hit a wall\n     * - We passed the goal along the travel direction\n     */\n    const travelDirs3: Array<\n      DirectionWithCollisionInfo3d & {\n        travelDistance: number\n        travelMarginCostFactor: number\n        enterMarginCost: number\n      }\n    > = []\n    for (const travelDir of travelDirs2) {\n      const isDownVia =\n        travelDir.dx === 0 && travelDir.dy === 0 && travelDir.dl === 1\n      const isUpVia =\n        travelDir.dx === 0 && travelDir.dy === 0 && travelDir.dl === -1\n      if (isDownVia || isUpVia) {\n        const hasSpaceForVia = [node.l, node.l + travelDir.dl].every(\n          (l) =>\n            obstacles.getObstaclesOverlappingRegion({\n              minX: node.x - this.VIA_DIAMETER / 2 - this.OBSTACLE_MARGIN,\n              minY: node.y - this.VIA_DIAMETER / 2 - this.OBSTACLE_MARGIN,\n              maxX: node.x + this.VIA_DIAMETER / 2 + this.OBSTACLE_MARGIN,\n              maxY: node.y + this.VIA_DIAMETER / 2 + this.OBSTACLE_MARGIN,\n              l,\n            }).length === 0,\n        )\n        if (!hasSpaceForVia) {\n          continue\n        }\n      }\n      if (isDownVia) {\n        if (node.l < this.layerCount - 1) {\n          travelDirs3.push({\n            ...travelDir,\n            travelDistance: 0,\n            enterMarginCost: 0,\n            travelMarginCostFactor: 1,\n          })\n        }\n        continue\n      }\n      if (isUpVia) {\n        if (node.l > 0) {\n          travelDirs3.push({\n            ...travelDir,\n            travelDistance: 0,\n            enterMarginCost: 0,\n            travelMarginCostFactor: 1,\n          })\n        }\n        continue\n      }\n\n      let overcomeDistance: number | null = null\n      if (node?.obstacleHit) {\n        overcomeDistance = getDistanceToOvercomeObstacle({\n          node,\n          travelDir,\n          wallDir: { ...forwardDir, wallDistance: this.OBSTACLE_MARGIN },\n          obstacle: node.obstacleHit,\n          obstacles,\n          OBSTACLE_MARGIN: this.OBSTACLE_MARGIN,\n          SHOULD_DETECT_CONJOINED_OBSTACLES: true,\n        })\n      }\n\n      const goalDistAlongTravelDir = distAlongDir(node, goalPoint, travelDir)\n      const isGoalInTravelDir =\n        (travelDir.dx === 0 ||\n          Math.sign(goalPoint.x - node.x) === travelDir.dx) &&\n        (travelDir.dy === 0 || Math.sign(goalPoint.y - node.y) === travelDir.dy)\n\n      if (\n        goalDistAlongTravelDir < travelDir.wallDistance &&\n        goalDistAlongTravelDir > 0 &&\n        isGoalInTravelDir\n      ) {\n        const isGoalOnSameLayer = node.l === goalPoint.l\n\n        let stopShortDistance = 0\n        if (\n          !isGoalOnSameLayer &&\n          Math.abs(goalDistAlongTravelDir - goalDistIgnoringLayer) <\n            this.GRID_STEP\n        ) {\n          stopShortDistance =\n            this.VIA_DIAMETER + this.OBSTACLE_MARGIN + this.defaultGoalViaMargin\n        }\n\n        travelDirs3.push({\n          ...travelDir,\n          travelDistance: goalDistAlongTravelDir - stopShortDistance,\n          enterMarginCost: 0,\n          travelMarginCostFactor: 1,\n        })\n      } else if (\n        overcomeDistance !== null &&\n        overcomeDistance < travelDir.wallDistance\n      ) {\n        for (const { margin, enterCost, travelCostFactor } of this\n          .marginsWithCosts) {\n          if (\n            overcomeDistance - this.OBSTACLE_MARGIN + margin * 2 <\n            travelDir.wallDistance\n          ) {\n            travelDirs3.push({\n              ...travelDir,\n              travelDistance: overcomeDistance - this.OBSTACLE_MARGIN + margin,\n              enterMarginCost: enterCost,\n              travelMarginCostFactor: travelCostFactor,\n            })\n          }\n        }\n        if (travelDir.wallDistance === Infinity) {\n          travelDirs3.push({\n            ...travelDir,\n            travelDistance: goalDistAlongTravelDir,\n            enterMarginCost: 0,\n            travelMarginCostFactor: 1,\n          })\n        } else if (travelDir.wallDistance > this.largestMargin) {\n          for (const { margin, enterCost, travelCostFactor } of this\n            .marginsWithCosts) {\n            if (travelDir.wallDistance > this.largestMargin + margin) {\n              travelDirs3.push({\n                ...travelDir,\n                travelDistance: travelDir.wallDistance - margin,\n                enterMarginCost: enterCost,\n                travelMarginCostFactor: travelCostFactor,\n              })\n            }\n          }\n        }\n      } else if (travelDir.wallDistance !== Infinity) {\n        for (const { margin, enterCost, travelCostFactor } of this\n          .marginsWithCosts) {\n          if (travelDir.wallDistance > margin) {\n            travelDirs3.push({\n              ...travelDir,\n              travelDistance: travelDir.wallDistance - margin,\n              enterMarginCost: enterCost,\n              travelMarginCostFactor: travelCostFactor,\n            })\n          }\n        }\n      }\n    }\n\n    return travelDirs3.map((dir) => ({\n      x: node.x + dir.dx * dir.travelDistance,\n      y: node.y + dir.dy * dir.travelDistance,\n      l: node.l + dir.dl,\n      obstacleHit: dir.obstacle,\n      travelMarginCostFactor: dir.travelMarginCostFactor,\n      enterMarginCost: dir.enterMarginCost,\n    }))\n  }\n}\n","import type { AnyCircuitElement as AnySoupElement } from \"circuit-json\"\nimport type { SolutionWithDebugInfo } from \"autorouting-dataset/lib/solver-utils/ProblemSolver\"\nimport { getSimpleRouteJson } from \"autorouting-dataset/lib/solver-utils/getSimpleRouteJson\"\nimport { MultilayerIjump } from \"./MultilayerIjump\"\nimport { getFullConnectivityMapFromCircuitJson } from \"circuit-json-to-connectivity-map\"\n\nexport function autoroute(soup: AnySoupElement[]): SolutionWithDebugInfo {\n  const connMap = getFullConnectivityMapFromCircuitJson(soup)\n  const input = getSimpleRouteJson(soup, {\n    layerCount: 2,\n    connMap,\n  })\n\n  const autorouter = new MultilayerIjump({\n    input,\n    connMap,\n    isRemovePathLoopsEnabled: true,\n    optimizeWithGoalBoxes: true,\n  })\n\n  const solution = autorouter.solveAndMapToTraces()\n\n  return {\n    solution,\n    debugSolutions: autorouter.debugSolutions,\n    debugMessage: autorouter.debugMessage,\n  }\n}\n","import type { AnyCircuitElement as AnySoupElement } from \"circuit-json\"\nimport type { SolutionWithDebugInfo } from \"solver-utils/ProblemSolver\"\nimport { IJumpAutorouter } from \"./lib/IJumpAutorouter\"\nimport {\n  getSimpleRouteJson,\n  markObstaclesAsConnected,\n  isPointInsideObstacle,\n} from \"solver-utils/getSimpleRouteJson\"\nimport { getObstaclesFromCircuitJson } from \"solver-utils/getObstaclesFromCircuitJson\"\nimport { IJumpMultiMarginAutorouter } from \"./lib/IJumpMultiMarginAutorouter\"\n\nexport function autoroute(soup: AnySoupElement[]): SolutionWithDebugInfo {\n  const input = getSimpleRouteJson(soup)\n\n  const autorouter = new IJumpAutorouter({\n    input,\n  })\n\n  const solution = autorouter.solveAndMapToTraces()\n\n  return {\n    solution,\n    debugSolutions: autorouter.debugSolutions,\n    debugMessage: autorouter.debugMessage,\n  }\n}\n\nexport function autorouteMultiMargin(\n  soup: AnySoupElement[],\n): SolutionWithDebugInfo {\n  const input = getSimpleRouteJson(soup)\n\n  const autorouter = new IJumpMultiMarginAutorouter({\n    input,\n    isRemovePathLoopsEnabled: true,\n  })\n\n  const solution = autorouter.solveAndMapToTraces()\n\n  return {\n    solution,\n    debugSolutions: autorouter.debugSolutions,\n    debugMessage: autorouter.debugMessage,\n  }\n}\n\nexport const getObstaclesFromSoup = getObstaclesFromCircuitJson\n\nexport { autoroute as autorouteMultiLayer } from \"../../multi-layer-ijump\"\nexport { MultilayerIjump } from \"../../multi-layer-ijump/MultilayerIjump\"\n\nexport {\n  IJumpAutorouter,\n  IJumpMultiMarginAutorouter,\n  getSimpleRouteJson,\n  markObstaclesAsConnected,\n  isPointInsideObstacle,\n  getObstaclesFromCircuitJson,\n}\n"],"mappings":"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","names":["Debug","current","debug","Debug","current","dist","Debug","debug","PcbConnectivityMap","current","dirFromAToB","PcbConnectivityMap","PcbConnectivityMap","current","dirFromAToB","getFullConnectivityMapFromCircuitJson","autoroute"]}