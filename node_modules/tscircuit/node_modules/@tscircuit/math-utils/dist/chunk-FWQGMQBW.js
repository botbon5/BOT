import {
  distance,
  doSegmentsIntersect,
  pointToSegmentDistance
} from "./chunk-3453HRP7.js";
import {
  clamp
} from "./chunk-MHHTZHOJ.js";

// src/segment-distance.ts
function segmentToSegmentMinDistance(a, b, u, v) {
  if (a.x === b.x && a.y === b.y) {
    return pointToSegmentDistance(a, u, v);
  }
  if (u.x === v.x && u.y === v.y) {
    return pointToSegmentDistance(u, a, b);
  }
  if (doSegmentsIntersect(a, b, u, v)) {
    return 0;
  }
  const distances = [
    pointToSegmentDistance(a, u, v),
    pointToSegmentDistance(b, u, v),
    pointToSegmentDistance(u, a, b),
    pointToSegmentDistance(v, a, b)
  ];
  return Math.min(...distances);
}
function segmentToBoundsMinDistance(a, b, bounds) {
  const topLeft = { x: bounds.minX, y: bounds.minY };
  const topRight = { x: bounds.maxX, y: bounds.minY };
  const bottomLeft = { x: bounds.minX, y: bounds.maxY };
  const bottomRight = { x: bounds.maxX, y: bounds.maxY };
  if (doSegmentsIntersect(a, b, topLeft, topRight) || doSegmentsIntersect(a, b, topRight, bottomRight) || doSegmentsIntersect(a, b, bottomRight, bottomLeft) || doSegmentsIntersect(a, b, bottomLeft, topLeft)) {
    return 0;
  }
  if (a.x >= bounds.minX && a.x <= bounds.maxX && a.y >= bounds.minY && a.y <= bounds.maxY && b.x >= bounds.minX && b.x <= bounds.maxX && b.y >= bounds.minY && b.y <= bounds.maxY) {
    return 0;
  }
  const distances = [
    pointToSegmentDistance(topLeft, a, b),
    pointToSegmentDistance(topRight, a, b),
    pointToSegmentDistance(bottomLeft, a, b),
    pointToSegmentDistance(bottomRight, a, b)
  ];
  if (a.x >= bounds.minX && a.x <= bounds.maxX && a.y >= bounds.minY && a.y <= bounds.maxY) {
    return 0;
  }
  if (b.x >= bounds.minX && b.x <= bounds.maxX && b.y >= bounds.minY && b.y <= bounds.maxY) {
    return 0;
  }
  if (a.x < bounds.minX || a.x > bounds.maxX || a.y < bounds.minY || a.y > bounds.maxY) {
    const closestX = clamp(a.x, bounds.minX, bounds.maxX);
    const closestY = clamp(a.y, bounds.minY, bounds.maxY);
    distances.push(distance(a, { x: closestX, y: closestY }));
  }
  if (b.x < bounds.minX || b.x > bounds.maxX || b.y < bounds.minY || b.y > bounds.maxY) {
    const closestX = clamp(b.x, bounds.minX, bounds.maxX);
    const closestY = clamp(b.y, bounds.minY, bounds.maxY);
    distances.push(distance(b, { x: closestX, y: closestY }));
  }
  return Math.min(...distances);
}
function segmentToBoxMinDistance(a, b, box) {
  const halfWidth = box.width / 2;
  const halfHeight = box.height / 2;
  const bounds = {
    minX: box.center.x - halfWidth,
    maxX: box.center.x + halfWidth,
    minY: box.center.y - halfHeight,
    maxY: box.center.y + halfHeight
  };
  return segmentToBoundsMinDistance(a, b, bounds);
}
function segmentToCircleMinDistance(a, b, circle) {
  const circleCenter = { x: circle.x, y: circle.y };
  if (a.x === b.x && a.y === b.y) {
    return Math.max(0, distance(a, circleCenter) - circle.radius);
  }
  const ab = { x: b.x - a.x, y: b.y - a.y };
  const ac = { x: circleCenter.x - a.x, y: circleCenter.y - a.y };
  const abLengthSq = ab.x * ab.x + ab.y * ab.y;
  const t = Math.max(0, Math.min(1, (ab.x * ac.x + ab.y * ac.y) / abLengthSq));
  const closestPoint = {
    x: a.x + t * ab.x,
    y: a.y + t * ab.y
  };
  const distToCenter = distance(closestPoint, circleCenter);
  return Math.max(0, distToCenter - circle.radius);
}
function pointToSegmentClosestPoint(p, a, b) {
  const dx_ab = b.x - a.x;
  const dy_ab = b.y - a.y;
  const l2 = dx_ab * dx_ab + dy_ab * dy_ab;
  if (l2 === 0) return { x: a.x, y: a.y };
  let t = ((p.x - a.x) * dx_ab + (p.y - a.y) * dy_ab) / l2;
  t = Math.max(0, Math.min(1, t));
  const closestPoint = {
    x: a.x + t * dx_ab,
    y: a.y + t * dy_ab
  };
  return closestPoint;
}

export {
  segmentToSegmentMinDistance,
  segmentToBoundsMinDistance,
  segmentToBoxMinDistance,
  segmentToCircleMinDistance,
  pointToSegmentClosestPoint
};
//# sourceMappingURL=chunk-FWQGMQBW.js.map