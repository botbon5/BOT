var __defProp = Object.defineProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};

// src/fn/index.ts
var fn_exports = {};
__export(fn_exports, {
  axial: () => axial,
  bga: () => bga,
  breakoutheaders: () => breakoutheaders,
  cap: () => cap,
  dfn: () => dfn,
  diode: () => diode,
  dip: () => dip,
  electrolytic: () => electrolytic,
  hc49: () => hc49,
  jst: () => jst,
  led: () => led,
  lqfp: () => lqfp,
  m2host: () => m2host,
  melf: () => melf,
  micromelf: () => micromelf,
  minimelf: () => minimelf,
  mlp: () => mlp,
  ms012: () => ms012,
  ms013: () => ms013,
  msop: () => msop,
  pad: () => pad,
  pinrow: () => pinrow,
  platedhole: () => platedhole3,
  potentiometer: () => potentiometer,
  pushbutton: () => pushbutton,
  qfn: () => qfn,
  qfp: () => qfp,
  quad: () => quad,
  res: () => res,
  sma: () => sma,
  smb: () => smb,
  smbf: () => smbf,
  smc: () => smc,
  smf: () => smf,
  smtpad: () => smtpad,
  sod110: () => sod110,
  sod123: () => sod123,
  sod123f: () => sod123f,
  sod123fl: () => sod123fl,
  sod123w: () => sod123w,
  sod128: () => sod128,
  sod323: () => sod323,
  sod323f: () => sod323f,
  sod323fl: () => sod323fl,
  sod323w: () => sod323w,
  sod523: () => sod523,
  sod723: () => sod723,
  sod80: () => sod80,
  sod882: () => sod882,
  sod882d: () => sod882d,
  sod923: () => sod923,
  soic: () => soic,
  solderjumper: () => solderjumper,
  son: () => son,
  sop8: () => sop8,
  sot: () => sot,
  sot223: () => sot223,
  sot23: () => sot23,
  sot23w: () => sot23w,
  sot25: () => sot25,
  sot323: () => sot323,
  sot363: () => sot363,
  sot457: () => sot457,
  sot563: () => sot563,
  sot723: () => sot723,
  sot89: () => sot89,
  ssop: () => ssop,
  stampboard: () => stampboard,
  stampreceiver: () => stampreceiver,
  to220: () => to220,
  to92: () => to92,
  to92s: () => to92s,
  tssop: () => tssop,
  vssop: () => vssop
});

// src/helpers/silkscreenRef.ts
var silkscreenRef = (x, y, font_size) => {
  return {
    type: "pcb_silkscreen_text",
    pcb_silkscreen_text_id: "silkscreen_text_1",
    font: "tscircuit2024",
    font_size,
    pcb_component_id: "pcb_component_1",
    text: "{REF}",
    layer: "top",
    anchor_position: { x, y },
    anchor_alignment: "center"
  };
};

// src/fn/dip.ts
import { z } from "zod";

// src/helpers/platedhole.ts
import { mm } from "@tscircuit/mm";
var platedhole = (pn, x, y, id, od) => {
  return {
    pcb_plated_hole_id: "",
    type: "pcb_plated_hole",
    shape: "circle",
    x,
    y,
    hole_diameter: mm(id),
    outer_diameter: mm(od),
    pcb_port_id: "",
    layers: ["top", "bottom"],
    port_hints: [pn.toString()]
  };
};

// src/helpers/u-curve.ts
var u_curve = Array.from(
  { length: 9 },
  (_, i) => Math.cos(i / 8 * Math.PI - Math.PI)
).map((x) => ({
  x,
  y: -Math.sqrt(1 - x ** 2)
}));

// src/fn/dip.ts
function convertMilToMm(value) {
  if (typeof value === "string") {
    if (value.trim().toLowerCase().endsWith("mil")) {
      const num = Number.parseFloat(value);
      return num * 0.0254;
    }
    return Number.parseFloat(value);
  }
  return Number(value);
}
var lengthInMm = z.union([z.string(), z.number()]).transform((val) => convertMilToMm(val));
var extendDipDef = (newDefaults) => z.object({
  fn: z.string(),
  num_pins: z.number().optional().default(6),
  wide: z.boolean().optional(),
  narrow: z.boolean().optional(),
  w: lengthInMm.optional(),
  p: lengthInMm.default(newDefaults.p ?? "2.54mm"),
  id: lengthInMm.optional(),
  od: lengthInMm.optional()
}).transform((v) => {
  if (!v.id && !v.od) {
    if (Math.abs(v.p - 1.27) < 0.01) {
      v.id = convertMilToMm("0.55mm");
      v.od = convertMilToMm("0.95mm");
    } else {
      v.id = convertMilToMm("1.0mm");
      v.od = convertMilToMm("1.5mm");
    }
  } else if (!v.id) {
    v.id = v.od * (1 / 1.5);
  } else if (!v.od) {
    v.od = v.id * (1.5 / 1);
  }
  if (!v.w) {
    if (v.wide) {
      v.w = convertMilToMm("600mil");
    } else if (v.narrow) {
      v.w = convertMilToMm("300mil");
    } else {
      v.w = convertMilToMm(newDefaults.w ?? "300mil");
    }
  }
  return v;
});
var dip_def = extendDipDef({});
var getCcwDipCoords = (pinCount, pn, w, p) => {
  const ph = pinCount / 2;
  const isLeft = pn <= ph;
  const leftPinGaps = ph - 1;
  const gs = p;
  const h = gs * leftPinGaps;
  if (isLeft) {
    return { x: -w / 2 - 0.4, y: h / 2 - (pn - 1) * gs };
  }
  return { x: w / 2 + 0.4, y: -h / 2 + (pn - ph - 1) * gs };
};
var dip = (raw_params) => {
  const parameters = dip_def.parse(raw_params);
  const platedHoles = [];
  for (let i = 0; i < parameters.num_pins; i++) {
    const { x, y } = getCcwDipCoords(
      parameters.num_pins,
      i + 1,
      parameters.w,
      parameters.p ?? 2.54
    );
    platedHoles.push(
      platedhole(i + 1, x, y, parameters.id ?? "0.8mm", parameters.od ?? "1mm")
    );
  }
  const sw = parameters.w - parameters.od - 0.4;
  const sh = (parameters.num_pins / 2 - 1) * parameters.p + parameters.od + 0.4;
  const silkscreenBorder = {
    layer: "top",
    pcb_component_id: "",
    pcb_silkscreen_path_id: "silkscreen_path_1",
    route: [
      { x: -sw / 2, y: -sh / 2 },
      { x: -sw / 2, y: sh / 2 },
      // Little U shape at the top
      ...u_curve.map(({ x, y }) => ({
        x: x * sw / 6,
        y: y * sw / 6 + sh / 2
      })),
      { x: sw / 2, y: sh / 2 },
      { x: sw / 2, y: -sh / 2 },
      { x: -sw / 2, y: -sh / 2 }
    ],
    type: "pcb_silkscreen_path",
    stroke_width: 0.1
  };
  const silkscreenPins = [];
  for (let i = 0; i < parameters.num_pins; i++) {
    const isLeft = i < parameters.num_pins / 2;
    const pinLabelX = isLeft ? -parameters.w / 2 - parameters.p / 2 - 0.2 : parameters.p / 2 + parameters.w / 2 + 0.2;
    const pinLabelY = isLeft ? (-sh + 1.6) / 2 + i * parameters.p : (-sh + 1.6) / 2 + (i - parameters.num_pins / 2) * parameters.p;
    const silkscreenPin2 = {
      type: "pcb_fabrication_note_text",
      layer: "top",
      pcb_component_id: `pin_${i + 1}`,
      pcb_silkscreen_text_id: `pin_${i + 1}`,
      text: `{pin${i + 1}}`,
      anchor_position: {
        x: pinLabelX,
        y: pinLabelY
      },
      font_size: 0.3,
      font_color: "red",
      font: "tscircuit2024",
      anchor_alignment: "top-left"
    };
    silkscreenPins.push(silkscreenPin2);
  }
  const silkscreenRefText = silkscreenRef(0, sh / 2 + 0.5, 0.4);
  return {
    circuitJson: [
      ...platedHoles,
      silkscreenBorder,
      silkscreenRefText,
      ...silkscreenPins
    ],
    parameters
  };
};

// src/helpers/rectpad.ts
var rectpad = (pn, x, y, w, h) => {
  return {
    type: "pcb_smtpad",
    x,
    y,
    width: w,
    height: h,
    layer: "top",
    shape: "rect",
    pcb_smtpad_id: "",
    port_hints: Array.isArray(pn) ? pn.map((item) => item.toString()) : [pn.toString()]
  };
};

// src/helpers/passive-fn.ts
import mm2 from "@tscircuit/mm";
import { z as z2 } from "zod";
import { length, distance } from "circuit-json";
var footprintSizes = [
  {
    imperial: "01005",
    metric: "0402",
    p_mm_min: 0.5,
    pw_mm_min: 0.4,
    ph_mm_min: 0.3,
    w_mm_min: 0.58,
    h_mm_min: 0.21
  },
  {
    imperial: "0504",
    metric: "1310",
    p_mm_min: 1.1,
    pw_mm_min: 0.65,
    ph_mm_min: 1.3,
    w_mm_min: 0.58,
    h_mm_min: 0.21
  },
  {
    imperial: "1812",
    metric: "4532",
    p_mm_min: 4.1,
    pw_mm_min: 1.4,
    ph_mm_min: 3.4,
    w_mm_min: 0.58,
    h_mm_min: 0.21
  },
  {
    imperial: "0201",
    metric: "0603",
    p_mm_min: 0.66,
    pw_mm_min: 0.46,
    ph_mm_min: 0.4,
    w_mm_min: 0.9,
    h_mm_min: 0.3
  },
  {
    imperial: "0402",
    metric: "1005",
    p_mm_min: 1,
    pw_mm_min: 0.6,
    ph_mm_min: 0.6,
    w_mm_min: 1.6,
    h_mm_min: 0.7
  },
  {
    imperial: "0603",
    metric: "1608",
    p_mm_min: 1.7,
    pw_mm_min: 1.1,
    ph_mm_min: 1,
    w_mm_min: 2.6,
    h_mm_min: 1
  },
  {
    imperial: "0805",
    metric: "2012",
    p_mm_min: 2.15,
    pw_mm_min: 0.85,
    ph_mm_min: 1.2,
    w_mm_min: 3,
    h_mm_min: 1.2
  },
  {
    imperial: "1206",
    metric: "3216",
    p_mm_min: 3.2,
    pw_mm_min: 1,
    ph_mm_min: 1.9,
    w_mm_min: 4.2,
    h_mm_min: 2.5
  },
  {
    imperial: "1210",
    metric: "3225",
    p_mm_min: 2.8,
    pw_mm_min: 1.25,
    ph_mm_min: 2.65,
    w_mm_min: 4.5,
    h_mm_min: 3.3
  },
  {
    imperial: "2010",
    metric: "5025",
    p_mm_min: 3.6,
    pw_mm_min: 1.2,
    ph_mm_min: 1.2,
    w_mm_min: 5,
    h_mm_min: 2.5
  },
  {
    imperial: "2512",
    metric: "6332",
    p_mm_min: 5.8,
    pw_mm_min: 1.35,
    ph_mm_min: 3.35,
    w_mm_min: 6.3,
    h_mm_min: 3.2
  }
];
var metricMap = Object.fromEntries(footprintSizes.map((s) => [s.metric, s]));
var imperialMap = Object.fromEntries(
  footprintSizes.map((s) => [s.imperial, s])
);
var passive_def = z2.object({
  tht: z2.boolean(),
  p: length.optional(),
  pw: length.optional(),
  ph: length.optional(),
  metric: distance.optional(),
  imperial: distance.optional(),
  w: length.optional(),
  h: length.optional(),
  textbottom: z2.boolean().optional()
});
var passive = (params) => {
  let { tht, p, pw, ph, metric, imperial, w, h, textbottom } = params;
  if (typeof w === "string") w = mm2(w);
  if (typeof h === "string") h = mm2(h);
  if (typeof p === "string") p = mm2(p);
  if (typeof pw === "string") pw = mm2(pw);
  if (typeof ph === "string") ph = mm2(ph);
  if (h !== void 0 && w !== void 0 && h > w) {
    throw new Error(
      "height cannot be greater than width (rotated footprint not yet implemented)"
    );
  }
  let sz;
  if (metric) sz = metricMap[metric];
  if (imperial) sz = imperialMap[imperial];
  if (sz) {
    w = sz.w_mm_min;
    h = sz.h_mm_min;
    p = sz.p_mm_min;
    pw = sz.pw_mm_min;
    ph = sz.ph_mm_min;
  }
  if (p === void 0 || pw === void 0 || ph === void 0) {
    throw new Error("Could not determine required pad dimensions (p, pw, ph)");
  }
  const silkscreenLine = {
    type: "pcb_silkscreen_path",
    layer: "top",
    pcb_component_id: "",
    route: [
      { x: p / 2, y: ph / 2 + 0.4 },
      { x: -p / 2 - pw / 2 - 0.2, y: ph / 2 + 0.4 },
      { x: -p / 2 - pw / 2 - 0.2, y: -ph / 2 - 0.4 },
      { x: p / 2, y: -ph / 2 - 0.4 }
    ],
    stroke_width: 0.1,
    pcb_silkscreen_path_id: ""
  };
  const textY = textbottom ? -ph / 2 - 0.9 : ph / 2 + 0.9;
  const silkscreenRefText = silkscreenRef(0, textY, 0.2);
  if (tht) {
    return [
      platedhole(1, -p / 2, 0, pw, pw * 1 / 0.8),
      platedhole(2, p / 2, 0, pw, pw * 1 / 0.8),
      silkscreenLine,
      silkscreenRefText
    ];
  } else {
    return [
      rectpad(["1", "left"], -p / 2, 0, pw, ph),
      rectpad(["2", "right"], p / 2, 0, pw, ph),
      silkscreenLine,
      silkscreenRefText
    ];
  }
};

// src/fn/diode.ts
var diode = (parameters) => {
  return { circuitJson: passive(parameters), parameters };
};

// src/fn/cap.ts
var cap = (parameters) => {
  return { circuitJson: passive(parameters), parameters };
};

// src/fn/led.ts
var led = (parameters) => {
  return { circuitJson: passive(parameters), parameters };
};

// src/fn/res.ts
var res = (parameters) => {
  return { circuitJson: passive(parameters), parameters };
};

// src/helpers/circlepad.ts
var circlepad = (pn, { x, y, radius }) => {
  return {
    type: "pcb_smtpad",
    x,
    y,
    radius,
    layer: "top",
    shape: "circle",
    pcb_smtpad_id: "",
    port_hints: Array.isArray(pn) ? pn.map((item) => item.toString()) : [pn.toString()]
  };
};

// src/helpers/zod/ALPHABET.ts
var ALPHABET = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";

// src/fn/bga.ts
import { z as z5 } from "zod";
import { length as length2, distance as distance2 } from "circuit-json";

// src/helpers/zod/dim-2d.ts
import { z as z3 } from "zod";
var dim2d = z3.string().transform((a) => {
  const [x, y] = a.split(/[x ]/);
  return {
    x: parseFloat(x),
    y: parseFloat(y)
  };
}).pipe(
  z3.object({
    x: z3.number(),
    y: z3.number()
  })
);

// src/helpers/zod/function-call.ts
import { z as z4 } from "zod";
var function_call = z4.string().or(z4.array(z4.any())).transform((a) => {
  if (Array.isArray(a)) return a;
  if (a.startsWith("(") && a.endsWith(")")) {
    a = a.slice(1, -1);
  }
  return a.split(",").map((v) => {
    const numVal = Number(v);
    return isNaN(numVal) ? v : numVal;
  });
}).pipe(z4.array(z4.string().or(z4.number())));

// src/fn/bga.ts
import "circuit-json";
var bga_def = z5.object({
  fn: z5.string(),
  num_pins: z5.number().optional().default(64),
  grid: dim2d.optional(),
  p: distance2.default("0.8mm"),
  w: length2.optional(),
  h: length2.optional(),
  ball: length2.optional().describe("ball diameter"),
  pad: length2.optional().describe("pad width/height"),
  circularpads: z5.boolean().optional().describe("use circular pads"),
  tlorigin: z5.boolean().optional(),
  blorigin: z5.boolean().optional(),
  trorigin: z5.boolean().optional(),
  brorigin: z5.boolean().optional(),
  missing: function_call.default([])
}).transform((a) => {
  let origin = "tl";
  if (a.blorigin) origin = "bl";
  if (a.trorigin) origin = "tr";
  if (a.brorigin) origin = "br";
  if (!a.grid) {
    const largest_square = Math.ceil(Math.sqrt(a.num_pins));
    a.grid = { x: largest_square, y: largest_square };
  }
  if (a.missing) {
    a.missing = a.missing.map((s) => {
      if (typeof s === "number") return s;
      if (s === "center") return "center";
      if (s === "topleft") return "topleft";
      const m = s.match(/([A-Z]+)(\d+)/);
      if (!m) return s;
      const Y = ALPHABET.indexOf(m[1]);
      const X = Number.parseInt(m[2]) - 1;
      return Y * a.grid.x + X + 1;
    });
  }
  const new_def = { ...a, origin };
  return new_def;
});
var bga = (raw_params) => {
  const parameters = bga_def.parse(raw_params);
  let { num_pins, grid, p, w, h, ball, pad: pad2, missing } = parameters;
  ball ??= 0.75 / 1.27 * p;
  pad2 ??= ball * 0.8;
  const pads = [];
  const missing_pin_nums = (missing ?? []).filter((a) => typeof a === "number");
  const num_pins_missing = grid.x * grid.y - num_pins;
  if (missing.length === 0 && num_pins_missing > 0) {
    if (Math.sqrt(num_pins_missing) % 1 === 0) {
      missing.push("center");
    } else if (num_pins_missing === 1) {
      missing.push("topleft");
    }
  }
  if (missing?.includes("center")) {
    const square_size = Math.floor(Math.sqrt(num_pins_missing));
    const inner_square_x = Math.floor((grid.x - square_size) / 2);
    const inner_square_y = Math.floor((grid.y - square_size) / 2);
    for (let y = inner_square_y; y < inner_square_y + square_size; y++) {
      for (let x = inner_square_x; x < inner_square_x + square_size; x++) {
        missing_pin_nums.push(y * grid.x + x + 1);
      }
    }
  }
  if (missing?.includes("topleft")) {
    missing_pin_nums.push(1);
  }
  const missing_pin_nums_set = new Set(missing_pin_nums);
  let missing_pins_passed = 0;
  for (let y = 0; y < grid.y; y++) {
    for (let x = 0; x < grid.x; x++) {
      const pad_x = (x - (grid.x - 1) / 2) * p;
      const pad_y = (y - (grid.y - 1) / 2) * p;
      let pin_x = x;
      let pin_y = y;
      switch (parameters.origin) {
        case "bl":
          pin_x = x;
          pin_y = grid.y - 1 - y;
          break;
        case "br":
          pin_x = grid.x - 1 - x;
          pin_y = grid.y - 1 - y;
          break;
        case "tr":
          pin_x = grid.x - 1 - x;
          pin_y = y;
          break;
        case "tl":
        default:
          break;
      }
      let pin_num = pin_y * grid.x + pin_x + 1;
      if (missing_pin_nums_set.has(pin_num)) {
        missing_pins_passed++;
        continue;
      }
      pin_num -= missing_pins_passed;
      const portHints = [pin_num, `${ALPHABET[pin_y]}${pin_x + 1}`];
      pads.push(
        parameters.circularpads ? circlepad(portHints, {
          x: pad_x,
          y: pad_y,
          radius: pad2 / 2
        }) : rectpad(portHints, pad_x, pad_y, pad2, pad2)
      );
    }
  }
  const silkscreenRefText = silkscreenRef(
    0,
    grid.y * p / 2,
    0.2
  );
  const pin1MarkerSize = p / 6;
  let markerRoute;
  const edgeX = grid.x * p / 2;
  const edgeY = grid.y * p / 2;
  switch (parameters.origin) {
    case "bl":
      markerRoute = [
        { x: -edgeX, y: -edgeY },
        // Start at corner
        { x: -edgeX, y: -edgeY - pin1MarkerSize },
        // Up
        { x: -edgeX - pin1MarkerSize, y: -edgeY },
        // Left
        { x: -edgeX, y: -edgeY }
        // Back to start
      ];
      break;
    case "br":
      markerRoute = [
        { x: edgeX, y: -edgeY },
        // Start at corner
        { x: edgeX, y: -edgeY - pin1MarkerSize },
        // Up
        { x: edgeX + pin1MarkerSize, y: -edgeY },
        // Right
        { x: edgeX, y: -edgeY }
        // Back to start
      ];
      break;
    case "tr":
      markerRoute = [
        { x: edgeX, y: edgeY },
        // Start at corner
        { x: edgeX, y: edgeY + pin1MarkerSize },
        // Down
        { x: edgeX + pin1MarkerSize, y: edgeY },
        // Right
        { x: edgeX, y: edgeY }
        // Back to start
      ];
      break;
    case "tl":
    default:
      markerRoute = [
        { x: -edgeX, y: edgeY },
        // Start at corner
        { x: -edgeX, y: edgeY + pin1MarkerSize },
        // Down
        { x: -edgeX - pin1MarkerSize, y: edgeY },
        // Left
        { x: -edgeX, y: edgeY }
        // Back to start
      ];
      break;
  }
  const pin1Marker = {
    type: "pcb_silkscreen_path",
    layer: "top",
    pcb_component_id: "",
    pcb_silkscreen_path_id: "pin1_marker",
    route: markerRoute,
    stroke_width: 0.05
  };
  return {
    circuitJson: [...pads, silkscreenRefText, pin1Marker],
    parameters
  };
};

// src/fn/soic.ts
import { z as z6 } from "zod";
import { length as length3 } from "circuit-json";
var extendSoicDef = (newDefaults) => z6.object({
  fn: z6.string(),
  num_pins: z6.number().optional().default(8),
  w: length3.default(length3.parse(newDefaults.w ?? "5.3mm")),
  p: length3.default(length3.parse(newDefaults.p ?? "1.27mm")),
  pw: length3.default(length3.parse(newDefaults.pw ?? "0.6mm")),
  pl: length3.default(length3.parse(newDefaults.pl ?? "1.0mm")),
  legsoutside: z6.boolean().optional().default(newDefaults.legsoutside ?? false)
}).transform((v) => {
  if (!v.pw && !v.pl) {
    v.pw = length3.parse("0.6mm");
    v.pl = length3.parse("1.0mm");
  } else if (!v.pw) {
    v.pw = v.pl * (0.6 / 1);
  } else if (!v.pl) {
    v.pl = v.pw * (1 / 0.6);
  }
  return v;
});
var soic_def = extendSoicDef({});
var getCcwSoicCoords = (parameters) => {
  if (parameters.widthincludeslegs !== void 0) {
    parameters.legsoutside = !parameters.widthincludeslegs;
  }
  const { num_pins, pn, w, p, pl, legsoutside } = parameters;
  const ph = num_pins / 2;
  const isLeft = pn <= ph;
  const leftPinGaps = ph - 1;
  const gs = p;
  const h = gs * leftPinGaps;
  const legoffset = legsoutside ? pl / 2 : -pl / 2;
  if (isLeft) {
    return { x: -w / 2 - legoffset, y: h / 2 - (pn - 1) * gs };
  }
  return { x: w / 2 + legoffset, y: -h / 2 + (pn - ph - 1) * gs };
};
var soic = (raw_params) => {
  const parameters = soic_def.parse(raw_params);
  return {
    circuitJson: soicWithoutParsing(parameters),
    parameters
  };
};
var soicWithoutParsing = (parameters) => {
  const pads = [];
  for (let i = 0; i < parameters.num_pins; i++) {
    const { x, y } = getCcwSoicCoords({
      num_pins: parameters.num_pins,
      pn: i + 1,
      w: parameters.w,
      p: parameters.p,
      pl: parameters.pl,
      legsoutside: parameters.legsoutside
    });
    pads.push(rectpad(i + 1, x, y, parameters.pl, parameters.pw));
  }
  const m = Math.min(1, parameters.p / 2);
  const sw = parameters.w - (parameters.legsoutside ? 0 : parameters.pl * 2) - 0.2;
  const sh = (parameters.num_pins / 2 - 1) * parameters.p + parameters.pw + m;
  const silkscreenRefText = silkscreenRef(
    0,
    sh / 2 + 0.4,
    sh / 12
  );
  const silkscreenBorder = {
    type: "pcb_silkscreen_path",
    layer: "top",
    pcb_component_id: "",
    pcb_silkscreen_path_id: "silkscreen_path_1",
    stroke_width: 0.1,
    route: [
      { x: -sw / 2, y: -sh / 2 },
      { x: -sw / 2, y: sh / 2 },
      // Little U shape at the top
      ...u_curve.map(({ x, y }) => ({
        x: x * sw / 6,
        y: y * sw / 6 + sh / 2
      })),
      { x: sw / 2, y: sh / 2 },
      { x: sw / 2, y: -sh / 2 },
      { x: -sw / 2, y: -sh / 2 }
    ]
  };
  return [...pads, silkscreenBorder, silkscreenRefText];
};

// src/fn/quad.ts
import { z as z8 } from "zod";
import { length as length4 } from "circuit-json";

// src/helpers/zod/pin-order-specifier.ts
import { z as z7 } from "zod";
var pin_order_specifier = z7.enum([
  "leftside",
  "topside",
  "rightside",
  "bottomside",
  "toppin",
  "bottompin",
  "leftpin",
  "rightpin"
]);

// src/helpers/get-quad-pin-map.ts
var getQuadPinMap = ({
  num_pins,
  cw,
  ccw,
  startingpin
}) => {
  const pin_map = [];
  const pins_per_side = num_pins / 4;
  let current_position_ccw_normal = 1;
  const sfp = {};
  for (const specifier of startingpin ?? []) {
    sfp[specifier] = true;
  }
  if (!sfp.leftside && !sfp.topside && !sfp.rightside && !sfp.bottomside) {
    sfp.leftside = true;
  }
  if (!sfp.bottompin && !sfp.leftpin && !sfp.rightpin && !sfp.toppin) {
    if (sfp.leftside) {
      sfp.toppin = true;
    } else if (sfp.topside) {
      sfp.rightpin = true;
    } else if (sfp.rightside) {
      sfp.bottompin = true;
    } else if (sfp.bottomside) {
      sfp.leftpin = true;
    }
  }
  if (sfp.leftside && sfp.toppin) {
    current_position_ccw_normal = 1;
  } else if (sfp.leftside && sfp.bottompin) {
    current_position_ccw_normal = pins_per_side;
  } else if (sfp.bottomside && sfp.leftpin) {
    current_position_ccw_normal = pins_per_side + 1;
  } else if (sfp.bottomside && sfp.rightpin) {
    current_position_ccw_normal = pins_per_side * 2;
  } else if (sfp.rightside && sfp.bottompin) {
    current_position_ccw_normal = pins_per_side * 2 + 1;
  } else if (sfp.rightside && sfp.toppin) {
    current_position_ccw_normal = pins_per_side * 3;
  } else if (sfp.topside && sfp.rightpin) {
    current_position_ccw_normal = pins_per_side * 3 + 1;
  } else if (sfp.topside && sfp.leftpin) {
    current_position_ccw_normal = pins_per_side * 4;
  }
  pin_map.push(-1);
  for (let i = 0; i < num_pins; i++) {
    pin_map[current_position_ccw_normal] = i + 1;
    if (ccw || !cw) {
      current_position_ccw_normal++;
      if (current_position_ccw_normal > num_pins) {
        current_position_ccw_normal = 1;
      }
    } else {
      current_position_ccw_normal--;
      if (current_position_ccw_normal < 1) {
        current_position_ccw_normal = num_pins;
      }
    }
  }
  return pin_map;
};

// src/fn/quad.ts
var base_quad_def = z8.object({
  fn: z8.string(),
  cc: z8.boolean().default(true).optional(),
  ccw: z8.boolean().default(true).optional(),
  startingpin: z8.string().or(z8.array(pin_order_specifier)).transform((a) => typeof a === "string" ? a.slice(1, -1).split(",") : a).pipe(z8.array(pin_order_specifier)).optional(),
  num_pins: z8.number().optional().default(64),
  w: length4.optional(),
  h: length4.optional(),
  p: length4.default(length4.parse("0.5mm")),
  pw: length4.optional(),
  pl: length4.optional(),
  thermalpad: z8.union([z8.literal(true), dim2d]).optional(),
  legsoutside: z8.boolean().default(false)
});
var quadTransform = (v) => {
  if (v.w && !v.h) {
    v.h = v.w;
  } else if (!v.w && v.h) {
    v.w = v.h;
  }
  const side_pin_count = v.num_pins / 4;
  if (!v.p && !v.pw && !v.pl && v.w) {
    const approx_pin_size_of_side = side_pin_count + 4;
    v.p = v.w / approx_pin_size_of_side;
  }
  if (!v.p && v.w && v.h && v.pw && v.pl) {
    v.p = (v.w - v.pl * 2) / (side_pin_count - 1);
  }
  if (!v.w && !v.h && v.p) {
    v.w = v.p * (side_pin_count + 4);
    v.h = v.w;
  }
  if (v.p && !v.pw && !v.pl) {
    v.pw = v.p / 2;
    v.pl = v.p / 2;
  } else if (!v.pw) {
    v.pw = v.pl * (0.6 / 1);
  } else if (!v.pl) {
    v.pl = v.pw * (1 / 0.6);
  }
  return v;
};
var quad_def = base_quad_def.transform(quadTransform);
var SIDES_CCW = ["left", "bottom", "right", "top"];
var getQuadCoords = (params) => {
  const { pin_count, pn, w, h, p, pl, legsoutside } = params;
  const sidePinCount = pin_count / 4;
  const side = SIDES_CCW[Math.floor((pn - 1) / sidePinCount)];
  const pos = (pn - 1) % sidePinCount;
  const ibw = p * (sidePinCount - 1);
  const ibh = p * (sidePinCount - 1);
  const pcdfe = legsoutside ? pl / 2 : -pl / 2;
  switch (side) {
    case "left":
      return { x: -w / 2 - pcdfe, y: ibh / 2 - pos * p, o: "vert" };
    case "bottom":
      return { x: -ibw / 2 + pos * p, y: -h / 2 - pcdfe, o: "horz" };
    case "right":
      return { x: w / 2 + pcdfe, y: -ibh / 2 + pos * p, o: "vert" };
    case "top":
      return { x: ibw / 2 - pos * p, y: h / 2 + pcdfe, o: "horz" };
    default:
      throw new Error("Invalid pin number");
  }
};
var quad = (raw_params) => {
  const parameters = quad_def.parse(raw_params);
  const pads = [];
  const pin_map = getQuadPinMap(parameters);
  const spc = parameters.num_pins / 4;
  for (let i = 0; i < parameters.num_pins; i++) {
    const {
      x,
      y,
      o: orientation
    } = getQuadCoords({
      pin_count: parameters.num_pins,
      pn: i + 1,
      w: parameters.w,
      h: parameters.h,
      p: parameters.p ?? 0.5,
      pl: parameters.pl,
      legsoutside: parameters.legsoutside
    });
    let pw = parameters.pw;
    let pl = parameters.pl;
    if (orientation === "vert") {
      ;
      [pw, pl] = [pl, pw];
    }
    const pn = pin_map[i + 1];
    pads.push(rectpad(pn, x, y, pw, pl));
  }
  if (parameters.thermalpad) {
    if (typeof parameters.thermalpad === "boolean") {
      const ibw = parameters.p * (spc - 1) + parameters.pw;
      const ibh = parameters.p * (spc - 1) + parameters.pw;
      pads.push(rectpad(["thermalpad"], 0, 0, ibw, ibh));
    } else {
      pads.push(
        rectpad(
          ["thermalpad"],
          0,
          0,
          parameters.thermalpad.x,
          parameters.thermalpad.y
        )
      );
    }
  }
  const silkscreen_corners = [];
  for (const [corner, dx, dy] of [
    ["top-left", -1, 1],
    ["bottom-left", -1, -1],
    ["bottom-right", 1, -1],
    ["top-right", 1, 1]
  ]) {
    const corner_x = parameters.w / 2 * dx;
    const corner_y = parameters.h / 2 * dy;
    let arrow = "none";
    let arrow_x = corner_x;
    let arrow_y = corner_y;
    const csz = parameters.pw * 2;
    if (pin_map[1] === 1 && corner === "top-left") {
      arrow = "in1";
    } else if (pin_map[spc * 4] === 1 && corner === "top-left") {
      arrow = "in2";
    } else if (pin_map[spc * 3 + 1] === 1 && corner === "top-right") {
      arrow = "in2";
    } else if (pin_map[spc * 3] === 1 && corner === "top-right") {
      arrow = "in1";
    } else if (pin_map[spc] === 1 && corner === "bottom-left") {
      arrow = "in1";
    } else if (pin_map[spc + 1] === 1 && corner === "bottom-left") {
      arrow = "in2";
    } else if (pin_map[spc * 2] === 1 && corner === "bottom-right") {
      arrow = "in1";
    } else if (pin_map[spc * 2 + 1] === 1 && corner === "bottom-right") {
      arrow = "in2";
    }
    const rotate_arrow = arrow === "in1" ? 1 : -1;
    if (parameters.legsoutside) {
      const arrow_dx = arrow === "in1" ? parameters.pl / 2 : parameters.pw / 2;
      const arrow_dy = arrow === "in1" ? parameters.pw / 2 : parameters.pl / 2;
      arrow_x += arrow_dx * dx * rotate_arrow;
      arrow_y -= arrow_dy * dy * rotate_arrow;
    }
    if (arrow === "none" || parameters.legsoutside) {
      silkscreen_corners.push({
        layer: "top",
        pcb_component_id: "",
        pcb_silkscreen_path_id: `pcb_silkscreen_path_${corner}`,
        route: [
          {
            x: corner_x - csz * dx,
            y: corner_y
          },
          {
            x: corner_x,
            y: corner_y
          },
          {
            x: corner_x,
            y: corner_y - csz * dy
          }
        ],
        type: "pcb_silkscreen_path",
        stroke_width: 0.1
      });
    }
    if ((arrow === "in1" || arrow === "in2") && !parameters.legsoutside) {
      silkscreen_corners.push(
        {
          layer: "top",
          pcb_component_id: "",
          pcb_silkscreen_path_id: `pcb_silkscreen_path_${corner}_1`,
          route: [
            {
              x: corner_x - csz * dx,
              y: corner_y
            },
            {
              x: corner_x - csz * dx / 2,
              y: corner_y
            }
          ],
          type: "pcb_silkscreen_path",
          stroke_width: 0
        },
        {
          layer: "top",
          pcb_component_id: "",
          pcb_silkscreen_path_id: `pcb_silkscreen_path_${corner}_2`,
          route: [
            {
              x: corner_x,
              y: corner_y - csz * dy / 2
            },
            {
              x: corner_x,
              y: corner_y - csz * dy
            }
          ],
          type: "pcb_silkscreen_path",
          stroke_width: 0.1
        }
      );
    }
    if (arrow === "in1" || arrow === "in2") {
      silkscreen_corners.push({
        layer: "top",
        pcb_component_id: "",
        pcb_silkscreen_path_id: `pcb_silkscreen_path_${corner}_3`,
        route: [
          {
            x: arrow_x - 0.2 * -dx,
            y: arrow_y + 0.2 * rotate_arrow
          },
          {
            x: arrow_x,
            y: arrow_y
          },
          {
            x: arrow_x + 0.2 * rotate_arrow * -dx,
            y: arrow_y + 0.2
          },
          {
            x: arrow_x - 0.2 * -dx,
            y: arrow_y + 0.2 * rotate_arrow
          }
        ],
        type: "pcb_silkscreen_path",
        stroke_width: 0.1
      });
    }
  }
  const silkscreenRefText = silkscreenRef(
    0,
    parameters.h / 2 + (parameters.legsoutside ? parameters.pl * 1.2 : 0.5),
    0.3
  );
  return {
    circuitJson: [
      ...pads,
      ...silkscreen_corners,
      silkscreenRefText
    ],
    parameters
  };
};

// src/fn/qfn.ts
var qfn_def = base_quad_def.extend({}).transform(quadTransform);
var qfn = (parameters) => {
  parameters.legsoutside = false;
  return quad(parameters);
};

// src/fn/qfp.ts
var qfp = (raw_params) => {
  raw_params.legsoutside = true;
  const quad_defaults = quad_def.parse(raw_params);
  if (!raw_params.p) {
    switch (raw_params.num_pins) {
      case 44:
      case 64:
        raw_params.p = 0.8;
        break;
      case 52:
        if (raw_params.w === 14) raw_params.p = 1;
        else raw_params.p = 0.65;
        break;
      case 208:
        raw_params.p = 0.5;
        break;
    }
  }
  if (!raw_params.pl) {
    switch (raw_params.num_pins) {
      case 44:
      case 52:
      case 64:
        raw_params.pl = 2.25;
        break;
      case 208:
        raw_params.pl = 1.65;
        break;
      default:
        raw_params.pl = quad_defaults.pl * 4;
        break;
    }
  }
  if (!raw_params.pw) {
    switch (raw_params.num_pins) {
      case 44:
      case 64:
        raw_params.pw = 0.5;
        break;
      case 52:
        if (raw_params.w === 14) raw_params.pw = 0.45;
        else raw_params.pw = 0.55;
        break;
      case 208:
        raw_params.pw = 0.3;
        break;
      default:
        raw_params.pw = quad_defaults.pw;
        break;
    }
  }
  return quad(raw_params);
};

// src/fn/mlp.ts
var mlp_def = base_quad_def.extend({}).transform(quadTransform);
var mlp = (parameters) => {
  parameters.legsoutside = false;
  if (parameters.thermalpad === void 0) {
    parameters.thermalpad = true;
  }
  return quad(parameters);
};

// src/fn/ssop.ts
var ssop_def = extendSoicDef({
  w: "3.9mm",
  p: "1.27mm"
});
var ssop = (raw_params) => {
  const parameters = ssop_def.parse(raw_params);
  return {
    circuitJson: soicWithoutParsing(parameters),
    parameters
  };
};

// src/fn/tssop.ts
var tssop_def = extendSoicDef({
  w: "7.1mm",
  p: "0.65mm",
  pl: "1.35mm",
  pw: "0.40mm",
  legsoutside: true
});
var tssop = (raw_params) => {
  const parameters = tssop_def.parse(raw_params);
  return {
    circuitJson: soicWithoutParsing(parameters),
    parameters
  };
};

// src/fn/sot363.ts
var sot363_def = extendSoicDef({});
var sot363 = (raw_params) => {
  const parameters = sot363_def.parse({
    fn: "sot363",
    num_pins: 6,
    w: 1.94,
    p: 0.65,
    pw: 0.3,
    pl: 0.7,
    legoutside: true
  });
  return {
    circuitJson: soicWithoutParsing(parameters),
    parameters
  };
};

// src/fn/sot23.ts
import { z as z9 } from "zod";
var sot23_def = z9.object({
  fn: z9.string(),
  num_pins: z9.number().default(3),
  w: z9.string().default("1.92mm"),
  h: z9.string().default("2.74mm"),
  pl: z9.string().default("0.8mm"),
  pw: z9.string().default("0.764mm"),
  p: z9.string().default("0.95mm"),
  string: z9.string().optional()
});
var sot23_6_or_8_def = extendSoicDef({
  p: "0.95mm",
  w: "1.6mm",
  legsoutside: true
});
var sot23 = (raw_params) => {
  const match = raw_params.string?.match(/^sot23_(\d+)/);
  const numPins = match ? Number.parseInt(match[1], 10) : 3;
  if (numPins === 6 || numPins === 8) {
    const parameters2 = sot23_6_or_8_def.parse({
      ...raw_params,
      num_pins: numPins
    });
    return {
      circuitJson: soicWithoutParsing(parameters2),
      parameters: parameters2
    };
  }
  const parameters = sot23_def.parse({
    ...raw_params,
    num_pins: numPins
  });
  if (parameters.num_pins === 3) {
    return {
      circuitJson: sot23_3(parameters),
      parameters
    };
  }
  if (parameters.num_pins === 5) {
    return {
      circuitJson: sot23_5(parameters),
      parameters
    };
  }
  throw new Error("Invalid number of pins");
};
var getCcwSot23Coords = (parameters) => {
  const { pn, w, h, pl } = parameters;
  if (pn === 1) {
    return { x: -1.7, y: 0 };
  }
  if (pn === 2) {
    return { x: 1.7, y: -0.95 };
  }
  return { x: 1.7, y: 0.95 };
};
var sot23_3 = (parameters) => {
  const pads = [];
  for (let i = 0; i < parameters.num_pins; i++) {
    const { x, y } = getCcwSot23Coords({
      num_pins: parameters.num_pins,
      pn: i + 1,
      w: Number.parseFloat(parameters.w),
      h: Number.parseFloat(parameters.h),
      pl: Number.parseFloat(parameters.pl)
    });
    pads.push(
      rectpad(
        i + 1,
        x,
        y,
        Number.parseFloat(parameters.pl),
        Number.parseFloat(parameters.pw)
      )
    );
  }
  const silkscreenRefText = silkscreenRef(
    0,
    Number.parseInt(parameters.h),
    0.3
  );
  return [...pads, silkscreenRefText];
};
var getCcwSot235Coords = (parameters) => {
  const { p, h, pn } = parameters;
  if (pn === 1) {
    return { x: -h / 2 - 0.5, y: p };
  }
  if (pn === 2) {
    return { x: -h / 2 - 0.5, y: 0 };
  }
  if (pn === 3) {
    return { x: -h / 2 - 0.5, y: -p };
  }
  if (pn === 4) {
    return { x: h / 2 + 0.5, y: -p };
  }
  if (pn === 5) {
    return { x: h / 2 + 0.5, y: p };
  }
  throw new Error("Invalid pin number");
};
var sot23_5 = (parameters) => {
  const pads = [];
  for (let i = 1; i <= parameters.num_pins; i++) {
    const { x, y } = getCcwSot235Coords({
      h: Number.parseFloat(parameters.h),
      p: Number.parseFloat(parameters.p),
      pn: i
    });
    pads.push(
      rectpad(
        i,
        x,
        y,
        Number.parseFloat(parameters.pl),
        Number.parseFloat(parameters.pw)
      )
    );
  }
  const width = (parameters.num_pins + 1) / 2 * Number.parseFloat(parameters.p);
  const height = Number.parseFloat(parameters.h);
  const silkscreenPath1 = {
    layer: "top",
    pcb_component_id: "",
    pcb_silkscreen_path_id: "silkscreen_path_1",
    route: [
      { x: -width / 3, y: height / 2 + Number.parseFloat(parameters.p) / 1.3 },
      { x: width / 3, y: height / 2 + Number.parseFloat(parameters.p) / 1.3 }
    ],
    type: "pcb_silkscreen_path",
    stroke_width: 0.05
  };
  const silkscreenPath2 = {
    layer: "top",
    pcb_component_id: "",
    pcb_silkscreen_path_id: "silkscreen_path_2",
    route: [
      { x: -width / 3, y: -height / 2 - Number.parseFloat(parameters.p) / 1.3 },
      { x: width / 3, y: -height / 2 - Number.parseFloat(parameters.p) / 1.3 }
    ],
    type: "pcb_silkscreen_path",
    stroke_width: 0.05
  };
  const silkscreenRefText = silkscreenRef(0, height + 0.3, 0.3);
  const pin1Position = getCcwSot235Coords({
    h: Number.parseFloat(parameters.h),
    p: Number.parseFloat(parameters.p),
    pn: 1
  });
  pin1Position.x = pin1Position.x - Number.parseFloat(parameters.pw) * 1.5;
  const triangleHeight = 0.7;
  const triangleWidth = 0.3;
  const pin1Indicator = {
    type: "pcb_silkscreen_path",
    layer: "top",
    pcb_component_id: "",
    pcb_silkscreen_path_id: "pin1_indicator",
    route: [
      {
        x: pin1Position.x + triangleHeight / 2,
        y: pin1Position.y
      },
      // Tip of the triangle (pointing right)
      {
        x: pin1Position.x - triangleHeight / 2,
        y: pin1Position.y + triangleWidth / 2
      },
      // Bottom corner of the base
      {
        x: pin1Position.x - triangleHeight / 2,
        y: pin1Position.y - triangleWidth / 2
      },
      // Top corner of the base
      {
        x: pin1Position.x + triangleHeight / 2,
        y: pin1Position.y
      }
      // Close the path at the tip
    ],
    stroke_width: 0.05
  };
  return [
    ...pads,
    silkscreenRefText,
    silkscreenPath1,
    silkscreenPath2,
    pin1Indicator
  ];
};

// src/fn/sot25.ts
import "zod";
var sot25_def = sot23_def.extend({});
var sot25 = (raw_params) => {
  const parameters = sot25_def.parse({
    ...raw_params,
    num_pins: 5
  });
  return {
    circuitJson: sot23_5(parameters),
    parameters
  };
};

// src/fn/dfn.ts
import "zod";

// src/helpers/corner.ts
var CORNERS = [
  { name: "top-left", dx: -1, dy: 1 },
  { name: "top-right", dx: 1, dy: 1 },
  { name: "bottom-left", dx: -1, dy: -1 },
  { name: "bottom-right", dx: 1, dy: -1 }
];

// src/fn/dfn.ts
var dfn_def = extendSoicDef({});
var dfn = (raw_params) => {
  const parameters = dfn_def.parse(raw_params);
  const pads = [];
  for (let i = 0; i < parameters.num_pins; i++) {
    const { x, y } = getCcwSoicCoords({
      num_pins: parameters.num_pins,
      pn: i + 1,
      w: parameters.w,
      p: parameters.p ?? 1.27,
      pl: parameters.pl,
      widthincludeslegs: true
    });
    pads.push(
      rectpad(i + 1, x, y, parameters.pl ?? "1mm", parameters.pw ?? "0.6mm")
    );
  }
  const m = Math.min(1, parameters.p / 2);
  const sw = parameters.w + m;
  const sh = (parameters.num_pins / 2 - 1) * parameters.p + parameters.pw + m;
  const silkscreenPaths = [];
  for (const corner of CORNERS) {
    const { dx, dy } = corner;
    silkscreenPaths.push({
      layer: "top",
      pcb_component_id: "",
      pcb_silkscreen_path_id: "",
      route: [
        { x: dx * sw / 2 - dx * parameters.p, y: dy * sh / 2 },
        { x: dx * sw / 2, y: dy * sh / 2 },
        { x: dx * sw / 2, y: dy * sh / 2 - dy * parameters.p }
      ],
      type: "pcb_silkscreen_path",
      stroke_width: 0.1
    });
  }
  const as = parameters.p / 4;
  const atx = -sw / 2 - as / 2;
  const aty = sh / 2 - parameters.p / 2;
  silkscreenPaths.push({
    layer: "top",
    pcb_component_id: "",
    pcb_silkscreen_path_id: "",
    type: "pcb_silkscreen_path",
    route: [
      {
        x: atx,
        y: aty
      },
      {
        x: atx - as,
        y: aty + as
      },
      {
        x: atx - as,
        y: aty - as
      },
      {
        x: atx,
        y: aty
      }
    ],
    stroke_width: 0.1
  });
  const silkscreenRefText = silkscreenRef(
    0,
    sh / 2 + 0.4,
    sh / 12
  );
  return {
    circuitJson: [
      ...pads,
      silkscreenRefText,
      ...silkscreenPaths
    ],
    parameters
  };
};

// src/fn/pinrow.ts
import { z as z12 } from "zod";
import { length as length5 } from "circuit-json";

// src/helpers/platedHoleWithRectPad.ts
import { mm as mm3 } from "@tscircuit/mm";
var platedHoleWithRectPad = (pn, x, y, holeDiameter, rectPadWidth, rectPadHeight) => {
  return {
    pcb_plated_hole_id: "",
    type: "pcb_plated_hole",
    shape: "circular_hole_with_rect_pad",
    x,
    y,
    hole_diameter: mm3(holeDiameter),
    hole_shape: "circle",
    pad_shape: "rect",
    rect_pad_width: mm3(rectPadWidth),
    rect_pad_height: mm3(rectPadHeight),
    pcb_port_id: "",
    layers: ["top", "bottom"],
    port_hints: [pn.toString()]
  };
};

// src/helpers/silkscreenPin.ts
var silkscreenPin = ({
  fs,
  pn,
  anchor_x,
  anchor_y,
  textalign = "center",
  orthogonal = false,
  verticallyinverted = false,
  layer = "top"
}) => {
  let ccw_rotation = 0;
  if (orthogonal && verticallyinverted) {
    ccw_rotation = 270;
  } else if (verticallyinverted) {
    ccw_rotation = 180;
  } else if (orthogonal) {
    ccw_rotation = 90;
  } else {
    ccw_rotation = 0;
  }
  let anchor_alignment = "center";
  if (textalign === "left") {
    if (verticallyinverted) anchor_alignment = "center_right";
    else anchor_alignment = "center_left";
  }
  if (textalign === "right") {
    if (verticallyinverted) anchor_alignment = "center_left";
    else anchor_alignment = "center_right";
  }
  if (layer === "bottom") {
    if (anchor_alignment === "center_left") {
      anchor_alignment = "center_right";
    } else if (anchor_alignment === "center_right") {
      anchor_alignment = "center_left";
    }
  }
  return {
    type: "pcb_silkscreen_text",
    pcb_silkscreen_text_id: "silkscreen_text_1",
    font: "tscircuit2024",
    font_size: fs,
    pcb_component_id: "pcb_component_1",
    text: `{PIN${pn}}`,
    layer,
    anchor_position: { x: anchor_x, y: anchor_y },
    anchor_alignment,
    ccw_rotation
  };
};

// src/fn/pinrow.ts
import "@tscircuit/mm";

// src/helpers/determine-pin-label-anchor-side.ts
function determinePinlabelAnchorSide({
  pinlabeltextalignleft,
  pinlabeltextalignright,
  pinlabelorthogonal
}) {
  let pinlabelAnchorSide = "top";
  if (pinlabelorthogonal) {
    pinlabelAnchorSide = "left";
  } else {
    pinlabelAnchorSide = "top";
  }
  if (pinlabeltextalignleft) {
    if (pinlabelorthogonal) {
      pinlabelAnchorSide = "bottom";
    } else {
      pinlabelAnchorSide = "right";
    }
  }
  if (pinlabeltextalignright) {
    if (pinlabelorthogonal) {
      pinlabelAnchorSide = "top";
    } else {
      pinlabelAnchorSide = "left";
    }
  }
  return pinlabelAnchorSide;
}

// src/fn/pinrow.ts
var pinrow_def = z12.object({
  fn: z12.string(),
  num_pins: z12.number().optional().default(6),
  rows: z12.union([z12.string(), z12.number()]).transform((val) => Number(val)).optional().default(1).describe("number of rows"),
  p: length5.default("0.1in").describe("pitch"),
  id: length5.default("1.0mm").describe("inner diameter"),
  od: length5.default("1.5mm").describe("outer diameter"),
  male: z12.boolean().optional().describe("for male pin headers"),
  female: z12.boolean().optional().describe("for female pin headers"),
  pinlabeltextalignleft: z12.boolean().optional().default(false),
  pinlabeltextaligncenter: z12.boolean().optional().default(false),
  pinlabeltextalignright: z12.boolean().optional().default(false),
  pinlabelverticallyinverted: z12.boolean().optional().default(false),
  pinlabelorthogonal: z12.boolean().optional().default(false),
  nosquareplating: z12.boolean().optional().default(false).describe("do not use rectangular pad for pin 1"),
  nopinlabels: z12.boolean().optional().default(false).describe("omit silkscreen pin labels"),
  doublesidedpinlabel: z12.boolean().optional().default(false).describe("add silkscreen pins in top and bottom layers"),
  backsidelabel: z12.boolean().optional().default(false).describe(
    "place the silkscreen reference text on the bottom layer instead of top"
  )
}).transform((data) => {
  const pinlabelAnchorSide = determinePinlabelAnchorSide(data);
  return {
    ...data,
    pinlabelAnchorSide,
    male: data.male ?? (data.female ? false : true),
    female: data.female ?? false
  };
}).superRefine((data, ctx) => {
  if (data.male && data.female) {
    ctx.addIssue({
      code: z12.ZodIssueCode.custom,
      message: "'male' and 'female' cannot both be true; it should be male or female.",
      path: ["male", "female"]
    });
  }
});
var pinrow = (raw_params) => {
  const parameters = pinrow_def.parse(raw_params);
  const {
    p,
    id,
    od,
    rows,
    num_pins,
    pinlabelAnchorSide,
    pinlabelverticallyinverted,
    pinlabelorthogonal,
    pinlabeltextalignleft,
    pinlabeltextalignright,
    nopinlabels,
    doublesidedpinlabel,
    backsidelabel
  } = parameters;
  let pinlabelTextAlign = "center";
  if (pinlabeltextalignleft) pinlabelTextAlign = "left";
  else if (pinlabeltextalignright) pinlabelTextAlign = "right";
  const holes = [];
  const numPinsPerRow = Math.ceil(num_pins / rows);
  const ySpacing = -p;
  const calculateAnchorPosition = ({
    xoff,
    yoff,
    od: od2,
    anchorSide
  }) => {
    let dx = 0, dy = 0;
    const offset = od2 * 0.75;
    switch (anchorSide) {
      case "right":
        dx = offset;
        break;
      case "top":
        dy = offset;
        break;
      case "bottom":
        dy = -offset;
        break;
      case "left":
        dx = -offset;
        break;
    }
    return { anchor_x: xoff + dx, anchor_y: yoff + dy };
  };
  const addPin = (pinNumber, xoff, yoff) => {
    if (pinNumber === 1 && !parameters.nosquareplating) {
      holes.push(platedHoleWithRectPad(pinNumber, xoff, yoff, id, od, od));
    } else {
      holes.push(platedhole(pinNumber, xoff, yoff, id, od));
    }
    const { anchor_x, anchor_y } = calculateAnchorPosition({
      xoff,
      yoff,
      od,
      anchorSide: pinlabelAnchorSide
    });
    if (!nopinlabels) {
      if (!backsidelabel) {
        holes.push(
          silkscreenPin({
            fs: od / 5,
            pn: pinNumber,
            anchor_x,
            anchor_y,
            anchorplacement: pinlabelAnchorSide,
            textalign: pinlabelTextAlign,
            orthogonal: pinlabelorthogonal,
            verticallyinverted: pinlabelverticallyinverted,
            layer: "top"
          })
        );
      } else {
        holes.push(
          silkscreenPin({
            fs: od / 5,
            pn: pinNumber,
            anchor_x,
            anchor_y,
            anchorplacement: pinlabelAnchorSide,
            textalign: pinlabelTextAlign,
            orthogonal: pinlabelorthogonal,
            verticallyinverted: pinlabelverticallyinverted,
            layer: "bottom"
          })
        );
      }
      if (doublesidedpinlabel) {
        holes.push(
          silkscreenPin({
            fs: od / 5,
            pn: pinNumber,
            anchor_x,
            anchor_y,
            anchorplacement: pinlabelAnchorSide,
            textalign: pinlabelTextAlign,
            orthogonal: pinlabelorthogonal,
            verticallyinverted: pinlabelverticallyinverted,
            layer: "bottom"
          })
        );
      }
    }
  };
  const usedPositions = /* @__PURE__ */ new Set();
  const useBGAStyle = rows > 2 && numPinsPerRow > 2;
  if (rows === 1) {
    const xStart = -((num_pins - 1) / 2) * p;
    for (let i = 0; i < num_pins; i++) {
      const pinNumber = i + 1;
      const xoff = xStart + i * p;
      const posKey = `${xoff},${0}`;
      if (usedPositions.has(posKey)) throw new Error(`Overlap at ${posKey}`);
      usedPositions.add(posKey);
      addPin(pinNumber, xoff, 0);
    }
  } else if (useBGAStyle) {
    const xStart = -((numPinsPerRow - 1) / 2) * p;
    let currentPin = 1;
    for (let row = 0; row < rows && currentPin <= num_pins; row++) {
      for (let col = 0; col < numPinsPerRow && currentPin <= num_pins; col++) {
        const xoff = xStart + col * p;
        const yoff = row * ySpacing;
        const posKey = `${xoff},${yoff}`;
        if (usedPositions.has(posKey)) throw new Error(`Overlap at ${posKey}`);
        usedPositions.add(posKey);
        addPin(currentPin++, xoff, yoff);
      }
    }
  } else {
    const xStart = -((numPinsPerRow - 1) / 2) * p;
    let currentPin = 1;
    let top = 0;
    let bottom = rows - 1;
    let left = 0;
    let right = numPinsPerRow - 1;
    while (currentPin <= num_pins && top <= bottom && left <= right) {
      for (let row = top; row <= bottom && currentPin <= num_pins; row++) {
        const xoff = xStart + left * p;
        const yoff = row * ySpacing;
        const posKey = `${xoff},${yoff}`;
        if (usedPositions.has(posKey)) throw new Error(`Overlap at ${posKey}`);
        usedPositions.add(posKey);
        addPin(currentPin++, xoff, yoff);
      }
      left++;
      for (let col = left; col <= right && currentPin <= num_pins; col++) {
        const xoff = xStart + col * p;
        const yoff = bottom * ySpacing;
        const posKey = `${xoff},${yoff}`;
        if (usedPositions.has(posKey)) throw new Error(`Overlap at ${posKey}`);
        usedPositions.add(posKey);
        addPin(currentPin++, xoff, yoff);
      }
      bottom--;
      if (left <= right) {
        for (let row = bottom; row >= top && currentPin <= num_pins; row--) {
          const xoff = xStart + right * p;
          const yoff = row * ySpacing;
          const posKey = `${xoff},${yoff}`;
          if (usedPositions.has(posKey)) throw new Error(`Overlap at ${posKey}`);
          usedPositions.add(posKey);
          addPin(currentPin++, xoff, yoff);
        }
        right--;
      }
      if (top <= bottom) {
        for (let col = right; col >= left && currentPin <= num_pins; col--) {
          const xoff = xStart + col * p;
          const yoff = top * ySpacing;
          const posKey = `${xoff},${yoff}`;
          if (usedPositions.has(posKey)) throw new Error(`Overlap at ${posKey}`);
          usedPositions.add(posKey);
          addPin(currentPin++, xoff, yoff);
        }
        top++;
      }
    }
    if (currentPin - 1 < num_pins) {
      throw new Error(
        `Missing pins: assigned ${currentPin - 1}, expected ${num_pins}`
      );
    }
  }
  const refText = silkscreenRef(0, p, 0.5);
  return {
    circuitJson: [...holes, refText],
    parameters
  };
};

// src/fn/sot563.ts
var sot563_def = extendSoicDef({});
var sot563 = (raw_params) => {
  const parameters = sot563_def.parse({
    fn: "sot563",
    num_pins: 6,
    w: 1.94,
    p: 0.5,
    pw: 0.3,
    pl: 0.67,
    legoutside: true
  });
  return {
    circuitJson: soicWithoutParsing(parameters),
    parameters
  };
};

// src/fn/ms012.ts
var ms012_def = extendSoicDef({
  p: "1.27mm",
  w: "3.9mm",
  legsoutside: true
});
var ms012 = (raw_params) => {
  const parameters = ms012_def.parse({ ...raw_params, num_pins: 8 });
  return {
    circuitJson: soicWithoutParsing(parameters),
    parameters
  };
};

// src/fn/ms013.ts
var ms013_def = extendSoicDef({
  p: "1.27mm",
  w: "7.5mm",
  legsoutside: true
});
var ms013 = (raw_params) => {
  const parameters = ms013_def.parse({ ...raw_params, num_pins: 16 });
  return {
    circuitJson: soicWithoutParsing(parameters),
    parameters
  };
};

// src/fn/sot723.ts
import { length as length6 } from "circuit-json";
import { z as z13 } from "zod";
var sot723_def = z13.object({
  fn: z13.string(),
  num_pins: z13.literal(3).default(3),
  w: z13.string().default("1.2mm"),
  h: z13.string().default("1.2mm"),
  pl: z13.string().default("0.3mm"),
  pw: z13.string().default("0.32mm")
});
var sot723 = (raw_params) => {
  const parameters = sot723_def.parse(raw_params);
  const pad2 = sot723WithoutParsing(parameters);
  const silkscreenRefText = silkscreenRef(
    0.4,
    length6.parse(parameters.h),
    0.2
  );
  return {
    circuitJson: [...pad2, silkscreenRefText],
    parameters
  };
};
var getCcwSot723Coords = (parameters) => {
  const { pn, w, h, pl } = parameters;
  if (pn === 1) {
    return { x: 0, y: 0 };
  } else if (pn === 2) {
    return { x: 1, y: -0.4 };
  } else {
    return { x: 1, y: 0.4 };
  }
};
var sot723WithoutParsing = (parameters) => {
  const pads = [];
  for (let i = 0; i < 3; i++) {
    const { x, y } = getCcwSot723Coords({
      num_pins: parameters.num_pins,
      pn: i + 1,
      w: Number.parseFloat(parameters.w),
      h: Number.parseFloat(parameters.h),
      pl: Number.parseFloat(parameters.pl)
    });
    pads.push(
      rectpad(
        i + 1,
        x,
        y,
        Number.parseFloat(parameters.pl),
        i !== 0 ? Number.parseFloat(parameters.pw) : 0.42
      )
    );
  }
  return pads;
};

// src/fn/sod123.ts
import { z as z14 } from "zod";
import { length as length7 } from "circuit-json";
var sod_def = z14.object({
  fn: z14.string(),
  num_pins: z14.literal(2).default(2),
  w: z14.string().default("2.36mm"),
  h: z14.string().default("1.22mm"),
  pl: z14.string().default("0.9mm"),
  pw: z14.string().default("0.9mm"),
  p: z14.string().default("4.19mm")
});
var sod123 = (raw_params) => {
  const parameters = sod_def.parse(raw_params);
  const silkscreenRefText = silkscreenRef(
    0,
    length7.parse(parameters.h) / 4 + 0.4,
    0.3
  );
  return {
    circuitJson: sodWithoutParsing(parameters).concat(
      silkscreenRefText
    ),
    parameters
  };
};
var getSodCoords = (parameters) => {
  const { pn, p } = parameters;
  if (pn === 1) {
    return { x: -p / 2, y: 0 };
  } else {
    return { x: p / 2, y: 0 };
  }
};
var sodWithoutParsing = (parameters) => {
  const pads = [];
  for (let i = 1; i <= parameters.num_pins; i++) {
    const { x, y } = getSodCoords({
      pn: i,
      p: Number.parseFloat(parameters.p)
    });
    pads.push(
      rectpad(
        i,
        x,
        y,
        Number.parseFloat(parameters.pl),
        Number.parseFloat(parameters.pw)
      )
    );
  }
  return pads;
};

// src/fn/axial.ts
import {
  length as length8
} from "circuit-json";
import { z as z15 } from "zod";
var axial_def = z15.object({
  fn: z15.string(),
  p: length8.optional().default("2.54mm"),
  id: length8.optional().default("0.7mm"),
  od: length8.optional().default("1mm")
});
var axial = (raw_params) => {
  const parameters = axial_def.parse(raw_params);
  const { p, id, od } = parameters;
  const plated_holes = [
    platedhole(1, -p / 2, 0, id, od),
    platedhole(2, p / 2, 0, id, od)
  ];
  const silkscreenLine = {
    type: "pcb_silkscreen_path",
    layer: "top",
    pcb_component_id: "",
    route: [
      { x: -p / 2 + od + id / 2, y: 0 },
      { x: p / 2 - od - id / 2, y: 0 }
    ],
    stroke_width: 0.1,
    pcb_silkscreen_path_id: ""
  };
  const silkscreenRefText = silkscreenRef(0, p / 4, 0.5);
  return {
    circuitJson: [
      ...plated_holes,
      silkscreenLine,
      silkscreenRefText
    ],
    parameters
  };
};

// src/fn/pushbutton.ts
import { length as length9 } from "circuit-json";
import { z as z16 } from "zod";

// src/helpers/silkscreenpath.ts
var silkscreenpath = (route, options = {}) => {
  return {
    type: "pcb_silkscreen_path",
    layer: options.layer || "top",
    pcb_component_id: options.pcb_component_id || "",
    pcb_silkscreen_path_id: options.pcb_silkscreen_path_id || "",
    route,
    stroke_width: options.stroke_width || 0.1
  };
};

// src/fn/pushbutton.ts
var pushbutton_def = z16.object({
  fn: z16.literal("pushbutton"),
  w: length9.default(4.5),
  h: length9.default(6.5),
  id: length9.default(1),
  od: length9.default(1.2)
});
var pushbutton = (raw_params) => {
  const parameters = pushbutton_def.parse(raw_params);
  const width = parameters.w;
  const height = parameters.h;
  const holeDiameter = parameters.id;
  const holes = [
    platedhole(1, -width / 2, height / 2, holeDiameter, holeDiameter * 1.5),
    platedhole(2, -width / 2, -height / 2, holeDiameter, holeDiameter * 1.5),
    platedhole(3, width / 2, -height / 2, holeDiameter, holeDiameter * 1.5),
    platedhole(4, width / 2, height / 2, holeDiameter, holeDiameter * 1.5)
  ];
  const silkscreenLines = [
    // Vertical lines indicating connections
    silkscreenpath([
      { x: -width / 2, y: -height / 2 },
      { x: -width / 2, y: height / 2 }
    ]),
    silkscreenpath([
      { x: width / 2, y: -height / 2 },
      { x: width / 2, y: height / 2 }
    ]),
    // Center indicating latch
    silkscreenpath([
      { x: -width / 2, y: 0 },
      { x: -width / 5, y: 0 },
      { x: width / 5 * 1 / Math.sqrt(2), y: height / 8 }
    ]),
    silkscreenpath([
      { x: width / 2, y: 0 },
      { x: width / 5, y: 0 }
    ])
  ];
  const silkscreenRefText = silkscreenRef(
    0,
    height / 2 + 0.4,
    0.5
  );
  return {
    circuitJson: [...holes, ...silkscreenLines, silkscreenRefText],
    parameters
  };
};

// src/fn/stampboard.ts
import {
  length as length10
} from "circuit-json";
import { z as z17 } from "zod";
var stampboard_def = z17.object({
  fn: z17.string(),
  w: length10.default("22.58mm"),
  h: length10.optional(),
  left: length10.optional().default(20),
  right: length10.optional().default(20),
  top: length10.optional().default(2),
  bottom: length10.optional().default(2),
  p: length10.default(length10.parse("2.54mm")),
  pw: length10.default(length10.parse("1.6mm")),
  pl: length10.default(length10.parse("2.4mm")),
  innerhole: z17.boolean().default(false),
  innerholeedgedistance: length10.default(length10.parse("1.61mm"))
});
var getHeight = (parameters) => {
  const params = stampboard_def.parse(parameters);
  if (params.left && params.right) {
    return Math.max(params.left, params.right) * params.p;
  }
  if (params.left) {
    return params.left * params.p;
  }
  if (params.right) {
    return params.right * params.p;
  }
  return 51;
};
var getTriangleDir = (x, y, side) => {
  let routes = [];
  const triangleHeight = 1;
  const triangleWidth = 0.6;
  if (side === "right") {
    routes = [
      {
        x: x + triangleHeight / 2,
        y
      },
      // Tip of the triangle (pointing right)
      {
        x: x - triangleHeight / 2,
        y: y + triangleWidth / 2
      },
      // Bottom corner of the base
      {
        x: x - triangleHeight / 2,
        y: y - triangleWidth / 2
      },
      // Top corner of the base
      {
        x: x + triangleHeight / 2,
        y
      }
      // Close the path at the tip
    ];
  }
  if (side === "left") {
    routes = [
      {
        x: x - triangleHeight / 2,
        y
      },
      // Tip of the triangle (pointing left)
      {
        x: x + triangleHeight / 2,
        y: y + triangleWidth / 2
      },
      // Top corner of the base
      {
        x: x + triangleHeight / 2,
        y: y - triangleWidth / 2
      },
      // Bottom corner of the base
      {
        x: x - triangleHeight / 2,
        y
      }
      // Close the path at the tip
    ];
  }
  if (side === "top") {
    routes = [
      {
        x,
        y: y + triangleHeight / 2
      },
      // Tip of the triangle (pointing up)
      {
        x: x - triangleWidth / 2,
        y: y - triangleHeight / 2
      },
      // Left corner of the base
      {
        x: x + triangleWidth / 2,
        y: y - triangleHeight / 2
      },
      // Right corner of the base
      {
        x,
        y: y + triangleHeight / 2
      }
      // Close the path at the tip
    ];
  }
  if (side === "bottom") {
    routes = [
      {
        x,
        y: y - triangleHeight / 2
      },
      // Tip of the triangle (pointing down)
      {
        x: x - triangleWidth / 2,
        y: y + triangleHeight / 2
      },
      // Left corner of the base
      {
        x: x + triangleWidth / 2,
        y: y + triangleHeight / 2
      },
      // Right corner of the base
      {
        x,
        y: y - triangleHeight / 2
      }
      // Close the path at the tip
    ];
  }
  return routes;
};
var stampboard = (raw_params) => {
  const params = stampboard_def.parse(raw_params);
  const height = params.h ?? getHeight(params);
  const rectpads = [];
  const holes = [];
  let routes = [];
  const innerDiameter = 1;
  const outerDiameter = 1.2;
  const totalPadsNumber = params.left + params.right + (params.bottom ?? 0) + (params.top ?? 0);
  if (params.right) {
    const yoff = -((params.right - 1) / 2) * params.p;
    for (let i = 0; i < params.right; i++) {
      if (i === 0 && !params.left && !params.bottom) {
        routes = getTriangleDir(
          params.w / 2 - params.pl * 1.4,
          yoff + i * params.p,
          "right"
        );
      }
      rectpads.push(
        rectpad(
          i + 1 + params.left + (params.bottom ?? 0),
          params.w / 2 - params.pl / 2,
          yoff + i * params.p,
          params.pl,
          params.pw
        )
      );
      if (params.innerhole) {
        holes.push(
          platedhole(
            i + 1 + params.left + (params.bottom ?? 0) + totalPadsNumber,
            params.w / 2,
            yoff + i * params.p,
            innerDiameter,
            outerDiameter
          )
        );
        holes.push(
          platedhole(
            i + 1 + params.left + (params.bottom ?? 0) + totalPadsNumber * 2,
            params.w / 2 - params.innerholeedgedistance,
            yoff + i * params.p,
            innerDiameter,
            outerDiameter
          )
        );
      }
    }
  }
  if (params.left) {
    const yoff = -((params.left - 1) / 2) * params.p;
    for (let i = 0; i < params.left; i++) {
      if (i === params.left - 1) {
        routes = getTriangleDir(
          -params.w / 2 + params.pl * 1.4,
          yoff + i * params.p,
          "left"
        );
      }
      rectpads.push(
        rectpad(
          i + 1,
          -params.w / 2 + params.pl / 2,
          yoff + i * params.p,
          params.pl,
          params.pw
        )
      );
      if (params.innerhole) {
        holes.push(
          platedhole(
            i + 1 + totalPadsNumber,
            -params.w / 2,
            yoff + i * params.p,
            innerDiameter,
            outerDiameter
          )
        );
        holes.push(
          platedhole(
            i + 1 + totalPadsNumber * 2,
            -params.w / 2 + params.innerholeedgedistance,
            yoff + i * params.p,
            innerDiameter,
            outerDiameter
          )
        );
      }
    }
  }
  if (params.top) {
    const xoff = -((params.top - 1) / 2) * params.p;
    for (let i = 0; i < params.top; i++) {
      if (i === params.top - 1 && !params.left && !params.bottom && !params.right) {
        routes = getTriangleDir(
          xoff + i * params.p,
          height / 2 - params.pl * 1.4,
          "top"
        );
      }
      rectpads.push(
        rectpad(
          i + 1 + params.left + params.right + (params.bottom ?? 0),
          xoff + i * params.p,
          height / 2 - params.pl / 2,
          params.pw,
          params.pl
        )
      );
      if (params.innerhole) {
        holes.push(
          platedhole(
            i + 1 + params.left + params.right + (params.bottom ?? 0) + totalPadsNumber,
            xoff + i * params.p,
            height / 2,
            innerDiameter,
            outerDiameter
          )
        );
        holes.push(
          platedhole(
            i + 1 + params.left + params.right + (params.bottom ?? 0) + totalPadsNumber * 2,
            xoff + i * params.p,
            height / 2 - params.innerholeedgedistance,
            innerDiameter,
            outerDiameter
          )
        );
      }
    }
  }
  if (params.bottom) {
    const xoff = -((params.bottom - 1) / 2) * params.p;
    for (let i = 0; i < params.bottom; i++) {
      if (i === 0 && !params.left) {
        routes = getTriangleDir(
          xoff + i * params.p,
          -height / 2 + params.pl * 1.4,
          "bottom"
        );
      }
      rectpads.push(
        rectpad(
          i + 1 + params.left,
          xoff + i * params.p,
          -height / 2 + params.pl / 2,
          params.pw,
          params.pl
        )
      );
      if (params.innerhole) {
        holes.push(
          platedhole(
            i + 1 + params.left + totalPadsNumber,
            xoff + i * params.p,
            -height / 2,
            innerDiameter,
            outerDiameter
          )
        );
        holes.push(
          platedhole(
            i + 1 + params.left + totalPadsNumber * 2,
            xoff + i * params.p,
            -height / 2 + params.innerholeedgedistance,
            innerDiameter,
            outerDiameter
          )
        );
      }
    }
  }
  const silkscreenTriangle = {
    type: "pcb_silkscreen_path",
    pcb_silkscreen_path_id: "pcb_silkscreen_triangle_1",
    pcb_component_id: "2",
    route: routes,
    stroke_width: 0.1,
    layer: "top"
  };
  const silkscreenPath = {
    type: "pcb_silkscreen_path",
    pcb_silkscreen_path_id: "pcb_silkscreen_path_1",
    pcb_component_id: "1",
    route: [
      { x: -params.w / 2, y: height / 2 },
      { x: params.w / 2, y: height / 2 },
      { x: params.w / 2, y: -height / 2 },
      { x: -params.w / 2, y: -height / 2 },
      { x: -params.w / 2, y: height / 2 }
    ],
    stroke_width: 0.1,
    layer: "top"
  };
  const silkscreenRefText = silkscreenRef(
    0,
    height / 1.8,
    height / 25
  );
  return {
    circuitJson: [
      ...rectpads,
      ...holes,
      silkscreenPath,
      silkscreenTriangle,
      silkscreenRefText
    ],
    parameters: params
  };
};

// src/fn/stampreceiver.ts
import {
  length as length11
} from "circuit-json";
import { z as z18 } from "zod";
var stampreceiver_def = z18.object({
  fn: z18.string(),
  w: length11.default("22.58mm"),
  h: length11.optional(),
  left: length11.optional().default(20),
  right: length11.optional().default(20),
  top: length11.optional().default(2),
  bottom: length11.optional().default(2),
  p: length11.default(length11.parse("2.54mm")),
  pw: length11.default(length11.parse("1.6mm")),
  pl: length11.default(length11.parse("3.2mm")),
  innerhole: z18.boolean().default(false),
  innerholeedgedistance: length11.default(length11.parse("1.61mm"))
});
var getHeight2 = (parameters) => {
  const params = stampreceiver_def.parse(parameters);
  if (params.left && params.right) {
    return Math.max(params.left, params.right) * params.p;
  }
  if (params.left) {
    return params.left * params.p;
  }
  if (params.right) {
    return params.right * params.p;
  }
  return 51;
};
var getTriangleDir2 = (x, y, side, triangleHeight = 1, triangleWidth = 0.6) => {
  const halfHeight = triangleHeight / 2;
  const halfWidth = triangleWidth / 2;
  const routes = {
    left: [
      { x: x + halfHeight, y },
      // Tip
      { x: x - halfHeight, y: y + halfWidth },
      // Bottom corner
      { x: x - halfHeight, y: y - halfWidth },
      // Top corner
      { x: x + halfHeight, y }
      // Close path
    ],
    right: [
      { x: x - halfHeight, y },
      // Tip
      { x: x + halfHeight, y: y + halfWidth },
      // Top corner
      { x: x + halfHeight, y: y - halfWidth },
      // Bottom corner
      { x: x - halfHeight, y }
      // Close path
    ],
    top: [
      { x, y: y - halfHeight },
      // Tip
      { x: x - halfWidth, y: y + halfHeight },
      // Left corner
      { x: x + halfWidth, y: y + halfHeight },
      // Right corner
      { x, y: y - halfHeight }
      // Close path
    ],
    bottom: [
      { x, y: y + halfHeight },
      // Tip
      { x: x - halfWidth, y: y - halfHeight },
      // Left corner
      { x: x + halfWidth, y: y - halfHeight },
      // Right corner
      { x, y: y + halfHeight }
      // Close path
    ]
  };
  return routes[side];
};
var stampreceiver = (raw_params) => {
  const params = stampreceiver_def.parse(raw_params);
  const height = params.h ?? getHeight2(params);
  const rectpads = [];
  const pinLabels = [];
  const holes = [];
  const innerDiameter = 1;
  const outerDiameter = 1.2;
  const totalPadsNumber = params.left + params.right + (params.bottom ?? 0) + (params.top ?? 0);
  let routes = [];
  let padIndex = 1;
  if (params.left) {
    const yoff = (params.left - 1) / 2 * params.p;
    for (let i = 0; i < params.left; i++) {
      if (i === 0) {
        routes = getTriangleDir2(
          -params.w / 2 - params.pl / 2,
          yoff - i * params.p,
          "left"
        );
      }
      rectpads.push(
        rectpad(
          padIndex,
          -params.w / 2 + params.pl / 2,
          yoff - i * params.p,
          params.pl,
          params.pw
        )
      );
      pinLabels.push({
        type: "pcb_silkscreen_text",
        pcb_silkscreen_text_id: `pin_${padIndex}`,
        pcb_component_id: "1",
        layer: "top",
        anchor_position: {
          x: -params.w / 2 + params.pl / 2 - 4.5,
          y: yoff - i * params.p
        },
        text: `pin${padIndex}`,
        font_size: 0.7,
        font: "tscircuit2024",
        anchor_alignment: "center"
      });
      padIndex++;
      params.innerhole && holes.push(
        platedhole(
          padIndex + totalPadsNumber,
          -params.w / 2 + params.innerholeedgedistance,
          yoff - i * params.p,
          innerDiameter,
          outerDiameter
        )
      );
    }
  }
  if (params.bottom) {
    const xoff = (params.bottom - 1) / 2 * params.p;
    for (let i = params.bottom - 1; i >= 0; i--) {
      rectpads.push(
        rectpad(
          padIndex,
          xoff - i * params.p,
          -height / 2 + params.pl / 2,
          params.pw,
          params.pl
        )
      );
      pinLabels.push({
        type: "pcb_silkscreen_text",
        pcb_silkscreen_text_id: `pin_${padIndex}`,
        pcb_component_id: "1",
        layer: "top",
        anchor_position: {
          x: xoff - i * params.p,
          y: -height / 2 + params.pl / 2 - 3.2
        },
        text: `pin${padIndex}`,
        font_size: 0.7,
        font: "tscircuit2024",
        anchor_alignment: "center"
      });
      padIndex++;
      params.innerhole && holes.push(
        platedhole(
          padIndex + totalPadsNumber,
          xoff - i * params.p,
          -height / 2 + params.innerholeedgedistance,
          innerDiameter,
          outerDiameter
        )
      );
    }
  }
  if (params.right) {
    const yoff = -((params.right - 1) / 2) * params.p;
    for (let i = 0; i < params.right; i++) {
      rectpads.push(
        rectpad(
          padIndex,
          params.w / 2 - params.pl / 2,
          yoff + i * params.p,
          params.pl,
          params.pw
        )
      );
      pinLabels.push({
        type: "pcb_silkscreen_text",
        pcb_silkscreen_text_id: `pin_${padIndex}`,
        pcb_component_id: "1",
        layer: "top",
        anchor_position: {
          x: params.w / 2 - params.pl / 2 + 3.7,
          y: yoff + i * params.p
        },
        text: `pin${padIndex}`,
        font_size: 0.7,
        font: "tscircuit2024",
        anchor_alignment: "center"
      });
      padIndex++;
      params.innerhole && holes.push(
        platedhole(
          padIndex + totalPadsNumber,
          params.w / 2 - params.innerholeedgedistance,
          yoff + i * params.p,
          innerDiameter,
          outerDiameter
        )
      );
    }
  }
  if (params.top) {
    const xoff = -((params.top - 1) / 2) * params.p;
    for (let i = params.top - 1; i >= 0; i--) {
      rectpads.push(
        rectpad(
          padIndex,
          xoff + i * params.p,
          height / 2 - params.pl / 2,
          params.pw,
          params.pl
        )
      );
      pinLabels.push({
        type: "pcb_silkscreen_text",
        pcb_silkscreen_text_id: `pin_${padIndex}`,
        pcb_component_id: "1",
        layer: "top",
        anchor_position: {
          x: xoff + i * params.p,
          y: height / 2 - params.pl / 2 + 3.2
        },
        text: `pin${padIndex}`,
        font_size: 0.7,
        font: "tscircuit2024",
        anchor_alignment: "center"
      });
      padIndex++;
      params.innerhole && holes.push(
        platedhole(
          padIndex + totalPadsNumber,
          xoff + i * params.p,
          height / 2 - params.innerholeedgedistance,
          innerDiameter,
          outerDiameter
        )
      );
    }
  }
  const silkscreenTriangle = {
    type: "pcb_silkscreen_path",
    pcb_silkscreen_path_id: "1",
    pcb_component_id: "1",
    layer: "top",
    route: routes,
    stroke_width: 0.1
  };
  const silkscreenPath = {
    type: "pcb_silkscreen_path",
    pcb_silkscreen_path_id: "pcb_silkscreen_path_1",
    pcb_component_id: "1",
    route: [
      {
        x: -params.w / 2 - params.pl / 3,
        y: height / 2 + params.pl / 3
      },
      {
        x: params.w / 2 + params.pl / 3,
        y: height / 2 + params.pl / 3
      },
      {
        x: params.w / 2 + params.pl / 3,
        y: -height / 2 - params.pl / 3
      },
      {
        x: -params.w / 2 - params.pl / 3,
        y: -height / 2 - params.pl / 3
      },
      {
        x: -params.w / 2 - params.pl / 3,
        y: height / 2 + params.pl / 3
      }
    ],
    stroke_width: 0.1,
    layer: "top"
  };
  const silkscreenRefText = silkscreenRef(
    0,
    height / 1.8,
    height / 25
  );
  return {
    circuitJson: [
      ...holes,
      ...rectpads,
      ...pinLabels,
      silkscreenPath,
      silkscreenTriangle,
      silkscreenRefText
    ],
    parameters: params
  };
};

// src/fn/lqfp.ts
var lqfp = (parameters) => {
  parameters.legsoutside = true;
  return quad(parameters);
};

// src/fn/breakoutheaders.ts
import {
  length as length12
} from "circuit-json";
import { z as z19 } from "zod";
var breakoutheaders_def = z19.object({
  fn: z19.string(),
  w: length12.default("10mm"),
  h: length12.optional(),
  left: length12.optional().default(20),
  right: length12.optional().default(20),
  top: length12.optional().default(0),
  bottom: length12.optional().default(0),
  p: length12.default(length12.parse("2.54mm")),
  id: length12.optional().default(length12.parse("1mm")),
  od: length12.optional().default(length12.parse("1.5mm"))
});
var getHeight3 = (parameters) => {
  const params = breakoutheaders_def.parse(parameters);
  if (params.left && params.right) {
    return Math.max(params.left, params.right) * params.p;
  }
  if (params.left) {
    return params.left * params.p;
  }
  if (params.right) {
    return params.right * params.p;
  }
  return 51;
};
var getTrianglePath = (x, y, side, triangleHeight = 1, triangleWidth = 0.6) => {
  const halfHeight = triangleHeight / 2;
  const halfWidth = triangleWidth / 2;
  const silkscreenTriangleRoutes = {
    left: [
      { x: x + halfHeight, y },
      { x: x - halfHeight, y: y + halfWidth },
      { x: x - halfHeight, y: y - halfWidth },
      { x: x + halfHeight, y }
    ],
    right: [
      { x: x - halfHeight, y },
      { x: x + halfHeight, y: y + halfWidth },
      { x: x + halfHeight, y: y - halfWidth },
      { x: x - halfHeight, y }
    ],
    top: [
      { x, y: y - halfHeight },
      { x: x - halfWidth, y: y + halfHeight },
      { x: x + halfWidth, y: y + halfHeight },
      { x, y: y - halfHeight }
    ],
    bottom: [
      { x, y: y + halfHeight },
      { x: x - halfWidth, y: y - halfHeight },
      { x: x + halfWidth, y: y - halfHeight },
      { x, y: y + halfHeight }
    ]
  };
  return silkscreenTriangleRoutes[side];
};
var breakoutheaders = (raw_params) => {
  const params = breakoutheaders_def.parse(raw_params);
  const height = params.h ?? getHeight3(params);
  const holes = [];
  const innerDiameter = params.id;
  const outerDiameter = params.od;
  let silkscreenTriangleRoutes = [];
  if (params.right) {
    const yoff = -((params.right - 1) / 2) * params.p;
    for (let i = 0; i < params.right; i++) {
      if (i === 0 && !params.left && !params.bottom) {
        silkscreenTriangleRoutes = getTrianglePath(
          params.w / 2 + outerDiameter * 1.4,
          yoff + i * params.p,
          "right"
        );
      }
      holes.push(
        platedhole(
          i + 1 + params.left + (params.bottom ?? 0),
          params.w / 2,
          yoff + i * params.p,
          innerDiameter,
          outerDiameter
        )
      );
    }
  }
  if (params.left) {
    const yoff = -((params.left - 1) / 2) * params.p;
    for (let i = 0; i < params.left; i++) {
      if (i === params.left - 1) {
        silkscreenTriangleRoutes = getTrianglePath(
          -params.w / 2 - outerDiameter * 1.4,
          yoff + i * params.p,
          "left"
        );
      }
      holes.push(
        platedhole(
          i + 1,
          -params.w / 2,
          yoff + i * params.p,
          innerDiameter,
          outerDiameter
        )
      );
    }
  }
  if (params.top) {
    const xoff = -((params.top - 1) / 2) * params.p;
    for (let i = 0; i < params.top; i++) {
      if (i === params.top - 1 && !params.left && !params.bottom && !params.right) {
        silkscreenTriangleRoutes = getTrianglePath(
          xoff + i * params.p,
          height / 2 + outerDiameter * 1.4,
          "top"
        );
      }
      holes.push(
        platedhole(
          i + 1 + params.right + (params.bottom ?? 0) + params.left,
          xoff + i * params.p,
          height / 2,
          innerDiameter,
          outerDiameter
        )
      );
    }
  }
  if (params.bottom) {
    const xoff = -((params.bottom - 1) / 2) * params.p;
    for (let i = 0; i < params.bottom; i++) {
      if (i === 0 && !params.left) {
        silkscreenTriangleRoutes = getTrianglePath(
          xoff + i * params.p,
          -height / 2 - outerDiameter * 1.4,
          "bottom"
        );
      }
      holes.push(
        platedhole(
          i + 1 + params.left,
          xoff + i * params.p,
          -height / 2,
          innerDiameter,
          outerDiameter
        )
      );
    }
  }
  const silkscreenTriangle = {
    type: "pcb_silkscreen_path",
    pcb_silkscreen_path_id: "1",
    pcb_component_id: "1",
    layer: "top",
    route: silkscreenTriangleRoutes,
    stroke_width: 0.1
  };
  const silkscreenPath = {
    type: "pcb_silkscreen_path",
    pcb_silkscreen_path_id: "pcb_silkscreen_path_1",
    pcb_component_id: "1",
    route: [
      {
        x: -params.w / 2 - outerDiameter,
        y: height / 2 + outerDiameter
      },
      {
        x: params.w / 2 + outerDiameter,
        y: height / 2 + outerDiameter
      },
      {
        x: params.w / 2 + outerDiameter,
        y: -height / 2 - outerDiameter
      },
      {
        x: -params.w / 2 - outerDiameter,
        y: -height / 2 - outerDiameter
      },
      {
        x: -params.w / 2 - outerDiameter,
        y: height / 2 + outerDiameter
      }
    ],
    stroke_width: 0.1,
    layer: "top"
  };
  const silkscreenRefText = silkscreenRef(
    0,
    height / 1.7,
    height / 25
  );
  return {
    circuitJson: [
      ...holes,
      silkscreenPath,
      silkscreenRefText,
      silkscreenTriangle
    ],
    parameters: params
  };
};

// src/fn/hc49.ts
import {
  length as length13
} from "circuit-json";
import { z as z20 } from "zod";
var generate_u_curve = (centerX, centerY, radius, direction) => {
  return Array.from({ length: 25 }, (_, i) => {
    const theta = i / 24 * Math.PI - Math.PI / 2;
    return {
      x: centerX + (direction === "right" ? 1 : -1) * Math.cos(theta) * radius,
      y: centerY + Math.sin(theta) * radius
    };
  });
};
var hc49_def = z20.object({
  fn: z20.string(),
  p: length13.optional().default("4.88mm"),
  id: length13.optional().default("0.6mm"),
  od: length13.optional().default("1.2mm"),
  w: length13.optional().default("5.6mm"),
  h: length13.optional().default("3.5mm")
});
var hc49 = (raw_params) => {
  const parameters = hc49_def.parse(raw_params);
  const { p, id, od, w, h } = parameters;
  const radius = h / 2;
  const plated_holes = [
    platedhole(1, -p / 2, 0, id, od),
    platedhole(2, p / 2, 0, id, od)
  ];
  const leftCurve = generate_u_curve(-w / 2, 0, radius, "left");
  const rightCurve = generate_u_curve(w / 2, 0, radius, "right");
  const silkscreenBody = {
    type: "pcb_silkscreen_path",
    layer: "top",
    pcb_component_id: "",
    route: [
      ...leftCurve,
      ...leftCurve.slice(1).reverse(),
      { x: -w / 2, y: -h / 2 },
      { x: w / 2, y: -h / 2 },
      ...rightCurve,
      { x: w / 2, y: h / 2 },
      { x: -w / 2, y: h / 2 }
    ],
    stroke_width: 0.1,
    pcb_silkscreen_path_id: ""
  };
  const silkscreenRefText = silkscreenRef(0, p / 4, 0.5);
  return {
    circuitJson: [
      ...plated_holes,
      silkscreenBody,
      silkscreenRefText
    ],
    parameters
  };
};

// src/fn/pad.ts
import { z as z21 } from "zod";
import { length as length14 } from "circuit-json";
import { mm as mm5 } from "@tscircuit/mm";
var pad_def = z21.object({
  w: length14,
  h: length14
});
var pad = (params) => {
  const { w, h } = params;
  const width = mm5(w);
  const height = mm5(h);
  return {
    circuitJson: [
      rectpad(1, 0, 0, width, height),
      silkscreenRef(0, height / 2 + 0.5, 0.2)
    ],
    parameters: params
  };
};

// src/fn/to92.ts
import { z as z22 } from "zod";
var to92_def = z22.object({
  fn: z22.string(),
  num_pins: z22.union([z22.literal(3), z22.literal(2)]).default(3),
  p: z22.string().default("1.27mm"),
  id: z22.string().default("0.72mm"),
  od: z22.string().default("0.95mm"),
  w: z22.string().default("4.5mm"),
  h: z22.string().default("4.5mm"),
  inline: z22.boolean().default(false),
  string: z22.string().optional()
});
var generateSemicircle = (centerX, centerY, radius) => {
  return Array.from({ length: 25 }, (_, i) => {
    const theta = i / 24 * Math.PI;
    return {
      x: centerX + Math.cos(theta) * radius,
      y: centerY + Math.sin(theta) * radius
    };
  });
};
var to92_2 = (parameters) => {
  const { p, id, od, h } = parameters;
  const holeY = Number.parseFloat(h) / 2;
  const padSpacing = Number.parseFloat(p);
  return [
    platedhole(1, -padSpacing, holeY - padSpacing, id, od),
    platedhole(2, padSpacing, holeY - padSpacing, id, od)
  ];
};
var to92 = (raw_params) => {
  const match = raw_params.string?.match(/^to92_(\d+)/);
  const numPins = match ? Number.parseInt(match[1], 10) : 3;
  const parameters = to92_def.parse({
    ...raw_params,
    num_pins: numPins
  });
  const { p, id, od, w, h, inline } = parameters;
  const holeY = Number.parseFloat(h) / 2;
  const padSpacing = Number.parseFloat(p);
  let platedHoles = [];
  if (parameters.num_pins === 3) {
    platedHoles = inline ? [
      platedhole(1, -padSpacing, holeY - padSpacing, id, od),
      platedhole(2, 0, holeY - padSpacing, id, od),
      platedhole(3, padSpacing, holeY - padSpacing, id, od)
    ] : [
      platedhole(1, 0, holeY, id, od),
      platedhole(2, -padSpacing, holeY - padSpacing, id, od),
      platedhole(3, padSpacing, holeY - padSpacing, id, od)
    ];
  } else if (parameters.num_pins === 2) {
    platedHoles = to92_2(parameters);
  } else {
    throw new Error("Invalid number of pins for TO-92");
  }
  const radius = Number.parseFloat(w) / 2;
  const semicircle = generateSemicircle(0, holeY, radius);
  const silkscreenBody = {
    type: "pcb_silkscreen_path",
    layer: "top",
    pcb_component_id: "",
    route: [
      ...semicircle,
      { x: -radius, y: 0 },
      { x: radius, y: 0 },
      semicircle[0]
    ],
    stroke_width: 0.1,
    pcb_silkscreen_path_id: ""
  };
  const silkscreenRefText = silkscreenRef(0, holeY + 1, 0.5);
  return {
    circuitJson: [
      ...platedHoles,
      silkscreenBody,
      silkscreenRefText
    ],
    parameters
  };
};

// src/fn/sod523.ts
import { z as z23 } from "zod";
import { length as length15 } from "circuit-json";
var sod_def2 = z23.object({
  fn: z23.string(),
  num_pins: z23.literal(2).default(2),
  w: z23.string().default("2.15mm"),
  h: z23.string().default("1.20mm"),
  pl: z23.string().default("0.5mm"),
  pw: z23.string().default("0.6mm"),
  p: z23.string().default("1.4mm")
});
var sod523 = (raw_params) => {
  const parameters = sod_def2.parse(raw_params);
  const silkscreenRefText = silkscreenRef(
    0,
    length15.parse(parameters.h),
    0.3
  );
  const silkscreenLine = {
    type: "pcb_silkscreen_path",
    layer: "top",
    pcb_component_id: "",
    route: [
      {
        x: length15.parse(parameters.p) / 2,
        y: length15.parse(parameters.h) / 2
      },
      {
        x: -length15.parse(parameters.w) / 2 - 0.2,
        y: length15.parse(parameters.h) / 2
      },
      {
        x: -length15.parse(parameters.w) / 2 - 0.2,
        y: -length15.parse(parameters.h) / 2
      },
      {
        x: length15.parse(parameters.p) / 2,
        y: -length15.parse(parameters.h) / 2
      }
    ],
    stroke_width: 0.1,
    pcb_silkscreen_path_id: ""
  };
  return {
    circuitJson: sodWithoutParsing2(parameters).concat(
      silkscreenLine,
      silkscreenRefText
    ),
    parameters
  };
};
var getSodCoords2 = (parameters) => {
  const { pn, p } = parameters;
  if (pn === 1) {
    return { x: -p / 2, y: 0 };
  } else {
    return { x: p / 2, y: 0 };
  }
};
var sodWithoutParsing2 = (parameters) => {
  const pads = [];
  for (let i = 1; i <= parameters.num_pins; i++) {
    const { x, y } = getSodCoords2({
      pn: i,
      p: Number.parseFloat(parameters.p)
    });
    pads.push(
      rectpad(
        i,
        x,
        y,
        Number.parseFloat(parameters.pl),
        Number.parseFloat(parameters.pw)
      )
    );
  }
  return pads;
};

// src/fn/sop8.ts
var sop8_def = extendSoicDef({});
var sop8 = (raw_params) => {
  const parameters = sop8_def.parse(raw_params);
  const pads = [];
  for (let i = 0; i < parameters.num_pins; i++) {
    const { x, y } = getCcwSoicCoords({
      num_pins: parameters.num_pins,
      pn: i + 1,
      w: parameters.w,
      p: parameters.p ?? 1.27,
      pl: parameters.pl,
      widthincludeslegs: true
    });
    pads.push(
      rectpad(i + 1, x, y, parameters.pl ?? "1.5mm", parameters.pw ?? "0.6mm")
    );
  }
  const sh = (parameters.num_pins / 2 - 1) * parameters.p + parameters.pw;
  const silkscreenRefText = silkscreenRef(
    0,
    sh / 2 - 0.5,
    sh / 12
  );
  const silkscreenLine = {
    layer: "top",
    pcb_component_id: "",
    pcb_silkscreen_path_id: "",
    type: "pcb_silkscreen_path",
    route: [
      { x: -parameters.w / 3, y: sh / 2 + 0.2 },
      { x: parameters.w / 3, y: sh / 2 + 0.2 }
    ],
    stroke_width: 0.1
  };
  return {
    circuitJson: [
      ...pads,
      silkscreenRefText,
      silkscreenLine
    ],
    parameters
  };
};

// src/fn/sod80.ts
import { z as z24 } from "zod";
import { length as length16 } from "circuit-json";
var sod80_def = z24.object({
  fn: z24.string(),
  num_pins: z24.literal(2).default(2),
  w: z24.string().default("5.0mm"),
  h: z24.string().default("2.30mm"),
  pl: z24.string().default("1.25mm"),
  pw: z24.string().default("2mm"),
  p: z24.string().default("3.75mm")
});
var sod80 = (raw_params) => {
  const parameters = sod80_def.parse(raw_params);
  const silkscreenRefText = silkscreenRef(
    0,
    length16.parse(parameters.h) / 2 + 1,
    0.3
  );
  const silkscreenLine = {
    type: "pcb_silkscreen_path",
    layer: "top",
    pcb_component_id: "",
    route: [
      {
        x: length16.parse(parameters.p) / 2 + 0.5,
        y: length16.parse(parameters.h) / 2 + 0.5
      },
      {
        x: -length16.parse(parameters.w) / 2 - 0.5,
        y: length16.parse(parameters.h) / 2 + 0.5
      },
      {
        x: -length16.parse(parameters.w) / 2 - 0.5,
        y: -length16.parse(parameters.h) / 2 - 0.5
      },
      {
        x: length16.parse(parameters.p) / 2 + 0.5,
        y: -length16.parse(parameters.h) / 2 - 0.5
      }
    ],
    stroke_width: 0.1,
    pcb_silkscreen_path_id: ""
  };
  return {
    circuitJson: sod80WithoutParsing(parameters).concat(
      silkscreenLine,
      silkscreenRefText
    ),
    parameters
  };
};
var getsod80Coords = (parameters) => {
  const { pn, p } = parameters;
  return pn === 1 ? { x: -p / 2, y: 0 } : { x: p / 2, y: 0 };
};
var sod80WithoutParsing = (parameters) => {
  const pads = [];
  for (let i = 1; i <= parameters.num_pins; i++) {
    const { x, y } = getsod80Coords({
      pn: i,
      p: Number.parseFloat(parameters.p)
    });
    pads.push(
      rectpad(
        i,
        x,
        y,
        Number.parseFloat(parameters.pl),
        Number.parseFloat(parameters.pw)
      )
    );
  }
  return pads;
};

// src/fn/sod123w.ts
import { z as z25 } from "zod";
import { length as length17 } from "circuit-json";
var sod_def3 = z25.object({
  fn: z25.string(),
  num_pins: z25.literal(2).default(2),
  w: z25.string().default("4.4mm"),
  h: z25.string().default("2.1mm"),
  pl: z25.string().default("1.2mm"),
  pw: z25.string().default("1.2mm"),
  p: z25.string().default("2.9mm")
});
var sod123w = (raw_params) => {
  const parameters = sod_def3.parse(raw_params);
  const silkscreenRefText = silkscreenRef(
    0,
    length17.parse(parameters.h) - 0.5,
    0.3
  );
  const silkscreenLine = {
    type: "pcb_silkscreen_path",
    layer: "top",
    pcb_component_id: "",
    route: [
      {
        x: length17.parse(parameters.p) / 2,
        y: length17.parse(parameters.h) / 2
      },
      {
        x: -length17.parse(parameters.w) / 2 - 0.2,
        y: length17.parse(parameters.h) / 2
      },
      {
        x: -length17.parse(parameters.w) / 2 - 0.2,
        y: -length17.parse(parameters.h) / 2
      },
      {
        x: length17.parse(parameters.p) / 2,
        y: -length17.parse(parameters.h) / 2
      }
    ],
    stroke_width: 0.1,
    pcb_silkscreen_path_id: ""
  };
  return {
    circuitJson: sodWithoutParsing3(parameters).concat(
      silkscreenLine,
      silkscreenRefText
    ),
    parameters
  };
};
var getSodCoords3 = (parameters) => {
  const { pn, p } = parameters;
  if (pn === 1) {
    return { x: -p / 2, y: 0 };
  }
  return { x: p / 2, y: 0 };
};
var sodWithoutParsing3 = (parameters) => {
  const pads = [];
  for (let i = 1; i <= parameters.num_pins; i++) {
    const { x, y } = getSodCoords3({
      pn: i,
      p: Number.parseFloat(parameters.p)
    });
    pads.push(
      rectpad(
        i,
        x,
        y,
        Number.parseFloat(parameters.pl),
        Number.parseFloat(parameters.pw)
      )
    );
  }
  return pads;
};

// src/fn/sod323.ts
import { z as z26 } from "zod";
import { length as length18 } from "circuit-json";
var sod_def4 = z26.object({
  fn: z26.string(),
  num_pins: z26.literal(2).default(2),
  w: z26.string().default("3.30mm"),
  h: z26.string().default("1.80mm"),
  pl: z26.string().default("0.60mm"),
  pw: z26.string().default("0.45mm"),
  p: z26.string().default("2.1mm")
});
var sod323 = (raw_params) => {
  const parameters = sod_def4.parse(raw_params);
  const silkscreenRefText = silkscreenRef(
    0,
    length18.parse(parameters.h) - 0.5,
    0.3
  );
  const silkscreenLine = {
    type: "pcb_silkscreen_path",
    layer: "top",
    pcb_component_id: "",
    route: [
      {
        x: length18.parse(parameters.p) / 2,
        y: length18.parse(parameters.h) / 2
      },
      {
        x: -length18.parse(parameters.w) / 2,
        y: length18.parse(parameters.h) / 2
      },
      {
        x: -length18.parse(parameters.w) / 2,
        y: -length18.parse(parameters.h) / 2
      },
      {
        x: length18.parse(parameters.p) / 2,
        y: -length18.parse(parameters.h) / 2
      }
    ],
    stroke_width: 0.1,
    pcb_silkscreen_path_id: ""
  };
  return {
    circuitJson: sodWithoutParsing4(parameters).concat(
      silkscreenLine,
      silkscreenRefText
    ),
    parameters
  };
};
var getSodCoords4 = (parameters) => {
  const { pn, p } = parameters;
  if (pn === 1) {
    return { x: -p / 2, y: 0 };
  }
  return { x: p / 2, y: 0 };
};
var sodWithoutParsing4 = (parameters) => {
  const pads = [];
  for (let i = 1; i <= parameters.num_pins; i++) {
    const { x, y } = getSodCoords4({
      pn: i,
      p: Number.parseFloat(parameters.p)
    });
    pads.push(
      rectpad(
        i,
        x,
        y,
        Number.parseFloat(parameters.pl),
        Number.parseFloat(parameters.pw)
      )
    );
  }
  return pads;
};

// src/fn/sod923.ts
import { z as z27 } from "zod";
import { length as length19 } from "circuit-json";
var sod_def5 = z27.object({
  fn: z27.string(),
  num_pins: z27.literal(2).default(2),
  w: z27.string().default("1.4mm"),
  h: z27.string().default("0.9mm"),
  pl: z27.string().default("0.35mm"),
  pw: z27.string().default("0.25mm"),
  p: z27.string().default("1.2mm")
});
var sod923 = (raw_params) => {
  const parameters = sod_def5.parse(raw_params);
  const silkscreenRefText = silkscreenRef(
    0,
    length19.parse(parameters.h),
    0.3
  );
  const silkscreenLine = {
    type: "pcb_silkscreen_path",
    layer: "top",
    pcb_component_id: "",
    route: [
      {
        x: length19.parse(parameters.p) / 2 + 0.15,
        y: length19.parse(parameters.h) / 2
      },
      {
        x: -length19.parse(parameters.w) / 2 - 0.4,
        y: length19.parse(parameters.h) / 2
      },
      {
        x: -length19.parse(parameters.w) / 2 - 0.4,
        y: -length19.parse(parameters.h) / 2
      },
      {
        x: length19.parse(parameters.p) / 2 + 0.15,
        y: -length19.parse(parameters.h) / 2
      }
    ],
    stroke_width: 0.1,
    pcb_silkscreen_path_id: ""
  };
  return {
    circuitJson: sodWithoutParsing5(parameters).concat(
      silkscreenLine,
      silkscreenRefText
    ),
    parameters
  };
};
var getSodCoords5 = (parameters) => {
  const { pn, p } = parameters;
  if (pn === 1) {
    return { x: -p / 2, y: 0 };
  } else {
    return { x: p / 2, y: 0 };
  }
};
var sodWithoutParsing5 = (parameters) => {
  const pads = [];
  for (let i = 1; i <= parameters.num_pins; i++) {
    const { x, y } = getSodCoords5({
      pn: i,
      p: Number.parseFloat(parameters.p)
    });
    pads.push(
      rectpad(
        i,
        x,
        y,
        Number.parseFloat(parameters.pl),
        Number.parseFloat(parameters.pw)
      )
    );
  }
  return pads;
};

// src/fn/sod882.ts
import { z as z28 } from "zod";
import { length as length20 } from "circuit-json";
var sod_def6 = z28.object({
  fn: z28.string(),
  num_pins: z28.literal(2).default(2),
  w: z28.string().default("1.3mm"),
  h: z28.string().default("0.9mm"),
  pl: z28.string().default("0.4mm"),
  pw: z28.string().default("0.7mm"),
  p: z28.string().default("0.7mm")
});
var sod882 = (raw_params) => {
  const parameters = sod_def6.parse(raw_params);
  const silkscreenRefText = silkscreenRef(
    0,
    length20.parse(parameters.h) + 0.1,
    0.3
  );
  const silkscreenLine = {
    type: "pcb_silkscreen_path",
    layer: "top",
    pcb_component_id: "",
    route: [
      {
        x: length20.parse(parameters.p) / 2 + 0.2,
        y: length20.parse(parameters.h) / 2 + 0.2
      },
      {
        x: -length20.parse(parameters.w) / 2 - 0.2,
        y: length20.parse(parameters.h) / 2 + 0.2
      },
      {
        x: -length20.parse(parameters.w) / 2 - 0.2,
        y: -length20.parse(parameters.h) / 2 - 0.2
      },
      {
        x: length20.parse(parameters.p) / 2 + 0.2,
        y: -length20.parse(parameters.h) / 2 - 0.2
      }
    ],
    stroke_width: 0.1,
    pcb_silkscreen_path_id: ""
  };
  return {
    circuitJson: sodWithoutParsing6(parameters).concat(
      silkscreenLine,
      silkscreenRefText
    ),
    parameters
  };
};
var getSodCoords6 = (parameters) => {
  const { pn, p } = parameters;
  if (pn === 1) {
    return { x: -p / 2, y: 0 };
  } else {
    return { x: p / 2, y: 0 };
  }
};
var sodWithoutParsing6 = (parameters) => {
  const pads = [];
  for (let i = 1; i <= parameters.num_pins; i++) {
    const { x, y } = getSodCoords6({
      pn: i,
      p: Number.parseFloat(parameters.p)
    });
    pads.push(
      rectpad(
        i,
        x,
        y,
        Number.parseFloat(parameters.pl),
        Number.parseFloat(parameters.pw)
      )
    );
  }
  return pads;
};

// src/fn/sod323f.ts
import { z as z29 } from "zod";
import { length as length21 } from "circuit-json";
var sod_def7 = z29.object({
  fn: z29.string(),
  num_pins: z29.literal(2).default(2),
  w: z29.string().default("3,05mm"),
  h: z29.string().default("1.65mm"),
  pl: z29.string().default("0.6mm"),
  pw: z29.string().default("0.6mm"),
  pad_spacing: z29.string().default("2.2mm")
});
var sod323f = (raw_params) => {
  const parameters = sod_def7.parse(raw_params);
  const silkscreenRefText = silkscreenRef(
    0,
    length21.parse(parameters.h),
    0.3
  );
  const silkscreenLine = {
    type: "pcb_silkscreen_path",
    layer: "top",
    pcb_component_id: "",
    route: [
      {
        x: length21.parse(parameters.pad_spacing) / 2,
        y: length21.parse(parameters.h) / 2
      },
      {
        x: -length21.parse(parameters.w) / 2 - 0.2,
        y: length21.parse(parameters.h) / 2
      },
      {
        x: -length21.parse(parameters.w) / 2 - 0.2,
        y: -length21.parse(parameters.h) / 2
      },
      {
        x: length21.parse(parameters.pad_spacing) / 2,
        y: -length21.parse(parameters.h) / 2
      }
    ],
    stroke_width: 0.1,
    pcb_silkscreen_path_id: ""
  };
  return {
    circuitJson: sodWithoutParsing7(parameters).concat(
      silkscreenLine,
      silkscreenRefText
    ),
    parameters
  };
};
var getSodCoords7 = (parameters) => {
  const { pn, pad_spacing } = parameters;
  if (pn === 1) {
    return { x: -pad_spacing / 2, y: 0 };
  } else {
    return { x: pad_spacing / 2, y: 0 };
  }
};
var sodWithoutParsing7 = (parameters) => {
  const pads = [];
  for (let i = 1; i <= parameters.num_pins; i++) {
    const { x, y } = getSodCoords7({
      pn: i,
      pad_spacing: Number.parseFloat(parameters.pad_spacing)
    });
    pads.push(
      rectpad(
        i,
        x,
        y,
        Number.parseFloat(parameters.pl),
        Number.parseFloat(parameters.pw)
      )
    );
  }
  return pads;
};

// src/fn/sod123f.ts
import { z as z30 } from "zod";
import { length as length22 } from "circuit-json";
var sod_def8 = z30.object({
  fn: z30.string(),
  num_pins: z30.literal(2).default(2),
  w: z30.string().default("4.4mm"),
  h: z30.string().default("2.1mm"),
  pl: z30.string().default("1.2mm"),
  pw: z30.string().default("1.2mm"),
  p: z30.string().default("2.9mm")
});
var sod123f = (raw_params) => {
  const parameters = sod_def8.parse(raw_params);
  const silkscreenRefText = silkscreenRef(
    0,
    length22.parse(parameters.h),
    0.3
  );
  const silkscreenLine = {
    type: "pcb_silkscreen_path",
    layer: "top",
    pcb_component_id: "",
    route: [
      {
        x: length22.parse(parameters.p) / 2,
        y: length22.parse(parameters.h) / 2
      },
      {
        x: -length22.parse(parameters.w) / 2 - 0.2,
        y: length22.parse(parameters.h) / 2
      },
      {
        x: -length22.parse(parameters.w) / 2 - 0.2,
        y: -length22.parse(parameters.h) / 2
      },
      {
        x: length22.parse(parameters.p) / 2,
        y: -length22.parse(parameters.h) / 2
      }
    ],
    stroke_width: 0.1,
    pcb_silkscreen_path_id: ""
  };
  return {
    circuitJson: sodWithoutParsing8(parameters).concat(
      silkscreenLine,
      silkscreenRefText
    ),
    parameters
  };
};
var getSodCoords8 = (parameters) => {
  const { pn, p } = parameters;
  if (pn === 1) {
    return { x: -p / 2, y: 0 };
  } else {
    return { x: p / 2, y: 0 };
  }
};
var sodWithoutParsing8 = (parameters) => {
  const pads = [];
  for (let i = 1; i <= parameters.num_pins; i++) {
    const { x, y } = getSodCoords8({
      pn: i,
      p: Number.parseFloat(parameters.p)
    });
    pads.push(
      rectpad(
        i,
        x,
        y,
        Number.parseFloat(parameters.pl),
        Number.parseFloat(parameters.pw)
      )
    );
  }
  return pads;
};

// src/fn/sod123fl.ts
import { z as z31 } from "zod";
import { length as length23 } from "circuit-json";
var sod123FL_def = z31.object({
  fn: z31.string(),
  num_pins: z31.literal(2).default(2),
  w: z31.string().default("4.4mm"),
  h: z31.string().default("2.1mm"),
  pl: z31.string().default("0.91mm"),
  pw: z31.string().default("1.22mm"),
  p: z31.string().default("3.146mm")
});
var sod123fl = (raw_params) => {
  const parameters = sod123FL_def.parse(raw_params);
  const silkscreenRefText = silkscreenRef(
    0,
    length23.parse(parameters.h),
    0.3
  );
  const silkscreenLine = {
    type: "pcb_silkscreen_path",
    layer: "top",
    pcb_component_id: "",
    route: [
      {
        x: length23.parse(parameters.p) / 2,
        y: length23.parse(parameters.h) / 2
      },
      {
        x: -length23.parse(parameters.w) / 2 - 0.2,
        y: length23.parse(parameters.h) / 2
      },
      {
        x: -length23.parse(parameters.w) / 2 - 0.2,
        y: -length23.parse(parameters.h) / 2
      },
      {
        x: length23.parse(parameters.p) / 2,
        y: -length23.parse(parameters.h) / 2
      }
    ],
    stroke_width: 0.1,
    pcb_silkscreen_path_id: ""
  };
  return {
    circuitJson: sodWithoutParsing9(parameters).concat(
      silkscreenLine,
      silkscreenRefText
    ),
    parameters
  };
};
var getSodCoords9 = (parameters) => {
  const { pn, p } = parameters;
  if (pn === 1) {
    return { x: -p / 2, y: 0 };
  } else {
    return { x: p / 2, y: 0 };
  }
};
var sodWithoutParsing9 = (parameters) => {
  const pads = [];
  for (let i = 1; i <= parameters.num_pins; i++) {
    const { x, y } = getSodCoords9({
      pn: i,
      p: Number.parseFloat(parameters.p)
    });
    pads.push(
      rectpad(
        i,
        x,
        y,
        Number.parseFloat(parameters.pl),
        Number.parseFloat(parameters.pw)
      )
    );
  }
  return pads;
};

// src/fn/sod723.ts
import { z as z32 } from "zod";
import { length as length24 } from "circuit-json";
var sod_def9 = z32.object({
  fn: z32.string(),
  num_pins: z32.literal(2).default(2),
  w: z32.string().default("1.80mm"),
  h: z32.string().default("1.00mm"),
  pl: z32.string().default("0.66mm"),
  pw: z32.string().default("0.5mm"),
  p: z32.string().default("0.8mm")
});
var sod723 = (raw_params) => {
  const parameters = sod_def9.parse(raw_params);
  const silkscreenRefText = silkscreenRef(
    0,
    length24.parse(parameters.h),
    0.3
  );
  const silkscreenLine = {
    type: "pcb_silkscreen_path",
    layer: "top",
    pcb_component_id: "",
    route: [
      {
        x: length24.parse(parameters.p) / 2,
        y: length24.parse(parameters.h) / 2
      },
      {
        x: -length24.parse(parameters.w) / 2 - 0.1,
        y: length24.parse(parameters.h) / 2
      },
      {
        x: -length24.parse(parameters.w) / 2 - 0.1,
        y: -length24.parse(parameters.h) / 2
      },
      {
        x: length24.parse(parameters.p) / 2,
        y: -length24.parse(parameters.h) / 2
      }
    ],
    stroke_width: 0.1,
    pcb_silkscreen_path_id: ""
  };
  return {
    circuitJson: sodWithoutParsing10(parameters).concat(
      silkscreenLine,
      silkscreenRefText
    ),
    parameters
  };
};
var getSodCoords10 = (parameters) => {
  const { pn, p } = parameters;
  if (pn === 1) {
    return { x: -p / 2, y: 0 };
  } else {
    return { x: p / 2, y: 0 };
  }
};
var sodWithoutParsing10 = (parameters) => {
  const pads = [];
  for (let i = 1; i <= parameters.num_pins; i++) {
    const { x, y } = getSodCoords10({
      pn: i,
      p: Number.parseFloat(parameters.p)
    });
    pads.push(
      rectpad(
        i,
        x,
        y,
        Number.parseFloat(parameters.pl),
        Number.parseFloat(parameters.pw)
      )
    );
  }
  return pads;
};

// src/fn/sod128.ts
import { z as z33 } from "zod";
import { length as length25 } from "circuit-json";
var sod_def10 = z33.object({
  fn: z33.string(),
  num_pins: z33.literal(2).default(2),
  w: z33.string().default("6.2mm"),
  h: z33.string().default("3.4mm"),
  pl: z33.string().default("1.4mm"),
  pw: z33.string().default("2.1mm"),
  p: z33.string().default("4.4mm")
});
var sod128 = (raw_params) => {
  const parameters = sod_def10.parse(raw_params);
  const silkscreenRefText = silkscreenRef(
    0,
    length25.parse(parameters.h) / 2 + 0.4,
    0.3
  );
  const silkscreenLine = {
    type: "pcb_silkscreen_path",
    layer: "top",
    pcb_component_id: "",
    route: [
      {
        x: length25.parse(parameters.p) / 2,
        y: length25.parse(parameters.h) / 2
      },
      {
        x: -length25.parse(parameters.w) / 2 - 0.2,
        y: length25.parse(parameters.h) / 2
      },
      {
        x: -length25.parse(parameters.w) / 2 - 0.2,
        y: -length25.parse(parameters.h) / 2
      },
      {
        x: length25.parse(parameters.p) / 2,
        y: -length25.parse(parameters.h) / 2
      }
    ],
    stroke_width: 0.1,
    pcb_silkscreen_path_id: ""
  };
  return {
    circuitJson: sodWithoutParsing11(parameters).concat(
      silkscreenLine,
      silkscreenRefText
    ),
    parameters
  };
};
var getSodCoords11 = (parameters) => {
  const { pn, p } = parameters;
  if (pn === 1) {
    return { x: -p / 2, y: 0 };
  } else {
    return { x: p / 2, y: 0 };
  }
};
var sodWithoutParsing11 = (parameters) => {
  const pads = [];
  for (let i = 1; i <= parameters.num_pins; i++) {
    const { x, y } = getSodCoords11({
      pn: i,
      p: Number.parseFloat(parameters.p)
    });
    pads.push(
      rectpad(
        i,
        x,
        y,
        Number.parseFloat(parameters.pl),
        Number.parseFloat(parameters.pw)
      )
    );
  }
  return pads;
};

// src/fn/sot89.ts
import { z as z34 } from "zod";
var sot89_def = z34.object({
  fn: z34.string(),
  num_pins: z34.union([z34.literal(3), z34.literal(5)]).default(3),
  w: z34.string().default("4.80mm"),
  h: z34.string().default("4.80mm"),
  pl: z34.string().default("1.3mm"),
  pw: z34.string().default("0.9mm"),
  p: z34.string().default("1.5mm"),
  string: z34.string().optional()
});
var sot89_3 = (parameters) => {
  const pads = [];
  const padGap = Number.parseFloat(parameters.p);
  const padWidth = Number.parseFloat(parameters.pw);
  const length47 = Number.parseFloat(parameters.w);
  const padHeight = Number.parseFloat(parameters.pl);
  pads.push(
    rectpad(1, -length47 / 2, padGap, padHeight, padWidth),
    rectpad(2, -length47 / 2 + (1.5 - 1.3) / 2, 0, 1.5, padWidth),
    rectpad(3, -length47 / 2, -padGap, padHeight, padWidth)
  );
  const silkscreenRefText = silkscreenRef(0, 0, 0.3);
  const width = Number.parseFloat(parameters.w) / 2 - 1;
  const height = Number.parseFloat(parameters.h) / 2;
  const silkscreenPath1 = {
    layer: "top",
    pcb_component_id: "",
    pcb_silkscreen_path_id: "silkscreen_path_1",
    route: [
      { x: -width, y: height },
      { x: width, y: height },
      { x: width, y: height / 2 + 0.5 }
    ],
    type: "pcb_silkscreen_path",
    stroke_width: 0.1
  };
  const silkscreenPath2 = {
    layer: "top",
    pcb_component_id: "",
    pcb_silkscreen_path_id: "silkscreen_path_2",
    route: [
      { x: -width, y: -height },
      { x: width, y: -height },
      { x: width, y: -height / 2 - 0.5 }
    ],
    type: "pcb_silkscreen_path",
    stroke_width: 0.1
  };
  return [
    ...pads,
    silkscreenPath1,
    silkscreenPath2,
    silkscreenRefText
  ];
};
var sot89_5 = (parameters) => {
  const pads = [];
  const padGap = Number.parseFloat(parameters.p);
  const padWidth = Number.parseFloat(parameters.pw);
  const length47 = Number.parseFloat(parameters.w);
  pads.push(
    rectpad(1, -1.85, -1.5, 1.5, 0.7),
    rectpad(2, -1.85, 1.5, 1.5, 0.7),
    rectpad(3, 0, 0, 0.8, 2),
    rectpad(4, 1.85, -1.5, 1.5, 0.7),
    rectpad(5, 1.85, 1.5, 1.5, 0.7)
  );
  const silkscreenRefText = silkscreenRef(
    0,
    Number.parseFloat(parameters.h) / 2 + 0.5,
    0.3
  );
  const width = Number.parseFloat(parameters.w) / 2 - 1;
  const height = Number.parseFloat(parameters.h) / 2;
  const silkscreenPath1 = {
    layer: "top",
    pcb_component_id: "",
    pcb_silkscreen_path_id: "silkscreen_path_1",
    route: [
      { x: -width, y: height },
      { x: width, y: height }
    ],
    type: "pcb_silkscreen_path",
    stroke_width: 0.1
  };
  const silkscreenPath2 = {
    layer: "top",
    pcb_component_id: "",
    pcb_silkscreen_path_id: "silkscreen_path_2",
    route: [
      { x: -width, y: -height },
      { x: width, y: -height }
    ],
    type: "pcb_silkscreen_path",
    stroke_width: 0.1
  };
  return [
    ...pads,
    silkscreenPath1,
    silkscreenPath2,
    silkscreenRefText
  ];
};
var sot89 = (raw_params) => {
  const match = raw_params.string?.match(/^sot89_(\d+)/);
  const numPins = match ? Number.parseInt(match[1], 10) : 3;
  const parameters = sot89_def.parse({
    ...raw_params,
    num_pins: numPins
  });
  if (parameters.num_pins === 3) {
    return {
      circuitJson: sot89_3(parameters),
      parameters
    };
  }
  if (parameters.num_pins === 5) {
    return {
      circuitJson: sot89_5(parameters),
      parameters
    };
  }
  throw new Error("Invalid number of pins for SOT89");
};

// src/fn/to220.ts
import {
  length as length26
} from "circuit-json";
import { z as z35 } from "zod";
var to220_def = z35.object({
  fn: z35.string(),
  p: length26.optional().default("5.0mm"),
  id: length26.optional().default("1.0mm"),
  od: length26.optional().default("1.9mm"),
  w: length26.optional().default("13mm"),
  h: length26.optional().default("7mm"),
  num_pins: z35.number().optional(),
  string: z35.string().optional()
});
var to220 = (raw_params) => {
  const parameters = to220_def.parse(raw_params);
  const { fn, id, od, w, h, string: string3 } = parameters;
  const numPins = Number.parseInt(string3?.split("_")[1] ?? "3");
  const holeY = -1;
  const halfWidth = w / 2;
  const halfHeight = h / 2;
  const minPitch = 2.5;
  const maxHoleWidth = w * 0.4;
  const computedPitch = Math.max(minPitch, maxHoleWidth / (numPins - 1));
  const plated_holes = Array.from({ length: numPins }, (_, i) => {
    const x = numPins % 2 === 0 ? (i - numPins / 2 + 0.5) * computedPitch : (i - Math.floor(numPins / 2)) * computedPitch;
    return platedhole(i + 1, x, holeY, id, od);
  });
  const silkscreenBody = {
    type: "pcb_silkscreen_path",
    layer: "top",
    pcb_component_id: "",
    route: [
      { x: -halfWidth, y: -halfHeight },
      { x: halfWidth, y: -halfHeight },
      { x: halfWidth, y: halfHeight },
      { x: -halfWidth, y: halfHeight },
      { x: -halfWidth, y: -halfHeight }
    ],
    stroke_width: 0.1,
    pcb_silkscreen_path_id: ""
  };
  const yLine = -halfHeight + 2 * h / 3;
  const horizontalLine = {
    type: "pcb_silkscreen_path",
    layer: "top",
    pcb_component_id: "",
    route: [
      { x: -halfWidth, y: yLine },
      { x: halfWidth, y: yLine }
    ],
    stroke_width: 0.1,
    pcb_silkscreen_path_id: ""
  };
  const verticalLines = [
    {
      type: "pcb_silkscreen_path",
      layer: "top",
      pcb_component_id: "",
      route: [
        { x: -w / 6, y: yLine },
        { x: -w / 6, y: halfHeight }
      ],
      stroke_width: 0.1,
      pcb_silkscreen_path_id: ""
    },
    {
      type: "pcb_silkscreen_path",
      layer: "top",
      pcb_component_id: "",
      route: [
        { x: w / 6, y: yLine },
        { x: w / 6, y: halfHeight }
      ],
      stroke_width: 0.1,
      pcb_silkscreen_path_id: ""
    }
  ];
  const silkscreenRefText = silkscreenRef(0, h / 2 + 0.6, 0.5);
  return {
    circuitJson: [
      ...plated_holes,
      silkscreenBody,
      horizontalLine,
      ...verticalLines,
      silkscreenRefText
    ],
    parameters: { ...parameters, p: computedPitch }
  };
};

// src/fn/minimelf.ts
import { z as z36 } from "zod";
import { length as length27 } from "circuit-json";
var minimelf_def = z36.object({
  fn: z36.string(),
  num_pins: z36.literal(2).default(2),
  w: z36.string().default("5.40mm"),
  h: z36.string().default("2.30mm"),
  pl: z36.string().default("1.30mm"),
  pw: z36.string().default("1.70mm"),
  p: z36.string().default("3.5mm")
});
var minimelf = (raw_params) => {
  const parameters = minimelf_def.parse(raw_params);
  const silkscreenRefText = silkscreenRef(
    0,
    length27.parse(parameters.h) / 2 + 0.4,
    0.3
  );
  const silkscreenLine = {
    type: "pcb_silkscreen_path",
    layer: "top",
    pcb_component_id: "",
    route: [
      {
        x: length27.parse(parameters.p) / 2,
        y: length27.parse(parameters.h) / 2
      },
      {
        x: -length27.parse(parameters.w) / 2,
        y: length27.parse(parameters.h) / 2
      },
      {
        x: -length27.parse(parameters.w) / 2,
        y: -length27.parse(parameters.h) / 2
      },
      {
        x: length27.parse(parameters.p) / 2,
        y: -length27.parse(parameters.h) / 2
      }
    ],
    stroke_width: 0.1,
    pcb_silkscreen_path_id: ""
  };
  return {
    circuitJson: miniMelfWithoutParsing(parameters).concat(
      silkscreenLine,
      silkscreenRefText
    ),
    parameters
  };
};
var getMiniMelfCoords = (parameters) => {
  const { pn, p } = parameters;
  return pn === 1 ? { x: -p / 2, y: 0 } : { x: p / 2, y: 0 };
};
var miniMelfWithoutParsing = (parameters) => {
  const pads = [];
  for (let i = 1; i <= parameters.num_pins; i++) {
    const { x, y } = getMiniMelfCoords({
      pn: i,
      p: Number.parseFloat(parameters.p)
    });
    pads.push(
      rectpad(
        i,
        x,
        y,
        Number.parseFloat(parameters.pl),
        Number.parseFloat(parameters.pw)
      )
    );
  }
  return pads;
};

// src/fn/sod882d.ts
import { z as z37 } from "zod";
import { length as length28 } from "circuit-json";
var sod_def11 = z37.object({
  fn: z37.string(),
  num_pins: z37.literal(2).default(2),
  w: z37.string().default("1.90mm"),
  h: z37.string().default("1.33mm"),
  pl: z37.string().default("0.5mm"),
  pw: z37.string().default("0.7mm"),
  p: z37.string().default("0.8mm")
});
var sod882d = (raw_params) => {
  const parameters = sod_def11.parse(raw_params);
  const silkscreenRefText = silkscreenRef(
    0,
    length28.parse(parameters.h) + 0.1,
    0.3
  );
  const silkscreenLine = {
    type: "pcb_silkscreen_path",
    layer: "top",
    pcb_component_id: "",
    route: [
      {
        x: length28.parse(parameters.p) / 2 + 0.1,
        y: length28.parse(parameters.h) / 2
      },
      {
        x: -length28.parse(parameters.w) / 2,
        y: length28.parse(parameters.h) / 2
      },
      {
        x: -length28.parse(parameters.w) / 2,
        y: -length28.parse(parameters.h) / 2
      },
      {
        x: length28.parse(parameters.p) / 2 + 0.1,
        y: -length28.parse(parameters.h) / 2
      }
    ],
    stroke_width: 0.1,
    pcb_silkscreen_path_id: ""
  };
  return {
    circuitJson: sodWithoutParsing12(parameters).concat(
      silkscreenLine,
      silkscreenRefText
    ),
    parameters
  };
};
var getSodCoords12 = (parameters) => {
  const { pn, p } = parameters;
  if (pn === 1) {
    return { x: -p / 2, y: 0 };
  } else {
    return { x: p / 2, y: 0 };
  }
};
var sodWithoutParsing12 = (parameters) => {
  const pads = [];
  for (let i = 1; i <= parameters.num_pins; i++) {
    const { x, y } = getSodCoords12({
      pn: i,
      p: Number.parseFloat(parameters.p)
    });
    pads.push(
      rectpad(
        i,
        x,
        y,
        Number.parseFloat(parameters.pl),
        Number.parseFloat(parameters.pw)
      )
    );
  }
  return pads;
};

// src/fn/melf.ts
import { z as z38 } from "zod";
import { length as length29 } from "circuit-json";
var melf_def = z38.object({
  fn: z38.string(),
  num_pins: z38.literal(2).default(2),
  w: z38.string().default("7.0mm"),
  h: z38.string().default("3.35mm"),
  pl: z38.string().default("1.50mm"),
  pw: z38.string().default("2.70mm"),
  p: z38.string().default("4.8mm")
});
var melf = (raw_params) => {
  const parameters = melf_def.parse(raw_params);
  const silkscreenRefText = silkscreenRef(
    0,
    length29.parse(parameters.h),
    0.3
  );
  const silkscreenLine = {
    type: "pcb_silkscreen_path",
    layer: "top",
    pcb_component_id: "",
    route: [
      {
        x: length29.parse(parameters.p) / 2,
        y: length29.parse(parameters.h) / 2
      },
      {
        x: -length29.parse(parameters.w) / 2,
        y: length29.parse(parameters.h) / 2
      },
      {
        x: -length29.parse(parameters.w) / 2,
        y: -length29.parse(parameters.h) / 2
      },
      {
        x: length29.parse(parameters.p) / 2,
        y: -length29.parse(parameters.h) / 2
      }
    ],
    stroke_width: 0.1,
    pcb_silkscreen_path_id: ""
  };
  return {
    circuitJson: melfWithoutParsing(parameters).concat(
      silkscreenLine,
      silkscreenRefText
    ),
    parameters
  };
};
var getMelfCoords = (parameters) => {
  const { pn, p } = parameters;
  if (pn === 1) {
    return { x: -p / 2, y: 0 };
  } else {
    return { x: p / 2, y: 0 };
  }
};
var melfWithoutParsing = (parameters) => {
  const pads = [];
  for (let i = 1; i <= parameters.num_pins; i++) {
    const { x, y } = getMelfCoords({
      pn: i,
      p: Number.parseFloat(parameters.p)
    });
    pads.push(
      rectpad(
        i,
        x,
        y,
        Number.parseFloat(parameters.pl),
        Number.parseFloat(parameters.pw)
      )
    );
  }
  return pads;
};

// src/fn/micromelf.ts
import { z as z39 } from "zod";
import { length as length30 } from "circuit-json";
var micromelf_def = z39.object({
  fn: z39.string(),
  num_pins: z39.literal(2).default(2),
  w: z39.string().default("3.0mm"),
  h: z39.string().default("1.80mm"),
  pl: z39.string().default("0.80mm"),
  pw: z39.string().default("1.20mm"),
  p: z39.string().default("1.6mm")
});
var micromelf = (raw_params) => {
  const parameters = micromelf_def.parse(raw_params);
  const silkscreenRefText = silkscreenRef(
    0,
    length30.parse(parameters.h),
    0.3
  );
  const silkscreenLine = {
    type: "pcb_silkscreen_path",
    layer: "top",
    pcb_component_id: "",
    route: [
      {
        x: length30.parse(parameters.p) / 2,
        y: length30.parse(parameters.h) / 2
      },
      {
        x: -length30.parse(parameters.w) / 2 - 0.1,
        y: length30.parse(parameters.h) / 2
      },
      {
        x: -length30.parse(parameters.w) / 2 - 0.1,
        y: -length30.parse(parameters.h) / 2
      },
      {
        x: length30.parse(parameters.p) / 2,
        y: -length30.parse(parameters.h) / 2
      }
    ],
    stroke_width: 0.1,
    pcb_silkscreen_path_id: ""
  };
  return {
    circuitJson: microMelfWithoutParsing(parameters).concat(
      silkscreenLine,
      silkscreenRefText
    ),
    parameters
  };
};
var getMicroMelfCoords = (parameters) => {
  const { pn, p } = parameters;
  if (pn === 1) {
    return { x: -p / 2, y: 0 };
  } else {
    return { x: p / 2, y: 0 };
  }
};
var microMelfWithoutParsing = (parameters) => {
  const pads = [];
  for (let i = 1; i <= parameters.num_pins; i++) {
    const { x, y } = getMicroMelfCoords({
      pn: i,
      p: Number.parseFloat(parameters.p)
    });
    pads.push(
      rectpad(
        i,
        x,
        y,
        Number.parseFloat(parameters.pl),
        Number.parseFloat(parameters.pw)
      )
    );
  }
  return pads;
};

// src/fn/sma.ts
import { z as z40 } from "zod";
import { length as length31 } from "circuit-json";
var sma_def = z40.object({
  fn: z40.string(),
  num_pins: z40.literal(2).default(2),
  w: z40.string().default("7.10mm"),
  h: z40.string().default("3.40mm"),
  pl: z40.string().default("2.45mm"),
  pw: z40.string().default("1.80mm"),
  p: z40.string().default("4.05mm")
});
var sma = (raw_params) => {
  const parameters = sma_def.parse(raw_params);
  const silkscreenRefText = silkscreenRef(
    0,
    length31.parse(parameters.h) / 2 + 0.5,
    0.3
  );
  const silkscreenLine = {
    type: "pcb_silkscreen_path",
    layer: "top",
    pcb_component_id: "",
    route: [
      {
        x: length31.parse(parameters.p) / 2,
        y: length31.parse(parameters.h) / 2
      },
      {
        x: -length31.parse(parameters.w) / 2 - 0.5,
        y: length31.parse(parameters.h) / 2
      },
      {
        x: -length31.parse(parameters.w) / 2 - 0.5,
        y: -length31.parse(parameters.h) / 2
      },
      {
        x: length31.parse(parameters.p) / 2,
        y: -length31.parse(parameters.h) / 2
      }
    ],
    stroke_width: 0.1,
    pcb_silkscreen_path_id: ""
  };
  return {
    circuitJson: smaWithoutParsing(parameters).concat(
      silkscreenLine,
      silkscreenRefText
    ),
    parameters
  };
};
var getSmaCoords = (parameters) => {
  const { pn, p } = parameters;
  if (pn === 1) {
    return { x: -p / 2, y: 0 };
  }
  return { x: p / 2, y: 0 };
};
var smaWithoutParsing = (parameters) => {
  const pads = [];
  for (let i = 1; i <= parameters.num_pins; i++) {
    const { x, y } = getSmaCoords({
      pn: i,
      p: Number.parseFloat(parameters.p)
    });
    pads.push(
      rectpad(
        i,
        x,
        y,
        Number.parseFloat(parameters.pl),
        Number.parseFloat(parameters.pw)
      )
    );
  }
  return pads;
};

// src/fn/smf.ts
import { z as z41 } from "zod";
import { length as length32 } from "circuit-json";
var smf_def = z41.object({
  fn: z41.string(),
  num_pins: z41.literal(2).default(2),
  w: z41.string().default("4.80mm"),
  h: z41.string().default("2.10mm"),
  pl: z41.string().default("1.30mm"),
  pw: z41.string().default("1.40mm"),
  p: z41.string().default("2.9mm")
});
var smf = (raw_params) => {
  const parameters = smf_def.parse(raw_params);
  const silkscreenRefText = silkscreenRef(
    0,
    length32.parse(parameters.h) - 0.5,
    0.3
  );
  const silkscreenLine = {
    type: "pcb_silkscreen_path",
    layer: "top",
    pcb_component_id: "",
    route: [
      {
        x: length32.parse(parameters.p) / 2,
        y: length32.parse(parameters.h) / 2
      },
      {
        x: -length32.parse(parameters.w) / 2,
        y: length32.parse(parameters.h) / 2
      },
      {
        x: -length32.parse(parameters.w) / 2,
        y: -length32.parse(parameters.h) / 2
      },
      {
        x: length32.parse(parameters.p) / 2,
        y: -length32.parse(parameters.h) / 2
      }
    ],
    stroke_width: 0.1,
    pcb_silkscreen_path_id: ""
  };
  return {
    circuitJson: smfWithoutParsing(parameters).concat(
      silkscreenLine,
      silkscreenRefText
    ),
    parameters
  };
};
var getSmfCoords = (parameters) => {
  const { pn, p } = parameters;
  if (pn === 1) {
    return { x: -p / 2, y: 0 };
  } else {
    return { x: p / 2, y: 0 };
  }
};
var smfWithoutParsing = (parameters) => {
  const pads = [];
  for (let i = 1; i <= parameters.num_pins; i++) {
    const { x, y } = getSmfCoords({
      pn: i,
      p: Number.parseFloat(parameters.p)
    });
    pads.push(
      rectpad(
        i,
        x,
        y,
        Number.parseFloat(parameters.pl),
        Number.parseFloat(parameters.pw)
      )
    );
  }
  return pads;
};

// src/fn/smb.ts
import { z as z42 } from "zod";
import { length as length33 } from "circuit-json";
var smb_def = z42.object({
  fn: z42.string(),
  num_pins: z42.literal(2).default(2),
  w: z42.string().default("7.30mm"),
  h: z42.string().default("4.40mm"),
  pl: z42.string().default("2.50mm"),
  pw: z42.string().default("2.30mm"),
  p: z42.string().default("4.30mm")
});
var smb = (raw_params) => {
  const parameters = smb_def.parse(raw_params);
  const silkscreenRefText = silkscreenRef(
    0,
    length33.parse(parameters.h) / 2 + 0.5,
    0.3
  );
  const silkscreenLine = {
    type: "pcb_silkscreen_path",
    layer: "top",
    pcb_component_id: "",
    route: [
      {
        x: length33.parse(parameters.p) / 2,
        y: length33.parse(parameters.h) / 2
      },
      {
        x: -length33.parse(parameters.w) / 2 - 0.1,
        y: length33.parse(parameters.h) / 2
      },
      {
        x: -length33.parse(parameters.w) / 2 - 0.1,
        y: -length33.parse(parameters.h) / 2
      },
      {
        x: length33.parse(parameters.p) / 2,
        y: -length33.parse(parameters.h) / 2
      }
    ],
    stroke_width: 0.1,
    pcb_silkscreen_path_id: ""
  };
  return {
    circuitJson: smbWithoutParsing(parameters).concat(
      silkscreenLine,
      silkscreenRefText
    ),
    parameters
  };
};
var getSmbCoords = (parameters) => {
  const { pn, p } = parameters;
  if (pn === 1) {
    return { x: -p / 2, y: 0 };
  } else {
    return { x: p / 2, y: 0 };
  }
};
var smbWithoutParsing = (parameters) => {
  const pads = [];
  for (let i = 1; i <= parameters.num_pins; i++) {
    const { x, y } = getSmbCoords({
      pn: i,
      p: Number.parseFloat(parameters.p)
    });
    pads.push(
      rectpad(
        i,
        x,
        y,
        Number.parseFloat(parameters.pl),
        Number.parseFloat(parameters.pw)
      )
    );
  }
  return pads;
};

// src/fn/smc.ts
import { z as z43 } from "zod";
import { length as length34 } from "circuit-json";
var smc_def = z43.object({
  fn: z43.string(),
  num_pins: z43.literal(2).default(2),
  w: z43.string().default("10.70mm"),
  h: z43.string().default("6.60mm"),
  pl: z43.string().default("3.30mm"),
  pw: z43.string().default("2.50mm"),
  p: z43.string().default("6.80mm")
});
var smc = (raw_params) => {
  const parameters = smc_def.parse(raw_params);
  const silkscreenRefText = silkscreenRef(0, 3, 0.3);
  const silkscreenLine = {
    type: "pcb_silkscreen_path",
    layer: "top",
    pcb_component_id: "",
    route: [
      {
        x: length34.parse(parameters.p) / 2,
        y: length34.parse(parameters.h) / 2 - 0.8
      },
      {
        x: -length34.parse(parameters.w) / 2 - 0.8,
        y: length34.parse(parameters.h) / 2 - 0.8
      },
      {
        x: -length34.parse(parameters.w) / 2 - 0.8,
        y: -length34.parse(parameters.h) / 2 + 0.8
      },
      {
        x: length34.parse(parameters.p) / 2,
        y: -length34.parse(parameters.h) / 2 + 0.8
      }
    ],
    stroke_width: 0.1,
    pcb_silkscreen_path_id: ""
  };
  return {
    circuitJson: smcWithoutParsing(parameters).concat(
      silkscreenLine,
      silkscreenRefText
    ),
    parameters
  };
};
var getSmcCoords = (parameters) => {
  const { pn, p } = parameters;
  if (pn === 1) {
    return { x: -p / 2, y: 0 };
  }
  return { x: p / 2, y: 0 };
};
var smcWithoutParsing = (parameters) => {
  const pads = [];
  for (let i = 1; i <= parameters.num_pins; i++) {
    const { x, y } = getSmcCoords({
      pn: i,
      p: Number.parseFloat(parameters.p)
    });
    pads.push(
      rectpad(
        i,
        x,
        y,
        Number.parseFloat(parameters.pl),
        Number.parseFloat(parameters.pw)
      )
    );
  }
  return pads;
};

// src/fn/sot223.ts
import { z as z44 } from "zod";
var sot223_def = z44.object({
  fn: z44.string(),
  num_pins: z44.number().default(4),
  w: z44.string().default("8.50mm"),
  h: z44.string().default("6.90mm"),
  pl: z44.string().default("2mm"),
  pw: z44.string().default("1.5mm"),
  p: z44.string().default("2.30mm"),
  string: z44.string().optional()
});
var sot223 = (raw_params) => {
  const match = raw_params.string?.match(/^sot223_(\d+)/);
  const numPins = match ? Number.parseInt(match[1], 10) : 4;
  if (numPins === 8) {
    const parameters2 = sot223_8_def.parse({
      ...raw_params,
      num_pins: numPins
    });
    return {
      circuitJson: soicWithoutParsing(parameters2),
      parameters: parameters2
    };
  }
  const parameters = sot223_def.parse({
    ...raw_params,
    num_pins: numPins
  });
  if (parameters.num_pins === 4) {
    return {
      circuitJson: sot223_4(parameters),
      parameters
    };
  }
  if (parameters.num_pins === 5) {
    return {
      circuitJson: sot223_5(parameters),
      parameters
    };
  }
  if (parameters.num_pins === 6) {
    return {
      circuitJson: sot223_6(parameters),
      parameters
    };
  }
  throw new Error("Invalid number of pins");
};
var get2CcwSot223Coords = (parameters) => {
  const { pn, w, h, pl, p } = parameters;
  if (pn === 1) {
    return { x: -w / 2 + 1.1, y: p };
  }
  if (pn === 2) {
    return { x: -w / 2 + 1.1, y: 0 };
  }
  if (pn === 3) {
    return { x: -w / 2 + 1.1, y: -p };
  }
  return { x: w / 2 - 1.1, y: 0 };
};
var sot223_4 = (parameters) => {
  const pads = [];
  for (let i = 0; i < parameters.num_pins; i++) {
    const { x, y } = get2CcwSot223Coords({
      num_pins: parameters.num_pins,
      pn: i + 1,
      w: Number.parseFloat(parameters.w),
      h: Number.parseFloat(parameters.h),
      pl: Number.parseFloat(parameters.pl),
      p: Number.parseFloat(parameters.p)
    });
    const pinWidth = i === 3 ? 3.8 : Number.parseFloat(parameters.pw);
    pads.push(rectpad(i + 1, x, y, Number.parseFloat(parameters.pl), pinWidth));
  }
  const silkscreenRefText = silkscreenRef(0, 0, 0.3);
  const width = Number.parseFloat(parameters.w) / 2 - 2.4;
  const height = Number.parseFloat(parameters.h) / 2;
  const silkscreenPath1 = {
    layer: "top",
    pcb_component_id: "",
    pcb_silkscreen_path_id: "silkscreen_path_1",
    route: [
      { x: -width, y: height },
      { x: width, y: height },
      { x: width, y: height / 2 + 0.5 }
    ],
    type: "pcb_silkscreen_path",
    stroke_width: 0.1
  };
  const silkscreenPath2 = {
    layer: "top",
    pcb_component_id: "",
    pcb_silkscreen_path_id: "silkscreen_path_2",
    route: [
      { x: -width, y: -height },
      { x: width, y: -height },
      { x: width, y: -height / 2 - 0.5 }
    ],
    type: "pcb_silkscreen_path",
    stroke_width: 0.1
  };
  return [
    ...pads,
    silkscreenPath1,
    silkscreenPath2,
    silkscreenRefText
  ];
};
var sot223_8_def = extendSoicDef({
  p: "0.90mm",
  w: "2.8mm",
  legsoutside: true
});
var get2CcwSot2235Coords = (parameters) => {
  const { p, h, pn, w } = parameters;
  if (pn === 1) {
    return { x: -w / 2 + 1.2, y: p / 2 + p };
  }
  if (pn === 2) {
    return { x: -w / 2 + 1.2, y: p / 2 };
  }
  if (pn === 3) {
    return { x: -w / 2 + 1.2, y: -p / 2 };
  }
  if (pn === 4) {
    return { x: -w / 2 + 1.2, y: -p / 2 - p };
  }
  if (pn === 5) {
    return { x: w / 2 - 1, y: 0 };
  }
  throw new Error("Invalid pin number");
};
var sot223_5 = (parameters) => {
  const pads = [];
  for (let i = 1; i <= parameters.num_pins; i++) {
    const { x, y } = get2CcwSot2235Coords({
      h: Number.parseFloat(parameters.h),
      p: 1.5,
      pn: i,
      w: Number.parseFloat(parameters.w)
    });
    let pinWidth = Number.parseFloat(parameters.pw);
    let pinLength = Number.parseFloat(parameters.pl);
    if (i === 5) {
      pinWidth = 3.4;
      pinLength = 1.8;
    } else {
      pinWidth = 1;
      pinLength = 2.2;
    }
    pads.push(rectpad(i, x, y, pinLength, pinWidth));
  }
  const width = Number.parseFloat(parameters.w) / 2 - 2.4;
  const height = Number.parseFloat(parameters.h) / 2;
  const silkscreenPath1 = {
    layer: "top",
    pcb_component_id: "",
    pcb_silkscreen_path_id: "silkscreen_path_1",
    route: [
      { x: -width, y: height },
      { x: width, y: height },
      { x: width, y: height / 2 + 0.5 }
    ],
    type: "pcb_silkscreen_path",
    stroke_width: 0.1
  };
  const silkscreenPath2 = {
    layer: "top",
    pcb_component_id: "",
    pcb_silkscreen_path_id: "silkscreen_path_2",
    route: [
      { x: -width, y: -height },
      { x: width, y: -height },
      { x: width, y: -height / 2 - 0.5 }
    ],
    type: "pcb_silkscreen_path",
    stroke_width: 0.1
  };
  const silkscreenRefText = silkscreenRef(0, 0, 0.3);
  return [...pads, silkscreenPath1, silkscreenPath2, silkscreenRefText];
};
var get2CcwSot2236Coords = (parameters) => {
  const { p, h, pn, w } = parameters;
  if (pn === 1) {
    return { x: -w / 2 + 1.2, y: 2 * p };
  }
  if (pn === 2) {
    return { x: -w / 2 + 1.2, y: p };
  }
  if (pn === 3) {
    return { x: -w / 2 + 1.2, y: 0 };
  }
  if (pn === 4) {
    return { x: -w / 2 + 1.2, y: -p };
  }
  if (pn === 5) {
    return { x: -w / 2 + 1.2, y: -2 * p };
  }
  if (pn === 6) {
    return { x: w / 2 - 1.175, y: 0 };
  }
  throw new Error("Invalid pin number");
};
var sot223_6 = (parameters) => {
  const pads = [];
  for (let i = 1; i <= parameters.num_pins; i++) {
    const { x, y } = get2CcwSot2236Coords({
      h: Number.parseFloat(parameters.h),
      p: 1.3,
      pn: i,
      w: 8.7
    });
    let pinWidth = Number.parseFloat(parameters.pw);
    let pinLength = Number.parseFloat(parameters.pl);
    if (i === 6) {
      pinWidth = 3.4;
      pinLength = 2.15;
    } else {
      pinWidth = 0.6;
      pinLength = 2.2;
    }
    pads.push(rectpad(i, x, y, pinLength, pinWidth));
  }
  const width = Number.parseFloat(parameters.w) / 2 - 2.4;
  const height = Number.parseFloat(parameters.h) / 2;
  const silkscreenPath1 = {
    layer: "top",
    pcb_component_id: "",
    pcb_silkscreen_path_id: "silkscreen_path_1",
    route: [
      { x: -width, y: height },
      { x: width, y: height },
      { x: width, y: height / 2 + 0.5 }
    ],
    type: "pcb_silkscreen_path",
    stroke_width: 0.1
  };
  const silkscreenPath2 = {
    layer: "top",
    pcb_component_id: "",
    pcb_silkscreen_path_id: "silkscreen_path_2",
    route: [
      { x: -width, y: -height },
      { x: width, y: -height },
      { x: width, y: -height / 2 - 0.5 }
    ],
    type: "pcb_silkscreen_path",
    stroke_width: 0.1
  };
  const silkscreenRefText = silkscreenRef(0, 0, 0.3);
  return [...pads, silkscreenPath1, silkscreenPath2, silkscreenRefText];
};

// src/fn/sot23w.ts
import { z as z45 } from "zod";
var sot23w_def = z45.object({
  fn: z45.string(),
  num_pins: z45.number().default(3),
  w: z45.string().default("3.40mm"),
  h: z45.string().default("3.30mm"),
  pl: z45.string().default("1mm"),
  pw: z45.string().default("0.7mm"),
  p: z45.string().default("1.2mm"),
  string: z45.string().optional()
});
var sot23w = (raw_params) => {
  const match = raw_params.string?.match(/^sot23w_(\d+)/);
  const numPins = match ? Number.parseInt(match[1], 3) : 3;
  const parameters = sot23w_def.parse({
    ...raw_params,
    num_pins: numPins
  });
  if (parameters.num_pins === 3) {
    return {
      circuitJson: sot23w_3(parameters),
      parameters
    };
  }
  throw new Error("Invalid number of pins");
};
var getCcwSot23wCoords = (parameters) => {
  const { pn, w, h, pl, p } = parameters;
  if (pn === 1) {
    return { x: -p, y: 0.95 };
  }
  if (pn === 2) {
    return { x: -p, y: -0.95 };
  }
  return { x: p, y: 0 };
};
var sot23w_3 = (parameters) => {
  const pads = [];
  for (let i = 0; i < parameters.num_pins; i++) {
    const { x, y } = getCcwSot23wCoords({
      num_pins: parameters.num_pins,
      pn: i + 1,
      w: Number.parseFloat(parameters.w),
      h: Number.parseFloat(parameters.h),
      pl: Number.parseFloat(parameters.pl),
      p: Number.parseFloat(parameters.p)
    });
    pads.push(
      rectpad(
        i + 1,
        x,
        y,
        Number.parseFloat(parameters.pl),
        Number.parseFloat(parameters.pw)
      )
    );
  }
  const silkscreenRefText = silkscreenRef(
    0,
    Number.parseInt(parameters.h) / 2 + 1,
    0.3
  );
  const width = Number.parseFloat(parameters.w) / 2 - 1;
  const height = Number.parseFloat(parameters.h) / 2;
  const silkscreenPath1 = {
    layer: "top",
    pcb_component_id: "",
    pcb_silkscreen_path_id: "silkscreen_path_1",
    route: [
      { x: -width, y: height },
      { x: width + 0.3, y: height },
      { x: width + 0.3, y: height / 2 }
    ],
    type: "pcb_silkscreen_path",
    stroke_width: 0.1
  };
  const silkscreenPath2 = {
    layer: "top",
    pcb_component_id: "",
    pcb_silkscreen_path_id: "silkscreen_path_2",
    route: [
      { x: -width, y: -height },
      { x: width + 0.3, y: -height },
      { x: width + 0.3, y: -height / 2 }
    ],
    type: "pcb_silkscreen_path",
    stroke_width: 0.1
  };
  return [
    ...pads,
    silkscreenPath1,
    silkscreenPath2,
    silkscreenRefText
  ];
};

// src/fn/to92s.ts
import { z as z46 } from "zod";
var to92s_def = z46.object({
  fn: z46.string(),
  num_pins: z46.union([z46.literal(3), z46.literal(2)]).default(3),
  p: z46.string().default("1.27mm"),
  id: z46.string().default("0.72mm"),
  od: z46.string().default("0.95mm"),
  w: z46.string().default("2.5mm"),
  h: z46.string().default("4.2mm"),
  string: z46.string().optional()
});
var to92s_3 = (parameters) => {
  const { p, id, od, w, h } = parameters;
  const holeY = Number.parseFloat(h) / 2;
  const padSpacing = Number.parseFloat(p);
  return [
    platedhole(1, -padSpacing, holeY - padSpacing, id, od),
    platedhole(2, 0, holeY - padSpacing, id, od),
    platedhole(3, padSpacing, holeY - padSpacing, id, od)
  ];
};
var to92s_2 = (parameters) => {
  const { p, id, od, h } = parameters;
  const holeY = Number.parseFloat(h) / 2;
  const padSpacing = Number.parseFloat(p);
  return [
    platedhole(1, -padSpacing, holeY - padSpacing, id, od),
    platedhole(2, padSpacing, holeY - padSpacing, id, od)
  ];
};
var to92s = (raw_params) => {
  const match = raw_params.string?.match(/^to92s_(\d+)/);
  const numPins = match ? Number.parseInt(match[1], 10) : 3;
  const parameters = to92s_def.parse({
    ...raw_params,
    num_pins: numPins
  });
  let platedHoles = [];
  if (parameters.num_pins === 3) {
    platedHoles = to92s_3(parameters);
  } else if (parameters.num_pins === 2) {
    platedHoles = to92s_2(parameters);
  } else {
    throw new Error("Invalid number of pins for TO-92");
  }
  const holeY = Number.parseFloat(parameters.h) / 2;
  const padSpacing = Number.parseFloat(parameters.p);
  const silkscreenBody = {
    type: "pcb_silkscreen_path",
    layer: "top",
    pcb_component_id: "",
    route: [
      { x: -holeY, y: holeY - padSpacing },
      { x: -1.9, y: 0 },
      { x: 1.9, y: 0 },
      { x: holeY, y: holeY - padSpacing },
      { x: 1.5, y: Number.parseFloat(parameters.h) / 2 + 0.5 },
      { x: -1.5, y: Number.parseFloat(parameters.h) / 2 + 0.5 },
      { x: -holeY, y: holeY - padSpacing }
    ],
    stroke_width: 0.1,
    pcb_silkscreen_path_id: ""
  };
  const silkscreenRefText = silkscreenRef(0, holeY + 1, 0.5);
  return {
    circuitJson: [
      ...platedHoles,
      silkscreenBody,
      silkscreenRefText
    ],
    parameters
  };
};

// src/fn/jst.ts
import {
  length as length35
} from "circuit-json";
import { z as z47 } from "zod";
var jst_def = z47.object({
  fn: z47.string(),
  p: length35.optional().default("2.2mm"),
  id: length35.optional().default("0.70mm"),
  pw: length35.optional().default("1.20mm"),
  pl: length35.optional().default("1.20mm"),
  w: length35.optional().default("6mm"),
  h: length35.optional().default("5mm")
});
var jst = (raw_params) => {
  const parameters = jst_def.parse(raw_params);
  const { p, id, pw, pl, h } = parameters;
  const half_p = p / 2;
  const plated_holes = [
    platedHoleWithRectPad(1, -half_p, 2, id, pw, pl),
    platedHoleWithRectPad(2, half_p, 2, id, pw, pl)
  ];
  const silkscreenBody = {
    type: "pcb_silkscreen_path",
    layer: "top",
    pcb_component_id: "",
    route: [
      { x: -3, y: 3 },
      { x: 3, y: 3 },
      { x: 3, y: -2 },
      { x: -3, y: -2 },
      { x: -3, y: 3 }
    ],
    stroke_width: 0.1,
    pcb_silkscreen_path_id: ""
  };
  const silkscreenRefText = silkscreenRef(0, h / 2 + 1, 0.5);
  return {
    circuitJson: [
      ...plated_holes,
      silkscreenBody,
      silkscreenRefText
    ],
    parameters
  };
};

// src/fn/sod110.ts
import { z as z48 } from "zod";
import { length as length36 } from "circuit-json";
var sod_def12 = z48.object({
  fn: z48.string(),
  num_pins: z48.literal(2).default(2),
  w: z48.string().default("3.30mm"),
  h: z48.string().default("1.70mm"),
  pl: z48.string().default("0.80mm"),
  pw: z48.string().default("1mm"),
  p: z48.string().default("1.90mm")
});
var sod110 = (raw_params) => {
  const parameters = sod_def12.parse(raw_params);
  const silkscreenRefText = silkscreenRef(
    0,
    length36.parse(parameters.h) / 2 + 0.5,
    0.3
  );
  const silkscreenLine = {
    type: "pcb_silkscreen_path",
    layer: "top",
    pcb_component_id: "",
    route: [
      {
        x: length36.parse(parameters.p) / 2,
        y: length36.parse(parameters.h) / 2
      },
      {
        x: -length36.parse(parameters.w) / 2,
        y: length36.parse(parameters.h) / 2
      },
      {
        x: -length36.parse(parameters.w) / 2,
        y: -length36.parse(parameters.h) / 2
      },
      {
        x: length36.parse(parameters.p) / 2,
        y: -length36.parse(parameters.h) / 2
      }
    ],
    stroke_width: 0.1,
    pcb_silkscreen_path_id: ""
  };
  return {
    circuitJson: sodWithoutParsing13(parameters).concat(
      silkscreenLine,
      silkscreenRefText
    ),
    parameters
  };
};
var getSodCoords13 = (parameters) => {
  const { pn, p } = parameters;
  if (pn === 1) {
    return { x: -p / 2, y: 0 };
  }
  return { x: p / 2, y: 0 };
};
var sodWithoutParsing13 = (parameters) => {
  const pads = [];
  for (let i = 1; i <= parameters.num_pins; i++) {
    const { x, y } = getSodCoords13({
      pn: i,
      p: Number.parseFloat(parameters.p)
    });
    pads.push(
      rectpad(
        i,
        x,
        y,
        Number.parseFloat(parameters.pl),
        Number.parseFloat(parameters.pw)
      )
    );
  }
  return pads;
};

// src/fn/vssop.ts
import { z as z49 } from "zod";
import { length as length37 } from "circuit-json";
var getDefaultValues = (num_pins) => {
  switch (num_pins) {
    case 8:
      return {
        w: "3.06mm",
        h: "3.14mm",
        p: "0.65mm",
        pl: "1.6mm",
        pw: "0.5mm"
      };
    case 10:
      return {
        w: "3.10mm",
        h: "3.33mm",
        p: "0.5mm",
        pl: "1.45mm",
        pw: "0.3mm"
      };
    default:
      return {
        w: "3.06mm",
        h: "3.14mm",
        p: "0.65mm",
        pl: "1.6mm",
        pw: "0.5mm"
      };
  }
};
var vssop_def = z49.object({
  fn: z49.string(),
  num_pins: z49.union([z49.literal(8), z49.literal(10)]).default(8),
  w: z49.string().optional(),
  h: z49.string().optional(),
  p: z49.string().optional(),
  pl: z49.string().optional(),
  pw: z49.string().optional(),
  string: z49.string().optional()
});
var vssop = (raw_params) => {
  const parameters = vssop_def.parse(raw_params);
  const defaults = getDefaultValues(parameters.num_pins);
  const w = length37.parse(parameters.w || defaults.w);
  const h = length37.parse(parameters.h || defaults.h);
  const p = length37.parse(parameters.p || defaults.p);
  const pl = length37.parse(parameters.pl || defaults.pl);
  const pw = length37.parse(parameters.pw || defaults.pw);
  const pads = [];
  const half = parameters.num_pins / 2;
  for (let i = 0; i < parameters.num_pins; i++) {
    const { x, y } = getVssopPadCoord(parameters.num_pins, i + 1, w, p);
    const logical_pn = i < half ? i + 1 : parameters.num_pins - (i - half);
    pads.push(rectpad(logical_pn, x, y, pl, pw));
  }
  const silkscreenBoxWidth = w;
  const silkscreenBoxHeight = h;
  const silkscreenTopLine = {
    type: "pcb_silkscreen_path",
    layer: "top",
    pcb_component_id: "",
    route: [
      { x: -silkscreenBoxWidth / 2, y: silkscreenBoxHeight / 2 },
      { x: silkscreenBoxWidth / 2, y: silkscreenBoxHeight / 2 }
    ],
    stroke_width: 0.05,
    pcb_silkscreen_path_id: ""
  };
  const silkscreenBottomLine = {
    type: "pcb_silkscreen_path",
    layer: "top",
    pcb_component_id: "",
    route: [
      { x: -silkscreenBoxWidth / 2, y: -silkscreenBoxHeight / 2 },
      { x: silkscreenBoxWidth / 2, y: -silkscreenBoxHeight / 2 }
    ],
    stroke_width: 0.05,
    pcb_silkscreen_path_id: ""
  };
  const pin1Position = getVssopPadCoord(
    parameters.num_pins,
    1,
    silkscreenBoxWidth,
    p
  );
  const pin1MarkerPosition = {
    x: pin1Position.x - 0.8,
    y: pin1Position.y
  };
  const pin1Marking = {
    type: "pcb_silkscreen_path",
    layer: "top",
    pcb_component_id: "pin_marker_1",
    route: [
      { x: pin1MarkerPosition.x - 0.4, y: pin1MarkerPosition.y },
      { x: pin1MarkerPosition.x - 0.7, y: pin1MarkerPosition.y + 0.3 },
      { x: pin1MarkerPosition.x - 0.7, y: pin1MarkerPosition.y - 0.3 },
      { x: pin1MarkerPosition.x - 0.4, y: pin1MarkerPosition.y }
    ],
    stroke_width: 0.05,
    pcb_silkscreen_path_id: "pin_marker_1"
  };
  const silkscreenRefText = silkscreenRef(
    0,
    silkscreenBoxHeight / 2 + 0.5,
    0.3
  );
  return {
    circuitJson: [
      ...pads,
      silkscreenTopLine,
      silkscreenBottomLine,
      silkscreenRefText,
      pin1Marking
    ],
    parameters
  };
};
var getVssopPadCoord = (pinCount, pn, w, p) => {
  const half = pinCount / 2;
  const rowIndex = (pn - 1) % half;
  const col = pn <= half ? -1 : 1;
  const row = (half - 1) / 2 - rowIndex;
  return {
    x: col * length37.parse(pinCount === 8 ? "1.8mm" : "2.2mm"),
    y: row * p
  };
};

// src/fn/msop.ts
import { z as z50 } from "zod";
import { length as length38 } from "circuit-json";
var getDefaultValues2 = (num_pins) => {
  switch (num_pins) {
    case 10:
      return {
        w: "3.10mm",
        h: "3.32mm",
        p: "0.5mm",
        pl: "1.63mm",
        pw: "0.33mm"
      };
    case 12:
      return {
        w: "3mm",
        h: "4mm",
        p: "0.65mm",
        pl: "0.88mm",
        pw: "0.4mm"
      };
    case 16:
      return {
        w: "3.10mm",
        h: "4mm",
        p: "0.5mm",
        pl: "0.88mm",
        pw: "0.3mm"
      };
    default:
      return {
        w: "3.10mm",
        h: "3.32mm",
        p: "0.65mm",
        pl: "1.63mm",
        pw: "0.4mm"
      };
  }
};
var msop_def = z50.object({
  fn: z50.string(),
  num_pins: z50.union([z50.literal(8), z50.literal(10), z50.literal(12), z50.literal(16)]).default(8),
  w: z50.string().optional(),
  h: z50.string().optional(),
  p: z50.string().optional(),
  pl: z50.string().optional(),
  pw: z50.string().optional(),
  string: z50.string().optional()
});
var getMsopCoords = (pinCount, pn, w, p) => {
  const half = pinCount / 2;
  const rowIndex = (pn - 1) % half;
  const col = pn <= half ? -1 : 1;
  const row = (half - 1) / 2 - rowIndex;
  return {
    x: col * length38.parse("2mm"),
    y: row * p
  };
};
var msop = (raw_params) => {
  const parameters = msop_def.parse(raw_params);
  const defaults = getDefaultValues2(parameters.num_pins);
  const w = length38.parse(parameters.w || defaults.w);
  const h = length38.parse(parameters.h || defaults.h);
  const p = length38.parse(parameters.p || defaults.p);
  const pl = length38.parse(parameters.pl || defaults.pl);
  const pw = length38.parse(parameters.pw || defaults.pw);
  const pads = [];
  for (let i = 0; i < parameters.num_pins; i++) {
    const { x, y } = getMsopCoords(parameters.num_pins, i + 1, w, p);
    pads.push(rectpad(i + 1, x, y, pl, pw));
  }
  const silkscreenBoxWidth = w;
  const silkscreenBoxHeight = h;
  const silkscreenTopLine = {
    type: "pcb_silkscreen_path",
    layer: "top",
    pcb_component_id: "",
    route: [
      { x: -silkscreenBoxWidth / 2, y: silkscreenBoxHeight / 2 },
      { x: silkscreenBoxWidth / 2, y: silkscreenBoxHeight / 2 }
    ],
    stroke_width: 0.05,
    pcb_silkscreen_path_id: ""
  };
  const silkscreenBottomLine = {
    type: "pcb_silkscreen_path",
    layer: "top",
    pcb_component_id: "",
    route: [
      { x: -silkscreenBoxWidth / 2, y: -silkscreenBoxHeight / 2 },
      { x: silkscreenBoxWidth / 2, y: -silkscreenBoxHeight / 2 }
    ],
    stroke_width: 0.05,
    pcb_silkscreen_path_id: ""
  };
  const pin1Position = getMsopCoords(
    parameters.num_pins,
    1,
    silkscreenBoxWidth,
    p
  );
  const pin1MarkerPosition = {
    x: pin1Position.x - 0.8,
    y: pin1Position.y
  };
  const pin1Marking = {
    type: "pcb_silkscreen_path",
    layer: "top",
    pcb_component_id: "pin_marker_1",
    route: [
      { x: pin1MarkerPosition.x - 0.4, y: pin1MarkerPosition.y },
      { x: pin1MarkerPosition.x - 0.7, y: pin1MarkerPosition.y + 0.3 },
      { x: pin1MarkerPosition.x - 0.7, y: pin1MarkerPosition.y - 0.3 },
      { x: pin1MarkerPosition.x - 0.4, y: pin1MarkerPosition.y }
    ],
    stroke_width: 0.05,
    pcb_silkscreen_path_id: "pin_marker_1"
  };
  const silkscreenRefText = silkscreenRef(
    0,
    silkscreenBoxHeight / 2 + 0.5,
    0.3
  );
  return {
    circuitJson: [
      ...pads,
      silkscreenTopLine,
      silkscreenBottomLine,
      silkscreenRefText,
      pin1Marking
    ],
    parameters
  };
};

// src/fn/sod323w.ts
import { z as z51 } from "zod";
import { length as length39 } from "circuit-json";
var sod323w_def = z51.object({
  fn: z51.string(),
  num_pins: z51.literal(2).default(2),
  w: z51.string().default("3.8mm"),
  h: z51.string().default("1.65mm"),
  pl: z51.string().default("1.2mm"),
  pw: z51.string().default("1.2mm"),
  pad_spacing: z51.string().default("2.6mm")
});
var sod323w = (raw_params) => {
  const parameters = sod323w_def.parse(raw_params);
  const silkscreenRefText = silkscreenRef(
    0,
    length39.parse(parameters.h),
    0.3
  );
  const silkscreenLine = {
    type: "pcb_silkscreen_path",
    layer: "top",
    pcb_component_id: "",
    route: [
      {
        x: length39.parse(parameters.pad_spacing) / 2,
        y: length39.parse(parameters.h) / 2
      },
      {
        x: -length39.parse(parameters.w) / 2 - 0.2,
        y: length39.parse(parameters.h) / 2
      },
      {
        x: -length39.parse(parameters.w) / 2 - 0.2,
        y: -length39.parse(parameters.h) / 2
      },
      {
        x: length39.parse(parameters.pad_spacing) / 2,
        y: -length39.parse(parameters.h) / 2
      }
    ],
    stroke_width: 0.1,
    pcb_silkscreen_path_id: ""
  };
  return {
    circuitJson: sodWithoutParsing14(parameters).concat(
      silkscreenLine,
      silkscreenRefText
    ),
    parameters
  };
};
var getSodCoords14 = (parameters) => {
  const { pn, pad_spacing } = parameters;
  if (pn === 1) {
    return { x: -pad_spacing / 2, y: 0 };
  } else {
    return { x: pad_spacing / 2, y: 0 };
  }
};
var sodWithoutParsing14 = (parameters) => {
  const pads = [];
  for (let i = 1; i <= parameters.num_pins; i++) {
    const { x, y } = getSodCoords14({
      pn: i,
      pad_spacing: Number.parseFloat(parameters.pad_spacing)
    });
    pads.push(
      rectpad(
        i,
        x,
        y,
        Number.parseFloat(parameters.pl),
        Number.parseFloat(parameters.pw)
      )
    );
  }
  return pads;
};

// src/fn/sod323fl.ts
import { z as z52 } from "zod";
import { length as length40 } from "circuit-json";
var sod323FL_def = z52.object({
  fn: z52.string(),
  num_pins: z52.literal(2).default(2),
  w: z52.string().default("3.20mm"),
  h: z52.string().default("1.65mm"),
  pl: z52.string().default("0.8mm"),
  pw: z52.string().default("0.9mm"),
  pad_spacing: z52.string().default("2.1mm")
});
var sod323fl = (raw_params) => {
  const parameters = sod323FL_def.parse(raw_params);
  const silkscreenRefText = silkscreenRef(
    0,
    length40.parse(parameters.h),
    0.3
  );
  const silkscreenLine = {
    type: "pcb_silkscreen_path",
    layer: "top",
    pcb_component_id: "",
    route: [
      {
        x: length40.parse(parameters.pad_spacing) / 2,
        y: length40.parse(parameters.h) / 2
      },
      {
        x: -length40.parse(parameters.w) / 2 - 0.2,
        y: length40.parse(parameters.h) / 2
      },
      {
        x: -length40.parse(parameters.w) / 2 - 0.2,
        y: -length40.parse(parameters.h) / 2
      },
      {
        x: length40.parse(parameters.pad_spacing) / 2,
        y: -length40.parse(parameters.h) / 2
      }
    ],
    stroke_width: 0.1,
    pcb_silkscreen_path_id: ""
  };
  return {
    circuitJson: sodWithoutParsing15(parameters).concat(
      silkscreenLine,
      silkscreenRefText
    ),
    parameters
  };
};
var getSodCoords15 = (parameters) => {
  const { pn, pad_spacing } = parameters;
  if (pn === 1) {
    return { x: -pad_spacing / 2, y: 0 };
  } else {
    return { x: pad_spacing / 2, y: 0 };
  }
};
var sodWithoutParsing15 = (parameters) => {
  const pads = [];
  for (let i = 1; i <= parameters.num_pins; i++) {
    const { x, y } = getSodCoords15({
      pn: i,
      pad_spacing: Number.parseFloat(parameters.pad_spacing)
    });
    pads.push(
      rectpad(
        i,
        x,
        y,
        Number.parseFloat(parameters.pl),
        Number.parseFloat(parameters.pw)
      )
    );
  }
  return pads;
};

// src/fn/son.ts
import { z as z53 } from "zod";
import { length as length41 } from "circuit-json";
var son_def = z53.object({
  fn: z53.string(),
  num_pins: z53.union([z53.literal(6), z53.literal(8)]).default(8),
  w: z53.string().default("3mm"),
  h: z53.string().default("3mm"),
  p: z53.string().default("0.5mm"),
  pl: z53.string().default("0.52mm"),
  pw: z53.string().default("0.35mm"),
  epw: z53.string().default("1.40mm"),
  eph: z53.string().default("1.60mm"),
  string: z53.string().optional(),
  ep: z53.boolean().default(false)
});
var son = (raw_params) => {
  if (raw_params.string && raw_params.string.includes("_ep")) {
    raw_params.ep = true;
  }
  const match = raw_params.string?.match(/^son_(\d+)/);
  const numPins = match ? Number.parseInt(match[1], 10) : raw_params.num_pins || 8;
  const parameters = son_def.parse({
    ...raw_params,
    num_pins: numPins
  });
  const w = length41.parse(parameters.w);
  const h = length41.parse(parameters.h);
  const p = length41.parse(parameters.p);
  const pl = length41.parse(parameters.pl);
  const pw = length41.parse(parameters.pw);
  const epw = length41.parse(parameters.epw);
  const eph = length41.parse(parameters.eph);
  const pads = [];
  for (let i = 0; i < parameters.num_pins; i++) {
    const { x, y } = getSonPadCoord(parameters.num_pins, i + 1, w, p);
    pads.push(rectpad(i + 1, x, y, pl, pw));
  }
  if (parameters.ep) {
    pads.push(rectpad(parameters.num_pins + 1, 0, 0, epw, eph));
  }
  const silkscreenBoxWidth = w;
  const silkscreenBoxHeight = h;
  const silkscreenTopLine = {
    type: "pcb_silkscreen_path",
    layer: "top",
    pcb_component_id: "",
    route: [
      { x: -silkscreenBoxWidth / 2, y: silkscreenBoxHeight / 2 },
      { x: silkscreenBoxWidth / 2, y: silkscreenBoxHeight / 2 }
    ],
    stroke_width: 0.05,
    pcb_silkscreen_path_id: ""
  };
  const silkscreenBottomLine = {
    type: "pcb_silkscreen_path",
    layer: "top",
    pcb_component_id: "",
    route: [
      { x: -silkscreenBoxWidth / 2, y: -silkscreenBoxHeight / 2 },
      { x: silkscreenBoxWidth / 2, y: -silkscreenBoxHeight / 2 }
    ],
    stroke_width: 0.05,
    pcb_silkscreen_path_id: ""
  };
  const pin1Position = getSonPadCoord(
    parameters.num_pins,
    1,
    silkscreenBoxWidth,
    p
  );
  const pin1MarkerPosition = {
    x: pin1Position.x - 0.4,
    y: pin1Position.y
  };
  const pin1Marking = {
    type: "pcb_silkscreen_path",
    layer: "top",
    pcb_component_id: "pin_marker_1",
    route: [
      { x: pin1MarkerPosition.x - 0.4, y: pin1MarkerPosition.y },
      { x: pin1MarkerPosition.x - 0.7, y: pin1MarkerPosition.y + 0.3 },
      { x: pin1MarkerPosition.x - 0.7, y: pin1MarkerPosition.y - 0.3 },
      { x: pin1MarkerPosition.x - 0.4, y: pin1MarkerPosition.y }
    ],
    stroke_width: 0.05,
    pcb_silkscreen_path_id: "pin_marker_1"
  };
  const silkscreenRefText = silkscreenRef(
    0,
    silkscreenBoxHeight / 2 + 0.5,
    0.3
  );
  return {
    circuitJson: [
      ...pads,
      silkscreenTopLine,
      silkscreenBottomLine,
      silkscreenRefText,
      pin1Marking
    ],
    parameters
  };
};
var getSonPadCoord = (num_pins, pn, w, p) => {
  const half = num_pins / 2;
  const rowIndex = (pn - 1) % half;
  const col = pn <= half ? -1 : 1;
  const row = (half - 1) / 2 - rowIndex;
  return {
    x: col * length41.parse("1.4mm"),
    y: row * p
  };
};

// src/fn/solderjumper.ts
import { length as length42 } from "circuit-json";
var solderjumper = (params) => {
  const { num_pins, bridged, p = 2.54, pw = 1.5, ph = 1.5 } = params;
  const padSpacing = length42.parse(p);
  const padWidth = length42.parse(pw);
  const padHeight = length42.parse(ph);
  const traceWidth = Math.min(padHeight / 4, 0.5);
  const pads = [];
  for (let i = 0; i < num_pins; i++) {
    pads.push(rectpad(i + 1, i * padSpacing, 0, padWidth, padHeight));
  }
  let traces = [];
  if (bridged) {
    const pins = bridged.split("").map(Number);
    if (pins.length > 1) {
      for (let i = 0; i < pins.length - 1; i++) {
        const from = pins[i];
        const to = pins[i + 1];
        if (typeof from === "number" && typeof to === "number" && !isNaN(from) && !isNaN(to)) {
          const xCenterFrom = (from - 1) * padSpacing;
          const xCenterTo = (to - 1) * padSpacing;
          const directionMult = Math.sign(xCenterTo - xCenterFrom);
          const x1 = xCenterFrom + directionMult * (padWidth / 2);
          const x2 = xCenterTo - directionMult * (padWidth / 2);
          traces.push({
            type: "pcb_trace",
            pcb_trace_id: "",
            route: [
              {
                start_pcb_port_id: `{PIN${from}}`,
                x: x1,
                y: 0,
                width: traceWidth,
                layer: "top",
                route_type: "wire"
              },
              {
                end_pcb_port_id: `{PIN${to}}`,
                x: x2,
                y: 0,
                width: traceWidth,
                layer: "top",
                route_type: "wire"
              }
            ]
          });
        }
      }
    }
  }
  const outlineWidth = (num_pins - 1) * padSpacing + padWidth + 0.7;
  const outlineHeight = padHeight + 1;
  const outlineCenterX = (num_pins - 1) * padSpacing / 2;
  const outlineCenterY = 0;
  const silkscreenRect = {
    type: "pcb_silkscreen_path",
    layer: "top",
    pcb_component_id: "",
    pcb_silkscreen_path_id: "outline",
    route: [
      {
        x: outlineCenterX - outlineWidth / 2,
        y: outlineCenterY - outlineHeight / 2
      },
      {
        x: outlineCenterX + outlineWidth / 2,
        y: outlineCenterY - outlineHeight / 2
      },
      {
        x: outlineCenterX + outlineWidth / 2,
        y: outlineCenterY + outlineHeight / 2
      },
      {
        x: outlineCenterX - outlineWidth / 2,
        y: outlineCenterY + outlineHeight / 2
      },
      {
        x: outlineCenterX - outlineWidth / 2,
        y: outlineCenterY - outlineHeight / 2
      }
    ],
    stroke_width: 0.15
  };
  const refOffset = 0.6;
  const refY = outlineCenterY + outlineHeight / 2 + refOffset;
  const silk = silkscreenRef(outlineCenterX, refY, 0.4);
  return {
    circuitJson: [...pads, ...traces, silkscreenRect, silk],
    parameters: params
  };
};

// src/fn/sot457.ts
import { z as z54 } from "zod";

// src/helpers/pillpad.ts
var pillpad = (pn, x, y, w, h) => {
  return {
    type: "pcb_smtpad",
    x,
    y,
    width: w,
    height: h,
    radius: h / 2,
    layer: "top",
    shape: "pill",
    pcb_smtpad_id: "",
    port_hints: Array.isArray(pn) ? pn.map((item) => item.toString()) : [pn.toString()]
  };
};

// src/fn/sot457.ts
var commonSchema = {
  fn: z54.literal("sot457"),
  num_pins: z54.literal(6).default(6),
  pillh: z54.string().default("0.45mm"),
  pillw: z54.string().default("1.45mm"),
  pl: z54.string(),
  pw: z54.string(),
  p: z54.string(),
  wave: z54.boolean().optional(),
  reflow: z54.boolean().optional()
};
var sot457DefSchema = z54.object({
  ...commonSchema,
  h: z54.string().default("2.5mm"),
  w: z54.string().default("2.7mm"),
  pl: z54.string().default("0.8mm"),
  pw: z54.string().default("0.55mm"),
  p: z54.string().default("0.95mm")
});
var sot457WaveSchema = z54.object({
  ...commonSchema,
  h: z54.string().default("3mm"),
  w: z54.string().default("4mm"),
  pillr: z54.string().default("0.225mm"),
  pl: z54.string().default("1.45mm"),
  pw: z54.string().default("1.5mm"),
  p: z54.string().default("1.475mm")
}).transform((data) => ({
  ...data,
  wave: data.wave ?? (data.reflow === void 0 ? true : !data.reflow),
  reflow: data.reflow ?? (data.wave === void 0 ? false : !data.wave)
}));
var parseDimension = (value) => {
  return Number.parseFloat(value.replace("mm", ""));
};
var getCcwSot457Coords = ({
  pitch,
  width,
  pinNumber
}) => {
  const offset = 0.1;
  const coords = {
    1: { x: -width / 2 - offset, y: pitch },
    2: { x: -width / 2 - offset, y: 0 },
    3: { x: -width / 2 - offset, y: -pitch },
    4: { x: width / 2 + offset, y: -pitch },
    5: { x: width / 2 + offset, y: 0 },
    6: { x: width / 2 + offset, y: pitch }
  };
  const coord = coords[pinNumber];
  if (!coord) {
    throw new Error(`Invalid pin number: ${pinNumber}`);
  }
  return coord;
};
var generateSot457Elements = (params) => {
  const pads = [];
  const pitch = parseDimension(params.p);
  const padLength = parseDimension(params.pl);
  const padWidth = parseDimension(params.pw);
  const width = parseDimension(params.w);
  const height = parseDimension(params.h);
  if (params.wave) {
    const pinConfigs = {
      1: ({ padWidth: padWidth2, padHeight }) => rectpad(1, -pitch, pitch, padHeight, padWidth2),
      2: ({ padWidth: padWidth2, padHeight }) => rectpad(2, -pitch, -pitch, padHeight, padWidth2),
      3: ({ padWidth: padWidth2, padHeight }) => pillpad(
        3,
        -pitch,
        0,
        parseDimension(params.pillw),
        parseDimension(params.pillh)
      ),
      4: ({ padWidth: padWidth2, padHeight }) => pillpad(
        4,
        pitch,
        0,
        parseDimension(params.pillw),
        parseDimension(params.pillh)
      ),
      5: ({ padWidth: padWidth2, padHeight }) => rectpad(5, pitch, pitch, padHeight, padWidth2),
      6: ({ padWidth: padWidth2, padHeight }) => rectpad(6, pitch, -pitch, padHeight, padWidth2)
    };
    for (let i = 1; i <= params.num_pins; i++) {
      const config = pinConfigs[i];
      if (config) {
        pads.push(config({ padWidth: padLength, padHeight: padWidth }));
      }
    }
  } else {
    for (let i = 1; i <= params.num_pins; i++) {
      const { x, y } = getCcwSot457Coords({ pitch, width, pinNumber: i });
      pads.push(rectpad(i, x, y, padLength, padWidth));
    }
  }
  const silkscreenPath1 = {
    type: "pcb_silkscreen_path",
    layer: "top",
    pcb_component_id: "",
    pcb_silkscreen_path_id: "silkscreen_path_1",
    route: [
      { x: -width / 3, y: height / 2 + pitch / 1.3 },
      { x: width / 3, y: height / 2 + pitch / 1.3 }
    ],
    stroke_width: 0.05
  };
  const silkscreenPath2 = {
    type: "pcb_silkscreen_path",
    layer: "top",
    pcb_component_id: "",
    pcb_silkscreen_path_id: "silkscreen_path_2",
    route: [
      { x: -width / 3, y: -height / 2 - pitch / 1.3 },
      { x: width / 3, y: -height / 2 - pitch / 1.3 }
    ],
    stroke_width: 0.05
  };
  const silkscreenRefText = silkscreenRef(0, height + 0.5, 0.3);
  const pin1Position = getCcwSot457Coords({ pitch, width, pinNumber: 1 });
  const triangleHeight = params.wave ? 1 : 0.5;
  const triangleWidth = params.wave ? 0.7 : 0.3;
  pin1Position.x -= params.wave ? padWidth : padWidth * 1.7;
  const pin1Indicator = {
    type: "pcb_silkscreen_path",
    layer: "top",
    pcb_component_id: "",
    pcb_silkscreen_path_id: "pin1_indicator",
    route: [
      { x: pin1Position.x + triangleHeight / 2, y: pin1Position.y },
      {
        x: pin1Position.x - triangleHeight / 2,
        y: pin1Position.y + triangleWidth / 2
      },
      {
        x: pin1Position.x - triangleHeight / 2,
        y: pin1Position.y - triangleWidth / 2
      },
      { x: pin1Position.x + triangleHeight / 2, y: pin1Position.y }
    ],
    stroke_width: 0.05
  };
  return [
    silkscreenRefText,
    silkscreenPath1,
    silkscreenPath2,
    pin1Indicator,
    ...pads
  ];
};
var sot457 = (rawParams) => {
  if (rawParams.wave) {
    const parameters2 = sot457WaveSchema.parse({ ...rawParams, fn: "sot457" });
    return {
      circuitJson: generateSot457Elements(parameters2),
      parameters: parameters2
    };
  }
  const parameters = sot457DefSchema.parse(rawParams);
  return {
    circuitJson: generateSot457Elements(parameters),
    parameters
  };
};

// src/fn/potentiometer.ts
import { z as z55 } from "zod";
var potentiometer_def = z55.object({
  fn: z55.string(),
  num_pins: z55.union([z55.literal(3), z55.literal(2)]).default(3),
  p: z55.string().default("3.8mm"),
  id: z55.string().default("1.25mm"),
  od: z55.string().default("2.35mm"),
  ca: z55.string().default("14mm").describe(
    "Caliper axis (width or diameter of the potentiometer body or adjustment knob)"
  ),
  w: z55.string().default("5.35mm"),
  h: z55.string().default("4mm"),
  string: z55.string().optional()
});
var potentiometer_acp = (parameters) => {
  const { p, id, od, h, ca } = parameters;
  const y = Number.parseFloat(h);
  const caliper = Number.parseFloat(ca);
  return [
    platedhole(1, 0, caliper / 4 + 0.3, id, od),
    platedhole(2, y, 0, id, od),
    platedhole(3, 0, -caliper / 4 - 0.3, id, od)
  ];
};
var potentiometer = (raw_params) => {
  const match = raw_params.string?.match(/^potentiometer_(\d+)/);
  const numPins = match ? Number.parseInt(match[1], 10) : 3;
  const parameters = potentiometer_def.parse({
    ...raw_params,
    num_pins: numPins
  });
  let platedHoles = [];
  if (parameters.num_pins === 3) {
    platedHoles = potentiometer_acp(parameters);
  }
  const y = Number.parseFloat(parameters.ca) / 2 + 0.15;
  const x = Number.parseFloat(parameters.w);
  const od = Number.parseFloat(parameters.od) / 2 + 0.35;
  const silkscreenBody = {
    type: "pcb_silkscreen_path",
    layer: "top",
    pcb_component_id: "",
    route: [
      { x: 0, y: y - 1.75 },
      { x: 0, y },
      { x, y },
      { x, y: od }
    ],
    stroke_width: 0.1,
    pcb_silkscreen_path_id: ""
  };
  const silkscreenBody2 = {
    type: "pcb_silkscreen_path",
    layer: "top",
    pcb_component_id: "",
    route: [
      { x, y: -od },
      { x, y: -y },
      { x: 0, y: -y },
      { x: 0, y: -y + 1.75 }
    ],
    stroke_width: 0.1,
    pcb_silkscreen_path_id: ""
  };
  const W = Number.parseFloat(parameters.w) / 2;
  const silkscreenRefText = silkscreenRef(W, y + 1, 0.5);
  return {
    circuitJson: [
      ...platedHoles,
      silkscreenBody,
      silkscreenBody2,
      silkscreenRefText
    ],
    parameters
  };
};

// src/fn/electrolytic.ts
import {
  length as length43
} from "circuit-json";
import { z as z56 } from "zod";
var electrolytic_def = z56.object({
  fn: z56.string(),
  p: length43.optional().default("7.5mm"),
  id: length43.optional().default("1mm"),
  od: length43.optional().default("2mm"),
  d: length43.optional().default("10.5mm")
});
var generate_circle_arcs = (centerX, centerY, radius, cut, cutHeight) => {
  const topArc = [];
  const bottomArc = [];
  for (let i = 0; i <= 50; i++) {
    const theta = i / 50 * Math.PI;
    const x = centerX + Math.cos(theta) * radius;
    const y = centerY + Math.sin(theta) * radius;
    if (x < centerX - cut && y >= centerY - cutHeight / 2 && y <= centerY + cutHeight / 2) {
      continue;
    }
    topArc.push({ x, y });
  }
  for (let i = 0; i <= 50; i++) {
    const theta = Math.PI + i / 50 * Math.PI;
    const x = centerX + Math.cos(theta) * radius;
    const y = centerY + Math.sin(theta) * radius;
    if (x < centerX - cut && y >= centerY - cutHeight / 2 && y <= centerY + cutHeight / 2) {
      continue;
    }
    bottomArc.push({ x, y });
  }
  return { topArc, bottomArc };
};
var electrolytic = (raw_params) => {
  const parameters = electrolytic_def.parse(raw_params);
  const { p, id, od, d } = parameters;
  const plated_holes = [
    platedhole(1, -p / 2, 0, id, od),
    platedhole(2, p / 2, 0, id, od)
  ];
  const { topArc, bottomArc } = generate_circle_arcs(
    0,
    0,
    d / 2 + 0.1,
    od / 2,
    od
  );
  const silkscreenBody2 = {
    type: "pcb_silkscreen_path",
    layer: "top",
    pcb_component_id: "",
    route: topArc,
    stroke_width: 0.1,
    pcb_silkscreen_path_id: ""
  };
  const silkscreenBody3 = {
    type: "pcb_silkscreen_path",
    layer: "top",
    pcb_component_id: "",
    route: bottomArc,
    stroke_width: 0.1,
    pcb_silkscreen_path_id: ""
  };
  const silkscreenBody = {
    type: "pcb_silkscreen_path",
    layer: "top",
    pcb_component_id: "",
    route: [
      { x: 0, y: d / 2 + 0.1 },
      { x: 0, y: -(d / 2 + 0.1) }
    ],
    stroke_width: 0.1,
    pcb_silkscreen_path_id: ""
  };
  const X = -(d / 2 + 0.5);
  const plusY = od / 2 + 1.5;
  const Size = 0.5;
  const silkscreenpath2 = {
    type: "pcb_silkscreen_path",
    layer: "top",
    pcb_component_id: "",
    route: [
      { x: X - Size, y: plusY },
      { x: X + Size, y: plusY }
    ],
    stroke_width: 0.1,
    pcb_silkscreen_path_id: ""
  };
  const silkscreenline = {
    type: "pcb_silkscreen_path",
    layer: "top",
    pcb_component_id: "",
    route: [
      { x: X, y: plusY - Size },
      { x: X, y: plusY + Size }
    ],
    stroke_width: 0.1,
    pcb_silkscreen_path_id: ""
  };
  const silkscreenRefText = silkscreenRef(0, d / 2 + 1, 0.5);
  return {
    circuitJson: [
      ...plated_holes,
      silkscreenBody2,
      silkscreenBody3,
      silkscreenBody,
      silkscreenpath2,
      silkscreenline,
      silkscreenRefText
    ],
    parameters
  };
};

// src/fn/smbf.ts
import { z as z57 } from "zod";
import { length as length44 } from "circuit-json";
var smbf_def = z57.object({
  fn: z57.string(),
  num_pins: z57.literal(2).default(2),
  w: z57.string().default("6.5mm"),
  h: z57.string().default("3mm"),
  pl: z57.string().default("1.75mm"),
  pw: z57.string().default("2.40mm"),
  p: z57.string().default("4.75mm")
});
var smbf = (raw_params) => {
  const parameters = smbf_def.parse(raw_params);
  const silkscreenRefText = silkscreenRef(
    0,
    length44.parse(parameters.h) - 0.5,
    0.3
  );
  const silkscreenLine = {
    type: "pcb_silkscreen_path",
    layer: "top",
    pcb_component_id: "",
    route: [
      {
        x: length44.parse(parameters.p) / 2,
        y: length44.parse(parameters.h) / 2
      },
      {
        x: -length44.parse(parameters.w) / 2 - 0.3,
        y: length44.parse(parameters.h) / 2
      },
      {
        x: -length44.parse(parameters.w) / 2 - 0.3,
        y: -length44.parse(parameters.h) / 2
      },
      {
        x: length44.parse(parameters.p) / 2,
        y: -length44.parse(parameters.h) / 2
      }
    ],
    stroke_width: 0.1,
    pcb_silkscreen_path_id: ""
  };
  return {
    circuitJson: smbfWithoutParsing(parameters).concat(
      silkscreenLine,
      silkscreenRefText
    ),
    parameters
  };
};
var getSmbfCoords = (parameters) => {
  const { pn, p } = parameters;
  if (pn === 1) {
    return { x: -p / 2, y: 0 };
  }
  return { x: p / 2, y: 0 };
};
var smbfWithoutParsing = (parameters) => {
  const pads = [];
  for (let i = 1; i <= parameters.num_pins; i++) {
    const { x, y } = getSmbfCoords({
      pn: i,
      p: Number.parseFloat(parameters.p)
    });
    pads.push(
      rectpad(
        i,
        x,
        y,
        Number.parseFloat(parameters.pl),
        Number.parseFloat(parameters.pw)
      )
    );
  }
  return pads;
};

// src/fn/sot323.ts
import { z as z58 } from "zod";
var sot323_def = z58.object({
  fn: z58.string(),
  num_pins: z58.number().default(3),
  w: z58.string().default("2.45mm"),
  h: z58.string().default("2.40mm"),
  pl: z58.string().default("0.45mm"),
  pw: z58.string().default("0.70mm"),
  p: z58.string().default("1mm"),
  string: z58.string().optional()
});
var sot323 = (raw_params) => {
  const match = raw_params.string?.match(/^sot323_(\d+)/);
  const numPins = match ? Number.parseInt(match[1], 3) : 3;
  const parameters = sot323_def.parse({
    ...raw_params,
    num_pins: numPins
  });
  if (parameters.num_pins === 3) {
    return {
      circuitJson: sot323_3(parameters),
      parameters
    };
  }
  throw new Error("Invalid number of pins");
};
var getCcwSot323Coords = (parameters) => {
  const { pn, w, h, pl, p } = parameters;
  if (pn === 1) {
    return { x: -p, y: 0.65 };
  }
  if (pn === 2) {
    return { x: -p, y: -0.65 };
  }
  return { x: p, y: 0 };
};
var sot323_3 = (parameters) => {
  const pads = [];
  for (let i = 0; i < parameters.num_pins; i++) {
    const { x, y } = getCcwSot323Coords({
      num_pins: parameters.num_pins,
      pn: i + 1,
      w: Number.parseFloat(parameters.w),
      h: Number.parseFloat(parameters.h),
      pl: Number.parseFloat(parameters.pl),
      p: Number.parseFloat(parameters.p)
    });
    pads.push(
      rectpad(
        i + 1,
        x,
        y,
        Number.parseFloat(parameters.pl),
        Number.parseFloat(parameters.pw)
      )
    );
  }
  const silkscreenRefText = silkscreenRef(
    0,
    Number.parseInt(parameters.h) / 2 + 1,
    0.3
  );
  const width = Number.parseFloat(parameters.w) / 2 - Number.parseFloat(parameters.pl);
  const height = Number.parseFloat(parameters.h) / 2;
  const silkscreenPath1 = {
    layer: "top",
    pcb_component_id: "",
    pcb_silkscreen_path_id: "silkscreen_path_1",
    route: [
      { x: -width, y: height + 0.3 },
      { x: width, y: height + 0.3 },
      { x: width, y: height / 2 }
    ],
    type: "pcb_silkscreen_path",
    stroke_width: 0.1
  };
  const silkscreenPath2 = {
    layer: "top",
    pcb_component_id: "",
    pcb_silkscreen_path_id: "silkscreen_path_2",
    route: [
      { x: -width, y: -height - 0.3 },
      { x: width, y: -height - 0.3 },
      { x: width, y: -height / 2 }
    ],
    type: "pcb_silkscreen_path",
    stroke_width: 0.1
  };
  return [
    ...pads,
    silkscreenPath1,
    silkscreenPath2,
    silkscreenRefText
  ];
};

// src/fn/smtpad.ts
import { z as z59 } from "zod";
import { length as length45 } from "circuit-json";
import { mm as mm6 } from "@tscircuit/mm";
var smtpad_def = z59.object({
  fn: z59.string(),
  circle: z59.boolean().optional(),
  rect: z59.boolean().optional(),
  square: z59.boolean().optional(),
  d: length45.optional(),
  pd: length45.optional(),
  diameter: length45.optional(),
  r: length45.optional(),
  pr: length45.optional(),
  radius: length45.optional(),
  w: length45.optional(),
  pw: length45.optional(),
  width: length45.optional(),
  h: length45.optional(),
  ph: length45.optional(),
  height: length45.optional(),
  s: length45.optional(),
  size: length45.optional(),
  string: z59.string().optional()
}).transform((v) => {
  let shape = "rect";
  if (v.circle) shape = "circle";
  if (v.square) shape = "square";
  if (v.rect) shape = "rect";
  let radius;
  let width;
  let height;
  if (shape === "circle") {
    if (v.r !== void 0) radius = mm6(v.r);
    else if (v.pr !== void 0) radius = mm6(v.pr);
    else if (v.radius !== void 0) radius = mm6(v.radius);
    else if (v.d !== void 0) radius = mm6(v.d) / 2;
    else if (v.pd !== void 0) radius = mm6(v.pd) / 2;
    else if (v.diameter !== void 0) radius = mm6(v.diameter) / 2;
    else radius = mm6("1mm") / 2;
  } else {
    if (v.w !== void 0) width = mm6(v.w);
    else if (v.pw !== void 0) width = mm6(v.pw);
    else if (v.width !== void 0) width = mm6(v.width);
    else if (v.s !== void 0) width = mm6(v.s);
    else if (v.size !== void 0) width = mm6(v.size);
    else width = mm6("1mm");
    if (v.h !== void 0) height = mm6(v.h);
    else if (v.ph !== void 0) height = mm6(v.ph);
    else if (v.height !== void 0) height = mm6(v.height);
    else height = width;
  }
  return {
    fn: v.fn,
    shape,
    radius,
    width,
    height
  };
});
var smtpad = (raw_params) => {
  const params = smtpad_def.parse(raw_params);
  const { shape, radius, width, height } = params;
  return {
    circuitJson: [
      shape === "circle" ? circlepad(1, { x: 0, y: 0, radius }) : rectpad(1, 0, 0, width, height),
      silkscreenRef(
        0,
        shape === "circle" ? radius + 0.5 : height / 2 + 0.5,
        0.2
      )
    ],
    parameters: params
  };
};

// src/fn/platedhole.ts
import { z as z60 } from "zod";
import { length as length46 } from "circuit-json";
import { mm as mm7 } from "@tscircuit/mm";
var platedhole_def = z60.object({
  fn: z60.string(),
  d: length46.optional(),
  hd: length46.optional(),
  r: length46.optional(),
  hr: length46.optional(),
  pd: length46.optional(),
  pr: length46.optional(),
  squarepad: z60.boolean().optional().default(false)
}).transform((v) => {
  let holeD;
  if (v.d !== void 0) holeD = mm7(v.d);
  else if (v.hd !== void 0) holeD = mm7(v.hd);
  else if (v.r !== void 0) holeD = mm7(v.r) * 2;
  else if (v.hr !== void 0) holeD = mm7(v.hr) * 2;
  else holeD = mm7("1mm");
  let padD;
  if (v.pd !== void 0) padD = mm7(v.pd);
  else if (v.pr !== void 0) padD = mm7(v.pr) * 2;
  else padD = holeD * (1.5 / 1);
  return {
    fn: v.fn,
    d: holeD,
    pd: padD,
    squarepad: v.squarepad ?? false
  };
});
var platedhole3 = (raw_params) => {
  const params = platedhole_def.parse(raw_params);
  const { d, pd, squarepad } = params;
  return {
    circuitJson: [
      squarepad ? platedHoleWithRectPad(1, 0, 0, d, pd, pd) : platedhole(1, 0, 0, d, pd),
      silkscreenRef(0, pd / 2 + 0.5, 0.2)
    ],
    parameters: params
  };
};

// src/fn/sot.ts
import { z as z61 } from "zod";
var sot_def = z61.object({
  fn: z61.string(),
  num_pins: z61.literal(6).default(6),
  h: z61.string().default("1.6mm"),
  pl: z61.string().default("1mm"),
  pw: z61.string().default("0.7mm"),
  p: z61.string().default("0.95mm")
});
var sot = (raw_params) => {
  const parameters = sot_def.parse(raw_params);
  return {
    circuitJson: sotWithoutParsing(parameters),
    parameters
  };
};
var getCcwSotCoords = (parameters) => {
  const { p, h, pn } = parameters;
  if (pn === 1) {
    return { x: -h / 2 - 0.5, y: p };
  }
  if (pn === 2) {
    return { x: -h / 2 - 0.5, y: 0 };
  }
  if (pn === 3) {
    return { x: -h / 2 - 0.5, y: -p };
  }
  if (pn === 4) {
    return { x: h / 2 + 0.5, y: -p };
  }
  if (pn === 5) {
    return { x: h / 2 + 0.5, y: 0 };
  }
  if (pn === 6) {
    return { x: h / 2 + 0.5, y: p };
  }
  throw new Error("Invalid pin number");
};
var sotWithoutParsing = (parameters) => {
  const pads = [];
  for (let i = 1; i <= parameters.num_pins; i++) {
    const { x, y } = getCcwSotCoords({
      h: Number.parseFloat(parameters.h),
      p: Number.parseFloat(parameters.p),
      pn: i
    });
    pads.push(
      rectpad(
        i,
        x,
        y,
        Number.parseFloat(parameters.pl),
        Number.parseFloat(parameters.pw)
      )
    );
  }
  const width = parameters.num_pins / 2 * Number.parseFloat(parameters.p);
  const height = Number.parseFloat(parameters.h);
  const silkscreenPath1 = {
    layer: "top",
    pcb_component_id: "",
    pcb_silkscreen_path_id: "silkscreen_path_1",
    route: [
      { x: -width / 3, y: height / 2 + Number.parseFloat(parameters.p) / 1.3 },
      { x: width / 3, y: height / 2 + Number.parseFloat(parameters.p) / 1.3 }
    ],
    type: "pcb_silkscreen_path",
    stroke_width: 0.05
  };
  const silkscreenPath2 = {
    layer: "top",
    pcb_component_id: "",
    pcb_silkscreen_path_id: "silkscreen_path_2",
    route: [
      { x: -width / 3, y: -height / 2 - Number.parseFloat(parameters.p) / 1.3 },
      { x: width / 3, y: -height / 2 - Number.parseFloat(parameters.p) / 1.3 }
    ],
    type: "pcb_silkscreen_path",
    stroke_width: 0.05
  };
  const silkscreenRefText = silkscreenRef(0, height + 0.3, 0.3);
  const pin1Position = getCcwSotCoords({
    h: Number.parseFloat(parameters.h),
    p: Number.parseFloat(parameters.p),
    pn: 1
  });
  pin1Position.x = pin1Position.x - Number.parseFloat(parameters.pw) * 1.5;
  const triangleHeight = 0.7;
  const triangleWidth = 0.3;
  const pin1Indicator = {
    type: "pcb_silkscreen_path",
    layer: "top",
    pcb_component_id: "",
    pcb_silkscreen_path_id: "pin1_indicator",
    route: [
      {
        x: pin1Position.x + triangleHeight / 2,
        y: pin1Position.y
      },
      {
        x: pin1Position.x - triangleHeight / 2,
        y: pin1Position.y + triangleWidth / 2
      },
      {
        x: pin1Position.x - triangleHeight / 2,
        y: pin1Position.y - triangleWidth / 2
      },
      {
        x: pin1Position.x + triangleHeight / 2,
        y: pin1Position.y
      }
    ],
    stroke_width: 0.05
  };
  return [
    ...pads,
    silkscreenRefText,
    silkscreenPath1,
    silkscreenPath2,
    pin1Indicator
  ];
};

// src/fn/m2host.ts
import { z as z62 } from "zod";
var m2host_def = z62.object({
  fn: z62.string()
});
var m2host = (raw_params) => {
  const parameters = m2host_def.parse(raw_params);
  const pads = [];
  const padWidth = 0.5 - 0.15;
  const padLength = 1.5;
  const pitch = 0.5;
  const halfPitch = pitch / 2;
  const rowOffset = 0.5;
  const numPads = 75;
  const startY = -((numPads - 1) * pitch) / 2;
  for (let i = 0; i < numPads; i++) {
    const pn = i + 1;
    if (pn >= 24 && pn <= 31) continue;
    const y = startY - i * halfPitch;
    const x = i % 2 === 0 ? 0 : -rowOffset / 2;
    const padLengthWithOffset = padLength + (i % 2 === 0 ? 0 : 0.25);
    const pad2 = rectpad(pn, x, y, padLengthWithOffset, padWidth);
    pad2.layer = pn % 2 === 0 ? "bottom" : "top";
    pads.push(pad2);
  }
  const cutoutWidth = 46 * 0.0254;
  const cutoutDepth = 137 * 0.0254;
  const cutoutOffsetFromPin1 = 261 * 0.0254;
  const cutout = {
    type: "pcb_cutout",
    pcb_cutout_id: "",
    shape: "rect",
    center: {
      x: -cutoutDepth / 2 + padLength / 2,
      y: startY - cutoutOffsetFromPin1
    },
    width: cutoutDepth,
    height: cutoutWidth
  };
  const pin1MarkerPosition = {
    x: -0.5,
    y: startY
  };
  const pin1Marker = {
    type: "pcb_silkscreen_path",
    layer: "top",
    pcb_component_id: "pin_marker_1",
    route: [
      { x: pin1MarkerPosition.x - 0.4, y: pin1MarkerPosition.y },
      { x: pin1MarkerPosition.x - 0.7, y: pin1MarkerPosition.y + 0.3 },
      { x: pin1MarkerPosition.x - 0.7, y: pin1MarkerPosition.y - 0.3 },
      { x: pin1MarkerPosition.x - 0.4, y: pin1MarkerPosition.y }
    ],
    stroke_width: 0.05,
    pcb_silkscreen_path_id: "pin_marker_1"
  };
  return {
    circuitJson: [
      ...pads,
      cutout,
      // silkscreenRefText,
      pin1Marker
    ],
    parameters
  };
};

// src/helpers/is-not-null.ts
function isNotNull(value) {
  return value !== null;
}

// src/footprinter.ts
var string2 = (def) => {
  let fp2 = footprinter();
  const modifiedDef = def.replace(/^((?:\d{4}|\d{5}))(?=$|_)/, "res$1");
  const def_parts = modifiedDef.split("_").map((s) => {
    const m = s.match(/([a-z]+)([\(\d\.\+\?].*)?/);
    const [_, fn, v] = m ?? [];
    if (v?.includes("?")) return null;
    return { fn, v: m?.[2] };
  }).filter(isNotNull);
  for (const { fn, v } of def_parts) {
    fp2 = fp2[fn](v);
  }
  fp2.setString(def);
  return fp2;
};
var getFootprintNames = () => {
  return Object.keys(fn_exports);
};
var getFootprintSizes = () => {
  return footprintSizes;
};
var getFootprintNamesByType = () => {
  const allFootprintNames = Object.keys(fn_exports);
  const passiveFootprintNames = allFootprintNames.filter((name) => {
    const fn = fn_exports[name];
    return fn.toString().includes("passive(");
  });
  return {
    passiveFootprintNames,
    normalFootprintNames: allFootprintNames.filter(
      (name) => !passiveFootprintNames.includes(name)
    )
  };
};
var footprinter = () => {
  const proxy = new Proxy(
    {},
    {
      get: (target, prop) => {
        if (prop === "soup" || prop === "circuitJson") {
          if ("fn" in target && fn_exports[target.fn]) {
            return () => fn_exports[target.fn](target).circuitJson;
          }
          if (!fn_exports[target.fn]) {
            throw new Error(
              `Invalid footprint function, got "${target.fn}"${target.string ? `, from string "${target.string}"` : ""}`
            );
          }
          return () => {
            throw new Error(
              `No function found for footprinter, make sure to specify .dip, .lr, .p, etc. Got "${prop}"`
            );
          };
        }
        if (prop === "json") {
          if (!fn_exports[target.fn]) {
            throw new Error(
              `Invalid footprint function, got "${target.fn}"${target.string ? `, from string "${target.string}"` : ""}`
            );
          }
          return () => fn_exports[target.fn](target).parameters;
        }
        if (prop === "getFootprintNames") {
          return () => Object.keys(fn_exports);
        }
        if (prop === "params") {
          return () => target;
        }
        if (prop === "setString") {
          return (v) => {
            target.string = v;
            return proxy;
          };
        }
        return (v) => {
          if (Object.keys(target).length === 0) {
            if (`${prop}${v}` in fn_exports) {
              target[`${prop}${v}`] = true;
              target.fn = `${prop}${v}`;
            } else {
              target[prop] = true;
              target.fn = prop;
              if (prop === "res" || prop === "cap") {
                if (v) {
                  target.imperial = v;
                }
              } else {
                target.num_pins = Number.isNaN(Number.parseFloat(v)) ? void 0 : Number.parseFloat(v);
              }
            }
          } else {
            if (!v && ["w", "h", "p"].includes(prop)) {
            } else {
              target[prop] = v ?? true;
            }
          }
          return proxy;
        };
      }
    }
  );
  return proxy;
};
footprinter.string = string2;
footprinter.getFootprintNames = getFootprintNames;
var fp = footprinter;
export {
  footprinter,
  fp,
  getFootprintNames,
  getFootprintNamesByType,
  getFootprintSizes,
  string2 as string
};
//# sourceMappingURL=index.js.map