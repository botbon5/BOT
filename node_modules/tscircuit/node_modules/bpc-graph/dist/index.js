// lib/graph-utils/center.ts
var center = (obj) => {
  if (!obj) {
    return { x: 0, y: 0 };
  }
  if ("x" in obj && "y" in obj) {
    return obj;
  }
  if ("center" in obj) {
    return obj.center;
  }
  return {
    x: (obj.minX + obj.maxX) / 2,
    y: (obj.minY + obj.maxY) / 2
  };
};

// lib/graph-utils/getBoundsOfBpcBox.ts
var getBoundsOfBpcBox = (graph, boxId) => {
  const box = graph.boxes.find((b) => b.boxId === boxId);
  const pins = graph.pins.filter((p) => p.boxId === boxId);
  if (!box) {
    throw new Error(`Box "${boxId}" not found`);
  }
  const boxCenter = box.center ?? { x: 0, y: 0 };
  let minX = Infinity;
  let minY = Infinity;
  let maxX = -Infinity;
  let maxY = -Infinity;
  for (const pin of pins) {
    minX = Math.min(minX, pin.offset.x + boxCenter.x);
    minY = Math.min(minY, pin.offset.y + boxCenter.y);
    maxX = Math.max(maxX, pin.offset.x + boxCenter.x);
    maxY = Math.max(maxY, pin.offset.y + boxCenter.y);
  }
  return {
    minX,
    minY,
    maxX,
    maxY
  };
};

// lib/graph-utils/getColorByIndex.ts
var getColorByIndex = (index, total, opacity) => {
  const hue = index * 360 / total;
  return `hsl(${hue}, 100%, 50%, ${opacity ?? 1})`;
};

// lib/graph-utils/getGraphBounds.ts
var getGraphBounds = (g) => {
  let minX = Infinity;
  let minY = Infinity;
  let maxX = -Infinity;
  let maxY = -Infinity;
  if (g.boxes.length === 0) {
    return {
      minX: 0,
      minY: 0,
      maxX: 0,
      maxY: 0
    };
  }
  for (const box of g.boxes) {
    const bounds = getBoundsOfBpcBox(g, box.boxId);
    minX = Math.min(minX, bounds.minX);
    minY = Math.min(minY, bounds.minY);
    maxX = Math.max(maxX, bounds.maxX);
    maxY = Math.max(maxY, bounds.maxY);
  }
  return {
    minX,
    minY,
    maxX,
    maxY
  };
};

// lib/graph-utils/getGraphNetworkIds.ts
var getGraphNetworkIds = (g) => {
  const networkIds = /* @__PURE__ */ new Set();
  for (const pin of g.pins) {
    networkIds.add(pin.networkId);
  }
  return Array.from(networkIds);
};

// lib/debug/getGraphicsForBpcGraph.ts
import { getBounds } from "graphics-debug";

// lib/debug/translateColor.ts
var COLOR_MAPPINGS = {
  not_connected: "rgba(0, 0, 0, 0.2)",
  normal: "blue",
  vcc: "orange",
  gnd: "purple",
  component_center: "gray"
};
var COMMON_COLORS = [
  "red",
  "green",
  "blue",
  "yellow",
  "purple",
  "orange",
  "brown",
  "gray",
  "black",
  "white"
];
function hashString(str) {
  let hash = 0;
  for (let i = 0; i < str.length; i++) {
    hash = (hash << 5) - hash + str.charCodeAt(i);
  }
  return hash;
}
var translateColor = (color) => {
  if (color.startsWith("rgb") || color.startsWith("hsl") || color.startsWith("#") || COMMON_COLORS.includes(color)) {
    return color;
  }
  if (color in COLOR_MAPPINGS) {
    return COLOR_MAPPINGS[color];
  }
  return getColorByIndex(hashString(color) % 50, 50);
};

// lib/debug/getGraphicsForBpcGraph.ts
var getGraphicsForBpcGraph = (g, opts) => {
  const graphics = {
    points: [],
    lines: [],
    rects: [],
    circles: [],
    texts: [],
    coordinateSystem: "cartesian",
    title: "BPC Graph Graphics"
  };
  const pinPositions = /* @__PURE__ */ new Map();
  const positionGroups = /* @__PURE__ */ new Map();
  for (const box of g.boxes) {
    const bounds2 = getBoundsOfBpcBox(g, box.boxId);
    const boundsCenter = center(bounds2);
    graphics.rects.push({
      label: box.boxId,
      center: boundsCenter,
      width: bounds2.maxX - bounds2.minX + 0.1,
      height: bounds2.maxY - bounds2.minY + 0.1,
      fill: "rgba(0, 0, 0, 0.2)"
    });
    const boxPins = g.pins.filter((p) => p.boxId === box.boxId);
    const boxCenter = box.center ?? { x: 0, y: 0 };
    for (const pin of boxPins) {
      const pinPosition = {
        x: pin.offset.x + boxCenter.x,
        y: pin.offset.y + boxCenter.y
      };
      const positionKey = `${pinPosition.x.toFixed(6)},${pinPosition.y.toFixed(6)}`;
      if (!positionGroups.has(positionKey)) {
        positionGroups.set(positionKey, []);
      }
      positionGroups.get(positionKey).push({ box, pin });
      pinPositions.set(`${box.boxId}.${pin.pinId}`, pinPosition);
    }
  }
  for (const [positionKey, items] of positionGroups) {
    const coordinates = positionKey.split(",").map(Number);
    const baseX = coordinates[0];
    const baseY = coordinates[1];
    for (let i = 0; i < items.length; i++) {
      const item = items[i];
      const { box, pin } = item;
      let adjustedPosition = { x: baseX, y: baseY };
      if (items.length > 1) {
        const boxCenter = box.center ?? { x: 0, y: 0 };
        const directionX = boxCenter.x - baseX;
        const directionY = boxCenter.y - baseY;
        const distance = Math.sqrt(
          directionX * directionX + directionY * directionY
        );
        let unitX = 0;
        let unitY = 0;
        if (distance > 0) {
          unitX = directionX / distance;
          unitY = directionY / distance;
        } else {
          const offsetAngle = i * 2 * Math.PI / items.length;
          unitX = Math.cos(offsetAngle);
          unitY = Math.sin(offsetAngle);
        }
        adjustedPosition = {
          x: baseX + 0.01 * unitX,
          y: baseY + 0.01 * unitY
        };
      }
      pinPositions.set(`${box.boxId}.${pin.pinId}`, adjustedPosition);
      graphics.points.push({
        ...adjustedPosition,
        label: [pin.pinId, pin.color, pin.networkId].join("\n"),
        color: translateColor(pin.color)
      });
    }
  }
  const networks = getGraphNetworkIds(g);
  for (let ni = 0; ni < networks.length; ni++) {
    const networkId = networks[ni];
    const networkColor = getColorByIndex(ni, networks.length, 0.5);
    const pins = g.pins.filter((p) => p.networkId === networkId);
    const pinsInNetworkWithPosition = pins.map((pin) => ({
      pin,
      position: pinPositions.get(`${pin.boxId}.${pin.pinId}`)
    }));
    for (let i = 0; i < pinsInNetworkWithPosition.length; i++) {
      const { position: pos1 } = pinsInNetworkWithPosition[i];
      for (let j = i + 1; j < pinsInNetworkWithPosition.length; j++) {
        const { position: pos2 } = pinsInNetworkWithPosition[j];
        graphics.lines.push({
          points: [pos1, pos2],
          strokeColor: opts?.grayNetworks ? "rgba(0, 0, 0, 0.05)" : networkColor
        });
      }
    }
  }
  const bounds = getBounds(graphics);
  if (opts?.title) {
    graphics.title = opts.title;
    graphics.texts.push({
      text: opts.title,
      x: bounds.minX,
      y: bounds.maxY,
      fontSize: (bounds.maxY - bounds.minY) * 0.05,
      anchorSide: "bottom_left"
    });
  }
  if (opts?.caption) {
    graphics.texts.push({
      text: opts.caption,
      x: bounds.minX,
      y: bounds.minY,
      fontSize: (bounds.maxY - bounds.minY) * 0.05,
      anchorSide: "top_left"
    });
  }
  return graphics;
};

// lib/graph-utils/getPinPosition.ts
var getPinPosition = (g, boxId, pinId) => {
  const pin = g.pins.find((p) => p.pinId === pinId && p.boxId === boxId);
  if (!pin) {
    throw new Error(`Pin "${pinId}" not found`);
  }
  const box = g.boxes.find((b) => b.boxId === pin.boxId);
  if (!box) {
    throw new Error(`Box "${pin.boxId}" not found`);
  }
  const boxCenter = box.center ?? { x: 0, y: 0 };
  return {
    x: pin.offset.x + boxCenter.x,
    y: pin.offset.y + boxCenter.y
  };
};

// lib/graph-utils/getPinDirection.ts
var getPinDirectionOrThrow = (g, boxIdOrBox, pinIdOrPin) => {
  const pin = typeof pinIdOrPin === "string" ? g.pins.find((p) => p.pinId === pinIdOrPin && p.boxId === boxIdOrBox) : pinIdOrPin;
  if (!pin) {
    throw new Error(`Pin not found "${pinIdOrPin}"`);
  }
  const box = typeof boxIdOrBox === "string" ? g.boxes.find((b) => b.boxId === boxIdOrBox) : boxIdOrBox;
  if (!box) {
    throw new Error(
      `Box not found for pin "${pinIdOrPin}" (looked for "${pin.boxId}")`
    );
  }
  const bounds = getBoundsOfBpcBox(g, pin.boxId);
  const pinPosition = getPinPosition(g, pin.boxId, pin.pinId);
  const width = bounds.maxX - bounds.minX;
  const height = bounds.maxY - bounds.minY;
  if (width === 0 && height === 0) {
    if (Math.abs(pin.offset.x) > Math.abs(pin.offset.y)) {
      return pin.offset.x > 0 ? "x+" : "x-";
    } else {
      return pin.offset.y > 0 ? "y+" : "y-";
    }
  }
  if (width === 0) {
    if (Math.abs(pinPosition.y - bounds.minY) < 1e-4) {
      return "y-";
    }
    if (Math.abs(pinPosition.y - bounds.maxY) < 1e-4) {
      return "y+";
    }
  }
  if (height === 0) {
    if (Math.abs(pinPosition.x - bounds.minX) < 1e-4) {
      return "x-";
    }
    if (Math.abs(pinPosition.x - bounds.maxX) < 1e-4) {
      return "x+";
    }
  }
  const onLeftEdge = Math.abs(pinPosition.x - bounds.minX) < 1e-4;
  const onRightEdge = Math.abs(pinPosition.x - bounds.maxX) < 1e-4;
  const onBottomEdge = Math.abs(pinPosition.y - bounds.minY) < 1e-4;
  const onTopEdge = Math.abs(pinPosition.y - bounds.maxY) < 1e-4;
  if ((onLeftEdge || onRightEdge) && (onBottomEdge || onTopEdge)) {
    return pin.offset.x > 0 ? "x+" : "x-";
  }
  if (onLeftEdge) {
    return "x-";
  }
  if (onRightEdge) {
    return "x+";
  }
  if (onBottomEdge) {
    return "y-";
  }
  if (onTopEdge) {
    return "y+";
  }
  throw new Error(
    `Pin "${pin.pinId}" not on the edge of the box "${pin.boxId}" so we couldn't determine the direction`
  );
};
var getPinDirection = (g, boxIdOrBox, pinIdOrPin) => {
  try {
    return getPinDirectionOrThrow(g, boxIdOrBox, pinIdOrPin);
  } catch (e) {
    return null;
  }
};

// lib/generic-solvers/BaseSolver.ts
var BaseSolver = class {
  MAX_ITERATIONS = 1e3;
  solved = false;
  failed = false;
  iterations = 0;
  progress = 0;
  error = null;
  _activeSubSolver;
  usedSubSolvers = [];
  failedSubSolvers;
  timeToSolve;
  stats = {};
  /** DO NOT OVERRIDE! Override _step() instead */
  step() {
    if (this.solved) return;
    if (this.failed) return;
    this.iterations++;
    try {
      this._step();
    } catch (e) {
      this.error = `${this.constructor.name} error: ${e}`;
      console.error(this.error);
      this.failed = true;
      throw e;
    }
    if (!this.solved && this.iterations > this.MAX_ITERATIONS) {
      this.error = `${this.constructor.name} ran out of iterations`;
      console.error(this.error);
      this.failed = true;
    }
    if ("computeProgress" in this) {
      this.progress = this.computeProgress();
    }
  }
  _step() {
  }
  getStatsSummary() {
    return `${this.iterations} iterations`;
  }
  get activeSubSolver() {
    return this._activeSubSolver;
  }
  getConstructorParams() {
    throw new Error("getConstructorParams not implemented");
  }
  clearActiveSubSolver() {
    this._activeSubSolver = null;
  }
  setActiveSubSolver(subSolver) {
    this._activeSubSolver = subSolver;
    if (subSolver) {
      this.usedSubSolvers.push(subSolver);
    }
  }
  visualize() {
    return {};
  }
  solve() {
    const startTime = Date.now();
    while (!this.solved && !this.failed) {
      this.step();
    }
    const endTime = Date.now();
    this.timeToSolve = endTime - startTime;
  }
};

// lib/force-directed-layout/addBoxRepulsionForces.ts
function calculateEdgeToEdgeDistance(bounds1, bounds2) {
  let sep_x = 0;
  if (bounds1.maxX < bounds2.minX) {
    sep_x = bounds2.minX - bounds1.maxX;
  } else if (bounds2.maxX < bounds1.minX) {
    sep_x = bounds1.minX - bounds2.maxX;
  }
  let sep_y = 0;
  if (bounds1.maxY < bounds2.minY) {
    sep_y = bounds2.minY - bounds1.maxY;
  } else if (bounds2.maxY < bounds1.minY) {
    sep_y = bounds1.minY - bounds2.maxY;
  }
  if (sep_x > 0 && sep_y > 0) {
    return Math.sqrt(sep_x * sep_x + sep_y * sep_y);
  } else if (sep_x > 0) {
    return sep_x;
  } else if (sep_y > 0) {
    return sep_y;
  } else {
    return 0;
  }
}
var addBoxRepulsionForces = (g, appliedForces, hyperParameters) => {
  for (let i = 0; i < g.boxes.length; i++) {
    for (let j = i + 1; j < g.boxes.length; j++) {
      const box1 = g.boxes[i];
      const box2 = g.boxes[j];
      const bounds1 = getBoundsOfBpcBox(g, box1.boxId);
      const bounds2 = getBoundsOfBpcBox(g, box2.boxId);
      const edgeDistance = calculateEdgeToEdgeDistance(bounds1, bounds2);
      const D1 = hyperParameters.BOX_REPEL_DISTANCE1;
      const D2 = hyperParameters.BOX_REPEL_DISTANCE2;
      const power = hyperParameters.BOX_CLOSE_REPULSION_POWER;
      const minEffectiveEdgeDist = hyperParameters.BOX_MIN_EFFECTIVE_EDGE_DISTANCE;
      let forceFactor;
      if (edgeDistance <= D1) {
        const effectiveEdgeDist = Math.max(edgeDistance, minEffectiveEdgeDist);
        if (D1 > 0 && effectiveEdgeDist > 0) {
          forceFactor = (D1 / effectiveEdgeDist) ** power;
        } else {
          forceFactor = edgeDistance <= 0 ? hyperParameters.BOX_REPEL_DISTANCE1 > 0 && minEffectiveEdgeDist > 0 ? (hyperParameters.BOX_REPEL_DISTANCE1 / minEffectiveEdgeDist) ** power : 100 : 1;
        }
      } else if (edgeDistance >= D2 || D1 >= D2) {
        forceFactor = 0;
      } else {
        forceFactor = (D2 - edgeDistance) / (D2 - D1);
      }
      if (forceFactor <= 0) {
        continue;
      }
      const center1 = box1.kind === "fixed" ? box1.center : box1.center;
      const center2 = box2.kind === "fixed" ? box2.center : box2.center;
      const dx = center1.x - center2.x;
      const dy = center1.y - center2.y;
      const distanceSquared = dx * dx + dy * dy;
      if (distanceSquared === 0) continue;
      const distance = Math.sqrt(distanceSquared);
      const baseForceMagnitude = hyperParameters.BOX_REPULSION_STRENGTH / distanceSquared;
      const finalForceMagnitude = baseForceMagnitude * forceFactor;
      const forceX = dx / distance * finalForceMagnitude;
      const forceY = dy / distance * finalForceMagnitude;
      const force1 = {
        x: forceX,
        y: forceY,
        sourceStage: "box-repel"
      };
      const force2 = {
        x: -forceX,
        y: -forceY,
        sourceStage: "box-repel"
      };
      if (box1.kind === "floating") {
        if (!appliedForces.has(box1.boxId)) appliedForces.set(box1.boxId, []);
        appliedForces.get(box1.boxId).push(force1);
      }
      if (box2.kind === "floating") {
        if (!appliedForces.has(box2.boxId)) appliedForces.set(box2.boxId, []);
        appliedForces.get(box2.boxId).push(force2);
      }
    }
  }
};

// lib/force-directed-layout/addPinAlignmentForces.ts
var addPinAlignmentForces = (g, appliedForces, hyperParameters) => {
  const networkIds = getGraphNetworkIds(g);
  const alignmentStrength = hyperParameters.PIN_ALIGNMENT_STRENGTH;
  for (const networkId of networkIds) {
    const pinsInNetwork = g.pins.filter((p) => p.networkId === networkId);
    for (const pinEmitter of pinsInNetwork) {
      const emitterPos = getPinPosition(g, pinEmitter.boxId, pinEmitter.pinId);
      const emitterDir = getPinDirectionOrThrow(
        g,
        pinEmitter.boxId,
        pinEmitter.pinId
      );
      for (const pinTarget of pinsInNetwork) {
        if (pinEmitter.pinId === pinTarget.pinId) continue;
        const targetPos = getPinPosition(g, pinTarget.boxId, pinTarget.pinId);
        let forceX = 0;
        let forceY = 0;
        const activateDistance = hyperParameters.PIN_ALIGNMENT_ACTIVATE_DISTANCE;
        const guidelineLength = hyperParameters.PIN_ALIGNMENT_GUIDELINE_LENGTH;
        if (emitterDir === "x+" || emitterDir === "x-") {
          const deltaYOrthogonal = emitterPos.y - targetPos.y;
          const deltaXParallel = targetPos.x - emitterPos.x;
          const withinActivateDistance = Math.abs(deltaYOrthogonal) <= activateDistance;
          let withinGuidelineLength = false;
          if (emitterDir === "x+") {
            withinGuidelineLength = deltaXParallel >= 0 && deltaXParallel <= guidelineLength;
          } else {
            withinGuidelineLength = deltaXParallel <= 0 && deltaXParallel >= -guidelineLength;
          }
          if (withinActivateDistance && withinGuidelineLength) {
            forceY = deltaYOrthogonal * alignmentStrength;
          }
        } else {
          const deltaXOrthogonal = emitterPos.x - targetPos.x;
          const deltaYParallel = targetPos.y - emitterPos.y;
          const withinActivateDistance = Math.abs(deltaXOrthogonal) <= activateDistance;
          let withinGuidelineLength = false;
          if (emitterDir === "y+") {
            withinGuidelineLength = deltaYParallel >= 0 && deltaYParallel <= guidelineLength;
          } else {
            withinGuidelineLength = deltaYParallel <= 0 && deltaYParallel >= -guidelineLength;
          }
          if (withinActivateDistance && withinGuidelineLength) {
            forceX = deltaXOrthogonal * alignmentStrength;
          }
        }
        if (forceX !== 0 || forceY !== 0) {
          const targetBox = g.boxes.find((b) => b.boxId === pinTarget.boxId);
          if (targetBox && targetBox.kind === "floating") {
            const force = {
              x: forceX,
              y: forceY,
              sourceStage: "pin-align",
              sourcePinId: pinTarget.pinId
            };
            if (!appliedForces.has(targetBox.boxId))
              appliedForces.set(targetBox.boxId, []);
            appliedForces.get(targetBox.boxId).push(force);
          }
        }
      }
    }
  }
};

// lib/force-directed-layout/addNetworkedPinPullingForces.ts
var addNetworkedPinPullingForces = (g, appliedForces, hyperParameters) => {
  const networkIds = getGraphNetworkIds(g);
  for (const networkId of networkIds) {
    const pinsInNetwork = g.pins.filter((p) => p.networkId === networkId);
    for (let i = 0; i < pinsInNetwork.length; i++) {
      for (let j = i + 1; j < pinsInNetwork.length; j++) {
        const pin1 = pinsInNetwork[i];
        const pin2 = pinsInNetwork[j];
        const dir1 = getPinDirectionOrThrow(g, pin1.boxId, pin1.pinId);
        const dir2 = getPinDirectionOrThrow(g, pin2.boxId, pin2.pinId);
        if (dir1 === dir2) {
          continue;
        }
        const pos1 = getPinPosition(g, pin1.boxId, pin1.pinId);
        const pos2 = getPinPosition(g, pin2.boxId, pin2.pinId);
        const dx = pos2.x - pos1.x;
        const dy = pos2.y - pos1.y;
        const springConstant = hyperParameters.PIN_PULL_STRENGTH;
        const networkSize = pinsInNetwork.length;
        const forceDivisor = (networkSize > 0 ? networkSize : 1) ** 2;
        const forceX = dx * springConstant / forceDivisor;
        const forceY = dy * springConstant / forceDivisor;
        const forceOnPin1Box = {
          x: forceX,
          y: forceY,
          sourceStage: "networked-pin-pull",
          sourcePinId: pin1.pinId
        };
        const forceOnPin2Box = {
          x: -forceX,
          y: -forceY,
          sourceStage: "networked-pin-pull",
          sourcePinId: pin2.pinId
        };
        const box1 = g.boxes.find((b) => b.boxId === pin1.boxId);
        const box2 = g.boxes.find((b) => b.boxId === pin2.boxId);
        if (box1 && box1.kind === "floating") {
          if (!appliedForces.has(box1.boxId)) appliedForces.set(box1.boxId, []);
          appliedForces.get(box1.boxId).push(forceOnPin1Box);
        }
        if (box2 && box2.kind === "floating") {
          if (!appliedForces.has(box2.boxId)) appliedForces.set(box2.boxId, []);
          appliedForces.get(box2.boxId).push(forceOnPin2Box);
        }
      }
    }
  }
};

// lib/force-directed-layout/applyForcesToGraph.ts
var applyForcesToGraph = (g, appliedForces, hyperParameters) => {
  const newBoxes = g.boxes.map((box) => {
    if (box.kind === "fixed") {
      return box;
    }
    const forcesOnBox = appliedForces.get(box.boxId) || [];
    if (forcesOnBox.length === 0) {
      return box;
    }
    const totalForce = { x: 0, y: 0 };
    for (const force of forcesOnBox) {
      totalForce.x += force.x;
      totalForce.y += force.y;
    }
    const pinCount = g.pins.filter((p) => p.boxId === box.boxId).length;
    const mass = 1 + pinCount * hyperParameters.PIN_MASS_MULTIPLIER;
    let displacement = {
      x: totalForce.x / mass * hyperParameters.LEARNING_RATE,
      y: totalForce.y / mass * hyperParameters.LEARNING_RATE
    };
    const displacementMagnitude = Math.sqrt(
      displacement.x ** 2 + displacement.y ** 2
    );
    if (displacementMagnitude > hyperParameters.MAX_DISPLACEMENT_PER_STEP) {
      const scale = hyperParameters.MAX_DISPLACEMENT_PER_STEP / displacementMagnitude;
      displacement.x *= scale;
      displacement.y *= scale;
    }
    const currentCenter = box.center;
    const newCenter = {
      x: currentCenter.x + displacement.x,
      y: currentCenter.y + displacement.y
    };
    return {
      ...box,
      center: newCenter
    };
  });
  return {
    ...g,
    boxes: newBoxes
    // Cast to any due to BpcGraph union type complexity
    // This assumes the structure remains valid for either FloatingBpcGraph or FixedBpcGraph
    // or that the consumer can handle mixed types if that's the actual case.
  };
};

// lib/force-directed-layout/ForceDirectedLayoutSolver.ts
var ForceDirectedLayoutSolver = class extends BaseSolver {
  graph;
  lastAppliedForces = /* @__PURE__ */ new Map();
  hyperParameters = {
    DISPLAY_FORCE_LINE_MULTIPLIER: 2,
    BOX_REPULSION_STRENGTH: 2,
    PIN_PULL_STRENGTH: 0.1,
    PIN_ALIGNMENT_STRENGTH: 2,
    PIN_ALIGNMENT_ACTIVATE_DISTANCE: 0.15,
    PIN_ALIGNMENT_GUIDELINE_LENGTH: 10,
    CENTER_OF_GRAPH_STRENGTH: 0.01,
    BOX_REPEL_DISTANCE1: 4,
    BOX_REPEL_DISTANCE2: 8,
    LEARNING_RATE: 0.1,
    MAX_DISPLACEMENT_PER_STEP: 1,
    RANDOM_INITIAL_PLACEMENT_MAX_X: 10,
    RANDOM_INITIAL_PLACEMENT_MAX_Y: 10,
    PIN_MASS_MULTIPLIER: 0.05,
    // Each pin adds 0.1 to the mass factor
    BOX_CLOSE_REPULSION_POWER: 1.1,
    // Results in an inverse square relationship with effective edge distance
    BOX_MIN_EFFECTIVE_EDGE_DISTANCE: 0.05
    // Prevents division by zero or excessively large forces
  };
  constructor(inputParams) {
    super();
    this.graph = inputParams.graph;
    this.initializeFloatingBoxPositions();
  }
  initializeFloatingBoxPositions() {
    this.graph.boxes = this.graph.boxes.map((box) => {
      if (box.kind === "floating" && box.center === void 0) {
        return {
          ...box,
          center: {
            x: (Math.random() - 0.5) * 2 * this.hyperParameters.RANDOM_INITIAL_PLACEMENT_MAX_X,
            y: (Math.random() - 0.5) * 2 * this.hyperParameters.RANDOM_INITIAL_PLACEMENT_MAX_Y
          }
        };
      }
      return box;
    });
  }
  _step() {
    const appliedForces = /* @__PURE__ */ new Map();
    addBoxRepulsionForces(this.graph, appliedForces, this.hyperParameters);
    addPinAlignmentForces(this.graph, appliedForces, this.hyperParameters);
    addNetworkedPinPullingForces(
      this.graph,
      appliedForces,
      this.hyperParameters
    );
    this.lastAppliedForces = appliedForces;
    this.graph = applyForcesToGraph(
      this.graph,
      appliedForces,
      this.hyperParameters
    );
  }
  visualize() {
    const baseGraphics = getGraphicsForBpcGraph(this.graph, {
      grayNetworks: true
    });
    for (const [boxId, forces] of this.lastAppliedForces) {
      const box = this.graph.boxes.find((b) => b.boxId === boxId);
      if (!box) continue;
      const boxCenter = box.kind === "fixed" ? box.center : box.center;
      if (!boxCenter && !forces.some((f) => f.sourcePinId)) continue;
      for (const force of forces) {
        let startPoint;
        if (force.sourcePinId) {
          try {
            startPoint = getPinPosition(
              this.graph,
              box.boxId,
              force.sourcePinId
            );
          } catch (e) {
            console.warn(
              `Could not find pin ${force.sourcePinId} for force visualization, falling back to box center.`
            );
            startPoint = boxCenter;
          }
        } else {
          startPoint = boxCenter;
        }
        if (!startPoint) continue;
        const endPoint = {
          x: startPoint.x + force.x * this.hyperParameters.DISPLAY_FORCE_LINE_MULTIPLIER,
          y: startPoint.y + force.y * this.hyperParameters.DISPLAY_FORCE_LINE_MULTIPLIER
        };
        let strokeColor = "rgba(128, 128, 128, 0.5)";
        switch (force.sourceStage) {
          case "box-repel":
            strokeColor = "rgba(255, 0, 0, 0.5)";
            break;
          case "pin-align":
            strokeColor = "rgba(0, 255, 0, 0.5)";
            break;
          case "center-pull":
            strokeColor = "rgba(0, 0, 255, 0.5)";
            break;
          case "networked-pin-pull":
            strokeColor = "rgba(255, 165, 0, 0.5)";
            break;
        }
        if (!baseGraphics.lines) baseGraphics.lines = [];
        baseGraphics.lines.push({
          points: [startPoint, endPoint],
          strokeColor,
          label: force.sourcePinId ? `${force.sourceStage}_${force.sourcePinId}` : force.sourceStage || "force"
        });
      }
    }
    return baseGraphics;
  }
};

// lib/adjacency-matrix-network-similarity/getAdjacencyMatrixFromFlatBpcGraph.ts
var getAdjacencyMatrixFromFlatBpcGraph = (flatBpcGraph) => {
  const nodeIdToIndex = /* @__PURE__ */ new Map();
  const indexMapping = [];
  flatBpcGraph.nodes.forEach((node, idx) => {
    nodeIdToIndex.set(node.id, idx);
    indexMapping.push(node.id);
  });
  const N = flatBpcGraph.nodes.length;
  const matrix = Array.from(
    { length: N },
    () => Array.from({ length: N }, () => 0)
  );
  for (const [id1, id2] of flatBpcGraph.undirectedEdges) {
    const i = nodeIdToIndex.get(id1);
    const j = nodeIdToIndex.get(id2);
    if (i !== void 0 && j !== void 0 && i !== j) {
      matrix[i][j] = 1;
      matrix[j][i] = 1;
    }
  }
  for (let i = 0; i < N; ++i) {
    matrix[i][i] = 1;
  }
  return { matrix, mapping: nodeIdToIndex, indexMapping };
};

// lib/matrix-utils/swapRowsAndColumns.ts
function swapRowsAndColumns(m, i, j) {
  if (i === j) return;
  [m[i], m[j]] = [m[j], m[i]];
  for (const row of m) {
    ;
    [row[i], row[j]] = [row[j], row[i]];
  }
}

// lib/adjacency-matrix-network-similarity/getEditOperationsForMatrix.ts
var getEditOperationsForMatrix = (params) => {
  const {
    fixedAdjMatrix,
    floatingAdjMatrix,
    floatingToFixedNodeAssignment,
    fixedMatrixMapping,
    floatingMatrixMapping
  } = params;
  const fixedToFloatingNodeAssignment = {};
  for (const [floatingNodeId, fixedNodeId] of Object.entries(
    floatingToFixedNodeAssignment
  )) {
    fixedToFloatingNodeAssignment[fixedNodeId] = floatingNodeId;
  }
  const operations = [];
  let currentFixedAdjMatrix = structuredClone(fixedAdjMatrix);
  let newFloatingToFixedNodeAssignment = structuredClone(
    floatingToFixedNodeAssignment
  );
  let currentFixedMatrixMapping = structuredClone(fixedMatrixMapping);
  {
    const unmappedFixedBoxIds = [...currentFixedMatrixMapping.keys()].filter(
      (boxId) => !(boxId in fixedToFloatingNodeAssignment)
    );
    if (unmappedFixedBoxIds.length === 0) {
    } else {
      const deletions = unmappedFixedBoxIds.map((boxId) => ({
        boxId,
        index: currentFixedMatrixMapping.get(boxId)
      })).sort((a, b) => b.index - a.index);
      for (const { boxId, index } of deletions) {
        operations.push({
          type: "delete_node",
          rowAndColumnIndexToRemove: index,
          nodeId: boxId
        });
        currentFixedAdjMatrix.splice(index, 1);
        for (const row of currentFixedAdjMatrix) {
          row.splice(index, 1);
        }
        currentFixedMatrixMapping.delete(boxId);
        for (const [otherBoxId, otherIdx] of currentFixedMatrixMapping) {
          if (otherIdx > index) {
            currentFixedMatrixMapping.set(otherBoxId, otherIdx - 1);
          }
        }
      }
    }
  }
  {
    const sizeDiff = floatingAdjMatrix.length - currentFixedAdjMatrix.length;
    if (sizeDiff <= 0) {
    } else {
      const mappedTargetBoxIds = new Set(
        Object.values(newFloatingToFixedNodeAssignment)
      );
      const unmappedTargetBoxIds = [...floatingMatrixMapping.keys()].filter(
        (tBoxId) => !mappedTargetBoxIds.has(tBoxId)
      );
      let newNodeCounter = 0;
      for (const targetNodeId of unmappedTargetBoxIds.slice(0, sizeDiff)) {
        const isBox = targetNodeId.split("-").length === 1;
        let newFixedNodeId;
        if (isBox) {
          newFixedNodeId = `newly_inserted_${isBox ? "box" : "pin"}_${++newNodeCounter}`;
        } else {
          const fixedBoxId = targetNodeId.split("-")[0];
          newFixedNodeId = `${fixedBoxId}-newly_inserted_pin_${++newNodeCounter}`;
        }
        const insertIndex = currentFixedAdjMatrix.length;
        for (const row of currentFixedAdjMatrix) {
          row.push(0);
        }
        const newRow = new Array(insertIndex + 1).fill(0);
        newRow[insertIndex] = 1;
        currentFixedAdjMatrix.push(newRow);
        currentFixedMatrixMapping.set(newFixedNodeId, insertIndex);
        newFloatingToFixedNodeAssignment[newFixedNodeId] = targetNodeId;
        operations.push({
          type: "create_node",
          newRowAndColumnIndex: insertIndex,
          nodeId: newFixedNodeId,
          floatingNodeId: targetNodeId,
          isBox
        });
      }
    }
  }
  {
    const floatingToFixedNodeAssignment2 = /* @__PURE__ */ new Map();
    for (const [fixedNodeId, floatingNodeId] of Object.entries(
      newFloatingToFixedNodeAssignment
    )) {
      floatingToFixedNodeAssignment2.set(floatingNodeId, fixedNodeId);
    }
    for (const [
      floatingNodeId,
      desiredIdx
    ] of floatingMatrixMapping.entries()) {
      const fixedNodeId = floatingToFixedNodeAssignment2.get(floatingNodeId);
      if (!fixedNodeId) continue;
      const currentIdx = currentFixedMatrixMapping.get(fixedNodeId);
      if (currentIdx === void 0 || currentIdx === desiredIdx) continue;
      const fixedNodeIdAtDesiredIdx = [
        ...currentFixedMatrixMapping.entries()
      ].find(([, idx]) => idx === desiredIdx)?.[0];
      if (fixedNodeIdAtDesiredIdx === void 0) continue;
      swapRowsAndColumns(currentFixedAdjMatrix, currentIdx, desiredIdx);
      currentFixedMatrixMapping.set(fixedNodeId, desiredIdx);
      currentFixedMatrixMapping.set(fixedNodeIdAtDesiredIdx, currentIdx);
      const index1 = Math.min(currentIdx, desiredIdx);
      const index2 = Math.max(currentIdx, desiredIdx);
      const sourceBoxId1 = index1 === currentIdx ? fixedNodeId : fixedNodeIdAtDesiredIdx;
      const sourceBoxId2 = index1 === currentIdx ? fixedNodeIdAtDesiredIdx : fixedNodeId;
      operations.push({
        type: "swap_indices",
        rowAndColumnIndex1: index1,
        rowAndColumnIndex2: index2,
        nodeId1: sourceBoxId1,
        nodeId2: sourceBoxId2
      });
    }
  }
  {
    const indexToFixedNodeId = /* @__PURE__ */ new Map();
    for (const [srcBoxId, idx] of currentFixedMatrixMapping) {
      indexToFixedNodeId.set(idx, srcBoxId);
    }
    const n = currentFixedAdjMatrix.length;
    for (let i = 0; i < n; i++) {
      for (let j = i + 1; j < n; j++) {
        const sourceVal = currentFixedAdjMatrix[i][j];
        const targetVal = floatingAdjMatrix[i][j];
        if (sourceVal === 1 && targetVal === 0) {
          const sourceBoxId1 = indexToFixedNodeId.get(i);
          const sourceBoxId2 = indexToFixedNodeId.get(j);
          operations.push({
            type: "disconnect_nodes",
            rowAndColumnIndex1: i,
            rowAndColumnIndex2: j,
            nodeId1: sourceBoxId1,
            nodeId2: sourceBoxId2
          });
          currentFixedAdjMatrix[i][j] = 0;
          currentFixedAdjMatrix[j][i] = 0;
        }
      }
    }
  }
  {
    const indexToSourceBoxId = /* @__PURE__ */ new Map();
    for (const [srcBoxId, idx] of currentFixedMatrixMapping) {
      indexToSourceBoxId.set(idx, srcBoxId);
    }
    const n = currentFixedAdjMatrix.length;
    for (let i = 0; i < n; i++) {
      for (let j = i + 1; j < n; j++) {
        const sourceVal = currentFixedAdjMatrix[i][j];
        const targetVal = floatingAdjMatrix[i][j];
        if (sourceVal === 0 && targetVal === 1) {
          const sourceBoxId1 = indexToSourceBoxId.get(i);
          const sourceBoxId2 = indexToSourceBoxId.get(j);
          operations.push({
            type: "connect_nodes",
            rowAndColumnIndex1: i,
            rowAndColumnIndex2: j,
            nodeId1: sourceBoxId1,
            nodeId2: sourceBoxId2
          });
          currentFixedAdjMatrix[i][j] = 1;
          currentFixedAdjMatrix[j][i] = 1;
        }
      }
    }
  }
  return {
    newSourceAdjMatrix: currentFixedAdjMatrix,
    newSourceMatrixMapping: currentFixedMatrixMapping,
    newFloatingToFixedNodeAssignment,
    operations
  };
};

// lib/assignment2/AssignmentSolver2.ts
import {
  stackGraphicsHorizontally,
  stackGraphicsVertically
} from "graphics-debug";

// lib/flat-bpc/convertToFlatBpcGraph.ts
var convertToFlatBpcGraph = (mixed) => {
  const nodes = [];
  const undirectedEdges = [];
  const boxCenterMap = /* @__PURE__ */ new Map();
  for (const box of mixed.boxes) {
    if (box.kind === "fixed") boxCenterMap.set(box.boxId, box.center);
    else boxCenterMap.set(box.boxId, box.center);
    nodes.push({
      id: box.boxId,
      boxId: box.boxId,
      color: "box",
      x: box.center?.x,
      y: box.center?.y
    });
  }
  const pinsByNetwork = {};
  for (const pin of mixed.pins) {
    const nodeId = `${pin.boxId}-${pin.pinId}`;
    const bCenter = boxCenterMap.get(pin.boxId);
    nodes.push({
      id: nodeId,
      boxId: pin.boxId,
      pinId: pin.pinId,
      color: pin.color,
      x: bCenter ? bCenter.x + pin.offset.x : void 0,
      y: bCenter ? bCenter.y + pin.offset.y : void 0
    });
    pinsByNetwork[pin.networkId] ??= [];
    pinsByNetwork[pin.networkId].push(nodeId);
  }
  for (const nodeIds of Object.values(pinsByNetwork)) {
    for (let i = 0; i < nodeIds.length; i++) {
      for (let j = i + 1; j < nodeIds.length; j++) {
        undirectedEdges.push([nodeIds[i], nodeIds[j]]);
      }
    }
  }
  for (const box of mixed.boxes) {
    for (const pin of mixed.pins) {
      if (pin.boxId === box.boxId) {
        undirectedEdges.push([box.boxId, `${box.boxId}-${pin.pinId}`]);
      }
    }
  }
  return { nodes, undirectedEdges };
};

// lib/adjacency-matrix-network-similarity/wlFeatureVec.ts
var wlFeatureVec = (adjMatrix, K, opts = {}) => {
  const n = adjMatrix.length;
  if (adjMatrix.some((row) => row.length !== n)) {
    throw new Error("adjMatrix must be square");
  }
  let colors = (opts.nodeInitialColors ?? Array.from({ length: n }, () => "_")).slice();
  const getCounts = (cols) => {
    const counts = {};
    for (const c of cols) counts[c] = (counts[c] ?? 0) + 1;
    return counts;
  };
  const countsArr = [];
  countsArr.push(getCounts(colors));
  for (let step = 0; step < K; step++) {
    const next = Array(n);
    for (let v = 0; v < n; v++) {
      const neigh = [];
      for (let u = 0; u < n; u++) if (adjMatrix[v][u]) neigh.push(colors[u]);
      neigh.sort();
      next[v] = `${colors[v]}|${neigh.join(",")}`;
    }
    colors = next;
    countsArr.push(getCounts(colors));
  }
  return countsArr;
};

// lib/adjacency-matrix-network-similarity/wlDotProduct.ts
var wlVecWeightedJaccardSimilarity = (wlFeatureVec1, wlFeatureVec2) => {
  let total = 0;
  const len = Math.min(wlFeatureVec1.length, wlFeatureVec2.length);
  for (let i = 0; i < len; i++) {
    const rec1 = wlFeatureVec1[i];
    const rec2 = wlFeatureVec2[i];
    const allKeys = /* @__PURE__ */ new Set([...Object.keys(rec1), ...Object.keys(rec2)]);
    let sumMin = 0;
    let sumMax = 0;
    for (const k of allKeys) {
      const v1 = rec1[k] ?? 0;
      const v2 = rec2[k] ?? 0;
      sumMin += Math.min(v1, v2);
      sumMax += Math.max(v1, v2);
    }
    total += sumMax === 0 ? 0 : sumMin / sumMax;
  }
  return total;
};
var wlVecCosineSimilarity = (wlFeatureVec1, wlFeatureVec2) => {
  let total = 0;
  const len = Math.min(wlFeatureVec1.length, wlFeatureVec2.length);
  for (let i = 0; i < len; i++) {
    const rec1 = wlFeatureVec1[i];
    const rec2 = wlFeatureVec2[i];
    const allColors = /* @__PURE__ */ new Set([...Object.keys(rec1), ...Object.keys(rec2)]);
    let dot12 = 0;
    let dot11 = 0;
    let dot22 = 0;
    for (const color of allColors) {
      const v1 = rec1[color] ?? 0;
      const v2 = rec2[color] ?? 0;
      dot12 += v1 * v2;
      dot11 += v1 * v1;
      dot22 += v2 * v2;
    }
    const denom = Math.sqrt(dot11) * Math.sqrt(dot22);
    if (denom > 0) {
      total += dot12 / denom;
    } else {
      total += 0;
    }
  }
  return total;
};
var getWlDotProduct = wlVecWeightedJaccardSimilarity;

// lib/adjacency-matrix-network-similarity/getBpcGraphWlDistance.ts
var DEFAULT_WL_DEGREES = 2;
var getWlFeatureVecs = (g, wlDegrees = DEFAULT_WL_DEGREES) => {
  const flatBpc = convertToFlatBpcGraph(g);
  const { matrix, indexMapping } = getAdjacencyMatrixFromFlatBpcGraph(flatBpc);
  return wlFeatureVec(matrix, wlDegrees, {
    nodeInitialColors: indexMapping.map(
      (id) => flatBpc.nodes.find((n) => n.id === id)?.color ?? "_"
    )
  });
};
var getBpcGraphWlDistance = (g1, g2, { wlDegrees = DEFAULT_WL_DEGREES } = {}) => {
  const wlVec1 = getWlFeatureVecs(g1, wlDegrees);
  const wlVec2 = getWlFeatureVecs(g2, wlDegrees);
  return (DEFAULT_WL_DEGREES + 1 - getWlDotProduct(wlVec1, wlVec2)) / (DEFAULT_WL_DEGREES + 1);
};

// lib/graph-utils/hashStringToNumber.ts
var hashStringToNumber = (str) => {
  let hash = 0;
  for (let i = 0; i < str.length; i++) {
    hash = (hash << 5) - hash + str.charCodeAt(i);
  }
  return Math.abs(hash);
};

// lib/debug/convertFlatBpcToGraphics.ts
import { getBounds as getBounds2 } from "graphics-debug";
var convertFlatBpcToGraphics = (flat, opts = {}) => {
  const gfx = {
    points: [],
    lines: [],
    rects: [],
    circles: [],
    texts: [],
    coordinateSystem: "cartesian",
    title: "Flat-BPC Graphics"
  };
  const pos = /* @__PURE__ */ new Map();
  for (const n of flat.nodes) {
    if (n.x === void 0 || n.y === void 0) continue;
    const p = { x: n.x, y: n.y };
    pos.set(n.id, p);
    gfx.points.push({
      ...p,
      color: translateColor(n.color),
      label: n.id
    });
  }
  for (const [a, b] of flat.undirectedEdges) {
    const pa = pos.get(a);
    const pb = pos.get(b);
    if (pa && pb) {
      gfx.lines.push({
        points: [pa, pb],
        strokeColor: "rgba(0,0,0,0.3)"
      });
    }
  }
  const bounds = getBounds2(gfx);
  if (opts.title) {
    gfx.texts.push({
      text: opts.title,
      x: bounds.minX,
      y: bounds.maxY,
      fontSize: (bounds.maxY - bounds.minY) * 0.05,
      anchorSide: "bottom_left"
    });
  }
  if (opts.caption) {
    gfx.texts.push({
      text: opts.caption,
      x: bounds.minX,
      y: bounds.minY,
      fontSize: (bounds.maxY - bounds.minY) * 0.05,
      anchorSide: "top_left"
    });
  }
  return gfx;
};
var getGraphicsForFlatBpcGraph = convertFlatBpcToGraphics;

// lib/graph-utils/getTotalNetworkLength.ts
var getTotalNetworkLength = (g) => {
  const networkPins = /* @__PURE__ */ new Map();
  for (const pin of g.pins) {
    const box = g.boxes.find((b) => b.boxId === pin.boxId);
    if (!box || !box.center)
      throw new Error(
        `Expected fixed graph \u2013 box "${pin.boxId}" missing or has no center`
      );
    const pos = {
      x: box.center.x + pin.offset.x,
      y: box.center.y + pin.offset.y
    };
    if (!networkPins.has(pin.networkId)) networkPins.set(pin.networkId, []);
    networkPins.get(pin.networkId).push(pos);
  }
  const networkLengths = /* @__PURE__ */ new Map();
  let totalNetworkLength = 0;
  for (const [netId, positions] of networkPins) {
    if (positions.length === 0) {
      networkLengths.set(netId, 0);
      continue;
    }
    const centre = positions.reduce(
      (acc, p) => ({ x: acc.x + p.x, y: acc.y + p.y }),
      { x: 0, y: 0 }
    );
    centre.x /= positions.length;
    centre.y /= positions.length;
    const len = positions.reduce((sum, p) => {
      const dx = p.x - centre.x;
      const dy = p.y - centre.y;
      return sum + Math.sqrt(dx * dx + dy * dy);
    }, 0);
    networkLengths.set(netId, len);
    totalNetworkLength += len;
  }
  return { totalNetworkLength, networkLengths };
};

// lib/network-bag-of-angles-assignment/computeBagOfAnglesForNetwork.ts
var computeBagOfAnglesForNetwork = (g, networkId) => {
  const pins = g.pins.filter((p) => p.networkId === networkId);
  const angles = [];
  for (const pin of pins) {
    const pinAngle = Math.atan2(pin.offset.y, pin.offset.x);
    angles.push(pinAngle);
  }
  return angles;
};

// lib/network-bag-of-angles-assignment/computeGraphNetworkBagOfAnglesMap.ts
var computeGraphNetworkBagOfAnglesMap = (g) => {
  const map = /* @__PURE__ */ new Map();
  const networks = Array.from(new Set(g.pins.map((p) => p.networkId)));
  for (const networkId of networks) {
    const angles = computeBagOfAnglesForNetwork(g, networkId);
    map.set(networkId, angles);
  }
  return map;
};

// lib/network-bag-of-angles-assignment/computeBagOfAnglesDistance.ts
var circularDistance = (a, b) => {
  const TAU = 2 * Math.PI;
  const normA = (a % TAU + TAU) % TAU;
  const normB = (b % TAU + TAU) % TAU;
  const diff = Math.abs(normA - normB);
  return Math.min(diff, TAU - diff);
};
var computeBagOfAnglesDistance = (bag1, bag2) => {
  if (bag1.length === 0 && bag2.length === 0) return 0;
  if (bag1.length === 0 || bag2.length === 0) return Math.PI;
  const avgNearest = (src, tgt) => {
    let sum = 0;
    for (const a of src) {
      let best = Infinity;
      for (const b of tgt) {
        const d = circularDistance(a, b);
        if (d < best) best = d;
      }
      sum += best;
    }
    return sum / src.length;
  };
  return (avgNearest(bag1, bag2) + avgNearest(bag2, bag1)) / 2;
};

// lib/network-bag-of-angles-assignment/computeNetworkMappingFromBagsOfAngles.ts
var computeNetworkMappingFromBagsOfAngles = (bag1, bag2) => {
  const networkMapping = /* @__PURE__ */ new Map();
  const bag1Entries = Array.from(bag1.entries());
  const bag2Entries = Array.from(bag2.entries());
  const n1 = bag1Entries.length;
  const n2 = bag2Entries.length;
  const distanceMatrix = Array.from(
    { length: n1 },
    () => new Array(n2).fill(0)
  );
  for (let i = 0; i < n1; i++) {
    const [, angles1] = bag1Entries[i];
    for (let j = 0; j < n2; j++) {
      const [, angles2] = bag2Entries[j];
      distanceMatrix[i][j] = computeBagOfAnglesDistance(angles1, angles2);
    }
  }
  const unmapped1 = new Set(Array.from({ length: n1 }, (_, i) => i));
  const unmapped2 = new Set(Array.from({ length: n2 }, (_, i) => i));
  let totalDistance = 0;
  while (unmapped1.size && unmapped2.size) {
    let bestI = -1;
    let bestJ = -1;
    let bestD = Infinity;
    for (const i of unmapped1) {
      for (const j of unmapped2) {
        const d = distanceMatrix[i][j];
        if (d < bestD) {
          bestD = d;
          bestI = i;
          bestJ = j;
        }
      }
    }
    const [net1] = bag1Entries[bestI];
    const [net2] = bag2Entries[bestJ];
    networkMapping.set(net1, net2);
    totalDistance += bestD;
    unmapped1.delete(bestI);
    unmapped2.delete(bestJ);
  }
  const UNMATCHED_PENALTY = Math.PI;
  totalDistance += (unmapped1.size + unmapped2.size) * UNMATCHED_PENALTY;
  return { networkMapping, distance: totalDistance };
};

// lib/graph-utils/getBoundsOfPinList.ts
var getBoundsOfPinList = (pins) => {
  const minX = Math.min(...pins.map((p) => p.offset.x));
  const maxX = Math.max(...pins.map((p) => p.offset.x));
  const minY = Math.min(...pins.map((p) => p.offset.y));
  const maxY = Math.max(...pins.map((p) => p.offset.y));
  return { minX, maxX, minY, maxY };
};

// lib/graph-utils/getNormalizedPerimeterDistance.ts
var getNormalizedPerimeterDistance = (A, B) => {
  const posToScalar = (p) => {
    switch (p.side) {
      case "x+":
        return p.cwDistanceFromCorner;
      // 0 … 1
      case "y-":
        return 1 + p.cwDistanceFromCorner;
      // 1 … 2
      case "x-":
        return 2 + p.cwDistanceFromCorner;
      // 2 … 3
      case "y+":
        return 3 + p.cwDistanceFromCorner;
    }
  };
  const a = posToScalar(A) % 4;
  const b = posToScalar(B) % 4;
  const cwDistance = (b - a + 4) % 4;
  const ccwDistance = (a - b + 4) % 4;
  const minDistance = Math.min(cwDistance, ccwDistance);
  return { cwDistance, ccwDistance, minDistance };
};

// lib/graph-utils/getNormalizedPerimeterPosition.ts
var EPS = 1e-6;
var getNormalizedPerimeterPosition = (bounds, position) => {
  const { minX, minY, maxX, maxY } = bounds;
  const near = (a, b) => Math.abs(a - b) < EPS;
  let side;
  let cwDistanceFromCorner;
  if (near(position.x, maxX) && position.y >= minY - EPS && position.y <= maxY + EPS) {
    side = "x+";
    cwDistanceFromCorner = (maxY - position.y) / (maxY - minY);
  } else if (near(position.y, maxY) && // TOP edge  (y+)
  position.x <= maxX + EPS && position.x >= minX - EPS) {
    side = "y+";
    cwDistanceFromCorner = (position.x - minX) / (maxX - minX);
  } else if (near(position.x, minX) && position.y <= maxY + EPS && position.y >= minY - EPS) {
    side = "x-";
    cwDistanceFromCorner = (position.y - minY) / (maxY - minY);
  } else if (near(position.y, minY) && // BOTTOM edge (y-)
  position.x >= minX - EPS && position.x <= maxX + EPS) {
    side = "y-";
    cwDistanceFromCorner = (maxX - position.x) / (maxX - minX);
  } else {
    return null;
  }
  cwDistanceFromCorner = Math.min(1, Math.max(0, cwDistanceFromCorner));
  return { side, cwDistanceFromCorner };
};

// lib/assignment2/matchPins.ts
var matchPins = (pinList1, pinList2) => {
  const matchedPins = [];
  const unmatchedPin1Ids = /* @__PURE__ */ new Set();
  const unmatchedPin2Ids = /* @__PURE__ */ new Set();
  const matchedPin1Ids = /* @__PURE__ */ new Set();
  const matchedPin2Ids = /* @__PURE__ */ new Set();
  const bounds1 = getBoundsOfPinList(pinList1);
  const bounds2 = getBoundsOfPinList(pinList2);
  for (const pin1 of pinList1) {
    const matchingPinsByColor = pinList2.filter((p2) => p2.color === pin1.color).filter((p2) => !matchedPin2Ids.has(p2.pinId));
    if (matchingPinsByColor.length === 0) {
      unmatchedPin1Ids.add(pin1.pinId);
      continue;
    }
    const normalizedPerimeterPosition1 = getNormalizedPerimeterPosition(
      bounds1,
      pin1.offset
    );
    if (normalizedPerimeterPosition1 === null) {
      unmatchedPin1Ids.add(pin1.pinId);
      continue;
    }
    let bestPerimeterDistance = Infinity;
    let bestMatchingPin2 = matchingPinsByColor[0];
    for (const pin2 of matchingPinsByColor) {
      const normalizedPerimeterPosition2 = getNormalizedPerimeterPosition(
        bounds2,
        pin2.offset
      );
      if (normalizedPerimeterPosition2 === null) {
        continue;
      }
      const { minDistance } = getNormalizedPerimeterDistance(
        normalizedPerimeterPosition1,
        normalizedPerimeterPosition2
      );
      if (minDistance < bestPerimeterDistance) {
        bestPerimeterDistance = minDistance;
        bestMatchingPin2 = pin2;
      }
    }
    matchedPins.push([pin1, bestMatchingPin2]);
    matchedPin1Ids.add(pin1.pinId);
    matchedPin2Ids.add(bestMatchingPin2.pinId);
  }
  for (const pin2 of pinList2) {
    if (matchedPin2Ids.has(pin2.pinId)) continue;
    unmatchedPin2Ids.add(pin2.pinId);
  }
  return {
    matchedPins,
    unmatchedPin1Ids,
    unmatchedPin2Ids
  };
};

// lib/assignment2/AssignmentSolver2.ts
var AssignmentSolver2 = class {
  constructor(floatingGraph, fixedGraph) {
    this.floatingGraph = floatingGraph;
    this.fixedGraph = fixedGraph;
    this.wipGraph = {
      pins: [],
      boxes: []
    };
    this.fixedToFloatingNetworkMap = this.computeFixedToFloatingNetworkMap();
    this.floatingToFixedNetworkMap = new Map(
      Array.from(this.fixedToFloatingNetworkMap.entries()).map(
        ([k, v]) => [v, k]
      )
    );
  }
  wipGraph;
  iterations = 0;
  solved = false;
  acceptedFloatingBoxIds = /* @__PURE__ */ new Set();
  rejectedFloatingBoxIds = /* @__PURE__ */ new Set();
  acceptedFixedBoxIds = /* @__PURE__ */ new Set();
  assignment = /* @__PURE__ */ new Map();
  lastAcceptedEvaluation = null;
  fixedToFloatingNetworkMap;
  floatingToFixedNetworkMap;
  lastComputedEvaluations = [];
  computeFixedToFloatingNetworkMap() {
    const floatingBagOfAnglesMap = computeGraphNetworkBagOfAnglesMap(
      this.floatingGraph
    );
    const fixedBagOfAnglesMap = computeGraphNetworkBagOfAnglesMap(
      this.fixedGraph
    );
    const { networkMapping } = computeNetworkMappingFromBagsOfAngles(
      fixedBagOfAnglesMap,
      floatingBagOfAnglesMap
    );
    return networkMapping;
  }
  /**
   * Returns the floating box id that should be assigned next.
   *
   * Currently this picks the boxes with the most pins first- but this
   * could be improved by picking the next box that is most relevant to the
   * network (e.g. a box that should be connected to the wipGraph)
   */
  getNextFloatingBoxId() {
    const remainingFloatingBoxIds = this.floatingGraph.boxes.map((b) => b.boxId).filter(
      (b) => !this.acceptedFloatingBoxIds.has(b) && !this.rejectedFloatingBoxIds.has(b)
    );
    if (!remainingFloatingBoxIds.length) {
      throw new Error("No remaining floating box ids");
    }
    let bestFloatingBoxId = remainingFloatingBoxIds[0];
    let bestFloatingBoxPinCount = 0;
    for (const floatingBoxId of remainingFloatingBoxIds) {
      const floatingBoxPins = this.floatingGraph.pins.filter(
        (p) => p.boxId === floatingBoxId
      );
      if (floatingBoxPins.length > bestFloatingBoxPinCount) {
        bestFloatingBoxId = floatingBoxId;
        bestFloatingBoxPinCount = floatingBoxPins.length;
      }
    }
    return bestFloatingBoxId;
  }
  getRemainingFloatingBoxIds() {
    return this.floatingGraph.boxes.map((b) => b.boxId).filter(
      (b) => !this.acceptedFloatingBoxIds.has(b) && !this.rejectedFloatingBoxIds.has(b)
    );
  }
  /**
   * The floating graph, but with only the boxes that have been accepted so far
   */
  getPartialFloatingGraph(nextFloatingBoxId) {
    const g = {
      pins: [],
      boxes: []
    };
    for (const box of this.floatingGraph.boxes) {
      if (this.acceptedFloatingBoxIds.has(box.boxId) || box.boxId === nextFloatingBoxId) {
        g.boxes.push(box);
        g.pins.push(
          ...this.floatingGraph.pins.filter((p) => p.boxId === box.boxId)
        );
      }
    }
    return g;
  }
  evaluateFloatingBoxAssignment(nextFloatingBoxId) {
    const partialFloatingGraph = this.getPartialFloatingGraph(nextFloatingBoxId);
    const currentWlDist = getBpcGraphWlDistance(
      partialFloatingGraph,
      this.wipGraph
    );
    let bestFixedBoxId = null;
    let bestNewWipGraph = null;
    const dEval = {
      floatingBoxId: nextFloatingBoxId,
      originalWipGraph: this.wipGraph,
      partialFloatingGraph,
      currentWlDist,
      networkLengths: /* @__PURE__ */ new Map(),
      wlDistances: /* @__PURE__ */ new Map(),
      wlVecs: /* @__PURE__ */ new Map(),
      wipGraphsWithAddedFixedBoxId: /* @__PURE__ */ new Map()
    };
    let bestDist = currentWlDist;
    let bestWlDist = currentWlDist;
    let bestTotalNetworkLength = Infinity;
    const floatingBoxWlVec = getWlFeatureVecs(partialFloatingGraph);
    for (const fixedBoxId of this.fixedGraph.boxes.map((b) => b.boxId)) {
      if (this.acceptedFixedBoxIds.has(fixedBoxId)) continue;
      const wipGraphWithAddedFixedBoxId = this.getWipGraphWithAddedFixedBoxIdForFloatingAssignment(
        fixedBoxId,
        nextFloatingBoxId
      );
      const wlDist = getBpcGraphWlDistance(
        partialFloatingGraph,
        wipGraphWithAddedFixedBoxId
      );
      const debug_wlVec = getWlFeatureVecs(wipGraphWithAddedFixedBoxId);
      const { totalNetworkLength } = getTotalNetworkLength(
        wipGraphWithAddedFixedBoxId
      );
      dEval.wipGraphsWithAddedFixedBoxId.set(
        fixedBoxId,
        wipGraphWithAddedFixedBoxId
      );
      dEval.wlVecs.set(fixedBoxId, debug_wlVec);
      dEval.wlDistances.set(fixedBoxId, wlDist);
      dEval.networkLengths.set(fixedBoxId, totalNetworkLength);
      const dist = wlDist + totalNetworkLength / 100;
      if (dist < bestDist) {
        bestDist = dist;
        bestWlDist = wlDist;
        bestTotalNetworkLength = totalNetworkLength;
        bestNewWipGraph = wipGraphWithAddedFixedBoxId;
        bestFixedBoxId = fixedBoxId;
      }
    }
    return {
      bestFixedBoxId,
      bestNewWipGraph,
      bestDist,
      bestWlDist,
      bestTotalNetworkLength,
      lastDistanceEvaluation: dEval,
      nextFloatingBoxId,
      partialFloatingGraph,
      floatingBoxWlVec
    };
  }
  getPinAssignment() {
    const pinAssignment = {};
    const fixedToFloatingBoxAssignment = {};
    for (const [floatingBoxId, fixedBoxId] of this.assignment) {
      pinAssignment[floatingBoxId] = {};
      fixedToFloatingBoxAssignment[fixedBoxId] = floatingBoxId;
    }
    for (const pin of this.wipGraph.pins) {
      const fixedBoxId = pin.boxId;
      const floatingBoxId = fixedToFloatingBoxAssignment[fixedBoxId];
      const floatingPinId = pin._floatingPinId;
      const fixedPinId = pin._fixedPinId;
      pinAssignment[floatingBoxId][floatingPinId] = fixedPinId;
    }
    return pinAssignment;
  }
  step() {
    if (this.solved) return;
    if (this.iterations > 1e3) {
      throw new Error("Too many iterations");
    }
    this.iterations++;
    if (this.iterations === 1) {
      const nextFloatingBoxId = this.getNextFloatingBoxId();
      const evalResult = this.evaluateFloatingBoxAssignment(nextFloatingBoxId);
      this.lastComputedEvaluations = [evalResult];
      this.acceptEvaluationResult(evalResult);
      return;
    }
    const remainingFloatingBoxIds = this.getRemainingFloatingBoxIds();
    if (remainingFloatingBoxIds.length === 0) {
      this.solved = true;
      return;
    }
    let bestEvalDist = Infinity;
    let bestEvalResult = null;
    this.lastComputedEvaluations = [];
    for (const floatingBoxId of remainingFloatingBoxIds) {
      const evalResult = this.evaluateFloatingBoxAssignment(floatingBoxId);
      this.lastComputedEvaluations.push(evalResult);
      if (evalResult.bestDist < bestEvalDist) {
        bestEvalDist = evalResult.bestDist;
        bestEvalResult = evalResult;
      }
    }
    if (bestEvalResult) {
      this.acceptEvaluationResult(bestEvalResult);
    }
  }
  acceptEvaluationResult(evalResult) {
    const { bestFixedBoxId, bestNewWipGraph, nextFloatingBoxId } = evalResult;
    if (bestFixedBoxId === null) {
      this.rejectedFloatingBoxIds.add(nextFloatingBoxId);
      return;
    }
    this.acceptedFloatingBoxIds.add(nextFloatingBoxId);
    this.assignment.set(nextFloatingBoxId, bestFixedBoxId);
    this.acceptedFixedBoxIds.add(bestFixedBoxId);
    this.wipGraph = bestNewWipGraph;
    this.lastAcceptedEvaluation = evalResult.lastDistanceEvaluation;
  }
  getWipGraphWithAddedFixedBoxIdForFloatingAssignment(fixedBoxId, floatingBoxId) {
    const g = structuredClone(this.wipGraph);
    const boxToAdd = this.fixedGraph.boxes.find((b) => b.boxId === fixedBoxId);
    g.boxes.push(boxToAdd);
    const floatingBoxPins = this.floatingGraph.pins.filter(
      (p) => p.boxId === floatingBoxId
    );
    const fixedBoxPins = this.fixedGraph.pins.filter(
      (p) => p.boxId === fixedBoxId
    );
    const { matchedPins } = matchPins(floatingBoxPins, fixedBoxPins);
    g.pins.push(
      ...matchedPins.map((p) => {
        const [floatingPin, fixedPin] = p;
        return {
          ...fixedPin,
          networkId: this.floatingToFixedNetworkMap.get(floatingPin.networkId),
          _floatingPinId: floatingPin.pinId,
          _fixedPinId: fixedPin.pinId
        };
      })
    );
    return g;
  }
  visualize() {
    const floatingGraphics = getGraphicsForBpcGraph(this.floatingGraph, {
      title: "Floating"
    });
    const wipGraphics = getGraphicsForBpcGraph(this.wipGraph, {
      title: "WIP"
    });
    const fixedGraphics = getGraphicsForBpcGraph(this.fixedGraph, {
      title: "Fixed"
    });
    const floatingPartialGraphics = getGraphicsForBpcGraph(
      this.getPartialFloatingGraph(),
      {
        title: "Partial Floating"
      }
    );
    const colorByFloatingId = /* @__PURE__ */ new Map();
    const fixedToFloating = /* @__PURE__ */ new Map();
    for (const [floatId, fixedId] of this.assignment) {
      const colour = getColorByIndex(
        hashStringToNumber(floatId) * 47 % 100,
        100,
        0.5
      );
      colorByFloatingId.set(floatId, colour);
      fixedToFloating.set(fixedId, floatId);
    }
    function decorateRect(rect, floatId, fixedId) {
      const colour = colorByFloatingId.get(floatId);
      rect.fill = colour;
      rect.label = `${floatId}\u2192${fixedId}`;
    }
    for (const rect of floatingGraphics.rects ?? []) {
      const floatId = rect.label;
      if (!floatId) continue;
      const fixedId = this.assignment.get(floatId);
      if (fixedId) decorateRect(rect, floatId, fixedId);
    }
    for (const rect of floatingPartialGraphics.rects ?? []) {
      const floatId = rect.label;
      if (!floatId) continue;
      const fixedId = this.assignment.get(floatId);
      if (fixedId) decorateRect(rect, floatId, fixedId);
    }
    const targetGraphics = [wipGraphics, fixedGraphics];
    for (const g of targetGraphics) {
      for (const rect of g.rects ?? []) {
        const fixedId = rect.label;
        if (!fixedId) continue;
        const floatId = fixedToFloating.get(fixedId);
        if (floatId) decorateRect(rect, floatId, fixedId);
      }
    }
    const floatingFlatG = convertToFlatBpcGraph(this.floatingGraph);
    const wipFlatG = convertToFlatBpcGraph(this.wipGraph);
    const fixedFlatG = convertToFlatBpcGraph(this.fixedGraph);
    const floatingFlatGraphics = convertFlatBpcToGraphics(floatingFlatG, {
      title: "Floating Flat"
    });
    const wipFlatGraphics = convertFlatBpcToGraphics(wipFlatG, {
      title: "WIP Flat"
    });
    const fixedFlatGraphics = convertFlatBpcToGraphics(fixedFlatG, {
      title: "Fixed Flat"
    });
    const graphics = stackGraphicsHorizontally([
      stackGraphicsVertically([
        floatingGraphics,
        floatingFlatGraphics,
        floatingPartialGraphics
      ]),
      stackGraphicsVertically([wipGraphics, wipFlatGraphics]),
      stackGraphicsVertically([fixedGraphics, fixedFlatGraphics])
    ]);
    return graphics;
  }
};

// lib/assignment2/getApproximateAssignments2.ts
var getApproximateAssignments2 = (floatingGraph, fixedGraph) => {
  const solver = new AssignmentSolver2(floatingGraph, fixedGraph);
  while (!solver.solved && solver.iterations < 1e3) {
    solver.step();
  }
  const boxAssignment = {};
  for (const [floatingBoxId, fixedBoxId] of solver.assignment.entries()) {
    boxAssignment[floatingBoxId] = fixedBoxId;
  }
  const networkAssignment = {};
  for (const [
    floatingNetId,
    fixedNetId
  ] of solver.floatingToFixedNetworkMap.entries()) {
    networkAssignment[floatingNetId] = fixedNetId;
  }
  const pinAssignment = solver.getPinAssignment();
  return {
    floatingToFixedBoxAssignment: boxAssignment,
    floatingToFixedNetworkAssignment: networkAssignment,
    floatingToFixedPinAssignment: pinAssignment
  };
};

// lib/bpc-graph-editing/netAdaptBpcGraph.ts
var netAdaptBpcGraph = (fixedGraph, floatingGraph) => {
  const approxAssignmentsResult = getApproximateAssignments2(
    floatingGraph,
    fixedGraph
  );
  const fixedFlatBpcGraph = convertToFlatBpcGraph(fixedGraph);
  const fixedAdjMatrixResult = getAdjacencyMatrixFromFlatBpcGraph(fixedFlatBpcGraph);
  const floatingFlatBpcGraph = convertToFlatBpcGraph(floatingGraph);
  const floatingAdjMatrixResult = getAdjacencyMatrixFromFlatBpcGraph(floatingFlatBpcGraph);
  const floatingToFixedNodeAssignment = {
    ...approxAssignmentsResult.floatingToFixedBoxAssignment
  };
  for (const [floatingBoxId, pinAssignment] of Object.entries(
    approxAssignmentsResult.floatingToFixedPinAssignment
  )) {
    for (const [floatingPinId, fixedPinId] of Object.entries(pinAssignment)) {
      const fixedBoxId = approxAssignmentsResult.floatingToFixedBoxAssignment[floatingBoxId];
      floatingToFixedNodeAssignment[`${floatingBoxId}-${floatingPinId}`] = `${fixedBoxId}-${fixedPinId}`;
    }
  }
  const editOpsResult = getEditOperationsForMatrix({
    floatingToFixedNodeAssignment,
    fixedAdjMatrix: fixedAdjMatrixResult.matrix,
    floatingAdjMatrix: floatingAdjMatrixResult.matrix,
    fixedMatrixMapping: fixedAdjMatrixResult.mapping,
    floatingMatrixMapping: floatingAdjMatrixResult.mapping
  });
  const newFixedToFloatingNodeAssignment = {};
  for (const [floatingNodeId, fixedNodeId] of Object.entries(
    editOpsResult.newFloatingToFixedNodeAssignment
  )) {
    newFixedToFloatingNodeAssignment[fixedNodeId] = floatingNodeId;
  }
  const adaptedBpcGraph = structuredClone(fixedGraph);
  for (const pin of adaptedBpcGraph.pins) {
    const fixedPinNodeId = `${pin.boxId}-${pin.pinId}`;
    const floatingPinNodeId = newFixedToFloatingNodeAssignment[fixedPinNodeId];
    if (!floatingPinNodeId) continue;
    const [tBoxId, tPinId] = floatingPinNodeId.split("-");
    const floatingPin = floatingGraph.pins.find(
      (p) => p.boxId === tBoxId && p.pinId === tPinId
    );
    if (!floatingPin) continue;
    pin.boxId = floatingPin.boxId;
    pin.pinId = floatingPin.pinId;
    pin.networkId = floatingPin.networkId;
    pin.color = floatingPin.color;
    pin.offset = floatingPin.offset;
  }
  for (const box of adaptedBpcGraph.boxes) {
    const floatingBoxId = newFixedToFloatingNodeAssignment[box.boxId];
    if (floatingBoxId) {
      box.boxId = floatingBoxId;
    } else {
    }
  }
  for (const op of editOpsResult.operations) {
    switch (op.type) {
      case "create_node": {
        if (op.isBox) {
          const targetBox = floatingGraph.boxes.find(
            (b) => b.boxId === op.floatingNodeId
          );
          if (!targetBox) {
            throw new Error(`Target box ${op.floatingNodeId} not found`);
          }
          adaptedBpcGraph.boxes.push({
            boxId: op.floatingNodeId,
            kind: "floating"
          });
        } else {
          const splitResult = op.floatingNodeId.split("-");
          if (splitResult.length !== 2) {
            throw new Error(`Invalid pin node ID format: ${op.floatingNodeId}`);
          }
          const targetBoxId = splitResult[0];
          const targetPinId = splitResult[1];
          const targetPin = floatingGraph.pins.find(
            (p) => p.boxId === targetBoxId && p.pinId === targetPinId
          );
          if (!targetPin) {
            throw new Error(`Target pin ${op.floatingNodeId} not found`);
          }
          const boxExists = adaptedBpcGraph.boxes.some(
            (box) => box.boxId === targetBoxId
          );
          if (!boxExists) {
            const targetBox = floatingGraph.boxes.find(
              (b) => b.boxId === targetBoxId
            );
            if (!targetBox) {
              throw new Error(`Target box ${targetBoxId} not found`);
            }
            adaptedBpcGraph.boxes.push({
              boxId: targetBoxId,
              kind: "floating"
            });
          }
          adaptedBpcGraph.pins.push({
            boxId: targetPin.boxId,
            pinId: targetPin.pinId,
            networkId: targetPin.networkId,
            color: targetPin.color,
            offset: targetPin.offset
          });
        }
        break;
      }
      case "delete_node": {
        if (op.nodeId.split("-").length === 1) {
          adaptedBpcGraph.boxes = adaptedBpcGraph.boxes.filter(
            (box) => box.boxId !== op.nodeId
          );
          adaptedBpcGraph.pins = adaptedBpcGraph.pins.filter(
            (p) => p.boxId !== op.nodeId
          );
        } else {
          const [boxId, pinId] = op.nodeId.split("-");
          adaptedBpcGraph.pins = adaptedBpcGraph.pins.filter(
            (pin) => !(pin.boxId === boxId && pin.pinId === pinId)
          );
        }
        break;
      }
      case "connect_nodes": {
        break;
      }
      case "disconnect_nodes": {
        break;
      }
      case "swap_indices": {
        break;
      }
    }
  }
  return {
    adaptedBpcGraph
  };
};

// lib/graph-utils/addVec2.ts
var addVec2 = (a, b) => ({
  x: a.x + b.x,
  y: a.y + b.y
});

// lib/bpc-graph-editing/assignFloatingBoxPositions.ts
var assignFloatingBoxPositions = (og) => {
  const g = structuredClone(og);
  for (const box of g.boxes) {
    if (box.center !== void 0) {
      box.kind = "fixed";
    }
  }
  const floatingBoxes = g.boxes.filter((box) => box.kind === "floating" && !box.center).sort(
    (a, b) => og.pins.filter((p) => p.boxId === b.boxId).length - og.pins.filter((p) => p.boxId === a.boxId).length
  );
  if (floatingBoxes.length === 0) {
    return g;
  }
  const remainingBoxes = [...floatingBoxes];
  const placedBoxIds = new Set(
    g.boxes.filter((b) => b.center !== void 0).map((b) => b.boxId)
  );
  while (remainingBoxes.length > 0) {
    let placedAny = false;
    for (let i = remainingBoxes.length - 1; i >= 0; i--) {
      const box = remainingBoxes[i];
      const candidateCenters = [];
      const boxPins = og.pins.filter((p) => p.boxId === box.boxId);
      for (const pin of boxPins) {
        const networkPins = og.pins.filter(
          (p) => p.networkId === pin.networkId && p.boxId !== box.boxId && placedBoxIds.has(p.boxId)
        );
        for (const np of networkPins) {
          const npBox = g.boxes.find((b) => b.boxId === np.boxId);
          if (!npBox?.center) continue;
          const networkPinWorldPos = addVec2(npBox.center, np.offset);
          const inferredBoxCenter = {
            x: networkPinWorldPos.x - pin.offset.x,
            y: networkPinWorldPos.y - pin.offset.y
          };
          candidateCenters.push(inferredBoxCenter);
        }
      }
      if (candidateCenters.length > 0) {
        const center2 = candidateCenters.reduce(
          (acc, v) => ({ x: acc.x + v.x, y: acc.y + v.y }),
          { x: 0, y: 0 }
        );
        center2.x /= candidateCenters.length;
        center2.y /= candidateCenters.length;
        box.kind = "fixed";
        box.center = center2;
        placedBoxIds.add(box.boxId);
        remainingBoxes.splice(i, 1);
        placedAny = true;
      }
    }
    if (!placedAny && remainingBoxes.length > 0) {
      const box = remainingBoxes.pop();
      box.kind = "fixed";
      box.center = { x: 0, y: 0 };
      placedBoxIds.add(box.boxId);
    }
  }
  return g;
};

// lib/adjacency-matrix-network-similarity/getApproximateAssignments.ts
var addColor = (h, color) => {
  h[color] = (h[color] ?? 0) + 1;
};
var histToKey = (h) => Object.entries(h).sort(([c1], [c2]) => c1 < c2 ? -1 : 1).map(([c, n]) => `${c}:${n}`).join("|");
var jaccardLike = (a, b) => {
  const colours = /* @__PURE__ */ new Set([...Object.keys(a), ...Object.keys(b)]);
  let intersect = 0;
  let union = 0;
  for (const c of colours) {
    const v1 = a[c] ?? 0;
    const v2 = b[c] ?? 0;
    intersect += Math.min(v1, v2);
    union += Math.max(v1, v2);
  }
  return union === 0 ? 0 : intersect / union;
};
var summarise = (g) => {
  const boxHist = {};
  const netHist = {};
  const boxKeyBuckets = {};
  const netKeyBuckets = {};
  for (const pin of g.pins) {
    boxHist[pin.boxId] ??= {};
    addColor(boxHist[pin.boxId], pin.color);
    netHist[pin.networkId] ??= {};
    addColor(netHist[pin.networkId], pin.color);
  }
  for (const [boxId, h] of Object.entries(boxHist)) {
    const k = histToKey(h);
    boxKeyBuckets[k] ??= [];
    boxKeyBuckets[k].push(boxId);
  }
  for (const [netId, h] of Object.entries(netHist)) {
    const k = histToKey(h);
    netKeyBuckets[k] ??= [];
    netKeyBuckets[k].push(netId);
  }
  return { boxHist, netHist, boxKeyBuckets, netKeyBuckets };
};
var greedyMatch = (leftIds, rightIds, leftHist, rightHist) => {
  const assigned = {};
  const usedRight = /* @__PURE__ */ new Set();
  for (const l of leftIds) {
    let best;
    let bestScore = -1;
    for (const r of rightIds) {
      if (usedRight.has(r)) continue;
      const s = jaccardLike(leftHist[l], rightHist[r]);
      if (s > bestScore) {
        bestScore = s;
        best = r;
        if (s === 1) break;
      }
    }
    if (best !== void 0) {
      assigned[l] = best;
      usedRight.add(best);
    }
  }
  return assigned;
};
var getApproximateAssignments = (g1, g2) => {
  const s1 = summarise(g1);
  const s2 = summarise(g2);
  const boxAssignment = {};
  const netAssignment = {};
  const unmatchedBoxes1 = [];
  const unmatchedBoxes2 = [];
  const unmatchedNets1 = [];
  const unmatchedNets2 = [];
  const exactMatchBuckets = (b1, b2, push1, push2, out) => {
    const keys = /* @__PURE__ */ new Set([...Object.keys(b1), ...Object.keys(b2)]);
    for (const k of keys) {
      const arr1 = b1[k] ?? [];
      const arr2 = b2[k] ?? [];
      if (arr1.length === 1 && arr2.length === 1) {
        out[arr1[0]] = arr2[0];
      } else {
        push1.push(...arr1);
        push2.push(...arr2);
      }
    }
  };
  exactMatchBuckets(
    s1.boxKeyBuckets,
    s2.boxKeyBuckets,
    unmatchedBoxes1,
    unmatchedBoxes2,
    boxAssignment
  );
  exactMatchBuckets(
    s1.netKeyBuckets,
    s2.netKeyBuckets,
    unmatchedNets1,
    unmatchedNets2,
    netAssignment
  );
  Object.assign(
    boxAssignment,
    greedyMatch(unmatchedBoxes1, unmatchedBoxes2, s1.boxHist, s2.boxHist)
  );
  Object.assign(
    netAssignment,
    greedyMatch(unmatchedNets1, unmatchedNets2, s1.netHist, s2.netHist)
  );
  const nodeAssignment = {};
  for (const box of g1.boxes) {
    nodeAssignment[box.boxId] = boxAssignment[box.boxId];
    for (const pin of g1.pins) {
      if (pin.boxId !== box.boxId) continue;
      const targetNet = netAssignment[pin.networkId];
      for (const targetPin of g2.pins) {
        if (targetPin.networkId !== targetNet) continue;
        if (targetPin.boxId !== boxAssignment[box.boxId]) continue;
        if (nodeAssignment[`${pin.boxId}-${pin.pinId}`]) continue;
        nodeAssignment[`${pin.boxId}-${pin.pinId}`] = `${targetPin.boxId}-${targetPin.pinId}`;
      }
    }
  }
  return { boxAssignment, networkAssignment: netAssignment, nodeAssignment };
};

// lib/box-sides/getBoxSideSubgraph.ts
var sideToDirection = {
  left: "x-",
  right: "x+",
  top: "y+",
  bottom: "y-"
};
var getBoxSideSubgraph = ({
  bpcGraph,
  boxId,
  side
}) => {
  const dir = sideToDirection[side];
  const subgraph = { boxes: [], pins: [] };
  const box = bpcGraph.boxes.find((b) => b.boxId === boxId);
  if (!box) throw new Error(`Box "${boxId}" not found`);
  subgraph.boxes.push({ ...structuredClone(box), boxId });
  for (const p of bpcGraph.pins) {
    if (p.boxId === boxId) {
      const pDir = getPinDirection(bpcGraph, boxId, p.pinId);
      if (pDir === dir || pDir === null) {
        subgraph.pins.push(structuredClone(p));
      }
    }
  }
  const visitedNetIds = /* @__PURE__ */ new Set();
  for (const p of subgraph.pins) visitedNetIds.add(p.networkId);
  const addedPinIds = new Set(subgraph.pins.map((p) => p.pinId));
  const addedBoxIds = new Set(subgraph.boxes.map((b) => b.boxId));
  const addBoxIfNeeded = (boxId2) => {
    if (addedBoxIds.has(boxId2)) return;
    const b = bpcGraph.boxes.find((bb) => bb.boxId === boxId2);
    if (b) {
      subgraph.boxes.push(structuredClone(b));
      addedBoxIds.add(boxId2);
    }
  };
  const addPinIfNeeded = (pin) => {
    if (addedPinIds.has(pin.pinId)) return;
    subgraph.pins.push(structuredClone(pin));
    addedPinIds.add(pin.pinId);
    addBoxIfNeeded(pin.boxId);
  };
  for (const netId of visitedNetIds) {
    for (const pin of bpcGraph.pins) {
      if (pin.networkId === netId) {
        addPinIfNeeded(pin);
      }
    }
  }
  for (const b of subgraph.boxes) {
    if (b.boxId === boxId) continue;
    const allPinsOfBox = bpcGraph.pins.filter(
      // every pin in original graph
      (pin) => pin.boxId === b.boxId
    );
    for (const pin of allPinsOfBox) {
      addPinIfNeeded(pin);
    }
  }
  return subgraph;
};

// lib/box-sides/mergeBoxSideSubgraphs.ts
var mergeBoxSideSubgraphs = (graphs, {
  renetworkedNetworkIdMap
} = {}) => {
  renetworkedNetworkIdMap ??= {};
  if (graphs.length === 1) {
    return graphs[0];
  }
  const merged = { boxes: [], pins: [] };
  const boxMap = /* @__PURE__ */ new Map();
  const pinMap = /* @__PURE__ */ new Map();
  const partitionedBoxIds = Object.entries(
    graphs.flatMap((g) => Array.from(new Set(g.boxes.map((b) => b.boxId)))).reduce(
      (acc, str) => {
        acc[str] = (acc[str] || 0) + 1;
        return acc;
      },
      {}
    )
  ).filter(([_, count]) => count === graphs.length).map(([str]) => str);
  if (partitionedBoxIds.length > 1) {
    throw new Error(
      `Expected at most one shared box across all partitions, the following box ids are shared across all graphs: ${partitionedBoxIds.join(
        ", "
      )}`
    );
  }
  const partitionedBoxId = partitionedBoxIds[0];
  for (const g of graphs) {
    const offset = g.boxes.find((b) => b.boxId === partitionedBoxId)?.center;
    for (const box of g.boxes) {
      if (boxMap.has(box.boxId)) continue;
      const modifiedBox = structuredClone(box);
      if (modifiedBox.center && offset) {
        modifiedBox.center = {
          x: modifiedBox.center.x - offset.x,
          y: modifiedBox.center.y - offset.y
        };
      }
      boxMap.set(box.boxId, modifiedBox);
    }
    for (const pin of g.pins) {
      if (!pinMap.has(`${pin.boxId}-${pin.pinId}`))
        pinMap.set(`${pin.boxId}-${pin.pinId}`, structuredClone(pin));
    }
  }
  merged.boxes = Array.from(boxMap.values());
  merged.pins = Array.from(pinMap.values());
  return merged;
};

// lib/renetwork/renetworkWithCondition.ts
var renetworkWithCondition = (g, conditionStillConnected) => {
  const out = {
    boxes: g.boxes.map((b) => structuredClone(b)),
    pins: g.pins.map((p) => structuredClone(p))
  };
  const renetworkedNetworkIdMap = {};
  const boxById = /* @__PURE__ */ new Map();
  for (const box of out.boxes) {
    boxById.set(box.boxId, box);
  }
  let netIdCounter = 1;
  const usedNetIds = new Set(out.pins.map((p) => p.networkId));
  function getFreshNetId(base) {
    let candidate;
    do {
      candidate = `${base}_${netIdCounter++}`;
    } while (usedNetIds.has(candidate));
    renetworkedNetworkIdMap[candidate] = renetworkedNetworkIdMap[base] ?? base;
    usedNetIds.add(candidate);
    return candidate;
  }
  const pinsByNetwork = {};
  for (const pin of out.pins) {
    pinsByNetwork[pin.networkId] ??= [];
    pinsByNetwork[pin.networkId].push(pin);
  }
  for (const [networkId, pins] of Object.entries(pinsByNetwork)) {
    const adj = /* @__PURE__ */ new Map();
    for (const pin of pins) adj.set(pin.pinId, /* @__PURE__ */ new Set());
    for (let i = 0; i < pins.length; i++) {
      for (let j = i + 1; j < pins.length; j++) {
        const pinA = pins[i];
        const pinB = pins[j];
        const boxA = boxById.get(pinA.boxId);
        const boxB = boxById.get(pinB.boxId);
        if (conditionStillConnected(
          { box: boxA, pin: pinA },
          { box: boxB, pin: pinB },
          networkId
        )) {
          adj.get(pinA.pinId).add(pinB.pinId);
          adj.get(pinB.pinId).add(pinA.pinId);
        }
      }
    }
    const pinIdToComponent = {};
    let compIdx = 0;
    for (const pin of pins) {
      if (pinIdToComponent[pin.pinId] !== void 0) continue;
      const stack = [pin.pinId];
      while (stack.length) {
        const pid = stack.pop();
        if (pinIdToComponent[pid] !== void 0) continue;
        pinIdToComponent[pid] = compIdx;
        for (const nb of adj.get(pid) ?? []) {
          if (pinIdToComponent[nb] === void 0) stack.push(nb);
        }
      }
      compIdx++;
    }
    const pinsByComponent = {};
    for (const pin of pins) {
      const c = pinIdToComponent[pin.pinId];
      pinsByComponent[c] ??= [];
      pinsByComponent[c].push(pin);
    }
    let first = true;
    for (const [c, pinsInComp] of Object.entries(pinsByComponent)) {
      let newNetId;
      if (first) {
        newNetId = networkId;
        first = false;
      } else {
        newNetId = getFreshNetId(networkId);
      }
      for (const pin of pinsInComp) {
        pin.networkId = newNetId;
      }
    }
  }
  return {
    renetworkedGraph: out,
    renetworkedNetworkIdMap
  };
};

// lib/graph-utils/reflectGraph.ts
var reflectGraph = ({
  graph,
  axis,
  centerBoxId
}) => {
  const newGraph = structuredClone(graph);
  const centreBox = newGraph.boxes.find((b) => b.boxId === centerBoxId);
  if (!centreBox || !centreBox.center) {
    throw new Error(`Center box "${centerBoxId}" not found or has no center`);
  }
  const { x: cx, y: cy } = centreBox.center;
  for (const box of newGraph.boxes) {
    if (!box.center) continue;
    if (axis === "x") {
      box.center.x = 2 * cx - box.center.x;
    } else {
      box.center.y = 2 * cy - box.center.y;
    }
  }
  for (const pin of newGraph.pins) {
    if (axis === "x") {
      pin.offset.x = -pin.offset.x;
    } else {
      pin.offset.y = -pin.offset.y;
    }
  }
  return newGraph;
};

// lib/partition-processing/getCanonicalRightFacingGraph.ts
var getCanonicalRightFacingGraph = (g) => {
  let largestLeftRightBox = null;
  let largestLeftRightBoxPins = -Infinity;
  for (const box of g.boxes) {
    const lrPins = g.pins.filter((p) => p.boxId === box.boxId).filter(
      (p) => ["x-", "x+"].includes(getPinDirection(g, box, p) ?? "none")
    );
    if (lrPins.length > largestLeftRightBoxPins && lrPins.length > 1) {
      largestLeftRightBox = box;
      largestLeftRightBoxPins = lrPins.length;
    }
  }
  if (!largestLeftRightBox) {
    return { g, reflected: false, centerBoxId: null };
  }
  const largestBoxLRPinDirections = g.pins.filter((p) => p.boxId === largestLeftRightBox.boxId).map((p) => getPinDirection(g, largestLeftRightBox, p));
  const dirCounts = {
    "x+": 0,
    "x-": 0,
    "y+": 0,
    "y-": 0
  };
  for (const dir of largestBoxLRPinDirections) {
    if (!dir) continue;
    dirCounts[dir]++;
  }
  if (dirCounts["x+"] >= dirCounts["x-"]) {
    return { g, reflected: false, centerBoxId: largestLeftRightBox.boxId };
  }
  return {
    g: reflectGraph({
      graph: g,
      axis: "x",
      centerBoxId: largestLeftRightBox.boxId
    }),
    reflected: true,
    centerBoxId: largestLeftRightBox.boxId
  };
};

// lib/partition-processing/SchematicPartitionProcessor.ts
import Debug from "debug";
var debug = Debug("schematic-partition-processor");
var SchematicPartitionProcessor = class {
  constructor(initialGraph, opts = {}) {
    this.initialGraph = initialGraph;
    this.lastGraph = initialGraph;
    this.singletonKeys = opts.singletonKeys ?? [];
    this.centerPinColors = opts.centerPinColors ?? [];
    const partitionInit = this.initializeWipPartitions();
    this.wipPartitions = partitionInit.wipPartitions;
    this.splitBoxIds = partitionInit.splitBoxIds;
    this.addedPins = partitionInit.addedPins;
    this.exploredPins = /* @__PURE__ */ new Set();
    this.unexploredPins = this.wipPartitions.flatMap(
      (part) => part.pins.map((p) => ({ ...p, partitionId: part.partitionId }))
    );
    this.boxSingletonKeys = this.initializeBoxSingletonKeys();
    this.pinConnectionCount = (() => {
      const counts = {};
      for (const pin of this.initialGraph.pins) {
        counts[`${pin.boxId}:${pin.pinId}`] = this.getNeighbors(pin).length;
      }
      return counts;
    })();
    const netCounts = {};
    for (const p of this.initialGraph.pins) {
      netCounts[p.networkId] = (netCounts[p.networkId] ?? 0) + 1;
    }
    this.networkSize = netCounts;
    const pNetSize = {};
    for (const p of this.initialGraph.pins) {
      pNetSize[`${p.boxId}:${p.pinId}`] = netCounts[p.networkId];
    }
    this.pinNetworkSize = pNetSize;
  }
  // frames: GraphicsObject[] = []
  lastGraph;
  lastExploredPin;
  solved = false;
  iteration = 0;
  wipPartitions;
  unexploredPins = [];
  boxSingletonKeys;
  /**
   * Pins we have *investigated* per partition
   *   key =  `${partitionId}[${boxId}:${pinId}]`
   */
  exploredPins;
  /**
   * Pins that have actually been *added* to some partition
   *   key =  `${boxId}:${string}`
   */
  addedPins;
  /**
   * All pins that have been accepted into any partition (regardless of duplicability)
   *   key =  `${boxId}:${string}`
   */
  allAcceptedPins = /* @__PURE__ */ new Set();
  /**
   * Cached fan-out ( #neighbors ) for every pin
   *   key = `${boxId}:${pinId}`
   */
  pinConnectionCount;
  /**
   * #pins on each network      key = networkId
   */
  networkSize;
  /**
   * Network-size for each pin  key = `${boxId}:${pinId}`
   */
  pinNetworkSize;
  /**
   * Boxes that have been split into multiple partitions
   *   key = boxId
   */
  splitBoxIds;
  /**
   * Track which boxes have been accepted into partitions
   *   key = boxId, value = partitionId where it was first accepted
   */
  acceptedBoxPartitionMap = /* @__PURE__ */ new Map();
  singletonKeys;
  /**
   * Center pins are alignment pins, they are duplicated to wherever a box is
   * copied and are duplicated across partitions
   */
  centerPinColors;
  initializeBoxSingletonKeys() {
    const boxSingletonKeys = {};
    for (const box of this.initialGraph.boxes) {
      const boxPins = this.initialGraph.pins.filter(
        (p) => p.boxId === box.boxId
      );
      const boxPinCount = boxPins.length;
      const singletonKeysForBox = boxPins.map((p) => `${p.color}/${boxPinCount}`).filter((k) => this.singletonKeys.includes(k));
      boxSingletonKeys[box.boxId] = new Set(singletonKeysForBox);
    }
    return boxSingletonKeys;
  }
  initializeWipPartitions() {
    const wipPartitions = [];
    const addedPins = /* @__PURE__ */ new Set();
    const splitBoxIds = /* @__PURE__ */ new Set();
    let partitionId = 0;
    for (const box of this.initialGraph.boxes) {
      const pins = this.initialGraph.pins.filter((p) => p.boxId === box.boxId).filter((p) => getPinDirection(this.initialGraph, box, p)).filter((p) => !this.centerPinColors.includes(p.color));
      if (pins.length < 4) {
        continue;
      }
      const uniqueDirections = new Set(
        pins.map((p) => getPinDirection(this.initialGraph, box, p))
      );
      if (uniqueDirections.size > 1) {
        splitBoxIds.add(box.boxId);
      }
      for (const direction of uniqueDirections) {
        const partition = {
          partitionId: `partition${partitionId++}`,
          filledSingletonSlots: /* @__PURE__ */ new Set(),
          pins: []
        };
        for (const pin of pins) {
          if (getPinDirection(this.initialGraph, box, pin) === direction) {
            partition.pins.push({ boxId: box.boxId, pinId: pin.pinId });
            addedPins.add(`${box.boxId}:${pin.pinId}`);
          }
        }
        wipPartitions.push(partition);
      }
    }
    if (wipPartitions.length === 0) {
      wipPartitions.push(this.createWipPartitionFromEntireGraph());
      this.solved = true;
    }
    debug(`splitBoxIds = ${Array.from(splitBoxIds).join(", ")}`);
    debug(
      `wipPartitions = ${wipPartitions.map((p) => p.partitionId).join(", ")}`
    );
    return { wipPartitions, splitBoxIds, addedPins };
  }
  createWipPartitionFromEntireGraph() {
    return {
      partitionId: "entire-graph",
      filledSingletonSlots: /* @__PURE__ */ new Set(),
      pins: this.initialGraph.pins.map((p) => ({
        boxId: p.boxId,
        pinId: p.pinId
      }))
    };
  }
  step() {
    if (this.solved) return;
    this.iteration++;
    debug(
      `
\u2500\u2500 Iteration ${this.iteration} \u2500\u2500  unexplored=${this.unexploredPins.length}  explored=${this.exploredPins.size}`
    );
    this.unexploredPins.sort((a, b) => {
      const aKey = `${a.boxId}:${a.pinId}`;
      const bKey = `${b.boxId}:${b.pinId}`;
      const netDiff = this.pinNetworkSize[aKey] - this.pinNetworkSize[bKey];
      if (netDiff !== 0) return netDiff;
      return this.pinConnectionCount[aKey] - this.pinConnectionCount[bKey];
    });
    if (this.unexploredPins.length === 0) {
      this.solved = true;
      return;
    }
    const current = this.unexploredPins.shift();
    const currentPinKey = `${current.boxId}:${current.pinId}`;
    debug(
      `Exploring pin ${current.boxId}:${current.pinId} for partition "${current.partitionId}"`
    );
    this.lastExploredPin = {
      ...current,
      partitionId: current.partitionId
    };
    const currentPinPartitionKey = `${current.partitionId}[${currentPinKey}]`;
    const currentPin = this.initialGraph.pins.find(
      (p) => p.boxId === current.boxId && p.pinId === current.pinId
    );
    if (!currentPin) return;
    if (this.exploredPins.has(currentPinPartitionKey)) return;
    const currentPartition = this.wipPartitions.find(
      (p) => p.partitionId === current.partitionId
    );
    if (!currentPartition) return;
    const pinAlreadyAcceptedIntoPartitionId = this.acceptedBoxPartitionMap.get(
      current.boxId
    );
    if (pinAlreadyAcceptedIntoPartitionId && pinAlreadyAcceptedIntoPartitionId !== current.partitionId && !this.splitBoxIds.has(current.boxId)) {
      debug(
        `  \u21B3 rejected (box ${current.boxId} for partition ${current.partitionId} already in partition ${this.acceptedBoxPartitionMap.get(current.boxId)})`
      );
      this.exploredPins.add(currentPinPartitionKey);
      return;
    }
    const singletonKeysForBox = this.boxSingletonKeys[current.boxId];
    const hasConflict = Array.from(singletonKeysForBox).some(
      (k) => currentPartition.filledSingletonSlots.has(k)
    );
    if (hasConflict) {
      debug(
        `  \u21B3 rejected (singleton already in partition "${current.partitionId}")`
      );
      this.exploredPins.add(currentPinPartitionKey);
      return;
    }
    for (const k of singletonKeysForBox) {
      currentPartition.filledSingletonSlots.add(k);
    }
    currentPartition.pins.push({ boxId: current.boxId, pinId: current.pinId });
    this.allAcceptedPins.add(currentPinKey);
    this.addedPins.add(currentPinKey);
    if (!this.splitBoxIds.has(current.boxId)) {
      this.acceptedBoxPartitionMap.set(current.boxId, current.partitionId);
    }
    this.exploredPins.add(currentPinPartitionKey);
    debug(
      `  \u21B3 accepted \u2192 pins in partition now = ${currentPartition.pins.length}`
    );
    const neighbors = this.getNeighbors(currentPin);
    for (const neighbor of neighbors) {
      const neighborPinKey = `${neighbor.boxId}:${neighbor.pinId}`;
      if (this.addedPins.has(neighborPinKey)) continue;
      if (this.centerPinColors.includes(neighbor.color)) continue;
      if (this.exploredPins.has(
        `${current.partitionId}[${neighborPinKey}]`
      ))
        continue;
      this.unexploredPins.push({
        boxId: neighbor.boxId,
        pinId: neighbor.pinId,
        partitionId: current.partitionId
      });
    }
    if (this.unexploredPins.length === 0) this.solved = true;
    if (this.solved) {
      debug(
        `Solver finished in ${this.iteration} iterations, partitions=${this.getPartitions().length}`
      );
    }
  }
  /**
   * Returns all pins reachable from the given pin
   *
   * A pin traverses it's own box as well as it's network
   */
  getNeighbors(pin) {
    const neighbors = [];
    for (const pinInNetwork of this.initialGraph.pins) {
      if (pinInNetwork.networkId !== pin.networkId) continue;
      if (pin.boxId === pinInNetwork.boxId && pinInNetwork.pinId === pin.pinId)
        continue;
      neighbors.push(pinInNetwork);
    }
    for (const pinInBox of this.initialGraph.pins) {
      if (pinInBox.boxId !== pin.boxId) continue;
      neighbors.push(pinInBox);
    }
    return neighbors;
  }
  solve() {
    while (!this.solved && this.iteration < 1e3) {
      this.step();
    }
  }
  getPartitions() {
    if (!this.solved) throw new Error("Graph not solved");
    const partitions = [];
    for (const part of this.wipPartitions) {
      if (part.pins.length === 0) continue;
      const partBoxIds = new Set(part.pins.map((p) => p.boxId));
      const partBoxes = this.initialGraph.boxes.filter(
        (b) => partBoxIds.has(b.boxId)
      );
      partitions.push({
        boxes: partBoxes,
        pins: this.initialGraph.pins.filter(
          (p) => part.pins.some(
            (pp) => pp.pinId === p.pinId && pp.boxId === p.boxId
          ) || this.centerPinColors.includes(p.color) && partBoxIds.has(p.boxId)
        )
      });
    }
    return partitions;
  }
  getGraphicsForLastGraph() {
    const graphics = getGraphicsForBpcGraph(this.lastGraph, {
      title: `Iteration ${this.iteration}`
    });
    const total = this.wipPartitions.length;
    const PIN_RECT_SIZE = 0.4;
    this.wipPartitions.forEach((part, idx) => {
      if (part.pins.length === 0) return;
      const fill = getColorByIndex(idx, total, 0.25);
      for (const { boxId, pinId } of part.pins) {
        const { x, y } = getPinPosition(this.lastGraph, boxId, pinId);
        graphics.rects.push({
          center: { x, y },
          width: PIN_RECT_SIZE,
          height: PIN_RECT_SIZE,
          fill
        });
      }
    });
    if (this.lastExploredPin) {
      const { boxId, pinId, color } = this.lastExploredPin;
      const pos = getPinPosition(this.lastGraph, boxId, pinId);
      const size = 0.25;
      graphics.rects.push({
        center: { x: pos.x, y: pos.y },
        width: size,
        height: size,
        fill: this.lastExploredPin.partitionId ? getColorByIndex(
          this.wipPartitions.findIndex(
            (p) => p.partitionId === this.lastExploredPin.partitionId
          ),
          this.wipPartitions.length,
          1
        ) : "black"
      });
      graphics.texts.push({
        x: pos.x,
        y: pos.y,
        text: `${boxId}:${pinId}-${Array.from(this.boxSingletonKeys[boxId] ?? []).join(",")}`,
        fontSize: 0.1
      });
    }
    const unexploredRectBaseSize = PIN_RECT_SIZE;
    for (const pin of this.unexploredPins) {
      const { boxId, pinId, partitionId } = pin;
      const partitionIdx = this.wipPartitions.findIndex(
        (p) => p.partitionId === partitionId
      );
      if (partitionIdx === -1) continue;
      const stroke = getColorByIndex(partitionIdx, this.wipPartitions.length, 1);
      const { x, y } = getPinPosition(this.lastGraph, boxId, pinId);
      const scale = 1 + 0.1 * partitionIdx;
      graphics.rects.push({
        center: { x, y },
        width: unexploredRectBaseSize * scale,
        height: unexploredRectBaseSize * scale,
        fill: "none",
        stroke
        // If you need to represent stroke width, consider adding a comment or handling it elsewhere
      });
    }
    return graphics;
  }
};

// lib/match-graph/matchGraph.ts
var matchGraph = (g, corpus, opts = {}) => {
  opts.similarityMethod ??= "wl-distance";
  const distanceFn = getBpcGraphWlDistance;
  const corpusScores = Object.fromEntries(
    Object.entries(corpus).map(([k, v]) => [k, distanceFn(g, v)])
  );
  const bestMatch = Object.entries(corpusScores).reduce(
    (best, [k, d]) => d < best[1] ? [k, d] : best
  );
  return {
    graphName: bestMatch[0],
    graph: corpus[bestMatch[0]],
    distance: bestMatch[1],
    corpusScores
  };
};

// lib/graph-utils/getDirectionFromVec2.ts
var getDirectionFromVec2 = (vec2) => {
  if (vec2.x > 0) return "x+";
  if (vec2.x < 0) return "x-";
  if (vec2.y > 0) return "y+";
  if (vec2.y < 0) return "y-";
  return null;
};

// lib/graph-utils/getDirectionVec2.ts
var getDirectionVec2 = (direction) => {
  switch (direction) {
    case "x+":
      return { x: 1, y: 0 };
    case "x-":
      return { x: -1, y: 0 };
    case "y+":
      return { x: 0, y: 1 };
    case "y-":
      return { x: 0, y: -1 };
  }
};

// lib/graph-utils/getDominantPinSide.ts
var getDominantPinSide = (g, boxId) => {
  const box = g.boxes.find((b) => b.boxId === boxId);
  if (!box) throw new Error(`Box ${boxId} not found`);
  const pins = g.pins.filter((p) => p.boxId === boxId);
  const pinDirections = pins.map((p) => getPinDirection(g, box, p));
  const sideCounts = {
    "x-": 0,
    "x+": 0,
    "y-": 0,
    "y+": 0
  };
  for (const dir of pinDirections) {
    if (!dir) continue;
    sideCounts[dir]++;
  }
  const maxSideCount = Math.max(...Object.values(sideCounts));
  for (const key of Object.keys(sideCounts)) {
    if (sideCounts[key] === maxSideCount) {
      return key;
    }
  }
  return null;
};

// lib/bpc-graph-editing/pushFloatingBoxesAdjustingForFixedSizeDelta.ts
var pushFloatingBoxesAdjustingForFixedSizeDelta = (adaptedFloatingBpcGraph, fixedGraph, {
  floatingToFixedBoxAssignment,
  floatingBoxIdsWithMutablePinOffsets
}) => {
  for (const floatingBox of adaptedFloatingBpcGraph.boxes) {
    const fixedBoxId = floatingToFixedBoxAssignment[floatingBox.boxId];
    if (!fixedBoxId) continue;
    if (!floatingBox.center) continue;
    if (floatingBoxIdsWithMutablePinOffsets?.has(floatingBox.boxId)) continue;
    const fixedBoxBounds = getBoundsOfBpcBox(fixedGraph, fixedBoxId);
    const floatingBoxBounds = getBoundsOfBpcBox(
      adaptedFloatingBpcGraph,
      floatingBox.boxId
    );
    const fixedDominantPinSide = getDominantPinSide(fixedGraph, fixedBoxId);
    const floatingDominantPinSide = getDominantPinSide(
      adaptedFloatingBpcGraph,
      floatingBox.boxId
    );
    if (fixedDominantPinSide === null || floatingDominantPinSide === null)
      continue;
    if (fixedDominantPinSide !== floatingDominantPinSide) continue;
    const shiftVec = getDirectionVec2(fixedDominantPinSide);
    const fixedWidth = fixedBoxBounds.maxX - fixedBoxBounds.minX;
    const floatingWidth = floatingBoxBounds.maxX - floatingBoxBounds.minX;
    const fixedHeight = fixedBoxBounds.maxY - fixedBoxBounds.minY;
    const floatingHeight = floatingBoxBounds.maxY - floatingBoxBounds.minY;
    const deltaWidth = floatingWidth - fixedWidth;
    const deltaHeight = floatingHeight - fixedHeight;
    if (deltaWidth < 1e-3 && deltaHeight < 1e-3) continue;
    for (const otherBox of adaptedFloatingBpcGraph.boxes) {
      if (otherBox.boxId === floatingBox.boxId) continue;
      if (!otherBox.center) continue;
      const deltaPos = {
        x: otherBox.center.x - floatingBox.center.x,
        y: otherBox.center.y - floatingBox.center.y
      };
      const isToTheSideOf = getDirectionFromVec2({
        x: deltaPos.x * Math.abs(shiftVec.x),
        y: deltaPos.y * Math.abs(shiftVec.y)
      }) === fixedDominantPinSide;
      if (isToTheSideOf) {
        otherBox.center.x += shiftVec.x * deltaWidth;
        otherBox.center.y += shiftVec.y * deltaHeight;
      }
    }
  }
};

// lib/bpc-graph-editing/netAdaptBpcGraph2.ts
var netAdaptBpcGraph2 = (floatingGraph, fixedGraph, opts = {}) => {
  const { floatingBoxIdsWithMutablePinOffsets = /* @__PURE__ */ new Set() } = opts;
  const { floatingToFixedBoxAssignment, floatingToFixedPinAssignment } = getApproximateAssignments2(floatingGraph, fixedGraph);
  const adaptedBpcGraph = structuredClone(floatingGraph);
  for (const floatingPin of adaptedBpcGraph.pins) {
    if (!floatingBoxIdsWithMutablePinOffsets.has(floatingPin.boxId)) {
      continue;
    }
    if (floatingToFixedPinAssignment[floatingPin.boxId]?.[floatingPin.pinId]) {
      const fixedPinId = floatingToFixedPinAssignment[floatingPin.boxId]?.[floatingPin.pinId];
      const fixedBoxId = floatingToFixedBoxAssignment[floatingPin.boxId];
      const fixedPin = fixedGraph.pins.find(
        (p) => p.boxId === fixedBoxId && p.pinId === fixedPinId
      );
      if (fixedPin) {
        floatingPin.offset = fixedPin.offset;
      }
    }
  }
  for (const box of adaptedBpcGraph.boxes) {
    if (floatingToFixedBoxAssignment[box.boxId]) {
      const fixedBoxId = floatingToFixedBoxAssignment[box.boxId];
      const fixedBox = fixedGraph.boxes.find((b) => b.boxId === fixedBoxId);
      if (fixedBox) {
        box.center = fixedBox.center;
        box.kind = "fixed";
      }
    }
  }
  if (opts.pushBoxesAsBoxesChangeSize) {
    pushFloatingBoxesAdjustingForFixedSizeDelta(adaptedBpcGraph, fixedGraph, {
      floatingToFixedBoxAssignment,
      floatingBoxIdsWithMutablePinOffsets
    });
  }
  return adaptedBpcGraph;
};

// lib/schematic-layout/layoutSchematicGraph.ts
var layoutSchematicGraph = (g, {
  corpus,
  singletonKeys,
  centerPinColors,
  floatingBoxIdsWithMutablePinOffsets
}) => {
  const processor = new SchematicPartitionProcessor(g, {
    singletonKeys,
    centerPinColors
  });
  while (!processor.solved && processor.iteration < 1e3) {
    processor.step();
  }
  const partitions = processor.getPartitions();
  const canonicalPartitions = partitions.map(getCanonicalRightFacingGraph);
  const adaptedGraphs = canonicalPartitions.map((part) => {
    const { graph: corpusSource, distance } = matchGraph(part.g, corpus);
    const adaptedBpcGraph = netAdaptBpcGraph2(
      structuredClone(part.g),
      corpusSource,
      {
        floatingBoxIdsWithMutablePinOffsets,
        pushBoxesAsBoxesChangeSize: true
      }
    );
    return {
      adaptedBpcGraph,
      reflected: part.reflected,
      centerBoxId: part.centerBoxId,
      distance
    };
  });
  const adaptedUnreflectedGraphs = adaptedGraphs.map(
    ({ adaptedBpcGraph, reflected, centerBoxId }) => {
      if (!reflected) return adaptedBpcGraph;
      return reflectGraph({
        graph: adaptedBpcGraph,
        axis: "x",
        centerBoxId
      });
    }
  );
  const remergedGraph = mergeBoxSideSubgraphs(adaptedUnreflectedGraphs);
  const totalDistance = adaptedGraphs.reduce(
    (sum, ag) => sum + (ag.distance || 0),
    0
  );
  return {
    fixedGraph: remergedGraph,
    distance: totalDistance
  };
};

// lib/schematic-layout/layoutSchematicGraphVariants.ts
var layoutSchematicGraphVariants = (variants, {
  corpus,
  singletonKeys,
  centerPinColors,
  floatingBoxIdsWithMutablePinOffsets
}) => {
  const variantResults = [];
  let bestVariant = null;
  for (const variant of variants) {
    const { fixedGraph, distance } = layoutSchematicGraph(
      variant.floatingGraph,
      {
        corpus,
        singletonKeys,
        centerPinColors,
        floatingBoxIdsWithMutablePinOffsets
      }
    );
    variantResults.push({
      variantName: variant.variantName,
      distance
    });
    if (!bestVariant || distance < bestVariant.distance) {
      bestVariant = {
        variantName: variant.variantName,
        result: fixedGraph,
        distance
      };
    }
  }
  return {
    result: bestVariant.result,
    selectedVariantName: bestVariant.variantName,
    variantResults
  };
};
export {
  ForceDirectedLayoutSolver,
  SchematicPartitionProcessor,
  assignFloatingBoxPositions,
  convertFlatBpcToGraphics,
  getAdjacencyMatrixFromFlatBpcGraph,
  getApproximateAssignments,
  getBoxSideSubgraph,
  getBpcGraphWlDistance,
  getCanonicalRightFacingGraph,
  getGraphBounds,
  getGraphicsForBpcGraph,
  getGraphicsForFlatBpcGraph,
  getPinDirection,
  getPinDirectionOrThrow,
  getPinPosition,
  getWlDotProduct,
  getWlFeatureVecs,
  layoutSchematicGraph,
  layoutSchematicGraphVariants,
  mergeBoxSideSubgraphs,
  netAdaptBpcGraph,
  renetworkWithCondition,
  wlFeatureVec,
  wlVecCosineSimilarity,
  wlVecWeightedJaccardSimilarity
};
