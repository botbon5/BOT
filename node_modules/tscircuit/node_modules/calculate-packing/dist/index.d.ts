import { GraphicsObject, Point } from 'graphics-debug';
import { CircuitJson } from 'circuit-json';

type ComponentId = string;
type PadId = string;
type NetworkId = string;
interface InputPad {
    padId: string;
    networkId: string;
    type: "rect";
    offset: {
        x: number;
        y: number;
    };
    size: {
        x: number;
        y: number;
    };
}
interface OutputPad extends InputPad {
    absoluteCenter: {
        x: number;
        y: number;
    };
}
interface InputComponent {
    componentId: string;
    pads: InputPad[];
}
interface PackedComponent extends InputComponent {
    center: {
        x: number;
        y: number;
    };
    ccwRotationOffset: number;
    pads: OutputPad[];
}
interface PackInput {
    components: InputComponent[];
    minGap: number;
    packOrderStrategy: "largest_to_smallest";
    packPlacementStrategy: "shortest_connection_along_outline";
    disconnectedPackDirection?: "left" | "right" | "up" | "down";
    packFirst?: ComponentId[];
}
interface PackOutput extends PackInput {
    components: PackedComponent[];
}

/**
 * The pack algorithm performs the following steps:
 * 1. Sort the components using the packOrderStrategy
 * 2. Select the next component to pack
 * 3. If the first component, pack at center (0,0) and go to step 2
 * 4. Compute the outline of all packed components with a gap of minGap + max(pad.width, pad.height)/2
 * 5. Find the point along the outline that minimizes the distance of the pad
 *    centers within a networkId. If no shared pads, pack to the defaultPackDirection
 * 6. Add the component at the selected point, with it's pad at the position
 *    minimizing the distance between the pad centers
 * 7. To determine the component rotation, find the minimum distance between pad
 *    centers for the remaining pads at each possible rotation (making sure that
 *    we never pack such that two pads overlap)
 * 8. Go to step 2 until all components are packed
 */
declare const pack: (input: PackInput) => PackOutput;

declare class BaseSolver {
    MAX_ITERATIONS: number;
    solved: boolean;
    failed: boolean;
    iterations: number;
    progress: number;
    error: string | null;
    activeSubSolver?: BaseSolver | null;
    failedSubSolvers?: BaseSolver[];
    timeToSolve?: number;
    stats: Record<string, any>;
    _setupDone: boolean;
    setup(): void;
    /** DO NOT OVERRIDE! Override _step() instead */
    step(): void;
    _setup(): void;
    _step(): void;
    getConstructorParams(): void;
    solve(): void;
    visualize(): GraphicsObject;
    /**
     * Called when the solver is about to fail, but we want to see if we have an
     * "acceptable" or "passable" solution. Mostly used for optimizers that
     * have an aggressive early stopping criterion.
     */
    tryFinalAcceptance(): void;
    /**
     * A lightweight version of the visualize method that can be used to stream
     * progress
     */
    preview(): GraphicsObject;
}

/**
 * The pack algorithm performs the following steps:
 * 1. Sort the components using the packOrderStrategy
 * 2. Select the next component to pack
 * 3. If the first component, pack at center (0,0) and go to step 2
 * 4. Compute the outline of all packed components with a gap of minGap + max(pad.width, pad.height)/2
 * 5. Find the point along the outline that minimizes the distance of the pad
 *    centers within a networkId. If no shared pads, pack to the defaultPackDirection
 * 6. Add the component at the selected point, with it's pad at the position
 *    minimizing the distance between the pad centers
 * 7. To determine the component rotation, find the minimum distance between pad
 *    centers for the remaining pads at each possible rotation (making sure that
 *    we never pack such that two pads overlap)
 * 8. Go to step 2 until all components are packed
 */
declare class PackSolver extends BaseSolver {
    packInput: PackInput;
    unpackedComponentQueue: InputComponent[];
    packedComponents: PackedComponent[];
    lastBestPointsResult?: {
        bestPoints: (Point & {
            networkId: NetworkId;
        })[];
        distance: number;
    };
    lastEvaluatedPositionShadows?: Array<PackedComponent>;
    constructor(input: PackInput);
    _setup(): void;
    _step(): void;
    getConstructorParams(): PackInput[];
    /** Visualize the current packing state – components are omitted, only the outline is shown. */
    visualize(): GraphicsObject;
    getResult(): PackedComponent[];
}

declare const convertCircuitJsonToPackOutput: (circuitJson: CircuitJson) => PackOutput;

declare const getGraphicsFromPackOutput: (packOutput: PackOutput) => GraphicsObject;

/**
 * Strip all “output only” properties (those added by the pack() solver)
 * so the result can be fed back into pack() again or compared against an
 * original PackInput.  Everything else must be preserved verbatim.
 *
 * NOTE:
 * – PackInput.components is an array of **InputComponent**,
 *   while PackOutput.components is an array of **PackedComponent**.
 *   We therefore have to:
 *     • copy componentId
 *     • copy each pad but drop `absoluteCenter`
 *     • drop `center` and `ccwRotationOffset`
 */
declare const convertPackOutputToPackInput: (packed: PackOutput) => PackInput;

export { type ComponentId, type InputComponent, type InputPad, type NetworkId, type OutputPad, type PackInput, type PackOutput, PackSolver, type PackedComponent, type PadId, convertCircuitJsonToPackOutput, convertPackOutputToPackInput, getGraphicsFromPackOutput, pack };
