{"version":3,"sources":["../src/utils/convert-si-unit-to-number.ts","../src/units/index.ts","../src/common/point.ts","../src/utils/expect-types-match.ts","../src/common/point3.ts","../src/common/size.ts","../src/common/getZodPrefixedIdWithDefault.ts","../src/common/NinePointAnchor.ts","../src/source/source_simple_capacitor.ts","../src/pcb/properties/supplier_name.ts","../src/source/base/source_component_base.ts","../src/source/source_simple_resistor.ts","../src/source/source_simple_diode.ts","../src/source/source_simple_led.ts","../src/source/source_simple_ground.ts","../src/source/source_simple_chip.ts","../src/source/source_simple_power_source.ts","../src/source/any_source_component.ts","../src/source/source_simple_fuse.ts","../src/source/source_simple_battery.ts","../src/source/source_simple_inductor.ts","../src/source/source_simple_push_button.ts","../src/source/source_simple_potentiometer.ts","../src/source/source_simple_crystal.ts","../src/source/source_simple_pin_header.ts","../src/source/source_simple_resonator.ts","../src/source/source_simple_transistor.ts","../src/source/source_simple_test_point.ts","../src/source/source_simple_mosfet.ts","../src/source/source_simple_switch.ts","../src/source/source_project_metadata.ts","../src/source/source_missing_property_error.ts","../src/source/source_failed_to_create_component_error.ts","../src/source/source_port.ts","../src/source/source_trace.ts","../src/source/source_group.ts","../src/source/source_net.ts","../src/source/source_pcb_ground_plane.ts","../src/schematic/schematic_box.ts","../src/schematic/schematic_path.ts","../src/schematic/schematic_component.ts","../src/schematic/schematic_line.ts","../src/schematic/schematic_trace.ts","../src/schematic/schematic_text.ts","../src/common/FivePointAnchor.ts","../src/schematic/schematic_port.ts","../src/schematic/schematic_net_label.ts","../src/schematic/schematic_error.ts","../src/schematic/schematic_layout_error.ts","../src/schematic/schematic_debug_object.ts","../src/schematic/schematic_voltage_probe.ts","../src/schematic/schematic_manual_edit_conflict_warning.ts","../src/schematic/schematic_group.ts","../src/schematic/schematic_table.ts","../src/schematic/schematic_table_cell.ts","../src/pcb/properties/layer_ref.ts","../src/pcb/properties/pcb_route_hints.ts","../src/pcb/properties/route_hint_point.ts","../src/pcb/pcb_component.ts","../src/pcb/pcb_hole.ts","../src/pcb/pcb_plated_hole.ts","../src/pcb/pcb_port.ts","../src/pcb/pcb_smtpad.ts","../src/pcb/pcb_solder_paste.ts","../src/pcb/pcb_text.ts","../src/pcb/pcb_trace.ts","../src/pcb/pcb_trace_error.ts","../src/pcb/pcb_port_not_matched_error.ts","../src/pcb/pcb_via.ts","../src/pcb/pcb_board.ts","../src/pcb/pcb_placement_error.ts","../src/pcb/pcb_trace_hint.ts","../src/pcb/pcb_silkscreen_line.ts","../src/pcb/pcb_silkscreen_path.ts","../src/pcb/pcb_silkscreen_text.ts","../src/pcb/pcb_silkscreen_rect.ts","../src/pcb/pcb_silkscreen_circle.ts","../src/pcb/pcb_silkscreen_oval.ts","../src/pcb/pcb_fabrication_note_text.ts","../src/pcb/pcb_fabrication_note_path.ts","../src/pcb/pcb_footprint_overlap_error.ts","../src/pcb/pcb_keepout.ts","../src/pcb/pcb_cutout.ts","../src/pcb/pcb_missing_footprint_error.ts","../src/pcb/pcb_group.ts","../src/pcb/pcb_autorouting_error.ts","../src/pcb/pcb_manual_edit_conflict_warning.ts","../src/pcb/pcb_breakout_point.ts","../src/pcb/pcb_ground_plane.ts","../src/pcb/pcb_ground_plane_region.ts","../src/pcb/pcb_thermal_spoke.ts","../src/cad/cad_component.ts","../src/any_circuit_element.ts"],"sourcesContent":["type UnitInfo = {\n  baseUnit: BaseTscircuitUnit\n  conversionFactor: number\n}\n\nconst unitMappings: Record<\n  string,\n  { baseUnit: BaseTscircuitUnit; variants: Record<string, number> }\n> = {\n  Hz: {\n    baseUnit: \"Hz\",\n    variants: {\n      MHz: 1e6,\n      kHz: 1e3,\n      Hz: 1,\n    },\n  },\n  g: {\n    baseUnit: \"g\",\n    variants: {\n      kg: 1e3,\n      g: 1,\n    },\n  },\n  Ω: {\n    baseUnit: \"Ω\",\n    variants: {\n      mΩ: 1e-3,\n      Ω: 1,\n      kΩ: 1e3,\n      KΩ: 1e3,\n      kohm: 1e3,\n      MΩ: 1e6,\n      GΩ: 1e9,\n      TΩ: 1e12,\n    },\n  },\n  V: {\n    baseUnit: \"V\",\n    variants: {\n      mV: 1e-3,\n      V: 1,\n      kV: 1e3,\n      KV: 1e3,\n      MV: 1e6,\n      GV: 1e9,\n      TV: 1e12,\n    },\n  },\n  A: {\n    baseUnit: \"A\",\n    variants: {\n      µA: 1e-6,\n      mA: 1e-3,\n      ma: 1e-3,\n      A: 1,\n      kA: 1e3,\n      MA: 1e6,\n    },\n  },\n  F: {\n    baseUnit: \"F\",\n    variants: {\n      pF: 1e-12,\n      nF: 1e-9,\n      µF: 1e-6,\n      uF: 1e-6,\n      mF: 1e-3,\n      F: 1,\n    },\n  },\n  ml: {\n    baseUnit: \"ml\",\n    variants: {\n      ml: 1,\n      mL: 1,\n      l: 1e3,\n      L: 1e3,\n    },\n  },\n  deg: {\n    baseUnit: \"deg\",\n    variants: {\n      rad: 180 / Math.PI,\n    },\n  },\n  ms: {\n    baseUnit: \"ms\",\n    variants: {\n      s: 1000,\n    },\n  },\n  mm: {\n    baseUnit: \"mm\",\n    variants: {\n      nm: 1e-6,\n      µm: 1e-3,\n      um: 1e-3,\n      mm: 1,\n      cm: 10,\n      dm: 100,\n      m: 1000,\n      km: 1e6,\n      in: 25.4,\n      ft: 304.8,\n      IN: 25.4,\n      FT: 304.8,\n      yd: 914.4,\n      mi: 1.609344e6,\n      mil: 0.0254,\n    },\n  },\n}\n\nconst unitMappingAndVariantSuffixes = new Set()\nfor (const [baseUnit, info] of Object.entries(unitMappings)) {\n  unitMappingAndVariantSuffixes.add(baseUnit)\n  for (const variant of Object.keys(info.variants)) {\n    unitMappingAndVariantSuffixes.add(variant)\n  }\n}\n\nfunction getBaseTscircuitUnit(unit: string): UnitInfo {\n  for (const [baseUnit, info] of Object.entries(unitMappings)) {\n    if (unit in info.variants) {\n      return {\n        baseUnit: info.baseUnit,\n        conversionFactor: info.variants[unit]!,\n      }\n    }\n  }\n  return {\n    baseUnit: unit as BaseTscircuitUnit,\n    conversionFactor: 1,\n  }\n}\n\nconst si_prefix_multiplier = {\n  tera: 1e12,\n  T: 1e12,\n  giga: 1e9,\n  G: 1e9,\n  mega: 1e6,\n  M: 1e6,\n  kilo: 1e3,\n  k: 1e3,\n  deci: 1e-1,\n  d: 1e-1,\n  centi: 1e-2,\n  c: 1e-2,\n  milli: 1e-3,\n  m: 1e-3,\n  micro: 1e-6,\n  u: 1e-6,\n  µ: 1e-6,\n  nano: 1e-9,\n  n: 1e-9,\n  pico: 1e-12,\n  p: 1e-12,\n}\ntype BaseTscircuitUnit =\n  | \"ms\"\n  | \"mm\"\n  | \"g\"\n  | \"deg\"\n  | \"Hz\"\n  | \"ml\"\n  | \"V\"\n  | \"A\"\n  | \"Ω\"\n  | \"F\"\n  | \"H\"\n\nexport const parseAndConvertSiUnit = <\n  T extends\n    | string\n    | number\n    | undefined\n    | { x: string | number; y: string | number },\n>(\n  v: T,\n): {\n  parsedUnit: string | null\n  unitOfValue: BaseTscircuitUnit | null\n  value: T extends { x: string | number; y: string | number }\n    ? null | { x: number; y: number }\n    : null | number\n} => {\n  if (typeof v === \"undefined\")\n    return { parsedUnit: null, unitOfValue: null, value: null }\n  if (typeof v === \"string\" && v.match(/^-?[\\d\\.]+$/))\n    return {\n      value: Number.parseFloat(v) as any,\n      parsedUnit: null,\n      unitOfValue: null,\n    }\n  if (typeof v === \"number\")\n    return { value: v as any, parsedUnit: null, unitOfValue: null }\n  if (typeof v === \"object\" && \"x\" in v && \"y\" in v) {\n    const { parsedUnit, unitOfValue } = parseAndConvertSiUnit(v.x)\n    return {\n      parsedUnit: parsedUnit,\n      unitOfValue: unitOfValue,\n      value: {\n        x: parseAndConvertSiUnit(v.x as any).value as number,\n        y: parseAndConvertSiUnit(v.y as any).value as number,\n      } as any,\n    }\n  }\n  const reversed_input_string = v.toString().split(\"\").reverse().join(\"\")\n  const unit_reversed = reversed_input_string.match(/[^\\d\\s]+/)?.[0]\n  if (!unit_reversed) {\n    throw new Error(`Could not determine unit: \"${v}\"`)\n  }\n  const unit = unit_reversed.split(\"\").reverse().join(\"\")\n\n  const numberPart = v.slice(0, -unit.length)\n  if (\n    unit in si_prefix_multiplier &&\n    !unitMappingAndVariantSuffixes.has(unit)\n  ) {\n    const siMultiplier =\n      si_prefix_multiplier[unit as keyof typeof si_prefix_multiplier]\n    return {\n      parsedUnit: null,\n      unitOfValue: null,\n      value: (Number.parseFloat(numberPart) * siMultiplier) as any,\n    }\n  }\n\n  const { baseUnit, conversionFactor } = getBaseTscircuitUnit(unit)\n\n  return {\n    parsedUnit: unit,\n    unitOfValue: baseUnit,\n    value: (conversionFactor * Number.parseFloat(numberPart)) as any,\n  }\n}\n","import { parseAndConvertSiUnit } from \"src/utils/convert-si-unit-to-number\"\nimport { z } from \"zod\"\n\n// // Currently, removing uncommon SI Prefixes for type simplicity.\n// export type SIPrefix =\n//   // | \"y\"\n//   // | \"yocto\"\n//   // | \"z\"\n//   // | \"zepto\"\n//   // | \"atto\"\n//   // | \"a\"\n//   | \"femto\"\n//   | \"f\"\n//   | \"u\"\n//   | \"micro\"\n//   // | \"d\"\n//   // | \"deci\"\n//   | \"c\"\n//   | \"centi\"\n//   | \"m\"\n//   | \"milli\"\n//   | \"k\"\n//   | \"kilo\"\n//   | \"M\"\n//   | \"mega\"\n// // | \"G\"\n// // | \"T\"\n// // | \"P\"\n// // | \"E\"\n// // | \"Z\"\n// // | \"Y\"\n\n// export type UnitAbbreviations = {\n//   farad: \"F\"\n//   ohm: \"Ω\"\n//   henry: \"H\"\n//   meter: \"m\"\n//   volt: \"V\"\n//   inch: \"in\"\n//   foot: \"ft\"\n// }\n\n// export type Unit = keyof UnitAbbreviations\n// export type NumberWithUnit<T extends Unit> =\n//   | `${number}${T | UnitAbbreviations[T]}`\n//   | `${number} ${T | UnitAbbreviations[T]}`\n//   | `${number}${SIPrefix}${T | UnitAbbreviations[T]}`\n//   | `${number} ${SIPrefix}${T | UnitAbbreviations[T]}`\n// export type NumberWithAnyUnit =\n//   | `${number}${UnitOrAbbreviation}`\n//   | `${number} ${UnitOrAbbreviation}`\n//   | `${number}${SIPrefix}${UnitOrAbbreviation}`\n//   | `${number} ${SIPrefix}${UnitOrAbbreviation}`\n\n// TODO lots of validation to make sure the unit is valid etc.\nexport const resistance = z\n  .string()\n  .or(z.number())\n  .transform((v) => parseAndConvertSiUnit(v).value!)\n\nexport const capacitance = z\n  .string()\n  .or(z.number())\n  .transform((v) => parseAndConvertSiUnit(v).value!)\n  .transform((value) => {\n    return Number.parseFloat(value.toPrecision(12)) // Round to 12 significant digits\n  })\n\nexport const inductance = z\n  .string()\n  .or(z.number())\n  .transform((v) => parseAndConvertSiUnit(v).value!)\n\nexport const voltage = z\n  .string()\n  .or(z.number())\n  .transform((v) => parseAndConvertSiUnit(v).value!)\n\nexport const length = z\n  .string()\n  .or(z.number())\n  .transform((v) => parseAndConvertSiUnit(v).value!)\n\nexport const frequency = z\n  .string()\n  .or(z.number())\n  .transform((v) => parseAndConvertSiUnit(v).value!)\n\n/**\n * Length in meters\n */\nexport type Length = number\nexport type Distance = number\n\nexport const distance = length\n\nexport const current = z\n  .string()\n  .or(z.number())\n  .transform((v) => parseAndConvertSiUnit(v).value!)\n\nexport const time = z\n  .string()\n  .or(z.number())\n  .transform((v) => parseAndConvertSiUnit(v).value!)\n\n/**\n * Rotation is always converted to degrees\n */\nexport const rotation = z\n  .string()\n  .or(z.number())\n  .transform((arg): number => {\n    if (typeof arg === \"number\") return arg\n    if (arg.endsWith(\"deg\")) {\n      return Number.parseFloat(arg.split(\"deg\")[0]!)\n    }\n    if (arg.endsWith(\"rad\")) {\n      return (Number.parseFloat(arg.split(\"rad\")[0]!) * 180) / Math.PI\n    }\n    return Number.parseFloat(arg)\n  })\n\nexport const battery_capacity = z\n  .number()\n  .or(z.string().endsWith(\"mAh\"))\n  .transform((v) => {\n    if (typeof v === \"string\") {\n      const valString = v.replace(\"mAh\", \"\")\n      const num = Number.parseFloat(valString)\n      if (Number.isNaN(num)) {\n        throw new Error(\"Invalid capacity\")\n      }\n      return num\n    }\n    return v\n  })\n  .describe(\"Battery capacity in mAh\")\n\nexport type InputRotation = number | string\nexport type Rotation = number\n","import { z } from \"zod\"\nimport { distance } from \"../units\"\nimport { expectTypesMatch } from \"src/utils/expect-types-match\"\n\nexport const point = z.object({\n  x: distance,\n  y: distance,\n})\n\nexport const position = point\n\nexport type InputPoint = z.input<typeof point>\nexport type InputPosition = z.input<typeof position>\ntype InferredPoint = z.infer<typeof point>\ntype InferredPosition = z.infer<typeof position>\n\nexport interface Point {\n  x: number\n  y: number\n}\n\nexport interface Position {\n  x: number\n  y: number\n}\n\nexpectTypesMatch<Point, InferredPoint>(true)\nexpectTypesMatch<Position, InferredPosition>(true)\n","import type { TypeEqual } from \"ts-expect\"\n\ntype IsNever<T> = [T] extends [never] ? true : false\n\ntype GetMismatchedProps<T1, T2> = {\n  [K in keyof T1 & keyof T2]: T1[K] extends T2[K]\n    ? T2[K] extends T1[K]\n      ? never\n      : K\n    : K\n}[keyof T1 & keyof T2]\n\nexport const expectTypesMatch = <\n  const T1,\n  const T2,\n  T3 = Exclude<keyof T1, keyof T2>,\n  T4 = Exclude<keyof T2, keyof T1>,\n  T5 = GetMismatchedProps<T1, T2>,\n>(\n  shouldBe: IsNever<T3> extends true\n    ? IsNever<T4> extends true\n      ? IsNever<T5> extends true\n        ? TypeEqual<T1, T2>\n        : `mismatched prop types: ${T5 extends string ? T5 : \"\"}`\n      : `extra props ${T4 extends string ? T4 : \"\"}`\n    : `missing props ${T3 extends string ? T3 : \"\"}`,\n): void => {}\n\n// ------ TESTS -------\n\nexpectTypesMatch<\n  {\n    a: number\n  },\n  {\n    a: number\n    b: number\n  }\n>(\"extra props b\")\n\nexpectTypesMatch<\n  {\n    a: number\n    b: number\n  },\n  {\n    a: number\n  }\n>(\"missing props b\")\n\nexpectTypesMatch<\n  {\n    a: number\n  },\n  {\n    a: number\n  }\n>(true)\n\nexpectTypesMatch<\n  {\n    a: number\n  },\n  {\n    a: string\n  }\n>(\"mismatched prop types: a\")\n\n// ------ String Union Matching -------\n\nexport type ExpectStringUnionsMatch<\n  T1 extends string,\n  T2 extends string,\n  Diff1 = Exclude<T1, T2>,\n  Diff2 = Exclude<T2, T1>,\n> = IsNever<Diff1> extends true\n  ? IsNever<Diff2> extends true\n    ? true // Unions are identical\n    : `T2 has extra: \"${Diff2 extends string ? Diff2 : \"\"}\"` // T2 has elements not in T1\n  : IsNever<Diff2> extends true\n    ? `T1 has extra: \"${Diff1 extends string ? Diff1 : \"\"}\"` // T1 has elements not in T2\n    : `T1 has extra: \"${Diff1 extends string\n        ? Diff1\n        : \"\"}\", T2 has extra: \"${Diff2 extends string ? Diff2 : \"\"}\"` // Both have differences\n\nexport const expectStringUnionsMatch = <\n  const T1 extends string,\n  const T2 extends string,\n  ShouldBeTrue = ExpectStringUnionsMatch<T1, T2>,\n>(\n  shouldBe: ShouldBeTrue,\n): void => {}\n\n// ------ TESTS -------\n\ntype TestUnion1 = \"a\" | \"b\" | \"c\"\ntype TestUnion2 = \"a\" | \"b\" | \"c\"\ntype TestUnion3 = \"a\" | \"b\" | \"d\"\ntype TestUnion4 = \"a\" | \"b\"\n\nexpectStringUnionsMatch<TestUnion1, TestUnion2>(true)\nexpectStringUnionsMatch<TestUnion1, TestUnion3>(\n  'T1 has extra: \"c\", T2 has extra: \"d\"',\n)\nexpectStringUnionsMatch<TestUnion1, TestUnion4>('T1 has extra: \"c\"')\nexpectStringUnionsMatch<TestUnion4, TestUnion1>('T2 has extra: \"c\"')\nexpectStringUnionsMatch<TestUnion3, TestUnion1>(\n  'T1 has extra: \"d\", T2 has extra: \"c\"',\n)\n\n// Example of using @ts-expect-error for expected failures\n// @ts-expect-error Type '\"T2 has extra: \\\"d\\\"\"' is not assignable to type 'true'.\nexpectStringUnionsMatch<TestUnion1, TestUnion3>(true)\n","import { z } from \"zod\"\nimport { distance } from \"../units\"\nimport { expectTypesMatch } from \"src/utils/expect-types-match\"\n\nexport const point3 = z.object({\n  x: distance,\n  y: distance,\n  z: distance,\n})\n\nexport const position3 = point3\n\ntype InferredPoint3 = z.infer<typeof point3>\n\nexport interface Point3 {\n  x: number\n  y: number\n  z: number\n}\n\nexpectTypesMatch<Point3, InferredPoint3>(true)\n","import { z } from \"zod\"\nimport { expectTypesMatch } from \"src/utils/expect-types-match\"\n\nexport const size = z.object({\n  width: z.number(),\n  height: z.number(),\n})\n\nexport type SizeInput = z.input<typeof size>\ntype InferredSize = z.infer<typeof size>\n\nexport interface Size {\n  width: number\n  height: number\n}\n\nexpectTypesMatch<Size, InferredSize>(true)\n","import { z } from \"zod\"\nimport { nanoid } from \"nanoid\"\n\n/**\n * Use this for primary keys for any circuit element\n */\nexport const getZodPrefixedIdWithDefault = (prefix: string) => {\n  return z\n    .string()\n    .optional()\n    .default(() => `${prefix}_${nanoid(10)}`)\n}\n","import { z } from \"zod\"\nimport { expectTypesMatch } from \"src/utils/expect-types-match\"\n\nexport type NinePointAnchor =\n  | \"top_left\"\n  | \"top_center\"\n  | \"top_right\"\n  | \"center_left\"\n  | \"center\"\n  | \"center_right\"\n  | \"bottom_left\"\n  | \"bottom_center\"\n  | \"bottom_right\"\n\nexport const ninePointAnchor = z.enum([\n  \"top_left\",\n  \"top_center\",\n  \"top_right\",\n  \"center_left\",\n  \"center\",\n  \"center_right\",\n  \"bottom_left\",\n  \"bottom_center\",\n  \"bottom_right\",\n])\n\ntype InferredNinePointAnchor = z.infer<typeof ninePointAnchor>\n\nexpectTypesMatch<NinePointAnchor, InferredNinePointAnchor>(true)\n","import { z } from \"zod\"\nimport {\n  source_component_base,\n  type SourceComponentBase,\n} from \"src/source/base/source_component_base\"\nimport { capacitance, distance, voltage } from \"src/units\"\nimport { expectTypesMatch } from \"src/utils/expect-types-match\"\n\nexport const source_simple_capacitor = source_component_base.extend({\n  ftype: z.literal(\"simple_capacitor\"),\n  capacitance,\n  max_voltage_rating: voltage.optional(),\n  display_capacitance: z.string().optional(),\n  max_decoupling_trace_length: distance.optional(),\n})\n\nexport type SourceSimpleCapacitorInput = z.input<typeof source_simple_capacitor>\ntype InferredSourceSimpleCapacitor = z.infer<typeof source_simple_capacitor>\n\n/**\n * Defines a simple capacitor component\n */\nexport interface SourceSimpleCapacitor extends SourceComponentBase {\n  ftype: \"simple_capacitor\"\n  capacitance: number\n  max_voltage_rating?: number\n  display_capacitance?: string\n  max_decoupling_trace_length?: number\n}\n\nexpectTypesMatch<SourceSimpleCapacitor, InferredSourceSimpleCapacitor>(true)\n","import { z } from \"zod\"\nimport { expectTypesMatch } from \"src/utils/expect-types-match\"\n\nexport const supplier_name = z.enum([\n  \"jlcpcb\",\n  \"macrofab\",\n  \"pcbway\",\n  \"digikey\",\n  \"mouser\",\n  \"lcsc\",\n])\n\ntype InferredSupplierName = z.infer<typeof supplier_name>\n\nexport type SupplierName =\n  | \"jlcpcb\"\n  | \"macrofab\"\n  | \"pcbway\"\n  | \"digikey\"\n  | \"mouser\"\n  | \"lcsc\"\n\nexpectTypesMatch<SupplierName, InferredSupplierName>(true)\n","import {\n  supplier_name,\n  type SupplierName,\n} from \"src/pcb/properties/supplier_name\"\nimport { expectTypesMatch } from \"src/utils/expect-types-match\"\nimport { z } from \"zod\"\n\nexport interface SourceComponentBase {\n  type: \"source_component\"\n  ftype?: string\n  source_component_id: string\n  name: string\n  manufacturer_part_number?: string\n  supplier_part_numbers?: Partial<Record<SupplierName, string[]>>\n  display_value?: string\n  are_pins_interchangeable?: boolean\n  internally_connected_source_port_ids?: string[][]\n  source_group_id?: string\n  subcircuit_id?: string\n}\n\nexport const source_component_base = z.object({\n  type: z.literal(\"source_component\"),\n  ftype: z.string().optional(),\n  source_component_id: z.string(),\n  name: z.string(),\n  manufacturer_part_number: z.string().optional(),\n  supplier_part_numbers: z\n    .record(supplier_name, z.array(z.string()))\n    .optional(),\n  display_value: z.string().optional(),\n  are_pins_interchangeable: z.boolean().optional(),\n  internally_connected_source_port_ids: z.array(z.array(z.string())).optional(),\n  source_group_id: z.string().optional(),\n  subcircuit_id: z.string().optional(),\n})\n\ntype InferredSourceComponentBase = z.infer<typeof source_component_base>\n\nexpectTypesMatch<SourceComponentBase, InferredSourceComponentBase>(true)\n","import { z } from \"zod\"\nimport {\n  source_component_base,\n  type SourceComponentBase,\n} from \"src/source/base/source_component_base\"\nimport { resistance } from \"src/units\"\nimport { expectTypesMatch } from \"src/utils/expect-types-match\"\n\nexport const source_simple_resistor = source_component_base.extend({\n  ftype: z.literal(\"simple_resistor\"),\n  resistance,\n  display_resistance: z.string().optional(),\n})\n\nexport type SourceSimpleResistorInput = z.input<typeof source_simple_resistor>\ntype InferredSourceSimpleResistor = z.infer<typeof source_simple_resistor>\n\n/**\n * Defines a simple resistor component\n */\nexport interface SourceSimpleResistor extends SourceComponentBase {\n  ftype: \"simple_resistor\"\n  resistance: number\n  display_resistance?: string\n}\n\nexpectTypesMatch<SourceSimpleResistor, InferredSourceSimpleResistor>(true)\n","import {\n  source_component_base,\n  type SourceComponentBase,\n} from \"src/source/base/source_component_base\"\nimport { z } from \"zod\"\nimport { expectTypesMatch } from \"src/utils/expect-types-match\"\n\nexport const source_simple_diode = source_component_base.extend({\n  ftype: z.literal(\"simple_diode\"),\n})\n\nexport type SourceSimpleDiodeInput = z.input<typeof source_simple_diode>\ntype InferredSourceSimpleDiode = z.infer<typeof source_simple_diode>\n\n/**\n * Defines a simple diode component\n */\nexport interface SourceSimpleDiode extends SourceComponentBase {\n  ftype: \"simple_diode\"\n}\n\nexpectTypesMatch<SourceSimpleDiode, InferredSourceSimpleDiode>(true)\n","import {\n  source_component_base,\n  type SourceComponentBase,\n} from \"src/source/base/source_component_base\"\nimport { z } from \"zod\"\nimport { expectTypesMatch } from \"src/utils/expect-types-match\"\nimport {\n  source_simple_diode,\n  type SourceSimpleDiode,\n} from \"./source_simple_diode\"\n\nexport const source_simple_led = source_simple_diode.extend({\n  ftype: z.literal(\"simple_led\"),\n  color: z.string().optional(),\n  wavelength: z.string().optional(),\n})\n\nexport type SourceSimpleLedInput = z.input<typeof source_simple_led>\ntype InferredSourceSimpleLed = z.infer<typeof source_simple_led>\n\n/**\n * Defines a simple led component\n */\nexport interface SourceSimpleLed extends Omit<SourceSimpleDiode, \"ftype\"> {\n  ftype: \"simple_led\"\n  color?: string\n  wavelength?: string\n}\n\nexpectTypesMatch<SourceSimpleLed, InferredSourceSimpleLed>(true)\n","import {\n  source_component_base,\n  type SourceComponentBase,\n} from \"src/source/base/source_component_base\"\nimport { z } from \"zod\"\nimport { expectTypesMatch } from \"src/utils/expect-types-match\"\n\nexport const source_simple_ground = source_component_base.extend({\n  ftype: z.literal(\"simple_ground\"),\n})\n\nexport type SourceSimpleGroundInput = z.input<typeof source_simple_ground>\ntype InferredSourceSimpleGround = z.infer<typeof source_simple_ground>\n\n/**\n * Defines a simple ground component\n */\nexport interface SourceSimpleGround extends SourceComponentBase {\n  ftype: \"simple_ground\"\n}\n\nexpectTypesMatch<SourceSimpleGround, InferredSourceSimpleGround>(true)\n","import { z } from \"zod\"\nimport {\n  source_component_base,\n  type SourceComponentBase,\n} from \"src/source/base/source_component_base\"\nimport { expectTypesMatch } from \"src/utils/expect-types-match\"\n\nexport const source_simple_chip = source_component_base.extend({\n  ftype: z.literal(\"simple_chip\"),\n})\n\nexport type SourceSimpleChipInput = z.input<typeof source_simple_chip>\ntype InferredSourceSimpleChip = z.infer<typeof source_simple_chip>\n\n/**\n * Defines a simple integrated circuit component\n */\nexport interface SourceSimpleChip extends SourceComponentBase {\n  ftype: \"simple_chip\"\n}\n\nexpectTypesMatch<SourceSimpleChip, InferredSourceSimpleChip>(true)\n","import { z } from \"zod\"\nimport {\n  source_component_base,\n  type SourceComponentBase,\n} from \"src/source/base/source_component_base\"\nimport { voltage } from \"../units\"\nimport { expectTypesMatch } from \"src/utils/expect-types-match\"\n\nexport const source_simple_power_source = source_component_base.extend({\n  ftype: z.literal(\"simple_power_source\"),\n  voltage,\n})\n\nexport type SourceSimplePowerSourceInput = z.input<\n  typeof source_simple_power_source\n>\ntype InferredSourceSimplePowerSource = z.infer<\n  typeof source_simple_power_source\n>\n\n/**\n * Defines a simple power source component\n */\nexport interface SourceSimplePowerSource extends SourceComponentBase {\n  ftype: \"simple_power_source\"\n  voltage: number\n}\n\nexpectTypesMatch<SourceSimplePowerSource, InferredSourceSimplePowerSource>(true)\n","import { z } from \"zod\"\nimport { expectTypesMatch } from \"src/utils/expect-types-match\"\nimport {\n  source_simple_resistor,\n  type SourceSimpleResistor,\n} from \"./source_simple_resistor\"\nimport {\n  source_simple_capacitor,\n  type SourceSimpleCapacitor,\n} from \"./source_simple_capacitor\"\nimport { source_simple_fuse, type SourceSimpleFuse } from \"./source_simple_fuse\"\nimport {\n  source_simple_diode,\n  type SourceSimpleDiode,\n} from \"./source_simple_diode\"\nimport { source_simple_led, type SourceSimpleLed } from \"./source_simple_led\"\nimport {\n  source_simple_ground,\n  type SourceSimpleGround,\n} from \"./source_simple_ground\"\nimport { source_simple_chip, type SourceSimpleChip } from \"./source_simple_chip\"\nimport {\n  source_simple_power_source,\n  type SourceSimplePowerSource,\n} from \"./source_simple_power_source\"\nimport {\n  source_simple_battery,\n  type SourceSimpleBattery,\n} from \"./source_simple_battery\"\nimport {\n  source_simple_inductor,\n  type SourceSimpleInductor,\n} from \"./source_simple_inductor\"\nimport {\n  source_simple_push_button,\n  type SourceSimplePushButton,\n} from \"./source_simple_push_button\"\nimport {\n  source_simple_potentiometer,\n  type SourceSimplePotentiometer,\n} from \"./source_simple_potentiometer\"\nimport {\n  source_simple_crystal,\n  type SourceSimpleCrystal,\n} from \"./source_simple_crystal\"\nimport {\n  source_simple_pin_header,\n  type SourceSimplePinHeader,\n} from \"./source_simple_pin_header\"\nimport {\n  source_simple_resonator,\n  type SourceSimpleResonator,\n} from \"./source_simple_resonator\"\nimport {\n  source_simple_transistor,\n  type SourceSimpleTransistor,\n} from \"./source_simple_transistor\"\nimport {\n  source_simple_test_point,\n  type SourceSimpleTestPoint,\n} from \"./source_simple_test_point\"\nimport {\n  source_simple_mosfet,\n  type SourceSimpleMosfet,\n} from \"./source_simple_mosfet\"\nimport {\n  source_simple_switch,\n  type SourceSimpleSwitch,\n} from \"./source_simple_switch\"\nimport {\n  source_project_metadata,\n  type SourceProjectMetadata,\n} from \"./source_project_metadata\"\nimport {\n  source_missing_property_error,\n  type SourceMissingPropertyError,\n} from \"./source_missing_property_error\"\nimport {\n  source_failed_to_create_component_error,\n  type SourceFailedToCreateComponentError,\n} from \"./source_failed_to_create_component_error\"\n\nexport const any_source_component = z.union([\n  source_simple_resistor,\n  source_simple_capacitor,\n  source_simple_diode,\n  source_simple_led,\n  source_simple_ground,\n  source_simple_chip,\n  source_simple_power_source,\n  source_simple_battery,\n  source_simple_inductor,\n  source_simple_push_button,\n  source_simple_potentiometer,\n  source_simple_crystal,\n  source_simple_pin_header,\n  source_simple_resonator,\n  source_simple_switch,\n  source_simple_transistor,\n  source_simple_test_point,\n  source_simple_mosfet,\n  source_simple_fuse,\n  source_project_metadata,\n  source_missing_property_error,\n  source_failed_to_create_component_error,\n])\n\n/**\n * Deprecated: use `AnySourceElement` instead\n */\nexport type AnySourceComponent = z.infer<typeof any_source_component>\n\nexport type AnySourceElement =\n  | SourceSimpleResistor\n  | SourceSimpleCapacitor\n  | SourceSimpleDiode\n  | SourceSimpleLed\n  | SourceSimpleGround\n  | SourceSimpleChip\n  | SourceSimplePowerSource\n  | SourceSimpleBattery\n  | SourceSimpleInductor\n  | SourceSimplePushButton\n  | SourceSimplePotentiometer\n  | SourceSimpleCrystal\n  | SourceSimplePinHeader\n  | SourceSimpleResonator\n  | SourceSimpleSwitch\n  | SourceSimpleTransistor\n  | SourceSimpleTestPoint\n  | SourceSimpleMosfet\n  | SourceSimpleFuse\n  | SourceProjectMetadata\n  | SourceMissingPropertyError\n  | SourceFailedToCreateComponentError\n\nexpectTypesMatch<AnySourceElement, AnySourceComponent>(true)\n","import { z } from \"zod\"\nimport {\n  source_component_base,\n  type SourceComponentBase,\n} from \"./base/source_component_base\"\nimport { expectTypesMatch } from \"src/utils/expect-types-match\"\n\nexport const source_simple_fuse = source_component_base.extend({\n  ftype: z.literal(\"simple_fuse\"),\n\n  current_rating_amps: z\n    .number()\n    .describe(\"Nominal current in amps the fuse is rated for\"),\n\n  voltage_rating_volts: z\n    .number()\n    .describe(\"Voltage rating in volts, e.g. ±5V would be 5\"),\n})\n\nexport interface SourceSimpleFuse extends SourceComponentBase {\n  ftype: \"simple_fuse\"\n  current_rating_amps: number\n  voltage_rating_volts: number\n}\n\nexport type SourceSimpleFuseInput = z.input<typeof source_simple_fuse>\ntype InferredSourceSimpleFuse = z.infer<typeof source_simple_fuse>\n\nexpectTypesMatch<SourceSimpleFuse, InferredSourceSimpleFuse>(true)\n","import { z } from \"zod\"\nimport {\n  source_component_base,\n  type SourceComponentBase,\n} from \"src/source/base/source_component_base\"\nimport { battery_capacity } from \"src/units\"\nimport { expectTypesMatch } from \"src/utils/expect-types-match\"\n\nexport const source_simple_battery = source_component_base.extend({\n  ftype: z.literal(\"simple_battery\"),\n  capacity: battery_capacity,\n})\n\nexport type SourceSimpleBatteryInput = z.input<typeof source_simple_battery>\ntype InferredSourceSimpleBattery = z.infer<typeof source_simple_battery>\n\n/**\n * Defines a simple battery component\n */\nexport interface SourceSimpleBattery extends SourceComponentBase {\n  ftype: \"simple_battery\"\n  capacity: number\n}\n\nexpectTypesMatch<SourceSimpleBattery, InferredSourceSimpleBattery>(true)\n","import { z } from \"zod\"\nimport {\n  source_component_base,\n  type SourceComponentBase,\n} from \"src/source/base/source_component_base\"\nimport { inductance } from \"../units\"\nimport { expectTypesMatch } from \"src/utils/expect-types-match\"\n\nexport const source_simple_inductor = source_component_base.extend({\n  ftype: z.literal(\"simple_inductor\"),\n  inductance,\n  max_current_rating: z.number().optional(),\n})\n\nexport type SourceSimpleInductorInput = z.input<typeof source_simple_inductor>\ntype InferredSourceSimpleInductor = z.infer<typeof source_simple_inductor>\n\n/**\n * Defines a simple inductor component\n */\nexport interface SourceSimpleInductor extends SourceComponentBase {\n  ftype: \"simple_inductor\"\n  inductance: number\n  max_current_rating?: number\n}\n\nexpectTypesMatch<SourceSimpleInductor, InferredSourceSimpleInductor>(true)\n","import { z } from \"zod\"\nimport {\n  source_component_base,\n  type SourceComponentBase,\n} from \"src/source/base/source_component_base\"\nimport { expectTypesMatch } from \"src/utils/expect-types-match\"\n\nexport const source_simple_push_button = source_component_base.extend({\n  ftype: z.literal(\"simple_push_button\"),\n})\n\nexport type SourceSimplePushButtonInput = z.input<\n  typeof source_simple_push_button\n>\ntype InferredSourceSimplePushButton = z.infer<typeof source_simple_push_button>\n\n/**\n * Defines a simple push button component\n */\nexport interface SourceSimplePushButton extends SourceComponentBase {\n  ftype: \"simple_push_button\"\n}\n\nexpectTypesMatch<SourceSimplePushButton, InferredSourceSimplePushButton>(true)\n","import { z } from \"zod\"\nimport { source_component_base } from \"src/source/base/source_component_base\"\nimport { resistance } from \"src/units\"\nimport { expectTypesMatch } from \"src/utils/expect-types-match\"\n\nexport const source_simple_potentiometer = source_component_base.extend({\n  ftype: z.literal(\"simple_potentiometer\"),\n  max_resistance: resistance,\n})\n\nexport type SourceSimplePotentiometerInput = z.input<\n  typeof source_simple_potentiometer\n>\ntype InferredSourceSimplePotentiometer = z.infer<\n  typeof source_simple_potentiometer\n>\n\nexport interface SourceSimplePotentiometer\n  extends SourceSimplePotentiometerInput {\n  ftype: \"simple_potentiometer\"\n  max_resistance: number\n}\n\nexpectTypesMatch<SourceSimplePotentiometer, InferredSourceSimplePotentiometer>(\n  true,\n)\n","import { z } from \"zod\"\nimport {\n  source_component_base,\n  type SourceComponentBase,\n} from \"src/source/base/source_component_base\"\nimport { expectTypesMatch } from \"src/utils/expect-types-match\"\n\nexport const source_simple_crystal = source_component_base.extend({\n  ftype: z.literal(\"simple_crystal\"),\n  frequency: z.number().describe(\"Frequency in Hz\"),\n  load_capacitance: z.number().optional().describe(\"Load capacitance in pF\"),\n})\n\nexport type SourceSimpleCrystalInput = z.input<typeof source_simple_crystal>\ntype InferredSourceSimpleCrystal = z.infer<typeof source_simple_crystal>\n\n/**\n * Defines a simple crystal oscillator component\n */\nexport interface SourceSimpleCrystal extends SourceComponentBase {\n  ftype: \"simple_crystal\"\n  frequency: number\n  load_capacitance?: number\n}\n\nexpectTypesMatch<SourceSimpleCrystal, InferredSourceSimpleCrystal>(true)\n","import { source_component_base } from \"src/source/base/source_component_base\"\nimport { z } from \"zod\"\nimport { expectTypesMatch } from \"src/utils/expect-types-match\"\n\nexport const source_simple_pin_header = source_component_base.extend({\n  ftype: z.literal(\"simple_pin_header\"),\n  pin_count: z.number(),\n  gender: z.enum([\"male\", \"female\"]).optional().default(\"male\"),\n})\n\nexport type SourceSimplePinHeaderInput = z.input<\n  typeof source_simple_pin_header\n>\ntype InferredSourceSimplePinHeader = z.infer<typeof source_simple_pin_header>\n\nexport interface SourceSimplePinHeader extends SourceSimplePinHeaderInput {\n  ftype: \"simple_pin_header\"\n  pin_count: number\n  gender: \"male\" | \"female\"\n}\n\nexpectTypesMatch<SourceSimplePinHeader, InferredSourceSimplePinHeader>(true)\n","import { z } from \"zod\"\nimport {\n  source_component_base,\n  type SourceComponentBase,\n} from \"src/source/base/source_component_base\"\nimport { capacitance, resistance, frequency } from \"src/units\"\nimport { expectTypesMatch } from \"src/utils/expect-types-match\"\n\nexport const source_simple_resonator = source_component_base.extend({\n  ftype: z.literal(\"simple_resonator\"),\n  load_capacitance: capacitance,\n  equivalent_series_resistance: resistance.optional(),\n  frequency: frequency,\n})\n\nexport type SourceSimpleResonatorInput = z.input<typeof source_simple_resonator>\ntype InferredSourceSimpleResonator = z.infer<typeof source_simple_resonator>\n\n/**\n * Defines a simple resonator component\n */\nexport interface SourceSimpleResonator extends SourceComponentBase {\n  ftype: \"simple_resonator\"\n  load_capacitance: number\n  equivalent_series_resistance?: number\n  frequency: number\n}\n\nexpectTypesMatch<SourceSimpleResonator, InferredSourceSimpleResonator>(true)\n","import { z } from \"zod\"\nimport {\n  source_component_base,\n  type SourceComponentBase,\n} from \"src/source/base/source_component_base\"\nimport { expectTypesMatch } from \"src/utils/expect-types-match\"\n\nexport const source_simple_transistor = source_component_base.extend({\n  ftype: z.literal(\"simple_transistor\"),\n  transistor_type: z.enum([\"npn\", \"pnp\"]),\n})\n\nexport type SourceSimpleTransistorInput = z.input<\n  typeof source_simple_transistor\n>\ntype InferredSourceSimpleTransistor = z.infer<typeof source_simple_transistor>\n\n/**\n * Defines a simple transistor component\n * This is a three-pin semiconductor device (emitter, base, collector)\n * Pin configuration is handled by the schematic port system\n */\n\nexport interface SourceSimpleTransistor extends SourceComponentBase {\n  ftype: \"simple_transistor\"\n  transistor_type: \"npn\" | \"pnp\"\n}\n\nexpectTypesMatch<SourceSimpleTransistor, InferredSourceSimpleTransistor>(true)\n","import { z } from \"zod\"\nimport {\n  source_component_base,\n  type SourceComponentBase,\n} from \"src/source/base/source_component_base\"\nimport { expectTypesMatch } from \"src/utils/expect-types-match\"\n\nexport const source_simple_test_point = source_component_base.extend({\n  ftype: z.literal(\"simple_test_point\"),\n  footprint_variant: z.enum([\"pad\", \"through_hole\"]).optional(),\n  pad_shape: z.enum([\"rect\", \"circle\"]).optional(),\n  pad_diameter: z.union([z.number(), z.string()]).optional(),\n  hole_diameter: z.union([z.number(), z.string()]).optional(),\n  width: z.union([z.number(), z.string()]).optional(),\n  height: z.union([z.number(), z.string()]).optional(),\n})\n\nexport type SourceSimpleTestPointInput = z.input<\n  typeof source_simple_test_point\n>\ntype InferredSourceSimpleTestPoint = z.infer<typeof source_simple_test_point>\n\n/**\n * Defines a simple test point component\n * Can be surface-mount or through-hole.\n * Pad shape and dimensions configurable for different use cases.\n */\nexport interface SourceSimpleTestPoint extends SourceComponentBase {\n  ftype: \"simple_test_point\"\n  footprint_variant?: \"pad\" | \"through_hole\"\n  pad_shape?: \"rect\" | \"circle\"\n  pad_diameter?: number | string\n  hole_diameter?: number | string\n  width?: number | string\n  height?: number | string\n}\n\nexpectTypesMatch<SourceSimpleTestPoint, InferredSourceSimpleTestPoint>(true)\n","import { z } from \"zod\"\nimport {\n  source_component_base,\n  type SourceComponentBase,\n} from \"src/source/base/source_component_base\"\nimport { expectTypesMatch } from \"src/utils/expect-types-match\"\n\nexport const source_simple_mosfet = source_component_base.extend({\n  ftype: z.literal(\"simple_mosfet\"),\n  channel_type: z.enum([\"n\", \"p\"]),\n  mosfet_mode: z.enum([\"enhancement\", \"depletion\"]),\n})\n\nexport type SourceSimpleMosfetInput = z.input<typeof source_simple_mosfet>\ntype InferredSourceSimpleMosfet = z.infer<typeof source_simple_mosfet>\n\n/**\n * Defines a simple mosfet component\n * This is a three-pin semiconductor device (source, gate, drain)\n * Pin configuration is handled by the schematic port system\n */\n\nexport interface SourceSimpleMosfet extends SourceComponentBase {\n  ftype: \"simple_mosfet\"\n  channel_type: \"n\" | \"p\"\n  mosfet_mode: \"enhancement\" | \"depletion\"\n}\n\nexpectTypesMatch<SourceSimpleMosfet, InferredSourceSimpleMosfet>(true)\n","import { z } from \"zod\"\nimport {\n  source_component_base,\n  type SourceComponentBase,\n} from \"src/source/base/source_component_base\"\nimport { expectTypesMatch } from \"src/utils/expect-types-match\"\n\nexport const source_simple_switch = source_component_base.extend({\n  ftype: z.literal(\"simple_switch\"),\n})\nexport type SourceSimpleSwitchInput = z.input<typeof source_simple_switch>\ntype InferredSourceSimpleSwitch = z.infer<typeof source_simple_switch>\n\n/**\n * Defines a simple switch component\n */\nexport interface SourceSimpleSwitch extends SourceComponentBase {\n  ftype: \"simple_switch\"\n}\n\nexpectTypesMatch<SourceSimpleSwitch, InferredSourceSimpleSwitch>(true)\n","import { expectTypesMatch } from \"src/utils/expect-types-match\"\nimport { z } from \"zod\"\n\nexport interface SourceProjectMetadata {\n  type: \"source_project_metadata\"\n  name?: string\n  software_used_string?: string\n  project_url?: string\n  created_at?: string // ISO8601 timestamp\n}\n\nexport const source_project_metadata = z.object({\n  type: z.literal(\"source_project_metadata\"),\n  name: z.string().optional(),\n  software_used_string: z.string().optional(),\n  project_url: z.string().optional(),\n  created_at: z.string().datetime().optional(),\n})\n\nexport type InferredProjectMetadata = z.infer<typeof source_project_metadata>\nexpectTypesMatch<SourceProjectMetadata, InferredProjectMetadata>(true)\n","import { z } from \"zod\"\nimport { getZodPrefixedIdWithDefault } from \"src/common\"\nimport { expectTypesMatch } from \"src/utils/expect-types-match\"\n\nexport const source_missing_property_error = z\n  .object({\n    type: z.literal(\"source_missing_property_error\"),\n    source_missing_property_error_id: getZodPrefixedIdWithDefault(\n      \"source_missing_property_error\",\n    ),\n    source_component_id: z.string(),\n    property_name: z.string(),\n    subcircuit_id: z.string().optional(),\n    error_type: z\n      .literal(\"source_missing_property_error\")\n      .default(\"source_missing_property_error\"),\n    message: z.string(),\n  })\n  .describe(\"The source code is missing a property\")\n\nexport type SourceMissingPropertyErrorInput = z.input<\n  typeof source_missing_property_error\n>\ntype InferredSourceMissingPropertyError = z.infer<\n  typeof source_missing_property_error\n>\n\n/**\n * The source code is missing a property\n */\nexport interface SourceMissingPropertyError {\n  type: \"source_missing_property_error\"\n  source_missing_property_error_id: string\n  source_component_id: string\n  property_name: string\n  subcircuit_id?: string\n  error_type: \"source_missing_property_error\"\n  message: string\n}\n\nexpectTypesMatch<\n  SourceMissingPropertyError,\n  InferredSourceMissingPropertyError\n>(true)\n","import { z } from \"zod\"\nimport { getZodPrefixedIdWithDefault } from \"src/common\"\nimport { expectTypesMatch } from \"src/utils/expect-types-match\"\n\nexport const source_failed_to_create_component_error = z\n  .object({\n    type: z.literal(\"source_failed_to_create_component_error\"),\n    source_failed_to_create_component_error_id: getZodPrefixedIdWithDefault(\n      \"source_failed_to_create_component_error\",\n    ),\n    error_type: z\n      .literal(\"source_failed_to_create_component_error\")\n      .default(\"source_failed_to_create_component_error\"),\n    component_name: z.string().optional(),\n    subcircuit_id: z.string().optional(),\n    parent_source_component_id: z.string().optional(),\n    message: z.string(),\n    pcb_center: z\n      .object({\n        x: z.number().optional(),\n        y: z.number().optional(),\n      })\n      .optional(),\n    schematic_center: z\n      .object({\n        x: z.number().optional(),\n        y: z.number().optional(),\n      })\n      .optional(),\n  })\n  .describe(\"Error emitted when a component fails to be constructed\")\n\nexport type SourceFailedToCreateComponentErrorInput = z.input<\n  typeof source_failed_to_create_component_error\n>\ntype InferredSourceFailedToCreateComponentError = z.infer<\n  typeof source_failed_to_create_component_error\n>\n\n/**\n * Error emitted when a component fails to be constructed.\n * Contains details about the failure and prevents the component from being rendered.\n */\nexport interface SourceFailedToCreateComponentError {\n  type: \"source_failed_to_create_component_error\"\n  source_failed_to_create_component_error_id: string\n  error_type: \"source_failed_to_create_component_error\"\n  message: string\n  component_name?: string\n  subcircuit_id?: string\n  parent_source_component_id?: string\n  pcb_center?: {\n    x?: number\n    y?: number\n  }\n  schematic_center?: {\n    x?: number\n    y?: number\n  }\n}\n\nexpectTypesMatch<\n  SourceFailedToCreateComponentError,\n  InferredSourceFailedToCreateComponentError\n>(true)\n","import { z } from \"zod\"\nimport { expectTypesMatch } from \"src/utils/expect-types-match\"\n\nexport const source_port = z.object({\n  type: z.literal(\"source_port\"),\n  pin_number: z.number().optional(),\n  port_hints: z.array(z.string()).optional(),\n  name: z.string(),\n  source_port_id: z.string(),\n  source_component_id: z.string(),\n  subcircuit_id: z.string().optional(),\n  subcircuit_connectivity_map_key: z.string().optional(),\n})\n\nexport type SourcePortInput = z.input<typeof source_port>\ntype InferredSourcePort = z.infer<typeof source_port>\n\n/**\n * Defines a source port that can be connected to other components\n */\nexport interface SourcePort {\n  type: \"source_port\"\n  pin_number?: number\n  port_hints?: string[]\n  name: string\n  source_port_id: string\n  source_component_id: string\n  subcircuit_id?: string\n  subcircuit_connectivity_map_key?: string\n}\n\nexpectTypesMatch<SourcePort, InferredSourcePort>(true)\n","import { expectTypesMatch } from \"src/utils/expect-types-match\"\nimport { z } from \"zod\"\n\nexport interface SourceTrace {\n  type: \"source_trace\"\n  source_trace_id: string\n  connected_source_port_ids: string[]\n  connected_source_net_ids: string[]\n  subcircuit_id?: string\n  subcircuit_connectivity_map_key?: string\n  max_length?: number\n  display_name?: string\n  min_trace_thickness?: number\n}\n\nexport const source_trace = z.object({\n  type: z.literal(\"source_trace\"),\n  source_trace_id: z.string(),\n  connected_source_port_ids: z.array(z.string()),\n  connected_source_net_ids: z.array(z.string()),\n  subcircuit_id: z.string().optional(),\n  subcircuit_connectivity_map_key: z.string().optional(),\n  max_length: z.number().optional(),\n  min_trace_thickness: z.number().optional(),\n  display_name: z.string().optional(),\n})\n\ntype InferredSourceTrace = z.infer<typeof source_trace>\n\nexpectTypesMatch<SourceTrace, InferredSourceTrace>(true)\n","import { z } from \"zod\"\nimport { expectTypesMatch } from \"src/utils/expect-types-match\"\n\nexport const source_group = z.object({\n  type: z.literal(\"source_group\"),\n  source_group_id: z.string(),\n  subcircuit_id: z.string().optional(),\n  parent_subcircuit_id: z.string().optional(),\n  parent_source_group_id: z.string().optional(),\n  is_subcircuit: z.boolean().optional(),\n  name: z.string().optional(),\n})\n\nexport type SourceGroupInput = z.input<typeof source_group>\ntype InferredSourceGroup = z.infer<typeof source_group>\n\nexport interface SourceGroup {\n  type: \"source_group\"\n  source_group_id: string\n  subcircuit_id?: string\n  parent_subcircuit_id?: string\n  parent_source_group_id?: string\n  is_subcircuit?: boolean\n  name?: string\n}\n\nexpectTypesMatch<SourceGroup, InferredSourceGroup>(true)\n","import { z } from \"zod\"\nimport { expectTypesMatch } from \"src/utils/expect-types-match\"\n\nexport const source_net = z.object({\n  type: z.literal(\"source_net\"),\n  source_net_id: z.string(),\n  name: z.string(),\n  member_source_group_ids: z.array(z.string()),\n  is_power: z.boolean().optional(),\n  is_ground: z.boolean().optional(),\n  is_digital_signal: z.boolean().optional(),\n  is_analog_signal: z.boolean().optional(),\n  trace_width: z.number().optional(),\n  subcircuit_id: z.string().optional(),\n  subcircuit_connectivity_map_key: z.string().optional(),\n})\n\nexport type SourceNetInput = z.input<typeof source_net>\ntype InferredSourceNet = z.infer<typeof source_net>\n\nexport interface SourceNet {\n  type: \"source_net\"\n  source_net_id: string\n  name: string\n  member_source_group_ids: string[]\n  is_power?: boolean\n  is_ground?: boolean\n  is_digital_signal?: boolean\n  is_analog_signal?: boolean\n  trace_width?: number\n  subcircuit_id?: string\n  subcircuit_connectivity_map_key?: string\n}\n\nexpectTypesMatch<SourceNet, InferredSourceNet>(true)\n","import { z } from \"zod\"\nimport { expectTypesMatch } from \"src/utils/expect-types-match\"\n\nexport const source_pcb_ground_plane = z\n  .object({\n    type: z.literal(\"source_pcb_ground_plane\"),\n    source_pcb_ground_plane_id: z.string(),\n    source_group_id: z.string(),\n    source_net_id: z.string(),\n    subcircuit_id: z.string().optional(),\n  })\n  .describe(\"Defines a ground plane in the source domain\")\n\nexport type SourcePcbGroundPlaneInput = z.input<typeof source_pcb_ground_plane>\ntype InferredSourcePcbGroundPlane = z.infer<typeof source_pcb_ground_plane>\n\n/**\n * Defines a ground plane in the source domain\n */\nexport interface SourcePcbGroundPlane {\n  type: \"source_pcb_ground_plane\"\n  source_pcb_ground_plane_id: string\n  source_group_id: string\n  source_net_id: string\n  subcircuit_id?: string\n}\n\nexpectTypesMatch<SourcePcbGroundPlane, InferredSourcePcbGroundPlane>(true)\n","import { z } from \"zod\"\nimport { distance } from \"../units\"\nimport { expectTypesMatch } from \"src/utils/expect-types-match\"\n\nexport interface SchematicBox {\n  type: \"schematic_box\"\n  schematic_component_id?: string\n  width: number\n  height: number\n  is_dashed: boolean\n  x: number\n  y: number\n  subcircuit_id?: string\n}\n\nexport const schematic_box = z\n  .object({\n    type: z.literal(\"schematic_box\"),\n    schematic_component_id: z.string().optional(),\n    width: distance,\n    height: distance,\n    is_dashed: z.boolean().default(false),\n    x: distance,\n    y: distance,\n    subcircuit_id: z.string().optional(),\n  })\n  .describe(\"Draws a box on the schematic\")\n\nexport type SchematicBoxInput = z.input<typeof schematic_box>\ntype InferredSchematicBox = z.infer<typeof schematic_box>\n\nexpectTypesMatch<SchematicBox, InferredSchematicBox>(true)\n","import { z } from \"zod\"\nimport { point, type Point } from \"../common/point\"\nimport { expectTypesMatch } from \"src/utils/expect-types-match\"\n\nexport interface SchematicPath {\n  type: \"schematic_path\"\n  schematic_component_id: string\n  fill_color?: \"red\" | \"blue\"\n  is_filled?: boolean\n  points: Point[]\n  subcircuit_id?: string\n}\n\nexport const schematic_path = z.object({\n  type: z.literal(\"schematic_path\"),\n  schematic_component_id: z.string(),\n  fill_color: z.enum([\"red\", \"blue\"]).optional(),\n  is_filled: z.boolean().optional(),\n  points: z.array(point),\n  subcircuit_id: z.string().optional(),\n})\n\nexport type SchematicPathInput = z.input<typeof schematic_path>\ntype InferredSchematicPath = z.infer<typeof schematic_path>\n\nexpectTypesMatch<SchematicPath, InferredSchematicPath>(true)\n","import { z } from \"zod\"\nimport { point, type Point } from \"../common/point\"\nimport { size, type Size } from \"../common/size\"\nimport { length } from \"../units\"\nimport { expectTypesMatch } from \"src/utils/expect-types-match\"\n\nexport const schematic_pin_styles = z.record(\n  z.object({\n    left_margin: length.optional(),\n    right_margin: length.optional(),\n    top_margin: length.optional(),\n    bottom_margin: length.optional(),\n  }),\n)\n\nexport interface SchematicPortArrangementBySize {\n  left_size: number\n  right_size: number\n  top_size?: number\n  bottom_size?: number\n}\n\nexport interface SchematicPortArrangementBySides {\n  left_side?: { pins: number[]; direction?: \"top-to-bottom\" | \"bottom-to-top\" }\n  right_side?: { pins: number[]; direction?: \"top-to-bottom\" | \"bottom-to-top\" }\n  top_side?: { pins: number[]; direction?: \"left-to-right\" | \"right-to-left\" }\n  bottom_side?: {\n    pins: number[]\n    direction?: \"left-to-right\" | \"right-to-left\"\n  }\n}\n\nexport type SchematicPortArrangement =\n  | SchematicPortArrangementBySize\n  | SchematicPortArrangementBySides\n\nexport interface SchematicComponent {\n  type: \"schematic_component\"\n  size: Size\n  center: Point\n  source_component_id: string\n  schematic_component_id: string\n  pin_spacing?: number\n  pin_styles?: Record<\n    string,\n    {\n      left_margin?: number\n      right_margin?: number\n      top_margin?: number\n      bottom_margin?: number\n    }\n  >\n  box_width?: number\n  symbol_name?: string\n  port_arrangement?: SchematicPortArrangement\n  port_labels?: Record<string, string>\n  symbol_display_value?: string\n  subcircuit_id?: string\n  schematic_group_id?: string\n}\n\nexport const schematic_component_port_arrangement_by_size = z.object({\n  left_size: z.number(),\n  right_size: z.number(),\n  top_size: z.number().optional(),\n  bottom_size: z.number().optional(),\n})\n\nexpectTypesMatch<\n  SchematicPortArrangementBySize,\n  z.infer<typeof schematic_component_port_arrangement_by_size>\n>(true)\n\nexport const schematic_component_port_arrangement_by_sides = z.object({\n  left_side: z\n    .object({\n      pins: z.array(z.number()),\n      // @ts-ignore\n      direction: z.enum([\"top-to-bottom\", \"bottom-to-top\"]).optional(),\n    })\n    .optional(),\n  right_side: z\n    .object({\n      pins: z.array(z.number()),\n      // @ts-ignore\n      direction: z.enum([\"top-to-bottom\", \"bottom-to-top\"]).optional(),\n    })\n    .optional(),\n  top_side: z\n    .object({\n      pins: z.array(z.number()),\n      // @ts-ignore\n      direction: z.enum([\"left-to-right\", \"right-to-left\"]).optional(),\n    })\n    .optional(),\n  bottom_side: z\n    .object({\n      pins: z.array(z.number()),\n      // @ts-ignore\n      direction: z.enum([\"left-to-right\", \"right-to-left\"]).optional(),\n    })\n    .optional(),\n})\n\nexpectTypesMatch<\n  SchematicPortArrangementBySides,\n  z.infer<typeof schematic_component_port_arrangement_by_sides>\n>(true)\n\nexport const port_arrangement = z.union([\n  schematic_component_port_arrangement_by_size,\n  schematic_component_port_arrangement_by_sides,\n])\n\nexport const schematic_component = z.object({\n  type: z.literal(\"schematic_component\"),\n  size,\n  center: point,\n  source_component_id: z.string(),\n  schematic_component_id: z.string(),\n  pin_spacing: length.optional(),\n  pin_styles: schematic_pin_styles.optional(),\n  box_width: length.optional(),\n  symbol_name: z.string().optional(),\n  port_arrangement: port_arrangement.optional(),\n  port_labels: z.record(z.string()).optional(),\n  symbol_display_value: z.string().optional(),\n  subcircuit_id: z.string().optional(),\n  schematic_group_id: z.string().optional(),\n})\n\nexport type SchematicComponentInput = z.input<typeof schematic_component>\ntype InferredSchematicComponent = z.infer<typeof schematic_component>\n\nexpectTypesMatch<SchematicComponent, InferredSchematicComponent>(true)\n","import { z } from \"zod\"\nimport { distance } from \"../units\"\nimport { expectTypesMatch } from \"src/utils/expect-types-match\"\n\n/**\n * Defines a line on the schematic, this can be used for adding arbitrary lines\n * to a schematic, but don't use it for drawing traces, schematic boxes or where\n * other schematic elements are more appropriate.\n */\nexport interface SchematicLine {\n  type: \"schematic_line\"\n  schematic_component_id: string\n  x1: number\n  x2: number\n  y1: number\n  y2: number\n  subcircuit_id?: string\n}\n\nexport const schematic_line = z.object({\n  type: z.literal(\"schematic_line\"),\n  schematic_component_id: z.string(),\n  x1: distance,\n  x2: distance,\n  y1: distance,\n  y2: distance,\n  subcircuit_id: z.string().optional(),\n})\n\nexport type SchematicLineInput = z.input<typeof schematic_line>\ntype InferredSchematicLine = z.infer<typeof schematic_line>\n\nexpectTypesMatch<SchematicLine, InferredSchematicLine>(true)\n","import { z } from \"zod\"\nimport { distance } from \"../units\"\nimport { expectTypesMatch } from \"src/utils/expect-types-match\"\n\nexport interface SchematicTraceEdge {\n  from: {\n    x: number\n    y: number\n  }\n  to: {\n    x: number\n    y: number\n  }\n  is_crossing?: boolean\n  from_schematic_port_id?: string\n  to_schematic_port_id?: string\n}\n\nexport interface SchematicTrace {\n  type: \"schematic_trace\"\n  schematic_trace_id: string\n  source_trace_id: string\n  junctions: {\n    x: number\n    y: number\n  }[]\n  edges: SchematicTraceEdge[]\n  subcircuit_id?: string\n}\n\nexport const schematic_trace = z.object({\n  type: z.literal(\"schematic_trace\"),\n  schematic_trace_id: z.string(),\n  source_trace_id: z.string(),\n  junctions: z.array(\n    z.object({\n      x: z.number(),\n      y: z.number(),\n    }),\n  ),\n  edges: z.array(\n    z.object({\n      from: z.object({\n        x: z.number(),\n        y: z.number(),\n      }),\n      to: z.object({\n        x: z.number(),\n        y: z.number(),\n      }),\n      is_crossing: z.boolean().optional(),\n      from_schematic_port_id: z.string().optional(),\n      to_schematic_port_id: z.string().optional(),\n    }),\n  ),\n  subcircuit_id: z.string().optional(),\n})\n\nexport type SchematicTraceInput = z.input<typeof schematic_trace>\ntype InferredSchematicTrace = z.infer<typeof schematic_trace>\n\nexpectTypesMatch<SchematicTraceInput, InferredSchematicTrace>(true)\n","import { z } from \"zod\"\nimport { distance } from \"../units\"\nimport { expectTypesMatch } from \"src/utils/expect-types-match\"\nimport { ninePointAnchor } from \"src/common/NinePointAnchor\"\nimport type { NinePointAnchor } from \"src/common/NinePointAnchor\"\nimport type { FivePointAnchor } from \"src/common/FivePointAnchor\"\nimport { fivePointAnchor } from \"src/common/FivePointAnchor\"\n\nexport interface SchematicText {\n  type: \"schematic_text\"\n  schematic_component_id?: string\n  schematic_text_id: string\n  text: string\n  font_size: number\n  position: {\n    x: number\n    y: number\n  }\n  rotation: number\n  anchor: NinePointAnchor | FivePointAnchor\n  color: string\n  subcircuit_id?: string\n}\n\nexport const schematic_text = z.object({\n  type: z.literal(\"schematic_text\"),\n  schematic_component_id: z.string().optional(),\n  schematic_text_id: z.string(),\n  text: z.string(),\n  font_size: z.number().default(0.18),\n  position: z.object({\n    x: distance,\n    y: distance,\n  }),\n  rotation: z.number().default(0),\n  anchor: z\n    .union([fivePointAnchor.describe(\"legacy\"), ninePointAnchor])\n    .default(\"center\"),\n  color: z.string().default(\"#000000\"),\n  subcircuit_id: z.string().optional(),\n})\n\nexport type SchematicTextInput = z.input<typeof schematic_text>\ntype InferredSchematicText = z.infer<typeof schematic_text>\n\nexpectTypesMatch<SchematicText, InferredSchematicText>(true)\n","import { z } from \"zod\"\nimport { expectTypesMatch } from \"src/utils/expect-types-match\"\n\nexport type FivePointAnchor = \"center\" | \"left\" | \"right\" | \"top\" | \"bottom\"\n\nexport const fivePointAnchor = z.enum([\n  \"center\",\n  \"left\",\n  \"right\",\n  \"top\",\n  \"bottom\",\n])\n\ntype InferredFivePointAnchor = z.infer<typeof fivePointAnchor>\n\nexpectTypesMatch<FivePointAnchor, InferredFivePointAnchor>(true)\n","import { z } from \"zod\"\nimport { point, type Point } from \"../common\"\nimport { expectTypesMatch } from \"src/utils/expect-types-match\"\n\nexport interface SchematicPort {\n  type: \"schematic_port\"\n  schematic_port_id: string\n  source_port_id: string\n  schematic_component_id?: string\n  center: Point\n  facing_direction?: \"up\" | \"down\" | \"left\" | \"right\"\n  distance_from_component_edge?: number\n  side_of_component?: \"top\" | \"bottom\" | \"left\" | \"right\"\n  true_ccw_index?: number\n  pin_number?: number\n  display_pin_label?: string\n  subcircuit_id?: string\n  is_connected?: boolean\n}\n\nexport const schematic_port = z\n  .object({\n    type: z.literal(\"schematic_port\"),\n    schematic_port_id: z.string(),\n    source_port_id: z.string(),\n    schematic_component_id: z.string().optional(),\n    center: point,\n    facing_direction: z.enum([\"up\", \"down\", \"left\", \"right\"]).optional(),\n    distance_from_component_edge: z.number().optional(),\n    side_of_component: z.enum([\"top\", \"bottom\", \"left\", \"right\"]).optional(),\n    true_ccw_index: z.number().optional(),\n    pin_number: z.number().optional(),\n    display_pin_label: z.string().optional(),\n    subcircuit_id: z.string().optional(),\n    is_connected: z.boolean().optional(),\n  })\n  .describe(\"Defines a port on a schematic component\")\n\nexport type SchematicPortInput = z.input<typeof schematic_port>\ntype InferredSchematicPort = z.infer<typeof schematic_port>\n\nexpectTypesMatch<SchematicPort, InferredSchematicPort>(true)\n","import { z } from \"zod\"\nimport { point, type Point } from \"../common/point\"\nimport { expectTypesMatch } from \"src/utils/expect-types-match\"\nimport { getZodPrefixedIdWithDefault } from \"src/common\"\n\nexport interface SchematicNetLabel {\n  type: \"schematic_net_label\"\n  schematic_net_label_id: string\n  schematic_trace_id?: string\n  source_trace_id?: string\n  source_net_id: string\n  center: Point\n  anchor_position?: Point | undefined\n  anchor_side: \"top\" | \"bottom\" | \"left\" | \"right\"\n  text: string\n  symbol_name?: string | undefined\n  /**\n   * When true the net label can be repositioned. When false the label's\n   * position is fixed by the element it is attached to.\n   */\n  is_movable?: boolean\n  subcircuit_id?: string\n}\n\nexport const schematic_net_label = z.object({\n  type: z.literal(\"schematic_net_label\"),\n  schematic_net_label_id: getZodPrefixedIdWithDefault(\"schematic_net_label\"),\n  schematic_trace_id: z.string().optional(),\n  source_trace_id: z.string().optional(),\n  source_net_id: z.string(),\n  center: point,\n  anchor_position: point.optional(),\n  anchor_side: z.enum([\"top\", \"bottom\", \"left\", \"right\"]),\n  text: z.string(),\n  symbol_name: z.string().optional(),\n  is_movable: z.boolean().optional(),\n  subcircuit_id: z.string().optional(),\n})\n\nexport type SchematicNetLabelInput = z.input<typeof schematic_net_label>\nexport type InferredSchematicNetLabel = z.infer<typeof schematic_net_label>\n\nexpectTypesMatch<SchematicNetLabel, InferredSchematicNetLabel>(true)\n","import { z } from \"zod\"\nimport { expectTypesMatch } from \"src/utils/expect-types-match\"\n\nexport interface SchematicError {\n  type: \"schematic_error\"\n  schematic_error_id: string\n  error_type: \"schematic_port_not_found\"\n  message: string\n  subcircuit_id?: string\n}\n\nexport const schematic_error = z\n  .object({\n    type: z.literal(\"schematic_error\"),\n    schematic_error_id: z.string(),\n    // eventually each error type should be broken out into a dir of files\n    error_type: z\n      .literal(\"schematic_port_not_found\")\n      .default(\"schematic_port_not_found\"),\n    message: z.string(),\n    subcircuit_id: z.string().optional(),\n  })\n  .describe(\"Defines a schematic error on the schematic\")\n\nexport type SchematicErrorInput = z.input<typeof schematic_error>\ntype InferredSchematicError = z.infer<typeof schematic_error>\n\nexpectTypesMatch<SchematicError, InferredSchematicError>(true)\n","import { z } from \"zod\"\nimport { getZodPrefixedIdWithDefault } from \"src/common\"\nimport { expectTypesMatch } from \"src/utils/expect-types-match\"\n\nexport const schematic_layout_error = z\n  .object({\n    type: z.literal(\"schematic_layout_error\"),\n    schematic_layout_error_id: getZodPrefixedIdWithDefault(\n      \"schematic_layout_error\",\n    ),\n    error_type: z\n      .literal(\"schematic_layout_error\")\n      .default(\"schematic_layout_error\"),\n    message: z.string(),\n    source_group_id: z.string(),\n    schematic_group_id: z.string(),\n    subcircuit_id: z.string().optional(),\n  })\n  .describe(\"Error emitted when schematic layout fails for a group\")\n\nexport type SchematicLayoutErrorInput = z.input<typeof schematic_layout_error>\ntype InferredSchematicLayoutError = z.infer<typeof schematic_layout_error>\n\nexport interface SchematicLayoutError {\n  type: \"schematic_layout_error\"\n  schematic_layout_error_id: string\n  error_type: \"schematic_layout_error\"\n  message: string\n  source_group_id: string\n  schematic_group_id: string\n  subcircuit_id?: string\n}\n\nexpectTypesMatch<SchematicLayoutError, InferredSchematicLayoutError>(true)\n","import { z } from \"zod\"\nimport { point, type Point } from \"../common/point\"\nimport { size, type Size } from \"../common/size\"\nimport { expectTypesMatch } from \"src/utils/expect-types-match\"\n\nexport const schematic_debug_object_base = z.object({\n  type: z.literal(\"schematic_debug_object\"),\n  label: z.string().optional(),\n  subcircuit_id: z.string().optional(),\n})\n\nexport const schematic_debug_rect = schematic_debug_object_base.extend({\n  shape: z.literal(\"rect\"),\n  center: point,\n  size: size,\n})\n\nexport const schematic_debug_line = schematic_debug_object_base.extend({\n  shape: z.literal(\"line\"),\n  start: point,\n  end: point,\n})\n\nexport const schematic_debug_point = schematic_debug_object_base.extend({\n  shape: z.literal(\"point\"),\n  center: point,\n})\n\nexport const schematic_debug_object = z.discriminatedUnion(\"shape\", [\n  schematic_debug_rect,\n  schematic_debug_line,\n  schematic_debug_point,\n])\ntype InferredSchematicDebugObject = z.infer<typeof schematic_debug_object>\n\nexport interface SchematicDebugRect {\n  type: \"schematic_debug_object\"\n  label?: string\n  shape: \"rect\"\n  center: Point\n  size: Size\n  subcircuit_id?: string\n}\n\nexport interface SchematicDebugLine {\n  type: \"schematic_debug_object\"\n  label?: string\n  shape: \"line\"\n  start: Point\n  end: Point\n  subcircuit_id?: string\n}\n\nexport interface SchematicDebugPoint {\n  type: \"schematic_debug_object\"\n  label?: string\n  shape: \"point\"\n  center: Point\n  subcircuit_id?: string\n}\n\nexport type SchematicDebugObject =\n  | SchematicDebugRect\n  | SchematicDebugLine\n  | SchematicDebugPoint\n\nexpectTypesMatch<SchematicDebugObject, InferredSchematicDebugObject>(true)\nexport type SchematicDebugObjectInput = z.input<typeof schematic_debug_object>\n","import { z } from \"zod\"\nimport { point, type Point } from \"../common/point\"\nimport { expectTypesMatch } from \"src/utils/expect-types-match\"\nimport { voltage } from \"src/units\"\n\nexport interface SchematicVoltageProbe {\n  type: \"schematic_voltage_probe\"\n  schematic_voltage_probe_id: string\n  position: Point\n  schematic_trace_id: string\n  voltage?: number\n  subcircuit_id?: string\n}\n\nexport const schematic_voltage_probe = z\n  .object({\n    type: z.literal(\"schematic_voltage_probe\"),\n    schematic_voltage_probe_id: z.string(),\n    position: point,\n    schematic_trace_id: z.string(),\n    voltage: voltage.optional(),\n    subcircuit_id: z.string().optional(),\n  })\n  .describe(\"Defines a voltage probe measurement point on a schematic trace\")\n\nexport type SchematicVoltageProbeInput = z.input<typeof schematic_voltage_probe>\ntype InferredSchematicVoltageProbe = z.infer<typeof schematic_voltage_probe>\n\nexpectTypesMatch<SchematicVoltageProbe, InferredSchematicVoltageProbe>(true)\n","import { z } from \"zod\"\nimport { getZodPrefixedIdWithDefault } from \"../common\"\nimport { expectTypesMatch } from \"../utils/expect-types-match\"\n\nexport const schematic_manual_edit_conflict_warning = z\n  .object({\n    type: z.literal(\"schematic_manual_edit_conflict_warning\"),\n    schematic_manual_edit_conflict_warning_id: getZodPrefixedIdWithDefault(\n      \"schematic_manual_edit_conflict_warning\",\n    ),\n    warning_type: z\n      .literal(\"schematic_manual_edit_conflict_warning\")\n      .default(\"schematic_manual_edit_conflict_warning\"),\n    message: z.string(),\n    schematic_component_id: z.string(),\n    schematic_group_id: z.string().optional(),\n    subcircuit_id: z.string().optional(),\n    source_component_id: z.string(),\n  })\n  .describe(\n    \"Warning emitted when a component has both manual placement and explicit schX/schY coordinates\",\n  )\n\nexport type SchematicManualEditConflictWarningInput = z.input<\n  typeof schematic_manual_edit_conflict_warning\n>\ntype InferredSchematicManualEditConflictWarning = z.infer<\n  typeof schematic_manual_edit_conflict_warning\n>\n\n/**\n * Warning emitted when a component has both manual placement (via manualEdits) and explicit schX/schY coordinates\n */\nexport interface SchematicManualEditConflictWarning {\n  type: \"schematic_manual_edit_conflict_warning\"\n  schematic_manual_edit_conflict_warning_id: string\n  warning_type: \"schematic_manual_edit_conflict_warning\"\n  message: string\n  schematic_component_id: string\n  schematic_group_id?: string\n  subcircuit_id?: string\n  source_component_id: string\n}\n\nexpectTypesMatch<\n  SchematicManualEditConflictWarning,\n  InferredSchematicManualEditConflictWarning\n>(true)\n","import { z } from \"zod\"\nimport { point, type Point, getZodPrefixedIdWithDefault } from \"src/common\"\nimport { length, type Length } from \"src/units\"\nimport { expectTypesMatch } from \"src/utils/expect-types-match\"\n\nexport const schematic_group = z\n  .object({\n    type: z.literal(\"schematic_group\"),\n    schematic_group_id: getZodPrefixedIdWithDefault(\"schematic_group\"),\n    source_group_id: z.string(),\n    is_subcircuit: z.boolean().optional(),\n    subcircuit_id: z.string().optional(),\n    width: length,\n    height: length,\n    center: point,\n    schematic_component_ids: z.array(z.string()),\n    name: z.string().optional(),\n    description: z.string().optional(),\n  })\n  .describe(\"Defines a group of components on the schematic\")\n\nexport type SchematicGroupInput = z.input<typeof schematic_group>\ntype InferredSchematicGroup = z.infer<typeof schematic_group>\n\n/**\n * Defines a group of components on the schematic\n */\nexport interface SchematicGroup {\n  type: \"schematic_group\"\n  schematic_group_id: string\n  source_group_id: string\n  is_subcircuit?: boolean\n  subcircuit_id?: string\n  width: Length\n  height: Length\n  center: Point\n  schematic_component_ids: string[]\n  name?: string\n  description?: string\n}\n\nexpectTypesMatch<SchematicGroup, InferredSchematicGroup>(true)\n","import { z } from \"zod\"\nimport {\n  getZodPrefixedIdWithDefault,\n  ninePointAnchor,\n  point,\n  type NinePointAnchor,\n  type Point,\n} from \"src/common\"\nimport { distance, type Length } from \"src/units\"\nimport { expectTypesMatch } from \"src/utils/expect-types-match\"\n\nexport const schematic_table = z\n  .object({\n    type: z.literal(\"schematic_table\"),\n    schematic_table_id: getZodPrefixedIdWithDefault(\"schematic_table\"),\n    anchor_position: point,\n    column_widths: z.array(distance),\n    row_heights: z.array(distance),\n    cell_padding: distance.optional(),\n    border_width: distance.optional(),\n    subcircuit_id: z.string().optional(),\n    schematic_component_id: z.string().optional(),\n    anchor: ninePointAnchor.optional(),\n  })\n  .describe(\"Defines a table on the schematic\")\n\nexport type SchematicTableInput = z.input<typeof schematic_table>\ntype InferredSchematicTable = z.infer<typeof schematic_table>\n\n/**\n * Defines a table on the schematic, useful for displaying data in a structured format.\n */\nexport interface SchematicTable {\n  type: \"schematic_table\"\n  schematic_table_id: string\n  anchor_position: Point\n  column_widths: Length[]\n  row_heights: Length[]\n  cell_padding?: Length\n  border_width?: Length\n  subcircuit_id?: string\n  schematic_component_id?: string\n  anchor?: NinePointAnchor\n}\n\nexpectTypesMatch<SchematicTable, InferredSchematicTable>(true)\n","import { z } from \"zod\"\nimport { getZodPrefixedIdWithDefault, point, type Point } from \"src/common\"\nimport { distance, type Length } from \"src/units\"\nimport { expectTypesMatch } from \"src/utils/expect-types-match\"\n\nexport const schematic_table_cell = z\n  .object({\n    type: z.literal(\"schematic_table_cell\"),\n    schematic_table_cell_id: getZodPrefixedIdWithDefault(\n      \"schematic_table_cell\",\n    ),\n    schematic_table_id: z.string(),\n    start_row_index: z.number(),\n    end_row_index: z.number(),\n    start_column_index: z.number(),\n    end_column_index: z.number(),\n    text: z.string().optional(),\n    center: point,\n    width: distance,\n    height: distance,\n    horizontal_align: z.enum([\"left\", \"center\", \"right\"]).optional(),\n    vertical_align: z.enum([\"top\", \"middle\", \"bottom\"]).optional(),\n    font_size: distance.optional(),\n    subcircuit_id: z.string().optional(),\n  })\n  .describe(\"Defines a cell within a schematic_table\")\n\nexport type SchematicTableCellInput = z.input<typeof schematic_table_cell>\ntype InferredSchematicTableCell = z.infer<typeof schematic_table_cell>\n\n/**\n * Defines a cell within a schematic_table\n */\nexport interface SchematicTableCell {\n  type: \"schematic_table_cell\"\n  schematic_table_cell_id: string\n  schematic_table_id: string\n  start_row_index: number\n  end_row_index: number\n  start_column_index: number\n  end_column_index: number\n  text?: string\n  center: Point\n  width: Length\n  height: Length\n  horizontal_align?: \"left\" | \"center\" | \"right\"\n  vertical_align?: \"top\" | \"middle\" | \"bottom\"\n  font_size?: Length\n  subcircuit_id?: string\n}\n\nexpectTypesMatch<SchematicTableCell, InferredSchematicTableCell>(true)\n","import { z } from \"zod\"\nimport { expectTypesMatch } from \"src/utils/expect-types-match\"\n\nexport const all_layers = [\n  \"top\",\n  \"bottom\",\n  \"inner1\",\n  \"inner2\",\n  \"inner3\",\n  \"inner4\",\n  \"inner5\",\n  \"inner6\",\n] as const\n\nexport const layer_string = z.enum(all_layers)\n\nexport const layer_ref = layer_string\n  .or(\n    z.object({\n      name: layer_string,\n    }),\n  )\n  .transform((layer) => {\n    if (typeof layer === \"string\") {\n      return layer\n    }\n    return layer.name\n  })\n\nexport type LayerRefInput = z.input<typeof layer_ref>\ntype InferredLayerRef = z.output<typeof layer_ref>\nexport type LayerRef = (typeof all_layers)[number]\n\nexpectTypesMatch<LayerRef, InferredLayerRef>(true)\n\nexport const visible_layer = z.enum([\"top\", \"bottom\"])\nexport type VisibleLayerRef = z.infer<typeof visible_layer>\nexport type VisibleLayer = z.infer<typeof visible_layer>\n","import { z } from \"zod\"\nimport { distance } from \"src/units\"\nimport { layer_ref, type LayerRef } from \"./layer_ref\"\nimport { expectTypesMatch } from \"src/utils/expect-types-match\"\n\n// x: string | number\n// y: string | number\n// via?: boolean\n// via_to_layer?: string\nexport const pcb_route_hint = z.object({\n  x: distance,\n  y: distance,\n  via: z.boolean().optional(),\n  via_to_layer: layer_ref.optional(),\n})\nexport const pcb_route_hints = z.array(pcb_route_hint)\n\nexport type PcbRouteHintInput = z.input<typeof pcb_route_hint>\nexport type PcbRouteHintsInput = z.input<typeof pcb_route_hints>\ntype InferredPcbRouteHint = z.output<typeof pcb_route_hint>\ntype InferredPcbRouteHints = z.output<typeof pcb_route_hints>\n\nexport interface PcbRouteHint {\n  x: number\n  y: number\n  via?: boolean\n  via_to_layer?: LayerRef\n}\n\nexport type PcbRouteHints = PcbRouteHint[]\n\nexpectTypesMatch<PcbRouteHint, InferredPcbRouteHint>(true)\nexpectTypesMatch<PcbRouteHints, InferredPcbRouteHints>(true)\n","import { z } from \"zod\"\nimport { distance } from \"../../units\"\nimport { layer_ref, type LayerRef } from \"./layer_ref\"\nimport { expectTypesMatch } from \"src/utils/expect-types-match\"\n\nexport const route_hint_point = z.object({\n  x: distance,\n  y: distance,\n  via: z.boolean().optional(),\n  to_layer: layer_ref.optional(),\n  trace_width: distance.optional(),\n})\n\nexport type RouteHintPointInput = z.input<typeof route_hint_point>\ntype InferredRouteHintPoint = z.infer<typeof route_hint_point>\n\nexport interface RouteHintPoint {\n  x: number\n  y: number\n  via?: boolean\n  to_layer?: LayerRef\n  trace_width?: number\n}\n\nexpectTypesMatch<RouteHintPoint, InferredRouteHintPoint>(true)\n","import { z } from \"zod\"\nimport { point, type Point, getZodPrefixedIdWithDefault } from \"src/common\"\nimport { layer_ref, type LayerRef } from \"src/pcb/properties/layer_ref\"\nimport { rotation, length, type Rotation, type Length } from \"src/units\"\nimport { expectTypesMatch } from \"src/utils/expect-types-match\"\n\nexport const pcb_component = z\n  .object({\n    type: z.literal(\"pcb_component\"),\n    pcb_component_id: getZodPrefixedIdWithDefault(\"pcb_component\"),\n    source_component_id: z.string(),\n    center: point,\n    layer: layer_ref,\n    rotation: rotation,\n    width: length,\n    height: length,\n    subcircuit_id: z.string().optional(),\n    pcb_group_id: z.string().optional(),\n  })\n  .describe(\"Defines a component on the PCB\")\n\nexport type PcbComponentInput = z.input<typeof pcb_component>\ntype InferredPcbComponent = z.infer<typeof pcb_component>\n\n/**\n * Defines a component on the PCB\n */\nexport interface PcbComponent {\n  type: \"pcb_component\"\n  pcb_component_id: string\n  source_component_id: string\n  subcircuit_id?: string\n  center: Point\n  layer: LayerRef\n  rotation: Rotation\n  width: Length\n  height: Length\n  pcb_group_id?: string\n}\n\n/**\n * @deprecated use PcbComponent\n */\nexport type PCBComponent = PcbComponent\n\nexpectTypesMatch<PcbComponent, InferredPcbComponent>(true)\n","import { z } from \"zod\"\nimport { getZodPrefixedIdWithDefault } from \"src/common\"\nimport { distance, type Distance } from \"src/units\"\nimport { expectTypesMatch } from \"src/utils/expect-types-match\"\n\nconst pcb_hole_circle_or_square = z.object({\n  type: z.literal(\"pcb_hole\"),\n  pcb_hole_id: getZodPrefixedIdWithDefault(\"pcb_hole\"),\n  pcb_group_id: z.string().optional(),\n  subcircuit_id: z.string().optional(),\n  hole_shape: z.enum([\"circle\", \"square\"]),\n  hole_diameter: z.number(),\n  x: distance,\n  y: distance,\n})\n\nexport const pcb_hole_circle_or_square_shape =\n  pcb_hole_circle_or_square.describe(\n    \"Defines a circular or square hole on the PCB\",\n  )\n\nexport type PcbHoleCircleOrSquareInput = z.input<\n  typeof pcb_hole_circle_or_square\n>\ntype InferredPcbHoleCircleOrSquare = z.infer<typeof pcb_hole_circle_or_square>\n\n/**\n * Defines a circular or square hole on the PCB\n */\nexport interface PcbHoleCircleOrSquare {\n  type: \"pcb_hole\"\n  pcb_hole_id: string\n  pcb_group_id?: string\n  subcircuit_id?: string\n  hole_shape: \"circle\" | \"square\"\n  hole_diameter: number\n  x: Distance\n  y: Distance\n}\n\nexpectTypesMatch<PcbHoleCircleOrSquare, InferredPcbHoleCircleOrSquare>(true)\n\nconst pcb_hole_oval = z.object({\n  type: z.literal(\"pcb_hole\"),\n  pcb_hole_id: getZodPrefixedIdWithDefault(\"pcb_hole\"),\n  pcb_group_id: z.string().optional(),\n  subcircuit_id: z.string().optional(),\n  hole_shape: z.literal(\"oval\"),\n  hole_width: z.number(),\n  hole_height: z.number(),\n  x: distance,\n  y: distance,\n})\n\nexport const pcb_hole_oval_shape = pcb_hole_oval.describe(\n  \"Defines an oval hole on the PCB\",\n)\n\nexport type PcbHoleOvalInput = z.input<typeof pcb_hole_oval>\ntype InferredPcbHoleOval = z.infer<typeof pcb_hole_oval>\n\n/**\n * Defines an oval hole on the PCB\n */\nexport interface PcbHoleOval {\n  type: \"pcb_hole\"\n  pcb_hole_id: string\n  pcb_group_id?: string\n  subcircuit_id?: string\n  hole_shape: \"oval\"\n  hole_width: number\n  hole_height: number\n  x: Distance\n  y: Distance\n}\n\nexpectTypesMatch<PcbHoleOval, InferredPcbHoleOval>(true)\n\nexport const pcb_hole = pcb_hole_circle_or_square.or(pcb_hole_oval)\n\n/**\n * @deprecated Use PcbHoleCircleOrSquare or PcbHoleOval\n */\nexport type PCBHoleInput = z.input<typeof pcb_hole>\n/**\n * @deprecated Use PcbHoleCircleOrSquare or PcbHoleOval\n */\nexport type PCBHole = z.infer<typeof pcb_hole>\n\nexport type PcbHole = PcbHoleCircleOrSquare | PcbHoleOval\n","import { z } from \"zod\"\nimport { distance, type Distance } from \"src/units\"\nimport { layer_ref, type LayerRef } from \"src/pcb/properties/layer_ref\"\nimport { getZodPrefixedIdWithDefault } from \"src/common\"\nimport { expectTypesMatch } from \"src/utils/expect-types-match\"\n\nconst pcb_plated_hole_circle = z.object({\n  type: z.literal(\"pcb_plated_hole\"),\n  shape: z.literal(\"circle\"),\n  pcb_group_id: z.string().optional(),\n  subcircuit_id: z.string().optional(),\n  outer_diameter: z.number(),\n  hole_diameter: z.number(),\n  x: distance,\n  y: distance,\n  layers: z.array(layer_ref),\n  port_hints: z.array(z.string()).optional(),\n  pcb_component_id: z.string().optional(),\n  pcb_port_id: z.string().optional(),\n  pcb_plated_hole_id: getZodPrefixedIdWithDefault(\"pcb_plated_hole\"),\n})\n\n/**\n * Defines a circular plated hole on the PCB\n */\nexport interface PcbPlatedHoleCircle {\n  type: \"pcb_plated_hole\"\n  shape: \"circle\"\n  pcb_group_id?: string\n  subcircuit_id?: string\n  outer_diameter: number\n  hole_diameter: number\n  x: Distance\n  y: Distance\n  layers: LayerRef[]\n  port_hints?: string[]\n  pcb_component_id?: string\n  pcb_port_id?: string\n  pcb_plated_hole_id: string\n}\n\nconst pcb_plated_hole_oval = z.object({\n  type: z.literal(\"pcb_plated_hole\"),\n  shape: z.enum([\"oval\", \"pill\"]),\n  pcb_group_id: z.string().optional(),\n  subcircuit_id: z.string().optional(),\n  outer_width: z.number(),\n  outer_height: z.number(),\n  hole_width: z.number(),\n  hole_height: z.number(),\n  x: distance,\n  y: distance,\n  layers: z.array(layer_ref),\n  port_hints: z.array(z.string()).optional(),\n  pcb_component_id: z.string().optional(),\n  pcb_port_id: z.string().optional(),\n  pcb_plated_hole_id: getZodPrefixedIdWithDefault(\"pcb_plated_hole\"),\n})\n\n/**\n * Defines an oval or pill-shaped plated hole on the PCB\n */\nexport interface PcbPlatedHoleOval {\n  type: \"pcb_plated_hole\"\n  shape: \"oval\" | \"pill\"\n  pcb_group_id?: string\n  subcircuit_id?: string\n  outer_width: number\n  outer_height: number\n  hole_width: number\n  hole_height: number\n  x: Distance\n  y: Distance\n  layers: LayerRef[]\n  port_hints?: string[]\n  pcb_component_id?: string\n  pcb_port_id?: string\n  pcb_plated_hole_id: string\n}\n\nconst pcb_circular_hole_with_rect_pad = z.object({\n  type: z.literal(\"pcb_plated_hole\"),\n  shape: z.literal(\"circular_hole_with_rect_pad\"),\n  pcb_group_id: z.string().optional(),\n  subcircuit_id: z.string().optional(),\n  hole_shape: z.literal(\"circle\"),\n  pad_shape: z.literal(\"rect\"),\n  hole_diameter: z.number(),\n  rect_pad_width: z.number(),\n  rect_pad_height: z.number(),\n  x: distance,\n  y: distance,\n  layers: z.array(layer_ref),\n  port_hints: z.array(z.string()).optional(),\n  pcb_component_id: z.string().optional(),\n  pcb_port_id: z.string().optional(),\n  pcb_plated_hole_id: getZodPrefixedIdWithDefault(\"pcb_plated_hole\"),\n})\nconst pcb_pill_hole_with_rect_pad = z.object({\n  type: z.literal(\"pcb_plated_hole\"),\n  shape: z.literal(\"pill_hole_with_rect_pad\"),\n  pcb_group_id: z.string().optional(),\n  subcircuit_id: z.string().optional(),\n  hole_shape: z.literal(\"pill\"),\n  pad_shape: z.literal(\"rect\"),\n  hole_width: z.number(),\n  hole_height: z.number(),\n  rect_pad_width: z.number(),\n  rect_pad_height: z.number(),\n  x: distance,\n  y: distance,\n  layers: z.array(layer_ref),\n  port_hints: z.array(z.string()).optional(),\n  pcb_component_id: z.string().optional(),\n  pcb_port_id: z.string().optional(),\n  pcb_plated_hole_id: getZodPrefixedIdWithDefault(\"pcb_plated_hole\"),\n})\nexport interface PcbHolePillWithRectPad {\n  type: \"pcb_plated_hole\"\n  shape: \"pill_hole_with_rect_pad\"\n  pcb_group_id?: string\n  subcircuit_id?: string\n  hole_shape: \"pill\"\n  pad_shape: \"rect\"\n  hole_width: number\n  hole_height: number\n  rect_pad_width: number\n  rect_pad_height: number\n  x: Distance\n  y: Distance\n  layers: LayerRef[]\n  port_hints?: string[]\n  pcb_component_id?: string\n  pcb_port_id?: string\n  pcb_plated_hole_id: string\n}\n\nexport interface PcbHoleCircularWithRectPad {\n  type: \"pcb_plated_hole\"\n  shape: \"circular_hole_with_rect_pad\"\n  pcb_group_id?: string\n  subcircuit_id?: string\n  hole_shape: \"circle\"\n  pad_shape: \"rect\"\n  hole_diameter: number\n  rect_pad_width: number\n  rect_pad_height: number\n  x: Distance\n  y: Distance\n  layers: LayerRef[]\n  port_hints?: string[]\n  pcb_component_id?: string\n  pcb_port_id?: string\n  pcb_plated_hole_id: string\n}\n\nexport const pcb_plated_hole = z.union([\n  pcb_plated_hole_circle,\n  pcb_plated_hole_oval,\n  pcb_circular_hole_with_rect_pad,\n  pcb_pill_hole_with_rect_pad,\n])\nexport type PcbPlatedHole =\n  | PcbPlatedHoleCircle\n  | PcbPlatedHoleOval\n  | PcbHoleCircularWithRectPad\n  | PcbHolePillWithRectPad\n\nexpectTypesMatch<PcbPlatedHoleCircle, z.infer<typeof pcb_plated_hole_circle>>(\n  true,\n)\nexpectTypesMatch<PcbPlatedHoleOval, z.infer<typeof pcb_plated_hole_oval>>(true)\nexpectTypesMatch<\n  PcbHoleCircularWithRectPad,\n  z.infer<typeof pcb_circular_hole_with_rect_pad>\n>(true)\nexpectTypesMatch<\n  PcbHolePillWithRectPad,\n  z.infer<typeof pcb_pill_hole_with_rect_pad>\n>(true)\n/**\n * @deprecated use PcbPlatedHole\n */\nexport type PCBPlatedHole = PcbPlatedHole\n\n/**\n * @deprecated use PcbPlatedHoleInput\n */\nexport type PCBPlatedHoleInput = z.input<typeof pcb_plated_hole>\nexport type PcbPlatedHoleInput = z.input<typeof pcb_plated_hole>\n","import { z } from \"zod\"\nimport { getZodPrefixedIdWithDefault } from \"src/common\"\nimport { distance, type Distance } from \"src/units\"\nimport { layer_ref, type LayerRef } from \"src/pcb/properties/layer_ref\"\nimport { expectTypesMatch } from \"src/utils/expect-types-match\"\n\nexport const pcb_port = z\n  .object({\n    type: z.literal(\"pcb_port\"),\n    pcb_port_id: getZodPrefixedIdWithDefault(\"pcb_port\"),\n    pcb_group_id: z.string().optional(),\n    subcircuit_id: z.string().optional(),\n    source_port_id: z.string(),\n    pcb_component_id: z.string(),\n    x: distance,\n    y: distance,\n    layers: z.array(layer_ref),\n  })\n  .describe(\"Defines a port on the PCB\")\n\nexport type PcbPortInput = z.input<typeof pcb_port>\ntype InferredPcbPort = z.infer<typeof pcb_port>\n\n/**\n * Defines a port on the PCB\n */\nexport interface PcbPort {\n  type: \"pcb_port\"\n  pcb_port_id: string\n  pcb_group_id?: string\n  subcircuit_id?: string\n  source_port_id: string\n  pcb_component_id: string\n  x: Distance\n  y: Distance\n  layers: LayerRef[]\n}\n\n/**\n * @deprecated use PcbPort\n */\nexport type PCBPort = PcbPort\n\n/**\n * @deprecated use PcbPortInput\n */\nexport type PCBPortInput = PcbPortInput\n\nexpectTypesMatch<PcbPort, InferredPcbPort>(true)\n","import { z } from \"zod\"\nimport { distance, type Distance, rotation, type Rotation } from \"src/units\"\nimport { layer_ref, type LayerRef } from \"src/pcb/properties/layer_ref\"\nimport { getZodPrefixedIdWithDefault, point, type Point } from \"src/common\"\nimport { expectTypesMatch } from \"src/utils/expect-types-match\"\n\nconst pcb_smtpad_circle = z.object({\n  type: z.literal(\"pcb_smtpad\"),\n  shape: z.literal(\"circle\"),\n  pcb_smtpad_id: getZodPrefixedIdWithDefault(\"pcb_smtpad\"),\n  pcb_group_id: z.string().optional(),\n  subcircuit_id: z.string().optional(),\n  x: distance,\n  y: distance,\n  radius: z.number(),\n  layer: layer_ref,\n  port_hints: z.array(z.string()).optional(),\n  pcb_component_id: z.string().optional(),\n  pcb_port_id: z.string().optional(),\n})\n\nconst pcb_smtpad_rect = z.object({\n  type: z.literal(\"pcb_smtpad\"),\n  shape: z.literal(\"rect\"),\n  pcb_smtpad_id: getZodPrefixedIdWithDefault(\"pcb_smtpad\"),\n  pcb_group_id: z.string().optional(),\n  subcircuit_id: z.string().optional(),\n  x: distance,\n  y: distance,\n  width: z.number(),\n  height: z.number(),\n  layer: layer_ref,\n  port_hints: z.array(z.string()).optional(),\n  pcb_component_id: z.string().optional(),\n  pcb_port_id: z.string().optional(),\n})\n\nconst pcb_smtpad_rotated_rect = z.object({\n  type: z.literal(\"pcb_smtpad\"),\n  shape: z.literal(\"rotated_rect\"),\n  pcb_smtpad_id: getZodPrefixedIdWithDefault(\"pcb_smtpad\"),\n  pcb_group_id: z.string().optional(),\n  subcircuit_id: z.string().optional(),\n  x: distance,\n  y: distance,\n  width: z.number(),\n  height: z.number(),\n  ccw_rotation: rotation,\n  layer: layer_ref,\n  port_hints: z.array(z.string()).optional(),\n  pcb_component_id: z.string().optional(),\n  pcb_port_id: z.string().optional(),\n})\n\nexport const pcb_smtpad_pill = z.object({\n  type: z.literal(\"pcb_smtpad\"),\n  shape: z.literal(\"pill\"),\n  pcb_smtpad_id: getZodPrefixedIdWithDefault(\"pcb_smtpad\"),\n  pcb_group_id: z.string().optional(),\n  subcircuit_id: z.string().optional(),\n  x: distance,\n  y: distance,\n  width: z.number(),\n  height: z.number(),\n  radius: z.number(),\n  layer: layer_ref,\n  port_hints: z.array(z.string()).optional(),\n  pcb_component_id: z.string().optional(),\n  pcb_port_id: z.string().optional(),\n})\n\nconst pcb_smtpad_polygon = z.object({\n  type: z.literal(\"pcb_smtpad\"),\n  shape: z.literal(\"polygon\"),\n  pcb_smtpad_id: getZodPrefixedIdWithDefault(\"pcb_smtpad\"),\n  pcb_group_id: z.string().optional(),\n  subcircuit_id: z.string().optional(),\n  points: z.array(point),\n  layer: layer_ref,\n  port_hints: z.array(z.string()).optional(),\n  pcb_component_id: z.string().optional(),\n  pcb_port_id: z.string().optional(),\n})\n\nexport const pcb_smtpad = z\n  .discriminatedUnion(\"shape\", [\n    pcb_smtpad_circle,\n    pcb_smtpad_rect,\n    pcb_smtpad_rotated_rect,\n    pcb_smtpad_pill,\n    pcb_smtpad_polygon,\n  ])\n  .describe(\"Defines an SMT pad on the PCB\")\n\nexport type PCBSMTPadInput = z.input<typeof pcb_smtpad>\ntype PCBSMTPadCircle = z.infer<typeof pcb_smtpad_circle>\ntype PCBSMTPadRect = z.infer<typeof pcb_smtpad_rect>\ntype PCBSMTPadRotatedRect = z.infer<typeof pcb_smtpad_rotated_rect>\ntype PCBSMTPadPill = z.infer<typeof pcb_smtpad_pill>\ntype PCBSMTPadPolygon = z.infer<typeof pcb_smtpad_polygon>\n\n/**\n * Defines a circular SMT pad on the PCB\n */\nexport interface PcbSmtPadCircle {\n  type: \"pcb_smtpad\"\n  shape: \"circle\"\n  pcb_smtpad_id: string\n  pcb_group_id?: string\n  subcircuit_id?: string\n  x: Distance\n  y: Distance\n  radius: number\n  layer: LayerRef\n  port_hints?: string[]\n  pcb_component_id?: string\n  pcb_port_id?: string\n}\n\n/**\n * Defines a rectangular SMT pad on the PCB\n */\nexport interface PcbSmtPadRect {\n  type: \"pcb_smtpad\"\n  shape: \"rect\"\n  pcb_smtpad_id: string\n  pcb_group_id?: string\n  subcircuit_id?: string\n  x: Distance\n  y: Distance\n  width: number\n  height: number\n  layer: LayerRef\n  port_hints?: string[]\n  pcb_component_id?: string\n  pcb_port_id?: string\n}\n\n/**\n * Defines a rotated rectangular SMT pad on the PCB\n */\nexport interface PcbSmtPadRotatedRect {\n  type: \"pcb_smtpad\"\n  shape: \"rotated_rect\"\n  pcb_smtpad_id: string\n  pcb_group_id?: string\n  subcircuit_id?: string\n  x: Distance\n  y: Distance\n  width: number\n  height: number\n  ccw_rotation: Rotation\n  layer: LayerRef\n  port_hints?: string[]\n  pcb_component_id?: string\n  pcb_port_id?: string\n}\n/**\n * Defines a pill-shaped SMT pad on the PCB (rounded rectangle).\n */\nexport interface PcbSmtPadPill {\n  type: \"pcb_smtpad\"\n  shape: \"pill\"\n  pcb_smtpad_id: string\n  pcb_group_id?: string\n  subcircuit_id?: string\n  x: Distance\n  y: Distance\n  width: number\n  height: number\n  radius: number\n  layer: LayerRef\n  port_hints?: string[]\n  pcb_component_id?: string\n  pcb_port_id?: string\n}\n\n/**\n * Defines a polygonal SMT pad on the PCB\n */\nexport interface PcbSmtPadPolygon {\n  type: \"pcb_smtpad\"\n  shape: \"polygon\"\n  pcb_smtpad_id: string\n  pcb_group_id?: string\n  subcircuit_id?: string\n  points: Point[]\n  layer: LayerRef\n  port_hints?: string[]\n  pcb_component_id?: string\n  pcb_port_id?: string\n}\n\nexport type PcbSmtPad =\n  | PcbSmtPadCircle\n  | PcbSmtPadRect\n  | PcbSmtPadRotatedRect\n  | PcbSmtPadPill\n  | PcbSmtPadPolygon\n\n/**\n * @deprecated use PcbSmtPad\n */\nexport type PCBSMTPad = PcbSmtPad\n\nexpectTypesMatch<PcbSmtPadCircle, PCBSMTPadCircle>(true)\nexpectTypesMatch<PcbSmtPadRect, PCBSMTPadRect>(true)\nexpectTypesMatch<PcbSmtPadRotatedRect, PCBSMTPadRotatedRect>(true)\nexpectTypesMatch<PcbSmtPadPill, PCBSMTPadPill>(true)\nexpectTypesMatch<PcbSmtPadPolygon, PCBSMTPadPolygon>(true)\n","import { z } from \"zod\"\nimport { distance, type Distance } from \"src/units\"\nimport { layer_ref, type LayerRef } from \"src/pcb/properties/layer_ref\"\nimport { getZodPrefixedIdWithDefault } from \"src/common\"\nimport { expectTypesMatch } from \"src/utils/expect-types-match\"\n\nconst pcb_solder_paste_circle = z.object({\n  type: z.literal(\"pcb_solder_paste\"),\n  shape: z.literal(\"circle\"),\n  pcb_solder_paste_id: getZodPrefixedIdWithDefault(\"pcb_solder_paste\"),\n  pcb_group_id: z.string().optional(),\n  subcircuit_id: z.string().optional(),\n  x: distance,\n  y: distance,\n  radius: z.number(),\n  layer: layer_ref,\n  pcb_component_id: z.string().optional(),\n  pcb_smtpad_id: z.string().optional(),\n})\n\nconst pcb_solder_paste_rect = z.object({\n  type: z.literal(\"pcb_solder_paste\"),\n  shape: z.literal(\"rect\"),\n  pcb_solder_paste_id: getZodPrefixedIdWithDefault(\"pcb_solder_paste\"),\n  pcb_group_id: z.string().optional(),\n  subcircuit_id: z.string().optional(),\n  x: distance,\n  y: distance,\n  width: z.number(),\n  height: z.number(),\n  layer: layer_ref,\n  pcb_component_id: z.string().optional(),\n  pcb_smtpad_id: z.string().optional(),\n})\nconst pcb_solder_paste_pill = z.object({\n  type: z.literal(\"pcb_solder_paste\"),\n  shape: z.literal(\"pill\"),\n  pcb_solder_paste_id: getZodPrefixedIdWithDefault(\"pcb_solder_paste\"),\n  pcb_group_id: z.string().optional(),\n  subcircuit_id: z.string().optional(),\n  x: distance,\n  y: distance,\n  width: z.number(),\n  height: z.number(),\n  radius: z.number(),\n  layer: layer_ref,\n  pcb_component_id: z.string().optional(),\n  pcb_smtpad_id: z.string().optional(),\n})\nconst pcb_solder_paste_rotated_rect = z.object({\n  type: z.literal(\"pcb_solder_paste\"),\n  shape: z.literal(\"rotated_rect\"),\n  pcb_solder_paste_id: getZodPrefixedIdWithDefault(\"pcb_solder_paste\"),\n  pcb_group_id: z.string().optional(),\n  subcircuit_id: z.string().optional(),\n  x: distance,\n  y: distance,\n  width: z.number(),\n  height: z.number(),\n  ccw_rotation: distance,\n  layer: layer_ref,\n  pcb_component_id: z.string().optional(),\n  pcb_smtpad_id: z.string().optional(),\n})\n\nconst pcb_solder_paste_oval = z.object({\n  type: z.literal(\"pcb_solder_paste\"),\n  shape: z.literal(\"oval\"),\n  pcb_solder_paste_id: getZodPrefixedIdWithDefault(\"pcb_solder_paste\"),\n  pcb_group_id: z.string().optional(),\n  subcircuit_id: z.string().optional(),\n  x: distance,\n  y: distance,\n  width: z.number(),\n  height: z.number(),\n  layer: layer_ref,\n  pcb_component_id: z.string().optional(),\n  pcb_smtpad_id: z.string().optional(),\n})\n\nexport const pcb_solder_paste = z\n  .union([\n    pcb_solder_paste_circle,\n    pcb_solder_paste_rect,\n    pcb_solder_paste_pill,\n    pcb_solder_paste_rotated_rect,\n    pcb_solder_paste_oval,\n  ])\n  .describe(\"Defines solderpaste on the PCB\")\n\nexport type PCBSolderPasteInput = z.input<typeof pcb_solder_paste>\ntype InferredPcbSolderPasteCircle = z.infer<typeof pcb_solder_paste_circle>\ntype InferredPcbSolderPasteRect = z.infer<typeof pcb_solder_paste_rect>\ntype InferredPcbSolderPastePill = z.infer<typeof pcb_solder_paste_pill>\ntype InferredPcbSolderPasteRotatedRect = z.infer<\n  typeof pcb_solder_paste_rotated_rect\n>\ntype InferredPcbSolderPasteOval = z.infer<typeof pcb_solder_paste_oval>\n\n/**\n * Defines solderpaste on the PCB\n */\nexport interface PcbSolderPasteCircle {\n  type: \"pcb_solder_paste\"\n  shape: \"circle\"\n  pcb_solder_paste_id: string\n  pcb_group_id?: string\n  subcircuit_id?: string\n  x: Distance\n  y: Distance\n  radius: number\n  layer: LayerRef\n  pcb_component_id?: string\n  pcb_smtpad_id?: string\n}\n\n/**\n * Defines solderpaste on the PCB\n */\nexport interface PcbSolderPasteRect {\n  type: \"pcb_solder_paste\"\n  shape: \"rect\"\n  pcb_solder_paste_id: string\n  pcb_group_id?: string\n  subcircuit_id?: string\n  x: Distance\n  y: Distance\n  width: number\n  height: number\n  layer: LayerRef\n  pcb_component_id?: string\n  pcb_smtpad_id?: string\n}\n/**\n * Defines solderpaste on the PCB\n */\nexport interface PcbSolderPastePill {\n  type: \"pcb_solder_paste\"\n  shape: \"pill\"\n  pcb_solder_paste_id: string\n  pcb_group_id?: string\n  subcircuit_id?: string\n  x: Distance\n  y: Distance\n  width: number\n  height: number\n  radius: number\n  layer: LayerRef\n  pcb_component_id?: string\n  pcb_smtpad_id?: string\n}\n/**\n * Defines solderpaste on the PCB\n */\nexport interface PcbSolderPasteRotatedRect {\n  type: \"pcb_solder_paste\"\n  shape: \"rotated_rect\"\n  pcb_solder_paste_id: string\n  pcb_group_id?: string\n  subcircuit_id?: string\n  x: Distance\n  y: Distance\n  width: number\n  height: number\n  ccw_rotation: Distance\n  layer: LayerRef\n  pcb_component_id?: string\n  pcb_smtpad_id?: string\n}\n/**\n * Defines solderpaste on the PCB\n */\nexport interface PcbSolderPasteOval {\n  type: \"pcb_solder_paste\"\n  shape: \"oval\"\n  pcb_solder_paste_id: string\n  pcb_group_id?: string\n  subcircuit_id?: string\n  x: Distance\n  y: Distance\n  width: number\n  height: number\n  layer: LayerRef\n  pcb_component_id?: string\n  pcb_smtpad_id?: string\n}\n\nexport type PcbSolderPaste =\n  | PcbSolderPasteCircle\n  | PcbSolderPasteRect\n  | PcbSolderPastePill\n  | PcbSolderPasteRotatedRect\n  | PcbSolderPasteOval\n\nexpectTypesMatch<PcbSolderPasteCircle, InferredPcbSolderPasteCircle>(true)\nexpectTypesMatch<PcbSolderPasteRect, InferredPcbSolderPasteRect>(true)\nexpectTypesMatch<PcbSolderPastePill, InferredPcbSolderPastePill>(true)\nexpectTypesMatch<PcbSolderPasteRotatedRect, InferredPcbSolderPasteRotatedRect>(\n  true,\n)\nexpectTypesMatch<PcbSolderPasteOval, InferredPcbSolderPasteOval>(true)\n","import { z } from \"zod\"\nimport { point, type Point, getZodPrefixedIdWithDefault } from \"src/common\"\nimport { layer_ref, type LayerRef } from \"src/pcb/properties/layer_ref\"\nimport { length, type Length } from \"src/units\"\nimport { expectTypesMatch } from \"src/utils/expect-types-match\"\n\nexport const pcb_text = z\n  .object({\n    type: z.literal(\"pcb_text\"),\n    pcb_text_id: getZodPrefixedIdWithDefault(\"pcb_text\"),\n    pcb_group_id: z.string().optional(),\n    subcircuit_id: z.string().optional(),\n    text: z.string(),\n    center: point,\n    layer: layer_ref,\n    width: length,\n    height: length,\n    lines: z.number(),\n    // @ts-ignore\n    align: z.enum([\"bottom-left\"]),\n  })\n  .describe(\"Defines text on the PCB\")\n\nexport type PcbTextInput = z.input<typeof pcb_text>\ntype InferredPcbText = z.infer<typeof pcb_text>\n\n/**\n * Defines text on the PCB\n */\nexport interface PcbText {\n  type: \"pcb_text\"\n  pcb_text_id: string\n  pcb_group_id?: string\n  subcircuit_id?: string\n  text: string\n  center: Point\n  layer: LayerRef\n  width: Length\n  height: Length\n  lines: number\n  // @ts-ignore\n  align: \"bottom-left\"\n}\n\n/**\n * @deprecated use PcbText\n */\nexport type PCBText = PcbText\n\nexpectTypesMatch<PcbText, InferredPcbText>(true)\n","import { z } from \"zod\"\nimport { getZodPrefixedIdWithDefault } from \"src/common\"\nimport { distance, type Distance } from \"src/units\"\nimport { layer_ref, type LayerRef } from \"src/pcb/properties/layer_ref\"\nimport { expectTypesMatch } from \"src/utils/expect-types-match\"\n\nexport const pcb_trace_route_point_wire = z.object({\n  route_type: z.literal(\"wire\"),\n  x: distance,\n  y: distance,\n  width: distance,\n  start_pcb_port_id: z.string().optional(),\n  end_pcb_port_id: z.string().optional(),\n  layer: layer_ref,\n})\n\nexport const pcb_trace_route_point_via = z.object({\n  route_type: z.literal(\"via\"),\n  x: distance,\n  y: distance,\n  hole_diameter: distance.optional(),\n  outer_diameter: distance.optional(),\n  from_layer: z.string(),\n  to_layer: z.string(),\n})\n\nexport const pcb_trace_route_point = z.union([\n  pcb_trace_route_point_wire,\n  pcb_trace_route_point_via,\n])\ntype InferredPcbTraceRoutePoint = z.infer<typeof pcb_trace_route_point>\n\nexport const pcb_trace = z\n  .object({\n    type: z.literal(\"pcb_trace\"),\n    source_trace_id: z.string().optional(),\n    pcb_component_id: z.string().optional(),\n    pcb_trace_id: getZodPrefixedIdWithDefault(\"pcb_trace\"),\n    pcb_group_id: z.string().optional(),\n    subcircuit_id: z.string().optional(),\n    route_thickness_mode: z\n      .enum([\"constant\", \"interpolated\"])\n      .default(\"constant\")\n      .optional(),\n    route_order_index: z.number().optional(),\n    should_round_corners: z.boolean().optional(),\n    trace_length: z.number().optional(),\n    route: z.array(pcb_trace_route_point),\n  })\n  .describe(\"Defines a trace on the PCB\")\n\nexport type PcbTraceInput = z.input<typeof pcb_trace>\ntype InferredPcbTrace = z.infer<typeof pcb_trace>\n\nexport interface PcbTraceRoutePointWire {\n  route_type: \"wire\"\n  x: Distance\n  y: Distance\n  width: Distance\n  start_pcb_port_id?: string\n  end_pcb_port_id?: string\n  layer: LayerRef\n}\n\nexport interface PcbTraceRoutePointVia {\n  route_type: \"via\"\n  x: Distance\n  y: Distance\n  hole_diameter?: Distance\n  outer_diameter?: Distance\n  from_layer: string\n  to_layer: string\n}\n\nexport type PcbTraceRoutePoint = PcbTraceRoutePointWire | PcbTraceRoutePointVia\n\n/**\n * Defines a trace on the PCB\n */\nexport interface PcbTrace {\n  type: \"pcb_trace\"\n  source_trace_id?: string\n  pcb_component_id?: string\n  pcb_group_id?: string\n  subcircuit_id?: string\n  pcb_trace_id: string\n  /**\n   * The order that this trace was routed in. This can be used to debug the\n   * autorouter and to understand the trace path better\n   *\n   * The route_order_index should be relative to a subcircuit\n   */\n  route_order_index?: number\n  route_thickness_mode?: \"constant\" | \"interpolated\"\n  should_round_corners?: boolean\n  trace_length?: number\n  route: Array<PcbTraceRoutePoint>\n}\n\n/**\n * @deprecated use PcbTrace\n */\nexport type PCBTrace = PcbTrace\n\n/**\n * @deprecated use PcbTraceInput\n */\nexport type PCBTraceInput = PcbTraceInput\n\nexpectTypesMatch<PcbTraceRoutePoint, InferredPcbTraceRoutePoint>(true)\nexpectTypesMatch<PcbTrace, InferredPcbTrace>(true)\n","import { z } from \"zod\"\nimport { point, type Point, getZodPrefixedIdWithDefault } from \"src/common\"\nimport { expectTypesMatch } from \"src/utils/expect-types-match\"\n\nexport const pcb_trace_error = z\n  .object({\n    type: z.literal(\"pcb_trace_error\"),\n    pcb_trace_error_id: getZodPrefixedIdWithDefault(\"pcb_trace_error\"),\n    error_type: z.literal(\"pcb_trace_error\").default(\"pcb_trace_error\"),\n    message: z.string(),\n    center: point.optional(),\n    pcb_trace_id: z.string(),\n    source_trace_id: z.string(),\n    pcb_component_ids: z.array(z.string()),\n    pcb_port_ids: z.array(z.string()),\n    subcircuit_id: z.string().optional(),\n  })\n  .describe(\"Defines a trace error on the PCB\")\n\nexport type PcbTraceErrorInput = z.input<typeof pcb_trace_error>\ntype InferredPcbTraceError = z.infer<typeof pcb_trace_error>\n\n/**\n * Defines a trace error on the PCB\n */\nexport interface PcbTraceError {\n  type: \"pcb_trace_error\"\n  pcb_trace_error_id: string\n  error_type: \"pcb_trace_error\"\n  message: string\n  center?: Point\n  pcb_trace_id: string\n  source_trace_id: string\n  pcb_component_ids: string[]\n  pcb_port_ids: string[]\n  subcircuit_id?: string\n}\n\n/**\n * @deprecated use PcbTraceError\n */\nexport type PCBTraceError = PcbTraceError\n\nexpectTypesMatch<PcbTraceError, InferredPcbTraceError>(true)\n","import { z } from \"zod\"\nimport { getZodPrefixedIdWithDefault } from \"src/common\"\nimport { expectTypesMatch } from \"src/utils/expect-types-match\"\n\nexport const pcb_port_not_matched_error = z\n  .object({\n    type: z.literal(\"pcb_port_not_matched_error\"),\n    pcb_error_id: getZodPrefixedIdWithDefault(\"pcb_error\"),\n    error_type: z\n      .literal(\"pcb_port_not_matched_error\")\n      .default(\"pcb_port_not_matched_error\"),\n    message: z.string(),\n    pcb_component_ids: z.array(z.string()),\n    subcircuit_id: z.string().optional(),\n  })\n  .describe(\"Defines a trace error on the PCB where a port is not matched\")\n\nexport type PcbPortNotMatchedErrorInput = z.input<\n  typeof pcb_port_not_matched_error\n>\ntype InferredPcbPortNotMatchedError = z.infer<typeof pcb_port_not_matched_error>\n\n/**\n * Defines a trace error on the PCB where a port is not matched\n */\nexport interface PcbPortNotMatchedError {\n  type: \"pcb_port_not_matched_error\"\n  pcb_error_id: string\n  error_type: \"pcb_port_not_matched_error\"\n  message: string\n  pcb_component_ids: string[]\n  subcircuit_id?: string\n}\n\n/**\n * @deprecated use PcbPortNotMatchedError\n */\nexport type PCBPortNotMatchedError = PcbPortNotMatchedError\n\nexpectTypesMatch<PcbPortNotMatchedError, InferredPcbPortNotMatchedError>(true)\n","import { z } from \"zod\"\nimport { distance, type Distance } from \"src/units\"\nimport { getZodPrefixedIdWithDefault } from \"src/common\"\nimport { layer_ref, type LayerRef } from \"src/pcb/properties/layer_ref\"\nimport { expectTypesMatch } from \"src/utils/expect-types-match\"\n\nexport const pcb_via = z\n  .object({\n    type: z.literal(\"pcb_via\"),\n    pcb_via_id: getZodPrefixedIdWithDefault(\"pcb_via\"),\n    pcb_group_id: z.string().optional(),\n    subcircuit_id: z.string().optional(),\n    x: distance,\n    y: distance,\n    outer_diameter: distance.default(\"0.6mm\"),\n    hole_diameter: distance.default(\"0.25mm\"),\n    /** @deprecated */\n    from_layer: layer_ref.optional(),\n    /** @deprecated */\n    to_layer: layer_ref.optional(),\n    layers: z.array(layer_ref),\n    pcb_trace_id: z.string().optional(),\n  })\n  .describe(\"Defines a via on the PCB\")\n\nexport type PcbViaInput = z.input<typeof pcb_via>\ntype InferredPcbVia = z.infer<typeof pcb_via>\n\n/**\n * Defines a via on the PCB\n */\nexport interface PcbVia {\n  type: \"pcb_via\"\n  pcb_via_id: string\n  pcb_group_id?: string\n  subcircuit_id?: string\n  x: Distance\n  y: Distance\n  outer_diameter: Distance\n  hole_diameter: Distance\n  /** @deprecated */\n  from_layer?: LayerRef\n  /** @deprecated */\n  to_layer?: LayerRef\n  layers: LayerRef[]\n  pcb_trace_id?: string\n}\n\n/**\n * @deprecated use PcbVia\n */\nexport type PCBVia = PcbVia\n\nexpectTypesMatch<PcbVia, InferredPcbVia>(true)\n","import { z } from \"zod\"\nimport { point, type Point, getZodPrefixedIdWithDefault } from \"src/common\"\nimport { length, type Length } from \"src/units\"\nimport { expectTypesMatch } from \"src/utils/expect-types-match\"\n\nexport const pcb_board = z\n  .object({\n    type: z.literal(\"pcb_board\"),\n    pcb_board_id: getZodPrefixedIdWithDefault(\"pcb_board\"),\n    is_subcircuit: z.boolean().optional(),\n    subcircuit_id: z.string().optional(),\n    width: length,\n    height: length,\n    center: point,\n    thickness: length.optional().default(1.4),\n    num_layers: z.number().optional().default(4),\n    outline: z.array(point).optional(),\n    material: z.enum([\"fr4\", \"fr1\"]).default(\"fr4\"),\n  })\n  .describe(\"Defines the board outline of the PCB\")\n\n/**\n * Defines the board outline of the PCB\n */\nexport interface PcbBoard {\n  type: \"pcb_board\"\n  pcb_board_id: string\n  is_subcircuit?: boolean\n  subcircuit_id?: string\n  width: Length\n  height: Length\n  thickness: Length\n  num_layers: number\n  center: Point\n  outline?: Point[]\n  material: \"fr4\" | \"fr1\"\n}\n\nexport type PcbBoardInput = z.input<typeof pcb_board>\ntype InferredPcbBoard = z.infer<typeof pcb_board>\n\n/**\n * @deprecated use PcbBoard\n */\nexport type PCBBoard = PcbBoard\n\nexpectTypesMatch<PcbBoard, InferredPcbBoard>(true)\n","import { z } from \"zod\"\nimport { getZodPrefixedIdWithDefault } from \"src/common\"\nimport { expectTypesMatch } from \"src/utils/expect-types-match\"\n\nexport const pcb_placement_error = z\n  .object({\n    type: z.literal(\"pcb_placement_error\"),\n    pcb_placement_error_id: getZodPrefixedIdWithDefault(\"pcb_placement_error\"),\n    error_type: z.literal(\"pcb_placement_error\").default(\"pcb_placement_error\"),\n    message: z.string(),\n    subcircuit_id: z.string().optional(),\n  })\n  .describe(\"Defines a placement error on the PCB\")\n\nexport type PcbPlacementErrorInput = z.input<typeof pcb_placement_error>\ntype InferredPcbPlacementError = z.infer<typeof pcb_placement_error>\n\n/**\n * Defines a placement error on the PCB\n */\nexport interface PcbPlacementError {\n  type: \"pcb_placement_error\"\n  pcb_placement_error_id: string\n  error_type: \"pcb_placement_error\"\n  message: string\n  subcircuit_id?: string\n}\n\n/**\n * @deprecated use PcbPlacementError\n */\nexport type PCBPlacementError = PcbPlacementError\n\nexpectTypesMatch<PcbPlacementError, InferredPcbPlacementError>(true)\n","import { z } from \"zod\"\nimport { getZodPrefixedIdWithDefault } from \"src/common\"\nimport { route_hint_point, type RouteHintPoint } from \"src/pcb\"\nimport { expectTypesMatch } from \"src/utils/expect-types-match\"\n\n/**\n * A hint that can be used during generation of a PCB trace.\n */\nexport interface PcbTraceHint {\n  type: \"pcb_trace_hint\"\n  pcb_trace_hint_id: string\n  pcb_port_id: string\n  pcb_component_id: string\n  route: RouteHintPoint[]\n  subcircuit_id?: string\n}\n\nexport const pcb_trace_hint = z\n  .object({\n    type: z.literal(\"pcb_trace_hint\"),\n    pcb_trace_hint_id: getZodPrefixedIdWithDefault(\"pcb_trace_hint\"),\n    pcb_port_id: z.string(),\n    pcb_component_id: z.string(),\n    route: z.array(route_hint_point),\n    subcircuit_id: z.string().optional(),\n  })\n  .describe(\"A hint that can be used during generation of a PCB trace\")\n\nexport type PcbTraceHintInput = z.input<typeof pcb_trace_hint>\ntype InferredPcbTraceHint = z.infer<typeof pcb_trace_hint>\n\n/**\n * @deprecated use PcbTraceHint\n */\nexport type PCBTraceHint = PcbTraceHint\n\nexpectTypesMatch<PcbTraceHint, InferredPcbTraceHint>(true)\n","import { z } from \"zod\"\nimport { distance, type Distance } from \"src/units\"\nimport {\n  layer_ref,\n  type LayerRef,\n  type VisibleLayer,\n  visible_layer,\n} from \"src/pcb/properties/layer_ref\"\nimport { getZodPrefixedIdWithDefault } from \"src/common\"\nimport { expectTypesMatch } from \"src/utils/expect-types-match\"\n\nexport const pcb_silkscreen_line = z\n  .object({\n    type: z.literal(\"pcb_silkscreen_line\"),\n    pcb_silkscreen_line_id: getZodPrefixedIdWithDefault(\"pcb_silkscreen_line\"),\n    pcb_component_id: z.string(),\n    pcb_group_id: z.string().optional(),\n    subcircuit_id: z.string().optional(),\n    stroke_width: distance.default(\"0.1mm\"),\n    x1: distance,\n    y1: distance,\n    x2: distance,\n    y2: distance,\n    layer: visible_layer,\n  })\n  .describe(\"Defines a silkscreen line on the PCB\")\n\nexport type PcbSilkscreenLineInput = z.input<typeof pcb_silkscreen_line>\ntype InferredPcbSilkscreenLine = z.infer<typeof pcb_silkscreen_line>\n\n/**\n * Defines a silkscreen line on the PCB\n */\nexport interface PcbSilkscreenLine {\n  type: \"pcb_silkscreen_line\"\n  pcb_silkscreen_line_id: string\n  pcb_component_id: string\n  pcb_group_id?: string\n  subcircuit_id?: string\n  stroke_width: Distance\n  x1: Distance\n  y1: Distance\n  x2: Distance\n  y2: Distance\n  layer: VisibleLayer\n}\n\n/**\n * @deprecated use PcbSilkscreenLine\n */\nexport type PCBSilkscreenLine = PcbSilkscreenLine\n\nexpectTypesMatch<PcbSilkscreenLine, InferredPcbSilkscreenLine>(true)\n","import { z } from \"zod\"\nimport { point, type Point, getZodPrefixedIdWithDefault } from \"src/common\"\nimport {\n  visible_layer,\n  type VisibleLayerRef,\n} from \"src/pcb/properties/layer_ref\"\nimport { length, type Length } from \"src/units\"\nimport { expectTypesMatch } from \"src/utils/expect-types-match\"\n\nexport const pcb_silkscreen_path = z\n  .object({\n    type: z.literal(\"pcb_silkscreen_path\"),\n    pcb_silkscreen_path_id: getZodPrefixedIdWithDefault(\"pcb_silkscreen_path\"),\n    pcb_component_id: z.string(),\n    pcb_group_id: z.string().optional(),\n    subcircuit_id: z.string().optional(),\n    layer: visible_layer,\n    route: z.array(point),\n    stroke_width: length,\n  })\n  .describe(\"Defines a silkscreen path on the PCB\")\n\nexport type PcbSilkscreenPathInput = z.input<typeof pcb_silkscreen_path>\ntype InferredPcbSilkscreenPath = z.infer<typeof pcb_silkscreen_path>\n\n/**\n * Defines a silkscreen path on the PCB\n */\nexport interface PcbSilkscreenPath {\n  type: \"pcb_silkscreen_path\"\n  pcb_silkscreen_path_id: string\n  pcb_component_id: string\n  pcb_group_id?: string\n  subcircuit_id?: string\n  layer: VisibleLayerRef\n  route: Point[]\n  stroke_width: Length\n}\n\n/**\n * @deprecated use PcbSilkscreenPath\n */\nexport type PcbSilkscreenPathDeprecated = PcbSilkscreenPath\n\nexpectTypesMatch<PcbSilkscreenPath, InferredPcbSilkscreenPath>(true)\n","import { z } from \"zod\"\nimport { point, type Point, getZodPrefixedIdWithDefault } from \"src/common\"\nimport { layer_ref, type LayerRef } from \"src/pcb/properties/layer_ref\"\nimport { distance, length, type Length } from \"src/units\"\nimport { expectTypesMatch } from \"src/utils/expect-types-match\"\nimport {\n  ninePointAnchor,\n  type NinePointAnchor,\n} from \"src/common/NinePointAnchor\"\n\nexport const pcb_silkscreen_text = z\n  .object({\n    type: z.literal(\"pcb_silkscreen_text\"),\n    pcb_silkscreen_text_id: getZodPrefixedIdWithDefault(\"pcb_silkscreen_text\"),\n    pcb_group_id: z.string().optional(),\n    subcircuit_id: z.string().optional(),\n    font: z.literal(\"tscircuit2024\").default(\"tscircuit2024\"),\n    font_size: distance.default(\"0.2mm\"),\n    pcb_component_id: z.string(),\n    text: z.string(),\n    ccw_rotation: z.number().optional(),\n    layer: layer_ref,\n    is_mirrored: z.boolean().default(false).optional(),\n    anchor_position: point.default({ x: 0, y: 0 }),\n    anchor_alignment: ninePointAnchor.default(\"center\"),\n  })\n  .describe(\"Defines silkscreen text on the PCB\")\n\nexport type PcbSilkscreenTextInput = z.input<typeof pcb_silkscreen_text>\ntype InferredPcbSilkscreenText = z.infer<typeof pcb_silkscreen_text>\n\n/**\n * Defines silkscreen text on the PCB\n */\nexport interface PcbSilkscreenText {\n  type: \"pcb_silkscreen_text\"\n  pcb_silkscreen_text_id: string\n  pcb_group_id?: string\n  subcircuit_id?: string\n  font: \"tscircuit2024\"\n  font_size: Length\n  pcb_component_id: string\n  text: string\n  ccw_rotation?: number\n  layer: LayerRef\n  is_mirrored?: boolean\n  anchor_position: Point\n  anchor_alignment: NinePointAnchor\n}\n\n/**\n * @deprecated use PcbSilkscreenText\n */\nexport type PCBSilkscreenText = PcbSilkscreenText\n\nexpectTypesMatch<PcbSilkscreenText, InferredPcbSilkscreenText>(true)\n","import { z } from \"zod\"\nimport { point, type Point, getZodPrefixedIdWithDefault } from \"src/common\"\nimport { layer_ref, type LayerRef } from \"src/pcb/properties/layer_ref\"\nimport { length, type Length } from \"src/units\"\nimport { expectTypesMatch } from \"src/utils/expect-types-match\"\n\nexport const pcb_silkscreen_rect = z\n  .object({\n    type: z.literal(\"pcb_silkscreen_rect\"),\n    pcb_silkscreen_rect_id: getZodPrefixedIdWithDefault(\"pcb_silkscreen_rect\"),\n    pcb_component_id: z.string(),\n    pcb_group_id: z.string().optional(),\n    subcircuit_id: z.string().optional(),\n    center: point,\n    width: length,\n    height: length,\n    layer: layer_ref,\n    stroke_width: length.default(\"1mm\"),\n    is_filled: z.boolean().default(true).optional(),\n    has_stroke: z.boolean().optional(),\n    is_stroke_dashed: z.boolean().optional(),\n  })\n  .describe(\"Defines a silkscreen rect on the PCB\")\n\nexport type PcbSilkscreenRectInput = z.input<typeof pcb_silkscreen_rect>\ntype InferredPcbSilkscreenRect = z.infer<typeof pcb_silkscreen_rect>\n\n/**\n * Defines a silkscreen rect on the PCB\n */\nexport interface PcbSilkscreenRect {\n  type: \"pcb_silkscreen_rect\"\n  pcb_silkscreen_rect_id: string\n  pcb_component_id: string\n  pcb_group_id?: string\n  subcircuit_id?: string\n  center: Point\n  width: Length\n  height: Length\n  layer: LayerRef\n  stroke_width: Length\n  is_filled?: boolean\n  has_stroke?: boolean\n  is_stroke_dashed?: boolean\n}\n\n/**\n * @deprecated use PcbSilkscreenRect\n */\nexport type PcbSilkscreenRectOld = PcbSilkscreenRect\n\nexpectTypesMatch<PcbSilkscreenRect, InferredPcbSilkscreenRect>(true)\n","import { z } from \"zod\"\nimport { point, type Point, getZodPrefixedIdWithDefault } from \"src/common\"\nimport {\n  layer_ref,\n  visible_layer,\n  type LayerRef,\n  type VisibleLayer,\n} from \"src/pcb/properties/layer_ref\"\nimport { length, type Length } from \"src/units\"\nimport { expectTypesMatch } from \"src/utils/expect-types-match\"\n\nexport const pcb_silkscreen_circle = z\n  .object({\n    type: z.literal(\"pcb_silkscreen_circle\"),\n    pcb_silkscreen_circle_id: getZodPrefixedIdWithDefault(\n      \"pcb_silkscreen_circle\",\n    ),\n    pcb_component_id: z.string(),\n    pcb_group_id: z.string().optional(),\n    subcircuit_id: z.string().optional(),\n    center: point,\n    radius: length,\n    layer: visible_layer,\n    stroke_width: length.default(\"1mm\"),\n  })\n  .describe(\"Defines a silkscreen circle on the PCB\")\n\nexport type PcbSilkscreenCircleInput = z.input<typeof pcb_silkscreen_circle>\ntype InferredPcbSilkscreenCircle = z.infer<typeof pcb_silkscreen_circle>\n\n/**\n * Defines a silkscreen circle on the PCB\n */\nexport interface PcbSilkscreenCircle {\n  type: \"pcb_silkscreen_circle\"\n  pcb_silkscreen_circle_id: string\n  pcb_component_id: string\n  pcb_group_id?: string\n  subcircuit_id?: string\n  center: Point\n  radius: Length\n  layer: VisibleLayer\n  stroke_width: Length\n}\n\nexpectTypesMatch<PcbSilkscreenCircle, InferredPcbSilkscreenCircle>(true)\n","import { z } from \"zod\"\nimport { point, type Point, getZodPrefixedIdWithDefault } from \"src/common\"\nimport {\n  layer_ref,\n  type LayerRef,\n  visible_layer,\n  type VisibleLayer,\n} from \"src/pcb/properties/layer_ref\"\nimport { distance, type Distance } from \"src/units\"\nimport { expectTypesMatch } from \"src/utils/expect-types-match\"\n\nexport const pcb_silkscreen_oval = z\n  .object({\n    type: z.literal(\"pcb_silkscreen_oval\"),\n    pcb_silkscreen_oval_id: getZodPrefixedIdWithDefault(\"pcb_silkscreen_oval\"),\n    pcb_component_id: z.string(),\n    pcb_group_id: z.string().optional(),\n    subcircuit_id: z.string().optional(),\n    center: point,\n    radius_x: distance,\n    radius_y: distance,\n    layer: visible_layer,\n  })\n  .describe(\"Defines a silkscreen oval on the PCB\")\n\nexport type PcbSilkscreenOvalInput = z.input<typeof pcb_silkscreen_oval>\ntype InferredPcbSilkscreenOval = z.infer<typeof pcb_silkscreen_oval>\n\n/**\n * Defines a silkscreen oval on the PCB\n */\nexport interface PcbSilkscreenOval {\n  type: \"pcb_silkscreen_oval\"\n  pcb_silkscreen_oval_id: string\n  pcb_component_id: string\n  pcb_group_id?: string\n  subcircuit_id?: string\n  center: Point\n  radius_x: Distance\n  radius_y: Distance\n  layer: VisibleLayer\n}\n\n/**\n * @deprecated use PcbSilkscreenOval\n */\nexport type PcbSilkscreenOvalDeprecated = PcbSilkscreenOval\n\nexpectTypesMatch<PcbSilkscreenOval, InferredPcbSilkscreenOval>(true)\n","import { z } from \"zod\"\nimport { point, type Point } from \"src/common\"\nimport { distance, type Length } from \"src/units\"\nimport {\n  visible_layer,\n  type LayerRef,\n  type VisibleLayer,\n} from \"src/pcb/properties/layer_ref\"\nimport { getZodPrefixedIdWithDefault } from \"src/common/getZodPrefixedIdWithDefault\"\nimport { expectTypesMatch } from \"src/utils/expect-types-match\"\n\nexport const pcb_fabrication_note_text = z\n  .object({\n    type: z.literal(\"pcb_fabrication_note_text\"),\n    pcb_fabrication_note_text_id: getZodPrefixedIdWithDefault(\n      \"pcb_fabrication_note_text\",\n    ),\n    subcircuit_id: z.string().optional(),\n    pcb_group_id: z.string().optional(),\n    font: z.literal(\"tscircuit2024\").default(\"tscircuit2024\"),\n    font_size: distance.default(\"1mm\"),\n    pcb_component_id: z.string(),\n    text: z.string(),\n    layer: visible_layer,\n    anchor_position: point.default({ x: 0, y: 0 }),\n    anchor_alignment: z\n      .enum([\"center\", \"top_left\", \"top_right\", \"bottom_left\", \"bottom_right\"])\n      .default(\"center\"),\n    color: z.string().optional(),\n  })\n  .describe(\n    \"Defines a fabrication note in text on the PCB, useful for leaving notes for assemblers or fabricators\",\n  )\n\nexport type PcbFabricationNoteTextInput = z.input<\n  typeof pcb_fabrication_note_text\n>\ntype InferredPcbFabricationNoteText = z.infer<typeof pcb_fabrication_note_text>\n\n/**\n * Defines a fabrication note in text on the PCB, useful for leaving notes for assemblers or fabricators\n */\nexport interface PcbFabricationNoteText {\n  type: \"pcb_fabrication_note_text\"\n  pcb_fabrication_note_text_id: string\n  subcircuit_id?: string\n  pcb_group_id?: string\n  font: \"tscircuit2024\"\n  font_size: Length\n  pcb_component_id: string\n  text: string\n  layer: VisibleLayer\n  anchor_position: Point\n  anchor_alignment:\n    | \"center\"\n    | \"top_left\"\n    | \"top_right\"\n    | \"bottom_left\"\n    | \"bottom_right\"\n  color?: string\n}\n\n/**\n * @deprecated use PcbFabricationNoteText\n */\nexport type PCBFabricationNoteText = PcbFabricationNoteText\n\nexpectTypesMatch<PcbFabricationNoteText, InferredPcbFabricationNoteText>(true)\n","import { z } from \"zod\"\nimport { getZodPrefixedIdWithDefault } from \"src/common\"\nimport {\n  layer_ref,\n  visible_layer,\n  type LayerRef,\n} from \"src/pcb/properties/layer_ref\"\nimport { point, type Point } from \"src/common\"\nimport { length, type Length } from \"src/units\"\nimport { expectTypesMatch } from \"src/utils/expect-types-match\"\n\nexport const pcb_fabrication_note_path = z\n  .object({\n    type: z.literal(\"pcb_fabrication_note_path\"),\n    pcb_fabrication_note_path_id: getZodPrefixedIdWithDefault(\n      \"pcb_fabrication_note_path\",\n    ),\n    pcb_component_id: z.string(),\n    subcircuit_id: z.string().optional(),\n    layer: layer_ref,\n    route: z.array(point),\n    stroke_width: length,\n    color: z.string().optional(),\n  })\n  .describe(\n    \"Defines a fabrication path on the PCB for fabricators or assemblers\",\n  )\n\nexport type PcbFabricationNotePathInput = z.input<\n  typeof pcb_fabrication_note_path\n>\ntype InferredPcbFabricationNotePath = z.infer<typeof pcb_fabrication_note_path>\n\n/**\n * Defines a fabrication path on the PCB for fabricators or assemblers\n */\nexport interface PcbFabricationNotePath {\n  type: \"pcb_fabrication_note_path\"\n  pcb_fabrication_note_path_id: string\n  pcb_component_id: string\n  subcircuit_id?: string\n  layer: LayerRef\n  route: Point[]\n  stroke_width: Length\n  color?: string\n}\n\n/**\n * @deprecated use PcbFabricationNotePath\n */\nexport type PCBFabricationNotePath = PcbFabricationNotePath\n\nexpectTypesMatch<PcbFabricationNotePath, InferredPcbFabricationNotePath>(true)\n","import { z } from \"zod\"\nimport { getZodPrefixedIdWithDefault } from \"src/common\"\nimport { expectTypesMatch } from \"src/utils/expect-types-match\"\n\nexport const pcb_footprint_overlap_error = z\n  .object({\n    type: z.literal(\"pcb_footprint_overlap_error\"),\n    pcb_error_id: getZodPrefixedIdWithDefault(\"pcb_error\"),\n    error_type: z\n      .literal(\"pcb_footprint_overlap_error\")\n      .default(\"pcb_footprint_overlap_error\"),\n    message: z.string(),\n    pcb_smtpad_ids: z.array(z.string()).optional(),\n    pcb_plated_hole_ids: z.array(z.string()).optional(),\n    pcb_hole_ids: z.array(z.string()).optional(),\n    pcb_keepout_ids: z.array(z.string()).optional(),\n  })\n  .describe(\"Error emitted when a pcb footprint overlaps with another element\")\n\nexport type PcbFootprintOverlapErrorInput = z.input<\n  typeof pcb_footprint_overlap_error\n>\ntype InferredPcbFootprintOverlapError = z.infer<\n  typeof pcb_footprint_overlap_error\n>\n\n/** Error emitted when a pcb footprint overlaps with another element */\nexport interface PcbFootprintOverlapError {\n  type: \"pcb_footprint_overlap_error\"\n  pcb_error_id: string\n  error_type: \"pcb_footprint_overlap_error\"\n  message: string\n  pcb_smtpad_ids?: string[]\n  pcb_plated_hole_ids?: string[]\n  pcb_hole_ids?: string[]\n  pcb_keepout_ids?: string[]\n}\n\nexpectTypesMatch<PcbFootprintOverlapError, InferredPcbFootprintOverlapError>(\n  true,\n)\n","import { z } from \"zod\"\nimport { point, type Point } from \"../common\"\nimport { distance } from \"../units\"\nimport { expectTypesMatch } from \"src/utils/expect-types-match\"\n\nexport const pcb_keepout = z\n  .object({\n    type: z.literal(\"pcb_keepout\"),\n    shape: z.literal(\"rect\"),\n    pcb_group_id: z.string().optional(),\n    subcircuit_id: z.string().optional(),\n    center: point,\n    width: distance,\n    height: distance,\n    pcb_keepout_id: z.string(),\n    layers: z.array(z.string()), // Specify layers where the keepout applies\n    description: z.string().optional(), // Optional description of the keepout\n  })\n  .or(\n    z.object({\n      type: z.literal(\"pcb_keepout\"),\n      shape: z.literal(\"circle\"),\n      pcb_group_id: z.string().optional(),\n      subcircuit_id: z.string().optional(),\n      center: point,\n      radius: distance,\n      pcb_keepout_id: z.string(),\n      layers: z.array(z.string()), // Specify layers where the keepout applies\n      description: z.string().optional(), // Optional description of the keepout\n    }),\n  )\n\nexport type PCBKeepoutInput = z.input<typeof pcb_keepout>\ntype InferredPCBKeepout = z.infer<typeof pcb_keepout>\n\nexport interface PCBKeepoutRect {\n  type: \"pcb_keepout\"\n  shape: \"rect\"\n  pcb_group_id?: string\n  subcircuit_id?: string\n  center: Point\n  width: number\n  height: number\n  pcb_keepout_id: string\n  layers: string[]\n  description?: string\n}\n\nexport interface PCBKeepoutCircle {\n  type: \"pcb_keepout\"\n  shape: \"circle\"\n  pcb_group_id?: string\n  subcircuit_id?: string\n  center: Point\n  radius: number\n  pcb_keepout_id: string\n  layers: string[]\n  description?: string\n}\n\nexport type PCBKeepout = PCBKeepoutRect | PCBKeepoutCircle\n\nexpectTypesMatch<PCBKeepout, InferredPCBKeepout>(true)\n","import { z } from \"zod\"\nimport { point, type Point, getZodPrefixedIdWithDefault } from \"src/common\"\nimport { length, type Length, rotation, type Rotation } from \"src/units\"\nimport { expectTypesMatch } from \"src/utils/expect-types-match\"\n\n// Common properties base for all cutout shapes (internal)\nconst pcb_cutout_base = z.object({\n  type: z.literal(\"pcb_cutout\"),\n  pcb_cutout_id: getZodPrefixedIdWithDefault(\"pcb_cutout\"),\n  pcb_group_id: z.string().optional(),\n  subcircuit_id: z.string().optional(),\n})\n\n// Rectangular Cutout\nexport const pcb_cutout_rect = pcb_cutout_base.extend({\n  shape: z.literal(\"rect\"),\n  center: point,\n  width: length,\n  height: length,\n  rotation: rotation.optional(),\n})\nexport type PcbCutoutRectInput = z.input<typeof pcb_cutout_rect>\ntype InferredPcbCutoutRect = z.infer<typeof pcb_cutout_rect>\n/**\n * Defines a rectangular cutout on the PCB.\n */\nexport interface PcbCutoutRect {\n  type: \"pcb_cutout\"\n  pcb_cutout_id: string\n  pcb_group_id?: string\n  subcircuit_id?: string\n  shape: \"rect\"\n  center: Point\n  width: Length\n  height: Length\n  rotation?: Rotation\n}\nexpectTypesMatch<PcbCutoutRect, InferredPcbCutoutRect>(true)\n\n// Circular Cutout\nexport const pcb_cutout_circle = pcb_cutout_base.extend({\n  shape: z.literal(\"circle\"),\n  center: point,\n  radius: length,\n})\nexport type PcbCutoutCircleInput = z.input<typeof pcb_cutout_circle>\ntype InferredPcbCutoutCircle = z.infer<typeof pcb_cutout_circle>\n/**\n * Defines a circular cutout on the PCB.\n */\nexport interface PcbCutoutCircle {\n  type: \"pcb_cutout\"\n  pcb_cutout_id: string\n  pcb_group_id?: string\n  subcircuit_id?: string\n  shape: \"circle\"\n  center: Point\n  radius: Length\n}\nexpectTypesMatch<PcbCutoutCircle, InferredPcbCutoutCircle>(true)\n\n// Polygon Cutout\nexport const pcb_cutout_polygon = pcb_cutout_base.extend({\n  shape: z.literal(\"polygon\"),\n  points: z.array(point),\n})\nexport type PcbCutoutPolygonInput = z.input<typeof pcb_cutout_polygon>\ntype InferredPcbCutoutPolygon = z.infer<typeof pcb_cutout_polygon>\n/**\n * Defines a polygonal cutout on the PCB, specified by a list of points.\n * The polygon should be closed (the last point implicitly connects to the first).\n */\nexport interface PcbCutoutPolygon {\n  type: \"pcb_cutout\"\n  pcb_cutout_id: string\n  pcb_group_id?: string\n  subcircuit_id?: string\n  shape: \"polygon\"\n  points: Point[]\n}\nexpectTypesMatch<PcbCutoutPolygon, InferredPcbCutoutPolygon>(true)\n\n// Union of all cutout shapes\nexport const pcb_cutout = z\n  .discriminatedUnion(\"shape\", [\n    pcb_cutout_rect,\n    pcb_cutout_circle,\n    pcb_cutout_polygon,\n  ])\n  .describe(\"Defines a cutout on the PCB, removing board material.\")\n\nexport type PcbCutoutInput = z.input<typeof pcb_cutout>\nexport type PcbCutout = PcbCutoutRect | PcbCutoutCircle | PcbCutoutPolygon\n\ntype InferredPcbCutout = z.infer<typeof pcb_cutout>\nexpectTypesMatch<PcbCutout, InferredPcbCutout>(true)\n","import { z } from \"zod\"\nimport { getZodPrefixedIdWithDefault } from \"src/common\"\nimport { expectTypesMatch } from \"src/utils/expect-types-match\"\n\nexport const pcb_missing_footprint_error = z\n  .object({\n    type: z.literal(\"pcb_missing_footprint_error\"),\n    pcb_missing_footprint_error_id: getZodPrefixedIdWithDefault(\n      \"pcb_missing_footprint_error\",\n    ),\n    pcb_group_id: z.string().optional(),\n    subcircuit_id: z.string().optional(),\n    error_type: z\n      .literal(\"pcb_missing_footprint_error\")\n      .default(\"pcb_missing_footprint_error\"),\n    source_component_id: z.string(),\n    message: z.string(),\n  })\n  .describe(\"Defines a missing footprint error on the PCB\")\n\nexport type PcbMissingFootprintErrorInput = z.input<\n  typeof pcb_missing_footprint_error\n>\ntype InferredPcbMissingFootprintError = z.infer<\n  typeof pcb_missing_footprint_error\n>\n\n/**\n * Defines a placement error on the PCB\n */\nexport interface PcbMissingFootprintError {\n  type: \"pcb_missing_footprint_error\"\n  pcb_missing_footprint_error_id: string\n  pcb_group_id?: string\n  subcircuit_id?: string\n  error_type: \"pcb_missing_footprint_error\"\n  source_component_id: string\n  message: string\n}\n\n/**\n * @deprecated use PcbMissingFootprintError\n */\nexport type PCBMissingFootprintError = PcbMissingFootprintError\n\nexpectTypesMatch<PcbMissingFootprintError, InferredPcbMissingFootprintError>(\n  true,\n)\n","import { z } from \"zod\"\nimport { point, type Point, getZodPrefixedIdWithDefault } from \"src/common\"\nimport { length, type Length } from \"src/units\"\nimport { expectTypesMatch } from \"src/utils/expect-types-match\"\n\nexport const pcb_group = z\n  .object({\n    type: z.literal(\"pcb_group\"),\n    pcb_group_id: getZodPrefixedIdWithDefault(\"pcb_group\"),\n    source_group_id: z.string(),\n    is_subcircuit: z.boolean().optional(),\n    subcircuit_id: z.string().optional(),\n    width: length,\n    height: length,\n    center: point,\n    pcb_component_ids: z.array(z.string()),\n    name: z.string().optional(),\n    description: z.string().optional(),\n    autorouter_configuration: z\n      .object({\n        trace_clearance: length,\n      })\n      .optional(),\n    autorouter_used_string: z.string().optional(),\n  })\n  .describe(\"Defines a group of components on the PCB\")\n\nexport type PcbGroupInput = z.input<typeof pcb_group>\ntype InferredPcbGroup = z.infer<typeof pcb_group>\n\n/**\n * Defines a group of components on the PCB\n */\nexport interface PcbGroup {\n  type: \"pcb_group\"\n  pcb_group_id: string\n  source_group_id: string\n  is_subcircuit?: boolean\n  subcircuit_id?: string\n  width: Length\n  height: Length\n  center: Point\n  pcb_component_ids: string[]\n  name?: string\n  description?: string\n  autorouter_configuration?: {\n    trace_clearance: Length\n  }\n  autorouter_used_string?: string\n}\n\nexpectTypesMatch<PcbGroup, InferredPcbGroup>(true)\n","import { z } from \"zod\"\nimport { getZodPrefixedIdWithDefault } from \"src/common\"\nimport { expectTypesMatch } from \"src/utils/expect-types-match\"\n\nexport const pcb_autorouting_error = z\n  .object({\n    type: z.literal(\"pcb_autorouting_error\"),\n    pcb_error_id: getZodPrefixedIdWithDefault(\"pcb_autorouting_error\"),\n    error_type: z\n      .literal(\"pcb_autorouting_error\")\n      .default(\"pcb_autorouting_error\"),\n    message: z.string(),\n    subcircuit_id: z.string().optional(),\n  })\n  .describe(\"The autorouting has failed to route a portion of the board\")\n\nexport type PcbAutoroutingErrorInput = z.input<typeof pcb_autorouting_error>\ntype PcbInferredAutoroutingError = z.infer<typeof pcb_autorouting_error>\n\nexport interface PcbAutoroutingErrorInterface {\n  type: \"pcb_autorouting_error\"\n  pcb_error_id: string\n  error_type: \"pcb_autorouting_error\"\n  message: string\n  subcircuit_id?: string\n}\n\nexport type PcbAutoroutingError = PcbAutoroutingErrorInterface\n\nexpectTypesMatch<PcbAutoroutingError, PcbInferredAutoroutingError>(true)\n","import { z } from \"zod\"\nimport { getZodPrefixedIdWithDefault } from \"../common\"\nimport { expectTypesMatch } from \"../utils/expect-types-match\"\n\nexport const pcb_manual_edit_conflict_warning = z\n  .object({\n    type: z.literal(\"pcb_manual_edit_conflict_warning\"),\n    pcb_manual_edit_conflict_warning_id: getZodPrefixedIdWithDefault(\n      \"pcb_manual_edit_conflict_warning\",\n    ),\n    warning_type: z\n      .literal(\"pcb_manual_edit_conflict_warning\")\n      .default(\"pcb_manual_edit_conflict_warning\"),\n    message: z.string(),\n    pcb_component_id: z.string(),\n    pcb_group_id: z.string().optional(),\n    subcircuit_id: z.string().optional(),\n    source_component_id: z.string(),\n  })\n  .describe(\n    \"Warning emitted when a component has both manual placement and explicit pcbX/pcbY coordinates\",\n  )\n\nexport type PcbManualEditConflictWarningInput = z.input<\n  typeof pcb_manual_edit_conflict_warning\n>\ntype InferredPcbManualEditConflictWarning = z.infer<\n  typeof pcb_manual_edit_conflict_warning\n>\n\n/**\n * Warning emitted when a component has both manual placement (via manualEdits) and explicit pcbX/pcbY coordinates\n */\nexport interface PcbManualEditConflictWarning {\n  type: \"pcb_manual_edit_conflict_warning\"\n  pcb_manual_edit_conflict_warning_id: string\n  warning_type: \"pcb_manual_edit_conflict_warning\"\n  message: string\n  pcb_component_id: string\n  pcb_group_id?: string\n  subcircuit_id?: string\n  source_component_id: string\n}\n\nexpectTypesMatch<\n  PcbManualEditConflictWarning,\n  InferredPcbManualEditConflictWarning\n>(true)\n","import { z } from \"zod\"\nimport { getZodPrefixedIdWithDefault } from \"src/common\"\nimport { distance, type Distance } from \"src/units\"\nimport { expectTypesMatch } from \"src/utils/expect-types-match\"\n\nexport const pcb_breakout_point = z\n  .object({\n    type: z.literal(\"pcb_breakout_point\"),\n    pcb_breakout_point_id: getZodPrefixedIdWithDefault(\"pcb_breakout_point\"),\n    pcb_group_id: z.string(),\n    subcircuit_id: z.string().optional(),\n    source_trace_id: z.string().optional(),\n    source_port_id: z.string().optional(),\n    source_net_id: z.string().optional(),\n    x: distance,\n    y: distance,\n  })\n  .describe(\n    \"Defines a routing target within a pcb_group for a source_trace or source_net\",\n  )\n\nexport type PcbBreakoutPointInput = z.input<typeof pcb_breakout_point>\ntype InferredPcbBreakoutPoint = z.infer<typeof pcb_breakout_point>\n\n/**\n * Defines a routing target within a pcb_group for a source_trace or source_net\n */\nexport interface PcbBreakoutPoint {\n  type: \"pcb_breakout_point\"\n  pcb_breakout_point_id: string\n  pcb_group_id: string\n  subcircuit_id?: string\n  source_trace_id?: string\n  source_port_id?: string\n  source_net_id?: string\n  x: Distance\n  y: Distance\n}\n\nexpectTypesMatch<PcbBreakoutPoint, InferredPcbBreakoutPoint>(true)\n","import { z } from \"zod\"\nimport { getZodPrefixedIdWithDefault } from \"src/common\"\nimport { expectTypesMatch } from \"src/utils/expect-types-match\"\n\nexport const pcb_ground_plane = z\n  .object({\n    type: z.literal(\"pcb_ground_plane\"),\n    pcb_ground_plane_id: getZodPrefixedIdWithDefault(\"pcb_ground_plane\"),\n    source_pcb_ground_plane_id: z.string(),\n    source_net_id: z.string(),\n    pcb_group_id: z.string().optional(),\n    subcircuit_id: z.string().optional(),\n  })\n  .describe(\"Defines a ground plane on the PCB\")\n\nexport type PcbGroundPlaneInput = z.input<typeof pcb_ground_plane>\ntype InferredPcbGroundPlane = z.infer<typeof pcb_ground_plane>\n\n/**\n * Defines a ground plane on the PCB\n */\nexport interface PcbGroundPlane {\n  type: \"pcb_ground_plane\"\n  pcb_ground_plane_id: string\n  source_pcb_ground_plane_id: string\n  source_net_id: string\n  pcb_group_id?: string\n  subcircuit_id?: string\n}\n\nexpectTypesMatch<PcbGroundPlane, InferredPcbGroundPlane>(true)\n","import { z } from \"zod\"\nimport { point, type Point, getZodPrefixedIdWithDefault } from \"src/common\"\nimport { layer_ref, type LayerRef } from \"src/pcb/properties/layer_ref\"\nimport { expectTypesMatch } from \"src/utils/expect-types-match\"\n\nexport const pcb_ground_plane_region = z\n  .object({\n    type: z.literal(\"pcb_ground_plane_region\"),\n    pcb_ground_plane_region_id: getZodPrefixedIdWithDefault(\n      \"pcb_ground_plane_region\",\n    ),\n    pcb_ground_plane_id: z.string(),\n    pcb_group_id: z.string().optional(),\n    subcircuit_id: z.string().optional(),\n    layer: layer_ref,\n    points: z.array(point),\n  })\n  .describe(\"Defines a polygon region of a ground plane\")\n\nexport type PcbGroundPlaneRegionInput = z.input<typeof pcb_ground_plane_region>\ntype InferredPcbGroundPlaneRegion = z.infer<typeof pcb_ground_plane_region>\n\n/**\n * Defines a polygon region of a ground plane\n */\nexport interface PcbGroundPlaneRegion {\n  type: \"pcb_ground_plane_region\"\n  pcb_ground_plane_region_id: string\n  pcb_ground_plane_id: string\n  pcb_group_id?: string\n  subcircuit_id?: string\n  layer: LayerRef\n  points: Point[]\n}\n\nexpectTypesMatch<PcbGroundPlaneRegion, InferredPcbGroundPlaneRegion>(true)\n","import { z } from \"zod\"\nimport { distance, type Distance } from \"src/units\"\nimport { getZodPrefixedIdWithDefault } from \"src/common\"\nimport { expectTypesMatch } from \"src/utils/expect-types-match\"\n\nexport const pcb_thermal_spoke = z\n  .object({\n    type: z.literal(\"pcb_thermal_spoke\"),\n    pcb_thermal_spoke_id: getZodPrefixedIdWithDefault(\"pcb_thermal_spoke\"),\n    pcb_ground_plane_id: z.string(),\n    shape: z.string(),\n    spoke_count: z.number(),\n    spoke_thickness: distance,\n    spoke_inner_diameter: distance,\n    spoke_outer_diameter: distance,\n    pcb_plated_hole_id: z.string().optional(),\n    subcircuit_id: z.string().optional(),\n  })\n  .describe(\"Pattern for connecting a ground plane to a plated hole\")\n\nexport type PcbThermalSpokeInput = z.input<typeof pcb_thermal_spoke>\ntype InferredPcbThermalSpoke = z.infer<typeof pcb_thermal_spoke>\n\n/**\n * Pattern for connecting a ground plane to a plated hole\n */\nexport interface PcbThermalSpoke {\n  type: \"pcb_thermal_spoke\"\n  pcb_thermal_spoke_id: string\n  pcb_ground_plane_id: string\n  shape: string\n  spoke_count: number\n  spoke_thickness: Distance\n  spoke_inner_diameter: Distance\n  spoke_outer_diameter: Distance\n  pcb_plated_hole_id?: string\n  subcircuit_id?: string\n}\n\nexpectTypesMatch<PcbThermalSpoke, InferredPcbThermalSpoke>(true)\n","import { z } from \"zod\"\nimport { point3, type Point3 } from \"../common\"\nimport { rotation, length, type Rotation, type Length } from \"../units\"\nimport { layer_ref, type LayerRef } from \"src/pcb\"\nimport { expectTypesMatch } from \"src/utils/expect-types-match\"\n\nexport const cad_component = z\n  .object({\n    type: z.literal(\"cad_component\"),\n    cad_component_id: z.string(),\n    pcb_component_id: z.string(),\n    source_component_id: z.string(),\n    position: point3,\n    rotation: point3.optional(),\n    size: point3.optional(),\n    layer: layer_ref.optional(),\n    subcircuit_id: z.string().optional(),\n\n    // These are all ways to generate/load the 3d model\n    footprinter_string: z.string().optional(),\n    model_obj_url: z.string().optional(),\n    model_stl_url: z.string().optional(),\n    model_3mf_url: z.string().optional(),\n    model_jscad: z.any().optional(),\n  })\n  .describe(\"Defines a component on the PCB\")\n\nexport type CadComponentInput = z.input<typeof cad_component>\ntype InferredCadComponent = z.infer<typeof cad_component>\n\nexport interface CadComponent {\n  type: \"cad_component\"\n  cad_component_id: string\n  pcb_component_id: string\n  source_component_id: string\n  position: Point3\n  rotation?: Point3\n  size?: Point3\n  layer?: LayerRef\n  subcircuit_id?: string\n  footprinter_string?: string\n  model_obj_url?: string\n  model_stl_url?: string\n  model_3mf_url?: string\n  model_jscad?: any\n}\n\nexpectTypesMatch<CadComponent, InferredCadComponent>(true)\n","import { z } from \"zod\"\nimport * as pcb from \"./pcb\"\nimport * as sch from \"./schematic\"\nimport * as src from \"./source\"\nimport * as cad from \"./cad\"\nimport {\n  expectStringUnionsMatch,\n  expectTypesMatch,\n} from \"./utils/expect-types-match\"\n\nexport const any_circuit_element = z.union([\n  // TODO source_config\n  // TODO pcb_config\n  // TODO schematic_config\n  // TODO schematic_group\n  src.source_trace,\n  src.source_port,\n  src.any_source_component,\n  src.source_net,\n  src.source_group,\n  src.source_simple_chip,\n  src.source_simple_capacitor,\n  src.source_simple_diode,\n  src.source_simple_led,\n  src.source_simple_resistor,\n  src.source_simple_power_source,\n  src.source_simple_battery,\n  src.source_simple_inductor,\n  src.source_simple_pin_header,\n  src.source_simple_resonator,\n  src.source_simple_switch,\n  src.source_simple_transistor,\n  src.source_simple_test_point,\n  src.source_simple_mosfet,\n  src.source_simple_potentiometer,\n  src.source_simple_push_button,\n  src.source_pcb_ground_plane,\n  src.source_project_metadata,\n  pcb.pcb_component,\n  pcb.pcb_hole,\n  pcb.pcb_missing_footprint_error,\n  pcb.pcb_manual_edit_conflict_warning,\n  pcb.pcb_plated_hole,\n  pcb.pcb_keepout,\n  pcb.pcb_port,\n  pcb.pcb_text,\n  pcb.pcb_trace,\n  pcb.pcb_via,\n  pcb.pcb_smtpad,\n  pcb.pcb_solder_paste,\n  pcb.pcb_board,\n  pcb.pcb_group,\n  pcb.pcb_trace_hint,\n  pcb.pcb_silkscreen_line,\n  pcb.pcb_silkscreen_path,\n  pcb.pcb_silkscreen_text,\n  pcb.pcb_silkscreen_rect,\n  pcb.pcb_silkscreen_circle,\n  pcb.pcb_silkscreen_oval,\n  pcb.pcb_trace_error,\n  pcb.pcb_placement_error,\n  pcb.pcb_port_not_matched_error,\n  pcb.pcb_fabrication_note_path,\n  pcb.pcb_fabrication_note_text,\n  pcb.pcb_autorouting_error,\n  pcb.pcb_footprint_overlap_error,\n  pcb.pcb_breakout_point,\n  pcb.pcb_cutout,\n  pcb.pcb_ground_plane,\n  pcb.pcb_ground_plane_region,\n  pcb.pcb_thermal_spoke,\n  sch.schematic_box,\n  sch.schematic_text,\n  sch.schematic_line,\n  sch.schematic_component,\n  sch.schematic_port,\n  sch.schematic_trace,\n  sch.schematic_path,\n  sch.schematic_error,\n  sch.schematic_layout_error,\n  sch.schematic_net_label,\n  sch.schematic_debug_object,\n  sch.schematic_voltage_probe,\n  sch.schematic_manual_edit_conflict_warning,\n  sch.schematic_group,\n  sch.schematic_table,\n  sch.schematic_table_cell,\n  cad.cad_component,\n])\n\n/**\n * @deprecated use any_circuit_element instead\n */\nexport const any_soup_element = any_circuit_element\n\nexport type AnyCircuitElement = z.infer<typeof any_circuit_element>\nexport type AnyCircuitElementInput = z.input<typeof any_circuit_element>\n/**\n * @deprecated use AnyCircuitElement instead\n */\nexport type AnySoupElement = AnyCircuitElement\n\n/**\n * @deprecated use AnyCircuitElementInput instead\n */\nexport type AnySoupElementInput = AnyCircuitElementInput\n\n/**\n * Type representing a complete Circuit JSON document, which is an array of circuit elements.\n * This is the primary type used when working with circuit-json files or API responses.\n */\nexport type CircuitJson = AnyCircuitElement[]\n\n// ------------------- SAFETY CHECKS -------------------\n\n// SAFETY CHECK: Every element has a type\nexpectTypesMatch<\n  AnyCircuitElement extends { type: string } ? AnyCircuitElement : never,\n  AnyCircuitElement\n>(true)\n\n// SAFETY CHECK: Every element has an id with the key name `${type}_id`\ntype FindMissingId<T extends AnyCircuitElement> = T extends {\n  type: infer U extends string\n}\n  ? T extends { [K in `${U}_id`]: infer V }\n    ? V extends string\n      ? never\n      : `${U} DOES NOT HAVE AN ${U}_id PROPERTY`\n    : `${U} DOES NOT HAVE AN ${U}_id PROPERTY`\n  : never\n\nexpectStringUnionsMatch<\n  FindMissingId<AnyCircuitElement>,\n  // EXCEPTIONS TO THE RULE\n  // THIS IS FOR LEGACY REASONS, DO NOT ADD MORE EXCEPTIONS\n  | \"source_project_metadata DOES NOT HAVE AN source_project_metadata_id PROPERTY\"\n  | \"pcb_port_not_matched_error DOES NOT HAVE AN pcb_port_not_matched_error_id PROPERTY\"\n  | \"pcb_autorouting_error DOES NOT HAVE AN pcb_autorouting_error_id PROPERTY\"\n  | \"pcb_footprint_overlap_error DOES NOT HAVE AN pcb_footprint_overlap_error_id PROPERTY\"\n  | \"schematic_debug_object DOES NOT HAVE AN schematic_debug_object_id PROPERTY\"\n  | \"schematic_box DOES NOT HAVE AN schematic_box_id PROPERTY\"\n  | \"schematic_line DOES NOT HAVE AN schematic_line_id PROPERTY\"\n  | \"schematic_path DOES NOT HAVE AN schematic_path_id PROPERTY\"\n>(true)\n"],"mappings":"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ACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AACN,CAAC;AAKM,IAAM,mBAAmB;AAuBhC,iBAGE,IAAI;AAaN,wBAYE,IAAI;","names":["z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z"]}