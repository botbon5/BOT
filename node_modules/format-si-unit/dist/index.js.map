{"version":3,"sources":["../index.ts"],"sourcesContent":["const SI_PREFIXES = [\n  { value: 1e12, symbol: \"T\" },\n  { value: 1e9, symbol: \"G\" },\n  { value: 1e6, symbol: \"M\" },\n  { value: 1e3, symbol: \"k\" },\n  { value: 1, symbol: \"\" },\n  { value: 1e-3, symbol: \"m\" },\n  { value: 1e-6, symbol: \"Âµ\" },\n  { value: 1e-9, symbol: \"n\" },\n  { value: 1e-12, symbol: \"p\" },\n]\n\nexport function formatSiUnit(value?: number | null): string {\n  if (value == null) return \"\"\n  if (value === 0) return \"0\"\n\n  const absValue = Math.abs(value)\n  \n  const prefix = SI_PREFIXES.find((p) => {\n    const scaled = absValue / p.value\n    return scaled >= 1 && scaled < 1000\n  }) || SI_PREFIXES[SI_PREFIXES.length - 1]\n\n  const scaled = value / prefix.value\n\n  let formatted = scaled.toPrecision(3)\n  \n  // Only remove trailing zeros if there's a non-zero digit after the decimal\n  if (formatted.includes('.') && !/\\.0+$/.test(formatted)) {\n    formatted = formatted.replace(/0+$/, '')\n  }\n  \n  // Remove any pure \".0\" or \".00\" suffixes\n  formatted = formatted.replace(/\\.0+$/, '')\n\n  return `${formatted}${prefix.symbol}`\n}"],"mappings":";AAAA,IAAM,cAAc;AAAA,EAClB,EAAE,OAAO,MAAM,QAAQ,IAAI;AAAA,EAC3B,EAAE,OAAO,KAAK,QAAQ,IAAI;AAAA,EAC1B,EAAE,OAAO,KAAK,QAAQ,IAAI;AAAA,EAC1B,EAAE,OAAO,KAAK,QAAQ,IAAI;AAAA,EAC1B,EAAE,OAAO,GAAG,QAAQ,GAAG;AAAA,EACvB,EAAE,OAAO,MAAM,QAAQ,IAAI;AAAA,EAC3B,EAAE,OAAO,MAAM,QAAQ,OAAI;AAAA,EAC3B,EAAE,OAAO,MAAM,QAAQ,IAAI;AAAA,EAC3B,EAAE,OAAO,OAAO,QAAQ,IAAI;AAC9B;AAEO,SAAS,aAAa,OAA+B;AAC1D,MAAI,SAAS,KAAM,QAAO;AAC1B,MAAI,UAAU,EAAG,QAAO;AAExB,QAAM,WAAW,KAAK,IAAI,KAAK;AAE/B,QAAM,SAAS,YAAY,KAAK,CAAC,MAAM;AACrC,UAAMA,UAAS,WAAW,EAAE;AAC5B,WAAOA,WAAU,KAAKA,UAAS;AAAA,EACjC,CAAC,KAAK,YAAY,YAAY,SAAS,CAAC;AAExC,QAAM,SAAS,QAAQ,OAAO;AAE9B,MAAI,YAAY,OAAO,YAAY,CAAC;AAGpC,MAAI,UAAU,SAAS,GAAG,KAAK,CAAC,QAAQ,KAAK,SAAS,GAAG;AACvD,gBAAY,UAAU,QAAQ,OAAO,EAAE;AAAA,EACzC;AAGA,cAAY,UAAU,QAAQ,SAAS,EAAE;AAEzC,SAAO,GAAG,SAAS,GAAG,OAAO,MAAM;AACrC;","names":["scaled"]}