import { GraphicsObject } from 'graphics-debug';

type ForceSourceStage = "box-repel" | "pin-align" | "center-pull" | "networked-pin-pull";
interface ForceVec2 extends Vec2 {
    sourceStage?: ForceSourceStage;
    sourcePinId?: PinId;
}

interface Vec2 {
    x: number;
    y: number;
}
type BpcGraph = FloatingBpcGraph | FixedBpcGraph | MixedBpcGraph;
interface MixedBpcGraph {
    boxes: (BpcFloatingBox | BpcFixedBox)[];
    pins: BpcPin[];
    boxAttributes?: Record<string, any>;
}
interface FloatingBpcGraph {
    boxes: BpcFloatingBox[];
    pins: BpcPin[];
}
interface FixedBpcGraph {
    boxes: BpcFixedBox[];
    pins: BpcPin[];
}
interface BpcFixedBox {
    kind: "fixed";
    boxId: string;
    center: Vec2;
    boxAttributes?: Record<string, any>;
}
interface BpcFloatingBox {
    kind: "floating";
    center?: undefined | Vec2;
    boxId: string;
}
type BpcBox = BpcFixedBox | BpcFloatingBox;
interface BpcPin {
    boxId: string;
    pinId: string;
    networkId: string;
    color: string;
    offset: Vec2;
    pinAttributes?: Record<string, any>;
}
interface Bounds {
    minX: number;
    minY: number;
    maxX: number;
    maxY: number;
}
type Direction = "x-" | "x+" | "y+" | "y-";
type Axis = "x" | "y";
type BoxId = string;
type PinId = string;
type NetworkId = string;
/**
 * A flat BPC graph is a non-hierarchical and looks a lot like a regular graph.
 * The boxes are converted to nodes with a color "box", the pins are converted
 * to nodes, and the network ids are converted to fully connected edges
 */
interface FlatBpcGraph {
    nodes: FlatBpcGraphNode[];
    undirectedEdges: Array<[string, string]>;
}
interface FlatBpcGraphNode {
    id: string;
    boxId?: BoxId;
    pinId?: BoxId;
    color: string;
    x?: number;
    y?: number;
}

type FloatingBoxId = string;
type FixedBoxId = string;
type FloatingPinId = string;
type FixedPinId = string;
type FloatingNetworkId = string;
type FixedNetworkId = string;

declare const getGraphicsForBpcGraph: (g: BpcGraph, opts?: {
    grayNetworks?: boolean;
    title?: string;
    caption?: string;
}) => Required<GraphicsObject>;

declare const getGraphBounds: (g: BpcGraph) => Bounds;

declare const getPinPosition: (g: BpcGraph, boxId: string, pinId: string) => Vec2;

declare const getPinDirectionOrThrow: (g: BpcGraph, boxIdOrBox: string | BpcBox, pinIdOrPin: string | BpcPin) => Direction;
declare const getPinDirection: (g: BpcGraph, boxIdOrBox: string | BpcBox, pinIdOrPin: string | BpcPin) => Direction | null;

declare class BaseSolver {
    MAX_ITERATIONS: number;
    solved: boolean;
    failed: boolean;
    iterations: number;
    progress: number;
    error: string | null;
    _activeSubSolver?: BaseSolver | null;
    usedSubSolvers: Array<BaseSolver>;
    failedSubSolvers?: BaseSolver[];
    timeToSolve?: number;
    stats: any;
    /** DO NOT OVERRIDE! Override _step() instead */
    step(): void;
    _step(): void;
    getStatsSummary(): string;
    get activeSubSolver(): BaseSolver | null | undefined;
    getConstructorParams(): void;
    clearActiveSubSolver(): void;
    setActiveSubSolver(subSolver: BaseSolver | null): void;
    visualize(): GraphicsObject;
    solve(): void;
}

interface ForceDirectedLayoutSolverParams {
    graph: BpcGraph;
}
interface ForceDirectedLayoutSolverHyperParameters {
    DISPLAY_FORCE_LINE_MULTIPLIER: number;
    BOX_REPULSION_STRENGTH: number;
    PIN_PULL_STRENGTH: number;
    PIN_ALIGNMENT_STRENGTH: number;
    PIN_ALIGNMENT_ACTIVATE_DISTANCE: number;
    PIN_ALIGNMENT_GUIDELINE_LENGTH: number;
    CENTER_OF_GRAPH_STRENGTH: number;
    BOX_REPEL_DISTANCE1: number;
    BOX_REPEL_DISTANCE2: number;
    LEARNING_RATE: number;
    MAX_DISPLACEMENT_PER_STEP: number;
    RANDOM_INITIAL_PLACEMENT_MAX_X: number;
    RANDOM_INITIAL_PLACEMENT_MAX_Y: number;
    PIN_MASS_MULTIPLIER: number;
    BOX_CLOSE_REPULSION_POWER: number;
    BOX_MIN_EFFECTIVE_EDGE_DISTANCE: number;
}
/**
 * Types of forces exterted:
 * - Repulse boxes from other boxes
 * - Pull networked pins together
 * - Each pin emits "alignment axis" outward from the
 *   direction it's facing. It pulls pins on it's same network
 *   into it's alignment axis (and only applies a force orthogonal
 *   to the alignment axis)
 * - Small force towards the center of the graph (0,0)
 *
 * Starting conditions:
 * - Fixed boxes start at their fixed position and don't move
 * - Floating boxes start at either their center position or at
 *   a random position if their center isn't defined
 * - Pins do not change their offset relative to the box center,
 *   a force against a pin will move the floating box
 */
declare class ForceDirectedLayoutSolver extends BaseSolver {
    graph: BpcGraph;
    lastAppliedForces: Map<BoxId, ForceVec2[]>;
    hyperParameters: ForceDirectedLayoutSolverHyperParameters;
    constructor(inputParams: ForceDirectedLayoutSolverParams);
    initializeFloatingBoxPositions(): void;
    _step(): void;
    visualize(): GraphicsObject;
}

/**
 * @deprecated, the approach in netAdaptBpcGraph2 is a lot easier to understand
 * and is more efficient. This function takes the fixed graph and tries to adapt
 * the network to the floating graph, in netAdaptBpcGraph2 we just copy the
 * floating graph and assign positions
 *
 * This method adapts a source BPC graph to a target BPC graph such that the
 * nets match. At the end, there are the same boxes, the boxes are networked
 * in the same way, and there is a one-to-one mapping of boxes to boxes and
 * nets to nets. The pin offsets are are also changed to resemble the target
 * net where possible, however, the target bpc graph has some is completely
 * made up of "floating boxes" that do not have a position.
 *
 * The following process is used:
 * - Get approximate assignments of boxes to boxes and nets to nets
 * - Get edit operations for the source and target adjacency matrices
 * - Apply the edit operations to the source BPC graph
 * - Return the adapted BPC graph, the net assignment, and the box assignment
 */
declare const netAdaptBpcGraph: (fixedGraph: FixedBpcGraph, floatingGraph: MixedBpcGraph) => {
    adaptedBpcGraph: MixedBpcGraph;
};

declare const assignFloatingBoxPositions: (og: MixedBpcGraph) => FixedBpcGraph;

declare const getWlFeatureVecs: (g: BpcGraph, wlDegrees?: number) => Record<string, number>[];
declare const getBpcGraphWlDistance: (g1: BpcGraph, g2: BpcGraph, { wlDegrees }?: {
    wlDegrees?: number;
}) => number;

declare const getAdjacencyMatrixFromFlatBpcGraph: (flatBpcGraph: FlatBpcGraph) => {
    matrix: number[][];
    mapping: Map<string, number>;
    indexMapping: string[];
};

/**
 * Example:
 * {
 *   "sourceBox1": "targetBoxA",
 *   "sourceBox2": "targetBoxB",
 *   "sourceBox3": "targetBoxC",
 * }
 */
type Assignment<K extends string, V extends string> = Record<K, V>;
declare const getApproximateAssignments: (g1: BpcGraph, g2: BpcGraph) => {
    boxAssignment: Assignment<string, string>;
    networkAssignment: Assignment<string, string>;
    nodeAssignment: Assignment<string, string>;
};

declare const wlVecWeightedJaccardSimilarity: (wlFeatureVec1: Array<Record<string, number>>, wlFeatureVec2: Array<Record<string, number>>) => number;
declare const wlVecCosineSimilarity: (wlFeatureVec1: Array<Record<string, number>>, wlFeatureVec2: Array<Record<string, number>>) => number;
declare const getWlDotProduct: (wlFeatureVec1: Array<Record<string, number>>, wlFeatureVec2: Array<Record<string, number>>) => number;

/**
 * Runs the Weisfeiler-Lehman algorithm on the adjacency matrix and returns
 * an array of color count records after each refinement step (including initial).
 * Each entry is a record mapping color labels to their counts at that step.
 */
declare const wlFeatureVec: (adjMatrix: number[][], K: number, opts?: {
    nodeInitialColors?: string[];
}) => Array<Record<string, number>>;

type Side = "left" | "right" | "top" | "bottom";
declare const getBoxSideSubgraph: ({ bpcGraph, boxId, side, }: {
    bpcGraph: BpcGraph;
    boxId: string;
    side: Side;
}) => MixedBpcGraph;

declare const mergeBoxSideSubgraphs: (graphs: BpcGraph[], { renetworkedNetworkIdMap, }?: {
    renetworkedNetworkIdMap?: Record<string, string>;
}) => BpcGraph;

/**
 * Re-network a BPC graph by examining each pair of pins within the same network
 *
 * If the condition returns false, then the pins are considered NOT CONNECTED
 * and we will need to create a new network. When we create this new network,
 * we'll need to test the the condition again with the new network (and repeat)
 *
 * The most common use case is breaking a network into a left and right side
 * because we don't want to keep pins on the other side of the box within the
 * network.
 *
 * So let's say we have a 3 boxes, box1, box2, and box3 arranged in a row.
 * box1.center = { x: -5, y: 0 }
 * box2.center = { x: 0, y: 0 }
 * box3.center = { x: 5, y: 0 }
 *
 * Let's say that box2 has two pins, pin1 and pin2
 * box2.pin1.offset = { x: -0.5, y: 0 }
 * box2.pin2.offset = { x: 0.5, y: 0 }
 *
 * [box1.pin1, box2.pin1, box2.pin2, box3.pin1] compose a network
 *
 * all the pins have the same networkId ("network1")
 *
 * But now we want to create a condition that makes it so that box3.pin1 lives
 * in a different network.
 *
 * conditionStillConnected = (from, to,networkId) => {
 *   const side1 = from.box.center.x + from.pin.offset.x < 0 ? "left" : "right"
 *   const side2 = to.box.center.x + to.pin.offset.x < 0 ? "left" : "right"
 *   return side1 === side2
 * }
 *
 * conditionStillConnected(box1.pin1, box2.pin1, "network1") -> true
 * conditionStillConnected(box1.pin1, box2.pin2, "network1") -> false
 * conditionStillConnected(box1.pin1, box3.pin1, "network1") -> false
 *
 * So we can see that the new networks should be:
 * network1 = [box1.pin1, box2.pin1]
 * network2 = [box2.pin2, box3.pin1]
 *
 */
declare const renetworkWithCondition: (g: BpcGraph, conditionStillConnected: (from: {
    box: BpcBox;
    pin: BpcPin;
}, to: {
    box: BpcBox;
    pin: BpcPin;
}, networkId: string) => boolean) => {
    renetworkedGraph: BpcGraph;
    renetworkedNetworkIdMap: Record<string, string>;
};

/**
 * Render a FlatBpcGraph into a GraphicsObject so it can be visualised
 * next to the regular BPC-graph representation.
 */
declare const convertFlatBpcToGraphics: (flat: FlatBpcGraph, opts?: {
    title?: string;
    caption?: string;
}) => GraphicsObject;
declare const getGraphicsForFlatBpcGraph: (flat: FlatBpcGraph, opts?: {
    title?: string;
    caption?: string;
}) => GraphicsObject;

declare const getCanonicalRightFacingGraph: (g: MixedBpcGraph) => {
    g: MixedBpcGraph;
    reflected: boolean;
    centerBoxId: BoxId | null;
};

type WipPartition = {
    partitionId: string;
    filledSingletonSlots: Set<string>;
    pins: Array<{
        boxId: string;
        pinId: string;
    }>;
};
type PartitionSingletonKey = `${string}/${number}`;
/**
 * A method of partitioning a graph into connected components by dividing boxes
 *
 * This partitioning method lends itself to schematics where some singletonKeys
 * make sense because you don't have the same netlabel on both sides of the box.
 */
declare class SchematicPartitionProcessor {
    initialGraph: MixedBpcGraph;
    lastGraph: BpcGraph;
    lastExploredPin?: BpcPin & {
        partitionId: string;
    };
    solved: boolean;
    iteration: number;
    wipPartitions: WipPartition[];
    unexploredPins: Array<{
        boxId: string;
        pinId: string;
        partitionId: string;
    }>;
    boxSingletonKeys: Record<BoxId, Set<string>>;
    /**
     * Pins we have *investigated* per partition
     *   key =  `${partitionId}[${boxId}:${pinId}]`
     */
    exploredPins: Set<`${string}[${string}:${string}]`>;
    /**
     * Pins that have actually been *added* to some partition
     *   key =  `${boxId}:${string}`
     */
    addedPins: Set<`${string}:${string}`>;
    /**
     * All pins that have been accepted into any partition (regardless of duplicability)
     *   key =  `${boxId}:${string}`
     */
    allAcceptedPins: Set<`${string}:${string}`>;
    /**
     * Cached fan-out ( #neighbors ) for every pin
     *   key = `${boxId}:${pinId}`
     */
    pinConnectionCount: Record<`${string}:${string}`, number>;
    /**
     * #pins on each network      key = networkId
     */
    networkSize: Record<string, number>;
    /**
     * Network-size for each pin  key = `${boxId}:${pinId}`
     */
    pinNetworkSize: Record<`${string}:${string}`, number>;
    /**
     * Boxes that have been split into multiple partitions
     *   key = boxId
     */
    splitBoxIds: Set<string>;
    /**
     * Track which boxes have been accepted into partitions
     *   key = boxId, value = partitionId where it was first accepted
     */
    acceptedBoxPartitionMap: Map<string, string>;
    singletonKeys: PartitionSingletonKey[];
    /**
     * Center pins are alignment pins, they are duplicated to wherever a box is
     * copied and are duplicated across partitions
     */
    centerPinColors: string[];
    constructor(initialGraph: MixedBpcGraph, opts?: {
        /**
         * Every box has a set of characteristic keys e.g. "vcc/2", "gnd/2". The
         * first part of the key is a color of a pin inside it, the second part is
         * the number of pins in the box. In some applications, we want to make
         * sure that no partition contains two boxes with the same singleton key.
         *
         * If singletonKeys are provided, then we will never partition such that
         * two of these singleton keys are in the same partition.
         */
        singletonKeys?: PartitionSingletonKey[];
        /**
         * Center pins are alignment pins, they are duplicated to wherever a box is
         * copied and are duplicated across partitions.
         *
         * Center pin colors typically end with "_center"
         */
        centerPinColors?: string[];
    });
    initializeBoxSingletonKeys(): Record<string, Set<string>>;
    initializeWipPartitions(): {
        wipPartitions: WipPartition[];
        splitBoxIds: Set<string>;
        addedPins: Set<`${string}:${string}`>;
    };
    createWipPartitionFromEntireGraph(): WipPartition;
    step(): void;
    /**
     * Returns all pins reachable from the given pin
     *
     * A pin traverses it's own box as well as it's network
     */
    getNeighbors(pin: BpcPin): BpcPin[];
    solve(): void;
    getPartitions(): MixedBpcGraph[];
    getGraphicsForLastGraph(): GraphicsObject;
}

declare const layoutSchematicGraph: (g: BpcGraph, { corpus, singletonKeys, centerPinColors, floatingBoxIdsWithMutablePinOffsets, accessoryCorpus, }: {
    singletonKeys?: PartitionSingletonKey[];
    centerPinColors?: string[];
    floatingBoxIdsWithMutablePinOffsets?: Set<FloatingBoxId>;
    corpus: Record<string, FixedBpcGraph>;
    /**
     * A corpus with extra boxes that is associated with the main corpus.
     *
     * If the accessoryCorpus is provided, we'll keep track of "accessory boxes"
     * which are boxes that aren't matched but may be useful outside of the
     * layout process. For example, this is often used for netlabels, which
     * don't effect the layout but it's useful to keep track of their positions
     * in the corpus so that you can use the netlabel positions outside of the
     * layout process.
     */
    accessoryCorpus?: Record<string, FixedBpcGraph>;
}) => {
    fixedGraph: FixedBpcGraph;
    accessoryFixedGraph?: FixedBpcGraph;
    distance: number;
};

declare const layoutSchematicGraphVariants: (variants: Array<{
    variantName: string;
    floatingGraph: BpcGraph;
}>, { corpus, singletonKeys, centerPinColors, floatingBoxIdsWithMutablePinOffsets, }: {
    singletonKeys?: PartitionSingletonKey[];
    centerPinColors?: string[];
    floatingBoxIdsWithMutablePinOffsets?: Set<FloatingBoxId>;
    corpus: Record<string, FixedBpcGraph>;
    accessoryCorpus?: Record<string, FixedBpcGraph>;
}) => {
    fixedGraph: FixedBpcGraph;
    accessoryFixedGraph?: FixedBpcGraph;
    selectedVariantName: string;
    variantResults: Array<{
        variantName: string;
        distance: number;
    }>;
};

export { type Assignment, type Axis, type Bounds, type BoxId, type BpcBox, type BpcFixedBox, type BpcFloatingBox, type BpcGraph, type BpcPin, type Direction, type FixedBoxId, type FixedBpcGraph, type FixedNetworkId, type FixedPinId, type FlatBpcGraph, type FlatBpcGraphNode, type FloatingBoxId, type FloatingBpcGraph, type FloatingNetworkId, type FloatingPinId, ForceDirectedLayoutSolver, type ForceDirectedLayoutSolverHyperParameters, type ForceSourceStage, type ForceVec2, type MixedBpcGraph, type NetworkId, type PartitionSingletonKey, type PinId, SchematicPartitionProcessor, type Side, type Vec2, type WipPartition, assignFloatingBoxPositions, convertFlatBpcToGraphics, getAdjacencyMatrixFromFlatBpcGraph, getApproximateAssignments, getBoxSideSubgraph, getBpcGraphWlDistance, getCanonicalRightFacingGraph, getGraphBounds, getGraphicsForBpcGraph, getGraphicsForFlatBpcGraph, getPinDirection, getPinDirectionOrThrow, getPinPosition, getWlDotProduct, getWlFeatureVecs, layoutSchematicGraph, layoutSchematicGraphVariants, mergeBoxSideSubgraphs, netAdaptBpcGraph, renetworkWithCondition, wlFeatureVec, wlVecCosineSimilarity, wlVecWeightedJaccardSimilarity };
