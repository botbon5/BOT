{"version":3,"sources":["../src/SuperGrid.tsx"],"sourcesContent":["import React, { useEffect, useRef, useState } from \"react\"\nimport { type Matrix, applyToPoint, inverse } from \"transformation-matrix\"\n\nconst rangeInclusive = (start: number, end: number, inc: number) => {\n  const result = []\n  if (end < start) {\n    for (let i = start; i >= end; i -= Math.abs(inc)) {\n      result.push(i)\n    }\n  } else {\n    for (let i = start; i <= end; i += Math.abs(inc)) {\n      result.push(i)\n    }\n  }\n  return result\n}\n\nexport interface SuperGridProps {\n  /**\n   * Represents the transformation between world and screen coordinates\n   */\n  transform: Matrix\n  width: number\n  height: number\n  screenSpaceCellSize?: number\n  textColor?: string\n  majorColor?: string\n  minorColor?: string\n  stringifyCoord?: (x: number, y: number, cellSize?: number) => string\n}\n\nfunction roundPointToZ(Z: number, position: { x: number; y: number }) {\n  return {\n    x: Math.round(position.x / Z) * Z,\n    y: Math.round(position.y / Z) * Z,\n  }\n}\n\nexport function toMeterSI(value: number, Z: number = 1): string {\n  if (value < 0) return \"-\" + toMeterSI(-value)\n  if (value < 0.000001) return \"0m\"\n\n  if (value > 1e3) return Math.floor(value / 1000) + \"km\"\n  if (value > 1 && Z > 1) return Math.round(value) + \"m\"\n  if (value > 1 && Z <= 1) return value.toFixed(Math.ceil(-Math.log10(Z))) + \"m\"\n  if (value < 1 && Z >= 1 / 1000) return Math.round(value * 1000) + \"mm\"\n  if (value < 1 && Z < 1 / 1000)\n    return (value * 1000).toFixed(Math.ceil(-Math.log10(Z * 1000))) + \"mm\"\n  return \"\"\n}\n\nexport function toMMSI(value: number, Z: number = 1): string {\n  return toMeterSI(value / 1000, Z / 1000)\n}\n\nexport const SuperGrid = (props: SuperGridProps) => {\n  const ref = useRef<HTMLCanvasElement>(null)\n  const [mousePos, setMousePos] = useState({ x: 0, y: 0 })\n  const {\n    majorColor = \"rgba(0,0,0,0.2)\",\n    minorColor = \"rgba(0,0,0,0.1)\",\n    textColor = props.majorColor ?? \"rgba(0,0,0,0.5)\",\n    width,\n    height,\n    screenSpaceCellSize = 200,\n    stringifyCoord = (x, y, Z) => `${toMeterSI(x, Z)}, ${toMeterSI(y, Z)}`,\n  } = props\n\n  /**\n   * Max number of major cells you could draw on the screen across it's width\n   */\n  const cellScreenWidth = Math.ceil(width / screenSpaceCellSize) + 2\n  /**\n   * Max number of major cells you could draw on the screen across it's height\n   */\n  const cellScreenHeight = Math.ceil(height / screenSpaceCellSize) + 2\n\n  useEffect(() => {\n    if (!ref.current) return\n    const ctx = ref.current.getContext(\"2d\")!\n    if (!ctx) return\n\n    /**\n     * Upper-bound at which minor cell becomes major cell.\n     *\n     * As you zoom in, this will go from 2000 to 200 to 20 to 2 etc. in discrete\n     * steps.\n     */\n    const Z =\n      screenSpaceCellSize / 10 ** Math.floor(Math.log10(props.transform.a))\n    const yInvN = props.transform.d < 0 ? -1 : 1\n    /**\n     * Size of a minor cell in transform space.\n     */\n    const Za = screenSpaceCellSize / 10 ** Math.log10(props.transform.a)\n    /**\n     * Percentage transition from major transition point.\n     *\n     * As you zoom in, Zp goes from 1 to 0 repeatedly\n     */\n    const Zp = Za / Z\n\n    function drawGridLines(\n      z: number,\n      start: { x: number; y: number },\n      end: { x: number; y: number }\n    ) {\n      const cellSize = z\n      let x: number, y: number\n      let lineStart: { x: number; y: number }\n      let lineEnd: { x: number; y: number }\n\n      // Vertical Lines\n      for (x = start.x; x <= end.x; x += cellSize) {\n        lineStart = applyToPoint(props.transform, { x, y: start.y })\n        lineEnd = applyToPoint(props.transform, { x, y: end.y })\n        ctx.beginPath()\n        ctx.moveTo(lineStart.x, lineStart.y)\n        ctx.lineTo(lineEnd.x, lineEnd.y)\n        ctx.stroke()\n      }\n      // Horizontal Lines\n      const rowYs = rangeInclusive(start.y, end.y, cellSize * yInvN)\n      // for (y = start.y; y <= end.y; y += cellSize) {\n      for (const y of rowYs) {\n        lineStart = applyToPoint(props.transform, { x: start.x, y })\n        lineEnd = applyToPoint(props.transform, { x: end.x, y })\n        ctx.beginPath()\n        ctx.moveTo(lineStart.x, lineStart.y)\n        ctx.lineTo(lineEnd.x, lineEnd.y)\n        ctx.stroke()\n      }\n    }\n\n    function drawGridText(\n      z: number,\n      start: { x: number; y: number },\n      end: { x: number; y: number }\n    ) {\n      const cellSize = z\n      let x: number, y: number\n\n      for (x = start.x; x <= end.x; x += cellSize) {\n        for (const y of rangeInclusive(start.y, end.y, cellSize * yInvN)) {\n          const point = applyToPoint(props.transform, { x, y })\n          ctx.fillStyle = textColor\n          ctx.font = `12px sans-serif`\n          ctx.fillText(stringifyCoord(x, y, z), point.x + 2, point.y - 2)\n        }\n      }\n    }\n\n    ctx.clearRect(0, 0, width, height)\n\n    const topLeft = applyToPoint(inverse(props.transform), { x: 0, y: 0 })\n\n    const zRoundedOffsetTopLeft = {\n      x: Math.floor((topLeft.x - Z) / Z) * Z,\n      // when y is cartesian (yInvN = -1), we need to add 2 rows to the top\n      y: Math.floor((topLeft.y - Z) / Z + (yInvN == -1 ? 2 : 0)) * Z,\n    }\n    const zRoundedOffsetBottomRight = {\n      x: zRoundedOffsetTopLeft.x + Z * cellScreenWidth,\n      y: zRoundedOffsetTopLeft.y + Z * cellScreenHeight * yInvN,\n    }\n\n    const textN = 5\n    const NZ = Z * textN\n    const NZRoundedOffsetTopLeft = {\n      x: Math.floor((topLeft.x - NZ) / NZ) * NZ,\n      // when y is cartesian (yInvN = -1), we need to add 2 rows to the top\n      y: Math.floor((topLeft.y - NZ) / NZ + (yInvN == -1 ? 2 : 0)) * NZ,\n    }\n    const NZRoundedOffsetBottomRight = {\n      x: NZRoundedOffsetTopLeft.x + NZ * cellScreenWidth,\n      y: NZRoundedOffsetTopLeft.y + NZ * cellScreenHeight * yInvN,\n    }\n\n    ctx.globalAlpha = 1\n    ctx.strokeStyle = majorColor\n    // Major Lines\n    drawGridLines(Z, zRoundedOffsetTopLeft, zRoundedOffsetBottomRight)\n    drawGridText(NZ, NZRoundedOffsetTopLeft, NZRoundedOffsetBottomRight)\n    // Minor Lines\n    ctx.globalAlpha = 1 - Zp\n    drawGridLines(NZ / 10, NZRoundedOffsetTopLeft, NZRoundedOffsetBottomRight)\n    ctx.globalAlpha = 1 - Zp\n    ctx.strokeStyle = minorColor\n    drawGridLines(Z / 10, zRoundedOffsetTopLeft, zRoundedOffsetBottomRight)\n    ctx.globalAlpha = Math.max(((1 - Zp) * 10 - 5) / 5, 0)\n    drawGridText(NZ / 10, NZRoundedOffsetTopLeft, NZRoundedOffsetBottomRight)\n\n    ctx.globalAlpha = 1\n    const projMousePos = applyToPoint(props.transform, mousePos)\n    ctx.font = `12px sans-serif`\n    ctx.fillStyle = textColor\n    ctx.fillText(\n      stringifyCoord(mousePos.x, mousePos.y, Z),\n      projMousePos.x + 2,\n      projMousePos.y - 2\n    )\n    ctx.strokeStyle = majorColor\n    ctx.strokeRect(projMousePos.x - 5, projMousePos.y - 5, 10, 10)\n  }, [ref, props.transform, mousePos, width, height])\n\n  const onMouseSetTarget = (e: React.MouseEvent<HTMLCanvasElement>) => {\n    if (!ref.current) return\n    const Z =\n      screenSpaceCellSize / 10 / 10 ** Math.floor(Math.log10(props.transform.a))\n    const rect = ref.current.getBoundingClientRect()\n    const projM = applyToPoint(inverse(props.transform), {\n      x: e.clientX - rect.left,\n      y: e.clientY - rect.top,\n    })\n    const m = roundPointToZ(Z, projM)\n    setMousePos(m)\n  }\n\n  return (\n    <canvas\n      onMouseUp={(e) => {\n        if (e.button !== 1) return\n        onMouseSetTarget(e)\n      }}\n      onDoubleClick={onMouseSetTarget}\n      ref={ref}\n      width={props.width}\n      height={props.height}\n    />\n  )\n}\n"],"mappings":"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","names":["y"]}