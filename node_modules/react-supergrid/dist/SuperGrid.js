"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/SuperGrid.tsx
var SuperGrid_exports = {};
__export(SuperGrid_exports, {
  SuperGrid: () => SuperGrid,
  toMMSI: () => toMMSI,
  toMeterSI: () => toMeterSI
});
module.exports = __toCommonJS(SuperGrid_exports);
var import_react = require("react");
var import_transformation_matrix = require("transformation-matrix");
var import_jsx_runtime = require("react/jsx-runtime");
var rangeInclusive = (start, end, inc) => {
  const result = [];
  if (end < start) {
    for (let i = start; i >= end; i -= Math.abs(inc)) {
      result.push(i);
    }
  } else {
    for (let i = start; i <= end; i += Math.abs(inc)) {
      result.push(i);
    }
  }
  return result;
};
function roundPointToZ(Z, position) {
  return {
    x: Math.round(position.x / Z) * Z,
    y: Math.round(position.y / Z) * Z
  };
}
function toMeterSI(value, Z = 1) {
  if (value < 0)
    return "-" + toMeterSI(-value);
  if (value < 1e-6)
    return "0m";
  if (value > 1e3)
    return Math.floor(value / 1e3) + "km";
  if (value > 1 && Z > 1)
    return Math.round(value) + "m";
  if (value > 1 && Z <= 1)
    return value.toFixed(Math.ceil(-Math.log10(Z))) + "m";
  if (value < 1 && Z >= 1 / 1e3)
    return Math.round(value * 1e3) + "mm";
  if (value < 1 && Z < 1 / 1e3)
    return (value * 1e3).toFixed(Math.ceil(-Math.log10(Z * 1e3))) + "mm";
  return "";
}
function toMMSI(value, Z = 1) {
  return toMeterSI(value / 1e3, Z / 1e3);
}
var SuperGrid = (props) => {
  var _a;
  const ref = (0, import_react.useRef)(null);
  const [mousePos, setMousePos] = (0, import_react.useState)({ x: 0, y: 0 });
  const {
    majorColor = "rgba(0,0,0,0.2)",
    minorColor = "rgba(0,0,0,0.1)",
    textColor = (_a = props.majorColor) != null ? _a : "rgba(0,0,0,0.5)",
    width,
    height,
    screenSpaceCellSize = 200,
    stringifyCoord = (x, y, Z) => `${toMeterSI(x, Z)}, ${toMeterSI(y, Z)}`
  } = props;
  const cellScreenWidth = Math.ceil(width / screenSpaceCellSize) + 2;
  const cellScreenHeight = Math.ceil(height / screenSpaceCellSize) + 2;
  (0, import_react.useEffect)(() => {
    if (!ref.current)
      return;
    const ctx = ref.current.getContext("2d");
    if (!ctx)
      return;
    const Z = screenSpaceCellSize / 10 ** Math.floor(Math.log10(props.transform.a));
    const yInvN = props.transform.d < 0 ? -1 : 1;
    const Za = screenSpaceCellSize / 10 ** Math.log10(props.transform.a);
    const Zp = Za / Z;
    function drawGridLines(z, start, end) {
      const cellSize = z;
      let x, y;
      let lineStart;
      let lineEnd;
      for (x = start.x; x <= end.x; x += cellSize) {
        lineStart = (0, import_transformation_matrix.applyToPoint)(props.transform, { x, y: start.y });
        lineEnd = (0, import_transformation_matrix.applyToPoint)(props.transform, { x, y: end.y });
        ctx.beginPath();
        ctx.moveTo(lineStart.x, lineStart.y);
        ctx.lineTo(lineEnd.x, lineEnd.y);
        ctx.stroke();
      }
      const rowYs = rangeInclusive(start.y, end.y, cellSize * yInvN);
      for (const y2 of rowYs) {
        lineStart = (0, import_transformation_matrix.applyToPoint)(props.transform, { x: start.x, y: y2 });
        lineEnd = (0, import_transformation_matrix.applyToPoint)(props.transform, { x: end.x, y: y2 });
        ctx.beginPath();
        ctx.moveTo(lineStart.x, lineStart.y);
        ctx.lineTo(lineEnd.x, lineEnd.y);
        ctx.stroke();
      }
    }
    function drawGridText(z, start, end) {
      const cellSize = z;
      let x, y;
      for (x = start.x; x <= end.x; x += cellSize) {
        for (const y2 of rangeInclusive(start.y, end.y, cellSize * yInvN)) {
          const point = (0, import_transformation_matrix.applyToPoint)(props.transform, { x, y: y2 });
          ctx.fillStyle = textColor;
          ctx.font = `12px sans-serif`;
          ctx.fillText(stringifyCoord(x, y2, z), point.x + 2, point.y - 2);
        }
      }
    }
    ctx.clearRect(0, 0, width, height);
    const topLeft = (0, import_transformation_matrix.applyToPoint)((0, import_transformation_matrix.inverse)(props.transform), { x: 0, y: 0 });
    const zRoundedOffsetTopLeft = {
      x: Math.floor((topLeft.x - Z) / Z) * Z,
      // when y is cartesian (yInvN = -1), we need to add 2 rows to the top
      y: Math.floor((topLeft.y - Z) / Z + (yInvN == -1 ? 2 : 0)) * Z
    };
    const zRoundedOffsetBottomRight = {
      x: zRoundedOffsetTopLeft.x + Z * cellScreenWidth,
      y: zRoundedOffsetTopLeft.y + Z * cellScreenHeight * yInvN
    };
    const textN = 5;
    const NZ = Z * textN;
    const NZRoundedOffsetTopLeft = {
      x: Math.floor((topLeft.x - NZ) / NZ) * NZ,
      // when y is cartesian (yInvN = -1), we need to add 2 rows to the top
      y: Math.floor((topLeft.y - NZ) / NZ + (yInvN == -1 ? 2 : 0)) * NZ
    };
    const NZRoundedOffsetBottomRight = {
      x: NZRoundedOffsetTopLeft.x + NZ * cellScreenWidth,
      y: NZRoundedOffsetTopLeft.y + NZ * cellScreenHeight * yInvN
    };
    ctx.globalAlpha = 1;
    ctx.strokeStyle = majorColor;
    drawGridLines(Z, zRoundedOffsetTopLeft, zRoundedOffsetBottomRight);
    drawGridText(NZ, NZRoundedOffsetTopLeft, NZRoundedOffsetBottomRight);
    ctx.globalAlpha = 1 - Zp;
    drawGridLines(NZ / 10, NZRoundedOffsetTopLeft, NZRoundedOffsetBottomRight);
    ctx.globalAlpha = 1 - Zp;
    ctx.strokeStyle = minorColor;
    drawGridLines(Z / 10, zRoundedOffsetTopLeft, zRoundedOffsetBottomRight);
    ctx.globalAlpha = Math.max(((1 - Zp) * 10 - 5) / 5, 0);
    drawGridText(NZ / 10, NZRoundedOffsetTopLeft, NZRoundedOffsetBottomRight);
    ctx.globalAlpha = 1;
    const projMousePos = (0, import_transformation_matrix.applyToPoint)(props.transform, mousePos);
    ctx.font = `12px sans-serif`;
    ctx.fillStyle = textColor;
    ctx.fillText(
      stringifyCoord(mousePos.x, mousePos.y, Z),
      projMousePos.x + 2,
      projMousePos.y - 2
    );
    ctx.strokeStyle = majorColor;
    ctx.strokeRect(projMousePos.x - 5, projMousePos.y - 5, 10, 10);
  }, [ref, props.transform, mousePos, width, height]);
  const onMouseSetTarget = (e) => {
    if (!ref.current)
      return;
    const Z = screenSpaceCellSize / 10 / 10 ** Math.floor(Math.log10(props.transform.a));
    const rect = ref.current.getBoundingClientRect();
    const projM = (0, import_transformation_matrix.applyToPoint)((0, import_transformation_matrix.inverse)(props.transform), {
      x: e.clientX - rect.left,
      y: e.clientY - rect.top
    });
    const m = roundPointToZ(Z, projM);
    setMousePos(m);
  };
  return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
    "canvas",
    {
      onMouseUp: (e) => {
        if (e.button !== 1)
          return;
        onMouseSetTarget(e);
      },
      onDoubleClick: onMouseSetTarget,
      ref,
      width: props.width,
      height: props.height
    }
  );
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  SuperGrid,
  toMMSI,
  toMeterSI
});
//# sourceMappingURL=SuperGrid.js.map