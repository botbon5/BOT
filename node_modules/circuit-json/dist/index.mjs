// src/utils/convert-si-unit-to-number.ts
var unitMappings = {
  Hz: {
    baseUnit: "Hz",
    variants: {
      MHz: 1e6,
      kHz: 1e3,
      Hz: 1
    }
  },
  g: {
    baseUnit: "g",
    variants: {
      kg: 1e3,
      g: 1
    }
  },
  \u03A9: {
    baseUnit: "\u03A9",
    variants: {
      m\u03A9: 1e-3,
      \u03A9: 1,
      k\u03A9: 1e3,
      K\u03A9: 1e3,
      kohm: 1e3,
      M\u03A9: 1e6,
      G\u03A9: 1e9,
      T\u03A9: 1e12
    }
  },
  V: {
    baseUnit: "V",
    variants: {
      mV: 1e-3,
      V: 1,
      kV: 1e3,
      KV: 1e3,
      MV: 1e6,
      GV: 1e9,
      TV: 1e12
    }
  },
  A: {
    baseUnit: "A",
    variants: {
      \u00B5A: 1e-6,
      mA: 1e-3,
      ma: 1e-3,
      A: 1,
      kA: 1e3,
      MA: 1e6
    }
  },
  F: {
    baseUnit: "F",
    variants: {
      pF: 1e-12,
      nF: 1e-9,
      \u00B5F: 1e-6,
      uF: 1e-6,
      mF: 1e-3,
      F: 1
    }
  },
  ml: {
    baseUnit: "ml",
    variants: {
      ml: 1,
      mL: 1,
      l: 1e3,
      L: 1e3
    }
  },
  deg: {
    baseUnit: "deg",
    variants: {
      rad: 180 / Math.PI
    }
  },
  ms: {
    baseUnit: "ms",
    variants: {
      s: 1e3
    }
  },
  mm: {
    baseUnit: "mm",
    variants: {
      nm: 1e-6,
      \u00B5m: 1e-3,
      um: 1e-3,
      mm: 1,
      cm: 10,
      dm: 100,
      m: 1e3,
      km: 1e6,
      in: 25.4,
      ft: 304.8,
      IN: 25.4,
      FT: 304.8,
      yd: 914.4,
      mi: 1609344,
      mil: 0.0254
    }
  }
};
var unitMappingAndVariantSuffixes = /* @__PURE__ */ new Set();
for (const [baseUnit, info] of Object.entries(unitMappings)) {
  unitMappingAndVariantSuffixes.add(baseUnit);
  for (const variant of Object.keys(info.variants)) {
    unitMappingAndVariantSuffixes.add(variant);
  }
}
function getBaseTscircuitUnit(unit) {
  for (const [baseUnit, info] of Object.entries(unitMappings)) {
    if (unit in info.variants) {
      return {
        baseUnit: info.baseUnit,
        conversionFactor: info.variants[unit]
      };
    }
  }
  return {
    baseUnit: unit,
    conversionFactor: 1
  };
}
var si_prefix_multiplier = {
  tera: 1e12,
  T: 1e12,
  giga: 1e9,
  G: 1e9,
  mega: 1e6,
  M: 1e6,
  kilo: 1e3,
  k: 1e3,
  deci: 0.1,
  d: 0.1,
  centi: 0.01,
  c: 0.01,
  milli: 1e-3,
  m: 1e-3,
  micro: 1e-6,
  u: 1e-6,
  \u00B5: 1e-6,
  nano: 1e-9,
  n: 1e-9,
  pico: 1e-12,
  p: 1e-12
};
var parseAndConvertSiUnit = (v) => {
  if (typeof v === "undefined")
    return { parsedUnit: null, unitOfValue: null, value: null };
  if (typeof v === "string" && v.match(/^-?[\d\.]+$/))
    return {
      value: Number.parseFloat(v),
      parsedUnit: null,
      unitOfValue: null
    };
  if (typeof v === "number")
    return { value: v, parsedUnit: null, unitOfValue: null };
  if (typeof v === "object" && "x" in v && "y" in v) {
    const { parsedUnit, unitOfValue } = parseAndConvertSiUnit(v.x);
    return {
      parsedUnit,
      unitOfValue,
      value: {
        x: parseAndConvertSiUnit(v.x).value,
        y: parseAndConvertSiUnit(v.y).value
      }
    };
  }
  const reversed_input_string = v.toString().split("").reverse().join("");
  const unit_reversed = reversed_input_string.match(/[^\d\s]+/)?.[0];
  if (!unit_reversed) {
    throw new Error(`Could not determine unit: "${v}"`);
  }
  const unit = unit_reversed.split("").reverse().join("");
  const numberPart = v.slice(0, -unit.length);
  if (unit in si_prefix_multiplier && !unitMappingAndVariantSuffixes.has(unit)) {
    const siMultiplier = si_prefix_multiplier[unit];
    return {
      parsedUnit: null,
      unitOfValue: null,
      value: Number.parseFloat(numberPart) * siMultiplier
    };
  }
  const { baseUnit, conversionFactor } = getBaseTscircuitUnit(unit);
  return {
    parsedUnit: unit,
    unitOfValue: baseUnit,
    value: conversionFactor * Number.parseFloat(numberPart)
  };
};

// src/units/index.ts
import { z } from "zod";
var resistance = z.string().or(z.number()).transform((v) => parseAndConvertSiUnit(v).value);
var capacitance = z.string().or(z.number()).transform((v) => parseAndConvertSiUnit(v).value).transform((value) => {
  return Number.parseFloat(value.toPrecision(12));
});
var inductance = z.string().or(z.number()).transform((v) => parseAndConvertSiUnit(v).value);
var voltage = z.string().or(z.number()).transform((v) => parseAndConvertSiUnit(v).value);
var length = z.string().or(z.number()).transform((v) => parseAndConvertSiUnit(v).value);
var frequency = z.string().or(z.number()).transform((v) => parseAndConvertSiUnit(v).value);
var distance = length;
var current = z.string().or(z.number()).transform((v) => parseAndConvertSiUnit(v).value);
var time = z.string().or(z.number()).transform((v) => parseAndConvertSiUnit(v).value);
var rotation = z.string().or(z.number()).transform((arg) => {
  if (typeof arg === "number") return arg;
  if (arg.endsWith("deg")) {
    return Number.parseFloat(arg.split("deg")[0]);
  }
  if (arg.endsWith("rad")) {
    return Number.parseFloat(arg.split("rad")[0]) * 180 / Math.PI;
  }
  return Number.parseFloat(arg);
});
var battery_capacity = z.number().or(z.string().endsWith("mAh")).transform((v) => {
  if (typeof v === "string") {
    const valString = v.replace("mAh", "");
    const num = Number.parseFloat(valString);
    if (Number.isNaN(num)) {
      throw new Error("Invalid capacity");
    }
    return num;
  }
  return v;
}).describe("Battery capacity in mAh");

// src/common/point.ts
import { z as z2 } from "zod";

// src/utils/expect-types-match.ts
var expectTypesMatch = (shouldBe) => {
};
expectTypesMatch("extra props b");
expectTypesMatch("missing props b");
expectTypesMatch(true);
expectTypesMatch("mismatched prop types: a");
var expectStringUnionsMatch = (shouldBe) => {
};
expectStringUnionsMatch(true);
expectStringUnionsMatch(
  'T1 has extra: "c", T2 has extra: "d"'
);
expectStringUnionsMatch('T1 has extra: "c"');
expectStringUnionsMatch('T2 has extra: "c"');
expectStringUnionsMatch(
  'T1 has extra: "d", T2 has extra: "c"'
);
expectStringUnionsMatch(true);

// src/common/point.ts
var point = z2.object({
  x: distance,
  y: distance
});
var position = point;
expectTypesMatch(true);
expectTypesMatch(true);

// src/common/point3.ts
import { z as z3 } from "zod";
var point3 = z3.object({
  x: distance,
  y: distance,
  z: distance
});
var position3 = point3;
expectTypesMatch(true);

// src/common/size.ts
import { z as z4 } from "zod";
var size = z4.object({
  width: z4.number(),
  height: z4.number()
});
expectTypesMatch(true);

// src/common/getZodPrefixedIdWithDefault.ts
import { z as z5 } from "zod";
import { nanoid } from "nanoid";
var getZodPrefixedIdWithDefault = (prefix) => {
  return z5.string().optional().default(() => `${prefix}_${nanoid(10)}`);
};

// src/common/NinePointAnchor.ts
import { z as z6 } from "zod";
var ninePointAnchor = z6.enum([
  "top_left",
  "top_center",
  "top_right",
  "center_left",
  "center",
  "center_right",
  "bottom_left",
  "bottom_center",
  "bottom_right"
]);
expectTypesMatch(true);

// src/source/source_simple_capacitor.ts
import { z as z9 } from "zod";

// src/pcb/properties/supplier_name.ts
import { z as z7 } from "zod";
var supplier_name = z7.enum([
  "jlcpcb",
  "macrofab",
  "pcbway",
  "digikey",
  "mouser",
  "lcsc"
]);
expectTypesMatch(true);

// src/source/base/source_component_base.ts
import { z as z8 } from "zod";
var source_component_base = z8.object({
  type: z8.literal("source_component"),
  ftype: z8.string().optional(),
  source_component_id: z8.string(),
  name: z8.string(),
  manufacturer_part_number: z8.string().optional(),
  supplier_part_numbers: z8.record(supplier_name, z8.array(z8.string())).optional(),
  display_value: z8.string().optional(),
  are_pins_interchangeable: z8.boolean().optional(),
  internally_connected_source_port_ids: z8.array(z8.array(z8.string())).optional(),
  source_group_id: z8.string().optional(),
  subcircuit_id: z8.string().optional()
});
expectTypesMatch(true);

// src/source/source_simple_capacitor.ts
var source_simple_capacitor = source_component_base.extend({
  ftype: z9.literal("simple_capacitor"),
  capacitance,
  max_voltage_rating: voltage.optional(),
  display_capacitance: z9.string().optional(),
  max_decoupling_trace_length: distance.optional()
});
expectTypesMatch(true);

// src/source/source_simple_resistor.ts
import { z as z10 } from "zod";
var source_simple_resistor = source_component_base.extend({
  ftype: z10.literal("simple_resistor"),
  resistance,
  display_resistance: z10.string().optional()
});
expectTypesMatch(true);

// src/source/source_simple_diode.ts
import { z as z11 } from "zod";
var source_simple_diode = source_component_base.extend({
  ftype: z11.literal("simple_diode")
});
expectTypesMatch(true);

// src/source/source_simple_led.ts
import { z as z12 } from "zod";
var source_simple_led = source_simple_diode.extend({
  ftype: z12.literal("simple_led"),
  color: z12.string().optional(),
  wavelength: z12.string().optional()
});
expectTypesMatch(true);

// src/source/source_simple_ground.ts
import { z as z13 } from "zod";
var source_simple_ground = source_component_base.extend({
  ftype: z13.literal("simple_ground")
});
expectTypesMatch(true);

// src/source/source_simple_chip.ts
import { z as z14 } from "zod";
var source_simple_chip = source_component_base.extend({
  ftype: z14.literal("simple_chip")
});
expectTypesMatch(true);

// src/source/source_simple_power_source.ts
import { z as z15 } from "zod";
var source_simple_power_source = source_component_base.extend({
  ftype: z15.literal("simple_power_source"),
  voltage
});
expectTypesMatch(true);

// src/source/any_source_component.ts
import { z as z31 } from "zod";

// src/source/source_simple_fuse.ts
import { z as z16 } from "zod";
var source_simple_fuse = source_component_base.extend({
  ftype: z16.literal("simple_fuse"),
  current_rating_amps: z16.number().describe("Nominal current in amps the fuse is rated for"),
  voltage_rating_volts: z16.number().describe("Voltage rating in volts, e.g. \xB15V would be 5")
});
expectTypesMatch(true);

// src/source/source_simple_battery.ts
import { z as z17 } from "zod";
var source_simple_battery = source_component_base.extend({
  ftype: z17.literal("simple_battery"),
  capacity: battery_capacity
});
expectTypesMatch(true);

// src/source/source_simple_inductor.ts
import { z as z18 } from "zod";
var source_simple_inductor = source_component_base.extend({
  ftype: z18.literal("simple_inductor"),
  inductance,
  max_current_rating: z18.number().optional()
});
expectTypesMatch(true);

// src/source/source_simple_push_button.ts
import { z as z19 } from "zod";
var source_simple_push_button = source_component_base.extend({
  ftype: z19.literal("simple_push_button")
});
expectTypesMatch(true);

// src/source/source_simple_potentiometer.ts
import { z as z20 } from "zod";
var source_simple_potentiometer = source_component_base.extend({
  ftype: z20.literal("simple_potentiometer"),
  max_resistance: resistance
});
expectTypesMatch(
  true
);

// src/source/source_simple_crystal.ts
import { z as z21 } from "zod";
var source_simple_crystal = source_component_base.extend({
  ftype: z21.literal("simple_crystal"),
  frequency: z21.number().describe("Frequency in Hz"),
  load_capacitance: z21.number().optional().describe("Load capacitance in pF")
});
expectTypesMatch(true);

// src/source/source_simple_pin_header.ts
import { z as z22 } from "zod";
var source_simple_pin_header = source_component_base.extend({
  ftype: z22.literal("simple_pin_header"),
  pin_count: z22.number(),
  gender: z22.enum(["male", "female"]).optional().default("male")
});
expectTypesMatch(true);

// src/source/source_simple_resonator.ts
import { z as z23 } from "zod";
var source_simple_resonator = source_component_base.extend({
  ftype: z23.literal("simple_resonator"),
  load_capacitance: capacitance,
  equivalent_series_resistance: resistance.optional(),
  frequency
});
expectTypesMatch(true);

// src/source/source_simple_transistor.ts
import { z as z24 } from "zod";
var source_simple_transistor = source_component_base.extend({
  ftype: z24.literal("simple_transistor"),
  transistor_type: z24.enum(["npn", "pnp"])
});
expectTypesMatch(true);

// src/source/source_simple_test_point.ts
import { z as z25 } from "zod";
var source_simple_test_point = source_component_base.extend({
  ftype: z25.literal("simple_test_point"),
  footprint_variant: z25.enum(["pad", "through_hole"]).optional(),
  pad_shape: z25.enum(["rect", "circle"]).optional(),
  pad_diameter: z25.union([z25.number(), z25.string()]).optional(),
  hole_diameter: z25.union([z25.number(), z25.string()]).optional(),
  width: z25.union([z25.number(), z25.string()]).optional(),
  height: z25.union([z25.number(), z25.string()]).optional()
});
expectTypesMatch(true);

// src/source/source_simple_mosfet.ts
import { z as z26 } from "zod";
var source_simple_mosfet = source_component_base.extend({
  ftype: z26.literal("simple_mosfet"),
  channel_type: z26.enum(["n", "p"]),
  mosfet_mode: z26.enum(["enhancement", "depletion"])
});
expectTypesMatch(true);

// src/source/source_simple_switch.ts
import { z as z27 } from "zod";
var source_simple_switch = source_component_base.extend({
  ftype: z27.literal("simple_switch")
});
expectTypesMatch(true);

// src/source/source_project_metadata.ts
import { z as z28 } from "zod";
var source_project_metadata = z28.object({
  type: z28.literal("source_project_metadata"),
  name: z28.string().optional(),
  software_used_string: z28.string().optional(),
  project_url: z28.string().optional(),
  created_at: z28.string().datetime().optional()
});
expectTypesMatch(true);

// src/source/source_missing_property_error.ts
import { z as z29 } from "zod";
var source_missing_property_error = z29.object({
  type: z29.literal("source_missing_property_error"),
  source_missing_property_error_id: getZodPrefixedIdWithDefault(
    "source_missing_property_error"
  ),
  source_component_id: z29.string(),
  property_name: z29.string(),
  subcircuit_id: z29.string().optional(),
  error_type: z29.literal("source_missing_property_error").default("source_missing_property_error"),
  message: z29.string()
}).describe("The source code is missing a property");
expectTypesMatch(true);

// src/source/source_failed_to_create_component_error.ts
import { z as z30 } from "zod";
var source_failed_to_create_component_error = z30.object({
  type: z30.literal("source_failed_to_create_component_error"),
  source_failed_to_create_component_error_id: getZodPrefixedIdWithDefault(
    "source_failed_to_create_component_error"
  ),
  error_type: z30.literal("source_failed_to_create_component_error").default("source_failed_to_create_component_error"),
  component_name: z30.string().optional(),
  subcircuit_id: z30.string().optional(),
  parent_source_component_id: z30.string().optional(),
  message: z30.string(),
  pcb_center: z30.object({
    x: z30.number().optional(),
    y: z30.number().optional()
  }).optional(),
  schematic_center: z30.object({
    x: z30.number().optional(),
    y: z30.number().optional()
  }).optional()
}).describe("Error emitted when a component fails to be constructed");
expectTypesMatch(true);

// src/source/any_source_component.ts
var any_source_component = z31.union([
  source_simple_resistor,
  source_simple_capacitor,
  source_simple_diode,
  source_simple_led,
  source_simple_ground,
  source_simple_chip,
  source_simple_power_source,
  source_simple_battery,
  source_simple_inductor,
  source_simple_push_button,
  source_simple_potentiometer,
  source_simple_crystal,
  source_simple_pin_header,
  source_simple_resonator,
  source_simple_switch,
  source_simple_transistor,
  source_simple_test_point,
  source_simple_mosfet,
  source_simple_fuse,
  source_project_metadata,
  source_missing_property_error,
  source_failed_to_create_component_error
]);
expectTypesMatch(true);

// src/source/source_port.ts
import { z as z32 } from "zod";
var source_port = z32.object({
  type: z32.literal("source_port"),
  pin_number: z32.number().optional(),
  port_hints: z32.array(z32.string()).optional(),
  name: z32.string(),
  source_port_id: z32.string(),
  source_component_id: z32.string(),
  subcircuit_id: z32.string().optional(),
  subcircuit_connectivity_map_key: z32.string().optional()
});
expectTypesMatch(true);

// src/source/source_trace.ts
import { z as z33 } from "zod";
var source_trace = z33.object({
  type: z33.literal("source_trace"),
  source_trace_id: z33.string(),
  connected_source_port_ids: z33.array(z33.string()),
  connected_source_net_ids: z33.array(z33.string()),
  subcircuit_id: z33.string().optional(),
  subcircuit_connectivity_map_key: z33.string().optional(),
  max_length: z33.number().optional(),
  min_trace_thickness: z33.number().optional(),
  display_name: z33.string().optional()
});
expectTypesMatch(true);

// src/source/source_group.ts
import { z as z34 } from "zod";
var source_group = z34.object({
  type: z34.literal("source_group"),
  source_group_id: z34.string(),
  subcircuit_id: z34.string().optional(),
  parent_subcircuit_id: z34.string().optional(),
  parent_source_group_id: z34.string().optional(),
  is_subcircuit: z34.boolean().optional(),
  name: z34.string().optional()
});
expectTypesMatch(true);

// src/source/source_net.ts
import { z as z35 } from "zod";
var source_net = z35.object({
  type: z35.literal("source_net"),
  source_net_id: z35.string(),
  name: z35.string(),
  member_source_group_ids: z35.array(z35.string()),
  is_power: z35.boolean().optional(),
  is_ground: z35.boolean().optional(),
  is_digital_signal: z35.boolean().optional(),
  is_analog_signal: z35.boolean().optional(),
  trace_width: z35.number().optional(),
  subcircuit_id: z35.string().optional(),
  subcircuit_connectivity_map_key: z35.string().optional()
});
expectTypesMatch(true);

// src/source/source_pcb_ground_plane.ts
import { z as z36 } from "zod";
var source_pcb_ground_plane = z36.object({
  type: z36.literal("source_pcb_ground_plane"),
  source_pcb_ground_plane_id: z36.string(),
  source_group_id: z36.string(),
  source_net_id: z36.string(),
  subcircuit_id: z36.string().optional()
}).describe("Defines a ground plane in the source domain");
expectTypesMatch(true);

// src/schematic/schematic_box.ts
import { z as z37 } from "zod";
var schematic_box = z37.object({
  type: z37.literal("schematic_box"),
  schematic_component_id: z37.string().optional(),
  width: distance,
  height: distance,
  is_dashed: z37.boolean().default(false),
  x: distance,
  y: distance,
  subcircuit_id: z37.string().optional()
}).describe("Draws a box on the schematic");
expectTypesMatch(true);

// src/schematic/schematic_path.ts
import { z as z38 } from "zod";
var schematic_path = z38.object({
  type: z38.literal("schematic_path"),
  schematic_component_id: z38.string(),
  fill_color: z38.enum(["red", "blue"]).optional(),
  is_filled: z38.boolean().optional(),
  points: z38.array(point),
  subcircuit_id: z38.string().optional()
});
expectTypesMatch(true);

// src/schematic/schematic_component.ts
import { z as z39 } from "zod";
var schematic_pin_styles = z39.record(
  z39.object({
    left_margin: length.optional(),
    right_margin: length.optional(),
    top_margin: length.optional(),
    bottom_margin: length.optional()
  })
);
var schematic_component_port_arrangement_by_size = z39.object({
  left_size: z39.number(),
  right_size: z39.number(),
  top_size: z39.number().optional(),
  bottom_size: z39.number().optional()
});
expectTypesMatch(true);
var schematic_component_port_arrangement_by_sides = z39.object({
  left_side: z39.object({
    pins: z39.array(z39.number()),
    // @ts-ignore
    direction: z39.enum(["top-to-bottom", "bottom-to-top"]).optional()
  }).optional(),
  right_side: z39.object({
    pins: z39.array(z39.number()),
    // @ts-ignore
    direction: z39.enum(["top-to-bottom", "bottom-to-top"]).optional()
  }).optional(),
  top_side: z39.object({
    pins: z39.array(z39.number()),
    // @ts-ignore
    direction: z39.enum(["left-to-right", "right-to-left"]).optional()
  }).optional(),
  bottom_side: z39.object({
    pins: z39.array(z39.number()),
    // @ts-ignore
    direction: z39.enum(["left-to-right", "right-to-left"]).optional()
  }).optional()
});
expectTypesMatch(true);
var port_arrangement = z39.union([
  schematic_component_port_arrangement_by_size,
  schematic_component_port_arrangement_by_sides
]);
var schematic_component = z39.object({
  type: z39.literal("schematic_component"),
  size,
  center: point,
  source_component_id: z39.string(),
  schematic_component_id: z39.string(),
  pin_spacing: length.optional(),
  pin_styles: schematic_pin_styles.optional(),
  box_width: length.optional(),
  symbol_name: z39.string().optional(),
  port_arrangement: port_arrangement.optional(),
  port_labels: z39.record(z39.string()).optional(),
  symbol_display_value: z39.string().optional(),
  subcircuit_id: z39.string().optional(),
  schematic_group_id: z39.string().optional()
});
expectTypesMatch(true);

// src/schematic/schematic_line.ts
import { z as z40 } from "zod";
var schematic_line = z40.object({
  type: z40.literal("schematic_line"),
  schematic_component_id: z40.string(),
  x1: distance,
  x2: distance,
  y1: distance,
  y2: distance,
  subcircuit_id: z40.string().optional()
});
expectTypesMatch(true);

// src/schematic/schematic_trace.ts
import { z as z41 } from "zod";
var schematic_trace = z41.object({
  type: z41.literal("schematic_trace"),
  schematic_trace_id: z41.string(),
  source_trace_id: z41.string(),
  junctions: z41.array(
    z41.object({
      x: z41.number(),
      y: z41.number()
    })
  ),
  edges: z41.array(
    z41.object({
      from: z41.object({
        x: z41.number(),
        y: z41.number()
      }),
      to: z41.object({
        x: z41.number(),
        y: z41.number()
      }),
      is_crossing: z41.boolean().optional(),
      from_schematic_port_id: z41.string().optional(),
      to_schematic_port_id: z41.string().optional()
    })
  ),
  subcircuit_id: z41.string().optional()
});
expectTypesMatch(true);

// src/schematic/schematic_text.ts
import { z as z43 } from "zod";

// src/common/FivePointAnchor.ts
import { z as z42 } from "zod";
var fivePointAnchor = z42.enum([
  "center",
  "left",
  "right",
  "top",
  "bottom"
]);
expectTypesMatch(true);

// src/schematic/schematic_text.ts
var schematic_text = z43.object({
  type: z43.literal("schematic_text"),
  schematic_component_id: z43.string().optional(),
  schematic_text_id: z43.string(),
  text: z43.string(),
  font_size: z43.number().default(0.18),
  position: z43.object({
    x: distance,
    y: distance
  }),
  rotation: z43.number().default(0),
  anchor: z43.union([fivePointAnchor.describe("legacy"), ninePointAnchor]).default("center"),
  color: z43.string().default("#000000"),
  subcircuit_id: z43.string().optional()
});
expectTypesMatch(true);

// src/schematic/schematic_port.ts
import { z as z44 } from "zod";
var schematic_port = z44.object({
  type: z44.literal("schematic_port"),
  schematic_port_id: z44.string(),
  source_port_id: z44.string(),
  schematic_component_id: z44.string().optional(),
  center: point,
  facing_direction: z44.enum(["up", "down", "left", "right"]).optional(),
  distance_from_component_edge: z44.number().optional(),
  side_of_component: z44.enum(["top", "bottom", "left", "right"]).optional(),
  true_ccw_index: z44.number().optional(),
  pin_number: z44.number().optional(),
  display_pin_label: z44.string().optional(),
  subcircuit_id: z44.string().optional(),
  is_connected: z44.boolean().optional()
}).describe("Defines a port on a schematic component");
expectTypesMatch(true);

// src/schematic/schematic_net_label.ts
import { z as z45 } from "zod";
var schematic_net_label = z45.object({
  type: z45.literal("schematic_net_label"),
  schematic_net_label_id: getZodPrefixedIdWithDefault("schematic_net_label"),
  schematic_trace_id: z45.string().optional(),
  source_trace_id: z45.string().optional(),
  source_net_id: z45.string(),
  center: point,
  anchor_position: point.optional(),
  anchor_side: z45.enum(["top", "bottom", "left", "right"]),
  text: z45.string(),
  symbol_name: z45.string().optional(),
  is_movable: z45.boolean().optional(),
  subcircuit_id: z45.string().optional()
});
expectTypesMatch(true);

// src/schematic/schematic_error.ts
import { z as z46 } from "zod";
var schematic_error = z46.object({
  type: z46.literal("schematic_error"),
  schematic_error_id: z46.string(),
  // eventually each error type should be broken out into a dir of files
  error_type: z46.literal("schematic_port_not_found").default("schematic_port_not_found"),
  message: z46.string(),
  subcircuit_id: z46.string().optional()
}).describe("Defines a schematic error on the schematic");
expectTypesMatch(true);

// src/schematic/schematic_layout_error.ts
import { z as z47 } from "zod";
var schematic_layout_error = z47.object({
  type: z47.literal("schematic_layout_error"),
  schematic_layout_error_id: getZodPrefixedIdWithDefault(
    "schematic_layout_error"
  ),
  error_type: z47.literal("schematic_layout_error").default("schematic_layout_error"),
  message: z47.string(),
  source_group_id: z47.string(),
  schematic_group_id: z47.string(),
  subcircuit_id: z47.string().optional()
}).describe("Error emitted when schematic layout fails for a group");
expectTypesMatch(true);

// src/schematic/schematic_debug_object.ts
import { z as z48 } from "zod";
var schematic_debug_object_base = z48.object({
  type: z48.literal("schematic_debug_object"),
  label: z48.string().optional(),
  subcircuit_id: z48.string().optional()
});
var schematic_debug_rect = schematic_debug_object_base.extend({
  shape: z48.literal("rect"),
  center: point,
  size
});
var schematic_debug_line = schematic_debug_object_base.extend({
  shape: z48.literal("line"),
  start: point,
  end: point
});
var schematic_debug_point = schematic_debug_object_base.extend({
  shape: z48.literal("point"),
  center: point
});
var schematic_debug_object = z48.discriminatedUnion("shape", [
  schematic_debug_rect,
  schematic_debug_line,
  schematic_debug_point
]);
expectTypesMatch(true);

// src/schematic/schematic_voltage_probe.ts
import { z as z49 } from "zod";
var schematic_voltage_probe = z49.object({
  type: z49.literal("schematic_voltage_probe"),
  schematic_voltage_probe_id: z49.string(),
  position: point,
  schematic_trace_id: z49.string(),
  voltage: voltage.optional(),
  subcircuit_id: z49.string().optional()
}).describe("Defines a voltage probe measurement point on a schematic trace");
expectTypesMatch(true);

// src/schematic/schematic_manual_edit_conflict_warning.ts
import { z as z50 } from "zod";
var schematic_manual_edit_conflict_warning = z50.object({
  type: z50.literal("schematic_manual_edit_conflict_warning"),
  schematic_manual_edit_conflict_warning_id: getZodPrefixedIdWithDefault(
    "schematic_manual_edit_conflict_warning"
  ),
  warning_type: z50.literal("schematic_manual_edit_conflict_warning").default("schematic_manual_edit_conflict_warning"),
  message: z50.string(),
  schematic_component_id: z50.string(),
  schematic_group_id: z50.string().optional(),
  subcircuit_id: z50.string().optional(),
  source_component_id: z50.string()
}).describe(
  "Warning emitted when a component has both manual placement and explicit schX/schY coordinates"
);
expectTypesMatch(true);

// src/schematic/schematic_group.ts
import { z as z51 } from "zod";
var schematic_group = z51.object({
  type: z51.literal("schematic_group"),
  schematic_group_id: getZodPrefixedIdWithDefault("schematic_group"),
  source_group_id: z51.string(),
  is_subcircuit: z51.boolean().optional(),
  subcircuit_id: z51.string().optional(),
  width: length,
  height: length,
  center: point,
  schematic_component_ids: z51.array(z51.string()),
  name: z51.string().optional(),
  description: z51.string().optional()
}).describe("Defines a group of components on the schematic");
expectTypesMatch(true);

// src/schematic/schematic_table.ts
import { z as z52 } from "zod";
var schematic_table = z52.object({
  type: z52.literal("schematic_table"),
  schematic_table_id: getZodPrefixedIdWithDefault("schematic_table"),
  anchor_position: point,
  column_widths: z52.array(distance),
  row_heights: z52.array(distance),
  cell_padding: distance.optional(),
  border_width: distance.optional(),
  subcircuit_id: z52.string().optional(),
  schematic_component_id: z52.string().optional(),
  anchor: ninePointAnchor.optional()
}).describe("Defines a table on the schematic");
expectTypesMatch(true);

// src/schematic/schematic_table_cell.ts
import { z as z53 } from "zod";
var schematic_table_cell = z53.object({
  type: z53.literal("schematic_table_cell"),
  schematic_table_cell_id: getZodPrefixedIdWithDefault(
    "schematic_table_cell"
  ),
  schematic_table_id: z53.string(),
  start_row_index: z53.number(),
  end_row_index: z53.number(),
  start_column_index: z53.number(),
  end_column_index: z53.number(),
  text: z53.string().optional(),
  center: point,
  width: distance,
  height: distance,
  horizontal_align: z53.enum(["left", "center", "right"]).optional(),
  vertical_align: z53.enum(["top", "middle", "bottom"]).optional(),
  font_size: distance.optional(),
  subcircuit_id: z53.string().optional()
}).describe("Defines a cell within a schematic_table");
expectTypesMatch(true);

// src/pcb/properties/layer_ref.ts
import { z as z54 } from "zod";
var all_layers = [
  "top",
  "bottom",
  "inner1",
  "inner2",
  "inner3",
  "inner4",
  "inner5",
  "inner6"
];
var layer_string = z54.enum(all_layers);
var layer_ref = layer_string.or(
  z54.object({
    name: layer_string
  })
).transform((layer) => {
  if (typeof layer === "string") {
    return layer;
  }
  return layer.name;
});
expectTypesMatch(true);
var visible_layer = z54.enum(["top", "bottom"]);

// src/pcb/properties/pcb_route_hints.ts
import { z as z55 } from "zod";
var pcb_route_hint = z55.object({
  x: distance,
  y: distance,
  via: z55.boolean().optional(),
  via_to_layer: layer_ref.optional()
});
var pcb_route_hints = z55.array(pcb_route_hint);
expectTypesMatch(true);
expectTypesMatch(true);

// src/pcb/properties/route_hint_point.ts
import { z as z56 } from "zod";
var route_hint_point = z56.object({
  x: distance,
  y: distance,
  via: z56.boolean().optional(),
  to_layer: layer_ref.optional(),
  trace_width: distance.optional()
});
expectTypesMatch(true);

// src/pcb/pcb_component.ts
import { z as z57 } from "zod";
var pcb_component = z57.object({
  type: z57.literal("pcb_component"),
  pcb_component_id: getZodPrefixedIdWithDefault("pcb_component"),
  source_component_id: z57.string(),
  center: point,
  layer: layer_ref,
  rotation,
  width: length,
  height: length,
  subcircuit_id: z57.string().optional(),
  pcb_group_id: z57.string().optional()
}).describe("Defines a component on the PCB");
expectTypesMatch(true);

// src/pcb/pcb_hole.ts
import { z as z58 } from "zod";
var pcb_hole_circle_or_square = z58.object({
  type: z58.literal("pcb_hole"),
  pcb_hole_id: getZodPrefixedIdWithDefault("pcb_hole"),
  pcb_group_id: z58.string().optional(),
  subcircuit_id: z58.string().optional(),
  hole_shape: z58.enum(["circle", "square"]),
  hole_diameter: z58.number(),
  x: distance,
  y: distance
});
var pcb_hole_circle_or_square_shape = pcb_hole_circle_or_square.describe(
  "Defines a circular or square hole on the PCB"
);
expectTypesMatch(true);
var pcb_hole_oval = z58.object({
  type: z58.literal("pcb_hole"),
  pcb_hole_id: getZodPrefixedIdWithDefault("pcb_hole"),
  pcb_group_id: z58.string().optional(),
  subcircuit_id: z58.string().optional(),
  hole_shape: z58.literal("oval"),
  hole_width: z58.number(),
  hole_height: z58.number(),
  x: distance,
  y: distance
});
var pcb_hole_oval_shape = pcb_hole_oval.describe(
  "Defines an oval hole on the PCB"
);
expectTypesMatch(true);
var pcb_hole = pcb_hole_circle_or_square.or(pcb_hole_oval);

// src/pcb/pcb_plated_hole.ts
import { z as z59 } from "zod";
var pcb_plated_hole_circle = z59.object({
  type: z59.literal("pcb_plated_hole"),
  shape: z59.literal("circle"),
  pcb_group_id: z59.string().optional(),
  subcircuit_id: z59.string().optional(),
  outer_diameter: z59.number(),
  hole_diameter: z59.number(),
  x: distance,
  y: distance,
  layers: z59.array(layer_ref),
  port_hints: z59.array(z59.string()).optional(),
  pcb_component_id: z59.string().optional(),
  pcb_port_id: z59.string().optional(),
  pcb_plated_hole_id: getZodPrefixedIdWithDefault("pcb_plated_hole")
});
var pcb_plated_hole_oval = z59.object({
  type: z59.literal("pcb_plated_hole"),
  shape: z59.enum(["oval", "pill"]),
  pcb_group_id: z59.string().optional(),
  subcircuit_id: z59.string().optional(),
  outer_width: z59.number(),
  outer_height: z59.number(),
  hole_width: z59.number(),
  hole_height: z59.number(),
  x: distance,
  y: distance,
  layers: z59.array(layer_ref),
  port_hints: z59.array(z59.string()).optional(),
  pcb_component_id: z59.string().optional(),
  pcb_port_id: z59.string().optional(),
  pcb_plated_hole_id: getZodPrefixedIdWithDefault("pcb_plated_hole")
});
var pcb_circular_hole_with_rect_pad = z59.object({
  type: z59.literal("pcb_plated_hole"),
  shape: z59.literal("circular_hole_with_rect_pad"),
  pcb_group_id: z59.string().optional(),
  subcircuit_id: z59.string().optional(),
  hole_shape: z59.literal("circle"),
  pad_shape: z59.literal("rect"),
  hole_diameter: z59.number(),
  rect_pad_width: z59.number(),
  rect_pad_height: z59.number(),
  x: distance,
  y: distance,
  layers: z59.array(layer_ref),
  port_hints: z59.array(z59.string()).optional(),
  pcb_component_id: z59.string().optional(),
  pcb_port_id: z59.string().optional(),
  pcb_plated_hole_id: getZodPrefixedIdWithDefault("pcb_plated_hole")
});
var pcb_pill_hole_with_rect_pad = z59.object({
  type: z59.literal("pcb_plated_hole"),
  shape: z59.literal("pill_hole_with_rect_pad"),
  pcb_group_id: z59.string().optional(),
  subcircuit_id: z59.string().optional(),
  hole_shape: z59.literal("pill"),
  pad_shape: z59.literal("rect"),
  hole_width: z59.number(),
  hole_height: z59.number(),
  rect_pad_width: z59.number(),
  rect_pad_height: z59.number(),
  x: distance,
  y: distance,
  layers: z59.array(layer_ref),
  port_hints: z59.array(z59.string()).optional(),
  pcb_component_id: z59.string().optional(),
  pcb_port_id: z59.string().optional(),
  pcb_plated_hole_id: getZodPrefixedIdWithDefault("pcb_plated_hole")
});
var pcb_plated_hole = z59.union([
  pcb_plated_hole_circle,
  pcb_plated_hole_oval,
  pcb_circular_hole_with_rect_pad,
  pcb_pill_hole_with_rect_pad
]);
expectTypesMatch(
  true
);
expectTypesMatch(true);
expectTypesMatch(true);
expectTypesMatch(true);

// src/pcb/pcb_port.ts
import { z as z60 } from "zod";
var pcb_port = z60.object({
  type: z60.literal("pcb_port"),
  pcb_port_id: getZodPrefixedIdWithDefault("pcb_port"),
  pcb_group_id: z60.string().optional(),
  subcircuit_id: z60.string().optional(),
  source_port_id: z60.string(),
  pcb_component_id: z60.string(),
  x: distance,
  y: distance,
  layers: z60.array(layer_ref)
}).describe("Defines a port on the PCB");
expectTypesMatch(true);

// src/pcb/pcb_smtpad.ts
import { z as z61 } from "zod";
var pcb_smtpad_circle = z61.object({
  type: z61.literal("pcb_smtpad"),
  shape: z61.literal("circle"),
  pcb_smtpad_id: getZodPrefixedIdWithDefault("pcb_smtpad"),
  pcb_group_id: z61.string().optional(),
  subcircuit_id: z61.string().optional(),
  x: distance,
  y: distance,
  radius: z61.number(),
  layer: layer_ref,
  port_hints: z61.array(z61.string()).optional(),
  pcb_component_id: z61.string().optional(),
  pcb_port_id: z61.string().optional()
});
var pcb_smtpad_rect = z61.object({
  type: z61.literal("pcb_smtpad"),
  shape: z61.literal("rect"),
  pcb_smtpad_id: getZodPrefixedIdWithDefault("pcb_smtpad"),
  pcb_group_id: z61.string().optional(),
  subcircuit_id: z61.string().optional(),
  x: distance,
  y: distance,
  width: z61.number(),
  height: z61.number(),
  layer: layer_ref,
  port_hints: z61.array(z61.string()).optional(),
  pcb_component_id: z61.string().optional(),
  pcb_port_id: z61.string().optional()
});
var pcb_smtpad_rotated_rect = z61.object({
  type: z61.literal("pcb_smtpad"),
  shape: z61.literal("rotated_rect"),
  pcb_smtpad_id: getZodPrefixedIdWithDefault("pcb_smtpad"),
  pcb_group_id: z61.string().optional(),
  subcircuit_id: z61.string().optional(),
  x: distance,
  y: distance,
  width: z61.number(),
  height: z61.number(),
  ccw_rotation: rotation,
  layer: layer_ref,
  port_hints: z61.array(z61.string()).optional(),
  pcb_component_id: z61.string().optional(),
  pcb_port_id: z61.string().optional()
});
var pcb_smtpad_pill = z61.object({
  type: z61.literal("pcb_smtpad"),
  shape: z61.literal("pill"),
  pcb_smtpad_id: getZodPrefixedIdWithDefault("pcb_smtpad"),
  pcb_group_id: z61.string().optional(),
  subcircuit_id: z61.string().optional(),
  x: distance,
  y: distance,
  width: z61.number(),
  height: z61.number(),
  radius: z61.number(),
  layer: layer_ref,
  port_hints: z61.array(z61.string()).optional(),
  pcb_component_id: z61.string().optional(),
  pcb_port_id: z61.string().optional()
});
var pcb_smtpad_polygon = z61.object({
  type: z61.literal("pcb_smtpad"),
  shape: z61.literal("polygon"),
  pcb_smtpad_id: getZodPrefixedIdWithDefault("pcb_smtpad"),
  pcb_group_id: z61.string().optional(),
  subcircuit_id: z61.string().optional(),
  points: z61.array(point),
  layer: layer_ref,
  port_hints: z61.array(z61.string()).optional(),
  pcb_component_id: z61.string().optional(),
  pcb_port_id: z61.string().optional()
});
var pcb_smtpad = z61.discriminatedUnion("shape", [
  pcb_smtpad_circle,
  pcb_smtpad_rect,
  pcb_smtpad_rotated_rect,
  pcb_smtpad_pill,
  pcb_smtpad_polygon
]).describe("Defines an SMT pad on the PCB");
expectTypesMatch(true);
expectTypesMatch(true);
expectTypesMatch(true);
expectTypesMatch(true);
expectTypesMatch(true);

// src/pcb/pcb_solder_paste.ts
import { z as z62 } from "zod";
var pcb_solder_paste_circle = z62.object({
  type: z62.literal("pcb_solder_paste"),
  shape: z62.literal("circle"),
  pcb_solder_paste_id: getZodPrefixedIdWithDefault("pcb_solder_paste"),
  pcb_group_id: z62.string().optional(),
  subcircuit_id: z62.string().optional(),
  x: distance,
  y: distance,
  radius: z62.number(),
  layer: layer_ref,
  pcb_component_id: z62.string().optional(),
  pcb_smtpad_id: z62.string().optional()
});
var pcb_solder_paste_rect = z62.object({
  type: z62.literal("pcb_solder_paste"),
  shape: z62.literal("rect"),
  pcb_solder_paste_id: getZodPrefixedIdWithDefault("pcb_solder_paste"),
  pcb_group_id: z62.string().optional(),
  subcircuit_id: z62.string().optional(),
  x: distance,
  y: distance,
  width: z62.number(),
  height: z62.number(),
  layer: layer_ref,
  pcb_component_id: z62.string().optional(),
  pcb_smtpad_id: z62.string().optional()
});
var pcb_solder_paste_pill = z62.object({
  type: z62.literal("pcb_solder_paste"),
  shape: z62.literal("pill"),
  pcb_solder_paste_id: getZodPrefixedIdWithDefault("pcb_solder_paste"),
  pcb_group_id: z62.string().optional(),
  subcircuit_id: z62.string().optional(),
  x: distance,
  y: distance,
  width: z62.number(),
  height: z62.number(),
  radius: z62.number(),
  layer: layer_ref,
  pcb_component_id: z62.string().optional(),
  pcb_smtpad_id: z62.string().optional()
});
var pcb_solder_paste_rotated_rect = z62.object({
  type: z62.literal("pcb_solder_paste"),
  shape: z62.literal("rotated_rect"),
  pcb_solder_paste_id: getZodPrefixedIdWithDefault("pcb_solder_paste"),
  pcb_group_id: z62.string().optional(),
  subcircuit_id: z62.string().optional(),
  x: distance,
  y: distance,
  width: z62.number(),
  height: z62.number(),
  ccw_rotation: distance,
  layer: layer_ref,
  pcb_component_id: z62.string().optional(),
  pcb_smtpad_id: z62.string().optional()
});
var pcb_solder_paste_oval = z62.object({
  type: z62.literal("pcb_solder_paste"),
  shape: z62.literal("oval"),
  pcb_solder_paste_id: getZodPrefixedIdWithDefault("pcb_solder_paste"),
  pcb_group_id: z62.string().optional(),
  subcircuit_id: z62.string().optional(),
  x: distance,
  y: distance,
  width: z62.number(),
  height: z62.number(),
  layer: layer_ref,
  pcb_component_id: z62.string().optional(),
  pcb_smtpad_id: z62.string().optional()
});
var pcb_solder_paste = z62.union([
  pcb_solder_paste_circle,
  pcb_solder_paste_rect,
  pcb_solder_paste_pill,
  pcb_solder_paste_rotated_rect,
  pcb_solder_paste_oval
]).describe("Defines solderpaste on the PCB");
expectTypesMatch(true);
expectTypesMatch(true);
expectTypesMatch(true);
expectTypesMatch(
  true
);
expectTypesMatch(true);

// src/pcb/pcb_text.ts
import { z as z63 } from "zod";
var pcb_text = z63.object({
  type: z63.literal("pcb_text"),
  pcb_text_id: getZodPrefixedIdWithDefault("pcb_text"),
  pcb_group_id: z63.string().optional(),
  subcircuit_id: z63.string().optional(),
  text: z63.string(),
  center: point,
  layer: layer_ref,
  width: length,
  height: length,
  lines: z63.number(),
  // @ts-ignore
  align: z63.enum(["bottom-left"])
}).describe("Defines text on the PCB");
expectTypesMatch(true);

// src/pcb/pcb_trace.ts
import { z as z64 } from "zod";
var pcb_trace_route_point_wire = z64.object({
  route_type: z64.literal("wire"),
  x: distance,
  y: distance,
  width: distance,
  start_pcb_port_id: z64.string().optional(),
  end_pcb_port_id: z64.string().optional(),
  layer: layer_ref
});
var pcb_trace_route_point_via = z64.object({
  route_type: z64.literal("via"),
  x: distance,
  y: distance,
  hole_diameter: distance.optional(),
  outer_diameter: distance.optional(),
  from_layer: z64.string(),
  to_layer: z64.string()
});
var pcb_trace_route_point = z64.union([
  pcb_trace_route_point_wire,
  pcb_trace_route_point_via
]);
var pcb_trace = z64.object({
  type: z64.literal("pcb_trace"),
  source_trace_id: z64.string().optional(),
  pcb_component_id: z64.string().optional(),
  pcb_trace_id: getZodPrefixedIdWithDefault("pcb_trace"),
  pcb_group_id: z64.string().optional(),
  subcircuit_id: z64.string().optional(),
  route_thickness_mode: z64.enum(["constant", "interpolated"]).default("constant").optional(),
  route_order_index: z64.number().optional(),
  should_round_corners: z64.boolean().optional(),
  trace_length: z64.number().optional(),
  route: z64.array(pcb_trace_route_point)
}).describe("Defines a trace on the PCB");
expectTypesMatch(true);
expectTypesMatch(true);

// src/pcb/pcb_trace_error.ts
import { z as z65 } from "zod";
var pcb_trace_error = z65.object({
  type: z65.literal("pcb_trace_error"),
  pcb_trace_error_id: getZodPrefixedIdWithDefault("pcb_trace_error"),
  error_type: z65.literal("pcb_trace_error").default("pcb_trace_error"),
  message: z65.string(),
  center: point.optional(),
  pcb_trace_id: z65.string(),
  source_trace_id: z65.string(),
  pcb_component_ids: z65.array(z65.string()),
  pcb_port_ids: z65.array(z65.string()),
  subcircuit_id: z65.string().optional()
}).describe("Defines a trace error on the PCB");
expectTypesMatch(true);

// src/pcb/pcb_port_not_matched_error.ts
import { z as z66 } from "zod";
var pcb_port_not_matched_error = z66.object({
  type: z66.literal("pcb_port_not_matched_error"),
  pcb_error_id: getZodPrefixedIdWithDefault("pcb_error"),
  error_type: z66.literal("pcb_port_not_matched_error").default("pcb_port_not_matched_error"),
  message: z66.string(),
  pcb_component_ids: z66.array(z66.string()),
  subcircuit_id: z66.string().optional()
}).describe("Defines a trace error on the PCB where a port is not matched");
expectTypesMatch(true);

// src/pcb/pcb_via.ts
import { z as z67 } from "zod";
var pcb_via = z67.object({
  type: z67.literal("pcb_via"),
  pcb_via_id: getZodPrefixedIdWithDefault("pcb_via"),
  pcb_group_id: z67.string().optional(),
  subcircuit_id: z67.string().optional(),
  x: distance,
  y: distance,
  outer_diameter: distance.default("0.6mm"),
  hole_diameter: distance.default("0.25mm"),
  /** @deprecated */
  from_layer: layer_ref.optional(),
  /** @deprecated */
  to_layer: layer_ref.optional(),
  layers: z67.array(layer_ref),
  pcb_trace_id: z67.string().optional()
}).describe("Defines a via on the PCB");
expectTypesMatch(true);

// src/pcb/pcb_board.ts
import { z as z68 } from "zod";
var pcb_board = z68.object({
  type: z68.literal("pcb_board"),
  pcb_board_id: getZodPrefixedIdWithDefault("pcb_board"),
  is_subcircuit: z68.boolean().optional(),
  subcircuit_id: z68.string().optional(),
  width: length,
  height: length,
  center: point,
  thickness: length.optional().default(1.4),
  num_layers: z68.number().optional().default(4),
  outline: z68.array(point).optional(),
  material: z68.enum(["fr4", "fr1"]).default("fr4")
}).describe("Defines the board outline of the PCB");
expectTypesMatch(true);

// src/pcb/pcb_placement_error.ts
import { z as z69 } from "zod";
var pcb_placement_error = z69.object({
  type: z69.literal("pcb_placement_error"),
  pcb_placement_error_id: getZodPrefixedIdWithDefault("pcb_placement_error"),
  error_type: z69.literal("pcb_placement_error").default("pcb_placement_error"),
  message: z69.string(),
  subcircuit_id: z69.string().optional()
}).describe("Defines a placement error on the PCB");
expectTypesMatch(true);

// src/pcb/pcb_trace_hint.ts
import { z as z70 } from "zod";
var pcb_trace_hint = z70.object({
  type: z70.literal("pcb_trace_hint"),
  pcb_trace_hint_id: getZodPrefixedIdWithDefault("pcb_trace_hint"),
  pcb_port_id: z70.string(),
  pcb_component_id: z70.string(),
  route: z70.array(route_hint_point),
  subcircuit_id: z70.string().optional()
}).describe("A hint that can be used during generation of a PCB trace");
expectTypesMatch(true);

// src/pcb/pcb_silkscreen_line.ts
import { z as z71 } from "zod";
var pcb_silkscreen_line = z71.object({
  type: z71.literal("pcb_silkscreen_line"),
  pcb_silkscreen_line_id: getZodPrefixedIdWithDefault("pcb_silkscreen_line"),
  pcb_component_id: z71.string(),
  pcb_group_id: z71.string().optional(),
  subcircuit_id: z71.string().optional(),
  stroke_width: distance.default("0.1mm"),
  x1: distance,
  y1: distance,
  x2: distance,
  y2: distance,
  layer: visible_layer
}).describe("Defines a silkscreen line on the PCB");
expectTypesMatch(true);

// src/pcb/pcb_silkscreen_path.ts
import { z as z72 } from "zod";
var pcb_silkscreen_path = z72.object({
  type: z72.literal("pcb_silkscreen_path"),
  pcb_silkscreen_path_id: getZodPrefixedIdWithDefault("pcb_silkscreen_path"),
  pcb_component_id: z72.string(),
  pcb_group_id: z72.string().optional(),
  subcircuit_id: z72.string().optional(),
  layer: visible_layer,
  route: z72.array(point),
  stroke_width: length
}).describe("Defines a silkscreen path on the PCB");
expectTypesMatch(true);

// src/pcb/pcb_silkscreen_text.ts
import { z as z73 } from "zod";
var pcb_silkscreen_text = z73.object({
  type: z73.literal("pcb_silkscreen_text"),
  pcb_silkscreen_text_id: getZodPrefixedIdWithDefault("pcb_silkscreen_text"),
  pcb_group_id: z73.string().optional(),
  subcircuit_id: z73.string().optional(),
  font: z73.literal("tscircuit2024").default("tscircuit2024"),
  font_size: distance.default("0.2mm"),
  pcb_component_id: z73.string(),
  text: z73.string(),
  ccw_rotation: z73.number().optional(),
  layer: layer_ref,
  is_mirrored: z73.boolean().default(false).optional(),
  anchor_position: point.default({ x: 0, y: 0 }),
  anchor_alignment: ninePointAnchor.default("center")
}).describe("Defines silkscreen text on the PCB");
expectTypesMatch(true);

// src/pcb/pcb_silkscreen_rect.ts
import { z as z74 } from "zod";
var pcb_silkscreen_rect = z74.object({
  type: z74.literal("pcb_silkscreen_rect"),
  pcb_silkscreen_rect_id: getZodPrefixedIdWithDefault("pcb_silkscreen_rect"),
  pcb_component_id: z74.string(),
  pcb_group_id: z74.string().optional(),
  subcircuit_id: z74.string().optional(),
  center: point,
  width: length,
  height: length,
  layer: layer_ref,
  stroke_width: length.default("1mm"),
  is_filled: z74.boolean().default(true).optional(),
  has_stroke: z74.boolean().optional(),
  is_stroke_dashed: z74.boolean().optional()
}).describe("Defines a silkscreen rect on the PCB");
expectTypesMatch(true);

// src/pcb/pcb_silkscreen_circle.ts
import { z as z75 } from "zod";
var pcb_silkscreen_circle = z75.object({
  type: z75.literal("pcb_silkscreen_circle"),
  pcb_silkscreen_circle_id: getZodPrefixedIdWithDefault(
    "pcb_silkscreen_circle"
  ),
  pcb_component_id: z75.string(),
  pcb_group_id: z75.string().optional(),
  subcircuit_id: z75.string().optional(),
  center: point,
  radius: length,
  layer: visible_layer,
  stroke_width: length.default("1mm")
}).describe("Defines a silkscreen circle on the PCB");
expectTypesMatch(true);

// src/pcb/pcb_silkscreen_oval.ts
import { z as z76 } from "zod";
var pcb_silkscreen_oval = z76.object({
  type: z76.literal("pcb_silkscreen_oval"),
  pcb_silkscreen_oval_id: getZodPrefixedIdWithDefault("pcb_silkscreen_oval"),
  pcb_component_id: z76.string(),
  pcb_group_id: z76.string().optional(),
  subcircuit_id: z76.string().optional(),
  center: point,
  radius_x: distance,
  radius_y: distance,
  layer: visible_layer
}).describe("Defines a silkscreen oval on the PCB");
expectTypesMatch(true);

// src/pcb/pcb_fabrication_note_text.ts
import { z as z77 } from "zod";
var pcb_fabrication_note_text = z77.object({
  type: z77.literal("pcb_fabrication_note_text"),
  pcb_fabrication_note_text_id: getZodPrefixedIdWithDefault(
    "pcb_fabrication_note_text"
  ),
  subcircuit_id: z77.string().optional(),
  pcb_group_id: z77.string().optional(),
  font: z77.literal("tscircuit2024").default("tscircuit2024"),
  font_size: distance.default("1mm"),
  pcb_component_id: z77.string(),
  text: z77.string(),
  layer: visible_layer,
  anchor_position: point.default({ x: 0, y: 0 }),
  anchor_alignment: z77.enum(["center", "top_left", "top_right", "bottom_left", "bottom_right"]).default("center"),
  color: z77.string().optional()
}).describe(
  "Defines a fabrication note in text on the PCB, useful for leaving notes for assemblers or fabricators"
);
expectTypesMatch(true);

// src/pcb/pcb_fabrication_note_path.ts
import { z as z78 } from "zod";
var pcb_fabrication_note_path = z78.object({
  type: z78.literal("pcb_fabrication_note_path"),
  pcb_fabrication_note_path_id: getZodPrefixedIdWithDefault(
    "pcb_fabrication_note_path"
  ),
  pcb_component_id: z78.string(),
  subcircuit_id: z78.string().optional(),
  layer: layer_ref,
  route: z78.array(point),
  stroke_width: length,
  color: z78.string().optional()
}).describe(
  "Defines a fabrication path on the PCB for fabricators or assemblers"
);
expectTypesMatch(true);

// src/pcb/pcb_footprint_overlap_error.ts
import { z as z79 } from "zod";
var pcb_footprint_overlap_error = z79.object({
  type: z79.literal("pcb_footprint_overlap_error"),
  pcb_error_id: getZodPrefixedIdWithDefault("pcb_error"),
  error_type: z79.literal("pcb_footprint_overlap_error").default("pcb_footprint_overlap_error"),
  message: z79.string(),
  pcb_smtpad_ids: z79.array(z79.string()).optional(),
  pcb_plated_hole_ids: z79.array(z79.string()).optional(),
  pcb_hole_ids: z79.array(z79.string()).optional(),
  pcb_keepout_ids: z79.array(z79.string()).optional()
}).describe("Error emitted when a pcb footprint overlaps with another element");
expectTypesMatch(
  true
);

// src/pcb/pcb_keepout.ts
import { z as z80 } from "zod";
var pcb_keepout = z80.object({
  type: z80.literal("pcb_keepout"),
  shape: z80.literal("rect"),
  pcb_group_id: z80.string().optional(),
  subcircuit_id: z80.string().optional(),
  center: point,
  width: distance,
  height: distance,
  pcb_keepout_id: z80.string(),
  layers: z80.array(z80.string()),
  // Specify layers where the keepout applies
  description: z80.string().optional()
  // Optional description of the keepout
}).or(
  z80.object({
    type: z80.literal("pcb_keepout"),
    shape: z80.literal("circle"),
    pcb_group_id: z80.string().optional(),
    subcircuit_id: z80.string().optional(),
    center: point,
    radius: distance,
    pcb_keepout_id: z80.string(),
    layers: z80.array(z80.string()),
    // Specify layers where the keepout applies
    description: z80.string().optional()
    // Optional description of the keepout
  })
);
expectTypesMatch(true);

// src/pcb/pcb_cutout.ts
import { z as z81 } from "zod";
var pcb_cutout_base = z81.object({
  type: z81.literal("pcb_cutout"),
  pcb_cutout_id: getZodPrefixedIdWithDefault("pcb_cutout"),
  pcb_group_id: z81.string().optional(),
  subcircuit_id: z81.string().optional()
});
var pcb_cutout_rect = pcb_cutout_base.extend({
  shape: z81.literal("rect"),
  center: point,
  width: length,
  height: length,
  rotation: rotation.optional()
});
expectTypesMatch(true);
var pcb_cutout_circle = pcb_cutout_base.extend({
  shape: z81.literal("circle"),
  center: point,
  radius: length
});
expectTypesMatch(true);
var pcb_cutout_polygon = pcb_cutout_base.extend({
  shape: z81.literal("polygon"),
  points: z81.array(point)
});
expectTypesMatch(true);
var pcb_cutout = z81.discriminatedUnion("shape", [
  pcb_cutout_rect,
  pcb_cutout_circle,
  pcb_cutout_polygon
]).describe("Defines a cutout on the PCB, removing board material.");
expectTypesMatch(true);

// src/pcb/pcb_missing_footprint_error.ts
import { z as z82 } from "zod";
var pcb_missing_footprint_error = z82.object({
  type: z82.literal("pcb_missing_footprint_error"),
  pcb_missing_footprint_error_id: getZodPrefixedIdWithDefault(
    "pcb_missing_footprint_error"
  ),
  pcb_group_id: z82.string().optional(),
  subcircuit_id: z82.string().optional(),
  error_type: z82.literal("pcb_missing_footprint_error").default("pcb_missing_footprint_error"),
  source_component_id: z82.string(),
  message: z82.string()
}).describe("Defines a missing footprint error on the PCB");
expectTypesMatch(
  true
);

// src/pcb/pcb_group.ts
import { z as z83 } from "zod";
var pcb_group = z83.object({
  type: z83.literal("pcb_group"),
  pcb_group_id: getZodPrefixedIdWithDefault("pcb_group"),
  source_group_id: z83.string(),
  is_subcircuit: z83.boolean().optional(),
  subcircuit_id: z83.string().optional(),
  width: length,
  height: length,
  center: point,
  pcb_component_ids: z83.array(z83.string()),
  name: z83.string().optional(),
  description: z83.string().optional(),
  autorouter_configuration: z83.object({
    trace_clearance: length
  }).optional(),
  autorouter_used_string: z83.string().optional()
}).describe("Defines a group of components on the PCB");
expectTypesMatch(true);

// src/pcb/pcb_autorouting_error.ts
import { z as z84 } from "zod";
var pcb_autorouting_error = z84.object({
  type: z84.literal("pcb_autorouting_error"),
  pcb_error_id: getZodPrefixedIdWithDefault("pcb_autorouting_error"),
  error_type: z84.literal("pcb_autorouting_error").default("pcb_autorouting_error"),
  message: z84.string(),
  subcircuit_id: z84.string().optional()
}).describe("The autorouting has failed to route a portion of the board");
expectTypesMatch(true);

// src/pcb/pcb_manual_edit_conflict_warning.ts
import { z as z85 } from "zod";
var pcb_manual_edit_conflict_warning = z85.object({
  type: z85.literal("pcb_manual_edit_conflict_warning"),
  pcb_manual_edit_conflict_warning_id: getZodPrefixedIdWithDefault(
    "pcb_manual_edit_conflict_warning"
  ),
  warning_type: z85.literal("pcb_manual_edit_conflict_warning").default("pcb_manual_edit_conflict_warning"),
  message: z85.string(),
  pcb_component_id: z85.string(),
  pcb_group_id: z85.string().optional(),
  subcircuit_id: z85.string().optional(),
  source_component_id: z85.string()
}).describe(
  "Warning emitted when a component has both manual placement and explicit pcbX/pcbY coordinates"
);
expectTypesMatch(true);

// src/pcb/pcb_breakout_point.ts
import { z as z86 } from "zod";
var pcb_breakout_point = z86.object({
  type: z86.literal("pcb_breakout_point"),
  pcb_breakout_point_id: getZodPrefixedIdWithDefault("pcb_breakout_point"),
  pcb_group_id: z86.string(),
  subcircuit_id: z86.string().optional(),
  source_trace_id: z86.string().optional(),
  source_port_id: z86.string().optional(),
  source_net_id: z86.string().optional(),
  x: distance,
  y: distance
}).describe(
  "Defines a routing target within a pcb_group for a source_trace or source_net"
);
expectTypesMatch(true);

// src/pcb/pcb_ground_plane.ts
import { z as z87 } from "zod";
var pcb_ground_plane = z87.object({
  type: z87.literal("pcb_ground_plane"),
  pcb_ground_plane_id: getZodPrefixedIdWithDefault("pcb_ground_plane"),
  source_pcb_ground_plane_id: z87.string(),
  source_net_id: z87.string(),
  pcb_group_id: z87.string().optional(),
  subcircuit_id: z87.string().optional()
}).describe("Defines a ground plane on the PCB");
expectTypesMatch(true);

// src/pcb/pcb_ground_plane_region.ts
import { z as z88 } from "zod";
var pcb_ground_plane_region = z88.object({
  type: z88.literal("pcb_ground_plane_region"),
  pcb_ground_plane_region_id: getZodPrefixedIdWithDefault(
    "pcb_ground_plane_region"
  ),
  pcb_ground_plane_id: z88.string(),
  pcb_group_id: z88.string().optional(),
  subcircuit_id: z88.string().optional(),
  layer: layer_ref,
  points: z88.array(point)
}).describe("Defines a polygon region of a ground plane");
expectTypesMatch(true);

// src/pcb/pcb_thermal_spoke.ts
import { z as z89 } from "zod";
var pcb_thermal_spoke = z89.object({
  type: z89.literal("pcb_thermal_spoke"),
  pcb_thermal_spoke_id: getZodPrefixedIdWithDefault("pcb_thermal_spoke"),
  pcb_ground_plane_id: z89.string(),
  shape: z89.string(),
  spoke_count: z89.number(),
  spoke_thickness: distance,
  spoke_inner_diameter: distance,
  spoke_outer_diameter: distance,
  pcb_plated_hole_id: z89.string().optional(),
  subcircuit_id: z89.string().optional()
}).describe("Pattern for connecting a ground plane to a plated hole");
expectTypesMatch(true);

// src/cad/cad_component.ts
import { z as z90 } from "zod";
var cad_component = z90.object({
  type: z90.literal("cad_component"),
  cad_component_id: z90.string(),
  pcb_component_id: z90.string(),
  source_component_id: z90.string(),
  position: point3,
  rotation: point3.optional(),
  size: point3.optional(),
  layer: layer_ref.optional(),
  subcircuit_id: z90.string().optional(),
  // These are all ways to generate/load the 3d model
  footprinter_string: z90.string().optional(),
  model_obj_url: z90.string().optional(),
  model_stl_url: z90.string().optional(),
  model_3mf_url: z90.string().optional(),
  model_jscad: z90.any().optional()
}).describe("Defines a component on the PCB");
expectTypesMatch(true);

// src/simulation/simulation_voltage_source.ts
import { z as z91 } from "zod";
var simulation_voltage_source = z91.object({
  type: z91.literal("simulation_voltage_source"),
  simulation_voltage_source_id: getZodPrefixedIdWithDefault(
    "simulation_voltage_source"
  ),
  positive_source_port_id: z91.string(),
  negative_source_port_id: z91.string(),
  voltage
}).describe("Defines a voltage source for simulation");
expectTypesMatch(true);

// src/any_circuit_element.ts
import { z as z92 } from "zod";
var any_circuit_element = z92.union([
  source_trace,
  source_port,
  any_source_component,
  source_net,
  source_group,
  source_simple_chip,
  source_simple_capacitor,
  source_simple_diode,
  source_simple_led,
  source_simple_resistor,
  source_simple_power_source,
  source_simple_battery,
  source_simple_inductor,
  source_simple_pin_header,
  source_simple_resonator,
  source_simple_switch,
  source_simple_transistor,
  source_simple_test_point,
  source_simple_mosfet,
  source_simple_potentiometer,
  source_simple_push_button,
  source_pcb_ground_plane,
  source_project_metadata,
  pcb_component,
  pcb_hole,
  pcb_missing_footprint_error,
  pcb_manual_edit_conflict_warning,
  pcb_plated_hole,
  pcb_keepout,
  pcb_port,
  pcb_text,
  pcb_trace,
  pcb_via,
  pcb_smtpad,
  pcb_solder_paste,
  pcb_board,
  pcb_group,
  pcb_trace_hint,
  pcb_silkscreen_line,
  pcb_silkscreen_path,
  pcb_silkscreen_text,
  pcb_silkscreen_rect,
  pcb_silkscreen_circle,
  pcb_silkscreen_oval,
  pcb_trace_error,
  pcb_placement_error,
  pcb_port_not_matched_error,
  pcb_fabrication_note_path,
  pcb_fabrication_note_text,
  pcb_autorouting_error,
  pcb_footprint_overlap_error,
  pcb_breakout_point,
  pcb_cutout,
  pcb_ground_plane,
  pcb_ground_plane_region,
  pcb_thermal_spoke,
  schematic_box,
  schematic_text,
  schematic_line,
  schematic_component,
  schematic_port,
  schematic_trace,
  schematic_path,
  schematic_error,
  schematic_layout_error,
  schematic_net_label,
  schematic_debug_object,
  schematic_voltage_probe,
  schematic_manual_edit_conflict_warning,
  schematic_group,
  schematic_table,
  schematic_table_cell,
  cad_component,
  simulation_voltage_source
]);
var any_soup_element = any_circuit_element;
expectTypesMatch(true);
expectStringUnionsMatch(true);
export {
  all_layers,
  any_circuit_element,
  any_soup_element,
  any_source_component,
  battery_capacity,
  cad_component,
  capacitance,
  current,
  distance,
  frequency,
  getZodPrefixedIdWithDefault,
  inductance,
  layer_ref,
  layer_string,
  length,
  ninePointAnchor,
  pcb_autorouting_error,
  pcb_board,
  pcb_breakout_point,
  pcb_component,
  pcb_cutout,
  pcb_cutout_circle,
  pcb_cutout_polygon,
  pcb_cutout_rect,
  pcb_fabrication_note_path,
  pcb_fabrication_note_text,
  pcb_footprint_overlap_error,
  pcb_ground_plane,
  pcb_ground_plane_region,
  pcb_group,
  pcb_hole,
  pcb_hole_circle_or_square_shape,
  pcb_hole_oval_shape,
  pcb_keepout,
  pcb_manual_edit_conflict_warning,
  pcb_missing_footprint_error,
  pcb_placement_error,
  pcb_plated_hole,
  pcb_port,
  pcb_port_not_matched_error,
  pcb_route_hint,
  pcb_route_hints,
  pcb_silkscreen_circle,
  pcb_silkscreen_line,
  pcb_silkscreen_oval,
  pcb_silkscreen_path,
  pcb_silkscreen_rect,
  pcb_silkscreen_text,
  pcb_smtpad,
  pcb_smtpad_pill,
  pcb_solder_paste,
  pcb_text,
  pcb_thermal_spoke,
  pcb_trace,
  pcb_trace_error,
  pcb_trace_hint,
  pcb_trace_route_point,
  pcb_trace_route_point_via,
  pcb_trace_route_point_wire,
  pcb_via,
  point,
  point3,
  port_arrangement,
  position,
  position3,
  resistance,
  rotation,
  route_hint_point,
  schematic_box,
  schematic_component,
  schematic_component_port_arrangement_by_sides,
  schematic_component_port_arrangement_by_size,
  schematic_debug_line,
  schematic_debug_object,
  schematic_debug_object_base,
  schematic_debug_point,
  schematic_debug_rect,
  schematic_error,
  schematic_group,
  schematic_layout_error,
  schematic_line,
  schematic_manual_edit_conflict_warning,
  schematic_net_label,
  schematic_path,
  schematic_pin_styles,
  schematic_port,
  schematic_table,
  schematic_table_cell,
  schematic_text,
  schematic_trace,
  schematic_voltage_probe,
  simulation_voltage_source,
  size,
  source_component_base,
  source_failed_to_create_component_error,
  source_group,
  source_missing_property_error,
  source_net,
  source_pcb_ground_plane,
  source_port,
  source_project_metadata,
  source_simple_battery,
  source_simple_capacitor,
  source_simple_chip,
  source_simple_crystal,
  source_simple_diode,
  source_simple_ground,
  source_simple_inductor,
  source_simple_led,
  source_simple_mosfet,
  source_simple_pin_header,
  source_simple_potentiometer,
  source_simple_power_source,
  source_simple_push_button,
  source_simple_resistor,
  source_simple_resonator,
  source_simple_switch,
  source_simple_test_point,
  source_simple_transistor,
  source_trace,
  supplier_name,
  time,
  visible_layer,
  voltage
};
//# sourceMappingURL=index.mjs.map